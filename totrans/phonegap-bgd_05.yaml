- en: Chapter 5. Using Device Storage and the Files API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用设备存储和Files API
- en: '*Your knowledge of PhoneGap is coming together well. It''s time to add some
    interaction with external data sources and with the device itself. The main goal
    of this chapter is to guide you through the offline storage capabilities of PhoneGap
    and help you understand how to interact with the Files API.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*你的PhoneGap知识正在逐步积累。现在是时候添加一些与外部数据源以及与设备本身的交互了。本章的主要目标是指导你了解PhoneGap的离线存储功能，并帮助你理解如何与Files
    API交互。*'
- en: 'In this chapter, you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将：
- en: Learn how to read and write data on the device using the `localStorage` object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`localStorage`对象在设备上读取和写入数据
- en: Learn how to handle the storage on a local database considering the specific
    platform implementation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何根据特定平台实现处理本地数据库的存储
- en: Understand database storage limitations and learn how to handle them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据库存储限制并学习如何处理它们
- en: Learn about the Files API, how it works, and how to organize your code to keep
    it clear and maintainable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Files API的工作原理，以及如何组织代码以保持其清晰和可维护性
- en: Use the Files API to explore the device filesystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Files API来探索设备文件系统
- en: Learn how to read and render data inside a file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在文件内部读取和渲染数据
- en: Learn how to load and save a file to a device's persistent storage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将文件加载和保存到设备的持久存储中
- en: Application data storage
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用数据存储
- en: Every application (desktop, web, or mobile) needs to store (and access) some
    data in order to work properly. How the data is stored depends on the kind of
    information the application will work with and on the environment in which the
    application will run. A web application, for instance, can rely mostly on server
    storage because it runs on the Internet. Most advanced web applications implement
    an offline strategy and store some data locally on the user machine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序（桌面、网页或移动）都需要存储（并访问）一些数据以正常工作。数据如何存储取决于应用程序将处理的信息类型以及应用程序将在其中运行的环境。例如，一个网页应用程序可以主要依赖服务器存储，因为它在互联网上运行。大多数高级网页应用程序实现离线策略，并在用户机器上本地存储一些数据。
- en: 'Modern web development offers several tools in order to let users interact
    with an application even when they''re not connected:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络开发提供了几个工具，以便让用户在未连接时也能与应用程序交互：
- en: The **LocalStorage** API ([http://www.w3.org/TR/webstorage/#the-localstorage-attribute](http://www.w3.org/TR/webstorage/#the-localstorage-attribute))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LocalStorage** API（[http://www.w3.org/TR/webstorage/#the-localstorage-attribute](http://www.w3.org/TR/webstorage/#the-localstorage-attribute)）'
- en: The **SessionStorage** API ([http://www.w3.org/TR/webstorage/#the-sessionstorage-attribute](http://www.w3.org/TR/webstorage/#the-sessionstorage-attribute))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SessionStorage** API（[http://www.w3.org/TR/webstorage/#the-sessionstorage-attribute](http://www.w3.org/TR/webstorage/#the-sessionstorage-attribute)）'
- en: The **ApplicationCache** interface ([http://www.w3.org/TR/2011/WD-html5-20110525/offline.html](http://www.w3.org/TR/2011/WD-html5-20110525/offline.html))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ApplicationCache**接口（[http://www.w3.org/TR/2011/WD-html5-20110525/offline.html](http://www.w3.org/TR/2011/WD-html5-20110525/offline.html)）'
- en: The **IndexedDB** API ([http://www.w3.org/TR/IndexedDB/](http://www.w3.org/TR/IndexedDB/))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IndexedDB** API（[http://www.w3.org/TR/IndexedDB/](http://www.w3.org/TR/IndexedDB/)）'
- en: All the modern mobile browsers let developers handle the online and offline
    events through the navigator object ([https://developer.mozilla.org/en/docs/Online_and_offline_events](https://developer.mozilla.org/en/docs/Online_and_offline_events)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代移动浏览器都允许开发者通过navigator对象处理在线和离线事件（[https://developer.mozilla.org/en/docs/Online_and_offline_events](https://developer.mozilla.org/en/docs/Online_and_offline_events)）。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to keep in mind that the specifications about the `OnLine` attribute
    report that this attribute is inherently unreliable because a computer can be
    connected to a network without having Internet access.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，关于`OnLine`属性的规范报告称，该属性本身是不可靠的，因为一台计算机可以连接到网络而没有互联网访问权限。
- en: 'A complete overview of the previous API, events, and interface is beyond the
    scope of this book. In the following sections, I will discuss only those that
    are most relevant for building a PhoneGap app: LocalStorage and IndexedDB.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书范围之外是对先前API、事件和界面的全面概述。在以下章节中，我将仅讨论对构建PhoneGap应用程序最相关的部分：LocalStorage和IndexedDB。
- en: Exploring the PhoneGap LocalStorage API
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索PhoneGap LocalStorage API
- en: 'There are two main web storage types: **local storage** and **session storage**.
    The LocalStorage API is part of the **WebStorage** API defined by the W3C in order
    to provide a guideline for persistent data storage of key-value pair data in web
    clients. The LocalStorage API is designed to support data that needs to be available
    between sessions. In other words, the data your app saves when using the LocalStorage
    API will be available again the next time the app runs.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两种网络存储类型：**本地存储**和**会话存储**。LocalStorage API是W3C定义的**WebStorage** API的一部分，旨在为网络客户端的键值对数据持久存储提供指导。LocalStorage
    API旨在支持需要在会话之间可用的数据。换句话说，使用LocalStorage API保存的应用程序数据将在应用程序下次运行时再次可用。
- en: 'In order to access the LocalStorage API, you have to refer the `window` object
    to its `localStorage` property. If you type the following snippet in your browser
    console, you can take a look at the methods and properties of the `localStorage`
    object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问LocalStorage API，你必须将`window`对象引用到其`localStorage`属性。如果你在浏览器控制台中输入以下代码片段，你可以查看`localStorage`对象的方法和属性：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following list summarizes the available methods and properties:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表总结了可用的方法和属性：
- en: '`key`: This returns the key name stored at a specific position; you can access
    the `localStorage` data either by key or by index'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`: 这返回存储在特定位置的键名；你可以通过键或索引访问`localStorage`数据'
- en: '`getItem`: This returns the value identified by a key'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getItem`: 这返回由键标识的值'
- en: '`setItem`: This saves the value in a specific key (that is, a string) of the
    `localStorage` object; the method needs a string as a key and a value to store
    in the specific key'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setItem`: 这将值保存到`localStorage`对象的特定键（即字符串）中；该方法需要一个字符串作为键和一个要存储在特定键中的值'
- en: '`removeItem`: This removes the item identified by a key from the `localStorage`
    object'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeItem`: 这将从`localStorage`对象中删除由键标识的项'
- en: '`clear`: This removes all of the key-value pairs from the `localStorage` object'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear`: 这将从`localStorage`对象中删除所有键值对'
- en: '`length`: This returns the total number of items stored in the `localStorage`
    object'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`: 这返回存储在`localStorage`对象中的项的总数'
- en: 'The `localStorage` object allows you to store only simple string data as key-value
    pairs. If you want to store more complex data, you have to use JSON or other string
    representations of the data you want to store. When you use a JSON formatted string
    to store the value, you will need to convert the string back to JSON when you
    want to use it. Each time the `localStorage` object is updated, `StorageEvent`
    is fired. This event cannot be cancelled and contains the following properties:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`对象允许你仅以键值对的形式存储简单的字符串数据。如果你想存储更复杂的数据，你必须使用JSON或其他数据的字符串表示形式。当你使用JSON格式的字符串来存储值时，当你想要使用它时，你需要将字符串转换回JSON。每次`localStorage`对象更新时，都会触发`StorageEvent`。此事件不能取消，并包含以下属性：'
- en: '`key`: This is a string that represents the named key that was added, removed,
    or modified in the storage'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`: 这是一个表示已添加、删除或修改的存储中的命名键的字符串'
- en: '`oldValue`: This is the previous value of the named key if it was updated or
    null if a new item was added to the `localStorage` object'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oldValue`: 如果更新了命名键，则这是该键的先前值；如果向`localStorage`对象中添加了新项，则为null'
- en: '`newValue`: This is the new value of the key or null if an item was removed'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newValue`: 这是键的新值，如果移除了项则为null'
- en: '`url`: This is the address of the HTML page that called a method that triggered
    this data change'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`: 这是调用触发此数据更改的方法的HTML页面的地址'
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A JavaScript event is cancelable if it is possible to prevent the event's default
    action.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以防止事件的默认操作，则JavaScript事件是可取消的。
- en: Keep in mind that storage events don't work for the same window or tab; they
    are fired only for other windows or tabs that use the same `localStorage` object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，存储事件不会在同一个窗口或标签页上工作；它们只为使用相同`localStorage`对象的其他窗口或标签页触发。
- en: The `localStorage` capabilities of PhoneGap allow you as a developer to write
    code as in the browser; it's the framework that handles the different platforms
    (Android, BlackBerry WebWorks OS 6.0 and higher, iOS, Windows Phone 7 and 8, and
    Tizen) on your behalf.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap的`localStorage`功能允许你作为开发者编写类似于浏览器的代码；它是为你处理不同平台（Android、BlackBerry WebWorks
    OS 6.0及以上、iOS、Windows Phone 7和8、以及Tizen）的框架。
- en: There are some drawbacks when using the `localStorage` object. As the `localStorage`
    API is synchronous, the time required to access the `localStorage` object is greater
    than the time needed to access an object in memory. Due to this, the app might
    appear less responsive. Also, as already mentioned, complex data needs to be serialized
    and de-serialized. This process might further impact the responsiveness of the
    app. You can use JavaScript **WebWorker** to avoid any performance degradation,
    but the support depends on the platform browser implementation and not on PhoneGap.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`localStorage`对象时存在一些缺点。由于`localStorage` API是同步的，访问`localStorage`对象所需的时间大于访问内存中对象所需的时间。因此，应用可能看起来响应较慢。此外，如前所述，复杂数据需要序列化和反序列化。这个过程可能会进一步影响应用的响应速度。您可以使用JavaScript
    **WebWorker**来避免任何性能下降，但支持取决于平台浏览器的实现，而不是PhoneGap。
- en: These drawbacks, however, should not prevent you from using the LocalStorage
    API because, as with most performance metrics, these performance hits really matter
    when you perform the same operation multiple times in a row. More specifically,
    the performance degradation due to the time needed to access the `localStorage`
    object happens when different tabs/windows access the same object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些缺点不应该阻止你使用LocalStorage API，因为，就像大多数性能指标一样，当你连续多次执行相同的操作时，这些性能影响真的很重要。更具体地说，由于访问`localStorage`对象所需的时间导致的性能下降发生在不同的标签页/窗口访问同一对象时。
- en: When the mobile app built on top of PhoneGap is running, it's almost impossible
    that `localStorage` is accessed at the same time by other tabs/windows (you should
    have an issue only if your app starts to use several `InAppBrowser` instances
    in `UIWebView` of the app).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当基于PhoneGap构建的移动应用运行时，几乎不可能同时由其他标签页/窗口访问`localStorage`（只有当你的应用开始使用`UIWebView`中的多个`InAppBrowser`实例时，你才应该遇到问题）。
- en: We will create a sample app now to get familiarized with using the `localStorage`
    object and all the methods supported by it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个示例应用，以便熟悉使用`localStorage`对象及其支持的所有方法。
- en: Time for action – reading and writing data on the LocalStorage
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 在LocalStorage上读取和写入数据
- en: 'Open the command-line tool and create a new PhoneGap project using the PhoneGap
    CLI you installed before. This will create a new directory called `DeviceApi`
    in your current working directory; this can be done using the following command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行工具，使用您之前安装的PhoneGap CLI创建一个新的PhoneGap项目。这将在您的当前工作目录中创建一个名为`DeviceApi`的新目录；这可以通过以下命令完成：
- en: '[PRE1]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Move to the directory you just created:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到您刚刚创建的目录：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the platforms you want to test on the device API. For this example, we
    add the Android platform:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备API上添加您想要测试的平台。例如，我们添加Android平台：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Delete all the files and subdirectories except `index.html` inside the `www`
    directory. Open the `index.html` file you will find in the `www` root folder and
    add the following HTML code snippet:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`www`目录内除`index.html`之外的所有文件和子目录。打开您在`www`根目录中找到的`index.html`文件，并添加以下HTML代码片段：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code will add four buttons, which will add new `localStorage` data, remove
    data, retrieve data, and clear all `localStorage` data. Note that each button
    has an `onclick` event referring to a function.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将添加四个按钮，这些按钮将添加新的`localStorage`数据，删除数据，检索数据和清除所有`localStorage`数据。请注意，每个按钮都有一个`onclick`事件，指向一个函数。
- en: 'Now let''s add the required JavaScript to the page. First, we will bind the
    `onDeviceReady` function to the `deviceready` event. This function is going to
    add 3 `localStorage` data when the page loads. The `setItem` method of the `localStorage`
    object is used to add a new key-value pair. This is shown here:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们向页面添加所需的JavaScript。首先，我们将`onDeviceReady`函数绑定到`deviceready`事件。当页面加载时，此函数将添加3个`localStorage`数据。使用`localStorage`对象的`setItem`方法来添加新的键值对。如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the user clicks on the **Add Canada** button, we will need to add a new
    country to the `localStorage` object. We will use the `setItem` again to add the
    new item. Once done, we will display an alert. Note that you can''t add the same
    key again to the storage, as shown here:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击**添加加拿大**按钮时，我们需要向`localStorage`对象添加一个新的国家。我们将再次使用`setItem`来添加新项。完成后，我们将显示一个警告。请注意，您不能再次添加相同的键到存储中，如下所示：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, to get a particular object from the storage, we should use the `getItem`
    method. When there is a matching key, the value is returned. If not, null is returned.
    In this example, we will get the value for the `USA` key and display it in the
    alert:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要获取存储中的特定对象，我们应该使用`getItem`方法。当存在匹配的键时，返回值。如果没有，则返回null。在这个例子中，我们将获取`USA`键的值并在alert中显示它：
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To get all items from the storage, we should loop the `localStorage` object
    and get the keys one by one as shown in the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取存储中的所有项，我们应该遍历`localStorage`对象，并逐个获取键，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `clear` method is used to clear out all the values from `localStorage`
    of the app:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clear`方法用于清除应用中`localStorage`的所有值：'
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As shown in the `removeAllData` function, we can use `window.localStorage` instead
    of `localStorage` to work with the `localStorage` object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如`removeAllData`函数所示，我们可以使用`window.localStorage`而不是`localStorage`来操作`localStorage`对象。
- en: 'The complete code for this example is provided for your reference as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的完整代码如下提供供您参考：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*What just happened?*'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You saved persistent data on the device using JavaScript that can also run in
    all major desktop browsers. Keep in mind that each platform stores this data in
    a different location and that this data may be cleared by the device. Depending
    on the platform, this data can be deleted when the app is closed or when the device
    is rebooted. For this reason, it's strongly encouraged not to use the `localStorage`
    object to store crucial information.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用JavaScript在设备上保存了持久数据，这些JavaScript也可以在所有主流桌面浏览器中运行。请注意，每个平台都会将数据存储在不同的位置，并且这些数据可能会被设备清除。根据平台的不同，这些数据可能在应用关闭或设备重启时被删除。因此，强烈建议不要使用`localStorage`对象来存储关键信息。
- en: Exploring the PhoneGap SQL storage
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索PhoneGap SQL存储
- en: The client-side storage implementation in different browsers on mobiles is pretty
    inconsistent right now. It's important to make an analysis of each browser implementation
    when working on a PhoneGap project because the app is rendered through WebView;
    on iOS, this is the Objective-C `UIWebView` class; on Android, it is `android.webkit.WebView`,
    and it differs on all other supported platforms. The web view simply exposes the
    underlying platform browser. For this reason, it's important to know which client-side
    storage option is supported by the mobile browsers of your target platform.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，移动设备上不同浏览器中的客户端存储实现相当不一致。在PhoneGap项目中工作时，对每个浏览器实现进行分析非常重要，因为应用是通过WebView渲染的；在iOS上，这是Objective-C的`UIWebView`类；在Android上，它是`android.webkit.WebView`，在其他所有支持的平台上也有所不同。WebView只是暴露了底层平台浏览器。因此，了解目标平台移动浏览器的客户端存储选项是否受支持非常重要。
- en: The following table summarizes the storage support for the mobile versions of
    the major browsers at the time of writing; the X sign indicates whether the feature
    is supported.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了在撰写本文时主要浏览器移动版本的存储支持；X标志表示该功能是否受支持。
- en: '|   | Android browser | Firefox OS | iOS Safari | IE 11 Mobile | Chrome for
    Android |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|   | Android浏览器 | Firefox OS | iOS Safari | IE 11移动版 | Chrome for Android
    |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| IndexedDB | X | X | X | X | X |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| IndexedDB | X | X | X | X | X |'
- en: '| Web SQL | X | --- | X | --- | X |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| Web SQL | X | --- | X | --- | X |'
- en: IndexedDB is a simple flat-file database with hierarchical key-value persistence
    and basic indexing. **Web SQL** is basically **SQLite** embedded in the browser.
    SQLite is a relational database contained in a small (approximately 350 KB) library
    written in C that is used by software such as **Skype** or **Photoshop Lightroom**.
    The main difference between these storage options is that IndexedDB is a NoSQL
    database that lets you work with your JavaScript objects and indexes based on
    your application needs, while Web SQL is a real, relational client-side database
    implementation. One of the advantages of using Web SQL is that you can share the
    same queries between the backend and frontend. When running some tests, you can
    see how much faster Web SQL can be.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB是一个简单的平面文件数据库，具有分层键值持久性和基本索引。**Web SQL**基本上是浏览器中嵌入的**SQLite**。SQLite是一个包含在用C编写的约350
    KB的小型库中的关系数据库，被Skype或Photoshop Lightroom等软件使用。这些存储选项之间的主要区别在于，IndexedDB是一个NoSQL数据库，允许您根据应用程序需求与JavaScript对象和索引一起工作，而Web
    SQL是一个真正的关系型客户端数据库实现。使用Web SQL的一个优点是您可以在后端和前端之间共享相同的查询。在运行一些测试时，您可以看到Web SQL可以有多快。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to run the same test on your machine, you can clone the GitHub repository
    at [https://github.com/scaljeri/indexeddb-vs-websql](https://github.com/scaljeri/indexeddb-vs-websql)
    and open the file `test.html` in your web browser.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的机器上运行相同的测试，您可以克隆位于[https://github.com/scaljeri/indexeddb-vs-websql](https://github.com/scaljeri/indexeddb-vs-websql)的GitHub仓库，并在您的网络浏览器中打开文件`test.html`。
- en: The W3C dropped support for Web SQL on November 18, 2010, making IndexedDB the
    *de facto* standard. From a developer's point of view, IndexedDB may look like
    a huge step backward but it really isn't. For years, developers have stored data
    on the client side using key-value pairs, and most of the time they use JSON to
    query the objects using **Unstructured Query Language** (**UQL**) or NoSQL. For
    these reasons, IndexedDB should be seen as the natural evolution of client-side
    storage.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: W3C于2010年11月18日停止了对Web SQL的支持，使IndexedDB成为*事实上的*标准。从开发者的角度来看，IndexedDB可能看起来是一个巨大的倒退，但实际上并非如此。多年来，开发者使用键值对在客户端存储数据，并且大多数时候他们使用**非结构化查询语言**（**UQL**）或NoSQL来查询对象。因此，IndexedDB应被视为客户端存储的自然演变。
- en: PhoneGap provides storage API based on the deprecated Web SQL database specification.
    When Web SQL is supported by the device, the app will use it. If not, the app
    will use the PhoneGap one. There will be no difference for the developer as we
    will not have to change any line of code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap提供基于已弃用的Web SQL数据库规范的存储API。当设备支持Web SQL时，应用程序将使用它。如果不支持，应用程序将使用PhoneGap的。对于开发者来说，将不会有任何区别，因为我们不需要更改任何代码行。
- en: Working with database storage in PhoneGap
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PhoneGap中处理数据库存储
- en: 'To work with a `Database` object in PhoneGap, it''s enough to use the `openDatabase`
    method shown as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在PhoneGap中使用`Database`对象，只需使用以下所示的`openDatabase`方法：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `openDatabase` method accepts the following four (self-explanatory) arguments:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`openDatabase`方法接受以下四个（自解释）参数：'
- en: The database **name**
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库**名称**
- en: The database **version**
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库**版本**
- en: The **display name** of the database
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库的**显示名称**
- en: Estimated **size** of the database
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库的**估计大小**
- en: Keep in mind that an application can query the version number of the database
    in order to understand whether an upgrade to the database schema is required.
    The `openDatabase` method returns a reference to the currently open database.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，应用程序可以查询数据库的版本号，以了解是否需要升级数据库模式。`openDatabase`方法返回当前打开数据库的引用。
- en: In the previous snippet, I allocated 2 MB of space in bytes. When allocating
    space, consider that mobile devices may have limitations on the size of the database
    they can support. For example, iOS only allows up to 5 MB for web-based applications;
    the same is true when using PhoneGap as a wrapper.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我分配了2MB的字节空间。在分配空间时，请考虑移动设备可能对其支持的数据库大小的限制。例如，iOS仅允许基于Web的应用程序使用最多5MB；当使用PhoneGap作为包装器时也是如此。
- en: 'The returned database object between the others exposes two methods that take
    from one to three arguments: `transaction()`and `readTransaction()`. The main
    difference is that the `readTransaction()` method has to be used in read-only
    mode. The arguments that can be passed to these methods are:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据库对象公开了两个方法，这些方法接受一个到三个参数：`transaction()`和`readTransaction()`。主要区别在于`readTransaction()`方法必须用于只读模式。可以传递给这些方法的参数包括：
- en: A function to execute one or more SQL statements
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个执行一个或多个SQL语句的函数
- en: A function to handle an exception raised by the app when opening the database
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个处理在打开数据库时由应用程序抛出的异常的函数
- en: A function to handle the successful opening of the database
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个处理数据库成功打开的函数
- en: Note that the `transaction()` and `readTransaction()` asynchronous methods are
    the only methods in the PhoneGap framework that want the failure handler function
    before the success one. Also, the success handler is the only one that doesn't
    receive any argument; the other handlers receive a `SQLTransaction` object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`transaction()`和`readTransaction()`异步方法是PhoneGap框架中唯一需要在成功处理函数之前想要失败处理函数的方法。此外，成功处理函数是唯一不接收任何参数的；其他处理函数接收一个`SQLTransaction`对象。
- en: The `SQLTransaction` object exposes the `executeSql` method. Using this method,
    it's possible to run several SQL statements and pass some parameters to the statements
    to handle successful SQL query execution and SQL errors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLTransaction`对象公开了`executeSql`方法。使用此方法，可以运行多个SQL语句，并将一些参数传递给语句以处理成功的SQL查询执行和SQL错误。'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use several tokens in order to pass parameters to a SQL statement. For
    a complete overview of the available tokens, refer to the online documentation
    at [http://www.sqlite.org/lang_expr.html](http://www.sqlite.org/lang_expr.html).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多个标记来将参数传递给 SQL 语句。有关可用标记的完整概述，请参阅在线文档中的[http://www.sqlite.org/lang_expr.html](http://www.sqlite.org/lang_expr.html)。
- en: 'The success handler receives two arguments: the first one is a reference to
    the transaction itself and the second one is a `SQLResultSet` object that contains
    the information, and optionally the results, of the executed query.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 成功处理程序接收两个参数：第一个是事务本身的引用，第二个是包含执行查询的信息和可选结果的 `SQLResultSet` 对象。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `insertId` property of the `SQLResultSet` object returns an `Exception:
    DOMException` value when performing a `SELECT` statement. You can safely ignore
    it because it doesn''t affect the app.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '当执行 `SELECT` 语句时，`SQLResultSet` 对象的 `insertId` 属性返回一个 `Exception: DOMException`
    值。你可以安全地忽略它，因为它不会影响应用程序。'
- en: Time for action – populating a local database
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践时间 - 填充本地数据库
- en: In order to reinforce what you just learned, you will create a new local database,
    add a table to it, and write and read some data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固你刚刚学到的知识，你将创建一个新的本地数据库，向其中添加一个表，并写入和读取一些数据。
- en: 'Return to the project you created for the previous example or create a new
    project. Clean out the content of the `index.html` file, and add the following
    button markup to it. This button will be used to query the data back from the
    database:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到之前示例中创建的项目，或者创建一个新的项目。清空 `index.html` 文件的内容，并添加以下按钮标记到其中。此按钮将用于从数据库中查询数据：
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a JavaScript tag and the `deviceready` event listener:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 JavaScript 标签和 `deviceready` 事件监听器：
- en: '[PRE13]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the body of the `onDeviceReady` function, we will create a new database
    called `EMP` with version number of `1.0`, named `Employee Details,` with an estimated
    size of 2 MB:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onDeviceReady` 函数的主体中，我们将创建一个名为 `EMP` 的新数据库，版本号为 `1.0`，命名为 `Employee Details`，估计大小为
    2 MB：
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the database is created using the `openDatabase` method, we populate the
    database. We have to create a transaction for every operation we need to perform
    and so we provide the `populateDB` method as an argument for the transaction:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `openDatabase` 方法创建数据库后，我们将填充数据库。我们必须为需要执行的每个操作创建一个事务，因此我们将 `populateDB`
    方法作为事务的参数提供：
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `executeSql` method can take any standard SQL statement and execute it.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`executeSql` 方法可以接受任何标准 SQL 语句并执行它。'
- en: 'We will now create the `queryEmployees` function, which is bound to the button
    `onclick` event. This function is going to open the database and create a transaction
    to query the database:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建 `queryEmployees` 函数，该函数绑定到按钮的 `onclick` 事件。此函数将打开数据库并创建一个事务以查询数据库：
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `queryData` function provided as an argument to the transaction executes
    the SQL query. This takes the transaction argument `tx` and the result set is
    passed to the `onSelectSuccess` function:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为事务参数提供的 `queryData` 函数执行 SQL 查询。这需要事务参数 `tx`，并将结果集传递给 `onSelectSuccess` 函数：
- en: '[PRE17]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `onSelectSuccess` function has the transaction and result set as an argument
    and does the actual parsing job:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onSelectSuccess` 函数将事务和结果集作为参数，并执行实际的解析工作：'
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The complete code of this example is provided for your quick reference. You
    can also verify the database records in your browser developer tools:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的完整代码提供给你快速参考。你还可以在浏览器开发者工具中验证数据库记录：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*What just happened?*'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You created a local database in order to store and recover information relevant
    for your app and its users. The database will be automatically removed when the
    app is uninstalled.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个本地数据库，用于存储和恢复与你的应用程序及其用户相关的信息。当应用程序被卸载时，数据库将自动删除。
- en: Database limitations
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库限制
- en: There are some limitations to be aware of when using the WebSQL implementation
    of PhoneGap (refer to the SQLite documentation for a complete overview at [http://www.sqlite.org/limits.html](http://www.sqlite.org/limits.html)).
    These limitations are not related to the framework itself but are due to the web
    view implementation of each target platform.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 PhoneGap 的 WebSQL 实现时，有一些限制需要注意（有关完整概述，请参阅 SQLite 文档中的[http://www.sqlite.org/limits.html](http://www.sqlite.org/limits.html)）。这些限制与框架本身无关，而是由于每个目标平台的
    web 视图实现造成的。
- en: The limit you can easily hit when working on an app is the size limit of the
    database file. For example, on WebKit, it varies depending on the operating system
    from 5 MB to 25 MB. Another limitation you can find is that, since iOS 5.1, both
    `localStorage` and Web SQL databases have been moved to the `~/Library/Caches`
    folder from the `~/Library/WebKit` folder. Actually, this change means that the
    information stored is not backed up anymore and can be arbitrarily deleted by
    the operating system when more space is needed (for more information about iOS
    data management, refer to the Apple Developer guide at [https://developer.apple.com/technologies/ios/data-management.html](https://developer.apple.com/technologies/ios/data-management.html)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，您很容易遇到的限制是数据库文件的大小限制。例如，在WebKit中，它取决于操作系统，从5 MB到25 MB不等。另一个您可能会遇到的限制是，自iOS
    5.1以来，`localStorage`和Web SQL数据库已从`~/Library/WebKit`文件夹移动到`~/Library/Caches`文件夹。实际上，这个变化意味着存储的信息不再备份，并且当需要更多空间时，操作系统可以随意删除（有关iOS数据管理的更多信息，请参阅Apple开发者指南[https://developer.apple.com/technologies/ios/data-management.html](https://developer.apple.com/technologies/ios/data-management.html)）。
- en: In order to avoid the issues described, you can use the Sqlite plugin available
    on GitHub for Android and iOS ([https://github.com/litehelpers/Cordova-sqlite-storage](https://github.com/litehelpers/Cordova-sqlite-storage)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免描述中的问题，您可以使用GitHub上可用的Sqlite插件，适用于Android和iOS ([https://github.com/litehelpers/Cordova-sqlite-storage](https://github.com/litehelpers/Cordova-sqlite-storage))。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will learn more about PhoneGap plugins throughout this book; for now, it
    suffices to know that a plugin is typically a combination of HML/CSS/JavaScript
    and native code used in order to extend the PhoneGap capabilities.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本书中了解更多关于PhoneGap插件的内容；目前，您只需要知道插件通常是HML/CSS/JavaScript和本地代码的组合，用于扩展PhoneGap的功能。
- en: The main advantages you get when using this plugin are that you can keep the
    SQLite database in a user data location that is known and can be reconfigured,
    there are no more size limits, and the database can be encrypted using **SQLcipher**
    (for a complete reference, refer to the online documentation at [http://sqlcipher.net/documentation/](http://sqlcipher.net/documentation/)).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此插件时，您获得的主要优势是您可以保持SQLite数据库在已知并可重新配置的用户数据位置，没有更多的大小限制，并且可以使用**SQLcipher**对数据库进行加密（有关完整参考，请参阅在线文档[http://sqlcipher.net/documentation/](http://sqlcipher.net/documentation/)）。
- en: 'From a developer''s point of view, there is no change in the API except the
    prefix; it means that instead of opening a database accessing the `window` object
    like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，API没有变化，只是前缀有所不同；这意味着您不需要像这样通过`window`对象打开数据库：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You have to refer to the plugin like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须像这样引用插件：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Understanding the Files API
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解文件API
- en: The PhoneGap Files API is an implementation of two different W3C APIs, the Directories
    and System API and the File API (you can find the complete specifications on the
    W3C website at [http://www.w3.org/TR/file-system-api/](http://www.w3.org/TR/file-system-api/)
    and [http://www.w3.org/TR/file-upload](http://www.w3.org/TR/file-upload).) The
    PhoneGap Files API is not a complete implementation of the W3C specification;
    the missing piece is the synchronous filesystem interface implementation. Asynchronous
    JavaScript APIs are a bit more complex to use because you have to work with multiple
    nested functions but this should not be a big issue; in fact, it's something web
    developers are all too familiar with.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap文件API是两个不同W3C API的实现，即目录和系统API以及文件API（您可以在W3C网站上找到完整的规范[http://www.w3.org/TR/file-system-api/](http://www.w3.org/TR/file-system-api/)和[http://www.w3.org/TR/file-upload](http://www.w3.org/TR/file-upload)）。PhoneGap文件API并不是W3C规范的完整实现；缺失的部分是同步文件系统接口的实现。异步JavaScript
    API使用起来稍微复杂一些，因为您必须与多个嵌套函数一起工作，但这不应成为大问题；实际上，这是所有网络开发者都非常熟悉的事情。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between asynchronous and synchronous JavaScript execution
    is that in the first case, you can run several processes simultaneously and avoid
    "freezing" the user interface. With the introduction of web workers in JavaScript,
    it's possible to avoid this issue but this is totally beyond the scope for this
    book; you can find more information about web workers on the Mozilla website at
    [https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers](https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 异步与同步JavaScript执行的主要区别在于，在前者的情况下，你可以同时运行多个进程，从而避免用户界面“冻结”。随着JavaScript中Web Workers的引入，可以避免这个问题，但这完全超出了本书的范围；你可以在Mozilla网站上找到更多关于Web
    Workers的信息，网址为[https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers](https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers)。
- en: 'In order to access the device filesystem, you can use the `requestFileSystem`
    method of the `LocalFileSystem` object; all the methods of this object are defined
    in the `window` object. The method accepts the following four arguments:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问设备文件系统，你可以使用`LocalFileSystem`对象的`requestFileSystem`方法；此对象的所有方法都在`window`对象中定义。该方法接受以下四个参数：
- en: The type of storage (temporary or persistent)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储类型（临时或持久）
- en: The amount of space in bytes to be allocated on the device storage
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备存储上要分配的字节数量
- en: The success handler
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功处理程序
- en: The error handler
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理程序
- en: 'When you want to access the device filesystem, the resulting code looks as
    shown the following snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想访问设备文件系统时，生成的代码看起来如下所示：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the `storage` argument, you need to specify one of the following two pseudo
    constants defined in the `LocalFileSystem` object:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`storage`参数，你需要指定`LocalFileSystem`对象中定义的以下两个伪常量之一：
- en: '`LocalFileSystem.PERSISTENT`: This indicates that the storage cannot be removed
    by the user agent without the app''s or user''s permission.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalFileSystem.PERSISTENT`：这表示存储无法在没有应用或用户许可的情况下被用户代理删除。'
- en: '`LocalFileSystem.TEMPORARY`: This indicates that the files stored in the requested
    space can be deleted by the user agent or by the system without the app''s or
    user''s permission'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalFileSystem.TEMPORARY`：这表示存储在请求空间中的文件可以被用户代理或系统删除，无需应用或用户的许可'
- en: The size of the requested sandbox storage is expressed in bytes; for example,
    in order to make the code more readable, you can use the syntax (4 x 1024 x 1024)
    to allocate 4 KB instead of the bytes number 4,194,304.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的沙盒存储大小以字节为单位表示；例如，为了使代码更易读，可以使用（4 x 1024 x 1024）的语法来分配4 KB，而不是使用4,194,304字节的数字。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The device hard disk is not completely open to the app's view. A limited portion
    of the hard disk is dedicated to a single app alone; this is the app **sandbox**.
    The idea behind the app sandbox is that each app can only access its own sandbox
    and some higher-level directories owned by the operating system. The structure
    of the high-level directories varies depending on the operating system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 设备硬盘并未完全对应用程序视图开放。硬盘的一部分仅被分配给单个应用；这就是应用的**沙盒**。应用沙盒背后的理念是每个应用只能访问其自己的沙盒以及操作系统拥有的某些高级目录。高级目录的结构取决于操作系统。
- en: 'The `onSuccess` handler receives a `FileSystem` object as an argument. The
    two properties defined for this object are `name` and `root`. Accessing the `name`
    property of the object makes it possible to read the name of the filesystem; accessing
    the `root` property allows you to get a reference to the `root` directory of the
    app sandbox. This is shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSuccess`处理程序接收一个`FileSystem`对象作为参数。为此对象定义的两个属性是`name`和`root`。访问对象的`name`属性可以读取文件系统的名称；访问`root`属性允许你获取应用沙盒的`root`目录的引用。这在此处显示：'
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `onError` handler receives a `FileError` object as an argument; this object
    represents different errors using several pseudo constants defined in the object
    itself, as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`onError`处理程序接收一个`FileError`对象作为参数；此对象使用对象本身定义的几个伪常量来表示不同的错误，如下所示：'
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the location of the file or directory is known, you can use the `resolveLocalFileSystemURI`
    method of the `LocalFileSystem` object to access it. This method accepts the following
    three arguments:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已知文件或目录的位置，可以使用`LocalFileSystem`对象的`resolveLocalFileSystemURI`方法来访问它。此方法接受以下三个参数：
- en: The URI of the file or directory
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件或目录的URI
- en: The success handler (`onSuccess`)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功处理程序（`onSuccess`）
- en: The error handler (`onError`)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理程序（`onError`）
- en: 'If you want to access, for instance, the external storage of an Android device,
    you can use the following syntax:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问例如Android设备的外部存储，可以使用以下语法：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `onSuccess` function receives as argument a `DirectoryEntry` or `FileEntry`
    object depending on the kind of path entered (that is, a directory or file); the
    `onError` handler receives a `FileError` object as argument.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSuccess`函数接收一个`DirectoryEntry`或`FileEntry`对象作为参数，这取决于输入路径的类型（即目录或文件）；`onError`处理程序接收一个`FileError`对象作为参数。'
- en: 'The values of the `code` property are summarized by the following pseudo constants:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`code`属性的值由以下伪常量总结：'
- en: '`FileError.NOT_FOUND_ERR` (returned value `1`): This means the file or directory
    required by the app cannot be found'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.NOT_FOUND_ERR`（返回值`1`）：这意味着应用所需的文件或目录无法找到'
- en: '`FileError.SECURITY_ERR` (returned value `2`): This means the file or directory
    is outside the app sandbox or the app does not have the rights to access it'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.SECURITY_ERR`（返回值`2`）：这意味着文件或目录位于应用沙盒之外，或者应用没有访问它的权限'
- en: '`FileError.ABORT_ERR` (returned value `3`): This is thrown when the `abort`
    method of the reader or writer is called'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.ABORT_ERR`（返回值`3`）：这是在调用读取器或写入器的`abort`方法时抛出的'
- en: '`FileError.NOT_READABLE_ERR` (returned value `4`): This means that the file
    or directory required by the app cannot be read'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.NOT_READABLE_ERR`（返回值`4`）：这意味着应用所需的文件或目录无法读取'
- en: '`FileError.ENCODING_ERR` (returned value `5`): This means a path or local URI
    used as an argument in the `resolveLocalFileSystemURI` method of the `LocalFileSystem`
    object is malformed'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.ENCODING_ERR`（返回值`5`）：这意味着在`LocalFileSystem`对象的`resolveLocalFileSystemURI`方法中用作参数的路径或本地URI格式不正确'
- en: '`FileError.NO_MODIFICATION_ALLOWED_ERR` (returned value `6`): This means the
    app attempted to write to a file or directory that cannot be modified due to the
    actual state of the filesystem'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.NO_MODIFICATION_ALLOWED_ERR`（返回值`6`）：这意味着应用尝试写入一个由于文件系统的实际状态而无法修改的文件或目录'
- en: '`FileError.INVALID_STATE_ERR` (returned value `7`): This means the app accesses
    a file that is used by another process'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.INVALID_STATE_ERR`（返回值`7`）：这意味着应用访问了一个由另一个进程使用的文件'
- en: '`FileError.SYNTAX_ERR` (returned value `8`): This is self-explanatory; this
    occurs due to the syntax error'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.SYNTAX_ERR`（返回值`8`）：这是不言自明的；这是由于语法错误导致的'
- en: '`FileError.INVALID_MODIFICATION_ERR` (returned value `9`): This means the modification
    requested by the app is invalid; an example of such an error is moving a directory
    into its own child'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.INVALID_MODIFICATION_ERR`（返回值`9`）：这意味着应用请求的修改无效；此类错误的例子是将目录移动到其自身的子目录中'
- en: '`FileError.QUOTA_EXCEEDED_ERR` (returned value `10`): This means the app requested
    a storage amount greater than the allowed storage quota'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.QUOTA_EXCEEDED_ERR`（返回值`10`）：这意味着应用请求的存储量超过了允许的存储配额'
- en: '`FileError.TYPE_MISMATCH_ERR` (returned value `11`): This means the app attempted
    to access a file or directory but the entry is not of the expected type (that
    is, a directory is returned instead of a file)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.TYPE_MISMATCH_ERR`（返回值`11`）：这意味着应用尝试访问一个文件或目录，但条目不是预期的类型（即返回的是目录而不是文件）'
- en: '`FileError.PATH_EXISTS_ERR` (returned value `12`): This means the app failed
    to create a file or directory due to the existence of a file or directory with
    the same path'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileError.PATH_EXISTS_ERR`（返回值`12`）：这意味着由于存在具有相同路径的文件或目录，应用未能创建文件或目录'
- en: Reading directories and files
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取目录和文件
- en: 'Only after getting access to the filesystem is it possible to read the device
    directories, subdirectories, and content. Again, the `onSuccess` handler used
    as an argument in the `requestFileSystem` method receives a `FileSystem` object.
    Through the `root` property of this object, it''s possible to access a `DirectoryEntry`
    object and then create a `DirectoryReader` object able to read all the entries
    available in the current directory. This is shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在获得对文件系统的访问权限后，才能读取设备目录、子目录和内容。再次强调，用作`requestFileSystem`方法参数的`onSuccess`处理程序接收一个`FileSystem`对象。通过此对象的`root`属性，可以访问一个`DirectoryEntry`对象，然后创建一个能够读取当前目录中所有条目的`DirectoryReader`对象。这在此处展示：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `DirectoryReader` object exposes one method named `readEntries`. It can
    be used in order to read the entries and, due to the asynchronous nature of the
    File API, it accepts a success and a failure handler. Similar to what's happening
    for the `resolveLocalFileSystemURI` method, the success handler receives an array
    of `DirectoryEntry` or `FileEntry` objects according to the kind of item that
    is listed (that is, a directory or a file).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectoryReader` 对象公开了一个名为 `readEntries` 的方法。它可以用来读取条目，由于文件 API 的异步特性，它接受一个成功处理程序和一个失败处理程序。类似于
    `resolveLocalFileSystemURI` 方法所发生的情况，成功处理程序根据所列项目的类型（即目录或文件）接收一个 `DirectoryEntry`
    或 `FileEntry` 对象的数组。'
- en: Time for action – listing folders
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 列出文件夹
- en: 'Get ready to explore the folders of the device''s persistent storage. Use the
    following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 准备探索设备的持久存储文件夹。使用以下步骤：
- en: 'Open the command-line tool and create a new project using the Cordova CLI tool
    you installed before. This will create a new directory called `FileSystem` in
    your current working directory:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行工具，使用您之前安装的 Cordova CLI 工具创建一个新的项目。这将在一个名为 `FileSystem` 的新目录中创建一个新目录，位于您当前的工作目录中：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Move to the directory you just created:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到您刚刚创建的目录：
- en: '[PRE28]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the platforms you want to test on the device API. For this example, we
    add the Android platform:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备 API 上添加您想要测试的平台。例如，我们添加了 Android 平台：
- en: '[PRE29]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the File API plugin using the following command:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令添加 File API 插件：
- en: '[PRE30]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Go to the `www` folder, open the `index.html` file, and add a `div` element
    with the `id` value as `fileslist` inside the body of the app:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `www` 文件夹，打开 `index.html` 文件，并在应用程序的主体中添加一个具有 `id` 值为 `fileslist` 的 `div`
    元素：
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will now add a `deviceready` event listener in the JavaScript section. The
    `onDeviceReady` function has to be called once the `deviceready` event is fired:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在 JavaScript 部分添加一个 `deviceready` 事件监听器。`onDeviceReady` 函数必须在 `deviceready`
    事件触发后调用：
- en: '[PRE32]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the body of the `onDeviceReady` function, request access to the device filesystem
    specifying the success and failure handlers you will define next and request a
    persistent storage of 0 KB; you need to specify a quota only when writing to the
    device filesystem:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onDeviceReady` 函数的主体中，请求访问设备文件系统，指定您将要定义的成功和失败处理程序，并请求 0 KB 的持久存储；您只需要在写入设备文件系统时指定配额：
- en: '[PRE33]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the error handler that will notify you when the code throws an error:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义错误处理程序，当代码抛出错误时，它会通知您：
- en: '[PRE34]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the success handler and inside its body, create a new `DirectoryReader`
    object and use this object to read all the directory contents. We need to pass
    a new function `parseDirectories`, which will actually iterate through the list
    of directories. The directory entries will be passed automatically as an argument
    to this function:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义成功处理程序，并在其主体内部创建一个新的 `DirectoryReader` 对象，并使用此对象来读取所有目录内容。我们需要传递一个新的函数 `parseDirectories`，该函数将实际遍历目录列表。目录条目将自动作为参数传递给此函数：
- en: '[PRE35]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define the `parseDirectories` function and add the following snippet to it:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `parseDirectories` 函数，并将其以下片段添加到其中：
- en: '[PRE36]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We read the entries and for each entry in the list, we check whether it's a
    directory or a file. If it's a directory, we append the directory name to the
    unordered list and ignore it if it's a file. At the end, we add the generated
    unordered list (`ul`) to the `div` named `fileslist` we previously created.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们读取条目，并在列表中的每个条目上检查它是否是目录或文件。如果是目录，我们将目录名称追加到无序列表，如果是文件则忽略它。最后，我们将生成的无序列表（`ul`）添加到我们之前创建的名为
    `fileslist` 的 `div` 中。
- en: When this code runs in an actual device, it will list all the directories in
    the persistent storage.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当此代码在实际设备上运行时，它将列出持久存储中的所有目录。
- en: 'The entire source code of this example is provided as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的整个源代码如下所示：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*What just happened?*'
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The app can now read the list of directories from the device's persistent storage
    using the asynchronous Files API.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在可以使用异步的 Files API 从设备的持久存储中读取目录列表。
- en: Writing and reading a file's data
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入和读取文件数据
- en: To write data to a file, it suffices that the app gets access to the file using
    the `FileWriter` object. In order to get a `FileWriter` object, you first have
    to get access to a `DirectoryEntry` object or a `FileEntry` object using the `requestFileSystem`
    method of the `LocalFileSystem` object.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据写入文件，应用程序只需使用 `FileWriter` 对象访问文件即可。为了获取 `FileWriter` 对象，您首先必须使用 `LocalFileSystem`
    对象的 `requestFileSystem` 方法访问 `DirectoryEntry` 对象或 `FileEntry` 对象。
- en: 'Once you successfully get access to the filesystem, you can request a file
    specifying that you want to create it using the `create` flag:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功访问文件系统，你可以请求一个文件，指定你想要使用`create`标志创建它：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two flags available within the Files API that can be used as arguments
    of the `getFile` and `getDirectory` methods: `create` and `exclusive`. The `create`
    flag is used to indicate that the file or directory should be created; the `exclusive`
    flag takes effect only when the `create` flag is set to `true` and it causes the
    file or directory creation to fail if it already exists.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 文件API中有两个标志可以作为`getFile`和`getDirectory`方法的参数使用：`create`和`exclusive`。`create`标志用于指示应创建文件或目录；当`create`标志设置为`true`时，`exclusive`标志才会生效，并且如果文件或目录已存在，它会导致创建失败。
- en: 'As with the other Files API, the `getFile` method is asynchronous and requires
    a success and failure handler. Once in the success handler, it''s possible to
    create a `FileWriter` object using the `createWriter` method of the `FileEntry`
    object received as an argument. The `createWriter` method also requires the success
    and failure handlers, as shown here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Files API一样，`getFile`方法也是异步的，需要成功和失败处理程序。一旦在成功处理程序中，就可以使用接收到的`FileEntry`对象的`createWriter`方法创建一个`FileWriter`对象。`createWriter`方法也需要成功和失败处理程序，如下所示：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once again, you have two other handlers, which means only after three callback
    functions, can you write some content into the file you just created:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你有另外两个处理程序，这意味着只有在你调用了三个回调函数之后，你才能将一些内容写入你刚刚创建的文件：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can't write binary data from JavaScript in PhoneGap using a `FileWriter`
    object; this is a limitation of the framework because it passes data between the
    native and JavaScript layers as a string. One possible solution is to write a
    plugin that translates a Base64 string into binary data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在PhoneGap中使用`FileWriter`对象无法从JavaScript写入二进制数据；这是框架的限制，因为它将数据作为字符串在原生和JavaScript层之间传递。一个可能的解决方案是编写一个插件，将Base64字符串转换为二进制数据。
- en: 'When you perform the write operation, several events occur. For each such event,
    there is a corresponding property available on the `FileWriter` object:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行写入操作时，会发生几个事件。对于每个此类事件，`FileWriter`对象上都有一个相应的属性：
- en: The `onwritestart` event is called when the `FileWriter` object starts to write
    the file; it receives as an argument a `ProgressEvent` object.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`FileWriter`对象开始写入文件时，会调用`onwritestart`事件；它接收一个`ProgressEvent`对象作为参数。
- en: The `onwrite` event gets called when the `FileWriter` object has successfully
    completed the write operation; it receives as an argument a `ProgressEvent` object.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`FileWriter`对象成功完成写入操作时，会调用`onwrite`事件；它接收一个`ProgressEvent`对象作为参数。
- en: The `Onabort` event is called when the write operation has been interrupted
    by calling the `abort` method of `FileWriter`; it receives as an argument a `ProgressEvent`
    object.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过调用`FileWriter`的`abort`方法中断写入操作时，会调用`Onabort`事件；它接收一个`ProgressEvent`对象作为参数。
- en: The `Onerror` event is called when the write operation fails; it receives as
    an argument the `ProgressEvent` object. In order to understand why the error occurs,
    you can access the `FileError` object stored in the `target.error` property of
    the `event` object.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当写入操作失败时，会调用`Onerror`事件；它接收一个`ProgressEvent`对象作为参数。为了了解错误发生的原因，你可以访问存储在`event`对象的`target.error`属性中的`FileError`对象。
- en: The `FileWriter` object contains other properties as well. For a complete overview,
    refer to the online guide available at [http://docs.phonegap.com/en/edge/cordova_file_file.md.html#FileWriter](http://docs.phonegap.com/en/edge/cordova_file_file.md.html#FileWriter).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileWriter`对象还包含其他属性。要获取完整概述，请参考可在[http://docs.phonegap.com/en/edge/cordova_file_file.md.html#FileWriter](http://docs.phonegap.com/en/edge/cordova_file_file.md.html#FileWriter)找到的在线指南。'
- en: 'Using the `ProgressEvent` object, you can access the bytes loaded, the total
    bytes, and the nature of the event (that is, `abort`, `writeend`, and so on) using
    the `loaded`, `total`, and `type` properties:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ProgressEvent`对象，你可以通过`loaded`、`total`和`type`属性访问已加载的字节、总字节和事件的性质（即`abort`、`writeend`等）：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you try to call sequentially the `write` method of the `FileWriter` object,
    only the first string will be added to the file. You have to wait until the `writeend`
    event is fired in order to write other data to the file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试依次调用`FileWriter`对象的`write`方法，只有第一个字符串将被添加到文件中。你必须等待`writeend`事件触发，才能将其他数据写入文件。
- en: 'When you want to read a file, you can use a `FileReader` object. This object
    works similarly to the `FileWriter` object. When using it, several events occur:
    the `onabort` and `onerror` properties of the `FileWriter` object act similarly
    to the `FileReader` ones. The properties related only to the `FileReader` object
    are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想读取文件时，你可以使用一个`FileReader`对象。此对象与`FileWriter`对象类似。使用它时，会发生几个事件：`FileWriter`对象的`onabort`和`onerror`属性与`FileReader`的类似。仅与`FileReader`对象相关的属性如下：
- en: '`onloadstart`: The function stored in this property is called when the `FileReader`
    object starts to read a file; it receives a `ProgressEvent` object as an argument.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onloadstart`: 当`FileReader`对象开始读取文件时，存储在此属性的函数将被调用；它接收一个`ProgressEvent`对象作为参数。'
- en: '`onload`: The function stored in this property is called when the read operation
    has successfully completed; it receives a `ProgressEvent` object as an argument.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onload`: 当读取操作成功完成后，存储在此属性的函数将被调用；它接收一个`ProgressEvent`对象作为参数。'
- en: '`onloadend`: The function stored in this property is called when the read operation
    is completed (regardless of whether it succeeded or failed); it receives a `ProgressEvent`
    object as argument.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onloadend`: 当读取操作完成时（无论成功与否），存储在此属性的函数将被调用；它接收一个`ProgressEvent`对象作为参数。'
- en: 'The `FileReader` object allows you to read the file data in the following four
    different ways:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileReader`对象允许你以以下四种不同的方式读取文件数据：'
- en: '`readAsDataURL`: This reads the file and returns the content of the specified
    file as a Base64-encoded data URL'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readAsDataURL`: 这将读取文件，并将指定文件的 内容作为Base64编码的数据URL返回'
- en: '`readAsText`: This reads a file and returns the data as a string encoded by
    default in UTF-8'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readAsText`: 这将读取文件，并以默认UTF-8编码将数据作为字符串返回'
- en: '`readAsBinaryString`: This reads the file as binary and returns the data as
    a binary string'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readAsBinaryString`: 这将以二进制形式读取文件，并将数据作为二进制字符串返回'
- en: '`readAsArrayBuffer`: This reads the file and returns the data as `ArrayBuffer`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readAsArrayBuffer`: 这将读取文件，并将数据作为`ArrayBuffer`返回'
- en: In order to put into practice what you just learned, you will now see how to
    parse the device's persistent storage, recover the first available image, and
    render it in the app's web view.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将你刚刚学到的知识付诸实践，现在你将看到如何解析设备的持久存储，恢复第一个可用的图像，并在app的web视图中渲染它。
- en: 'Here is the complete source code for writing a text file to the phone storage:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将文本文件写入手机存储的完整源代码：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Time for action – reading and rendering an image
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 读取和渲染图像
- en: 'Get ready to render the first available image in the device''s storage into
    the PhoneGap default app template. Refer to the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 准备将设备存储中第一个可用的图像渲染到PhoneGap默认app模板中。请参考以下步骤：
- en: Open the command-line tool and create a new PhoneGap project named `ReadingFile`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行工具，创建一个名为`ReadingFile`的新PhoneGap项目。
- en: 'Add the File API plugin using the following command line:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令行添加File API插件：
- en: '[PRE43]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Go to the `www` folder, open the `index.html` file, and add an `img` tag with
    the `id` value as `firstImage` inside the main `div` of the app following the
    `deviceready` one:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`www`文件夹，打开`index.html`文件，在紧随`deviceready`之后的app主`div`内添加一个`img`标签，其`id`值为`firstImage`：
- en: '[PRE44]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Go to the `www/js` folder, open the `index.js` file, and define a new function
    named `requestFileSystem`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`www/js`文件夹，打开`index.js`文件，并定义一个名为`requestFileSystem`的新函数：
- en: '[PRE45]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define the error handler in order to get the code of every possible error:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义错误处理程序以获取每个可能错误的代码：
- en: '[PRE46]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the body of the `requestFileSystem` function, access the device filesystem
    using the `requestFileSystem` function of the `LocalFileSystem` object, define
    the success and failure handlers, and inside the success handler, access the `root`
    filesystem:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`requestFileSystem`函数的主体中，使用`LocalFileSystem`对象的`requestFileSystem`函数访问设备文件系统，定义成功和失败处理程序，并在成功处理程序中访问`root`文件系统：
- en: '[PRE47]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You are requesting a `0` bytes quota because you are just reading a file; you
    need to specify a quota only when writing to the device filesystem.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你请求的是`0`字节的配额，因为你只是读取文件；你只需要在写入设备文件系统时指定配额。
- en: 'Once you get access to the `root` filesystem, you can create a `DirectoryReader`
    object in the success handler and start to explore the root filesystem using the
    `readEntries` asynchronous method of the object:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你获得对`root`文件系统的访问权限，你可以在成功处理程序中创建一个`DirectoryReader`对象，并开始使用该对象的`readEntries`异步方法探索根文件系统：
- en: '[PRE48]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In order to determine whether a file is an image in the `for` loop, you can
    first check the `isFile` property of the entry and then use a simple regular expression;
    when the condition is met, you access the file using the `getFile` method of the
    root `DirectoryEntry` object specifying the success and the failure handlers:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在`for`循环中确定一个文件是否是图片，你可以首先检查条目的`isFile`属性，然后使用一个简单的正则表达式；当条件满足时，使用根`DirectoryEntry`对象的`getFile`方法访问文件，指定成功和失败处理程序：
- en: '[PRE49]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the JavaScript section, define the `onGetFile` function, and in its body,
    access the real file by using the `file` method of the `FileEntry` object. Once
    you get access to the file, specify the `onload` and `onerror` handlers and read
    the file using the `readAsDataURL` method in order to assign the result as the
    `src` attribute of the `img` tag, as shown here:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript部分，定义`onGetFile`函数，并在其主体中，通过使用`FileEntry`对象的`file`方法访问实际的文件。一旦你获得了对文件的访问权限，指定`onload`和`onerror`处理程序，并使用`readAsDataURL`方法读取文件，以便将结果分配给`img`标签的`src`属性，如下所示：
- en: '[PRE50]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now test the project on a real device. Take a look at the following complete
    code provided for a quick review:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在一个真实设备上测试项目。查看以下提供的完整代码，以便快速审查：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*What just happened?*'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You explored the filesystem of the device and rendered the first image found
    as a Base64 data stream in your app. Now that you are somewhat familiar with the
    File API, it's time to learn how to transfer files from and to a device.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经探索了设备的文件系统，并在你的应用中将找到的第一张图片作为Base64数据流渲染。现在，你对File API有了一定的了解，是时候学习如何从设备传输文件到设备了。
- en: Transferring files
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件传输
- en: 'The PhoneGap File API also includes the `FileTransfer` object. As the name
    suggests, this object allows you to develop apps to download and upload files
    over the Internet. The methods exposed by the `FileTransfer` object are self-explanatory:
    `upload`, `download`, and `abort`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap File API还包括`FileTransfer`对象。正如其名所示，这个对象允许你开发应用程序，通过互联网下载和上传文件。`FileTransfer`对象公开的方法是自解释的：`upload`、`download`和`abort`。
- en: 'The `upload` method accepts several arguments: the path of the file on the
    device, a URL to receive the file, the success and failure handlers, an option
    object, and a Boolean to force the method to accept all the security certificates.
    (I omitted the Boolean in the next snippet because using it for production is
    not recommended; an app should accept only the protocols it was designed to deal
    with.)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload`方法接受多个参数：设备上文件的路径、接收文件的URL、成功和失败处理程序、选项对象以及一个布尔值，用于强制方法接受所有安全证书。（我在下一个片段中省略了布尔值，因为在生产中使用它不被推荐；应用程序应该只接受它被设计用来处理的协议。）'
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `options` argument is a `FileUploadOptions` object. This object allows
    you to provide additional information using the following properties:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`参数是一个`FileUploadOptions`对象。该对象允许你使用以下属性提供额外的信息：'
- en: '`chunkedMode`: This is a Boolean value that indicates whether the streaming
    of the HTPP request is performed without internal buffering. (For a more detailed
    description of the chunked transfer encoding, you can refer to [http://en.wikipedia.org/wiki/Chunked_transfer_encoding](http://en.wikipedia.org/wiki/Chunked_transfer_encoding)).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chunkedMode`: 这是一个布尔值，表示是否在不进行内部缓冲的情况下执行HTTP请求的流式传输。（对于分块传输编码的更详细描述，你可以参考[http://en.wikipedia.org/wiki/Chunked_transfer_encoding](http://en.wikipedia.org/wiki/Chunked_transfer_encoding)）。'
- en: '`fileKey`: This is a string that indicates the name of the form element under
    which the file is uploaded to the server; the default value is `file`.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileKey`: 这是一个字符串，表示文件上传到服务器上表单元素下的名称；默认值是`file`。'
- en: '`fileName`: This is a string that represents the name of the uploaded file;
    the default value is `image.jpg.`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileName`: 这是一个表示上传文件名称的字符串；默认值是`image.jpg`。'
- en: '`mimeType`: This is a string representing the MIME type of the file that will
    be uploaded; by default, the value is `image/jpg`.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mimeType`: 这是一个表示将要上传的文件MIME类型的字符串；默认值是`image/jpg`。'
- en: '`params`: This is an object that represents key-value pairs to be included
    in the HTTP request header.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`: 这是一个对象，表示要包含在HTTP请求头中的键值对。'
- en: 'The `onSuccess` handler receives a `FileEntry` object as an argument so that
    you can immediately access information, such as the filename and full path on
    the device. The `onError` handler receives a `FileTransferError` object; the properties
    of this object are as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSuccess`处理程序接收一个`FileEntry`对象作为参数，这样你就可以立即访问信息，例如设备上的文件名和完整路径。`onError`处理程序接收一个`FileTransferError`对象；该对象的属性如下：'
- en: '`code`: This is a number that represents one of the four possible error codes
    stored in the `FileTransferError` pseudo constants (that is, `FILE_NOT_FOUND_ERR`,
    `INVALID_URL_ERR`, `CONNECTION_ERR`, and `ABORT_ERR`).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code`：这是一个表示存储在`FileTransferError`伪常量中的四个可能错误代码之一的数字（即`FILE_NOT_FOUND_ERR`、`INVALID_URL_ERR`、`CONNECTION_ERR`和`ABORT_ERR`）。'
- en: '`source`: This is a string representing the URI to the source file.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：这是一个表示源文件URI的字符串。'
- en: '`target`: This is a string representing the URI to the target file.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：这是一个表示目标文件URI的字符串。'
- en: '`http_status`: This is a number representing the HTTP status code.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http_status`：这是一个表示HTTP状态码的数字。'
- en: 'The `download` method works in a similar way; the only difference is that the
    first two arguments are switched and are: the URL to download the file and the
    system URI (that is, the path) in order to store it on the device, respectively;
    also, the `options` parameter accepts only HTTP headers. This is shown here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`download`方法的工作方式类似；唯一的区别是前两个参数被交换，分别是：下载文件的URL和系统URI（即路径），以便在设备上存储；此外，`options`参数只接受HTTP头。如下所示：'
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `abort` method can be used to stop a download or an upload operation, once
    the `onError` handler is called, and the value of the `code` property of its argument
    is the pseudo constant, `FileTransferError.ABORT_ERR`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`abort`方法停止下载或上传操作，一旦调用`onError`处理程序，其参数的`code`属性值是伪常量，`FileTransferError.ABORT_ERR`。
- en: Note
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Also, when you set up the wrong path of the file to download, the `code` property
    of the `FileTransferError` object is equal to `FileTransferError.FILE_NOT_FOUND_ERR`
    (that is, the value `1`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你设置错误的文件下载路径时，`FileTransferError`对象的`code`属性等于`FileTransferError.FILE_NOT_FOUND_ERR`（即值`1`）。
- en: Only the `onprogress` property is defined in the `FileTransfer` object. As the
    name suggests, this property is used to store a function that is called whenever
    a chunk of data is transferred from or to the device.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FileTransfer`对象中只定义了`onprogress`属性。正如其名所示，此属性用于存储一个函数，每当从或向设备传输数据块时都会调用该函数。
- en: Next, in order to put into practice what you just learned, you will download
    a file, show the download progress, and add a link to the file once the download
    is completed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了将你刚刚学到的知识付诸实践，你将下载一个文件，显示下载进度，并在下载完成后添加一个文件链接。
- en: Time for action – downloading and saving a file
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 下载并保存文件
- en: 'Get ready to download a file and display in the PhoneGap default app template
    a progress bar and a link to the file. Refer to the following steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 准备下载一个文件并在PhoneGap默认应用模板中显示进度条和文件链接。请参考以下步骤：
- en: 'Open the command-line tool and create a new PhoneGap project named `DownloadFile`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行工具并创建一个名为`DownloadFile`的新PhoneGap项目：
- en: '[PRE54]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Change the directory to `DownloadFile`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`DownloadFile`目录：
- en: '[PRE55]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the File and FileTransfer API plugins using the following commands:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令添加File和FileTransfer API插件：
- en: '[PRE56]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Go to the `www` folder, open the `index.html` file, and add a `progress` tag
    with the `id` value as `progress` inside the main `div` element of the app below
    the `deviceready` tag; assign `1` to the `value` attribute and `100` to the `max`
    attribute:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`www`文件夹，打开`index.html`文件，在`deviceready`标签下面的应用主`div`元素内添加一个带有`progress`值的`progress`标签；将`value`属性赋值为`1`，将`max`属性赋值为`100`：
- en: '[PRE57]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define a new JavaScript function named `onDeviceReady` and add it to the `deviceready`
    listener:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`onDeviceReady`的新JavaScript函数，并将其添加到`deviceready`监听器中：
- en: '[PRE58]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the `onFileSystemSuccess` method, once you get access to the filesystem,
    create a new `FileTransfer` object and call the `download` method specifying the
    remote URL, the system root URI, and the success and failure handlers:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`onFileSystemSuccess`方法，一旦你获得对文件系统的访问权限，创建一个新的`FileTransfer`对象，并调用`download`方法，指定远程URL、系统根URI以及成功和失败处理程序：
- en: '[PRE59]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define the success and failure event callback functions. For any error, we
    will alert the entire `error` object as a JSON string, as shown here:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义成功和失败事件回调函数。对于任何错误，我们将以JSON字符串的形式将整个`error`对象警报整个系统，如下所示：
- en: '[PRE60]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now run your project on a real device. The file will be downloaded and the progress
    will be shown in the progress bar. Once it's done, you can verify the downloaded
    file in your device.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在真实设备上运行你的项目。文件将被下载，进度将在进度条中显示。一旦完成，你可以在设备上验证下载的文件。
- en: 'The complete source code of this example is provided as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的完整源代码如下所示：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '*What just happened?*'
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: You initiated a file download, displayed a progress bar, and rendered a link
    to the file. You will notice a problem because most platforms don't provide a
    PDF reader inside the WebView. In short, the user will not be able to read the
    file, neither in the app nor in the external browser. In order to open a native
    app to read the file, you have to use an external plugin. You will discover in
    the next chapter how to integrate a plugin in your app and how to solve this problem.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你启动了一个文件下载，显示了一个进度条，并渲染了一个指向文件的链接。你将注意到一个问题，因为大多数平台在 WebView 中不提供 PDF 阅读器。简而言之，用户既无法在应用中也无法在外部浏览器中阅读该文件。为了打开一个原生应用来阅读文件，你必须使用一个外部插件。你将在下一章中了解到如何在你的应用中集成插件以及如何解决这个问题。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to save data on the device and how to handle
    the most common limitations. You also learned how the Files API works and looked
    at its features.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在设备上保存数据以及如何处理最常见的限制。你还学习了 Files API 的工作原理，并了解了它的功能。
- en: In the next chapter, you will learn how to use the Contact API to work with
    contacts in the device and Camera API, in order to capture an image using the
    device camera.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用 Contact API 来处理设备中的联系人以及 Camera API，以便使用设备摄像头捕捉图像。
