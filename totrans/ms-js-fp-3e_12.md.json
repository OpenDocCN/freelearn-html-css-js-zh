["```js\n// firstToUpper :: String → String\nconst firstToUpper = (s: string): string =>\n  s[0].toUpperCase() + s.substring(1).toLowerCase();\n// Math.random :: () → Number\n```", "```js\n// firstToUpper :: String → String\nconst firstToUpper = (s: string) =>\n  s[0].toUpperCase() + s.substring(1).toLowerCase();\n```", "```js\n// sum3C :: Number → Number → Number → Number\nconst sum3C = curry(\n  (a: number, b: number, c: number): number => a + b + c\n);\n// sum3 :: (Number, Number, Number) → Number\nconst sum3 = (a: number, b: number, c: number) => a + b +\n  c;\n```", "```js\n// sum3C :: Number → (Number → (Number → (Number)))\nconst sum3C = curry(\n  (a: number, b: number, c: number): number => a + b + c\n);\n```", "```js\n// map :: [a] → (a → b) → [b]\nconst map = curry(<A, B>(arr: A[], fn: (x: A) => B) =>\n  arr.map(fn)\n);\n```", "```js\n// filter :: [a] → (a → Boolean) → [a]\nconst filter = curry(<A>(arr: A[], fn: (x: A) => B) =>\n  arr.filter(fn)\n);\n```", "```js\n// reduce :: [a] → (b → a → b) → b → b\nconst reduce = curry(\n  <A, B>(arr: A[], fn: (a: B, v: A) => B, acc: B) =>\n    arr.reduce(fn, acc)\n);\n```", "```js\n// String.repeat :: String ⇝ Number → String\n```", "```js\n// getWeekAndDay :: String → (Number × String)\nconst getWeekAndDay = (\n  yyyy_mm_dd: string\n): [number, string] => {\n  let weekNumber: number;\n  let dayOfWeekName: string;\n  .\n  .\n  .\n  return [weekNumber, dayOfWeekName];\n};\n```", "```js\n// getPerson :: Number → { id:Number × name:String }\nconst getPerson = (\n  personId: number\n): { id: number; name: string } => {\n  .\n  .\n  .\n  return { id: personId, name: personName };\n};\n```", "```js\n// getField :: String → Object → a | undefined\nconst getField =\n  <A>(attr: string) =>\n  (obj: { [key: string]: A }) =>\n    obj[attr];\n```", "```js\n// Sortable :: Number | String | Boolean\n```", "```js\n// compareFunction :: (Sortable, Sortable) → Number\n```", "```js\n// compareFunction :: Sortable a ⇒ (a, a) → Number\n```", "```js\n// compareFunction ::\n//    ((Number, Number) |\n//    (String, String)  |\n//    (Boolean, Boolean)) → Number\n```", "```js\n// unary :: ((b, ...) → a) → (b → a)\n```", "```js\n// parseInt :: (String, Number?) → Number\n```", "```js\n// Boolean.map :: Boolean ⇝ (Boolean → a) → Boolean\nBoolean.prototype.map = function (\n  this: boolean,\n  fn: (x: boolean) => any\n) {\n  return !!fn(this);\n};\n```", "```js\n// Number.map :: Number ⇝ (Number → a) → Number\nNumber.prototype.map = function (\n  this: number,\n  fn: (x: number) => number\n) {\n  return Number(fn(this));\n};\n// String.map :: String ⇝ (String → a) → String\nString.prototype.map = function (\n  this: string,\n  fn: (x: string) => string\n) {\n  return String(fn(this));\n};\n```", "```js\n// Function.map :: (a → b) ⇝ (b → c) → (a → c)\nFunction.prototype.map = function <A, B, C>(\n  this: (x: A) => B,\n  fn: (y: B) => C\n): (x: A) => C {\n  return (x: A) => fn(this(x));\n};\n```", "```js\nconst plus1 = (x) => x + 1;\nconst times10 = (y) => 10 * y;\nconsole.log(plus1.map(by10)(3));\n// 40: first add 1 to 3, then multiply by 10\n```", "```js\n// container.ts\nclass Container<A> {\n  protected x: A;\n  constructor(x: A) {\n    this.x = x;\n  }\n  map(fn: (_: A) => any) {\n    return fn(this.x);\n  }\n}\n```", "```js\n// continued...\nclass Container<A> {\n  protected x: A;\n  constructor(x: A) {\n    this.x = x;\n  }\n  static of<B>(x: B): Container<B> {\n    return new Container(x);\n  }\n  map(fn: (_: A) => any) {\n    return fn(this.x);\n  }\n  toString() {\n    return `${this.constructor.name}(${this.x})`;\n  }\n  valueOf() {\n    return this.x;\n  }\n}\n```", "```js\n// functor.ts\nclass Functor<A> extends Container<A> {\n  static of<B>(x: B) {\n    return new Functor(x);\n  }\n  map<B>(fn: (_: A) => B): Functor<B> {\n    return Functor.of(fn(this.x));\n  }\n}\n```", "```js\n// of :: Functor f ⇒ a → f a\n// Functor.toString :: Functor f ⇒ f a ⇝ String\n// Functor.valueOf :: Functor f ⇒ f a ⇝ a\n// Functor.map :: Functor f ⇒ f a ⇝ (a → b) → f b\n```", "```js\n// maybe.ts\nclass Nothing extends Maybe<any> {\n  constructor() {\n    super(null);\n  }\n  isNothing() {\n    return true;\n  }\n  toString() {\n    return \"Nothing()\";\n  }\n  map(_fn: FN) {\n    return this;\n  }\n}\n```", "```js\n// continued...\nclass Just<A> extends Maybe<A> {\n  static of<B>(x: B): Maybe<B> {\n    if (x === null || x === undefined) {\n      throw new Error(\"Just should have a value\");\n    } else {\n      return new Just(x);\n    }\n  }\n  isNothing() {\n    return false;\n  }\n  map<B>(fn: (_: A) => B): Just<B> {\n    return new Just(fn(this.x));\n  }\n}\n```", "```js\n// continued...\nabstract class Maybe<A> extends Functor<A> {\n  static of<B>(x: B): Maybe<B> {\n    return x === null || x === undefined\n      ? new Nothing()\n      : new Just(x);\n  }\n  isNothing() {\n    /* abstract */\n  }\n  map<B>(fn: (_: A) => B): Maybe<B> {\n    return Maybe.of(fn(this.x));\n  }\n}\n```", "```js\nconst plus1 = x => x + 1;\nMaybe.of(2209).map(plus1).map(plus1).toString();\n// \"Just(2211)\"\nMaybe.of(null).map(plus1).map(plus1).toString();\n// \"Nothing()\"\n```", "```js\nimport request from \"superagent\";\nconst getAlerts = (\n  lat: number,\n  long: number,\n  callback: FN\n) => {\n  const SERVER = \"https://api.darksky.net/forecast\";\n  const UNITS = \"units=si\";\n  const EXCLUSIONS = \"exclude=minutely,hourly,daily,flags\";\n  const API_KEY = \"you.need.to.get.your.own.api.key\";\n  request\n    .get(\n      `${SERVER}/${API_\n        KEY}/${lat},${long}?${UNITS}&${EXCLUSIONS}`\n    )\n    .end(function (err, res) {\n      if (err) {\n        callback({});\n      } else {\n        callback(JSON.parse(res.text));\n      }\n    });\n};\n```", "```js\n{\n  latitude: 29.76,\n  longitude: -95.37,\n  timezone: \"America/Chicago\",\n  offset: -5,\n  currently: {\n    time: 1503660334,\n    summary: \"Drizzle\",\n    icon: \"rain\",\n    temperature: 24.97,\n    .\n    .\n    .\n    uvIndex: 0,\n  },\n  alerts: [\n    {\n      title: \"Tropical Storm Warning\",\n      regions: [\"Harris\"],\n      severity: \"warning\",\n      time: 1503653400,\n      expires: 1503682200,\n      description:\n        \"TROPICAL STORM WARNING REMAINS IN EFFECT... WIND -        LATEST LOCAL FORECAST: Below tropical storm force wind         ... CURRENT THREAT TO LIFE AND PROPERTY: Moderate ...        Locations could realize roofs peeled off buildings,        chimneys toppled, mobile homes pushed off foundations         or overturned ...\",\n      uri: \"https://alerts.weather.gov/cap/wwacapget.php?x=      TX125862DD4F88.TropicalStormWarning.125862DE8808TX.      HGXTCVHGX.73ee697556fc6f3af7649812391a38b3\",\n    },\n    .\n    .\n    .\n    {\n      title: \"Hurricane Local Statement\",\n      regions: [\"Austin\", ... , \"Wharton\"],\n      severity: \"advisory\",\n      time: 1503748800,\n      expires: 1503683100,\n      description:\n        \"This product covers Southeast Texas **HURRICANE         HARVEY DANGEROUSLY APPROACHING THE TEXAS COAST** ...        The next local statement will be issued by the National         Weather Service in Houston/Galveston TX around 1030 AM         CDT, or sooner if conditions warrant.\\n\",\n      uri: \"https://alerts.weather.gov/...\",\n    },\n  ],\n};\n```", "```js\nimport os from \"os\";\nconst produceAlertsTable = (weatherObj: typeof resp) =>\n  Maybe.of(weatherObj)\n    .map((w: typeof resp) => w.alerts)\n    .map((a) =>\n      a.map(\n        (x) =>\n          `<tr><td>${x.title}</td>` +\n          `<td>${x.description.substr(0,\n            500)}...</td></tr>`\n      )\n    )\n    .map((a) => a.join(os.EOL))\n    .map((s) => `<table>${s}</table>`);\ngetAlerts(29.76, -95.37, (x) =>\n  console.log(produceAlertsTable(x).valueOf())\n);\n```", "```js\n<table><tr><td>Tropical Storm Warning</td><td>...TROPICAL STORM WARNING REMAINS IN EFFECT... ...STORM SURGE WATCH REMAINS IN EFFECT... * WIND -\nLATEST LOCAL FORECAST: Below tropical storm force wind - Peak Wind Forecast: 25-35 mph with gusts to 45 mph - CURRENT THREAT TO LIFE AND PROPERTY: Moderate - The wind threat has remained nearly steady from the previous assessment. - Emergency plans should include a reasonable threat for strong tropical storm force wind of 58 to 73 mph. - To be safe, earnestly prepare for the potential of significant...</td></tr>\n<tr><td>Flash Flood Watch</td><td>...FLASH FLOOD WATCH REMAINS IN EFFECT\nTHROUGH MONDAY MORNING... The Flash Flood Watch continues for * Portions of Southeast Texas...including the following counties...Austin...Brazoria...Brazos...Burleson...\nChambers...Colorado...Fort Bend...Galveston...Grimes...\nHarris...Jackson...Liberty...Matagorda...Montgomery...Waller... Washington and Wharton. * Through Monday morning * Rainfall from Harvey will cause devastating and life threatening flooding as a prolonged heavy rain and flash flood thre...</td></tr>\n<tr><td>Hurricane Local Statement</td><td>This product covers Southeast\nTexas **PREPARATIONS FOR HARVEY SHOULD BE RUSHED TO COMPLETION THIS MORNING** NEW INFORMATION --------------- * CHANGES TO WATCHES AND\nWARNINGS: - None * CURRENT WATCHES AND WARNINGS: - A Tropical Storm Warning and Storm Surge Watch are in effect for Chambers and Harris - A Tropical Storm Warning is in effect for Austin, Colorado, Fort Bend, Liberty, Waller, and Wharton - A Storm Surge Warning and Hurricane Warning are in effect for Jackson and Matagorda - A Storm S...</td></tr></table>\n```", "```js\n// continued...\nclass Maybe<A> extends Functor<A> {\n  .\n  .\n  .\n  orElse(v: any) {\n    /* abstract */\n  }\n}\nclass Nothing extends Functor<any> {\n  .\n  .\n  .\n  orElse(v: any) {\n    return v;\n  }\n}\nclass Just<A> extends Functor<A> {\n  .\n  .\n  .\n  orElse(v: any) {\n    return this.x;\n  }\n}\n```", "```js\ngetAlerts(-34.9, -54.6, (x) =>\n  console.log(\n    produceAlertsTable(x).orElse(\n      \"<span>No alerts today.</span>\"\n    )\n  )\n);\n```", "```js\nconst author = {\n  user: \"fkereki\",\n  name: {\n    first: \"Federico\",\n    middle: \"\",\n    last: \"Kereki\",\n  },\n  books: [\n    { name: \"Google Web Toolkit\", year: 2010 },\n    { name: \"Functional Programming\", year: 2017 },\n    { name: \"Javascript Cookbook\", year: 2018 },\n  ],\n};\n```", "```js\nconst pUser = prismProp(\"user\");\nconsole.log(review(pUser, author).toString());\n/*\nJust(\"fkereki\")\n*/\n```", "```js\nconst pPseudonym = prismProp(\"pseudonym\"); console.log(review(pPseudonym, author).toString());\n/*\nNothing()\n*/\n```", "```js\nclass ConstantP<V> {\n  private value: Maybe<V>;\n  map: FN;\n  constructor(v: V) {\n    this.value = Maybe.of(v);\n    this.map = () => this;\n  }\n}\n```", "```js\nconst preview = curry(\n  (prismAttr, obj) =>\n    prismAttr((x) => new ConstantP(x))(obj).value\n);\n```", "```js\nconst fakeSearchForSomething = (key: number) => {\n  if (key % 2 === 0) {\n    return { key, some: \"whatever\", other: \"more data\" };\n  } else {\n    throw new Error(\"Not found\");\n  }\n};\n```", "```js\nconst findSomething = (key: number) => {\n  try {\n    const something = fakeSearchForSomething(key);\n    return Maybe.of(something);\n  } catch (e) {\n    return Maybe.of(null);\n  }\n};\n```", "```js\nconst getSome = (something: any) =>\n  Maybe.of(something.map((x: any) => x.some));\nconst getSomeFromSomething = (key: number) =>\n  getSome(findSomething(key));\n```", "```js\nconst xxx = getSomeFromSomething(2222).valueOf().valueOf();\n// \"whatever\"\nconst yyy = getSomeFromSomething(9999).valueOf().valueOf();\n// undefined\n```", "```js\n// monad.ts\nclass Monad<A> extends Functor<A> {\n  static of<B>(x: B): Monad<B> {\n    return new Monad(x);\n  }\n  map<B>(fn: (_: A) => B): Monad<B> {\n    return new Monad(fn(this.x));\n  }\n  unwrap(): any {\n    const myValue = this.x;\n    return myValue instanceof Monad\n      ? myValue.unwrap()\n      : this;\n  }\n}\n```", "```js\nconst getSomeFromSomething = key => getSome(findSomething(key)).unwrap();\n```", "```js\n// continued...\nclass Monad<A> extends Functor<A> {\n  .\n  .\n  .\n  chain<B>(fn: (_: A) => B) {\n    return this.map(fn).unwrap();\n  }\n}\n```", "```js\nconst add = (x: number) => (y: number) => x + y;\n// or curry((x,y) => x+y)\nconst something = Monad.of(2).map(add);\n```", "```js\n// continued...\nclass Monad<A> extends Functor<A> {\n  .\n  .\n  .\n  ap<B, C extends FN>(this: Monad<C>, m: Monad<B>) {\n    return m.map(this.x);\n  }\n}\n```", "```js\nconst monad5 = something.ap(Monad.of(3));\nconsole.log(monad5.toString())\n// Monad(5)\n```", "```js\n// either.ts\nclass Left extends Monad<any> {\n  isLeft() {\n    return true;\n  }\n  map(_: any) {\n    return this;\n  }\n}\n```", "```js\n// continued...\nclass Right<A> extends Monad<A> {\n  isLeft() {\n    return false;\n  }\n  map(fn: (_: A) => any) {\n    return Either.of(null, fn(this.x));\n  }\n}\n```", "```js\n// continued...\nabstract class Either<A, B> extends Monad<A | B> {\n  static of<C, D>(left: C, right?: D): Left | Right<D> {\n    return right === undefined || right === null\n      ? new Left(left)\n      : new Right(right);\n  }\n  isLeft() {\n    /* */\n  }\n}\n```", "```js\nconst getAlerts2 = (lat, long, callback) => {\n  const SERVER = \"https://api.darksky.net/forecast\";\n  const UNITS = \"units=si\";\n  const EXCLUSIONS = \"exclude=minutely,hourly,daily,flags\";\n  const API_KEY = \"you.have.to.get.your.own.key\";\n  request\n    .get(\n      `${SERVER}/${API_KEY}/${lat},${long}` +\n        `?${UNITS}&${EXCLUSIONS}`\n    )\n    .end((err, res) =>\n      callback(\n        err\n          ? Either.of(\"AJAX FAILURE\", null)\n          : Either.of(null, JSON.parse(res.text))\n      )\n    );\n};\n```", "```js\nconst produceAlertsTable2 = (weatherObj: typeof resp) => {\n  return weatherObj\n    .chain((obj: typeof resp) => {\n      const alerts = getField(\"alerts\")(obj);\n      return alerts\n        ? Either.of(null, alerts)\n        : Either.of(\"NO ALERTS\", null);\n    })\n    .chain((a) =>\n      a.map(\n        (x) =>\n          `<tr><td>${x.title}</td>` +\n          `<td>${x.description.substr(0,\n            500)}...</td></tr>`\n      )\n    )\n    .chain((a) => a.join(os.EOL))\n    .chain((s) => `<table>${s}</table>`);\n};\n```", "```js\n// Houston, TX, US:\ngetAlerts2(29.76, -95.37, (x) =>\n  console.log(produceAlertsTable2(x).toString())\n);\n// Right(\"...a table with alerts: lots of HTML code...\");\n// Montevideo, UY\ngetAlerts2(-34.9, -54.6, (x) =>\n  console.log(produceAlertsTable2(x).toString())\n);\n// Left(\"NO ALERTS\");\n// A point with wrong coordinates\ngetAlerts2(444, 555, (x) =>\n  console.log(produceAlertsTable2(x).toString())\n);\n// Left(\"AJAX FAILURE\");\n```", "```js\n// try.ts\nclass Try<A> extends Either<A, string> {\n  // @ts-expect-error Call to super() not needed\n  constructor(fn: () => A, msg?: string) {\n    try {\n      return Either.of(null, fn()) as Either<A, string>;\n    } catch (e: any) {\n      return Either.of(msg || e.message, null) as Either<\n        string,\n        string\n      >;\n    }\n  }\n}\n```", "```js\nconst getField = attr => obj => obj[attr];\n```", "```js\nconst getField2 = (attr: string) => (obj: OBJ | null) =>\n  new Try(() => obj![attr], \"NULL OBJECT\");\n```", "```js\nconst x = getField2(\"somefield\")(null);\nconsole.log(x.isLeft()); // true\nconsole.log(x.toString()); // Left(NULL OBJECT)\n```", "```js\nPromise.prototype.ap = function (promise2) {\n  return this.then((x) => promise2.map(x));\n};\n```", "```js\ndata Tree a = Nil | Node a (Tree a) (Tree a)\n```", "```js\nempty :: Tree a -> Bool empty Nil = True\nempty (Node root left right) = False\n```", "```js\ncontains :: (Ord a) => (Tree a)\n     -> a -> Bool contains Nil _ = False\ncontains (Node root left right) x\n| x == root = True\n| x   < root = contains left x\n| x   > root = contains right x\n```", "```js\n// functionAsTree.ts\nconst myTree: TREE = NewTree(\n  22,\n  NewTree(\n    9,\n    NewTree(4, EmptyTree(), EmptyTree()),\n    NewTree(12, EmptyTree(), EmptyTree())\n  ),\n  NewTree(\n    60,\n    NewTree(56, EmptyTree(), EmptyTree()),\n    EmptyTree()\n  )\n);\n```", "```js\n// continued...\ntype TREE<A> = (\n  _nonEmptyTree: (\n    _x: A,\n    _left: TREE<A>,\n    _right: TREE<A>\n  ) => any,\n  _emptyTree: () => any\n) => any;\n```", "```js\nconst myRoot = myTree(\n  (value) => value,\n  () => null\n);\n```", "```js\n// continued...\nconst treeCount = <A>(tree: TREE<A>): number =>\n  tree(\n    (value, left, right) =>\n      1 + treeCount(left) + treeCount(right),\n    () => 0\n  );\nconsole.log(treeCount(myTree));\n```", "```js\n// continued...\nconst NewTree =\n  <A>(value: A, left: TREE<A>, right: TREE<A>): TREE<A> =>\n  (destructure, _) =>\n    destructure(value, left, right);\nconst EmptyTree =\n  <A>(): TREE<A> =>\n  (_, destructure) =>\n    destructure();\n```", "```js\n// continued...\nconst treeRoot = <A>(tree: TREE<A>): A | null =>\n  tree(\n    (value, _left, _right) => value,\n    () => null\n  );\n```", "```js\n// continued...\nconst treeIsEmpty = <A>(tree: TREE<A>): boolean =>\n  tree(\n    () => false,\n    () => true\n  );\n```", "```js\n// continued...\nconst treeToObject = <A>(tree: TREE<A>): OBJ =>\n  tree(\n    (value, left, right) => {\n      const leftBranch = treeToObject(left);\n      const rightBranch = treeToObject(right);\n      const result: OBJ = { value };\n      if (leftBranch) {\n        result.left = leftBranch;\n      }\n      if (rightBranch) {\n        result.right = rightBranch;\n      }\n      return result;\n    },\n    () => null\n  );\n```", "```js\nconsole.log(treeToObject(myTree));\n/*\n{\n  value: 22,\n  left: {\n    value: 9,\n    left: {\n      value: 4,\n    },\n    right: { value: 12 },\n  },\n  right: {\n    value: 60,\n    left: {\n      value: 56,\n    },\n  },\n};\n*/\n```", "```js\n// continued...\nconst treeSearch = <A>(\n  findValue: A,\n  tree: TREE<A>\n): boolean =>\n  tree(\n    (value, left, right) =>\n      findValue === value\n        ? true\n        : findValue < value\n        ? treeSearch(findValue, left)\n        : treeSearch(findValue, right),\n    () => false\n  );\n```", "```js\n// continued...\nconst treeInsert = <A>(\n  newValue: A,\n  tree: TREE<A>\n): TREE<A> =>\n  tree(\n    (value, left, right) =>\n      newValue <= value\n        ? NewTree(value, treeInsert(newValue, left), right)\n        : NewTree(value, left, treeInsert(newValue,\n          right)),\n    () => NewTree(newValue, EmptyTree(), EmptyTree())\n  );\n```", "```js\nlet myTree = EmptyTree();\nmyTree = treeInsert(22, myTree);\nmyTree = treeInsert(9, myTree);\nmyTree = treeInsert(60, myTree);\nmyTree = treeInsert(12, myTree);\nmyTree = treeInsert(4, myTree);\nmyTree = treeInsert(56, myTree);\n// The resulting tree is:\n{\n  value: 22,\n  left: {\n    value: 9,\n    left: { value: 4 },\n    right: { value: 12 },\n  },\n  right: { value: 60, left: { value: 56 } },\n}\n```", "```js\n// continued...\ntype NODE<K, D> = { key: K; data: D };\nconst compare = <K, D>(\n  obj1: NODE<K, D>,\n  obj2: NODE<K, D>\n) =>\n  obj1.key === obj2.key ? 0 : obj1.key < obj2.key ? -1 : 1;\n```", "```js\n// continued...\nconst treeInsert2 = <K, D>(\n  comparator: typeof compare<K, D>,\n  newValue: NODE<K, D>,\n  tree: TREE<NODE<K, D>>\n): TREE<NODE<K, D>> =>\n  tree(\n    (value, left, right) =>\n      comparator(newValue, value) === 0\n        ? NewTree(newValue, left, right)\n        : comparator(newValue, value) < 0\n        ? NewTree(\n            value,\n            treeInsert2(comparator, newValue, left),\n            right\n          )\n        : NewTree(\n            value,\n            left,\n            treeInsert2(comparator, newValue, right)\n          ),\n    () => NewTree(newValue, EmptyTree(), EmptyTree())\n  );\n```", "```js\n// continued...\nconst treeMap = <A, B>(\n  fn: (_x: A) => B,\n  tree: TREE<A>\n): TREE<B> =>\n  tree(\n    (value, left, right) =>\n      NewTree(\n        fn(value),\n        treeMap(fn, left),\n        treeMap(fn, right)\n      ),\n    () => EmptyTree()\n  );\n```", "```js\ntype LIST<A> = (\n  _nonEmptyList: (_head: A, _tail: LIST<A>) => any,\n  _emptyList: LIST<A>\n) => any;\nconst NewList =\n  <A>(head: A, tail: LIST<A>): LIST<A> =>\n  (f: FN, _g: FN) =>\n    f(head, tail);\nconst EmptyList =\n  <A>(): LIST<A> =>\n  (f: FN, g: FN) =>\n    g();\n```", "```js\nconst listHead = <A>(list: LIST<A>): A | null =>\n  list(\n    (head: A, _tail: LIST<A>) => head,\n    () => null\n  );\nconst listTail = <A>(list: LIST): LIST<A> | null =>\n  list(\n    (head: A, tail: LIST<A>) => tail,\n    () => null\n  );\nconst listIsEmpty = <A>(list: LIST<A>): boolean =>\n  list(\n    (_head: A, _tail: LIST<A>) => false,\n    () => true\n  );\nconst listSize = <A>(list: LIST<A>): number =>\n  list(\n    (head: A, tail: LIST<A>) => 1 + listSize(tail),\n    () => 0\n  );\n```", "```js\n// question_01_typescript_please.ts\nfunction fact(n: number): number {\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * fact(n - 1);\n  }\n}\nconst fact2 = (n: number): number => {\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * fact2(n - 1);\n  }\n};\nconst fact3 = (n: number): number =>\n  n === 0 ? 1 : n * fact3(n - 1);\n```", "```js\n// continued...\nfunction sum3(a: number, b: number, c: number): number {\n  return a + b + c;\n}\nconst x: [number, number, number] = [1, 2, 3];\nconst y = sum3(...x); // equivalent to sum3(1,2,3)\nconst f = [1, 2, 3];\nconst g = [4, ...f, 5];\nconst h = [...f, ...g];\nconst p = { some: 3, data: 5 };\nconst q = { more: 8, ...p };\nconst numbers = [2, 2, 9, 6, 0, 1, 2, 4, 5, 6];\nconst minA = Math.min(...numbers); // 0\nconst maxArray = (arr: number[]) => Math.max(...arr);\nconst maxA = maxArray(numbers); // 9\n```", "```js\n// question_01_classes_as_1st_class.ts\nconst makeSaluteClass = (term: string) =>\n  class {\n    x: string;\n    constructor(x: string) {\n      this.x = x;\n    }\n    salute(y: string) {\n      console.log(`${this.x} says \"${term}\" to ${y}`);\n    }\n  };\nconst Spanish = makeSaluteClass(\"HOLA\");\nnew Spanish(\"ALFA\").salute(\"BETA\");\n// ALFA says \"HOLA\" to BETA\nnew (makeSaluteClass(\"HELLO\"))(\"GAMMA\").salute(\"DELTA\");\n// GAMMA says \"HELLO\" to DELTA\nconst fullSalute = (\n  c: ReturnType<typeof makeSaluteClass>,\n  x: string,\n  y: string\n) => new c(x).salute(y);\nconst French = makeSaluteClass(\"BON JOUR\");\nfullSalute(French, \"EPSILON\", \"ZETA\");\n// EPSILON says \"BON JOUR\" to ZETA\n```", "```js\n// question_01_climbing_factorial.ts\nconst factUp = (n: number, f = 1): number =>\n  n <= f ? f : f * factUp(n, f + 1);\n```", "```js\n// continued...\nconst factUp2 = (n: number): number => {\n  const factAux = (f: number): number =>\n    n <= f ? f : f * factAux(f + 1);\n  return factAux(1);\n};\n```", "```js\n// continued...\nconst factUp3 = (n: number): number => {\n  const factAux = (f = 1): number =>\n    n <= f ? f : f * factAux(f + 1);\n  return factAux();\n};\n```", "```js\n// question_01_factorial_errors.ts\nconst carefulFact = (n: number): number | never => {\n  if (\n    typeof n === \"number\" &&\n    n >= 0 &&\n    n === Math.floor(n)\n  ) {\n    const innerFact = (n: number): number =>\n      n === 0 ? 1 : n * innerFact(n - 1);\n    return innerFact(n);\n  } else {\n    throw new Error(\"Wrong parameter for carefulFact2\");\n  }\n};\n```", "```js\n// question_01_factorial_testing.test.ts\nimport { carefulFact } from \"./question_1.4\";\ndescribe(\"Correct cases\", () => {\n  test(\"5! = 120\", () => expect(carefulFact(5)).toBe(120));\n  test(\"0! = 1\", () => expect(carefulFact(0)).toBe(1));\n});\ndescribe(\"Errors\", () => {\n  test(\"Should reject 3.1\", () => {\n    expect(() => carefulFact(3.1)).toThrow();\n  });\n  test(\"Should reject -4\", () => {\n    expect(() => carefulFact(-3)).toThrow();\n  });\n  test(\"Should reject -5.2\", () => {\n    expect(() => carefulFact(-3)).toThrow();\n  });\n});\n```", "```js\n// question_01_code_squeezing.ts\nconst shorterCounter = () => {\n  let count = 0;\n  return () => ++count;\n};\n```", "```js\n// question_02_no_extra_variables.ts\nconst once = <FNType extends (...args: any[]) => any>(\n  fn: FNType | null\n) =>\n  ((...args: Parameters<FNType>) => {\n    fn && fn(...args);\n    fn = null;\n  }) as FNType;\n```", "```js\n// question_02_alternating_fns.ts\nconst alternator = <FNType extends (...args: any[]) =>\n  any>(\n  fn1: FNType,\n  fn2: FNType\n) =>\n  ((...args: Parameters<FNType>) => {\n    [fn1, fn2] = [fn2, fn1];\n    return fn2(...args);\n  }) as FNType;\n```", "```js\n// question_02_alternating_fns.test.ts\nimport { alternator } from \"./question_2.2\";\ndescribe(\"alternator\", () => {\n  it(\"calls the two functions alternatively\", () => {\n    const funcA = jest.fn().mockReturnValue(\"A\");\n    const funcB = jest.fn().mockReturnValue(\"B\");\n    const testFn = jest.fn(alternator(funcA, funcB));\n    expect(testFn()).toEqual(\"A\");\n    expect(testFn()).toEqual(\"B\");\n    expect(testFn()).toEqual(\"A\");\n    expect(testFn()).toEqual(\"B\");\n    expect(testFn()).toEqual(\"A\");\n    expect(testFn()).toEqual(\"B\");\n    expect(testFn).toHaveBeenCalledTimes(6);\n    expect(funcA).toHaveBeenCalledTimes(3);\n    expect(funcB).toHaveBeenCalledTimes(3);\n  });\n});\n```", "```js\n// question_02_everything_has_a_limit.ts\nconst thisManyTimes =\n  <FNType extends (...args: any[]) => any>(\n    fn: FNType,\n    limit: number\n  ) =>\n  (...args: Parameters<FNType>) => {\n    if (limit > 0) {\n      limit--;\n      return fn(...args);\n    }\n  };\n```", "```js\n// question_02_everything_has_a_limit.test.ts\nimport { thisManyTimes } from \"./question_2.3\";\ndescribe(\"thisManyTimes\", () => {\n  it(\"calls the function 2 times, nothing after\", () => {\n    const fn = jest.fn();\n    const testFn = jest.fn(thisManyTimes(fn, 2));\n    testFn(); // works\n    testFn(); // works\n    testFn(); // nothing now\n    testFn(); // nothing now\n    testFn(); // nothing now\n    testFn(); // nothing now\n    expect(testFn).toHaveBeenCalledTimes(6);\n    expect(fn).toHaveBeenCalledTimes(2);\n  });\n});\n```", "```js\n// question_02_allow_for_crashing.ts\nconst onceIfSuccess = <\n  FNType extends (...args: any[]) => any\n>(\n  fn: FNType\n) => {\n  let done = false;\n  return ((...args: Parameters<FNType>) => {\n    if (!done) {\n      done = true;\n      try {\n        return fn(...args);\n      } catch {\n        done = false;\n      }\n    }\n  }) as FNType;\n};\n```", "```js\n// question_02_allow_for_crashing.manual.ts\nimport { onceIfSuccess } from \"./question_2.4\";\nlet count = 0;\nconst crashTwice = () => {\n  count++;\n  if (count <= 2) {\n    console.log(\"CRASH!\");\n    throw new Error(\"Crashing...\");\n  } else {\n    console.log(\"OK NOW\");\n  }\n};\nconst doIt = onceIfSuccess(crashTwice);\ndoIt(); // CRASH!\ndoIt(); // CRASH!\ndoIt(); // OK NOW\ndoIt(); // nothing\ndoIt(); // nothing\ndoIt(); // nothing\n```", "```js\n// question_02_allow_for_crashing.test.ts\nimport { onceIfSuccess } from \"./question_2.4\";\ndescribe(\"onceIfSuccess\", () => {\n  it(\"should run once if no errors\", () => {\n    const myFn = jest.fn();\n    const onceFn = jest.fn(onceIfSuccess(myFn));\n    onceFn();\n    onceFn();\n    onceFn();\n    expect(onceFn).toHaveBeenCalledTimes(3);\n    expect(myFn).toHaveBeenCalledTimes(1);\n  });\n  it(\"should run again if an exception\", () => {\n    const myFn = jest.fn()\n      .mockImplementationOnce(() => {\n        throw new Error(\"ERROR 1\");\n      })\n      .mockImplementationOnce(() => {\n        throw new Error(\"ERROR 2\");\n      })\n      .mockReturnValue(22);\n    const onceFn = jest.fn(onceIfSuccess(myFn));\n    expect(onceFn).toThrow();\n    expect(onceFn).toThrow();\n    expect(onceFn()).toBe(22); // OK now (returns 22)\n    onceFn(); // nothing\n    onceFn(); // nothing\n    onceFn(); // nothing\n    expect(onceFn).toHaveBeenCalledTimes(6);\n    expect(myFn).toHaveBeenCalledTimes(3);\n  });\n});\n```", "```js\n// question_02_say_no_to_arrows.ts\nfunction once<FNType extends (...args: any[]) => any>(\n  fn: FNType\n): FNType {\n  let done = false;\n  return function (...args: Parameters<FNType>) {\n    if (!done) {\n      done = true;\n      return fn(...args);\n    }\n  } as FNType;\n}\n```", "```js\nconst simpleAction = (t:string) => ({\n  type: t;\n});\n```", "```js\nuseArguments(22,9,60);\nUncaught ReferenceError: arguments is not defined\n```", "```js\ntype State = Record<string, unknown>;\n```", "```js\ntype ActionType = \"CREATE\" | \"DELETE\" | \"UPDATE\";\n```", "```js\ntype Action = {\n  type: ActionType;\n  payload: Record<string, unknown> | null;\n};\n```", "```js\nfunction doAction(state: State, action: Action) {\n  const newState: State = {};\n  switch (action?.type) {\n    …\n  }\n}\n```", "```js\nconst dispatchTable: Record<\n  ActionType,\n  (state: State, action: Action) => State\n> = {\n  CREATE: (state, action) => {\n    // update state, generating newState,\n    // depending on the action data\n    // to create a new item\n    const NewState: State = {\n      /* updated State */\n    };\n    return NewState;\n  },\n  …\n};\n```", "```js\nfunction doAction2(state: State, action: Action) {\n  return dispatchTable[action.type]\n    ? dispatchTable[action.type](state, action)\n    : state;\n}\n```", "```js\nconst oldSet = window.store.set.bind(window.store);\n```", "```js\n// question_03_bindless_binding.ts\nfunction bind(context) {\n  var that = this;\n  return function() {\n    return that.apply(context, arguments);\n  };\n}\n```", "```js\nFunction.prototype.bind =\n  Function.prototype.bind || function(context) {\n  var that = this;\n  return function() {\n    return that.apply(context, arguments);\n  };\n};\n```", "```js\nlet someNumbers = [3, 20, 100, -44, -5, -666];\nsomeNumbers.sort();  // [-44, -5, -666, 100, 20, 3]\n```", "```js\n// question_04_go_for_a_closure.ts\nconst fibC = (() => {\n  const cache: number[] = [];\n  const fib2 = (n: number): number => {\n    if (cache[n] === undefined) {\n      if (n === 0) {\n        cache[0] = 0;\n      } else if (n === 1) {\n        cache[1] = 1;\n      } else {\n        cache[n] = fib2(n - 2) + fib2(n - 1);\n      }\n    }\n    return cache[n];\n  };\n  return fib2;\n})();\n```", "```js\nconst roundFix2 = (\n  accum: number,\n  n: number\n): {\n  accum: number;\n  nRounded: number;\n} => ...\n```", "```js\n// question_04_tuples_to_go.ts\ntype AccumRoundedType = [number, number];\nconst roundFix2a = (\n  accum: number,\n  n: number\n): AccumRoundedType => {\n  const nRounded = accum > 0 ? Math.ceil(n) :\n    Math.floor(n);\n  accum += n - nRounded;\n  return [accum, nRounded];\n};\nconst roundFix2b = ([\n  accum,\n  n,\n]: AccumRoundedType): AccumRoundedType => {\n  const nRounded = accum > 0 ? Math.ceil(n) :\n    Math.floor(n);\n  accum += n - nRounded;\n  return [accum, nRounded];\n};\n```", "```js\n// question_04_tuples_to_go.test.ts\ndescribe(\"roundFix2a\", function () {\n  it(\"rounds 3.14159->3 if differences are 0\", () => {\n    const [accum, nRounded] = roundFix2a(0.0, 3.14159);\n    expect(accum).toBeCloseTo(0.14159);\n    expect(nRounded).toBe(3);\n  });\n  it(\"rounds 2.71828->3 if differences are 0.14159\", () =>\n    {\n    const [accum, nRounded] = roundFix2a(0.14159, 2.71828);\n    expect(accum).toBeCloseTo(-0.14013);\n    expect(nRounded).toBe(3);\n  });\n});\ndescribe(\"roundFix2b\", function () {\n  it(\"rounds 2.71828->2 if differences are -0.14013\", () =>\n    {\n    const [accum, nRounded] = roundFix2b([\n      -0.14013, 2.71828,\n    ]);\n    expect(accum).toBeCloseTo(0.57815);\n    expect(nRounded).toBe(2);\n  });\n  it(\"rounds 3.14159->4 if differences are 0.57815\", () =>\n    {\n    const [accum, nRounded] = roundFix2b([\n      0.57815, 3.14159,\n    ]);\n    expect(accum).toBeCloseTo(-0.28026);\n    expect(nRounded).toBe(4);\n  });\n});\n```", "```js\n// question_04_a_shuffle_test.test.ts\ndescribe(\"shuffleTest\", function () {\n  it(\"doesn't change the array length or elements\", () => {\n    const a = [22, 9, 60, 22, 12, 4, 56, 22, 60];\n    const oldA = JSON.stringify([...a].sort());\n    shuffle(a);\n    const newA = JSON.stringify([...a].sort());\n    expect(oldA).toBe(newA);\n  });\n});\n```", "```js\n// question_04_shuffling_by_sorting.ts\nconst sortingShuffle = <T>(arr: T[]): T[] =>\n  arr\n    .map((v) => ({ val: v, key: Math.random() }))\n    .sort((a, b) => a.key - b.key)\n    .map((o) => o.val);\n```", "```js\nconst characters = [\n  { name: \"Fred\", plays: \"bowling\" },\n  { name: \"Barney\", plays: \"chess\" },\n  { name: \"Wilma\", plays: \"bridge\" },\n  { name: \"Betty\", plays: \"checkers\" },\n  { name: \"Pebbles\", plays: \"chess\" },\n];\nconst list = characters\n  .filter(\n    (x) => x.plays === \"chess\" || x.plays == \"checkers\"\n  )\n  .map((x) => `<li>${x.name}</li>`)\n  .reduce((a, x) => [a[0] + x], [\"\"])\n  .map((x) => `<div><ul>${x}</ul></div>`)\n  .reduce((a, x) => x);\nconsole.log(list);\n/* Output is a single line; here output is wrapped\n<div><ul><li>Barney</li><li>Betty</li><li>Pebbles</li>\n</ul></div>\n*/\n```", "```js\nconst list2 = characters\n  .filter(\n    (x) => x.plays === \"chess\" || x.plays == \"checkers\"\n  )\n  .map(\n    (x, i, t) =>\n      `${i === 0 ? \"<div><ul>\" : \"\"}` +\n      `<li>${x.name}</li>` +\n      `${i == t.length - 1 ? \"</ul></div>\" : \"\"}`\n  )\n  .reduce((a, x) => a + x, \"\");\n// exact same result\n```", "```js\nconst list3 = characters\n  .filter(\n    (x) => x.plays === \"chess\" || x.plays == \"checkers\"\n  )\n  .map((x) => `<li>${x.name}</li>`)\n  .reduce(\n    (a, x, i, t) =>\n      a + x + (i === t.length - 1 ? \"</ul></div>\" : \"\"),\n    \"<div><ul>\"\n  );\n// again, the same result\n```", "```js\nfunction sum(x: number, y: number): number;\nfunction sum(x: string, y: string): string;\nfunction sum(x: any, y: any): string | number {\n  return x + y;\n}\n```", "```js\nconst reverseString2 = (str: string): string =>\n  str.split(\"\").reduceRight(sum, \"\");\nconsole.log(reverseString2(\"MONTEVIDEO\"));\n// OEDIVETNOM\nconst myArray = [22, 9, 60, 12, 4, 56];\nconsole.log(myArray.reduce(sum, 0));\n// 163\n```", "```js\ndescribe(\"myMap\", () => {\n  const myArray = [22, 9, 60, 12, 4, 56];\n  it(\"duplicates values\", () => {\n    const dup = (x: number): number => 2 * x;\n    expect(myArray.map(dup)).toEqual(myMap(myArray, dup));\n  });\n  it(\"add dashes\", () => {\n    const addDashes = (x: number): string => `-${x}-`;\n    expect(myArray.map(addDashes)).toEqual(\n      myMap(myArray, addDashes)\n    );\n  });\n});\n```", "```js\nconst range2 = (\n  from: number,\n  to: number,\n  step = Math.sign(to - from)\n): number[] => {\n  const arr = [];\n  do {\n    arr.push(from);\n    from += step;\n  } while (\n    (step > 0 && to > from) ||\n    (step < 0 && to < from)\n  );\n  return arr;\n};\n```", "```js\nconst range2b = (\n  start: number,\n  stop: number,\n  step: number = Math.sign(stop - start)\n): number[] =>\n  new Array(\n    step === 0 ? 1 : Math.ceil((stop - start) / step)\n  )\n    .fill(0)\n    .map((v, i) => start + i * step);\n```", "```js\nrange2(1, 10);        // [1, 2, 3, 4, 5, 6, 7, 8, 9]\nrange2(1, 10, 2);     // [1, 3, 5, 7, 9]\nrange2(1, 10, 3);     // [1, 4, 7]\nrange2(1, 10, 6);     // [1, 7]\nrange2(1, 10, 11);    // [1]\nrange2(21, 10);       // [21, 20, 19, ... 13, 12, 11]\nrange2(21, 10, -3);   // [21, 18, 15, 12]\nrange2(21, 10, -4);   // [21, 17, 13]\nrange2(21, 10, -7);   // [21, 14]\nrange2(21, 10, -12);  // [21]\n```", "```js\ndescribe(\"range2()\", () => {\n  it(\"works from 1 to 10\", () =>\n    expect(range2(1, 10)).toEqual([\n      1, 2, 3, 4, 5, 6, 7, 8, 9,\n    ]));\n  it(\"works from 1 to 10 by 2\", () =>\n    expect(range2(1, 10, 2)).toEqual([1, 3, 5, 7, 9]));\n  it(\"works from 21 down to 10 by -4\", () =>\n    expect(range2(21, 10, -4)).toEqual([21, 17, 13]));\n});\n```", "```js\nfunction* range4(\n  from: number,\n  to: number,\n  step: number = Math.sign(to - from)\n): Generator<number> {\n  do {\n    yield from;\n    from += step;\n  } while (\n    (step > 0 && to >= from) ||\n    (step < 0 && to <= from)\n  );\n}\n```", "```js\ndescribe(\"range4\", () => {\n  it(\"generates 2..5\", () => {\n    const range = range4(2, 5);\n    expect(range.next().value).toBe(2);\n    expect(range.next().value).toBe(3);\n    expect(range.next().value).toBe(4);\n    expect(range.next().value).toBe(5);\n    expect(range.next().value).toBe(undefined);\n  });\n  it(\"generates 5..2\", () => {\n    const range = range4(5, 2);\n    expect([...range]).toEqual([5, 4, 3, 2]);\n  });\n  it(\"generates 1..10 by 2\", () => {\n    const numbers = [];\n    for (const i of range4(1, 10, 2)) {\n      numbers.push(i);\n    }\n    expect(numbers).toEqual([1, 3, 5, 7, 9]);\n  });\n});\n```", "```js\nconst myData = [\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9, 10, 11, 12],\n];\nconst concatNumbers = (a: string, b: number): string =>\n  !a ? `${b}` : `${a},${b}`;\nconst concatLines = (c: string, d: string): string =>\n  c + \"\\n\" + d;\nconst makeCSV = (data: number[][]) =>\n  data\n    .map((x) => x.reduce(concatNumbers, \"\"))\n    .reduce(concatLines, \"\");\nconsole.log(makeCSV(myData));\n/*\n1,2,3,4\n5,6,7,8\n9,10,11,12\n*/\n```", "```js\nconst makeCSV2 = (data: number[][]) =>\n  data\n    .map((x: number[]) =>\n      x.reduce(\n        (a: string, b: number): string =>\n          !a ? `${b}` : `${a},${b}`,\n        \"\"\n      )\n    )\n    .reduce((c: string, d: string) => c + \"\\n\" + d, \"\");\n```", "```js\nconst better = apiAnswer\n  .flatMap((c) =>\n    c.states.map((s) => ({ ...s, country: c.name }))\n  )\n  .flatMap((s) =>\n    s.cities.map((t) => ({\n      ...t,\n      state: s.name,\n      country: s.country,\n    }))\n  )\n  .map((t) => `${t.name}, ${t.state}, ${t.country}`);\nconsole.log(better);\n/*\n[\n  'Lincoln, Buenos Aires, Argentine',\n  'Lincoln, England, Great Britain',\n  'Lincoln, California, United States of America',\n  'Lincoln, Rhode Island, United States of America',\n  'Lincolnia, Virginia, United States of America',\n  'Lincoln Park, Michigan, United States of America',\n  'Lincoln, Nebraska, United States of America',\n  'Lincoln Park, Illinois, United States of America',\n  'Lincoln Square, Illinois, United States of America'\n]\n*/\n```", "```js\nconst words = gettysburg.join(\" \").split(\" \").length; // 270\n```", "```js\nconst someAsync = <T>(\n  arr: T[],\n  fn: (x: T) => Promise<boolean>\n) =>\n  mapAsync(arr, fn).then((mapped) => mapped.some(Boolean));\n```", "```js\ndescribe(\"someAsync\", () => {\n  it(\"succeeds if sometimes OK\", async () => {\n    const someEven = await someAsync(\n      [1, 2, 3, 4],\n      fakeFilter\n    );\n    expect(someEven).toBeTruthy();\n  });\n  it(\"fails if never OK\", () => {\n    expect(\n      someAsync([1, 3, 5, 7, 9], fakeFilter)\n    ).resolves.toBeFalsy();\n  });\n});\n```", "```js\nconst notInUse = (p: PoolEntry): boolean => !p.inUse;\nconst MAX_NOT_IN_USE = 10;\n```", "```js\n  return new Promise((resolve) => {\n    available!.inUse = true;\n    available!.worker.on(\"message\", (x) => {\n      resolve(x);\n      available!.inUse = false;\n      while (\n        pool.filter(notInUse).length > MAX_NOT_IN_USE\n      ) {\n        const notUsed = pool.findIndex(notInUse);\n        pool[notUsed].worker.terminate();\n        pool.splice(notUsed, 1);\n      }\n    });\n    available!.worker.postMessage(value);\n  });\n```", "```js\nconst queue: ((v?: any) => void)[] = [];\nlet running = 0;\nconst MAX_TO_USE = 5;\n```", "```js\nconst enqueue = (resolve2: (v?: any) => void) => {\n  if (running < MAX_TO_USE) {\n    running++;\n    resolve2();\n  } else {\n    queue.push(resolve2);\n  }\n};\nconst dequeue = () => {\n  const resolve2 = queue.shift();\n  resolve2 && resolve2();\n};\n```", "```js\nexport const workerCall = (\n  filename: string,\n  value: any\n): Promise<any> => {\n  return new Promise((resolve) => {\n    new Promise((resolve2) => enqueue(resolve2)).then(\n      () => {\n        let available = pool\n          .filter(notInUse)\n          .find((x) => x.filename === filename);\n        if (available === undefined) {\n          available = {\n            worker: new Worker(filename),\n            filename,\n            value,\n            inUse: true,\n          } as PoolEntry;\n          pool.push(available);\n        }\n        available!.inUse = true;\n        available!.worker.on(\"message\", (x) => {\n          resolve(x);\n          available!.inUse = false;\n          dequeue();\n        });\n        available!.worker.postMessage(value);\n      }\n    );\n  });\n};\n```", "```js\n  let available = pool\n    .find((v) => !v.inUse && v.filename === filename);\n```", "```js\n  return new Promise((resolve, reject) => {\n    available!.inUse = true;\n    available!.worker.on(\"message\", (x) => {\n      resolve(x);\n      available!.inUse = false;\n    });\n    available!.worker.on(\"error\", (x) => {\n      reject(x);\n      available!.inUse = false;\n    });\n    available!.worker.postMessage(value);\n  });\n```", "```js\nconst addLogging = <T extends (...args: any[]) => any>(\n  fn: T\n): ((...args: Parameters<T>) => ReturnType<T>) => {\n  return (...args: Parameters<T>): ReturnType<T> => {\n    console.log(`entering ${fn.name}(${args})`);\n    const valueToReturn = fn(...args);\n    console.log(`exiting  ${fn.name}=>${valueToReturn}`);\n    return valueToReturn;\n  };\n};\n```", "```js\nconst memoize4 = <T extends (...x: any[]) => any>(\n  fn: T\n): ((...x: Parameters<T>) => ReturnType<T>) => {\n  const cache = new Map() as Map<string, ReturnType<T>>;\n  return (...args) => {\n    const strX = JSON.stringify(args);\n    if (!cache.has(strX)) {\n      cache.set(strX, fn(...args));\n    }\n    return cache.get(strX) as ReturnType<T>;\n  };\n};\n```", "```js\nconst randomizer =\n  <T extends (...x: any[]) => any>(...fns: T[]) =>\n  (\n    ...args: Parameters<T>\n  ): ((...args: Parameters<T>) => ReturnType<T>) => {\n    const first: T = fns.shift() as T;\n    fns = shuffle(fns);\n    fns.push(first);\n    return fns[0](...args);\n  };\n```", "```js\nconst say1 = () => console.log(1);\nconst say22 = () => console.log(22);\nconst say333 = () => console.log(333);\nconst say4444 = () => console.log(4444);\nconst rrr = randomizer(say1, say22, say333, say4444);\nrrr(); // 333\nrrr(); // 4444\nrrr(); // 333\nrrr(); // 22\nrrr(); // 333\nrrr(); // 22\nrrr(); // 333\nrrr(); // 4444\nrrr(); // 1\nrrr(); // 4444\n```", "```js\nconst not =\n  <T extends (...args: any[]) => boolean>(fn: T) =>\n  (...args: Parameters<T>): boolean =>\n    !fn(...args);\nconst invert =\n  <T extends (...args: any[]) => number>(fn: T) =>\n  (...args: Parameters<T>): number =>\n    -fn(...args);\n```", "```js\nconst opposite =\n  <T extends (...args: any[]) => number | boolean>(fn: T)\n    =>\n  (…args: Parameters<T>): ReturnType<T> => {\n    const result = fn(...args);\n    return (\n      typeof result === \"boolean\" ? !result : -result\n    ) as any;\n  };\n```", "```js\nimport { invert } from \"../invert\";\ndescribe(\"invert\", () => {\n  it(\"can be used to sort Spanish words\", () => {\n    const spanishComparison = (\n      a: string,\n      b: string\n    ): number => a.localeCompare(b, \"es\");\n    const palabras = [\n   \"  \"ñandú\",\n   \"  \"oasis\",\n   \"  \"mano\",\n   \"  \"natural\",\n   \"  \"mítico\",\n   \"  \"musical\",\n    ];\n    expect(\n      palabras.sort(invert(spanishComparison))\n    ).toEqual([\n   \"  \"oasis\",\n   \"  \"ñandú\",\n   \"  \"natural\",\n   \"  \"musical\",\n   \"  \"mítico\",\n   \"  \"mano\",\n    ]);\n  });\n});\n```", "```js\nimport { range } from \"../../chapter 05/range\";\nfunction arityL<T extends (...args: any[]) => any>(\n  n: number,\n  fn: T\n): (...x: Parameters<T>) => ReturnType<T> {\n  const args1n = range(0, n)\n    .map((i) => `x${i}`)\n    .join(\",\");\n  return eval(`(${args1n}) => ${fn.name}(${args1n})`);\n}\n```", "```js\nconst parseInt1 = arityL(parseInt, 1);\n// (x0) => parseInt(x0,x1) parseInt1.length === 1\nconst parseInt2 = arity(Number.parseInt,2)\n// (x0,x1) => parseInt(x0,x1) parseInt2.length === 2\n```", "```js\nconst binary = (fn) => (...a) => fn(a[0], a[1]);\nconst ternary = (fn) => (...a) => fn(a[0], a[1], a[2]);\n```", "```js\nconst binary =\n  <T extends (...x: any[]) => any>(\n    fn: T\n  ): ((\n    arg0: Parameters<T>[0],\n    arg1: Parameters<T>[1]\n  ) => ReturnType<T>) =>\n  (x, y) =>\n    fn(x, y);\nconst ternary =\n  <T extends (...x: any[]) => any>(\n    fn: T\n  ): ((\n    arg0: Parameters<T>[0],\n    arg1: Parameters<T>[1],\n    arg2: Parameters<T>[2]\n  ) => ReturnType<T>) =>\n  (x, y, z) =>\n    fn(x, y, z);\n```", "```js\nconst promiseThrottle = <\n  A,\n  T extends (...x: any[]) => Promise<A>\n>(\n  fn: T,\n  delay = 300_000  /* 5 minutes */\n): ((...x: Parameters<T>) => Promise<A>) => {\n  const cache = {} as Record<string, Promise<A>>;\n  const timers = {} as Record<\n    string,\n    ReturnType<typeof setTimeout>\n  >;\n  return (...args) => {\n    const strX = JSON.stringify(args);\n    if (!(strX in timers)) {\n      timers[strX] = setTimeout(() => {\n        delete cache[strX];\n        delete timers[strX];\n      }, delay);\n    }\n    return strX in cache\n      ? cache[strX]\n      : (cache[strX] = fn(...args).catch((x) => {\n          delete cache[strX];\n          delete timers[strX];\n          return x;\n        }));\n  };\n};\n```", "```js\nconst setField = <D>(\n  attr: keyof D,\n  value: any,\n  obj: D\n) => ({\n  ...obj,\n  [attr]: value,\n});\n```", "```js\nconst setField2 = <D>(\n  attr: keyof D,\n  value: any,\n  obj: D\n) => ({\n  ...deepCopy(obj),\n  [attr]: value,\n});\n```", "```js\nconst getField = attr => obj => obj[attr];\ngetField(\"someField\")(null);\n// Uncaught TypeError: Cannot read property 'a' of null\n```", "```js\nconst getField =\n  <D>(f: keyof D) =>\n  (obj: D) =>\n    obj[f];\n```", "```js\nconst demethodize1 =\n  <T extends (arg0: any, ...args: any[]) => any>(fn: T) =>\n  (arg0: any, ...args: Parameters<T>) =>\n    fn.apply(arg0, args);\nconst demethodize2 =\n  <T extends (arg0: any, ...args: any[]) => any>(fn: T) =>\n  (arg0: any, ...args: Parameters<T>): ReturnType<T> =>\n    fn.call(arg0, ...args);\nconst demethodize3 =\n  <T extends (arg0: any, ...args: any[]) => any>(fn: T) =>\n  (arg0: any, ...args: Parameters<T>): ReturnType<T> =>\n    fn.bind(arg0, ...args)();\n```", "```js\nconst findMaximum2 = findOptimum2((x, y) => Math.max(x,\n  y));\nconst findMinimum2 = findOptimum2((x, y) => Math.min(x,\n  y));\n```", "```js\nconst max = (...arr: number[]): number => Math.max(...arr);\nconst min = (...arr: number[]): number => Math.min(...arr);\n```", "```js\nconst findMaximum3 = findOptimum2(max);\nconst findMinimum3 = findOptimum2(min);\n```", "```js\nconst sumMany = (total: number) => (value?: number) =>\n  value === undefined ? total : sumMany(total + value);\nsumMany(2)(2)(9)(6)(0)(-3)(); // 16\n```", "```js\n// curryByEval.js\nfunction curryByEval(fn) {\n  return eval(`${range(0, fn.length)\n    .map((i) => `x${i}`)\n    .join(\"=>\")} => ${fn.name}(${range(0, fn.length)\n    .map((i) => `x${i}`)\n    .join(\",\")})`);\n}\n```", "```js\ncurryByEval(make3); // x0=>x1=>x2 => make3(x0,x1,x2)\n```", "```js\nfunction curryByEval<A extends any[], R>(\n  fn: (...args: A) => R\n): Curry<A, R>;\nfunction curryByEval(fn: (...args: any) => any) {\n  const pp = `${range(0, fn.length)\n    .map((i) => `x${i}`)\n    .join(\"=>\")} => ${fn.name}(${range(0, fn.length)\n    .map((i) => `x${i}`)\n    .join(\",\")})`;\n}\n```", "```js\nfunction curryByEval2<A extends any[], R>(\n  fn: (...args: A) => R\n): Curry<A, R>;\nfunction curryByEval2(fn: (...args: any) => any) {\n  return eval(`${range(0, fn.length)\n    .map((i) => `x${i}`)\n    .join(\"=>\")} =>\n    (${fn.toString()})\n    (${range(0, fn.length)\n      .map((i) => `x${i}`)\n      .join(\",\")})`);\n}\n```", "```js\ncurryByEval2(make3);\n// x0=>x1=>x2=> ((a, b, c) => `${a}:${b}:${c}`)(x0,x1,x2)\n```", "```js\nconst uncurry = (fn, len) =>\n  eval(\n    `(${range(0, len)\n      .map((i) => `x${i}`)\n      .join(\",\")}) => ${fn.name}${range(0, len)\n      .map((i) => `(x${i})`)\n      .join(\"\")}`\n  );\n```", "```js\nx0=>x1=>x2=> make3(x0,x1,x2)\n```", "```js\n(x0,x1,x2) => curriedFn(x0)(x1)(x2)\n```", "```js\nconst curriedMake3 = (x0) => (x1) => (x2) =>\n  ((a, b, c) => `${a}:${b}:${c}`)(x0, x1, x2);\nconsole.log(uncurry(curriedMake3, 3).toString());\n// (x0,x1,x2) => curriedMake3(x0)(x1)(x2)\n```", "```js\nFunction.prototype.curry = function () {\n  return this.length === 0\n    ? this()\n    : (p) => this.bind(this, p).curry();\n};\n```", "```js\ntype Curry2<P, R> = P extends [infer H, ...infer T]\n  ? (arg: H) => Curry2<[...T], R>\n  : R;\n```", "```js\ntype Curry<P extends any[], R> = 1 extends P[\"length\"]\n  ? (arg: P[0]) => R // only 1 arg\n  : P extends [infer H, ...infer T] // 2 or more args\n  ? (arg: H) => Curry<[...T], R>\n  : never;\n```", "```js\nconst applyStyle =\n  (style: string) =>\n  (text: string): string =>\n    `<${style}>${text}</${style}>`;\nconst makeBold = applyStyle(\"b\");\nconsole.log(makeBold(\"Montevideo\"));\n// <b>Montevideo</b>\nconst applyStyle2 = (style: string, text: string): string\n  =>\n  `<${style}>${text}</${style}>`;\nconst makeUnderline = curry(applyStyle2)(\"u\");\nconsole.log(makeUnderline(\"Uruguay\"));\n// <u>Uruguay</u>\n```", "```js\nconst partial =\n  (fn) =>\n  (...params) =>\n    fn.length <= params.length\n      ? fn(...params)\n      : (...otherParams) =>\n          partial(fn)(...params, ...otherParams);\n```", "```js\nconst split = (str: string) => (text: string) =>\n  text.split(str);\nconst map =\n  (fn: (x: string) => string) => (arr: string[]) =>\n    arr.map(fn);\nconst firstToUpper = (word: string): string =>\n  word[0].toUpperCase() + word.substring(1).toLowerCase();\nconst join = (str: string) => (arr: string[]) =>\n  arr.join(str);\nconst headline = pipeline(\n  split(\" \"),\n  map(firstToUpper),\n  join(\" \")\n);\n```", "```js\nconsole.log(headline(\"Alice's ADVENTURES in WoNdErLaNd\"));\n// Alice's Adventures In Wonderland\n```", "```js\nconst getField = attr => obj => obj[attr]; const filter =\n  fn => arr => arr.filter(fn); const map = fn => arr =>\n  arr.map(fn);\nconst reduce = (fn, init) => arr => arr.reduce(fn, init);\nconst pending = (listOfTasks, name) => pipeline(\ngetField(\"byPerson\"),\nfilter(t => t.responsible === name), map(t => t.tasks),\nreduce((y, x) => x, []), filter(t => t && !t.done),\n  map(getField(\"id\"))\n)(allTasks || {byPerson: []}); //\n```", "```js\nconst getSomeResults2 = compose(sort, group, filter, select);\n```", "```js\ntype Reverse<FNS extends FN[]> = 1 extends FNS[\"length\"]\n  ? [FNS[0]]\n  : FNS extends [\n      infer FN1st extends FN,\n      ...infer FNRest extends FN[]\n    ]\n  ? [...Reverse<FNRest>, FN1st]\n  : never;\n```", "```js\ntype Compose<FNS extends FN[]> = Pipeline<Reverse<FNS>>;\nfunction compose1<FNS extends FN[]>(\n  ...fns: FNS\n): Compose<FNS> {\n  return pipeline(...fns.reverse()) as Compose<FNS>;\n}\n```", "```js\n{\n    name: string;\n    lat: number;\n    long: number;\n    extra: boolean;\n    getName: () => string;\n    setName: (newName: string) => Chainify<City>;\n    setLat: (newLat: number) => Chainify<City>;\n    setLong: (newLong: number) => Chainify<City>;\n    getCoords: () => number[];\n}\n```", "```js\nconst reverse = (str: string): string =>\n  str.length === 0 ? \"\" : reverse(str.slice(1)) + str[0];\n```", "```js\nconst selectionSort = (arr: number[]): number[] => {\n  if (arr.length === 0) {\n    return [];\n  } else {\n    const max = Math.max(...arr);\n    const rest = [...arr];\n    rest.splice(arr.indexOf(max), 1);\n    return [...selectionSort(rest), max];\n  }\n};\nselectionSort([2, 2, 0, 9, 1, 9, 6, 0]);\n// [0, 0, 1, 2, 2, 6, 9, 9]\n```", "```js\nconst partition = <A>(\n  arr: A[],\n  fn: (x: A) => boolean\n): [A[], A[]] =>\n  arr.reduce(\n    (result: [A[], A[]], elem: A) => {\n      result[fn(elem) ? 0 : 1].push(elem);\n      return result;\n    },\n    [[], []]\n  );\n```", "```js\ntype Opt<X> = X | undefined;\nconst findR = <A>(\n  orig: Opt<A>[],\n  cb: (x: A, i: number, a: Opt<A>[]) => boolean\n): Opt<A> => {\n  const findLoop = (arr: Opt<A>[], i: number): Opt<A> =>\n    arr.length === 0\n      ? undefined\n      : !(0 in arr) || arr[0] === undefined\n      ? findLoop(arr.slice(1), I + 1)\n      : cb(arr[0], i, orig)\n      ? arr[0]\n      : findLoop(arr.slice(1), i + 1);\n  return findLoop(orig, 0);\n};\n```", "```js\ntype Opt<X> = X | undefined;\nconst everyR = <A>(\n  orig: Opt<A>[],\n  cb: (x: A, i: number, a: Opt<A>[]) => boolean\n): boolean => {\n  const everyLoop = (arr: Opt<A>[], i: number): boolean =>\n    arr.length === 0\n      ? true\n      : !(0 in arr) || arr[0] === undefined\n      ? true\n      : !cb(arr[0], i, orig)\n      ? false\n      : everyLoop(arr.slice(1), i + 1);\n  return everyLoop(orig, 0);\n};\n```", "```js\ntype Opt<X> = X | undefined;\nconst someR = <A>(\n  orig: Opt<A>[],\n  cb: (x: A, i: number, a: Opt<A>[]) => boolean\n): boolean => {\n  const someLoop = (arr: Opt<A>[], i: number): boolean =>\n    arr.length === 0\n      ? false\n      : !(0 in arr) || arr[0] === undefined\n      ? someLoop(arr.slice(1), i + 1)\n      : cb(arr[0], i, orig)\n      ? true\n      : someLoop(arr.slice(1), i + 1);\n  return someLoop(orig, 0);\n};\n```", "```js\nconst SIZE = 8;\nconst places = Array(SIZE);\nconst checkPlace = (column: number, row: number): boolean\n  =>\n  places\n    .slice(0, column)\n    .every(\n      (v, i) =>\n        v !== row && Math.abs(v - row) !== column - i\n    );\nconst symmetricFinder = (column = 0): void => {\n  if (column === SIZE) {\n    console.log(JSON.stringify(places.map((x) => x + 1)));\n  } else if (column <= SIZE / 2) {\n    // first half of the board?\n    const testRowsInColumn = (j: number): void => {\n      if (j < SIZE) {\n        if (checkPlace(column, j)) {\n          places[column] = j;\n          symmetricFinder(column + 1);\n        }\n        testRowsInColumn(j + 1);\n      }\n    };\n    testRowsInColumn(0);\n  } else {\n    // second half of the board\n    const symmetric = SIZE - 1 - places[SIZE - 1 - column];\n    if (checkPlace(column, symmetric)) {\n      places[column] = symmetric;\n      symmetricFinder(column + 1);\n    }\n  }\n};\n```", "```js\n[3,5,2,8,1,7,4,6]\n[4,6,8,2,7,1,3,5]\n[5,3,1,7,2,8,6,4]\n[6,4,7,1,8,2,5,3]\n```", "```js\nconst LCS = (strA: string, strB: string): number => {\n  // memoization \"by hand\"\n  const cache: { [k: string]: number } = {};\n  const innerLCS = (strA: string, strB: string): number =>\n    {\n    const key = strA + \"/\" + strB;\n    let ret: number;\n    if (!(key in cache)) {\n      if (strA.length === 0 || strB.length === 0) {\n        ret = 0;\n      } else if (strA[0] === strB[0]) {\n        ret = 1 + innerLCS(strA.substr(1), strB.substr(1));\n      } else {\n        ret = Math.max(\n          innerLCS(strA, strB.substr(1)),\n          innerLCS(strA.substr(1), strB)\n        );\n      }\n      cache[key] = ret;\n    }\n    return cache[key];\n  };\n  return innerLCS(strA, strB);\n};\nconsole.log(LCS(\"INTERNATIONAL\", \"CONTRACTOR\"));\n// 6, as in the text\n```", "```js\nfunction isOdd1(n: number): boolean {\n  return n % 2 === 1;\n}\n```", "```js\nfunction isOdd2(n: number): boolean {\n  return Boolean(n % 2);  // or !!(n % 2) instead\n}\n```", "```js\nfunction isOdd3(n: number): boolean {\n  return Math.floor(n / 2) !== n / 2;\n}\n```", "```js\nfunction isOdd4(n: number): boolean {\n  return Math.floor(n / 2) === Math.floor((n - 1) / 2);\n}\n```", "```js\nfunction isOdd5(n: number): boolean {\n  return (n & 1) === 1;\n}\n```", "```js\nfunction isOdd6(n: number): boolean {\n  return Boolean(n & 1); // or !!(n & 1) instead\n}\n```", "```js\nfunction isOdd7(n: number): boolean {\n  return (n >> 1) << 1 !== n;\n}\n```", "```js\nfunction isOdd8(n: number): boolean {\n  return n >> 1 === (n - 1) >> 1;\n}\n```", "```js\nfunction isOdd9(n: number): boolean {\n  return \"13579\".includes(String(n).at(-1)!);\n}\n```", "```js\nfunction isEven(n: number, cont: FN): () => boolean {\n  if (n === 0) {\n    return trampoline(() => cont(true));\n  } else {\n    return trampoline(() => isOdd(n - 1, (v) => cont(v)));\n  }\n}\nfunction isOdd(n: number, cont: FN): () => boolean {\n  return trampoline(() => isEven(n, (v) => cont(!v)));\n}\n```", "```js\nfunction isEvenT(n: number): boolean {\n  return trampoline(isEven(n, (x) => x));\n}\nfunction isOddT(n: number): boolean {\n  return trampoline(isOdd(n, (x) => x));\n}\nconsole.log(\"22.. isEven?\", isEvenT(22));  // true\nconsole.log(\"9... isOdd?\", isOddT(5));     // true\nconsole.log(\"63... isEven?\", isEvenT(63)); // false\nconsole.log(\"60... isOdd?\", isOddT(60));   // false\n```", "```js\nfunction term(): number {\n  let accum = power();\n  while (\n    tokens[curr] === TIMES ||\n    tokens[curr] === DIVIDES ||\n    tokens[curr] === MODULUS\n  ) {\n    if (tokens[curr] === TIMES) {\n      curr++;\n      accum *= power();\n    } else if (tokens[curr] === DIVIDES) {\n      curr++;\n      accum /= power();\n    } else if (tokens[curr] === MODULUS) {\n      curr++;\n      accum %= power();\n    }\n  }\n  return accum;\n}\n```", "```js\nfunction power(): number {\n  const tower = [factor()];\n  while (tokens[curr] === POWER) {\n    curr++;\n    tower.push(factor());\n  }\n  while (tower.length > 1) {\n    tower[tower.length - 2] **= tower[tower.length - 1];\n    tower.pop();\n  }\n  return tower[0];\n}\n```", "```js\nconst agent = {\n  error: new Error(\"It's stirred; I ordered it shaken\"),\n  map: new Map([[\"James\", \"Bond\"]]),\n  set: new Set([0, 0, 7]),\n  regex: /007/,\n  useLicense() {\n    console.log(\"Bang! Bang!\");\n  },\n};\nconsole.log(jsonCopy(agent));\n/*\n{ error: {}, map: {}, set: {}, regex: {} }\n*/\n```", "```js\n/*\n{\n  error: Error: It's stirred; I ordered it shaken\n    ...many lines snipped out\n  map: Map(0) {},\n  set: Set(0) {},\n  regex: /(?:)/,\n  useLicense: [Function: useLicense]\n}\n*/\n```", "```js\nconst deepCopy2 = <O extends OBJ>(obj: O): O => {\n  const mapped = new Map<O, O>();\n  const deepCopy = (obj: O): O => {\n    let aux: O = obj;\n    if (obj && typeof obj === \"object\") {\n      if (mapped.has(obj)) {\n        return mapped.get(obj) as O;\n      }\n      aux = new (obj as any).constructor();\n      mapped.set(obj, aux);\n      Object.getOwnPropertyNames(obj).forEach((prop) => {\n        (aux as any)[prop as keyof O] =\n          deepCopy(obj[prop]);\n      });\n    }\n    return aux;\n  };\n  return deepCopy(obj);\n};\n```", "```js\nconst circular = {\n  a: 1,\n  b: { c: 3, d: { e: 5, f: null } }\n};\ncircular.b.d.f = circular.b as any;\nconsole.log(deepCopy2(circular));\n/*\n{\n  a: 1,\n  b: <ref *1> { c: 3, d: { e: 5, f: [Circular *1] } }\n}\n*/\n```", "```js\nconst proxySetAll = (obj: OBJ): OBJ => {\n  Object.keys(obj).forEach((v) => {\n    if (typeof obj[v] === \"object\") {\n      obj[v] = proxySetAll(obj[v]);\n    }\n  });\n  return new Proxy(obj, {\n    set() {\n      throw new Error(\"DON'T MODIFY ANYTHING IN ME\");\n    },\n    deleteProperty() {\n      throw new Error(\"DON'T DELETE ANYTHING IN ME\");\n    },\n  }) as OBJ;\n};\n```", "```js\nconst myObj = proxySetAll({\n  a: 5,\n  b: 6,\n  c: { d: 7, e: 8 },\n});\nmyObj.a = 777;\n// Uncaught Error: DON'T MODIFY ANYTHING IN ME\nmyObj.f = 888;\n// Uncaught Error: DON'T MODIFY ANYTHING IN ME\ndelete myObj.b;\n// Uncaught Error: DON'T DELETE ANYTHING IN ME\n```", "```js\ntype NODE_PTR = Node | null;\nconst insertAfter = (\n  list: NODE_PTR,\n  newKey: string,\n  oldKey: string\n): NODE_PTR => {\n  if (list === null) {\n    return null;\n  } else if (list.key === oldKey) {\n    return new Node(list.key, new Node(newKey, list.next));\n  } else {\n    return new Node(\n      list.key,\n      insertAfter(list.next, newKey, oldKey)\n    );\n  }\n};\n```", "```js\nconst c3 =\n  new Node(\"G\",\n    new Node(\"B\",\n      new Node(\"F\",\n        new Node(\"A\",\n          new Node(\"C\",\n            new Node(\"E\", null))))));\nconst newList = insertAfter(c3, \"D\", \"B\");\nconsole.log(c3 === newList);\n// false\nconsole.log(c3!.key === newList!.key);\n// true (both are \"G\")\nconsole.log(c3!.next === newList!.next);\n// false\nconsole.log(c3!.next!.key === newList!.next!.key);\n// true (both are \"B\")\nconsole.log(c3!.next!.next === newList!.next!.next);\n// false\nconsole.log(c3!.next!.next!.key === \"F\");\n// true\nconsole.log(newList!.next!.next!.key === \"D\");\n// true\nconsole.log(\n  c3!.next!.next!.next === newList!.next!.next!.next!.next\n);\n// true – after F, the list is the old one\n```", "```js\nconst composeManyLenses = <O extends OBJ>(\n  ...lenses: LENS<O>[]\n) =>\n  lenses.reduce((acc, lens) => composeTwoLenses(acc,\n    lens));\n```", "```js\nconst deepObject = {\n  a: 1,\n  b: 2,\n  c: {\n    d: 3,\n    e: {\n      f: 6,\n      g: { i: 9, j: { k: 11 } },\n      h: 8,\n    },\n  },\n};\nconsole.log(\n  view(composeManyLenses(lC, lE, lG, lJ, lK), deepObject)\n);\n// 11, same as earlier\n```", "```js\nconst lastNameLens = composeTwoLenses(\n  lensProp(\"name\"),\n  lensProp(\"last\")\n);\nconst firstNameLens = composeTwoLenses(\n  lensProp(\"name\"),\n  lensProp(\"first\")\n);\nconst fullNameGetter = <O extends OBJ>(obj: O): string =>\n  `${view(lastNameLens)(obj)},\n    ${view(firstNameLens)(obj)}`;\n```", "```js\nconst fullNameSetter =\n  <O extends OBJ>(fullName: string) =>\n  (obj: O): O => {\n    const parts = fullName.split(\",\");\n    return set(firstNameLens)(parts[1])(\n      set(lastNameLens)(parts[0])(obj)\n    ) as O;\n  };\nconst fullNameLens = lens(fullNameGetter, fullNameSetter);\n```", "```js\nconst getMap =\n  <K, V>(key: K) =>\n  (map: Map<K, V>) =>\n    map.get(key);\nconst setMap =\n  <K, V>(key: K) =>\n  (value: V) =>\n  (map: Map<K, V>) =>\n    new Map(map).set(key, value);\nconst lensMap = <K, V>(key: K) =>\n  lens(getMap<K, V>(key), setMap<K, V>(key));\n```", "```js\nconst logging = (target, name, descriptor) => {\n  const savedMethod = descriptor.value;\n  descriptor.value = function (...args) {\n    console.log(`entering ${name}: ${args}`);\n    try {\n      const valueToReturn =\n        savedMethod.bind(this)(...args);\n      console.log(`exiting ${name}: ${valueToReturn}`);\n      return valueToReturn;\n    } catch (thrownError) {\n      console.log(`exiting ${name}: threw ${thrownError}`);\n      throw thrownError;\n    }\n  };\n  return descriptor;\n};\n```", "```js\nclass SumThree {\n  constructor(z) {\n    this.z = z;\n  }\n  @logging\n  sum(x, y) {\n    return x + y + this.z;\n  }\n}\nnew SumThree(100).sum(20, 8);\n// entering sum: 20,8\n// exiting sum: 128\n```", "```js\nconst addBar = (Base) =>\n  class extends Base {\n    constructor(fooValue, barValue) {\n      super(fooValue);\n      this.barValue = barValue;\n    }\n    somethingElse() {\n      console.log(\n        \"something added: bar... \",\n        this.barValue\n      );\n    }\n  };\n```", "```js\ndeclare global {\n  interface Boolean {\n    map(_f: (_x: boolean) => boolean): boolean;\n  }\n}\ndeclare global {\n  interface Number {\n    map(_f: (_x: number) => number): number;\n  }\n}\ndeclare global {\n  interface String {\n    map(_f: (_x: string) => string): string;\n  }\n}\n```", "```js\nBoolean.prototype.map = function (\n  this: boolean,\n  fn: (_x: boolean) => any\n) {\n  return !!fn(this);\n};\nconst t = true;\nconst f = false;\nconst negate = (x: boolean) => !x;\nconsole.log(t.map(negate), f.map(negate));\n// false true\nNumber.prototype.map = function (\n  this: number,\n  fn: (_x: number) => number\n) {\n  return Number(fn(this));\n};\nconst n = 22;\nconst add1 = (n: number) => n + 1;\nconsole.log(n.map(add1));\n// 23\nString.prototype.map = function (\n  this: string,\n  fn: (_x: string) => string\n) {\n  return String(fn(this));\n};\nconst s = \"Montevideo\";\nconst addBangs = (s: string): string => s + \"!!!\";\nconsole.log(s.map(addBangs));\n// Montevideo!!!\n```", "```js\nconst VALUE = Symbol(\"Value\");\nclass Container {\n  constructor(x) {\n    this[VALUE] = x;\n  }\n  map(fn) {\n    return fn(this[VALUE]);\n  }\n  .\n  . other methods\n  .\n}\n```", "```js\nclass XXX {\n  constructor(...) {\n    if (this.constructor === XXX) {\n      throw new Error(\"Cannot initialize XXX class\")\n    }\n    .\n    . rest of the constructor\n    .\n  }\n  .\n  . other methods\n  .\n}\n```", "```js\nconst pending = Maybe.of(listOfTasks)\n  .map(getField(\"byPerson\"))\n  .map(filter((t) => t.responsible === name))\n  .map((t) => tasks)\n  .map((t) => t[0])\n  .map(filter((t) => !t.done))\n  .map(getField(\"id\"))\n  .valueOf();\n```", "```js\nconst treeHeight = <A>(tree: TREE<A>): number =>\n  tree(\n    (val, left, right) =>\n      1 + Math.max(treeHeight(left), treeHeight(right)),\n    () => 0\n  );\n```", "```js\nconst treeList = <A>(tree: TREE<A>): void =>\n  tree(\n    (value, left, right) => {\n      treeList(left);\n      console.log(value);\n      treeList(right);\n    },\n    () => {\n      // nothing\n    }\n  );\n```", "```js\nconst treeRemove = <A>(\n  toRemove: A,\n  tree: TREE<A>\n): TREE<A> =>\n  tree(\n    (val, left, right) => {\n      const findMinimumAndRemove = (\n        tree: TREE<A> /* never empty */\n      ): { min: A; tree: TREE<A> } =>\n        tree(\n          (value, left, right) => {\n            if (treeIsEmpty(left)) {\n              return { min: value, tree: right };\n            } else {\n              const result = findMinimumAndRemove(left);\n              return {\n                min: result.min,\n                tree: Tree(value, result.tree, right),\n              };\n            }\n          },\n          () => {\n            /* not needed */\n          }\n        );\n      if (toRemove < val) {\n        return Tree(val, treeRemove(toRemove, left),\n          right);\n      } else if (toRemove > val) {\n        return Tree(val, left, treeRemove(toRemove,\n          right));\n      } else if (treeIsEmpty(left) && treeIsEmpty(right)) {\n        return EmptyTree();\n      } else if (treeIsEmpty(left) !== treeIsEmpty(right))\n        {\n        return tree(\n          (val, left, right) =>\n            left(\n              () => left,\n              () => right\n            ),\n          () => {\n            /* not needed */\n          }\n        );\n      } else {\n        const result = findMinimumAndRemove(right);\n        return Tree(result.min, left, result.tree);\n      }\n    },\n    () => tree\n  );\n```", "```js\nconst treeSearch2 = <A>(\n  findValue: A,\n  tree: TREE<A>\n): boolean =>\n  tree(\n    (value, left, right) =>\n      findValue === value ||\n      (findValue < value\n        ? treeSearch2(findValue, left)\n        : treeSearch2(findValue, right)),\n    () => false\n  );\n```", "```js\nconst treeSearch3 = <A>(\n  findValue: A,\n  tree: TREE<A>\n): boolean =>\n  tree(\n    (value, left, right) =>\n      findValue === value ||\n      treeSearch3(\n        findValue,\n        findValue < value ? left : right\n      ),\n    () => false\n  );\n```", "```js\nconst listToArray = <A>(list: LIST<A>): A[] =>\n  list(\n    (head, tail) => [head, ...listToArray(tail)],\n    () => []\n  );\nconst listFromArray = <A>(arr: A[]): LIST<A> =>\n  arr.length\n    ? NewList(arr[0], listFromArray(arr.slice(1)))\n    : EmptyList();\n```", "```js\nconst listConcat = <A>(list1: LIST<A>, list2: LIST<A>) =>\n  list1(\n    (head, tail) => NewList(head, listConcat(tail, list2)),\n    () => list2\n  );\nconst listAppend = <A>(list: LIST<A>, value: A): LIST<A> =>\n  list(\n    (head, tail) => NewList(head, listAppend(tail, value)),\n    () => NewList(value, EmptyList())\n  );\nconst listReverse = <A>(list: LIST<A>): LIST<A> =>\n  list(\n    (head, tail) => listAppend(listReverse(tail), head),\n    () => EmptyList()\n  );\n```", "```js\nconst listMap = <A, B>(\n  list: LIST<A>,\n  fn: (_x: A) => B\n): LIST<B> =>\n  list(\n    (head, tail) => NewList(fn(head), listMap(tail, fn)),\n    EmptyList\n  );\nconst listFilter = <A>(\n  list: LIST<A>,\n  fn: (_x: A) => boolean\n): LIST<A> =>\n  list(\n    (head, tail) =>\n      fn(head)\n        ? NewList(head, listFilter(tail, fn))\n        : listFilter(tail, fn),\n    EmptyList\n  );\nconst listReduce = <A, B>(\n  list: LIST<A>,\n  fn: (_acc: B, _val: A) => B,\n  accum: B\n): B =>\n  list(\n    (head, tail) => listReduce(tail, fn, fn(accum, head)),\n    () => accum\n  );\n```", "```js\ntype BOOLEAN = (_true: any, _false: any) => any;\nconst TRUE: BOOLEAN = (trueValue: any, __: any) =>\n  trueValue;\nconst FALSE: BOOLEAN = (__: any, falseValue: any) =>\n  falseValue;\n```", "```js\nconst MakeBool = (value: boolean) => (value ? TRUE :\n  FALSE);\nconst valueOf = (boolValue: BOOLEAN): boolean =>\n  boolValue(true, false);\nconsole.log(\"LOG T  \", valueOf(TRUE));\nconsole.log(\"LOG F  \", valueOf(FALSE));\n// true false\nconsole.log(\"VAL T  \", valueOf(MakeBool(true)));\nconsole.log(\"VAL F  \", valueOf(MakeBool(false)));\n// true false\n```", "```js\nconst NOT = (boolValue: BOOLEAN): BOOLEAN =>\n  boolValue(FALSE, TRUE);\nconst AND = (\n  boolLeft: BOOLEAN,\n  boolRight: BOOLEAN\n): BOOLEAN => boolLeft(boolRight, FALSE);\nconst OR = (\n  boolLeft: BOOLEAN,\n  boolRight: BOOLEAN\n): BOOLEAN => boolLeft(TRUE, boolRight);\nconst XOR = (\n  boolLeft: BOOLEAN,\n  boolRight: BOOLEAN\n): BOOLEAN => boolLeft(NOT(boolRight), boolRight);\nconst EQU = (\n  boolLeft: BOOLEAN,\n  boolRight: BOOLEAN\n): BOOLEAN => boolLeft(boolRight, NOT(boolRight));\nconst IMP = (\n  boolLeft: BOOLEAN,\n  boolRight: BOOLEAN\n): BOOLEAN => boolLeft(boolRight, TRUE);\n```", "```js\nconst ifElse = (\n  boolValue: BOOLEAN,\n  fnTRUE: FN,\n  fnFALSE: FN\n) => boolValue(fnTRUE, fnFALSE)();\nifElse(\n  TRUE,\n  () => console.log(\"I'm true\"),\n  () => console.log(\"I'm false\")\n);\n// true\nifElse(\n  FALSE,\n  () => console.log(\"I'm true\"),\n  () => console.log(\"I'm false\")\n);\n// false\n```"]