<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-168"><a id="_idTextAnchor177"/>9</h1>
<h1 id="_idParaDest-169"><a id="_idTextAnchor178"/>Using and Creating Adapters</h1>
<p>After developing for several years, you may have a set of common utility functions, a collection of other frameworks, and a library of your own scripts. Maintaining all of these moving parts may become too entropic for an enterprise project or a fleet of microservices. We can restructure our common code into a more generic interface, or pattern, and reclassify those scripts as an “adapter” (also known as a “plugin”).</p>
<p>Using adapters can save us development time, prevent us from repeating ourselves, and help centralize collaboration by maintaining its code base. A few examples of an adapter would be transforming text into a specific character ruleset, scaffolding a sidecar project such as an administrative dashboard, or providing a caching layer.</p>
<p>Sequelize offers a way to extend its behavior by allowing the integration of adapters and plugins through a mixture of object prototyping and its lifecycle events. Once we become familiar with using pre-existing adapters, we will create our own adapter/extension for Sequelize that will generate “slug URLs” for each instance within a model.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Installing, configuring, and integrating AdminJS with Sequelize</li>
<li>Integrating Sequelize with GraphQL</li>
<li>Creating our own adapter</li>
</ul>
<h1 id="_idParaDest-170"><a id="_idTextAnchor179"/>Technical requirements</h1>
<p>You can find the code files of this chapter on GitHub at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch9">https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch9</a></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor180"/>Installing, configuring, and integrating AdminJS with Sequelize</h1>
<p>AdminJS is an <a id="_idIndexMarker672"/>administrative dashboard that can integrate into various <a id="_idIndexMarker673"/>database management systems, ORMs, and web <a id="_idIndexMarker674"/>frameworks. In addition to AdminJS being <a id="_idIndexMarker675"/>able to generate charts and tables for <a id="_idIndexMarker676"/>your data, it can also create roles and access <a id="_idIndexMarker677"/>control lists, export <a id="_idIndexMarker678"/>reports, and centralize <a id="_idIndexMarker679"/>the modeling of <strong class="bold">Create, Read, Update, Delete</strong> (<strong class="bold">CRUD</strong>) operations.</p>
<p>Avalon Airline’s investors want us to have a dashboard that allows us to manage flights and tickets, and show basic reporting numbers, such as the total number of planes and gross profit. AdminJS seems to be a perfect fit here; we can begin by installing the necessary components within Avalon Airline’s root directory.</p>
<p>Within the terminal, we can install the packages by executing the following command:</p>
<pre>npm i adminjs @adminjs/express express-formidable @adminjs/sequelize tslib express-session</pre>
<p class="callout-heading">Note</p>
<p class="callout">The <code>express-formidable</code> module is required as a peer dependency for the <code>@adminjs/express</code> package. The <code>formidable</code> module is a fast-streaming multipart parser <a id="_idIndexMarker680"/>with a low memory footprint. For more information on <a id="_idIndexMarker681"/>formidable and its capabilities, you can refer to its GitHub repository, located at <a href="https://github.com/node-formidable/formidable">https://github.com/node-formidable/formidable</a>.</p>
<p>Depending on which version of <code>npm</code> you have installed (eight or above), and which version of <code>@adminjs/sequelize</code> is installed, you may run into legacy peer dependency issues. Due to one of our packages (<code>@adminjs/sequelize</code>) requiring an old module path for Sequelize (<code>sequelize</code> versus <code>@sequelize/core</code>) we will run into missing dependency issues which could be resolved by enabling <code>legacy-peer-deps</code> or using the <code>override</code> option.</p>
<p>Typically, we would want to avoid using the <code>legacy-peer-deps</code> option to avoid breaking changes. We could <a id="_idIndexMarker682"/>use the <code>override</code> option in <em class="italic">package.json</em> for resolving packages which is explained more at <a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides">https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides</a>. Within the <em class="italic">package.json</em> file, below the <code>scripts</code> block, we will want to add another block with the following:</p>
<pre class="source-code">
  "overrides": {
    "sequelize": "^6"
  },</pre>
<p>If the previous npm installation step failed, we can retry after the <em class="italic">package.json</em> updates which will resolve <code>@adminjs/sequelize</code> package’s <code>sequelize</code> version requirements.</p>
<p>Now, we can start integrating AdminJS into our application. Within the <code>index.js</code> file, at the very top, we can add the following lines, which will load the necessary AdminJS modules:</p>
<pre class="source-code">
const AdminJS = require("adminjs");
const AdminJSExpress = require("@adminjs/express");
const AdminJSSequelize = require("@adminjs/sequelize");</pre>
<p>Below <a id="_idIndexMarker683"/>the <code>const models = require("./models");</code> line, we <a id="_idIndexMarker684"/>can now <a id="_idIndexMarker685"/>add the following line, which will register <a id="_idIndexMarker686"/>the Sequelize adapter for AdminJS:</p>
<pre class="source-code">
AdminJS.registerAdapter(AdminJSSequelize);</pre>
<p>Below <a id="_idIndexMarker687"/>that line, we can add our AdminJS instance <a id="_idIndexMarker688"/>and build the Express router:</p>
<pre class="source-code">
const adminJs = new AdminJS({
    databases: [models.sequelize],
    resources: [
        models.Airplane,
        models.BoardingTicket,
        models.Customer,
        models.FlightSchedule,
        models.Receipts,
    ],
    rootPath: '/admin',
});
  
const router = AdminJSExpress.buildRouter(adminJs);</pre>
<p><code>model.sequelize</code> is the instance that we created from <code>models/index.js</code>. This will instruct AdminJS to use Sequelize for our connection. The <code>resources</code> key holds a list of all of the models that should be exposed/applicable to AdminJS. <code>rootPath</code> will be AdminJS’ URL prefix for our web application.</p>
<p>Within <code>index.js</code>, below the <code>app.use(bodyParser.json({ type: 'application/json' }));</code> line, we can now add the AdminJS middleware to help integrate into Express:</p>
<pre class="source-code">
app.use(adminJs.options.rootPath, router);</pre>
<p>Now, when <a id="_idIndexMarker689"/>we launch our browser to <code>http://localhost:3000/admin</code>, we <a id="_idIndexMarker690"/>should see a <a id="_idIndexMarker691"/>similar page to <em class="italic">Figure 9.1</em>.</p>
<p class="callout-heading">Note</p>
<p class="callout">In the next chapter, <em class="italic">Deploying a Sequelize Application</em>, we will cover how to password-protect your application to prevent an unwanted guest from modifying the database.</p>
<div><div><img alt="Figure 9.1 – AdminJS welcome dashboard " height="1094" src="img/Figure_9.01_B17841.jpg" width="1655"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – AdminJS welcome dashboard</p>
<p>On the <a id="_idIndexMarker692"/>left-side navigation, we should see our database <a id="_idIndexMarker693"/>labeled as <strong class="bold">airline</strong>. Clicking on that link will reveal <a id="_idIndexMarker694"/>our exposed Sequelize models. Clicking on <strong class="bold">Airplanes</strong> will show a brief table with our model’s data, similar to <em class="italic">Figure 9.2</em>:</p>
<div><div><img alt="Figure 9.2 – The Airplanes model table " height="480" src="img/Figure_9.02_B17841.jpg" width="1038"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The Airplanes model table</p>
<p>There is a <a id="_idIndexMarker695"/>small caveat with AdminJS; at the time of <a id="_idIndexMarker696"/>writing, AdminJS does not support <a id="_idIndexMarker697"/>Sequelize’s virtual data types, which are <a id="_idIndexMarker698"/>not text values. Our <code>BoardingTickets</code> model <a id="_idIndexMarker699"/>contains a virtual type as a Boolean value. When <a id="_idIndexMarker700"/>we click on the <strong class="bold">Boarding Tickets</strong> menu item, we will be greeted with an error similar to <em class="italic">Figure 9.3</em>.</p>
<div><div><img alt="Figure 9.3 – AdminJS Displaying an Error From Virtual Types " height="921" src="img/Figure_9.03_B17841.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – AdminJS Displaying an Error From Virtual Types</p>
<p>To fix this <a id="_idIndexMarker701"/>issue, we can remove the property’s visibility <a id="_idIndexMarker702"/>by extending our options for AdminJS’ <a id="_idIndexMarker703"/>resources. In the new <code>AdminJS(…)</code> block, under <a id="_idIndexMarker704"/>the resources key, replace <a id="_idIndexMarker705"/>the <code>models.BoardingTicket</code> line <a id="_idIndexMarker706"/>with the following:</p>
<pre class="source-code">
        {
            resource: models.BoardingTicket,
            options: {
                properties: {
                    isEmployee: {
                        isVisible: false,
                    }
                }
            }
        },</pre>
<p>This will <a id="_idIndexMarker707"/>instruct AdminJS to disable the <code>isEmployee</code> attribute’s <a id="_idIndexMarker708"/>visibility to <code>false</code>. Now, when <a id="_idIndexMarker709"/>we refresh the page, the error <a id="_idIndexMarker710"/>should no longer be displayed, as shown <a id="_idIndexMarker711"/>in <em class="italic">Figure 9.4</em>.</p>
<div><div><img alt="Figure 9.4 – Resolving AdminJS’ error with virtual types " height="502" src="img/Figure_9.04_B17841.jpg" width="1065"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Resolving AdminJS’ error with virtual types</p>
<p class="callout-heading">Note</p>
<p class="callout">For a complete reference on what kind of settings are tunable for AdminJS’ property configuration, you <a id="_idIndexMarker712"/>can refer to the API documentation here: <a href="https://docs.adminjs.co/PropertyOptions.xhtml">https://docs.adminjs.co/PropertyOptions.xhtml</a>.</p>
<p>AdminJS will also <a id="_idIndexMarker713"/>automatically integrate into Sequelize’s validation system. So, if we were to edit one of our flight schedules and entered an invalid airport, we would be presented with an error like the one shown in <em class="italic">Figure 9.5</em>.</p>
<div><div><img alt="Figure 9.5 – AdminJS validation integration " height="821" src="img/Figure_9.05_B17841.jpg" width="997"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – AdminJS validation integration</p>
<p>When <a id="_idIndexMarker714"/>we initialized our application with AdminJS, you <a id="_idIndexMarker715"/>may have noticed a new folder was <a id="_idIndexMarker716"/>automatically created called <code>.adminjs</code> within <a id="_idIndexMarker717"/>the project’s root directory. The files <a id="_idIndexMarker718"/>within this directory are local to your instance <a id="_idIndexMarker719"/>only and are neither applicable to deployments nor to other team members.</p>
<p class="callout-heading">Note</p>
<p class="callout">You may have noticed a <code>.gitignore</code> file that contains <code>.adminjs</code> as part of its content. The <code>.gitignore</code> file is for preventing folders, files, matching paths, and so on from being committed within the git’s object space. If you are working within a project using version control, such as Git, then it is recommended to ignore the <code>.adminjs</code> directory from being committed. </p>
<p>Whether adding, deleting, modifying, or validating records, AdminJS offers a very convenient way of managing models. Sometimes, convenience can get in the way, and we would need to view or modify our records in ways that AdminJS cannot. One way to achieve this is to use a GraphQL library.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor181"/>Integrating Sequelize with GraphQL</h1>
<p>GraphQL offers a few <a id="_idIndexMarker720"/>advantages over alternatives such as REST. We can declare data <a id="_idIndexMarker721"/>shapes with strong types, associate <a id="_idIndexMarker722"/>relational hierarchies, and reduce the number of requests required when querying data.</p>
<p>GraphQL is a query language that is data storage-agnostic. You can associate a GraphQL model with a typical <strong class="bold">Database Management System</strong> (<strong class="bold">DBMS</strong>), or just as an abstraction for model validation and shaping.</p>
<p>Here is an example of a GraphQL schema definition:</p>
<pre class="source-code">
type User {
  name: String!
  bio: String
  roles: [Role!]!
}
type Role {
  name: String!
}</pre>
<p>The <code>User</code> type has three attributes, with the <code>name</code> and <code>roles</code> being required (indicated with the exclamation mark), while the <code>bio</code> definition is an optional string. Within this example, the <code>User</code> type’s roles attributes will always return an array with zero or more items from the exclamation mark that sits outside of the brackets (<code>[…]!</code>), and the other exclamation mark indicates that each item within the set will be non-nullable and return a <code>Role</code> type.</p>
<p>A type just references an object, but there are two types that are reserved for GraphQL itself, the <code>Query</code> and the <code>Mutation</code> type. The query types are reserved for defining input parameters and relations, and associations, of a collection of types. <code>Mutation</code> types are utilized when we want to modify our data. You can think of queries as <code>GET</code> requests and mutation queries as a combination of <code>POST</code> and <code>PUT</code> HTTP methods. </p>
<p>To query the previous example’s types, we will invoke a query type like so:</p>
<pre class="source-code">
type Query {
  query usersByName($name: String!) {
    users(name: $name) {
      name
      bio
      roles {
        name
      }
    }
  }
}</pre>
<p>This example <a id="_idIndexMarker723"/>will generate a function called <code>usersByName</code> with <a id="_idIndexMarker724"/>an input parameter of a required string. The function would yield any <code>User</code> types whose name matches the <code>$name</code> variable. Each record would return the name, bio, and an array of roles associated with that user. The data shape that is returned would look similar to the following:</p>
<pre class="source-code">
{
    "data": {
        "usersByName": {
            "users": [
                {
                    "name": "Bob",
                    "bio": "Programmer",
                    "roles": []
                },
                {
                    "name": "Bob",
                    "bio": "Lead",
                    "roles": [{"name": "Admin"}]
                }
            ]
        }
    }
}</pre>
<p>Mick Hansen, one of the original maintainers of Sequelize, created an NPM package called <a id="_idIndexMarker725"/>sequelize-graphql that will help bridge our <a id="_idIndexMarker726"/>models with a GraphQL type definition. To get started on using GraphQL with Sequelize in our current project, we will need to install the following NPM modules:</p>
<pre>npm i --save graphql-sequelize @graphql-yoga/node graphql-relay</pre>
<p>The <code>graphql-sequelize</code> library may require old, or conflicting, versions for the <code>graphql</code> and <code>graphql-relay</code> library. We would need to modify our <code>override</code> object within the <em class="italic">package.json</em> file to the following to resolve those issues:</p>
<pre class="source-code">
  "overrides": {
    "graphql": "^15",
    "graphql-relay": "^0.10.0",
    "sequelize": "^6"
  },</pre>
<p>The <code>graphql-yoga</code> package is a <a id="_idIndexMarker727"/>GraphQL server framework <a id="_idIndexMarker728"/>dedicated to performance and ease of use. Its GitHub repository can be found here: <a href="https://github.com/dotansimha/graphql-yoga">https://github.com/dotansimha/graphql-yoga</a>. </p>
<p>The first step is to add a static constant called <code>tableName</code> for each model, with the value being the model’s table name for the <code>sequelize-graphql</code> plugin. </p>
<p>We will start with the <code>models/airplane.js</code> file; under the <code>class Airplane extends Model</code> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'Airplanes';</pre>
<p>Within <code>models/boardingticket.js</code>, under the <code>class BoardingTicket extends Model</code> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'BoardingTickets';</pre>
<p>Within <code>models/customer.js</code>, under the <code>class Customer extends Model</code> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'Customers';</pre>
<p>Within <code>models/flightschedule.js</code>, under the <code>class FlightSchedule extends Model</code> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'FlightSchedules';</pre>
<p>Within <code>models/receipts.js</code>, under the <code>class Receipts extends Model</code> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'Receipts';</pre>
<p>Now, we can <a id="_idIndexMarker729"/>begin with declaring our type definitions <a id="_idIndexMarker730"/>and query resolver patterns for the GraphQL server. Within the project’s root directory, add a new file called <code>graphql.js</code>, starting with the following <code>require</code> commands:</p>
<pre class="source-code">
const { createServer } = require("@graphql-yoga/node");
const { resolver } = require("graphql-sequelize");
const models = require("./models");</pre>
<p>Next, we want to start defining our query interface for when we want to execute queries later. You may think of this as something similar to a header file in a “C” language project:</p>
<pre class="source-code">
const typeDefs = `
  type Query {
    airplane(id: ID!): Airplane
    airplanes: [Airplane]
    boardingTicket(id: ID!): BoardingTicket
    boardingTickets: [BoardingTicket]
    customer(id: ID!): Customer
    customers: [Customer]
    flightSchedule(id: ID!): FlightSchedule
    flightSchedules: [FlightSchedule]
    receipt(id: ID!): Receipt
    receipts: [Receipt]
  }</pre>
<p>While <a id="_idIndexMarker731"/>keeping the <code>typeDef</code> variable open, we can <a id="_idIndexMarker732"/>add a simple <code>Mutation</code> query example:</p>
<pre class="source-code">
  type Mutation {
    upsertAirplane(name: String!, data: AirplaneInput!): 
    Airplane
  }
  input AirplaneInput {
    planeModel: String
    totalSeats: Int
  }
  type Airplane {
    id: ID!
    planeModel: String
    totalSeats: Int
    schedules: [FlightSchedule]
  }</pre>
<p>Next, we <a id="_idIndexMarker733"/>can add our model schematics to the <a id="_idIndexMarker734"/>definitions:</p>
<pre class="source-code">
  type Airplane {
    id: ID!
    planeModel: String
    totalSeats: Int
    schedules: [FlightSchedule]
  }
  type BoardingTicket {
    id: ID!
    seat: String
    owner: Customer
  }
  type Customer {
    id: ID!
    name: String
    email: String
    tickets: [BoardingTicket]
  }
  type FlightSchedule {
    id: ID!
    originAirport: String
    destinationAirport: String
    departureTime: String
  }
  type Receipt {
    id: ID!
    receipt: String
  }
`;</pre>
<p>Next, we will <a id="_idIndexMarker735"/>want to set our resolvers to associate the <a id="_idIndexMarker736"/>type definitions with the correct Sequelize model associations. Let’s start with the query resolvers:</p>
<pre class="source-code">
const resolvers = {
  Query: {
    airplane: resolver(models.Airplane),
    airplanes: resolver(models.Airplane),
    boardingTicket: resolver(models.BoardingTicket),
    boardingTickets: resolver(models.BoardingTicket),
    customer: resolver(models.Customer),
    customers: resolver(models.Customer),
    flightSchedule: resolver(models.FlightSchedule),
    flightSchedules: resolver(models.FlightSchedule),
    receipt: resolver(models.Receipts),
    receipts: resolver(models.Receipts),
  },</pre>
<p>Next, we <a id="_idIndexMarker737"/>can add <a id="_idIndexMarker738"/>a <code>Mutation</code> resolver example:</p>
<pre class="source-code">
  Mutation: {
    async upsertAirplane(parent, args, ctx, info) {
        const [airplane, created] = await models.Airplane.
        findOrCreate({
            where: {
                planeModel: args.name
            },
            defaults: (args.data || {}),
        });
        // if we created the record we do not need to 
           update it
        if (created) {
            return airplane;
        }
        if (typeof args.data !== "undefined") {
            await airplane.update(args.data);
        }
        return airplane;
    }
  },</pre>
<p>Then, we can resolve our model associations and close the variable:</p>
<pre class="source-code">
  Airplane: {
    schedules: resolver(models.Airplane.FlightSchedules),
  },
  BoardingTicket: {
    owner: resolver(models.BoardingTicket.Customer),
  },
  Customer: {
      tickets: resolver(models.Customer.BoardingTickets),
  },
};</pre>
<p>Finally, we <a id="_idIndexMarker739"/>can create our server with the schema <a id="_idIndexMarker740"/>definitions and export it:</p>
<pre class="source-code">
const server = new createServer({
  schema: {
    typeDefs,
    resolvers,
  }
});
module.exports = { server };</pre>
<p>Within the <code>index.js</code> file, in the project’s root directory, we can add the following line under our <code>var models = require("./models")</code> line:</p>
<pre class="source-code">
const { server } = require("./graphql");</pre>
<p>After we have mounted the AdminJS router, <code>app.use(adminJs.options.rootPath, router)</code>, add the following line:</p>
<pre class="source-code">
app.use('/graphql', server);</pre>
<p>After we have finished our <code>index.js</code> modifications, we can start our application:</p>
<pre>npm run start</pre>
<p>Once the server is <a id="_idIndexMarker741"/>up and running, we can access GraphQL Yoga’s <a id="_idIndexMarker742"/>dashboard interface (<em class="italic">Figure 9.6</em>) by visiting the following URL within a browser: <a href="http://localhost:3000/graphql"><code>http://localhost:3000/graphql</code></a>: </p>
<p class="callout-heading">Note</p>
<p class="callout">In a production deployment, we would either want to disable this route based on the value of <code>process.env.NODE_ENV</code> or add authentication-based middleware to the <code>/graphql</code> route in <code>index.js</code>.</p>
<div><div><img alt=" Figure 9.6 – The GraphQL Yoga dashboard " height="794" src="img/Figure_9.06_B17841.jpg" width="936"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 9.6 – The GraphQL Yoga dashboard</p>
<p>We can test our <a id="_idIndexMarker743"/>queries and resolvers by executing queries <a id="_idIndexMarker744"/>within this dashboard. Remove all of the current content on the notepad section of the dashboard and enter the following:</p>
<pre class="source-code">
{
  airplanes {
    id
    planeModel
    totalSeats
  }
}</pre>
<p>There should be a “play button” at the top that will execute your query (alternatively, hitting the <em class="italic">Ctrl</em> and <em class="italic">Enter</em> keys simultaneously will do the same), which should yield results similar to the following:</p>
<pre class="source-code">
{
  "data": {
    "airplanes": [
      {
        "id": "1",
        "planeModel": "A320",
        "totalSeats": 150
      }
    ]
  }
}</pre>
<p>If we <a id="_idIndexMarker745"/>wanted to update our airplane’s model <a id="_idIndexMarker746"/>name, we could use a <code>mutation</code> query:</p>
<pre class="source-code">
mutation {
  upsertAirplane(name:"A320", data:{planeModel:"A321"}) {
    planeModel
  }
}</pre>
<p>This will return the following result:</p>
<pre class="source-code">
{
  "data": {
    "upsertAirplane": {
      "planeModel": "A321"
    }
  }
}</pre>
<p>Within the GraphQL Yoga dashboard, there should be a <strong class="bold">&lt; Docs</strong> link at the top right (refer to <em class="italic">Figure 9.6</em>), which will <a id="_idIndexMarker747"/>open a drawer panel. There will <a id="_idIndexMarker748"/>then be a <strong class="bold">Query</strong> link, which will expose our queries and type definitions. This should help make queries easier within the dashboard.</p>
<p>Now that we have established a connection between a GraphQL server and our Sequelize models and integrated another adapter that provides an easy-to-use admin dashboard, it is time for us to build our own adapter for Sequelize.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor182"/>Creating our own adapter</h1>
<p>Sequelize is fairly extensible through its class properties, lifecycle events, and configurations. For the example of <a id="_idIndexMarker749"/>creating our own adapter for Sequelize, we will integrate a new data type that will automatically convert values, using a specific set of rules, to what is called a “slug URL.” A slug URL usually consists of hyphens instead of spaces, lowercase <a id="_idIndexMarker750"/>lettering, and removes all special characters.</p>
<p>Let’s look at <a id="_idIndexMarker751"/>the steps to create our adapter: </p>
<ol>
<li>We’ll begin by installing any necessary packages. Keeping a copy of a character map of special characters can be a daunting task, so we will use an <code>npm</code> package called, <code>github-slugger</code> to help us:<pre><strong class="bold">npm i --save github-slugger</strong></pre></li>
<li>Next, we will want to create a couple of directories and a file with <code>plugins/slug/index.js</code> as the path from the project’s root directory. Before we can begin coding within that file, we will need to add the <code>slug</code> column to a table within the database. We will use the Airplane model for this example; using the <code>sequelize-cli</code> command, we can create a new migration event:<pre><strong class="bold">sequelize-cli migration:create --name add_slug_to_airplanes</strong></pre></li>
</ol>
<p>This command should generate a new file within the <code>migrations</code> directory ending in <code>add_slug_to_airplanes.js</code>. </p>
<ol>
<li value="3">Replace <a id="_idIndexMarker752"/>the file’s contents with the following:<pre>'use strict';
module.exports = {
  up: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.addColumn(
      'Airplanes',
      'slug',
      {
        type: Sequelize.STRING,
        allowNull: true,
      },
    );
    await queryInterface.addIndex(
      'Airplanes',
      ['slug'],
      {
        name: 'airplanes_slug_uniq_idx',
        unique: true,
      },
    );
  },
  down: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.removeIndex('Airplanes', 
    'airplanes_slug_uniq_idx');
    await queryInterface.removeColumn('Airplanes', 
    'slug');
  },
};</pre></li>
</ol>
<p>This will instruct Sequelize to create a new column in the <code>Airplanes</code> table called <code>slug</code> as a text value, along with a unique index that is associated with that column. </p>
<ol>
<li value="4">To perform the <a id="_idIndexMarker753"/>latest migration, we will run the <code>db:migrate</code> command:<pre><strong class="bold">sequelize-cli db:migrate </strong></pre></li>
</ol>
<p>After the column has been added to the Airplanes table, we will need to add the attribute manually to the <code>models/airplanes.js</code> file. </p>
<ol>
<li value="5">Replace the <code>totalSeats</code> attribute block with the following:<pre>    totalSeats: {
      type: DataTypes.INTEGER,
      validate: {
        min: {
          args: 1,
          msg: 'A plane must have at least one seat'
        }
      }
    },
    slug: {
      type: DataTypes.STRING,
      unique: true,
    },</pre></li>
<li>In the <code>graphql.js</code> file, we will want to add the <code>slug</code> column to the <code>Airplane</code> type definition as well:<pre>  type Airplane {
    id: ID!
    planeModel: String
    totalSeats: Int
<strong class="bold">    slug: String</strong>
    schedules: [FlightSchedule]
  }</pre></li>
<li>Now, we can <a id="_idIndexMarker754"/>begin editing the <code>plugins/slug/index.js</code> file, starting with the following lines of code:<pre>const slug = require("github-slugger").slug;
class SlugPlugin {
    use(model, options) {
        const DEFAULTS = {
            column: 'slug',
            source: 'name',
            transaction: null,
        };
        options = {...DEFAULTS, ...options};</pre></li>
</ol>
<p>This will create a <code>SlugPlugin</code> class with one method called <code>use</code>. The input parameters are the <code>model</code> class, a couple of options, and their defaults. </p>
<ol>
<li value="8">Underneath <a id="_idIndexMarker755"/>those blocks, we will create our <code>generateSlug</code> method:<pre>        // concat the fields for the slug
        function generateSlug(instance, fields) {
            return slug(fields.map((field) =&gt; 
            instance[field]));
        }</pre></li>
<li>Next, we will want to ensure that a slug does not exist prior to updating. We will want to create some sort of finder method and an increment method for funding a unique value. We can start with the finder method shown here:<pre>        async function findSlug(slug) {
            return await model.findOne({
                where: {
                    [options.column]: slug
                },
                transaction: options.transaction || 
                null,
            });
        }</pre></li>
<li>Now for the incremental method; this function will run in a loop until a unique match is found using a combination of the slug’s value and an integer. Ideally, in a real production environment, we would come up with a cleverer way of finding unique values (for example, appending a hash instead of an incremental variable), but for brevity, we will create this function:<pre>        async function incrementSuffix(slugVal) {
            let found = false;
            let cnt = 1;
            let suffix = "";
            while (!found) {
                suffix = `${slugVal}-${cnt}`;
                found = await findSlug(suffix);
                cnt++;
            }
            return suffix;
        }</pre></li>
<li>We can now begin <a id="_idIndexMarker756"/>creating the main event function. First, we will check whether our slug’s applicable attributes (the <code>planeModel</code> attribute, in this example) have been modified. If they have not been changed, then we will skip the entire event, since there is nothing to be done:<pre>        async function onSaveOrUpdate(instance) {
            const changed = options.source.
            some(function (field) {
                return instance.changed(field);
            });
            if (!changed) {
                return instance;
            }</pre></li>
<li>Next, we will compare the current value with the newly generated value. If they are the same (for example, a letter casing change), then simply skip the event:<pre>            let curVal = instance[options.column];
            let newVal = generateSlug(instance, 
            options.source);
            if (curVal !== null &amp;&amp; curVal == newVal) {
                return instance;
            }</pre></li>
<li>Now, we can <a id="_idIndexMarker757"/>check and see whether the newly generated value is unique and, if so, set the instance’s <code>slug</code> attribute to that value and return the instance:<pre>            let slugExist = await findSlug(newVal);
            if (!slugExist) {
                instance[options.column] = newVal;
                return instance;
            }</pre></li>
<li>Otherwise, we will want to use our <code>incrementSuffix</code> method and return the instance afterward:<pre>            newVal = await incrementSuffix(newVal);
            instance[options.column] = newVal;
            return instance;</pre></li>
<li>Afterward, we can <a id="_idIndexMarker758"/>close our <code>event</code> method, attach the method to the model’s lifecycle events, and close the <code>SlugPlugin</code> class:<pre>        }
        // use the lifecycle events for invoking the 
           onSaveOrUpdate event
        model.addHook('beforeCreate', onSaveOrUpdate);
        model.addHook('beforeUpdate', onSaveOrUpdate);
    }
}</pre></li>
<li>Finally, we can export an instance of our plugin as well as the class definition itself:<pre>const instance = new SlugPlugin();
module.exports = instance;
module.exports.SlugPlugin = instance;</pre></li>
<li>Within the <code>models/airplanes.js</code> file, we will want to integrate our new plugin with the model. At the top of the file, we can include the plugin like so:<pre>const slugPlugin = require('../plugins/slug');</pre></li>
<li>After the model’s definition, and before the <code>return Airplane</code> line, we can associate the <code>slug</code> plugin with the model:<pre>  slugPlugin.use(Airplane, {
    source: ['planeModel']
  });</pre></li>
</ol>
<p>This will tell our plugin to use the <code>planeModel</code> attribute as the source field when generating the slug’s value.</p>
<ol>
<li value="19">In order to test our <a id="_idIndexMarker759"/>plugin, we can go to our GraphQL dashboard located at <code>http://localhost:3000/graphql</code> and enter the following command:<pre>mutation {
  upsertAirplane(name:"A321", data:{planeModel:
  "A321 B"}) {
    planeModel
    totalSeats
    slug
  }
}</pre></li>
</ol>
<p>This will find, and update, our A321 airplane’s <code>planeModel</code> value along with setting a <code>slug</code> value, as shown here:</p>
<pre>{
  "data": {
    "upsertAirplane": {
      "planeModel": "A321 B",
      "totalSeats": 150,
      "slug": "a321-b"
    }
  }
}</pre>
<p>This finalizes our custom <a id="_idIndexMarker760"/>Sequelize adapter section. You can use the <code>plugins/slug/index.js</code> adapter in any other project using Sequelize. Feel free to add <code>slug</code> columns to other models, but make sure to follow the necessary steps:</p>
<ol>
<li value="1">Generate a migration file and migrate the column changes to the database.</li>
<li>Update the <code>graphql.js</code> file with the appropriate type definitions.</li>
<li>Include the <code>plugin</code> library within the applicable models’ files and associate the plugin with the models using the <code>use</code> method.</li>
</ol>
<h1 id="_idParaDest-174"><a id="_idTextAnchor183"/>Summary</h1>
<p>In this chapter, we went through the process of installing a dashboard that integrates with a database, integrating GraphQL using a third-party library, and creating our own Sequelize adapter that will automatically add slug values.</p>
<p>In the next chapter, we will start developing our website to be more production-ready and feature-complete. Some of these features include listing schedules, ordering tickets, and entering customer information.</p>
</div>
</div></body></html>