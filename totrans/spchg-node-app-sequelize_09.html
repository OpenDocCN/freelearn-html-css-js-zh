<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer052">
<h1 class="chapter-number" id="_idParaDest-168"><a id="_idTextAnchor177"/>9</h1>
<h1 id="_idParaDest-169"><a id="_idTextAnchor178"/>Using and Creating Adapters</h1>
<p>After developing for several years, you may have a set of common utility functions, a collection of other frameworks, and a library of your own scripts. Maintaining all of these moving parts may become too entropic for an enterprise project or a fleet of microservices. We can restructure our common code into a more generic interface, or pattern, and reclassify those scripts as an “adapter” (also known as a “plugin”).</p>
<p>Using adapters can save us development time, prevent us from repeating ourselves, and help centralize collaboration by maintaining its code base. A few examples of an adapter would be transforming text into a specific character ruleset, scaffolding a sidecar project such as an administrative dashboard, or providing a caching layer.</p>
<p>Sequelize offers a way to extend its behavior by allowing the integration of adapters and plugins through a mixture of object prototyping and its lifecycle events. Once we become familiar with using pre-existing adapters, we will create our own adapter/extension for Sequelize that will generate “slug URLs” for each instance within a model.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Installing, configuring, and integrating AdminJS with Sequelize</li>
<li>Integrating Sequelize with GraphQL</li>
<li>Creating our own adapter</li>
</ul>
<h1 id="_idParaDest-170"><a id="_idTextAnchor179"/>Technical requirements</h1>
<p>You can find the code files of this chapter on GitHub at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch9">https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch9</a></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor180"/>Installing, configuring, and integrating AdminJS with Sequelize</h1>
<p>AdminJS is an <a id="_idIndexMarker672"/>administrative dashboard that can integrate into various <a id="_idIndexMarker673"/>database management systems, ORMs, and web <a id="_idIndexMarker674"/>frameworks. In addition to AdminJS being <a id="_idIndexMarker675"/>able to generate charts and tables for <a id="_idIndexMarker676"/>your data, it can also create roles and access <a id="_idIndexMarker677"/>control lists, export <a id="_idIndexMarker678"/>reports, and centralize <a id="_idIndexMarker679"/>the modeling of <strong class="bold">Create, Read, Update, Delete</strong> (<strong class="bold">CRUD</strong>) operations.</p>
<p>Avalon Airline’s investors want us to have a dashboard that allows us to manage flights and tickets, and show basic reporting numbers, such as the total number of planes and gross profit. AdminJS seems to be a perfect fit here; we can begin by installing the necessary components within Avalon Airline’s root directory.</p>
<p>Within the terminal, we can install the packages by executing the following command:</p>
<p class="source-code">npm i adminjs @adminjs/express express-formidable @adminjs/sequelize tslib express-session</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">express-formidable</strong> module is required as a peer dependency for the <strong class="source-inline">@adminjs/express</strong> package. The <strong class="source-inline">formidable</strong> module is a fast-streaming multipart parser <a id="_idIndexMarker680"/>with a low memory footprint. For more information on <a id="_idIndexMarker681"/>formidable and its capabilities, you can refer to its GitHub repository, located at <a href="https://github.com/node-formidable/formidable">https://github.com/node-formidable/formidable</a>.</p>
<p>Depending on which version of <strong class="source-inline">npm</strong> you have installed (eight or above), and which version of <strong class="source-inline">@adminjs/sequelize</strong> is installed, you may run into legacy peer dependency issues. Due to one of our packages (<strong class="source-inline">@adminjs/sequelize</strong>) requiring an old module path for Sequelize (<strong class="source-inline">sequelize</strong> versus <strong class="source-inline">@sequelize/core</strong>) we will run into missing dependency issues which could be resolved by enabling <strong class="source-inline">legacy-peer-deps</strong> or using the <strong class="source-inline">override</strong> option.</p>
<p>Typically, we would want to avoid using the <strong class="source-inline">legacy-peer-deps</strong> option to avoid breaking changes. We could <a id="_idIndexMarker682"/>use the <strong class="source-inline">override</strong> option in <em class="italic">package.json</em> for resolving packages which is explained more at <a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides">https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides</a>. Within the <em class="italic">package.json</em> file, below the <strong class="source-inline">scripts</strong> block, we will want to add another block with the following:</p>
<pre class="source-code">
  "overrides": {
    "sequelize": "^6"
  },</pre>
<p>If the previous npm installation step failed, we can retry after the <em class="italic">package.json</em> updates which will resolve <strong class="source-inline">@adminjs/sequelize</strong> package’s <strong class="source-inline">sequelize</strong> version requirements.</p>
<p>Now, we can start integrating AdminJS into our application. Within the <strong class="source-inline">index.js</strong> file, at the very top, we can add the following lines, which will load the necessary AdminJS modules:</p>
<pre class="source-code">
const AdminJS = require("adminjs");
const AdminJSExpress = require("@adminjs/express");
const AdminJSSequelize = require("@adminjs/sequelize");</pre>
<p>Below <a id="_idIndexMarker683"/>the <strong class="source-inline">const models = require("./models");</strong> line, we <a id="_idIndexMarker684"/>can now <a id="_idIndexMarker685"/>add the following line, which will register <a id="_idIndexMarker686"/>the Sequelize adapter for AdminJS:</p>
<pre class="source-code">
AdminJS.registerAdapter(AdminJSSequelize);</pre>
<p>Below <a id="_idIndexMarker687"/>that line, we can add our AdminJS instance <a id="_idIndexMarker688"/>and build the Express router:</p>
<pre class="source-code">
const adminJs = new AdminJS({
    databases: [models.sequelize],
    resources: [
        models.Airplane,
        models.BoardingTicket,
        models.Customer,
        models.FlightSchedule,
        models.Receipts,
    ],
    rootPath: '/admin',
});
  
const router = AdminJSExpress.buildRouter(adminJs);</pre>
<p><strong class="source-inline">model.sequelize</strong> is the instance that we created from <strong class="source-inline">models/index.js</strong>. This will instruct AdminJS to use Sequelize for our connection. The <strong class="source-inline">resources</strong> key holds a list of all of the models that should be exposed/applicable to AdminJS. <strong class="source-inline">rootPath</strong> will be AdminJS’ URL prefix for our web application.</p>
<p>Within <strong class="source-inline">index.js</strong>, below the <strong class="source-inline">app.use(bodyParser.json({ type: 'application/json' }));</strong> line, we can now add the AdminJS middleware to help integrate into Express:</p>
<pre class="source-code">
app.use(adminJs.options.rootPath, router);</pre>
<p>Now, when <a id="_idIndexMarker689"/>we launch our browser to <strong class="source-inline">http://localhost:3000/admin</strong>, we <a id="_idIndexMarker690"/>should see a <a id="_idIndexMarker691"/>similar page to <em class="italic">Figure 9.1</em>.</p>
<p class="callout-heading">Note</p>
<p class="callout">In the next chapter, <em class="italic">Deploying a Sequelize Application</em>, we will cover how to password-protect your application to prevent an unwanted guest from modifying the database.</p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 9.1 – AdminJS welcome dashboard " height="1094" src="image/Figure_9.01_B17841.jpg" width="1655"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – AdminJS welcome dashboard</p>
<p>On the <a id="_idIndexMarker692"/>left-side navigation, we should see our database <a id="_idIndexMarker693"/>labeled as <strong class="bold">airline</strong>. Clicking on that link will reveal <a id="_idIndexMarker694"/>our exposed Sequelize models. Clicking on <strong class="bold">Airplanes</strong> will show a brief table with our model’s data, similar to <em class="italic">Figure 9.2</em>:</p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 9.2 – The Airplanes model table " height="480" src="image/Figure_9.02_B17841.jpg" width="1038"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The Airplanes model table</p>
<p>There is a <a id="_idIndexMarker695"/>small caveat with AdminJS; at the time of <a id="_idIndexMarker696"/>writing, AdminJS does not support <a id="_idIndexMarker697"/>Sequelize’s virtual data types, which are <a id="_idIndexMarker698"/>not text values. Our <strong class="source-inline">BoardingTickets</strong> model <a id="_idIndexMarker699"/>contains a virtual type as a Boolean value. When <a id="_idIndexMarker700"/>we click on the <strong class="bold">Boarding Tickets</strong> menu item, we will be greeted with an error similar to <em class="italic">Figure 9.3</em>.</p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 9.3 – AdminJS Displaying an Error From Virtual Types " height="921" src="image/Figure_9.03_B17841.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – AdminJS Displaying an Error From Virtual Types</p>
<p>To fix this <a id="_idIndexMarker701"/>issue, we can remove the property’s visibility <a id="_idIndexMarker702"/>by extending our options for AdminJS’ <a id="_idIndexMarker703"/>resources. In the new <strong class="source-inline">AdminJS(…)</strong> block, under <a id="_idIndexMarker704"/>the resources key, replace <a id="_idIndexMarker705"/>the <strong class="source-inline">models.BoardingTicket</strong> line <a id="_idIndexMarker706"/>with the following:</p>
<pre class="source-code">
        {
            resource: models.BoardingTicket,
            options: {
                properties: {
                    isEmployee: {
                        isVisible: false,
                    }
                }
            }
        },</pre>
<p>This will <a id="_idIndexMarker707"/>instruct AdminJS to disable the <strong class="source-inline">isEmployee</strong> attribute’s <a id="_idIndexMarker708"/>visibility to <strong class="source-inline">false</strong>. Now, when <a id="_idIndexMarker709"/>we refresh the page, the error <a id="_idIndexMarker710"/>should no longer be displayed, as shown <a id="_idIndexMarker711"/>in <em class="italic">Figure 9.4</em>.</p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 9.4 – Resolving AdminJS’ error with virtual types " height="502" src="image/Figure_9.04_B17841.jpg" width="1065"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Resolving AdminJS’ error with virtual types</p>
<p class="callout-heading">Note</p>
<p class="callout">For a complete reference on what kind of settings are tunable for AdminJS’ property configuration, you <a id="_idIndexMarker712"/>can refer to the API documentation here: <a href="https://docs.adminjs.co/PropertyOptions.xhtml">https://docs.adminjs.co/PropertyOptions.xhtml</a>.</p>
<p>AdminJS will also <a id="_idIndexMarker713"/>automatically integrate into Sequelize’s validation system. So, if we were to edit one of our flight schedules and entered an invalid airport, we would be presented with an error like the one shown in <em class="italic">Figure 9.5</em>.</p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 9.5 – AdminJS validation integration " height="821" src="image/Figure_9.05_B17841.jpg" width="997"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – AdminJS validation integration</p>
<p>When <a id="_idIndexMarker714"/>we initialized our application with AdminJS, you <a id="_idIndexMarker715"/>may have noticed a new folder was <a id="_idIndexMarker716"/>automatically created called <strong class="source-inline">.adminjs</strong> within <a id="_idIndexMarker717"/>the project’s root directory. The files <a id="_idIndexMarker718"/>within this directory are local to your instance <a id="_idIndexMarker719"/>only and are neither applicable to deployments nor to other team members.</p>
<p class="callout-heading">Note</p>
<p class="callout">You may have noticed a <strong class="source-inline">.gitignore</strong> file that contains <strong class="source-inline">.adminjs</strong> as part of its content. The <strong class="source-inline">.gitignore</strong> file is for preventing folders, files, matching paths, and so on from being committed within the git’s object space. If you are working within a project using version control, such as Git, then it is recommended to ignore the <strong class="source-inline">.adminjs</strong> directory from being committed. </p>
<p>Whether adding, deleting, modifying, or validating records, AdminJS offers a very convenient way of managing models. Sometimes, convenience can get in the way, and we would need to view or modify our records in ways that AdminJS cannot. One way to achieve this is to use a GraphQL library.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor181"/>Integrating Sequelize with GraphQL</h1>
<p>GraphQL offers a few <a id="_idIndexMarker720"/>advantages over alternatives such as REST. We can declare data <a id="_idIndexMarker721"/>shapes with strong types, associate <a id="_idIndexMarker722"/>relational hierarchies, and reduce the number of requests required when querying data.</p>
<p>GraphQL is a query language that is data storage-agnostic. You can associate a GraphQL model with a typical <strong class="bold">Database Management System</strong> (<strong class="bold">DBMS</strong>), or just as an abstraction for model validation and shaping.</p>
<p>Here is an example of a GraphQL schema definition:</p>
<pre class="source-code">
type User {
  name: String!
  bio: String
  roles: [Role!]!
}
type Role {
  name: String!
}</pre>
<p>The <strong class="source-inline">User</strong> type has three attributes, with the <strong class="source-inline">name</strong> and <strong class="source-inline">roles</strong> being required (indicated with the exclamation mark), while the <strong class="source-inline">bio</strong> definition is an optional string. Within this example, the <strong class="source-inline">User</strong> type’s roles attributes will always return an array with zero or more items from the exclamation mark that sits outside of the brackets (<strong class="source-inline">[…]!</strong>), and the other exclamation mark indicates that each item within the set will be non-nullable and return a <strong class="source-inline">Role</strong> type.</p>
<p>A type just references an object, but there are two types that are reserved for GraphQL itself, the <strong class="source-inline">Query</strong> and the <strong class="source-inline">Mutation</strong> type. The query types are reserved for defining input parameters and relations, and associations, of a collection of types. <strong class="source-inline">Mutation</strong> types are utilized when we want to modify our data. You can think of queries as <strong class="source-inline">GET</strong> requests and mutation queries as a combination of <strong class="source-inline">POST</strong> and <strong class="source-inline">PUT</strong> HTTP methods. </p>
<p>To query the previous example’s types, we will invoke a query type like so:</p>
<pre class="source-code">
type Query {
  query usersByName($name: String!) {
    users(name: $name) {
      name
      bio
      roles {
        name
      }
    }
  }
}</pre>
<p>This example <a id="_idIndexMarker723"/>will generate a function called <strong class="source-inline">usersByName</strong> with <a id="_idIndexMarker724"/>an input parameter of a required string. The function would yield any <strong class="source-inline">User</strong> types whose name matches the <strong class="source-inline">$name</strong> variable. Each record would return the name, bio, and an array of roles associated with that user. The data shape that is returned would look similar to the following:</p>
<pre class="source-code">
{
    "data": {
        "usersByName": {
            "users": [
                {
                    "name": "Bob",
                    "bio": "Programmer",
                    "roles": []
                },
                {
                    "name": "Bob",
                    "bio": "Lead",
                    "roles": [{"name": "Admin"}]
                }
            ]
        }
    }
}</pre>
<p>Mick Hansen, one of the original maintainers of Sequelize, created an NPM package called <a id="_idIndexMarker725"/>sequelize-graphql that will help bridge our <a id="_idIndexMarker726"/>models with a GraphQL type definition. To get started on using GraphQL with Sequelize in our current project, we will need to install the following NPM modules:</p>
<p class="source-code">npm i --save graphql-sequelize @graphql-yoga/node graphql-relay</p>
<p>The <strong class="source-inline">graphql-sequelize</strong> library may require old, or conflicting, versions for the <strong class="source-inline">graphql</strong> and <strong class="source-inline">graphql-relay</strong> library. We would need to modify our <strong class="source-inline">override</strong> object within the <em class="italic">package.json</em> file to the following to resolve those issues:</p>
<pre class="source-code">
  "overrides": {
    "graphql": "^15",
    "graphql-relay": "^0.10.0",
    "sequelize": "^6"
  },</pre>
<p>The <strong class="source-inline">graphql-yoga</strong> package is a <a id="_idIndexMarker727"/>GraphQL server framework <a id="_idIndexMarker728"/>dedicated to performance and ease of use. Its GitHub repository can be found here: <a href="https://github.com/dotansimha/graphql-yoga">https://github.com/dotansimha/graphql-yoga</a>. </p>
<p>The first step is to add a static constant called <strong class="source-inline">tableName</strong> for each model, with the value being the model’s table name for the <strong class="source-inline">sequelize-graphql</strong> plugin. </p>
<p>We will start with the <strong class="source-inline">models/airplane.js</strong> file; under the <strong class="source-inline">class Airplane extends Model</strong> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'Airplanes';</pre>
<p>Within <strong class="source-inline">models/boardingticket.js</strong>, under the <strong class="source-inline">class BoardingTicket extends Model</strong> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'BoardingTickets';</pre>
<p>Within <strong class="source-inline">models/customer.js</strong>, under the <strong class="source-inline">class Customer extends Model</strong> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'Customers';</pre>
<p>Within <strong class="source-inline">models/flightschedule.js</strong>, under the <strong class="source-inline">class FlightSchedule extends Model</strong> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'FlightSchedules';</pre>
<p>Within <strong class="source-inline">models/receipts.js</strong>, under the <strong class="source-inline">class Receipts extends Model</strong> line, add the following variable:</p>
<pre class="source-code">
static tableName = 'Receipts';</pre>
<p>Now, we can <a id="_idIndexMarker729"/>begin with declaring our type definitions <a id="_idIndexMarker730"/>and query resolver patterns for the GraphQL server. Within the project’s root directory, add a new file called <strong class="source-inline">graphql.js</strong>, starting with the following <strong class="source-inline">require</strong> commands:</p>
<pre class="source-code">
const { createServer } = require("@graphql-yoga/node");
const { resolver } = require("graphql-sequelize");
const models = require("./models");</pre>
<p>Next, we want to start defining our query interface for when we want to execute queries later. You may think of this as something similar to a header file in a “C” language project:</p>
<pre class="source-code">
const typeDefs = `
  type Query {
    airplane(id: ID!): Airplane
    airplanes: [Airplane]
    boardingTicket(id: ID!): BoardingTicket
    boardingTickets: [BoardingTicket]
    customer(id: ID!): Customer
    customers: [Customer]
    flightSchedule(id: ID!): FlightSchedule
    flightSchedules: [FlightSchedule]
    receipt(id: ID!): Receipt
    receipts: [Receipt]
  }</pre>
<p>While <a id="_idIndexMarker731"/>keeping the <strong class="source-inline">typeDef</strong> variable open, we can <a id="_idIndexMarker732"/>add a simple <strong class="source-inline">Mutation</strong> query example:</p>
<pre class="source-code">
  type Mutation {
    upsertAirplane(name: String!, data: AirplaneInput!): 
    Airplane
  }
  input AirplaneInput {
    planeModel: String
    totalSeats: Int
  }
  type Airplane {
    id: ID!
    planeModel: String
    totalSeats: Int
    schedules: [FlightSchedule]
  }</pre>
<p>Next, we <a id="_idIndexMarker733"/>can add our model schematics to the <a id="_idIndexMarker734"/>definitions:</p>
<pre class="source-code">
  type Airplane {
    id: ID!
    planeModel: String
    totalSeats: Int
    schedules: [FlightSchedule]
  }
  type BoardingTicket {
    id: ID!
    seat: String
    owner: Customer
  }
  type Customer {
    id: ID!
    name: String
    email: String
    tickets: [BoardingTicket]
  }
  type FlightSchedule {
    id: ID!
    originAirport: String
    destinationAirport: String
    departureTime: String
  }
  type Receipt {
    id: ID!
    receipt: String
  }
`;</pre>
<p>Next, we will <a id="_idIndexMarker735"/>want to set our resolvers to associate the <a id="_idIndexMarker736"/>type definitions with the correct Sequelize model associations. Let’s start with the query resolvers:</p>
<pre class="source-code">
const resolvers = {
  Query: {
    airplane: resolver(models.Airplane),
    airplanes: resolver(models.Airplane),
    boardingTicket: resolver(models.BoardingTicket),
    boardingTickets: resolver(models.BoardingTicket),
    customer: resolver(models.Customer),
    customers: resolver(models.Customer),
    flightSchedule: resolver(models.FlightSchedule),
    flightSchedules: resolver(models.FlightSchedule),
    receipt: resolver(models.Receipts),
    receipts: resolver(models.Receipts),
  },</pre>
<p>Next, we <a id="_idIndexMarker737"/>can add <a id="_idIndexMarker738"/>a <strong class="source-inline">Mutation</strong> resolver example:</p>
<pre class="source-code">
  Mutation: {
    async upsertAirplane(parent, args, ctx, info) {
        const [airplane, created] = await models.Airplane.
        findOrCreate({
            where: {
                planeModel: args.name
            },
            defaults: (args.data || {}),
        });
        // if we created the record we do not need to 
           update it
        if (created) {
            return airplane;
        }
        if (typeof args.data !== "undefined") {
            await airplane.update(args.data);
        }
        return airplane;
    }
  },</pre>
<p>Then, we can resolve our model associations and close the variable:</p>
<pre class="source-code">
  Airplane: {
    schedules: resolver(models.Airplane.FlightSchedules),
  },
  BoardingTicket: {
    owner: resolver(models.BoardingTicket.Customer),
  },
  Customer: {
      tickets: resolver(models.Customer.BoardingTickets),
  },
};</pre>
<p>Finally, we <a id="_idIndexMarker739"/>can create our server with the schema <a id="_idIndexMarker740"/>definitions and export it:</p>
<pre class="source-code">
const server = new createServer({
  schema: {
    typeDefs,
    resolvers,
  }
});
module.exports = { server };</pre>
<p>Within the <strong class="source-inline">index.js</strong> file, in the project’s root directory, we can add the following line under our <strong class="source-inline">var models = require("./models")</strong> line:</p>
<pre class="source-code">
const { server } = require("./graphql");</pre>
<p>After we have mounted the AdminJS router, <strong class="source-inline">app.use(adminJs.options.rootPath, router)</strong>, add the following line:</p>
<pre class="source-code">
app.use('/graphql', server);</pre>
<p>After we have finished our <strong class="source-inline">index.js</strong> modifications, we can start our application:</p>
<p class="source-code">npm run start</p>
<p>Once the server is <a id="_idIndexMarker741"/>up and running, we can access GraphQL Yoga’s <a id="_idIndexMarker742"/>dashboard interface (<em class="italic">Figure 9.6</em>) by visiting the following URL within a browser: <a href="http://localhost:3000/graphql"><strong class="source-inline">http://localhost:3000/graphql</strong></a>: </p>
<p class="callout-heading">Note</p>
<p class="callout">In a production deployment, we would either want to disable this route based on the value of <strong class="source-inline">process.env.NODE_ENV</strong> or add authentication-based middleware to the <strong class="source-inline">/graphql</strong> route in <strong class="source-inline">index.js</strong>.</p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt=" Figure 9.6 – The GraphQL Yoga dashboard " height="794" src="image/Figure_9.06_B17841.jpg" width="936"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 9.6 – The GraphQL Yoga dashboard</p>
<p>We can test our <a id="_idIndexMarker743"/>queries and resolvers by executing queries <a id="_idIndexMarker744"/>within this dashboard. Remove all of the current content on the notepad section of the dashboard and enter the following:</p>
<pre class="source-code">
{
  airplanes {
    id
    planeModel
    totalSeats
  }
}</pre>
<p>There should be a “play button” at the top that will execute your query (alternatively, hitting the <em class="italic">Ctrl</em> and <em class="italic">Enter</em> keys simultaneously will do the same), which should yield results similar to the following:</p>
<pre class="source-code">
{
  "data": {
    "airplanes": [
      {
        "id": "1",
        "planeModel": "A320",
        "totalSeats": 150
      }
    ]
  }
}</pre>
<p>If we <a id="_idIndexMarker745"/>wanted to update our airplane’s model <a id="_idIndexMarker746"/>name, we could use a <strong class="source-inline">mutation</strong> query:</p>
<pre class="source-code">
mutation {
  upsertAirplane(name:"A320", data:{planeModel:"A321"}) {
    planeModel
  }
}</pre>
<p>This will return the following result:</p>
<pre class="source-code">
{
  "data": {
    "upsertAirplane": {
      "planeModel": "A321"
    }
  }
}</pre>
<p>Within the GraphQL Yoga dashboard, there should be a <strong class="bold">&lt; Docs</strong> link at the top right (refer to <em class="italic">Figure 9.6</em>), which will <a id="_idIndexMarker747"/>open a drawer panel. There will <a id="_idIndexMarker748"/>then be a <strong class="bold">Query</strong> link, which will expose our queries and type definitions. This should help make queries easier within the dashboard.</p>
<p>Now that we have established a connection between a GraphQL server and our Sequelize models and integrated another adapter that provides an easy-to-use admin dashboard, it is time for us to build our own adapter for Sequelize.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor182"/>Creating our own adapter</h1>
<p>Sequelize is fairly extensible through its class properties, lifecycle events, and configurations. For the example of <a id="_idIndexMarker749"/>creating our own adapter for Sequelize, we will integrate a new data type that will automatically convert values, using a specific set of rules, to what is called a “slug URL.” A slug URL usually consists of hyphens instead of spaces, lowercase <a id="_idIndexMarker750"/>lettering, and removes all special characters.</p>
<p>Let’s look at <a id="_idIndexMarker751"/>the steps to create our adapter: </p>
<ol>
<li>We’ll begin by installing any necessary packages. Keeping a copy of a character map of special characters can be a daunting task, so we will use an <strong class="source-inline">npm</strong> package called, <strong class="source-inline">github-slugger</strong> to help us:<p class="source-code"><strong class="bold">npm i --save github-slugger</strong></p></li>
<li>Next, we will want to create a couple of directories and a file with <strong class="source-inline">plugins/slug/index.js</strong> as the path from the project’s root directory. Before we can begin coding within that file, we will need to add the <strong class="source-inline">slug</strong> column to a table within the database. We will use the Airplane model for this example; using the <strong class="source-inline">sequelize-cli</strong> command, we can create a new migration event:<p class="source-code"><strong class="bold">sequelize-cli migration:create --name add_slug_to_airplanes</strong></p></li>
</ol>
<p>This command should generate a new file within the <strong class="source-inline">migrations</strong> directory ending in <strong class="source-inline">add_slug_to_airplanes.js</strong>. </p>
<ol>
<li value="3">Replace <a id="_idIndexMarker752"/>the file’s contents with the following:<p class="source-code">'use strict';</p><p class="source-code">module.exports = {</p><p class="source-code">  up: async (queryInterface, Sequelize) =&gt; {</p><p class="source-code">    await queryInterface.addColumn(</p><p class="source-code">      'Airplanes',</p><p class="source-code">      'slug',</p><p class="source-code">      {</p><p class="source-code">        type: Sequelize.STRING,</p><p class="source-code">        allowNull: true,</p><p class="source-code">      },</p><p class="source-code">    );</p><p class="source-code">    await queryInterface.addIndex(</p><p class="source-code">      'Airplanes',</p><p class="source-code">      ['slug'],</p><p class="source-code">      {</p><p class="source-code">        name: 'airplanes_slug_uniq_idx',</p><p class="source-code">        unique: true,</p><p class="source-code">      },</p><p class="source-code">    );</p><p class="source-code">  },</p><p class="source-code">  down: async (queryInterface, Sequelize) =&gt; {</p><p class="source-code">    await queryInterface.removeIndex('Airplanes', </p><p class="source-code">    'airplanes_slug_uniq_idx');</p><p class="source-code">    await queryInterface.removeColumn('Airplanes', </p><p class="source-code">    'slug');</p><p class="source-code">  },</p><p class="source-code">};</p></li>
</ol>
<p>This will instruct Sequelize to create a new column in the <strong class="source-inline">Airplanes</strong> table called <strong class="source-inline">slug</strong> as a text value, along with a unique index that is associated with that column. </p>
<ol>
<li value="4">To perform the <a id="_idIndexMarker753"/>latest migration, we will run the <strong class="source-inline">db:migrate</strong> command:<p class="source-code"><strong class="bold">sequelize-cli db:migrate </strong></p></li>
</ol>
<p>After the column has been added to the Airplanes table, we will need to add the attribute manually to the <strong class="source-inline">models/airplanes.js</strong> file. </p>
<ol>
<li value="5">Replace the <strong class="source-inline">totalSeats</strong> attribute block with the following:<p class="source-code">    totalSeats: {</p><p class="source-code">      type: DataTypes.INTEGER,</p><p class="source-code">      validate: {</p><p class="source-code">        min: {</p><p class="source-code">          args: 1,</p><p class="source-code">          msg: 'A plane must have at least one seat'</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    },</p><p class="source-code">    slug: {</p><p class="source-code">      type: DataTypes.STRING,</p><p class="source-code">      unique: true,</p><p class="source-code">    },</p></li>
<li>In the <strong class="source-inline">graphql.js</strong> file, we will want to add the <strong class="source-inline">slug</strong> column to the <strong class="source-inline">Airplane</strong> type definition as well:<p class="source-code">  type Airplane {</p><p class="source-code">    id: ID!</p><p class="source-code">    planeModel: String</p><p class="source-code">    totalSeats: Int</p><p class="source-code"><strong class="bold">    slug: String</strong></p><p class="source-code">    schedules: [FlightSchedule]</p><p class="source-code">  }</p></li>
<li>Now, we can <a id="_idIndexMarker754"/>begin editing the <strong class="source-inline">plugins/slug/index.js</strong> file, starting with the following lines of code:<p class="source-code">const slug = require("github-slugger").slug;</p><p class="source-code">class SlugPlugin {</p><p class="source-code">    use(model, options) {</p><p class="source-code">        const DEFAULTS = {</p><p class="source-code">            column: 'slug',</p><p class="source-code">            source: 'name',</p><p class="source-code">            transaction: null,</p><p class="source-code">        };</p><p class="source-code">        options = {...DEFAULTS, ...options};</p></li>
</ol>
<p>This will create a <strong class="source-inline">SlugPlugin</strong> class with one method called <strong class="source-inline">use</strong>. The input parameters are the <strong class="source-inline">model</strong> class, a couple of options, and their defaults. </p>
<ol>
<li value="8">Underneath <a id="_idIndexMarker755"/>those blocks, we will create our <strong class="source-inline">generateSlug</strong> method:<p class="source-code">        // concat the fields for the slug</p><p class="source-code">        function generateSlug(instance, fields) {</p><p class="source-code">            return slug(fields.map((field) =&gt; </p><p class="source-code">            instance[field]));</p><p class="source-code">        }</p></li>
<li>Next, we will want to ensure that a slug does not exist prior to updating. We will want to create some sort of finder method and an increment method for funding a unique value. We can start with the finder method shown here:<p class="source-code">        async function findSlug(slug) {</p><p class="source-code">            return await model.findOne({</p><p class="source-code">                where: {</p><p class="source-code">                    [options.column]: slug</p><p class="source-code">                },</p><p class="source-code">                transaction: options.transaction || </p><p class="source-code">                null,</p><p class="source-code">            });</p><p class="source-code">        }</p></li>
<li>Now for the incremental method; this function will run in a loop until a unique match is found using a combination of the slug’s value and an integer. Ideally, in a real production environment, we would come up with a cleverer way of finding unique values (for example, appending a hash instead of an incremental variable), but for brevity, we will create this function:<p class="source-code">        async function incrementSuffix(slugVal) {</p><p class="source-code">            let found = false;</p><p class="source-code">            let cnt = 1;</p><p class="source-code">            let suffix = "";</p><p class="source-code">            while (!found) {</p><p class="source-code">                suffix = `${slugVal}-${cnt}`;</p><p class="source-code">                found = await findSlug(suffix);</p><p class="source-code">                cnt++;</p><p class="source-code">            }</p><p class="source-code">            return suffix;</p><p class="source-code">        }</p></li>
<li>We can now begin <a id="_idIndexMarker756"/>creating the main event function. First, we will check whether our slug’s applicable attributes (the <strong class="source-inline">planeModel</strong> attribute, in this example) have been modified. If they have not been changed, then we will skip the entire event, since there is nothing to be done:<p class="source-code">        async function onSaveOrUpdate(instance) {</p><p class="source-code">            const changed = options.source.</p><p class="source-code">            some(function (field) {</p><p class="source-code">                return instance.changed(field);</p><p class="source-code">            });</p><p class="source-code">            if (!changed) {</p><p class="source-code">                return instance;</p><p class="source-code">            }</p></li>
<li>Next, we will compare the current value with the newly generated value. If they are the same (for example, a letter casing change), then simply skip the event:<p class="source-code">            let curVal = instance[options.column];</p><p class="source-code">            let newVal = generateSlug(instance, </p><p class="source-code">            options.source);</p><p class="source-code">            if (curVal !== null &amp;&amp; curVal == newVal) {</p><p class="source-code">                return instance;</p><p class="source-code">            }</p></li>
<li>Now, we can <a id="_idIndexMarker757"/>check and see whether the newly generated value is unique and, if so, set the instance’s <strong class="source-inline">slug</strong> attribute to that value and return the instance:<p class="source-code">            let slugExist = await findSlug(newVal);</p><p class="source-code">            if (!slugExist) {</p><p class="source-code">                instance[options.column] = newVal;</p><p class="source-code">                return instance;</p><p class="source-code">            }</p></li>
<li>Otherwise, we will want to use our <strong class="source-inline">incrementSuffix</strong> method and return the instance afterward:<p class="source-code">            newVal = await incrementSuffix(newVal);</p><p class="source-code">            instance[options.column] = newVal;</p><p class="source-code">            return instance;</p></li>
<li>Afterward, we can <a id="_idIndexMarker758"/>close our <strong class="source-inline">event</strong> method, attach the method to the model’s lifecycle events, and close the <strong class="source-inline">SlugPlugin</strong> class:<p class="source-code">        }</p><p class="source-code">        // use the lifecycle events for invoking the </p><p class="source-code">           onSaveOrUpdate event</p><p class="source-code">        model.addHook('beforeCreate', onSaveOrUpdate);</p><p class="source-code">        model.addHook('beforeUpdate', onSaveOrUpdate);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Finally, we can export an instance of our plugin as well as the class definition itself:<p class="source-code">const instance = new SlugPlugin();</p><p class="source-code">module.exports = instance;</p><p class="source-code">module.exports.SlugPlugin = instance;</p></li>
<li>Within the <strong class="source-inline">models/airplanes.js</strong> file, we will want to integrate our new plugin with the model. At the top of the file, we can include the plugin like so:<p class="source-code">const slugPlugin = require('../plugins/slug');</p></li>
<li>After the model’s definition, and before the <strong class="source-inline">return Airplane</strong> line, we can associate the <strong class="source-inline">slug</strong> plugin with the model:<p class="source-code">  slugPlugin.use(Airplane, {</p><p class="source-code">    source: ['planeModel']</p><p class="source-code">  });</p></li>
</ol>
<p>This will tell our plugin to use the <strong class="source-inline">planeModel</strong> attribute as the source field when generating the slug’s value.</p>
<ol>
<li value="19">In order to test our <a id="_idIndexMarker759"/>plugin, we can go to our GraphQL dashboard located at <strong class="source-inline">http://localhost:3000/graphql</strong> and enter the following command:<p class="source-code">mutation {</p><p class="source-code">  upsertAirplane(name:"A321", data:{planeModel:</p><p class="source-code">  "A321 B"}) {</p><p class="source-code">    planeModel</p><p class="source-code">    totalSeats</p><p class="source-code">    slug</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>This will find, and update, our A321 airplane’s <strong class="source-inline">planeModel</strong> value along with setting a <strong class="source-inline">slug</strong> value, as shown here:</p>
<p class="source-code">{</p>
<p class="source-code">  "data": {</p>
<p class="source-code">    "upsertAirplane": {</p>
<p class="source-code">      "planeModel": "A321 B",</p>
<p class="source-code">      "totalSeats": 150,</p>
<p class="source-code">      "slug": "a321-b"</p>
<p class="source-code">    }</p>
<p class="source-code">  }</p>
<p class="source-code">}</p>
<p>This finalizes our custom <a id="_idIndexMarker760"/>Sequelize adapter section. You can use the <strong class="source-inline">plugins/slug/index.js</strong> adapter in any other project using Sequelize. Feel free to add <strong class="source-inline">slug</strong> columns to other models, but make sure to follow the necessary steps:</p>
<ol>
<li value="1">Generate a migration file and migrate the column changes to the database.</li>
<li>Update the <strong class="source-inline">graphql.js</strong> file with the appropriate type definitions.</li>
<li>Include the <strong class="source-inline">plugin</strong> library within the applicable models’ files and associate the plugin with the models using the <strong class="source-inline">use</strong> method.</li>
</ol>
<h1 id="_idParaDest-174"><a id="_idTextAnchor183"/>Summary</h1>
<p>In this chapter, we went through the process of installing a dashboard that integrates with a database, integrating GraphQL using a third-party library, and creating our own Sequelize adapter that will automatically add slug values.</p>
<p>In the next chapter, we will start developing our website to be more production-ready and feature-complete. Some of these features include listing schedules, ordering tickets, and entering customer information.</p>
</div>
</div></body></html>