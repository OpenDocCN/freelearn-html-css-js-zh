["```js\n// Generator functions use an asterisk to\n// denote a that a generator instance is returned.\n// We can return values from generators, but instead\n// of the caller getting that value, they'll always\n// get a generator instance.\nfunction* gen() {\n    return 'hello world';\n}\n\n// Creates the generator instance.\nvar generator = gen();\n\n// Let's see what this looks like.\nconsole.log('generator', generator);\n// → generator Generator\n\n// Here's how we get the return value. Looks awkward,\n// because we would never use a generator function\n// that simply returns a single value.\nconsole.log('return', generator.next().value);\n// → return hello world\n```", "```js\n// This function yields values, in order. There's no\n// container structure, like an array. Instead, each time\n// the yield statement is called, control is yielded\n// back to the caller, and the position in the function\n// is bookmarked.\nfunction* gen() {\n    yield 'first';\n    yield 'second';\n    yield 'third';\n}\n\nvar generator = gen();\n\n// Each time we call \"next()\", control is passed back\n// to the generator function's execution context. Then,\n// the generator looks up the bookmark for where it\n// last yielded control.\nconsole.log(generator.next().value);\nconsole.log(generator.next().value);\nconsole.log(generator.next().value);\n```", "```js\n// A basic generator function that yields\n// sequential values.\nfunction* gen() {\n    yield 'first';\n    yield 'second';\n    yield 'third';\n}\n\n// Creates the generator.\nvar generator = gen();\n\n// Loop till the sequence is finished.\nwhile(true) {\n\n    // Gets the next item from the sequence.\n    let item = generator.next();\n\n    // Is there a next value, or are we done?\n    if (item.done) {\n        break;\n    }\n\n    console.log('while', item.value);\n}\n```", "```js\n// The \"for..of\" loop removes the need to explicitly\n// call generator constructs, like \"next()\", \"value\",\n// and \"done\".\nfor (let item of generator) {\n    console.log('for..of', item);\n}\n```", "```js\n// Generates an infinite Fibonacci sequence.\nfunction* fib() {\n    var seq = [ 0, 1 ],\n        next;\n\n    // This loop doesn't actually run infinitely,\n    // only as long as items from the sequence\n    // are requested using \"next()\".\n    while (true) {\n\n        // Yields the next item in the sequence.\n        yield (next = seq[0] + seq[1]);\n\n        // Stores state necessary to compute the\n        // item in the next iteration.\n        seq[0] = seq[1];\n        seq[1] = next;\n    }\n}\n\n// Launch the generator. This will never be \"done\"\n// generating values. However, it's lazy - it only\n// generates what we ask for.\nvar generator = fib();\n\n// Gets the first 5 items of the sequence.\nfor (let i = 0; i < 5; i++) {\n    console.log('item', generator.next().value);\n}\n```", "```js\n// A generic generator that will infinitely iterate\n// over the provided arguments, yielding each item.\nfunction* alternate(...seq) {\n    while (true) {\n        for (let item of seq) {\n            yield item;\n        }\n    }\n}\n```", "```js\n// Create a generator that alternates between\n// the provided arguments.\nvar alternator = alternate(true, false);\n\nconsole.log('true/false', alternator.next().value);\nconsole.log('true/false', alternator.next().value);\nconsole.log('true/false', alternator.next().value);\nconsole.log('true/false', alternator.next().value);\n// → \n// true/false true\n// true/false false\n// true/false true\n// true/false false\n```", "```js\n// Create a new generator instance, with new values\n// to alternate with each iteration.\nalternator = alternate('one', 'two', 'three');\n\n// Gets the first 10 items from the infinite sequence.\nfor (let i = 0; i< 10; i++) {\n    console.log('one/two/three',\n        `\"${alternator.next().value}\"`);\n}\n// → \n// one/two/three \"one\"\n// one/two/three \"two\"\n// one/two/three \"three\"\n// one/two/three \"one\"\n// one/two/three \"two\"\n// one/two/three \"three\"\n// one/two/three \"one\"\n// one/two/three \"two\"\n// one/two/three \"three\"\n// one/two/three \"one\"\n```", "```js\n// Generator that maps a collection of objects\n// to a specific property name.\nfunction* iteratePropertyValues(collection, property) {\n    for (let object of collection) {\n        yield object[property];\n    }\n}\n\n// Generator that yields each value of the given object.\nfunction* iterateObjectValues(collection) {\n    for (let key of Object.keys(collection)) {\n        yield collection[key];\n    }\n}\n\n// Generator that yields each item from the given array.\nfunction* iterateArrayElements(collection) {\n    for (let element of collection) {\n        yield element;\n    }\n}\n```", "```js\n// This generator defers to other generators. But first,\n// it executes some logic to determine the best strategy.\nfunction* iterateNames(collection) {\n\n    // Are we dealing with an array?\n    if (Array.isArray(collection)) {\n\n        // This is a heuristic where we check the first\n        // element of the array. Based on what's there, we\n        // make assumptions about the remaining elements.\n        let first = collection[0];\n\n        // Here is where we defer to other more specialized\n        // generators, based on what we find out about the\n        // first array element.\n        if (first.hasOwnProperty('name')) {\n            yield* iteratePropertyValues(collection,\n                'name');\n        } else if (first.hasOwnProperty('customerName')) {\n            yield* iteratePropertyValues(collection,\n                'customerName');\n        } else {\n            yield* iterateArrayElements(collection);\n        }\n    } else {\n        yield* iterateObjectValues(collection);\n    }\n}\n```", "```js\nvar collection;\n\n// Iterates over an array of string names.\ncollection = [ 'First', 'Second', 'Third' ];\n\nfor (let name of iterateNames(collection)) {\n    console.log('array element', `\"${name}\"`);\n}\n\n// Iterates over an object, where the names\n// are the values - the keys aren't relevant here.\ncollection = {\n    first: 'First',\n    second: 'Second',\n    third: 'Third'\n};\n\nfor (let name of iterateNames(collection)) {\n    console.log('object value', `\"${name}\"`);\n}\n\n// Iterates over the \"name\" property of each object\n// in the collection.\ncollection = [\n    { name: 'First' },\n    { name: 'Second' },\n    { name: 'Third' }\n];\n\nfor (let name of iterateNames(collection)) {\n    console.log('property value', `\"${name}\"`);\n}\n```", "```js\n'use strict';\n\n// Utility function that converts the input array to a\n// generator by yielding each of it's values. If its\n// not an array, it assumes it's already a generator\n// and defers to it.\nfunction* toGen(array) {\n    if (Array.isArray(array)) {\n        for (let item of array) {\n            yield item;\n        }\n    } else {\n        yield* array;\n    }\n}\n\n// Interweaves the given data sources (arrays or\n// generators) into a single generator source.\nfunction* weave(...sources) {\n\n    // This controls the \"while\" loop. As long as\n    // there's a source that's yielding data, the\n    // while loop is still valid.\n    var yielding = true;\n\n    // We have to make sure that each of our\n    // sources is a generator.\n    var generators = sources.map(\n        source =>toGen(source));\n\n    // Starts the main weaving loop. It makes it's\n    // way through each source, yielding one item\n    // from each, then starting over, till every\n    // source is empty.\n    while (yielding) {\n        yielding = false;\n\n        for (let source of generators) {\n            let next = source.next();\n\n            // As long as we're yielding data, the\n            // \"yielding\" value is true, and the\n            // \"while\" loop continues. As soon as\n            // \"done\" is true for every source, the\n            // \"yielding\" variable stays false, and\n            // the \"while loop exits.\n            if (!next.done) {\n                yielding = true;\n                yield next.value;\n            }\n        }\n    }\n}\n\n// A basic filter that generates values by\n// iterating over the given source, and yielding items\n// that are not disabled.\nfunction* enabled(source) {\n    for (let item of source) {\n        if (!item.disabled) {\n            yield item;\n        }\n    }\n}\n\n// These are the two data sources we want to weave\n// together into one generator, which can then be\n// filtered by another generator.\nvar enrolled = [\n    { name: 'First' },\n    { name: 'Sencond' },\n    { name: 'Third', disabled: true }\n];\n\nvar pending = [\n    { name: 'Fourth' },\n    { name: 'Fifth' },\n    { name: 'Sixth', disabled: true }\n];\n\n// Creates the generator, which yields user objects\n// from two data sources.\nvar users = enabled(weave(enrolled, pending));\n\n// Actually performs the weaving and filtering.\nfor (let user of users) {\n    console.log('name', `\"${user.name}\"`);\n}\n```", "```js\n// This generator will keep generating even numbers.\nfunction* genEvens() {\n\n    // The initial value is 2\\. But this can change based\n    // on the input passed to \"next()\".\n    var value = 2,\n        input;\n\n    while (true) {\n\n        // We yield the value, and get the input. If \n        // input is provided, this will serve as the\n        // next value.\n        input = yield value;\n\n        if (input) {\n            value = input;\n        } else {\n            // Make sure that the next value is even.\n            // Handles the case when an odd value is\n            // passed to \"next()\".\n            value += value % 2 ? 1 : 2;\n        }\n    }\n}\n\n// Creates the \"evens\" generator.\nvar evens = genEvens(),\n    even;\n\n// Iterate over evens up to 10.\nwhile ((even = evens.next().value) <= 10) {\n    console.log('even', even);\n}\n// →\n// even 2\n// even 4\n// even 6\n// even 8\n// even 10\n\n// Resets the generator. We don't need to\n// create a new one.\nevens.next(999);\n\n// Iterate over evens between 1000 - 1024.\nwhile ((even = evens.next().value) <= 1024) {\n    console.log('evens from 1000', even);\n}\n// → \n// evens from 1000 1000\n// evens from 1000 1002\n// evens from 1000 1004\n// evens from 1000 1006\n// evens from 1000 1008\n// evens from 1000 1010\n// evens from 1000 1012\n// evens from 1000 1014\n// ...\n```", "```js\n// This generator will keep iterating, as\n// long as \"next()\" is called. It's expecting\n// a value as well, so that it can call the\n// \"iteratee()\" function on it, and yield the\n// result.\nfunction* genMapNext(iteratee) {\n    var input = yield null;\n\n    while (true) {\n        input = yield iteratee(input);\n    }\n}\n\n// Our array of values we want to map.\nvar array = [ 'a', 'b', 'c', 'b', 'a' ];\n\n// A \"mapper\" generator. We pass an iteratee\n// function as an argument to \"genMapNext()\".\nvar mapper = genMapNext(x =>x.toUpperCase());\n\n// Our starting point for the reduction.\nvar reduced = {};\n\n// We have to call \"next()\" to bootstrap the\n// generator. \nmapper.next();\n\n// Now we can start iterating over the array.\n// The \"mapped\" value is yielded from the\n// generator. The value we want mapped is fed\n// into the generator by passing it to \"next()\".\nfor (let item of array) {\n    let mapped = mapper.next(item).value;\n\n    // Our reduction logic takes the mapped value,\n    // and adds it to the \"reduced\" object, counting\n    // the number of duplicate keys.\n    if (reduced.hasOwnProperty(mapped)) {\n        reduced[mapped]++;\n    } else {\n        reduced[mapped] = 1;\n    }\n}\n\nconsole.log('reduced', reduced);\n// → reduced { A: 2, B: 2, C: 1 }\n```", "```js\n// This generator is a more useful mapper than\n// \"genMapNext()\" because it doesn't rely on values\n// coming into the generator through \"next()\".\n//\n// Instead, this generator accepts an iterable, and\n// an iteratee function. The iterable is then\n// iterated-over, and the result of the iteratee\n// is yielded.\nfunction* genMap(iterable, iteratee) {\n    for (let item of iterable) {\n        yield iteratee(item);\n    }\n}\n\n// Creates our \"mapped\" generator, using an iterable\n// data source, and an iteratee function.\nvar mapped = genMap(array, x =>x.toUpperCase());\nvar reduced = {}\n\n// Now we can simply iterate over our genrator, instead\n// of calling \"next()\". The job of each loop iteration\n// is to perform the reduction logic, instead of having\n// to call \"next()\".\nfor (let item of mapped) {\n    if (reduced.hasOwnProperty(item)) {\n        reduced[item]++;\n    } else {\n        reduced[item] = 1;\n    }\n}\n\nconsole.log('reduce improved', reduced);\n// → reduce improved { A: 2, B: 2, C: 1 }\n```", "```js\n// This function composes a generator\n// function out of iteratees. The idea is to create\n// a generator for each iteratee, so that each item\n// from the original iterable, flows down, through\n// each iteratee, before mapping the next item.\nfunction composeGenMap(...iteratees) {\n\n    // We're returning a generator function. That way,\n    // the same mapping composition can be used on\n    // several iterables, not just one.\n    return function* (iterable) {\n\n        // Creates the generator for each iteratee\n        // passed to the function. The next generator\n        // gets the previous generator as the \"iterable\"\n        // argument.\n        for (let iteratee of iteratees) {\n            iterable = genMap(iterable, iteratee);\n        }\n\n        // Simply defer to the last iterable we created.\n        yield* iterable;\n    }\n}\n\n// Our iterable data source.\nvar array = [ 1, 2, 3 ];\n\n// Creates a \"composed\" mapping generator, using 3\n// iteratee functions.\nvar composed = composeGenMap(\n    x => x + 1,\n    x => x * x,\n    x => x - 2\n);\n\n// Now we can iterate over the composed generator,\n// passing it our iterable, and lazily mapping\n// values.\nfor (let item of composed(array)) {\n    console.log('composed', item)\n}\n// →\n// composed 2\n// composed 7\n// composed 14\n```", "```js\n// Taken from: http://syzygy.st/javascript-coroutines/\n// This utility takes a generator function, and returns\n// a coroutine function. Any time the coroutine is invoked,\n// it's job is to call \"next()\" on the generator.\n//\n// The effect is that the generator function can run\n// indefinitely, pausing when it hits \"yield\" statements.\nfunction coroutine(func) {\n\n    // Creates the generator, and moves the function\n    // ahead to the first \"yield\" statement.\n    var gen = func();\n    gen.next();\n\n    // The \"val\" is passed to the generator function\n    // through the \"yield\" statement. It then resumes\n    // from there, till it hits another yield.\n    return function(val) {\n        gen.next(val);\n    }\n}\n```", "```js\n// Creates a coroutine function that when called,\n// advances to the next yield statement.\nvar coFirst = coroutine(function* () {\n    var input;\n\n    // Input comes from the yield statement, and is\n    // the argument value passed to \"coFirst()\".\n    input = yield;\n    console.log('step1', input);\n    input = yield;\n    console.log('step3', input);\n});\n\n// Works the same as the coroutine created above...\nvar coSecond = coroutine(function* () {\n    var input;\n    input = yield;\n    console.log('step2', input);\n    input = yield;\n    console.log('step4', input);\n});\n\n// The two coroutines cooperating with one another,\n// to produce the expected output. We can see that\n// the second call to each coroutine picks up where\n// the last yield statement left off.\ncoFirst('the money');\ncoSecond('the show');\ncoFirst('get ready');\ncoSecond('go');\n// → \n// step1 the money\n// step2 the show\n// step3 get ready\n// step4 go\n```", "```js\n// Coroutine function that's used with mousemove\n// events.\nvar onMouseMove = coroutine(function* () {\n    var e;\n\n    // This loop continues indefinitely. The event\n    // object comes in through the yield statement.\n    while (true) {\n        e = yield;\n\n        // If the element is disabled, do nothing.\n        // Otherwise, log a message.\n        if (e.target.disabled) {\n            continue;\n        }\n\n        console.log('mousemove', e.target.textContent);\n    }\n});\n\n// Coroutine function that's used with click events.\nvar onClick = coroutine(function* () {\n\n    // Store references to our two buttons. Since\n    // coroutines are stateful, they'll always be \n    // available.\n    var first = document.querySelector(\n        'button:first-of-type');\n    var second = document.querySelector(\n        'button:last-of-type'),\n    var e;\n\n    while (true) {\n        e = yield;\n\n        // Disables the button that was clicked.\n        e.target.disabled = true;\n\n        // If the first button was clicked, toggle\n        // the state of the second button.\n        if (Object.is(e.target, first)) {\n            second.disabled = !second.disabled;\n            continue;\n        }\n\n        // If the second button was clicked, toggle\n        // the state of the first button.\n        if (Object.is(e.target, second)) {\n            first.disabled = !first.disabled;\n        }\n    }\n});\n\n// Sets up the event handlers - our coroutine functions.\nfor (let button of document.querySelectorAll('button')) {\n    button.addEventListener('mousemove', onMouseMove);\n    button.addEventListener('click', onClick);\n}\n```", "```js\n// An array of promises.\nvar promises = [];\n\n// Our resolution callback is a coroutine. This means\n// that every time it's called, a new resolved promise\n// value shows up here.\nvar onFulfilled = coroutine(function* () {\n    var data;\n\n    // Continue to process resolved promise values\n    // as they arrive.\n    while (true) {\n        data = yield;\n        console.log('data', data);\n    }\n});\n\n// Create 5 promises that resolve at random times,\n// between 1 and 5 seconds.\nfor (let i = 0; i< 5; i++) {\n    promises.push(new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(i);\n    }, Math.floor(\n        Math.random() * (5000 - 1000)) + 1000);\n    }));\n}\n\n// Attach our fulfillment coroutine as a \"then()\" callback.\nfor (let promise of promises) {\n    promise.then(onFulfilled);\n}\n```"]