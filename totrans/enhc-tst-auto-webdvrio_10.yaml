- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Increased Flexibility – Writing Robust Selectors and Reducing Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintenance is the ever-growing villain of a test automation project. Each release
    has more tests and more elements that can go stale, causing a test to fail. If
    you are new to the test automation field, you may not realize just how much maintenance
    will increasingly impact your project release after release. I (Paul) would like
    to share with you this story that inspired several unique solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Several years ago, my client’s development team decided to change the entire
    underlying architecture supporting the application under test. My automation team
    only became aware of this change when we found nearly all 100 of our test cases
    suite failed to reach a passing state. In fact, the only test case that passed
    was the `LogIn` test we wrote on the first day of the project. We realized that
    hundreds of element objects had changed their tag name to different types and
    used different properties. We were faced with the daunting task of rewriting hundreds
    of element selectors one by one. We estimated the rework of the page objects might
    take 2 days to be returned to a working state.
  prefs: []
  type: TYPE_NORMAL
- en: Add to this that the client had been used to receiving a detailed summary of
    the regression test suite results in under 2 hours, along with our smoke tests
    detecting issues within 15 minutes. We were faced with the task of explaining
    that release results would not be available for another 2 days or more. The manual
    team of six resources would likely complete their testing in that amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: My coworker set about the task of updating selectors in the page object tags.
    I had a different idea. From my analysis, I realized that just one element tag
    had changed. Many of the `<a>` link anchors were now `<button>` tags. Luckily,
    none of the strings used to locate elements had changed, they were just in different
    object properties. I proposed adding a thin layer to our framework that would
    search for alternate tag elements to the one that was no longer found.
  prefs: []
  type: TYPE_NORMAL
- en: The code change was completed in under an hour. The number of test cases that
    were executed increased to 95% completion. Two test cases failed the release,
    and another three needed to be maintained by hand to get to a working state. This
    was in line with the maintenance work on the previous release iterations. Our
    client understood the challenge the architectural change presented, and she was
    overjoyed we could provide actionable results within 4 hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'On similar lines, we will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing page object maintenance with generic selectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of an XPath selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging `data-qa` and **Accessible Rich Internet Applications** (**ARIA**)
    attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an XPath element that contains a textual substring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second chances – getting valid objects from stale selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All test examples can be found at this GitHub repository: [https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO](https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO)'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing page object maintenance with generic selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the advanced concepts of making our object flexible like
    plastic, let’s begin with several ways we can write better selectors. A robust
    selector is extremely important to reduce the maintenance of your test automation
    framework. We will move beyond exact matches to use substring matches to be sure
    that we can find an element even if it changes slightly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with a simple question. Which is better—XPath or CSS? There is a common
    idea that CSS is the preferred method for writing a selector because it executes
    faster. While this may be true, the speed difference today is minimal. I would
    rather spend a few more milliseconds finding an element over the minutes spent
    repeatedly updating object selectors. In addition, CSS selectors are harder to
    write syntactically. Furthermore, CSS selectors are not as flexible when we need
    to find one element relative to another—for example, locating one of many generic
    `label` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – A generic radio button relative to a Label element named “One”
    on the DOM](img/B19395_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – A generic radio button relative to a Label element named “One”
    on the DOM
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, there is no way to uniquely identify any of the radio
    buttons by their text. This is because the uniquely identifiable text is contained
    in a `Label` element relative to the **Span** **radio** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must leverage the XPath axis of a parent and child element to uniquely locate
    these elements by relative location. We write a selector to the parent object
    that has the text `One`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We then follow it with the generic child radio button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We then combine them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That was an easy riddle to solve. But what if we have text that has extra spaces,
    forced carriage returns, or even a mix of quotes and single quotes, as in the
    following example? To solve issues such as this, we will take a deeper dive into
    more ways that we can locate and identify elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Extra spaces, mixed single and double quotes, and embedded
    carriage returns](img/B19395_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Extra spaces, mixed single and double quotes, and embedded carriage
    returns
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, we have seen examples of XPath and CSS selectors. Let us take a moment
    to further explore the components to retrieve collections of elements in WebdriverIO.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of an XPath selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selectors are comprised of one or more node tag types followed by an optional
    `[predicate]` in square brackets. The predicates have operators and functions
    to filter certain node matches. Lastly, they include path separators with generic
    *axes* with double colons to further refine the path of the element. This makes
    it more likely to find an element regardless of its location in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'XPath selectors are written as *absolute* or *relative*. This is an example
    of an absolute-style selector to the **Find My Candy** button on the *Candymapper*
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have seen an absolute selector, use it only as a red flag. The
    point of this exercise is the fluid nature of the numeric indexes inside the square
    brackets. The exact location will be dynamic from release to release, causing
    endless maintenance. If you see a lot of selectors with this format in your code
    base, it is all but certain your selector is not robust. Furthermore, it is a
    devilish riddle for another developer to figure out the intended element since
    the text “Find My Candy” does not appear in the selector string. Let’s look for
    better ways to write selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Rule of thumb
  prefs: []
  type: TYPE_NORMAL
- en: Always take extra time to replace an absolute selector with a relative selector
    and use a descriptive element name. The `myElement` name in the preceding example
    is of no help and should be renamed `findMyCandy` or, better still, `btnFindMyCandy`.
  prefs: []
  type: TYPE_NORMAL
- en: Relative selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most relative selectors begin with a double slash (`//`) followed by a single
    slash indicating the next element in the path. Let’s look at this in a bit more
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//` `//div` selects all `<div>` elements anywhere in the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/` `/html/body/div` selects all `<div>` elements that are direct children
    of the `<body>` element inside the `<``html>` root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` **(star)**: Denotes a wildcard match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start, we will get a collection of all the elements on the page using the
    `*` wildcard matcher for all node types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Node test functions – text() versus normalize-space()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several of the element selector tags shown here, including anchors, buttons,
    and lists, can be matched with exact text using the `text()` Node test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is an easy sample, but what if there were some strange formatting embedded
    in the text?
  prefs: []
  type: TYPE_NORMAL
- en: Broken strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There can be times when extraneous spaces or carriage returns make a selector
    match challenging. In such cases, it is recommended to use `normalize-space()`
    instead of `text()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check if this selector is valid with the `SelectorsHub` Chrome extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – SelectorsHub indicates more than one element will match the
    selector](img/B19395_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – SelectorsHub indicates more than one element will match the selector
  prefs: []
  type: TYPE_NORMAL
- en: 'The XPath selector is valid, but it matches four additional elements on the
    screen. Another way is to get the button element relative to the container page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This element can be located with the parent class and converted to a CSS selector
    with a period (`.`) as a shortcut for a class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can perform a close match with a `popup` on the class name to
    find an anchor link child using the CSS containing a `*=` shortcut in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also narrow down the parent element to a specific tag type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There are five common web page elements we will seek: links, buttons, lists,
    fields, and text elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are common ways to find these elements with an exact string as well as
    a substring match in XPath:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Buttons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lists (unordered and ordered):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fields and multiline text areas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Text:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Leveraging data-qa and ARIA attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There have been two new developments in website design where developers can
    help SDETs maintain robust low-maintenance selectors. Consider this web page element
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be accomplished by adding the `data-qa` attribute, which is unique
    and static. Alternately, if the developer team follows the ARIA standard, many
    text elements can be identified by the `aria-label` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example leveraging `data-qa` and ARIA attributes to ensure that
    your web application’s elements are accessible and interactable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we have two test cases. The first one verifies that an element
    with a `data-qa` attribute has the correct ARIA role. The second test case checks
    the keyboard accessibility of an element with a specific ARIA label. This is just
    a basic example, and you can adapt it to your specific application’s needs to
    ensure that your elements are properly accessible and have the right attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Rule of thumb – alternatives to CSS selectors
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, CSS selectors do not provide a direct way to filter elements
    based on their text content, like the `text()` and `normalize-space()` functions
    in XPath.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, while CSS selectors are hailed as being faster, they can be limited in
    functionality in test automation. The next example utilizes CSS to quickly gather
    all elements on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For fetching particular types of elements, a combination of XPath and CSS can
    be employed. Here are some supplementary element selector types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Buttons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fields:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finding an element only by text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Elements can be found with an XPath selector with an exact matching string.
    For example, a **Next** button with an exact match would be formatted as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, while the text is likely to remain constant, the angle bracket and
    spacing could change. We can reduce our chance of future maintenance with a selector
    that has a substring.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an XPath element that contains a textual substring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By adding `contains()` to the selector, the object can be found with just a
    small part of the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This works for many elements, but checkboxes and radio buttons are tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an element relative to another element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this next example, we want to click the checkbox next to the name *John
    Smith*. We have several checkboxes but none has a unique identifier by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The name John Smith and its associated checkbox are two separate
    elements](img/B19395_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – The name John Smith and its associated checkbox are two separate
    elements
  prefs: []
  type: TYPE_NORMAL
- en: 'This selector will identify all the checkboxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To locate this checkbox element, we need to use the link and find the input
    checkbox preceding it. Here’s how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Case-insensitive partial matches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if we learn a developer sometimes changes the case of the text? A solution
    to that is to add a `translate` option and convert the text to match either upper-
    or lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The problem now is that the element the selector returns is not always visible.
    Here is how we handle that.
  prefs: []
  type: TYPE_NORMAL
- en: Finding only visible elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the biggest challenges in test automation is to return a collection
    of visible elements. This reminds us of a very famous quote delivered by Michael
    Keaton: “*Want to get nuts? Let’s* *get nuts!*”'
  prefs: []
  type: TYPE_NORMAL
- en: 'This extensive selector is provided as one example. It will eliminate most
    objects that are not visible in multiple ways. We addressed the opacity being
    `0`, the overflow or visibility being hidden, the display being `none`, and the
    width or height being set to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This selector also eliminates any elements that have an ancestor that is hidden.
    Here is another place where the 80/20 rule applies. Even if this selector only
    eliminates about 80% of non-visible elements, we will still need to parse through
    a collection of elements to find the first one that is visible. So, why not let
    XPath or CSS handle more than half of the work getting our visible elements?
  prefs: []
  type: TYPE_NORMAL
- en: The reason we want to do this is to give our methods a second chance at trying
    to find an element if it has been changed from its class. It’s never too late
    for a second or third chance to find an element.
  prefs: []
  type: TYPE_NORMAL
- en: Second chances – getting valid objects from stale selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our four primary method wrappers, let us make them more robust
    with self-healing code. The biggest drawback in automation is the maintenance
    to fix elements in the **Page Object Model** (**POM**) when selectors become stale.
    In this section, we look at self-healing techniques to find elements that have
    changed their node type.
  prefs: []
  type: TYPE_NORMAL
- en: Self healing techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go over some self-healing techniques in this sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing code for case-insensitive matches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All these functions will require a conversion to case-insensitive matches.
    We start by creating two constants to reduce the repeated use of the upper- and
    lowercase alphabet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will need a function that will extract unique text from a stale locator.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting selector text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function will try to return the first match of any unique text encased
    in double or single quotes. This will be injected into a close match locator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we check for a single quote, such as a possessive apostrophe, embedded
    in the selector string. For example, `"Moe''s Bar"` would result in an odd number
    of single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Handle cases where there is one single quote by surrounding it with a `concat`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This converts `"Moe's bar"` to `"concat("Moe","'","'s bar")` to support a single-quote
    match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In any other language, it would be impossible to have a locator with both a
    single quote and a quoted string in a single locator. But because JavaScript allows
    literal strings with backticks, there could be a string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we handle the case where there are three single quotes and only the second
    single quote should be escaped like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This extracts as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract text between two double or single quotes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If no match is found, or the matched group is not valid, return the original
    selector. In fact, the locator string passed is likely not robust enough to be
    given a second chance. We return a string clearly identifying the issue, as returning
    a `Null` value would throw an error, and an empty string likely would match all
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we return the captured group between single or double quotes modified
    if a single quote is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have extracted the text of a locator, we can inject it into a similar
    one for each class of elements.
  prefs: []
  type: TYPE_NORMAL
- en: From links to buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the main page of the *Candymapper* sandbox website, there is exactly one
    `<Button>` element. It is the `<A>` anchor link like the other ones on the page.
    and it was in all caps. I’ve since fixed that, but do I need to spend time fixing
    the locator in my code?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 –The Send button element on the Candymapper website](img/B19395_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 –The Send button element on the Candymapper website
  prefs: []
  type: TYPE_NORMAL
- en: 'This was the original locator that used to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What if we could pull the text and inject it into a button class like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If it still did not work, we made a third attempt to make a case-insensitive
    match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a solution that allows us to find our elements regardless of case
    sensitivity. We can now move on to optimizing this with a mutant merge power.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an element by text alone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This can be wrapped together as a function in use by `getValidElement()` to
    give our buttons a second chance to be identified without refactoring the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the **Send** button can be reached even if it changes case and class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Fields and lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fields could change from `<input>` to `<textarea>` objects. To find them, this
    change can be done with the `@``placeholder` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course, `<select>` objects might change to a `<``input>` combobox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Short substrings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One last trick before we leave this rabbit hole. Sometimes, small text changes
    can still be located accurately. `"Select all active files"` becomes `"Select
    all activated files"`. Divide the text into thirds. If the remaining length is
    greater than five characters, there is a good chance of matching on the middle
    string, `"all activ"`, as long as it is a unique match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Statistically, this will return a unique element about 40% of the time.
  prefs: []
  type: TYPE_NORMAL
- en: On thin ice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scrolling elements pose a particularly difficult challenge. Occasionally, they
    will end up partially outside of the view area of the browser. Let’s take a look
    at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Text area object of upper-left corner 0,0 located above the
    browser view area; center of a second text area object located off the bottom
    of the browser](img/B19395_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Text area object of upper-left corner 0,0 located above the browser
    view area; center of a second text area object located off the bottom of the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'And what if your site supports side-scrolling element animation? If your framework
    activates a sliding menu and immediately tries to click an element inside, there
    are bound to be some strange results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Example of clicking the center of a sliding menu item](img/B19395_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Example of clicking the center of a sliding menu item
  prefs: []
  type: TYPE_NORMAL
- en: What makes it more frustrating is that should this issue occur, the screen capture
    at the end of the test will likely occur once the slider animation has been completed.
    The only clue you might get is a message indicating the element was not clickable
    at point 2050, 250 which is just beyond the right edge of a display with a 1920
    x 1080 pixel resolution.
  prefs: []
  type: TYPE_NORMAL
- en: The intrinsic WebdriverIO `.click()` method should never have an issue interacting
    with an offscreen element. The major reason the `clickAdv()` wrapper function
    scrolls the element into the browser view area is to have a better chance of having
    the element appear in a screen capture if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to use a fancy JavaScript click can throw errors if the element
    is not in the viewport. It depends if the click is being executed at the top-left
    corner of the object or at its calculated center. Here is an example of a JavaScript
    click call using the `browser.execute` method to execute the `arguments[0].click();`
    code string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There is another good reason this approach can cause issues. In GUI automation,
    we always want to emulate the user as much as possible. What happens if we have
    a modal popup displayed over the desired element, as seen here?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Calling jsclick() to force interaction with an element below
    a modal popup will be problematic](img/B19395_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Calling jsclick() to force interaction with an element below a
    modal popup will be problematic
  prefs: []
  type: TYPE_NORMAL
- en: 'If the element we are seeking is sliding in on a control from off-screen, you
    often might get an error that the element click is out of bounds. It can occur
    if the element is an item in an expanding list that is still animating. Occasionally,
    an error can occur when the object has scrolled a few pixels out of the viewport.
    To counter this, we need to know if the element is moving when the error is thrown
    and when the movement has stopped. Here’s how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll down one mouse wheel and click, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Writing the isMoving() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The days of clicking on an element by an *x* or *y* coordinate are long past
    us. It does not mean the coordinates of an element are of no value. Surprisingly,
    in some instances, a click is sometimes performed relative to an element’s screen
    location. With coordinates, we can determine if an element is in motion to ensure
    there is a higher degree of accuracy in our framework. Consider this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return an object with the current *x* and *y* screen coordinate location
    of the element. By looping through with a brief pause of a few milliseconds, we
    can implement a dynamic wait that ensures our object scroll animation has been
    completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The best practice is to implement this just after any `browser.execute` scroll
    and before any similar click-based method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this thrilling installment of our superhero coding saga, we’ve journeyed
    through the enigmatic world of element targeting, mastering the art of locating
    elusive HTML entities in the wilds of the web. Our quest led us to conquer the
    shifting shapes of `<a>` anchors, transforming them into mighty `<button>` sentinels,
    and evolving simple `<input>` fields into vast expanses of `<textarea>` elements.
    We’ve navigated the morphing mazes of dropdowns metamorphosing into comboboxes,
    deploying our powers to match text with a disregard for case, and even to seek
    out the hidden meanings within the midst of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Our toolkit expanded, and we’ve embraced the arcane arts of self-healing locators,
    weaving spells to mend themselves when the digital winds change. We stood firm
    as elements danced and darted across the screen, phasing in with animations that
    would baffle a lesser Tech Mage.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we stand at the precipice of discovery, we pose a question that defies the
    very reality of our craft: What if the need for a page object locator were but
    a mere illusion? What if, in the shadowy recesses of the UI, we could summon a
    **Send** button with nothing but a whisper to the framework? The answer beckons
    us—dare we leap into the unknown? The next chapter awaits, promising wonders beyond
    the limits of our imagination.'
  prefs: []
  type: TYPE_NORMAL
