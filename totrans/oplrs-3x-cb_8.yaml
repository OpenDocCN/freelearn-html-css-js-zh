- en: Chapter 8. Beyond the Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 基础之外
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Working with projections
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用投影
- en: Requesting remote data with `OpenLayers.Request`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`OpenLayers.Request`请求远程数据
- en: Creating a custom control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义控件
- en: Creating a custom renderer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义渲染器
- en: Selecting features intersecting with a line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择与线相交的特征
- en: Making an animation with image layers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图像图层制作动画
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: OpenLayers is a big and complex framework. There is no other option available
    for a framework that allows working with many GIS standards, reading from many
    different data sources, rendering on different browser technologies, and so on.
    This power comes with a price.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers是一个庞大且复杂的框架。没有其他选项可以用于一个允许处理许多GIS标准、从许多不同的数据源读取、在不同的浏览器技术上进行渲染等的框架。这种力量是有代价的。
- en: 'The implementation of OpenLayers tries to have as less dependencies on external
    libraries as possible. This means, OpenLayers requires implementing many features
    that we can find in other projects: DOM elements'' manipulation, AJAX requests,
    and so on.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers的实现试图尽可能减少对外部库的依赖。这意味着，OpenLayers需要实现许多在其他项目中可以找到的功能：DOM元素的操纵、AJAX请求等。
- en: This chapter shows some of these features, in addition to other possible common
    needs we can require in our day-to-day work that are not explained in other chapters,
    such as creation of layer animations or the implementation of custom controls.
    Because of this, the chapter is more suited for more experienced JavaScript programmers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了这些功能中的一些，以及我们在日常工作中可能需要的一些其他可能的常见需求，这些需求在其他章节中没有解释，例如创建图层动画或实现自定义控件。因此，本章更适合有经验的JavaScript程序员。
- en: Working with projections
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用投影
- en: In contrast to other JavaScript mapping libraries, OpenLayers allows working
    with a great number of projections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他JavaScript地图库相比，OpenLayers允许使用大量的投影。
- en: Usually, we specify the desired projection for the map. Later when adding a
    vector layer to the map, we need to specify to the layer projection so that OpenLayers
    transforms features from the layer's projection to the map's projection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们指定地图所需的投影。稍后当向地图添加矢量图层时，我们需要指定图层的投影，以便OpenLayers将图层投影中的特征转换为地图投影。
- en: 'But, by default, OpenLayers has a great limitation on projections: we can only
    use **EPSG:4326** and **EPSG:900913**. Why? Because transforming between projections
    is not a simple task and there are other great projects that can make it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，默认情况下，OpenLayers在投影方面有一个很大的限制：我们只能使用**EPSG:4326**和**EPSG:900913**。为什么？因为投影之间的转换不是一项简单的任务，而且还有其他优秀的项目可以做到这一点。
- en: So, when we want to work with projections other than EPSG:4326 and EPSG:900913,
    OpenLayers uses **Proj4js Library** ([http://trac.osgeo.org/proj4js](http://trac.osgeo.org/proj4js)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们想要使用EPSG:4326和EPSG:900913之外的投影时，OpenLayers使用**Proj4js库**([http://trac.osgeo.org/proj4js](http://trac.osgeo.org/proj4js))。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Teaching about projections is out of the scope of this book. The EPSG codes
    are simply a standardized way to classify and identify the great amount of available
    projections. EPSG:4326 corresponds to the WGS84 (World Geodetic System) and EPSG:900913
    is the Spherical Mercator projection popularized by their use in Google Maps.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于投影的教学超出了本书的范围。EPSG代码只是对大量可用投影进行分类和识别的一种标准化方式。EPSG:4326对应于WGS84（世界大地测量系统），而EPSG:900913是球面墨卡托投影，因其被用于谷歌地图而广受欢迎。
- en: 'Let''s go to see how we can integrate Proj4js with OpenLayers and how easy
    it is to make use of it. The idea is to create an application that shows a map
    and a text area that will show the coordinates of the clicked location:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将Proj4js与OpenLayers集成，以及如何轻松地使用它。想法是创建一个显示地图和文本区域的程序，该文本区域将显示点击位置的坐标：
- en: '![Working with projections](img/7843_08_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![使用投影](img/7843_08_01.jpg)'
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We must place some of the available Proj4js files at our web application directory.
    To do so, perform the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将一些可用的Proj4js文件放置在我们的Web应用程序目录中。为此，请执行以下步骤：
- en: Go to the Proj4js project's web page and download the distribution ZIP file
    (for this recipe we have used [http://download.osgeo.org/proj4js/proj4js-1.1.0.zip)](http://download.osgeo.org/proj4js/proj4js-1.1.0.zip))
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问Proj4js项目的网页并下载分发ZIP文件（对于这个食谱，我们使用了[http://download.osgeo.org/proj4js/proj4js-1.1.0.zip](http://download.osgeo.org/proj4js/proj4js-1.1.0.zip)）
- en: Uncompress the downloaded file and copy the `proj4js-compressed.js` file and
    `defs` folder within your web application folder
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压缩下载的文件，并将`proj4js-compressed.js`文件和`defs`文件夹复制到您的网络应用程序文件夹中
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create an HTML file and add the OpenLayers dependencies. As a dependency, also
    include the `Proj4js` library:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTML文件并添加OpenLayers依赖项。作为一个依赖项，还包括`Proj4js`库：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now add the code for the text area and the map:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加文本区域和地图的代码：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the JavaScript section, create a new control to manage the click event:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript部分，创建一个新的控制来管理点击事件：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On the `trigger` function, add the following code to transform and show the
    coordinates in the `textarea` object:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`trigger`函数上，添加以下代码以在`textarea`对象中转换并显示坐标：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the map instance, add a base layer, and center the viewport:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建地图实例，添加基本图层，并定位视口：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, create a new click control instance and add it to the map:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个新的点击控制实例并将其添加到地图中：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'OpenLayers makes use of the Proj4js code internally when available. So as OpenLayers
    developers we do not need to use the Proj4js API directly, the only requirement
    is to add the Proj4js dependency in our application:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当Proj4js代码可用时，OpenLayers会内部使用Proj4js代码。因此，作为OpenLayers开发者，我们不需要直接使用Proj4js API，唯一的要求是在我们的应用程序中添加Proj4js依赖项：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the user clicks at some place on the map, the click control (that we will
    see later) executes the `trigger` function. The `e` variable contains all the
    click event's information that includes the pixel's xy position.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在地图上的某个位置点击时，点击控制（我们稍后将看到）执行`trigger`函数。`e`变量包含所有点击事件的信息，包括像素的xy位置。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ensure that the projection definition you are using, is defined within the `defs`
    folder. Otherwise you will need to create a new file with the transformation expressed
    in the proj4 notation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您使用的投影定义在`defs`文件夹中定义。否则，您需要创建一个新文件，其中包含以proj4表示法的转换。
- en: Given an `OpenLayers.LonLat` instance, we can translate among projections using
    the `tranform()` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`OpenLayers.LonLat`实例，我们可以使用`transform()`方法在投影之间进行转换。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We always can make use of the `transform()` method but without including the
    Proj4js dependencies, they will only translate between EPSG:4326 and EPSG:900913.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终可以使用`transform()`方法，但如果不包含Proj4js依赖项，它们将仅在EPSG:4326和EPSG:900913之间进行转换。
- en: Thanks to the `OpenLayers.Map.getLonLatFromViewPortPx()` method we can go from
    `OpenLayers.Pixel` to the `OpenLayers.LonLat` instance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`OpenLayers.Map.getLonLatFromViewPortPx()`方法，我们可以从`OpenLayers.Pixel`转换到`OpenLayers.LonLat`实例。
- en: Because the transform method modifies the current instance, we create a new
    one using the `clone()` method to avoid modifying the source variable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为转换方法会修改当前实例，所以我们使用`clone()`方法创建一个新的实例以避免修改源变量。
- en: At this point, the `trigger` method can construct a message string and place
    it within the text area.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`trigger`方法可以构建一个消息字符串并将其放置在文本区域中。
- en: Finally, let's briefly describe the click control used in the recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要描述在食谱中使用的点击控制。
- en: 'The first step is to define the new control as a subclass of the `OpenLayers.Control`
    class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义新的控制作为`OpenLayers.Control`类的子类：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The control will use an `OpenLayers.Handler`, so here we will define some options:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 控制将使用`OpenLayers.Handler`，因此在这里我们将定义一些选项：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `initialize` method is responsible to initialize the control instance.
    First, we create a set of options as a combination (using `OpenLayers.Util.extend()`
    method) of the previously defined object and options passed by the user as arguments:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialize`方法负责初始化控制实例。首先，我们创建一组选项，作为先前定义的对象和用户作为参数传递的选项的组合（使用`OpenLayers.Util.extend()`方法）：'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have initialized an `OpenLayers.Handler.Click` instance to execute the `trigger`
    listener function every time it detects that the user has pressed the mouse button.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经初始化了一个`OpenLayers.Handler.Click`实例，以便每次检测到用户按下鼠标按钮时执行`trigger`监听器函数。
- en: 'Finally, as a good practice we set the `CLASS_NAME` attribute with a string
    identifying our new control class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为一个好的实践，我们设置`CLASS_NAME`属性，使用一个字符串来标识我们的新控制类：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Playing with the map's options* recipe in [Chapter 1](ch01.html "Chapter 1. Web
    Mapping Basics"), *Web Mapping Basics*
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 网络地图基础")的“*使用地图选项进行游戏*”食谱中，*网络地图基础*
- en: The *Creating features programmatically* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Working with Vector Layers*
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. 处理矢量图层")的“*程序化创建要素*”食谱中，*处理矢量图层*
- en: Retrieving remote data with OpenLayers.Request
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenLayers.Request检索远程数据
- en: Data is the basis for a web mapping application. We can add raster or vector
    layers to the map, which will load images or vector information.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是网络地图应用的基础。我们可以在地图上添加栅格或矢量图层，这将加载图像或矢量信息。
- en: In the case of vector layers, thanks to the `OpenLayers.Protocol` and `OpenLayers.Format`
    subclasses, we can configure the layer to load data from different sources and
    with different formats.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在矢量图层的情况下，多亏了 `OpenLayers.Protocol` 和 `OpenLayers.Format` 子类，我们可以配置图层从不同的来源和不同的格式加载数据。
- en: Anyway, there can be circumstances where we need to request data by ourselves,
    read the specific format, and add features. We are talking about making asynchronous
    JavaScript calls.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，可能会有这样的情况，我们需要自己请求数据，读取特定格式，并添加功能。我们正在讨论如何进行异步JavaScript调用。
- en: This recipe shows how we can use the helper class `OpenLayers.Request` to asynchronously
    request data from the remote servers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了我们如何使用辅助类 `OpenLayers.Request` 从远程服务器异步请求数据。
- en: Here, we are going to request a URL that returns random x and y values that
    we will process as point features on the map.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将请求一个返回随机x和y值的URL，我们将这些值作为地图上的点要素进行处理。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OpenLayers is a framework for GIS web developers, so it is designed to be independent
    from other projects, such as jQuery and Dojo that offer facilities to request
    remote data and implement its own.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers是为GIS网络开发者设计的框架，因此它被设计为独立于其他项目，例如jQuery和Dojo，它们提供了请求远程数据和实现自己的功能。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once created the HTML file with OpenLayers library dependencies, add a `div`
    element to hold the map:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含OpenLayers库依赖关系的HTML文件后，添加一个 `div` 元素来容纳地图：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the JavaScript section, create the map instance, add a base layer, and center
    the viewport:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript部分，创建地图实例，添加基本图层，并定位视口：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a vector layer and add to the map:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个矢量图层并将其添加到地图中：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, make a request to the `points.php` utility code, which returns a set
    of random x and y values:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向返回一组随机x和y值的 `points.php` 工具代码发起请求：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In JavaScript, the `XMLHttpRequest` object allows us to communicate with the
    server side.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`XMLHttpRequest` 对象允许我们与服务器端进行通信。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about working with `XMLHttpRequest` can be found on [http://acuriousanimal.com/blog/2011/01/27/working-with-the-javascript-xmlhttprequest-object](http://acuriousanimal.com/blog/2011/01/27/working-with-the-javascript-xmlhttprequest-object)
    and [https://developer.mozilla.org/en/AJAX/Getting_Started](http://https://developer.mozilla.org/en/AJAX/Getting_Started).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用 `XMLHttpRequest` 的更多信息可以在 [http://acuriousanimal.com/blog/2011/01/27/working-with-the-javascript-xmlhttprequest-object](http://acuriousanimal.com/blog/2011/01/27/working-with-the-javascript-xmlhttprequest-object)
    和 [https://developer.mozilla.org/en/AJAX/Getting_Started](https://developer.mozilla.org/en/AJAX/Getting_Started)
    找到。
- en: Due to compatibility problems among browsers, OpenLayers uses a cross-browser
    W3C compliant version of the `XMLHttpRequest` object and wrapping it has implemented
    the `OpenLayers.Request` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器之间的兼容性问题，OpenLayers使用了一个跨浏览器的W3C兼容版本的 `XMLHttpRequest` 对象，并通过包装实现了 `OpenLayers.Request`
    类。
- en: '`OpenLayers.Request` class implements the HTTP methods: `GET, POST, PUT, DELETE,
    HEAD`, and `OPTIONS`, and is used by other OpenLayers classes to get/send data
    from/to remote servers (such as `OpenLayers.Protocol.HTTP).`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Request` 类实现了HTTP方法：`GET, POST, PUT, DELETE, HEAD` 和 `OPTIONS`，并且被其他OpenLayers类用于从/向远程服务器（如
    `OpenLayers.Protocol.HTTP`）获取/发送数据。'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'An HTTP introduction can be found at: [https://developer.mozilla.org/en/HTTP](http://https://developer.mozilla.org/en/HTTP)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP简介可以在：[https://developer.mozilla.org/en/HTTP](https://developer.mozilla.org/en/HTTP)
    找到。
- en: 'In this recipe we have used the `OpenLayers.Request.GET` method with the following
    parameters:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了 `OpenLayers.Request.GET` 方法，并带有以下参数：
- en: '`url:` It is the URL we are going to request'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url:` 它是我们将要请求的URL'
- en: '`params:` It is a set of options parameters we can send in the `GET` request'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params:` 它是一组我们可以发送到 `GET` 请求中的选项参数'
- en: '`success:` It is a callback function to be executed if the URL is successfully
    requested'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`success:` 它是一个在成功请求URL时将被执行的回调函数'
- en: '`failure:` It is a callback function to be executed if any problem occurs'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failure:` 它是一个在发生任何问题时将被执行的回调函数'
- en: In our code, we are requesting the `utils/points.php` passing a `num` parameter,
    this is the same as requesting the URL `utils/points.php?num=100:`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们通过传递一个 `num` 参数请求 `utils/points.php`，这等同于请求URL `utils/points.php?num=100`：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If for some reason the request fails, the method `failure` is executed and will
    show an alert message. On the other hand if the request succeeds we read the returned
    response and add point features to the map.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因请求失败，将执行 `failure` 方法并显示一个警告消息。另一方面，如果请求成功，我们将读取返回的响应并将点特征添加到地图中。
- en: The `points.php` script returns a random number of x and y values, depending
    on the `num` parameter, encoded as JSON array. The response of the call is nothing
    more than a text that must be interpreted and we can find it in the `responseText`
    of the response's property.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`points.php` 脚本根据 `num` 参数返回一个随机的 x 和 y 值，编码为 JSON 数组。调用响应的内容不过是一段需要解释的文本，我们可以在响应的
    `responseText` 属性中找到它。'
- en: To convert the JSON string into a JavaScript object we can use the class `OpenLayers.Format.JSON:`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 JSON 字符串转换为 JavaScript 对象，我们可以使用 `OpenLayers.Format.JSON` 类：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, for each object we read the x and y values and create a point feature:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于每个读取的对象，我们读取 x 和 y 值并创建一个点特征：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The x and y values returned by the PHP scripts goes from -180 to180 for x and
    -80 to 80 for y. Because of this, we translate the coordinates from EPSG:4326
    to EPSG:900913, which is the map's base layer projection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 脚本返回的 x 和 y 值范围从 -180 到 180（x 轴）和 -80 到 80（y 轴）。因此，我们将坐标从 EPSG:4326 转换为
    EPSG:900913，这是地图的基本图层投影。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`OpenLayers.Request` is a powerful class allowing working with almost any HTTP
    method. For example, in addition to the `GET` method we can also use the `POST`
    method to send data to servers.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Request` 是一个功能强大的类，允许使用几乎任何 HTTP 方法。例如，除了 `GET` 方法外，我们还可以使用 `POST`
    方法向服务器发送数据。'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are going to work extensively with AJAX in your application, be sure
    to understand the limitations of **Cross-Domain Requests (XDR)** and the **same
    origin policy** ([http://en.wikipedia.org/wiki/Same_origin_policy](http://en.wikipedia.org/wiki/Same_origin_policy)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在你的应用程序中广泛使用 AJAX，务必了解**跨域请求（XDR）**和**同源策略**（[http://en.wikipedia.org/wiki/Same_origin_policy](http://en.wikipedia.org/wiki/Same_origin_policy)）的限制。
- en: Finally, take a close look at `OpenLayers.Request` class options. You can find
    options, such as `async` to specify if the request must be made synchronously
    or asynchronously, `user/password` to make requests against servers with basic
    authentication, or `headers` to set the HTTP headers of the request.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，仔细查看 `OpenLayers.Request` 类的选项。你可以找到选项，例如 `async` 来指定请求是否必须同步执行，`user/password`
    来对使用基本身份验证的服务器进行请求，或者 `headers` 来设置请求的 HTTP 头。
- en: See also
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Reading features using Protocols directly* recipe in [Chapter 3](ch03.html
    "Chapter 3. Working with Vector Layers"), *Working with Vector Layers*
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 3 章 *Working with Vector Layers* 的 *Reading features using Protocols directly*
    节中，*Working with Vector Layers*，介绍了如何直接使用协议读取特征。
- en: The *Reading and creating features from a WKT* recipe in [Chapter 3](ch03.html
    "Chapter 3. Working with Vector Layers"), *Working with Vector Layers*
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 3 章 *Working with Vector Layers* 的 *Reading and creating features from a
    WKT* 节中，*Working with Vector Layers*，介绍了如何从 WKT 读取和创建特征。
- en: Creating a custom control
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义控件
- en: 'OpenLayers has plenty of controls that address a broad range of needs. Unfortunately,
    the requirements we could have for building a new web application can imply the
    creation of a new one, or the extension of a previous one:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers 提供了大量的控件，可以满足广泛的需求。不幸的是，我们可能需要为构建新的网络应用程序而创建一个新的控件，或者扩展一个现有的控件：
- en: '![Creating a custom control](img/7843_08_02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义控件](img/7843_08_02.jpg)'
- en: In this recipe, we are going to create a new control named **Cross**. The control
    will show a crosshair symbol, as shown in the previous screenshot, similar to
    the target selectors in the ancient war planes, which will show the location it
    is pointing to. In addition, the control will allow registering the click events
    that will return the current location too.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个新的名为 **Cross** 的控件。该控件将显示一个类似于古代战机的目标选择器的十字准线符号，如图中所示，它将显示所指向的位置。此外，该控件将允许注册点击事件，这些事件将返回当前位置。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create an HTML file and add the OpenLayers dependencies, then include the code
    of our new control:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 HTML 文件并添加 OpenLayers 依赖项，然后包含我们新控件的代码：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add the two CSS classes required for the control:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加两个所需的 CSS 类以控制：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, add a `div` element to hold the map:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个 `div` 元素来包含地图：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Within the JavaScript code, create the map instance and add a base layer:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JavaScript 代码中，创建地图实例并添加一个基本图层：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the cross control, add it to the map, and activate it:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建交叉控件，将其添加到地图中，并激活它：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we are going to describe step by step the source code of the new control
    we have created. First, create a new `crossControl.js` file and start applying
    the *best* practice of writing a description about the control:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将逐步描述我们创建的新控制的源代码。首先，创建一个新的 `crossControl.js` 文件，并开始应用关于控制的最佳实践，编写描述：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, create the new `OpenLayers.Control.Cross` class as a subclass of `OpenLayers.Control:`
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的 `OpenLayers.Control.Cross` 类，作为 `OpenLayers.Control:` 的子类。
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define the set of attributes and methods of the new control. The first step
    is to initialize an array with the set of events our control can emit:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义新控制的一组属性和方法。第一步是初始化一个数组，包含我们的控制可以发出的集合事件：
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, there is a `size` property, that is used to know the image control size
    and required to compute the exact control location:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，有一个 `size` 属性，它用于知道图像控制的大小，并且需要计算确切的控制位置：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last attribute is used to store a reference to the DOM element used as
    a label to show the current control target''s location:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个属性用于存储用作标签的 DOM 元素的引用，以显示当前控制目标的位置：
- en: '[PRE28]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we have defined all the required properties used in the class, we need
    to initialize the control. Again, it is a good practice to comment in the source
    code following the OpenLayers conventions:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们定义了类中使用的所有必需属性，我们需要初始化控制。再次强调，按照 OpenLayers 的约定在源代码中进行注释是一个好习惯：
- en: '[PRE29]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to implement the `draw` method, which is called when the control
    is ready to be displayed on the page and is responsible to set the required DOM
    elements to render the control. The first step involves computing the right position
    for the control, which is the middle of the map:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现 `draw` 方法，该方法在控制准备在页面上显示时被调用，并负责设置所需的 DOM 元素以渲染控制。第一步涉及计算控制的位置，即地图的中间位置：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we can call the `draw` method of the superclass to draw the control.
    This will initialize the `this.div` property (inherited from `OpenLayers.Control)`
    with the DOM element that will hold the control. By default a CSS class `olControlCross`
    is added to the `div` element, so we can style it easily:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以调用超类的 `draw` 方法来绘制控制。这将初始化 `this.div` 属性（从 `OpenLayers.Control` 继承而来）与将包含控制的
    DOM 元素。默认情况下，CSS 类 `olControlCross` 被添加到 `div` 元素中，因此我们可以轻松地对其进行样式化：
- en: '[PRE31]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After this, we can create a new `div` element for the label that will show
    the current target''s location. This is done by using the method `OpenLayers.Util.createDiv`.
    In addition, thanks to the `OpenLayers.Element.addClass` method, we set the CSS
    class `olControlCrossText` to the label so the user can style the label:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们可以创建一个新的 `div` 元素用于标签，该标签将显示当前目标的位置。这是通过使用 `OpenLayers.Util.createDiv`
    方法完成的。此外，由于 `OpenLayers.Element.addClass` 方法，我们设置了 CSS 类 `olControlCrossText`
    到标签，以便用户可以对其进行样式化：
- en: '[PRE32]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Compute the current `OpenLayers.LonLat` position and set the label text. We
    omit the code for the `computeLonLat` function that can be found within the control
    class:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算当前的 `OpenLayers.LonLat` 位置并设置标签文本。我们省略了 `computeLonLat` 函数的代码，该函数可以在控制类中找到：
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the label element to the main control element:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签元素添加到主控制元素中：
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As a final step, we register two listeners. First, a listener for the `this.div`
    element to detect when the mouse clicks the control:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们注册了两个监听器。首先，一个监听 `this.div` 元素以检测鼠标点击控制：
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Second, a listener for the map''s `move` event, so we can update the control''s
    location label:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步，添加一个监听地图的 `move` 事件，以便我们可以更新控制的位置标签：
- en: '[PRE36]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And finally, return a reference to the `this.div` element:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回对 `this.div` 元素的引用：
- en: '[PRE37]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next is the code for two listeners. The `onMove` method updates the label''s
    text (target''s location) each time the map is moved:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是两个监听器的代码。`onMove` 方法在地图每次移动时更新标签的文本（目标位置）：
- en: '[PRE38]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `onClick` function is executed when there is a mouse click on the control.
    Its responsibility is to trigger the `crossClick` event so that any outside listener
    can by notified:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在控制上发生鼠标点击时，`onClick` 函数被执行。其责任是触发 `crossClick` 事件，以便任何外部监听器都可以被通知：
- en: '[PRE39]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is the code for the helper function that computes the `OpenLayers.LonLat`
    from the current control''s pixel position:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是计算 `OpenLayers.LonLat` 的辅助函数的代码，从当前控制器的像素位置：
- en: '[PRE40]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Last, but not the least, we have to set the property `CLASS_NAME` with a string
    identifying the control name. By convention, it is the whole namespace of the
    control:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们必须设置属性 `CLASS_NAME`，它是一个字符串，用于标识控制名称。按照惯例，它是控制的整个命名空间：
- en: '[PRE41]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The program does not have much mystery, in addition to the base layer we have
    created a cross control:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们创建的基础图层外，程序没有太多神秘之处，还有一个交叉控件：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have initialized the cross control by registering a listener function on
    the `crossClick` event, which is triggered each time there is a mouse click on
    the cross image.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`crossClick`事件上注册监听函数来初始化交叉控制，该事件在每次点击交叉图像时都会触发。
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Note how we can create the new control class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何创建新的控件类：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'New classes or subclasses are easily created with `OpenLayers.Class`. It requires
    two parameters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`OpenLayers.Class`可以轻松创建新类或子类。它需要两个参数：
- en: The **source** class
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**类'
- en: An **object** with the class definition that will extend the source class
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有类定义的对象，该定义将扩展源类
- en: In our code, we are extending the `OpenLayers.Control` class with the properties
    and functions defined in the second parameter defined in the object literal notation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们通过对象字面量中定义的第二个参数中的属性和函数扩展了`OpenLayers.Control`类。
- en: 'In addition, any class must be initialized using the `initialize` method. The
    usual order of actions to be done is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何类都必须使用`initialize`方法进行初始化。通常要执行的操作的顺序是：
- en: 'Merge the array of `EVENT_TYPES` controls with those defined in the base `OpenLayers.Control`
    class. This means we are extending the base event types with the set defined in
    the new cross control:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`EVENT_TYPES`控制数组的数组与基础`OpenLayers.Control`类中定义的数组合并。这意味着我们正在扩展基础事件类型，以包含新交叉控制中定义的集合：
- en: '[PRE44]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Set a default value for the instance properties if they are not defined in
    the constructor:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在构造函数中未定义实例属性，则为它们设置默认值：
- en: '[PRE45]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Call the superclass constructor. Once we have the subclass initialized, we
    need to initialize the superclass. This is a bottom-top initialization:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用超类构造函数。一旦我们初始化了子类，我们需要初始化超类。这是一个自下而上的初始化：
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See also
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding and removing controls* recipe in [Chapter 5](ch05.html "Chapter 5. Adding
    Controls"), *Adding Controls*
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。添加控件")的*添加控件*配方中，*添加和删除控件*
- en: The *Listening for non OpenLayers events* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Events"), *Working with Events*
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。处理事件")的*监听非OpenLayers事件*配方中，*处理事件*
- en: The *Adding the WMS layer* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。添加栅格图层")的*添加WMS图层*配方中，*添加栅格图层*
- en: Creating a custom renderer
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义渲染器
- en: 'When working with vector layers, styling is a great feature which offers us
    a lot of possibilities: fill color and opacity, stroke color, labels and text
    colors, and so on. But, what if we need more?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当与矢量图层一起工作时，样式是一个强大的功能，它为我们提供了很多可能性：填充颜色和透明度、描边颜色、标签和文字颜色等等。但是，如果我们需要更多呢？
- en: Every `OpenLayers.Layer.Vector` instance contains a renderer that is responsible
    to render the layer's features (such as points, paths, and polygons) on the map
    using the best technologies available in the browser. These can be the HTML5 Canvas
    element ([http://en.wikipedia.org/wiki/Canvas_element](http://en.wikipedia.org/wiki/Canvas_element))
    available in many modern browsers (such as Firefox or Chrome), SVG ([http://en.wikipedia.org/wiki/Scalable_Vector_Graphics](http://en.wikipedia.org/wiki/Scalable_Vector_Graphics)),
    or VML ([http://en.wikipedia.org/wiki/Vector_Markup_Language](http://en.wikipedia.org/wiki/Vector_Markup_Language)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`OpenLayers.Layer.Vector`实例都包含一个渲染器，该渲染器负责使用浏览器中可用的最佳技术渲染图层特征（如点、路径和多边形）在地图上。这些可以是许多现代浏览器（如Firefox或Chrome）中可用的HTML5
    Canvas元素([http://en.wikipedia.org/wiki/Canvas_element](http://en.wikipedia.org/wiki/Canvas_element))，SVG([http://en.wikipedia.org/wiki/Scalable_Vector_Graphics](http://en.wikipedia.org/wiki/Scalable_Vector_Graphics))，或VML([http://en.wikipedia.org/wiki/Vector_Markup_Language](http://en.wikipedia.org/wiki/Vector_Markup_Language))。
- en: When `OpenLayers.Layer.Vector` is initialized, OpenLayers looks for the best
    available rendering engine and creates an instance of `OpenLayers.Renderer` that
    will render the features on the map.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当`OpenLayers.Layer.Vector`被初始化时，OpenLayers会寻找最佳可用的渲染引擎，并创建一个`OpenLayers.Renderer`实例，该实例将渲染地图上的特征。
- en: The goal of this recipe is to show how we can create a new renderer to improve
    the visualization of the features.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方旨在展示我们如何创建一个新的渲染器来改进特征的可视化。
- en: '![Creating a custom renderer](img/7843_08_03.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义渲染器](img/7843_08_03.jpg)'
- en: The previous screenshot shows some styled point geometry features and was rendered
    using the default OpenLayers renderer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了某些样式化的点几何特征，并使用默认的OpenLayers渲染器进行渲染。
- en: 'The following screenshot shows the same features rendered with our new renderer
    implementation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用我们新的渲染器实现渲染的相同特征：
- en: '![Creating a custom renderer](img/7843_08_04.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义渲染器](img/7843_08_04.jpg)'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We are going to extend `OpenLayers.Renderer.Canvas`, to improve visualizations.
    This renderer works using the HTML5 Canvas element. This means the new renderer
    only will work on HTML5 compliant browsers. You can check if the canvas element
    is supported by your browser at: [http://html5test.com](http://html5test.com)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展`OpenLayers.Renderer.Canvas`，以改进可视化。这个渲染器使用HTML5 Canvas元素。这意味着新的渲染器只能在HTML5兼容的浏览器上工作。您可以在[http://html5test.com](http://html5test.com)检查您的浏览器是否支持canvas元素：
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once an HTML file is created with OpenLayers dependencies, the first step is
    to include the file with the new renderer class'' implementation:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含OpenLayers依赖项的HTML文件后，第一步是包含具有新渲染器类实现的文件：
- en: '[PRE47]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, as usual you can add the `div` element that will hold the map:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，像往常一样，你可以添加将包含地图的`div`元素：
- en: '[PRE48]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the JavaScript section, add the following code to initialize the map and
    add a base layer:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript部分，添加以下代码以初始化地图并添加一个基本图层：
- en: '[PRE49]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Center the map''s viewport:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将地图的视口居中：
- en: '[PRE50]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a `StyleMap` instance with a **unique value rule** based on the `POP_RANK`
    attribute of the features:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于特征的`POP_RANK`属性的**唯一值规则**创建一个`StyleMap`实例：
- en: '[PRE51]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the vector layer and add it to the map:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建矢量图层并将其添加到地图中：
- en: '[PRE52]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s go to see the `OpenLayers.Renderer.Gradient` implementation that beautifies
    our point''s features that are rendered with a nice gradient style. Start creating
    a JavaScript file named `gradientRenderer.js`, which we have included previously
    in the main program. Following good practices, we start the commenting in the
    file:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`OpenLayers.Renderer.Gradient`的实现，它美化了以漂亮的渐变样式渲染的点特征。开始创建一个名为`gradientRenderer.js`的JavaScript文件，我们之前已经在主程序中包含了它。遵循良好的实践，我们在文件中开始注释：
- en: '[PRE53]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, create an `OpenLayers.Renderer.Canvas` subclass named `OpenLayers.Renderer.Gradient:`
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`OpenLayers.Renderer.Canvas`的子类，命名为`OpenLayers.Renderer.Gradient`：
- en: '[PRE54]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The first method to implement in a new OpenLayers class must be the `initialize()`
    method:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的OpenLayers类中要实现的第一种方法是`initialize()`方法：
- en: '[PRE55]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we implement the `drawPoint()` method, inherited from the `OpenLayers.Renderer.Canvas`
    class, which is responsible to render the point geometry features of the layer.
    Now, the method receives three parameters: the geometry object, the style to apply,
    and the feature identifier attribute:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现`drawPoint()`方法，该方法继承自`OpenLayers.Renderer.Canvas`类，负责渲染图层中的点几何特征。现在，该方法接收三个参数：几何对象、要应用的样式以及特征标识属性：
- en: '[PRE56]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'From the `geometry` parameter, compute the exact pixel position of the point.
    This can be done with the `getLocalXY()` method inherited from the `OpenLayers.Renderer.Canvas`
    class:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`geometry`参数中，使用从`OpenLayers.Renderer.Canvas`类继承的`getLocalXY()`方法计算点的确切像素位置。
- en: '[PRE57]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using the `fillColor` and `fillOpacity` properties create a string for the
    color to be applied for the gradient:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fillColor`和`fillOpacity`属性创建一个字符串，用于应用渐变的颜色：
- en: '[PRE58]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then create a canvas gradient, centered in the feature''s location and with
    the radius value specified in the feature''s style:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个以特征位置为中心、半径值由特征样式指定的canvas渐变：
- en: '[PRE59]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define the necessary steps so that the gradient goes from white to the previously
    created RGB color:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义必要的步骤，以便渐变从白色渐变到之前创建的RGB颜色：
- en: '[PRE60]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, identify the new class by setting the `CLASS_NAME` property:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过设置`CLASS_NAME`属性来识别新的类：
- en: '[PRE61]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The important point of this recipe resides in one of the properties we have
    specified for the vector layer, the `renderers.`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的重要点在于我们为矢量图层指定的一个属性，即`renderers`。
- en: 'The `renderers` property allows us to specify the set of `OpenLayers.Renderer`
    that the layer can make use of. Usually this property is never used and by default,
    its value is: `renderers: [''SVG'', ''VML'', ''Canvas'']`. This means the supported
    renderer instances the layer can use are `OpenLayers.Renderer.SVG, OpenLayers.Renderer.VML`,
    and `OpenLayers.Renderer.Canvas`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderers`属性允许我们指定图层可以使用的`OpenLayers.Renderer`集合。通常这个属性从不使用，并且默认值是：`renderers:
    [''SVG'', ''VML'', ''Canvas'']`。这意味着图层可以使用的支持的渲染器实例是`OpenLayers.Renderer.SVG,
    OpenLayers.Renderer.VML`和`OpenLayers.Renderer.Canvas`。'
- en: 'For this recipe, we have created the class `OpenLayers.Renderer.Gradient`,
    which we will describe later. The setting `renderers: ["Gradient"]` means we only
    want to allow the layer to work with an `OpenLayers.Renderer.Gradient` instance.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '对于这个菜谱，我们创建了`OpenLayers.Renderer.Gradient`类，我们将在后面描述。设置`renderers: ["Gradient"]`意味着我们只想允许图层与`OpenLayers.Renderer.Gradient`实例一起工作。'
- en: 'Let''s describe in more detail how to initialize the vector layer:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地描述如何初始化矢量图层：
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In addition to the renderers, we have used an `OpenLayers.Protocol.HTTP` instance
    with an `OpenLayers.Format.GeoJSON` instance, to load a GeoJSON file with some
    cities around the world. The features within the file have, among others, the
    `POP_RANK` attribute.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除了渲染器之外，我们还使用了一个`OpenLayers.Protocol.HTTP`实例和一个`OpenLayers.Format.GeoJSON`实例，来加载包含世界上一些城市的GeoJSON文件。文件中的特征包括`POP_RANK`属性等。
- en: Thanks to the `OpenLayers.Strategy.Fixed` strategy instance, the layer loads
    the data source, through the previous protocol, only once. We have no need to
    load the file each time the map is zoomed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`OpenLayers.Strategy.Fixed`策略实例，图层只通过之前的协议加载数据源一次。我们不需要在地图缩放时每次都加载文件。
- en: 'Last, but not the least, we have set the `styleMap` property to a previously
    created `OpenLayers.StyleMap` instance:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们已经将`styleMap`属性设置为一个先前创建的`OpenLayers.StyleMap`实例：
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This style map is defined making use of the unique value rule feature based
    on the `POP_RANK` attribute. This property takes values from `1` to `7`, so we
    define a symbolizer hash style for each possible value, playing with the radius
    and fill color properties:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个样式图是通过基于`POP_RANK`属性的唯一值规则功能定义的。该属性从`1`到`7`取值，因此我们为每个可能的值定义了一个符号化哈希样式，通过调整半径和填充颜色属性：
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: For the main program, there is nothing more to comment, except for the way we
    have centered the map's viewport.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主程序，没有更多要评论的，除了我们如何使地图视口居中的方式。
- en: Because the base layer is `OpenStreetMap`, which by default uses an EPSG:900913
    projection, and we have specified the center in the EPSG:4326 projection, we need
    to transform the coordinates to the appropriate map's projection.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因为基本图层是`OpenStreetMap`，默认使用EPSG:900913投影，而我们指定了EPSG:4326投影的中心，所以我们需要将坐标转换到适当的地图投影。
- en: There's more...
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Usually, this `initialize` method starts calling the `initialize` method of
    its parent class and then sets the concrete properties of the instance.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个`initialize`方法会先调用其父类的`initialize`方法，然后设置实例的具体属性。
- en: 'In this case, our class has no specific property to initialize, so it is not
    strictly necessary to implement this method, but as an example, (and as a good
    practice) we have written the call to the parent class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的类没有特定的初始化属性，因此实现这个方法并不是严格必要的，但作为一个例子（以及良好的实践），我们已经编写了对父类调用的代码：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The process followed within the `OpenLayers.Renderer.Canvas` class to render
    the features of a layer is a bit complex, but can be summarized as:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OpenLayers.Renderer.Canvas`类中遵循的渲染图层特征的过程稍微复杂一些，但可以总结如下：
- en: For each feature the class checks its geometry
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个特征，类都会检查其几何形状
- en: Depending on the geometry type the class invokes a different method specially
    designed to render points, lines, or polygons
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据几何类型，类会调用专门设计用于渲染点、线或多边形的不同方法
- en: Because our renderer is implemented to beautify points we only have rewritten
    the `drawPoint` method, which is responsible to render point geometries.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的渲染器是为了美化点而实现的，所以我们只重写了`drawPoint`方法，该方法负责渲染点几何形状。
- en: The renderer we have defined here uses the HTML5 canvas element, because of
    this, the main part of the recipe is related to this technology.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的渲染器使用HTML5 canvas元素，因此菜谱的主要部分与这项技术相关。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Lots of information about the HTML5 canvas element can be found on the Internet.
    We want to point to this tutorial from the Mozilla project: [https://developer.mozilla.org/en/Canvas_tutorial](http://https://developer.mozilla.org/en/Canvas_tutorial).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 关于HTML5 canvas元素的信息可以在互联网上找到。我们想指向Mozilla项目中的这个教程：[https://developer.mozilla.org/en/Canvas_tutorial](http://https://developer.mozilla.org/en/Canvas_tutorial)。
- en: A great exercise would be to create an SVG version of this renderer. This way,
    the possibility to render gradient points would be available in more browsers.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的练习是创建这个渲染器的SVG版本。这样，就可以在更多浏览器中渲染渐变点。
- en: See also
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a custom control* recipe
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自定义控件*菜谱'
- en: The *Styling features using symbolizers* recipe in [Chapter 7](ch07.html "Chapter 7. Styling
    Features"), *Styling Features*
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。样式化特征")的“样式化特征”中的*使用符号化样式化特征*菜谱
- en: The *Defining custom rules to style features* recipe in [Chapter 7](ch07.html
    "Chapter 7. Styling Features"), *Styling Features*
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。样式化特征")的“样式化特征”中的*定义自定义规则以样式化特征*菜谱
- en: Selecting features intersecting with a line
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择与线相交的特征
- en: One common action when working with features within a vector layer is its selection
    and, of course, OpenLayers has some feature selection controls.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理矢量层中的特征时，一个常见的操作是选择特征，当然，OpenLayers有一些特征选择控件。
- en: The `OpenLayers.Control.SelectFeature` control is specially useful as a selection
    control because the selection is made on the client side, that is, the selection
    is made through the features loaded in the browser. There is no request to a WFS
    server.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Control.SelectFeature`控件特别有用作为选择控件，因为选择是在客户端进行的，也就是说，选择是通过浏览器中加载的特征进行的。没有向WFS服务器发出请求。'
- en: The `OpenLayers.Control.SelectFeature` control can work in different ways. We
    can select a feature just by clicking on it or we can draw a box to select all
    the contained features.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Control.SelectFeature`控件可以以不同的方式工作。我们可以通过点击来选择一个特征，或者我们可以画一个框来选择所有包含的特征。'
- en: In contrast, it does not allow the possibility to select features that intersect
    with a path.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，它不允许选择与路径相交的特征。
- en: In this recipe, we are going to see how we can extend the `OpenLayers.Control.SelectFeature`
    control to allow select features for drawing a path.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何扩展`OpenLayers.Control.SelectFeature`控件以允许通过绘制路径选择特征。
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create an HTML5 file and add the OpenLayers library dependencies. Now, include
    the code for the new `OpenLayers.Control.SelectFeature` control:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTML5文件并添加OpenLayers库依赖项。现在，包括新的`OpenLayers.Control.SelectFeature`控件的代码：
- en: '[PRE66]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Within the `body` section, add a `div` element to hold the map instance:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`body`部分中，添加一个`div`元素来容纳地图实例：
- en: '[PRE67]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, place the JavaScript code within a `script` element at the document''s
    `head` element:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将JavaScript代码放置在文档的`head`元素中的`script`元素内：
- en: '[PRE68]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create the map instance, add a base layer, and center the viewport:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建地图实例，添加基础图层，并居中视口：
- en: '[PRE69]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, create a vector layer that loads a GML file with the European countries:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个加载欧洲国家GML文件的矢量图层：
- en: '[PRE70]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, create an instance of our new `OpenLayers.Control.SelectFeaturePath`
    control, add it to the map and activate it:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建我们新的`OpenLayers.Control.SelectFeaturePath`控件实例，将其添加到地图中并激活它：
- en: '[PRE71]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we are going to see the new `SelectFeaturePath` control''s implementation.
    Create a `selectFeaturePath.js` file and add some control description:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将看到新的`SelectFeaturePath`控制器的实现。创建一个`selectFeaturePath.js`文件并添加一些控制描述：
- en: '[PRE72]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create the new class:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的类：
- en: '[PRE73]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Implement the `initialize` method responsible for initializing the control.
    Note how we call the super class''s `initialize` method also, to initialize the
    parent class:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现负责初始化控件的`initialize`方法。注意我们如何调用父类的`initialize`方法来初始化父类：
- en: '[PRE74]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Implement the `selectPath` method. This method selects those features which
    intersect with the created line:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`selectPath`方法。此方法选择与创建的线相交的特征：
- en: '[PRE75]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, create a unique identifier for the class:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为类创建一个唯一的标识符：
- en: '[PRE76]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main program does not have much mystery. We have created a map, added a
    vector layer, and then added our custom `SelectFeaturePath` control:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序没有太多神秘之处。我们创建了一个地图，添加了一个矢量图层，然后添加了我们的自定义`SelectFeaturePath`控件：
- en: '[PRE77]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Note how we have transformed the coordinates to center the map''s viewport.
    This is because we are specifying the location in EPSG:4326 and the map is using
    a base layer with EPSG:900913:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将坐标转换以使地图视口居中的。这是因为我们正在指定EPSG:4326坐标系中的位置，而地图使用的是EPSG:900913的基础图层：
- en: '[PRE78]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Because our control is an extension of the `OpenLayers.Control.SelectFeature`
    control, it is important to describe it briefly before going into the code's description.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的控件是`OpenLayers.Control.SelectFeature`控件的扩展，所以在进入代码描述之前简要描述它很重要。
- en: As we commented at the beginning of the recipe, this control works on the client
    side, that is, no request is made to the data source. The control iterates over
    all features in a layer (or layers) and selects those features that match the
    criteria.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在菜谱开头所评论的，此控件在客户端工作，也就是说，没有向数据源发出请求。控件遍历图层（或图层集）中的所有特征，并选择符合标准的特征。
- en: By default, without specifying any options on its instantiation, the control
    allows us to select features by clicking on it. We can also set properties, such
    as the `hover` property, which allows us to highlight the feature pointed by the
    mouse or, the important one here, the `box` property, which allows the feature
    selection to draw a box.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在实例化时未指定任何选项，控制允许我们通过点击它来选择要素。我们还可以设置属性，例如`hover`属性，允许我们突出显示鼠标所指的要素，或者在这里很重要的`box`属性，允许通过绘制框来选择要素。
- en: This is done because the control internally uses an instance of an `OpenLayers.Handler.Box`
    handler, which is responsible to draw a box and returns a bounding box's coordinates
    so the control can check which features are inside the box.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是因为控制内部使用了一个`OpenLayers.Handler.Box`处理器的实例，它负责绘制一个框并返回边界框的坐标，以便控制可以检查哪些要素在框内。
- en: The idea to extend our control and allow selecting features just by drawing
    a path is simple, instead of using an `OpenLayers.Handler.Box` handler we are
    going to use an `OpenLayers.Handler.Path` handler.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展我们的控制并允许通过绘制路径来选择要素的想法很简单，我们不再使用`OpenLayers.Handler.Box`处理器，而是将使用`OpenLayers.Handler.Path`处理器。
- en: All right, we have background knowledge about what we need. Let's go to see
    how we have done.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经了解了我们需要的基础知识。让我们去看看我们做得怎么样。
- en: 'We have created the new `OpenLayers.Control.SelectFeaturePath` class using
    the `OpenLayers.Class` method. This class allows merging the properties and methods
    of two objects:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`OpenLayers.Class`方法创建了新的`OpenLayers.Control.SelectFeaturePath`类。这个类允许合并两个对象的属性和方法：
- en: '[PRE79]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the previous line, we are merging the properties and methods of the `OpenLayers.Control.SelectFeature`
    class with those defined in the second argument, which is an object in the literal
    notation.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中，我们正在合并`OpenLayers.Control.SelectFeature`类的属性和方法与第二个参数中定义的属性，该参数是一个字面量表示法中的对象。
- en: Within the `initialize()` method, it is important we set the `box` and `handlers.box`
    properties inherited from the superclass. Setting the `handlers.box` to a new
    instance of `OpenLayers.Handler.Path` makes the control use a path handler instead
    of a box handler to select the features.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize()`方法中，设置从超类继承的`box`和`handlers.box`属性非常重要。将`handlers.box`设置为`OpenLayers.Handler.Path`的新实例使控制使用路径处理器而不是框处理器来选择要素。
- en: 'The `box` property set to `true` indicates we want to select the features using
    a handler instead of simply clicking on them:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 设置为`true`的`box`属性表示我们想要使用处理器而不是简单地点击来选择要素：
- en: '[PRE80]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Using a property called `handlers.box` to specify a path handler is not the
    clearest way to do it, but in contrast, is the easiest one. The `OpenLayers.Control.SelectFeature`
    class uses this property to get the appropriate handler to make the selection.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为`handlers.box`的属性来指定路径处理器并不是最清晰的方法，但相比之下，这是最简单的方法。`OpenLayers.Control.SelectFeature`类使用这个属性来获取适当的处理器以进行选择。
- en: In the previous code, when the path handler is initialized, we have set a listener
    function for the `done` event, which is triggered when the path handler finishes
    drawing the line.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当路径处理器初始化时，我们为`done`事件设置了一个监听函数，该事件在路径处理器完成绘制线条时触发。
- en: The `selectPath` method, is responsible to find out which features of the layer
    intersect the path and change its renderer style to highlight them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectPath`方法负责找出哪些要素与路径相交，并更改其渲染样式以突出显示它们。'
- en: 'Note, the listener function receives an `OpenLayers.Geometry.LineString` instance
    with the created path:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，监听函数接收一个包含创建的路径的`OpenLayers.Geometry.LineString`实例：
- en: '[PRE81]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Because the control can work with more than one layer, we need to iterate over
    all the layers and all the features on each layer:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因为控制可以与多个图层一起工作，所以我们需要遍历所有图层以及每个图层上的所有要素：
- en: '[PRE82]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'After checking if the feature is visible we can check whether the feature intersects
    with the path, using the `intersects` method:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查要素是否可见之后，我们可以使用`intersects`方法检查要素是否与路径相交：
- en: '[PRE83]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `OpenLayers.Util.indexOf(array, object)` function returns the index at which
    an object is found within an array.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Util.indexOf(array, object)`函数返回一个对象在数组中找到的索引。'
- en: To change the rendering style of the feature, we simply call the method `select`
    inherited from the `OpenLayers.Control.SelectFeature` class.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改要素的渲染样式，我们只需调用从`OpenLayers.Control.SelectFeature`类继承的`select`方法。
- en: Note
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A vector layer can render the features using different styles, called render
    intents: default, select, or temporary are the default render intents we can use.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 向量图层可以使用不同的样式渲染特征，称为渲染意图：默认、选择或临时是我们可以使用的基本渲染意图。
- en: See also
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a custom renderer* recipe
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自定义渲染器*的食谱'
- en: The *Playing with StyleMap and the render intents* recipe in [Chapter 7](ch07.html
    "Chapter 7. Styling Features"), *Styling Features*
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第7章“特征样式”的“使用StyleMap和渲染意图”食谱中，*样式特征*
- en: Making an animation with image layers
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图像图层制作动画
- en: When working with geographic information, its geometrical representation within
    the space is not the only important thing. Day by day time is becoming a new and
    important dimension to take into account.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理地理信息时，其空间中的几何表示并不是唯一重要的事情。日复一日，时间正成为需要考虑的新维度。
- en: 'This way, visualizations must show how data changes over time: city population,
    country frontiers, roads built, and so on.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，可视化必须显示数据随时间的变化：城市人口、国家边界、道路建设等等。
- en: 'There are many solutions to animate the data evolution through time but, as
    always, we work with web technologies, there are two groups: the solutions based
    on the server side and those based on the client side.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以动画化数据随时间的变化，但正如往常一样，我们使用Web技术，可以分为两组：基于服务器端和基于客户端的解决方案。
- en: For server-side solutions, we can find the `TIME` parameter in the WMS and WFS
    standards. It allows us to request for raster or vector data in a specific time
    or within a range.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器端解决方案，我们可以在WMS和WFS标准中找到`TIME`参数。它允许我们请求特定时间或时间范围内的栅格或矢量数据。
- en: Server solutions means the client must request the server every time we want
    to show the data for a different interval.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端解决方案意味着客户端必须在我们想要显示不同区间数据时每次都请求服务器。
- en: For the client side, a simple solution is to have in the memory all the data,
    and only show those that correspond to the interval we are interested in.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端，一个简单的解决方案是在内存中保存所有数据，并且只显示我们感兴趣的区间对应的数据。
- en: In this recipe we are going to show how easily we can create an animation on
    the client side.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将展示如何轻松地在客户端创建动画。
- en: 'We are going to load some images from **NEXTRAD** ([http://en.wikipedia.org/wiki/NEXRAD](http://en.wikipedia.org/wiki/NEXRAD)),
    showing the rain evolution at different time instants (as shown in the following
    screenshot), and we will create an animation by simply showing or hiding images:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从**NEXTRAD**（[http://en.wikipedia.org/wiki/NEXRAD](http://en.wikipedia.org/wiki/NEXRAD)）加载一些图像，展示不同时间点的降雨演变（如图下截图所示），并且我们将通过简单地显示或隐藏图像来创建动画：
- en: '![Making an animation with image layers](img/7843_08_05.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![使用图像图层制作动画](img/7843_08_05.jpg)'
- en: How to do it...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new HTML file and add the OpenLayers dependencies. In the `body` section
    start adding the elements necessary for the play button and the slider:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的HTML文件，并添加OpenLayers依赖项。在`body`部分开始添加播放按钮和滑块所需的元素：
- en: '[PRE84]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to OpenLayers, we are using the Dojo Toolkit framework ([http://dojotoolkit.org](http://dojotoolkit.org))
    to create more attractive user interfaces. Learning Dojo is out of the scope of
    this book and also, it is not necessary to know it to understand this recipe.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了OpenLayers，我们还使用Dojo Toolkit框架（[http://dojotoolkit.org](http://dojotoolkit.org)）来创建更吸引人的用户界面。学习Dojo超出了本书的范围，而且，了解它也不是理解本食谱所必需的。
- en: 'Next, add the `div` element to hold the map:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`div`元素来包含地图：
- en: '[PRE85]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, in the header section add the next JavaScript code. Start initializing
    the map instance, add a base layer, and center the viewport:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在头部部分添加以下JavaScript代码。开始初始化地图实例，添加一个基本图层，并定位视口：
- en: '[PRE86]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, we are going to create some raster image layers, add them to the map,
    and also store them on an array to control their visibility:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一些栅格图像图层，将它们添加到地图中，并将它们存储在数组中以控制它们的可见性：
- en: '[PRE87]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The following code controls the changes in the slider widget:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码控制滑块小部件的变化：
- en: '[PRE88]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, the following code controls the automatic animation when the **Play**
    button is clicked:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以下代码控制当点击**播放**按钮时的自动动画：
- en: '[PRE89]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How it works...
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As mentioned at the beginning of this recipe, the idea is to animate some weather
    radar on the client side. For this reason, we load a set of images from the server,
    creating a layer for each one.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如本食谱开头所述，想法是在客户端动画化一些天气雷达。因此，我们从服务器加载一系列图像，为每个图像创建一个图层。
- en: 'The `OpenLayers.Layer.Image` class is used here to hold each image as a single
    layer. Its constructor requires five parameters:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`OpenLayers.Layer.Image`类来保存每个图像作为一个单独的层。其构造函数需要五个参数：
- en: '`name:` The name of the layer'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name:` 层的名称'
- en: '`url:` The URL where the image must be taken'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url:` 图像必须获取的URL'
- en: '`extent:` The bounds of the image within the map'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extent:` 图像在地图内的范围'
- en: '`size:` The size in pixels'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size:` 像素大小'
- en: '`options:` A set of options to be passed to the layer'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options:` 要传递给层的选项集'
- en: Note
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `extent` and the `size` arguments are used to compute the resolution of
    the image.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`extent`和`size`参数用于计算图像的分辨率。'
- en: In our case, all the image layers will have the same `extent` and `size:`
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，所有图像层将具有相同的`extent`和`size`：
- en: '[PRE90]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Later, within the loop to create all the image layers, we are setting dynamically
    the value of the `img_url` variable and passing some options to the `OpenLayers.Layer.Image`
    constructor:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建所有图像层的循环中，我们动态设置`img_url`变量的值，并将一些选项传递给`OpenLayers.Layer.Image`构造函数：
- en: '[PRE91]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'By setting the `isBaseLayer` property to `false` we are specifying that our
    layer is not a base layer, it will act as an overlay. In addition, we set the
    `visibility` property to `false` to initially hide the layer. Later, we will set
    the first image layer as the visible one:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`isBaseLayer`属性设置为`false`，我们指定我们的层不是基础层，它将作为覆盖层。此外，我们将`visibility`属性设置为`false`以最初隐藏层。稍后，我们将设置第一个图像层为可见层：
- en: '[PRE92]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `alwaysInRange` property is inherited from the superclass `OpenLayers.Layer`
    and specially useful in this case. We want our image layer to be visible at any
    zoom level. We do not want OpenLayers to compute the right resolution; given the
    image layer extent and size, the layer must be shown. So, setting `alwaysInRange`
    to `true` makes the layer always visible.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`alwaysInRange`属性是从超类`OpenLayers.Layer`继承的，在此情况下特别有用。我们希望我们的图像层在任何缩放级别都可见。我们不希望OpenLayers计算正确的分辨率；给定图像层的范围和大小，层必须显示。因此，将`alwaysInRange`设置为`true`使层始终可见。'
- en: 'Next, we are going to see how to automatically automate the animation. The
    `animateAction` is executed when the play button is pressed. It is a toggle button,
    so depending on its state, the boolean `checked` parameter will be true if checked
    or false if not:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何自动自动化动画。当按下播放按钮时执行`animateAction`。它是一个切换按钮，因此根据其状态，布尔参数`checked`如果被选中则为`true`，如果没有选中则为`false`：
- en: '[PRE93]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'If the play button is checked, then we create an interval to execute the given
    anonymous function every 50 milliseconds which, in fact, increases the value of
    the slider and calls the `animation` function:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果播放按钮被选中，则我们创建一个间隔，每50毫秒执行一次给定的匿名函数，实际上增加了滑块的值并调用`animation`函数：
- en: '[PRE94]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If the button is unchecked, then we remove the interval reference to stop the
    execution:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮未选中，则我们移除间隔引用以停止执行：
- en: '[PRE95]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Note
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Intervals** and **timeouts** are used in JavaScript to create animations
    and delays.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**间隔**和**超时**在JavaScript中用于创建动画和延迟。'
- en: A good explanation of intervals in JavaScript can be found at [http://www.w3schools.com/jsref/met_win_setinterval.asp](http://www.w3schools.com/jsref/met_win_setinterval.asp).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://www.w3schools.com/jsref/met_win_setinterval.asp](http://www.w3schools.com/jsref/met_win_setinterval.asp)找到JavaScript中关于间隔的良好解释。
- en: Finally, let's take a look at the `animation` function, which is responsible
    to change the layer visibilities and create the animation effect.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`animation`函数，它负责更改层可见性和创建动画效果。
- en: 'All the layers are added to the map and also stored in the `imgArray`. The
    global `currentIndex` variable is used to hold the current visible layer. The
    animation function does three things:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 所有层都添加到地图中，并存储在`imgArray`中。全局`currentIndex`变量用于保存当前可见层。动画函数执行三件事：
- en: Hides the current visible layer
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏当前可见层
- en: Given the numeric `value`, that varies from 0 to 100, computes the layer array
    index, that goes from 0 to 31
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个从0到100的数值`value`，计算层数组索引，该索引从0到31
- en: Shows the new current layer
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示新的当前层
- en: '[PRE96]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: That's all! Once the set of layers is loaded in the client side, using any modern
    browser, the performance of the animation is good enough.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部！一旦将层集加载到客户端，使用任何现代浏览器，动画的性能都足够好。
- en: This is only a sample, so there are tons of things to improve. For example,
    think on how to implement a situation where we have a remote server with hundreds
    of images to load sequentially. In this case we cannot load all images at once
    because that can cause an out-of-memory problem in the browser.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个示例，所以有很多地方可以改进。例如，考虑如何实现一个情况，即我们有一个远程服务器，上面有数百张图片需要顺序加载。在这种情况下，我们不能一次性加载所有图片，因为这可能会在浏览器中引起内存不足的问题。
- en: Supposing we have thousands of images to animate, we could implement some buffer
    strategy. Given a buffer of ten images, we can load the first ten images from
    the server, then animate them and when the animation arrives to the last loaded
    image, load the next ten images from the server.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一千张图片需要动画化，我们可以实施一些缓冲策略。给定一个包含十张图片的缓冲区，我们可以从服务器加载前十张图片，然后对它们进行动画处理，当动画到达最后加载的图片时，再从服务器加载下十张图片。
- en: As we can see, these situations are out of the scope of this book and not only
    related to OpenLayers but with software architecture and design.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这些情况超出了本书的范围，不仅与OpenLayers有关，还与软件架构和设计有关。
- en: See also
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating an Image layer* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。添加栅格图层")的*创建图像图层*配方中，*添加栅格图层*
- en: The *Changing layer opacity* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。添加栅格图层")的*改变图层不透明度*配方中，*添加栅格图层*
