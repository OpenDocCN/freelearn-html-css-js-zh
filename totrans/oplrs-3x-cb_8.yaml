- en: Chapter 8. Beyond the Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with projections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting remote data with `OpenLayers.Request`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting features intersecting with a line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an animation with image layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenLayers is a big and complex framework. There is no other option available
    for a framework that allows working with many GIS standards, reading from many
    different data sources, rendering on different browser technologies, and so on.
    This power comes with a price.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of OpenLayers tries to have as less dependencies on external
    libraries as possible. This means, OpenLayers requires implementing many features
    that we can find in other projects: DOM elements'' manipulation, AJAX requests,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows some of these features, in addition to other possible common
    needs we can require in our day-to-day work that are not explained in other chapters,
    such as creation of layer animations or the implementation of custom controls.
    Because of this, the chapter is more suited for more experienced JavaScript programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Working with projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to other JavaScript mapping libraries, OpenLayers allows working
    with a great number of projections.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we specify the desired projection for the map. Later when adding a
    vector layer to the map, we need to specify to the layer projection so that OpenLayers
    transforms features from the layer's projection to the map's projection.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, by default, OpenLayers has a great limitation on projections: we can only
    use **EPSG:4326** and **EPSG:900913**. Why? Because transforming between projections
    is not a simple task and there are other great projects that can make it.'
  prefs: []
  type: TYPE_NORMAL
- en: So, when we want to work with projections other than EPSG:4326 and EPSG:900913,
    OpenLayers uses **Proj4js Library** ([http://trac.osgeo.org/proj4js](http://trac.osgeo.org/proj4js)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Teaching about projections is out of the scope of this book. The EPSG codes
    are simply a standardized way to classify and identify the great amount of available
    projections. EPSG:4326 corresponds to the WGS84 (World Geodetic System) and EPSG:900913
    is the Spherical Mercator projection popularized by their use in Google Maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to see how we can integrate Proj4js with OpenLayers and how easy
    it is to make use of it. The idea is to create an application that shows a map
    and a text area that will show the coordinates of the clicked location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with projections](img/7843_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must place some of the available Proj4js files at our web application directory.
    To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Proj4js project's web page and download the distribution ZIP file
    (for this recipe we have used [http://download.osgeo.org/proj4js/proj4js-1.1.0.zip)](http://download.osgeo.org/proj4js/proj4js-1.1.0.zip))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncompress the downloaded file and copy the `proj4js-compressed.js` file and
    `defs` folder within your web application folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file and add the OpenLayers dependencies. As a dependency, also
    include the `Proj4js` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the code for the text area and the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the JavaScript section, create a new control to manage the click event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the `trigger` function, add the following code to transform and show the
    coordinates in the `textarea` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the map instance, add a base layer, and center the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a new click control instance and add it to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenLayers makes use of the Proj4js code internally when available. So as OpenLayers
    developers we do not need to use the Proj4js API directly, the only requirement
    is to add the Proj4js dependency in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks at some place on the map, the click control (that we will
    see later) executes the `trigger` function. The `e` variable contains all the
    click event's information that includes the pixel's xy position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure that the projection definition you are using, is defined within the `defs`
    folder. Otherwise you will need to create a new file with the transformation expressed
    in the proj4 notation.
  prefs: []
  type: TYPE_NORMAL
- en: Given an `OpenLayers.LonLat` instance, we can translate among projections using
    the `tranform()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We always can make use of the `transform()` method but without including the
    Proj4js dependencies, they will only translate between EPSG:4326 and EPSG:900913.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `OpenLayers.Map.getLonLatFromViewPortPx()` method we can go from
    `OpenLayers.Pixel` to the `OpenLayers.LonLat` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Because the transform method modifies the current instance, we create a new
    one using the `clone()` method to avoid modifying the source variable.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the `trigger` method can construct a message string and place
    it within the text area.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's briefly describe the click control used in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to define the new control as a subclass of the `OpenLayers.Control`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The control will use an `OpenLayers.Handler`, so here we will define some options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initialize` method is responsible to initialize the control instance.
    First, we create a set of options as a combination (using `OpenLayers.Util.extend()`
    method) of the previously defined object and options passed by the user as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have initialized an `OpenLayers.Handler.Click` instance to execute the `trigger`
    listener function every time it detects that the user has pressed the mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as a good practice we set the `CLASS_NAME` attribute with a string
    identifying our new control class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Playing with the map's options* recipe in [Chapter 1](ch01.html "Chapter 1. Web
    Mapping Basics"), *Web Mapping Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating features programmatically* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Working with Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving remote data with OpenLayers.Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is the basis for a web mapping application. We can add raster or vector
    layers to the map, which will load images or vector information.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of vector layers, thanks to the `OpenLayers.Protocol` and `OpenLayers.Format`
    subclasses, we can configure the layer to load data from different sources and
    with different formats.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, there can be circumstances where we need to request data by ourselves,
    read the specific format, and add features. We are talking about making asynchronous
    JavaScript calls.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how we can use the helper class `OpenLayers.Request` to asynchronously
    request data from the remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to request a URL that returns random x and y values that
    we will process as point features on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenLayers is a framework for GIS web developers, so it is designed to be independent
    from other projects, such as jQuery and Dojo that offer facilities to request
    remote data and implement its own.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once created the HTML file with OpenLayers library dependencies, add a `div`
    element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the JavaScript section, create the map instance, add a base layer, and center
    the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a vector layer and add to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, make a request to the `points.php` utility code, which returns a set
    of random x and y values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, the `XMLHttpRequest` object allows us to communicate with the
    server side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about working with `XMLHttpRequest` can be found on [http://acuriousanimal.com/blog/2011/01/27/working-with-the-javascript-xmlhttprequest-object](http://acuriousanimal.com/blog/2011/01/27/working-with-the-javascript-xmlhttprequest-object)
    and [https://developer.mozilla.org/en/AJAX/Getting_Started](http://https://developer.mozilla.org/en/AJAX/Getting_Started).
  prefs: []
  type: TYPE_NORMAL
- en: Due to compatibility problems among browsers, OpenLayers uses a cross-browser
    W3C compliant version of the `XMLHttpRequest` object and wrapping it has implemented
    the `OpenLayers.Request` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`OpenLayers.Request` class implements the HTTP methods: `GET, POST, PUT, DELETE,
    HEAD`, and `OPTIONS`, and is used by other OpenLayers classes to get/send data
    from/to remote servers (such as `OpenLayers.Protocol.HTTP).`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An HTTP introduction can be found at: [https://developer.mozilla.org/en/HTTP](http://https://developer.mozilla.org/en/HTTP)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe we have used the `OpenLayers.Request.GET` method with the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url:` It is the URL we are going to request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params:` It is a set of options parameters we can send in the `GET` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`success:` It is a callback function to be executed if the URL is successfully
    requested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failure:` It is a callback function to be executed if any problem occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our code, we are requesting the `utils/points.php` passing a `num` parameter,
    this is the same as requesting the URL `utils/points.php?num=100:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If for some reason the request fails, the method `failure` is executed and will
    show an alert message. On the other hand if the request succeeds we read the returned
    response and add point features to the map.
  prefs: []
  type: TYPE_NORMAL
- en: The `points.php` script returns a random number of x and y values, depending
    on the `num` parameter, encoded as JSON array. The response of the call is nothing
    more than a text that must be interpreted and we can find it in the `responseText`
    of the response's property.
  prefs: []
  type: TYPE_NORMAL
- en: To convert the JSON string into a JavaScript object we can use the class `OpenLayers.Format.JSON:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for each object we read the x and y values and create a point feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The x and y values returned by the PHP scripts goes from -180 to180 for x and
    -80 to 80 for y. Because of this, we translate the coordinates from EPSG:4326
    to EPSG:900913, which is the map's base layer projection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`OpenLayers.Request` is a powerful class allowing working with almost any HTTP
    method. For example, in addition to the `GET` method we can also use the `POST`
    method to send data to servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are going to work extensively with AJAX in your application, be sure
    to understand the limitations of **Cross-Domain Requests (XDR)** and the **same
    origin policy** ([http://en.wikipedia.org/wiki/Same_origin_policy](http://en.wikipedia.org/wiki/Same_origin_policy)).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, take a close look at `OpenLayers.Request` class options. You can find
    options, such as `async` to specify if the request must be made synchronously
    or asynchronously, `user/password` to make requests against servers with basic
    authentication, or `headers` to set the HTTP headers of the request.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Reading features using Protocols directly* recipe in [Chapter 3](ch03.html
    "Chapter 3. Working with Vector Layers"), *Working with Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading and creating features from a WKT* recipe in [Chapter 3](ch03.html
    "Chapter 3. Working with Vector Layers"), *Working with Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenLayers has plenty of controls that address a broad range of needs. Unfortunately,
    the requirements we could have for building a new web application can imply the
    creation of a new one, or the extension of a previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom control](img/7843_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we are going to create a new control named **Cross**. The control
    will show a crosshair symbol, as shown in the previous screenshot, similar to
    the target selectors in the ancient war planes, which will show the location it
    is pointing to. In addition, the control will allow registering the click events
    that will return the current location too.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file and add the OpenLayers dependencies, then include the code
    of our new control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the two CSS classes required for the control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a `div` element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the JavaScript code, create the map instance and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the cross control, add it to the map, and activate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are going to describe step by step the source code of the new control
    we have created. First, create a new `crossControl.js` file and start applying
    the *best* practice of writing a description about the control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create the new `OpenLayers.Control.Cross` class as a subclass of `OpenLayers.Control:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the set of attributes and methods of the new control. The first step
    is to initialize an array with the set of events our control can emit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, there is a `size` property, that is used to know the image control size
    and required to compute the exact control location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last attribute is used to store a reference to the DOM element used as
    a label to show the current control target''s location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have defined all the required properties used in the class, we need
    to initialize the control. Again, it is a good practice to comment in the source
    code following the OpenLayers conventions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to implement the `draw` method, which is called when the control
    is ready to be displayed on the page and is responsible to set the required DOM
    elements to render the control. The first step involves computing the right position
    for the control, which is the middle of the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can call the `draw` method of the superclass to draw the control.
    This will initialize the `this.div` property (inherited from `OpenLayers.Control)`
    with the DOM element that will hold the control. By default a CSS class `olControlCross`
    is added to the `div` element, so we can style it easily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we can create a new `div` element for the label that will show
    the current target''s location. This is done by using the method `OpenLayers.Util.createDiv`.
    In addition, thanks to the `OpenLayers.Element.addClass` method, we set the CSS
    class `olControlCrossText` to the label so the user can style the label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute the current `OpenLayers.LonLat` position and set the label text. We
    omit the code for the `computeLonLat` function that can be found within the control
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the label element to the main control element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a final step, we register two listeners. First, a listener for the `this.div`
    element to detect when the mouse clicks the control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Second, a listener for the map''s `move` event, so we can update the control''s
    location label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, return a reference to the `this.div` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next is the code for two listeners. The `onMove` method updates the label''s
    text (target''s location) each time the map is moved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `onClick` function is executed when there is a mouse click on the control.
    Its responsibility is to trigger the `crossClick` event so that any outside listener
    can by notified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the code for the helper function that computes the `OpenLayers.LonLat`
    from the current control''s pixel position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last, but not the least, we have to set the property `CLASS_NAME` with a string
    identifying the control name. By convention, it is the whole namespace of the
    control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The program does not have much mystery, in addition to the base layer we have
    created a cross control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have initialized the cross control by registering a listener function on
    the `crossClick` event, which is triggered each time there is a mouse click on
    the cross image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note how we can create the new control class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'New classes or subclasses are easily created with `OpenLayers.Class`. It requires
    two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The **source** class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **object** with the class definition that will extend the source class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our code, we are extending the `OpenLayers.Control` class with the properties
    and functions defined in the second parameter defined in the object literal notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, any class must be initialized using the `initialize` method. The
    usual order of actions to be done is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Merge the array of `EVENT_TYPES` controls with those defined in the base `OpenLayers.Control`
    class. This means we are extending the base event types with the set defined in
    the new cross control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a default value for the instance properties if they are not defined in
    the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the superclass constructor. Once we have the subclass initialized, we
    need to initialize the superclass. This is a bottom-top initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Adding and removing controls* recipe in [Chapter 5](ch05.html "Chapter 5. Adding
    Controls"), *Adding Controls*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Listening for non OpenLayers events* recipe in [Chapter 4](ch04.html "Chapter 4. Working
    with Events"), *Working with Events*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding the WMS layer* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with vector layers, styling is a great feature which offers us
    a lot of possibilities: fill color and opacity, stroke color, labels and text
    colors, and so on. But, what if we need more?'
  prefs: []
  type: TYPE_NORMAL
- en: Every `OpenLayers.Layer.Vector` instance contains a renderer that is responsible
    to render the layer's features (such as points, paths, and polygons) on the map
    using the best technologies available in the browser. These can be the HTML5 Canvas
    element ([http://en.wikipedia.org/wiki/Canvas_element](http://en.wikipedia.org/wiki/Canvas_element))
    available in many modern browsers (such as Firefox or Chrome), SVG ([http://en.wikipedia.org/wiki/Scalable_Vector_Graphics](http://en.wikipedia.org/wiki/Scalable_Vector_Graphics)),
    or VML ([http://en.wikipedia.org/wiki/Vector_Markup_Language](http://en.wikipedia.org/wiki/Vector_Markup_Language)).
  prefs: []
  type: TYPE_NORMAL
- en: When `OpenLayers.Layer.Vector` is initialized, OpenLayers looks for the best
    available rendering engine and creates an instance of `OpenLayers.Renderer` that
    will render the features on the map.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this recipe is to show how we can create a new renderer to improve
    the visualization of the features.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom renderer](img/7843_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows some styled point geometry features and was rendered
    using the default OpenLayers renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the same features rendered with our new renderer
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom renderer](img/7843_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to extend `OpenLayers.Renderer.Canvas`, to improve visualizations.
    This renderer works using the HTML5 Canvas element. This means the new renderer
    only will work on HTML5 compliant browsers. You can check if the canvas element
    is supported by your browser at: [http://html5test.com](http://html5test.com)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once an HTML file is created with OpenLayers dependencies, the first step is
    to include the file with the new renderer class'' implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, as usual you can add the `div` element that will hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the JavaScript section, add the following code to initialize the map and
    add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Center the map''s viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `StyleMap` instance with a **unique value rule** based on the `POP_RANK`
    attribute of the features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the vector layer and add it to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go to see the `OpenLayers.Renderer.Gradient` implementation that beautifies
    our point''s features that are rendered with a nice gradient style. Start creating
    a JavaScript file named `gradientRenderer.js`, which we have included previously
    in the main program. Following good practices, we start the commenting in the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create an `OpenLayers.Renderer.Canvas` subclass named `OpenLayers.Renderer.Gradient:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first method to implement in a new OpenLayers class must be the `initialize()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we implement the `drawPoint()` method, inherited from the `OpenLayers.Renderer.Canvas`
    class, which is responsible to render the point geometry features of the layer.
    Now, the method receives three parameters: the geometry object, the style to apply,
    and the feature identifier attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the `geometry` parameter, compute the exact pixel position of the point.
    This can be done with the `getLocalXY()` method inherited from the `OpenLayers.Renderer.Canvas`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the `fillColor` and `fillOpacity` properties create a string for the
    color to be applied for the gradient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then create a canvas gradient, centered in the feature''s location and with
    the radius value specified in the feature''s style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the necessary steps so that the gradient goes from white to the previously
    created RGB color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, identify the new class by setting the `CLASS_NAME` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The important point of this recipe resides in one of the properties we have
    specified for the vector layer, the `renderers.`
  prefs: []
  type: TYPE_NORMAL
- en: 'The `renderers` property allows us to specify the set of `OpenLayers.Renderer`
    that the layer can make use of. Usually this property is never used and by default,
    its value is: `renderers: [''SVG'', ''VML'', ''Canvas'']`. This means the supported
    renderer instances the layer can use are `OpenLayers.Renderer.SVG, OpenLayers.Renderer.VML`,
    and `OpenLayers.Renderer.Canvas`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we have created the class `OpenLayers.Renderer.Gradient`,
    which we will describe later. The setting `renderers: ["Gradient"]` means we only
    want to allow the layer to work with an `OpenLayers.Renderer.Gradient` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s describe in more detail how to initialize the vector layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the renderers, we have used an `OpenLayers.Protocol.HTTP` instance
    with an `OpenLayers.Format.GeoJSON` instance, to load a GeoJSON file with some
    cities around the world. The features within the file have, among others, the
    `POP_RANK` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `OpenLayers.Strategy.Fixed` strategy instance, the layer loads
    the data source, through the previous protocol, only once. We have no need to
    load the file each time the map is zoomed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, but not the least, we have set the `styleMap` property to a previously
    created `OpenLayers.StyleMap` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This style map is defined making use of the unique value rule feature based
    on the `POP_RANK` attribute. This property takes values from `1` to `7`, so we
    define a symbolizer hash style for each possible value, playing with the radius
    and fill color properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: For the main program, there is nothing more to comment, except for the way we
    have centered the map's viewport.
  prefs: []
  type: TYPE_NORMAL
- en: Because the base layer is `OpenStreetMap`, which by default uses an EPSG:900913
    projection, and we have specified the center in the EPSG:4326 projection, we need
    to transform the coordinates to the appropriate map's projection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, this `initialize` method starts calling the `initialize` method of
    its parent class and then sets the concrete properties of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, our class has no specific property to initialize, so it is not
    strictly necessary to implement this method, but as an example, (and as a good
    practice) we have written the call to the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The process followed within the `OpenLayers.Renderer.Canvas` class to render
    the features of a layer is a bit complex, but can be summarized as:'
  prefs: []
  type: TYPE_NORMAL
- en: For each feature the class checks its geometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the geometry type the class invokes a different method specially
    designed to render points, lines, or polygons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because our renderer is implemented to beautify points we only have rewritten
    the `drawPoint` method, which is responsible to render point geometries.
  prefs: []
  type: TYPE_NORMAL
- en: The renderer we have defined here uses the HTML5 canvas element, because of
    this, the main part of the recipe is related to this technology.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lots of information about the HTML5 canvas element can be found on the Internet.
    We want to point to this tutorial from the Mozilla project: [https://developer.mozilla.org/en/Canvas_tutorial](http://https://developer.mozilla.org/en/Canvas_tutorial).'
  prefs: []
  type: TYPE_NORMAL
- en: A great exercise would be to create an SVG version of this renderer. This way,
    the possibility to render gradient points would be available in more browsers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Creating a custom control* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Styling features using symbolizers* recipe in [Chapter 7](ch07.html "Chapter 7. Styling
    Features"), *Styling Features*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Defining custom rules to style features* recipe in [Chapter 7](ch07.html
    "Chapter 7. Styling Features"), *Styling Features*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting features intersecting with a line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common action when working with features within a vector layer is its selection
    and, of course, OpenLayers has some feature selection controls.
  prefs: []
  type: TYPE_NORMAL
- en: The `OpenLayers.Control.SelectFeature` control is specially useful as a selection
    control because the selection is made on the client side, that is, the selection
    is made through the features loaded in the browser. There is no request to a WFS
    server.
  prefs: []
  type: TYPE_NORMAL
- en: The `OpenLayers.Control.SelectFeature` control can work in different ways. We
    can select a feature just by clicking on it or we can draw a box to select all
    the contained features.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, it does not allow the possibility to select features that intersect
    with a path.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to see how we can extend the `OpenLayers.Control.SelectFeature`
    control to allow select features for drawing a path.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML5 file and add the OpenLayers library dependencies. Now, include
    the code for the new `OpenLayers.Control.SelectFeature` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `body` section, add a `div` element to hold the map instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, place the JavaScript code within a `script` element at the document''s
    `head` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the map instance, add a base layer, and center the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a vector layer that loads a GML file with the European countries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create an instance of our new `OpenLayers.Control.SelectFeaturePath`
    control, add it to the map and activate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are going to see the new `SelectFeaturePath` control''s implementation.
    Create a `selectFeaturePath.js` file and add some control description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `initialize` method responsible for initializing the control.
    Note how we call the super class''s `initialize` method also, to initialize the
    parent class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `selectPath` method. This method selects those features which
    intersect with the created line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a unique identifier for the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main program does not have much mystery. We have created a map, added a
    vector layer, and then added our custom `SelectFeaturePath` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we have transformed the coordinates to center the map''s viewport.
    This is because we are specifying the location in EPSG:4326 and the map is using
    a base layer with EPSG:900913:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Because our control is an extension of the `OpenLayers.Control.SelectFeature`
    control, it is important to describe it briefly before going into the code's description.
  prefs: []
  type: TYPE_NORMAL
- en: As we commented at the beginning of the recipe, this control works on the client
    side, that is, no request is made to the data source. The control iterates over
    all features in a layer (or layers) and selects those features that match the
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: By default, without specifying any options on its instantiation, the control
    allows us to select features by clicking on it. We can also set properties, such
    as the `hover` property, which allows us to highlight the feature pointed by the
    mouse or, the important one here, the `box` property, which allows the feature
    selection to draw a box.
  prefs: []
  type: TYPE_NORMAL
- en: This is done because the control internally uses an instance of an `OpenLayers.Handler.Box`
    handler, which is responsible to draw a box and returns a bounding box's coordinates
    so the control can check which features are inside the box.
  prefs: []
  type: TYPE_NORMAL
- en: The idea to extend our control and allow selecting features just by drawing
    a path is simple, instead of using an `OpenLayers.Handler.Box` handler we are
    going to use an `OpenLayers.Handler.Path` handler.
  prefs: []
  type: TYPE_NORMAL
- en: All right, we have background knowledge about what we need. Let's go to see
    how we have done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created the new `OpenLayers.Control.SelectFeaturePath` class using
    the `OpenLayers.Class` method. This class allows merging the properties and methods
    of two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the previous line, we are merging the properties and methods of the `OpenLayers.Control.SelectFeature`
    class with those defined in the second argument, which is an object in the literal
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `initialize()` method, it is important we set the `box` and `handlers.box`
    properties inherited from the superclass. Setting the `handlers.box` to a new
    instance of `OpenLayers.Handler.Path` makes the control use a path handler instead
    of a box handler to select the features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `box` property set to `true` indicates we want to select the features using
    a handler instead of simply clicking on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Using a property called `handlers.box` to specify a path handler is not the
    clearest way to do it, but in contrast, is the easiest one. The `OpenLayers.Control.SelectFeature`
    class uses this property to get the appropriate handler to make the selection.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, when the path handler is initialized, we have set a listener
    function for the `done` event, which is triggered when the path handler finishes
    drawing the line.
  prefs: []
  type: TYPE_NORMAL
- en: The `selectPath` method, is responsible to find out which features of the layer
    intersect the path and change its renderer style to highlight them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note, the listener function receives an `OpenLayers.Geometry.LineString` instance
    with the created path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the control can work with more than one layer, we need to iterate over
    all the layers and all the features on each layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking if the feature is visible we can check whether the feature intersects
    with the path, using the `intersects` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `OpenLayers.Util.indexOf(array, object)` function returns the index at which
    an object is found within an array.
  prefs: []
  type: TYPE_NORMAL
- en: To change the rendering style of the feature, we simply call the method `select`
    inherited from the `OpenLayers.Control.SelectFeature` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A vector layer can render the features using different styles, called render
    intents: default, select, or temporary are the default render intents we can use.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Creating a custom renderer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Playing with StyleMap and the render intents* recipe in [Chapter 7](ch07.html
    "Chapter 7. Styling Features"), *Styling Features*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an animation with image layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with geographic information, its geometrical representation within
    the space is not the only important thing. Day by day time is becoming a new and
    important dimension to take into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, visualizations must show how data changes over time: city population,
    country frontiers, roads built, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many solutions to animate the data evolution through time but, as
    always, we work with web technologies, there are two groups: the solutions based
    on the server side and those based on the client side.'
  prefs: []
  type: TYPE_NORMAL
- en: For server-side solutions, we can find the `TIME` parameter in the WMS and WFS
    standards. It allows us to request for raster or vector data in a specific time
    or within a range.
  prefs: []
  type: TYPE_NORMAL
- en: Server solutions means the client must request the server every time we want
    to show the data for a different interval.
  prefs: []
  type: TYPE_NORMAL
- en: For the client side, a simple solution is to have in the memory all the data,
    and only show those that correspond to the interval we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to show how easily we can create an animation on
    the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to load some images from **NEXTRAD** ([http://en.wikipedia.org/wiki/NEXRAD](http://en.wikipedia.org/wiki/NEXRAD)),
    showing the rain evolution at different time instants (as shown in the following
    screenshot), and we will create an animation by simply showing or hiding images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making an animation with image layers](img/7843_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new HTML file and add the OpenLayers dependencies. In the `body` section
    start adding the elements necessary for the play button and the slider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to OpenLayers, we are using the Dojo Toolkit framework ([http://dojotoolkit.org](http://dojotoolkit.org))
    to create more attractive user interfaces. Learning Dojo is out of the scope of
    this book and also, it is not necessary to know it to understand this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add the `div` element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the header section add the next JavaScript code. Start initializing
    the map instance, add a base layer, and center the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are going to create some raster image layers, add them to the map,
    and also store them on an array to control their visibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code controls the changes in the slider widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the following code controls the automatic animation when the **Play**
    button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this recipe, the idea is to animate some weather
    radar on the client side. For this reason, we load a set of images from the server,
    creating a layer for each one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OpenLayers.Layer.Image` class is used here to hold each image as a single
    layer. Its constructor requires five parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name:` The name of the layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url:` The URL where the image must be taken'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extent:` The bounds of the image within the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size:` The size in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options:` A set of options to be passed to the layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `extent` and the `size` arguments are used to compute the resolution of
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, all the image layers will have the same `extent` and `size:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, within the loop to create all the image layers, we are setting dynamically
    the value of the `img_url` variable and passing some options to the `OpenLayers.Layer.Image`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting the `isBaseLayer` property to `false` we are specifying that our
    layer is not a base layer, it will act as an overlay. In addition, we set the
    `visibility` property to `false` to initially hide the layer. Later, we will set
    the first image layer as the visible one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `alwaysInRange` property is inherited from the superclass `OpenLayers.Layer`
    and specially useful in this case. We want our image layer to be visible at any
    zoom level. We do not want OpenLayers to compute the right resolution; given the
    image layer extent and size, the layer must be shown. So, setting `alwaysInRange`
    to `true` makes the layer always visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to see how to automatically automate the animation. The
    `animateAction` is executed when the play button is pressed. It is a toggle button,
    so depending on its state, the boolean `checked` parameter will be true if checked
    or false if not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'If the play button is checked, then we create an interval to execute the given
    anonymous function every 50 milliseconds which, in fact, increases the value of
    the slider and calls the `animation` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If the button is unchecked, then we remove the interval reference to stop the
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Intervals** and **timeouts** are used in JavaScript to create animations
    and delays.'
  prefs: []
  type: TYPE_NORMAL
- en: A good explanation of intervals in JavaScript can be found at [http://www.w3schools.com/jsref/met_win_setinterval.asp](http://www.w3schools.com/jsref/met_win_setinterval.asp).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's take a look at the `animation` function, which is responsible
    to change the layer visibilities and create the animation effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the layers are added to the map and also stored in the `imgArray`. The
    global `currentIndex` variable is used to hold the current visible layer. The
    animation function does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Hides the current visible layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the numeric `value`, that varies from 0 to 100, computes the layer array
    index, that goes from 0 to 31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shows the new current layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: That's all! Once the set of layers is loaded in the client side, using any modern
    browser, the performance of the animation is good enough.
  prefs: []
  type: TYPE_NORMAL
- en: This is only a sample, so there are tons of things to improve. For example,
    think on how to implement a situation where we have a remote server with hundreds
    of images to load sequentially. In this case we cannot load all images at once
    because that can cause an out-of-memory problem in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Supposing we have thousands of images to animate, we could implement some buffer
    strategy. Given a buffer of ten images, we can load the first ten images from
    the server, then animate them and when the animation arrives to the last loaded
    image, load the next ten images from the server.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, these situations are out of the scope of this book and not only
    related to OpenLayers but with software architecture and design.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Creating an Image layer* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Changing layer opacity* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
