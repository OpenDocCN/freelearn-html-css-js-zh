<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Behavioral Design Patterns: Continuous"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Behavioral Design Patterns: Continuous</h1></div></div></div><p>In the previous chapter, we've already talked about some of the behavioral design patterns. We'll be continuing with more patterns in this category in this chapter, including: Strategy Pattern, State Pattern, Template Method Pattern, Observer Pattern, and Visitor Pattern.</p><p>Many of these patterns share the same idea: unify the shape and vary the details. Here is a quick overview:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Strategy Pattern</strong></span> and <span class="strong"><strong>Template Pattern</strong></span>: Defines the same outline of algorithms</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>State Pattern</strong></span>: Provides different behavior for objects in different states with the same interface</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Observer Pattern</strong></span>: Provides a unified process of handling subject changes and notifying observers</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Visitor Pattern</strong></span>: Does similar jobs as Strategy Pattern sometimes, but avoids an over complex interface that might be required for Strategy Pattern to handle objects in many different types</li></ul></div><p>Patterns that will be discussed in this chapter could be applied in different scopes just as many patterns in other categories.</p><div class="section" title="Strategy Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Strategy Pattern</h1></div></div></div><p>It's common that a program has similar outlines for processing different targets with different detailed algorithms. Strategy Pattern encapsulates those algorithms and makes them interchangeable within the shared outline.</p><p>Consider conflicting merging processes of data synchronization, which we talked about in <a class="link" href="ch02.html" title="Chapter 2. The Challenge of Increasing Complexity">Chapter 2</a>, <span class="emphasis"><em>The Challenge of Increasing Complexity</em></span>. Before refactoring, the code was like this:</p><pre class="programlisting">if (type === 'value') { &#13;
  // ... &#13;
} else if (type === 'increment') { &#13;
  // ... &#13;
} else if (type === 'set') { &#13;
  // ... &#13;
} &#13;
</pre><p>But later we found out that we could actually extract the same outlines from different phases of the synchronization process, and encapsulate them as different strategies. After refactoring, the outline of the code became as follows:</p><pre class="programlisting">let strategy = strategies[type]; &#13;
strategy.operation(); &#13;
</pre><p>We get a lot of ways to compose and organize those strategy objects or classes sometimes in JavaScript. A possible structure for Strategy Pattern could be:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_001.jpg" alt="Strategy Pattern"/></div><p>
</p><p>In this structure, the client is responsible for fetching specific strategies from the table and applying operations of the current phase.</p><p>Another structure is using contextual objects and letting them control their own strategies:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_002.jpg" alt="Strategy Pattern"/></div><p>
</p><p>Thus the client needs only to link a specific context with the corresponding strategy.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>Participants</h2></div></div></div><p>We've mentioned two possible structures for Strategy Pattern, so let's discuss the participants separately. For the first structure, the participants include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Strategy</strong></span><p>Defines the interface of strategy objects or classes.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete strategy</strong></span>: <code class="literal">ConcreteStrategyA</code> and <code class="literal">ConcreteStrategyB</code><p>Implements concrete strategy operations defined by the <code class="literal">Strategy</code> interface.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Strategy manager</strong></span>: <code class="literal">Strategies</code><p>Defines a data structure to manage strategy objects. In the example, it's just a simple hash table that uses data type names as keys and strategy objects as values. It could be more complex on demand: for example, with matching patterns or conditions.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Target</strong></span><p>The target to apply algorithms defined in strategy objects.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span><p>Makes targets and strategies cooperate.</p></li></ul></div><p>The participants of the second structure include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Strategy</strong></span> and <span class="strong"><strong>concrete strategy</strong></span><p>The same as in the preceding section.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Context</strong></span><p>Defines a reference to the strategy object applied. Provides related methods or property getters for clients to operate.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span><p>Manages context objects.</p></li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Pattern scope</h2></div></div></div><p>Strategy Pattern is usually applied to scopes with small or medium sizes. It provides a way to encapsulate algorithms and makes those algorithms easier to manage under the same outline. Strategy Pattern can also be the core of an entire solution sometimes, and a good example is the synchronization implementation we've been playing with. In this case, Strategy Pattern builds the bridge of plugins and makes the system extendable. But most of the time, the fundamental work done by Strategy Pattern is decoupling concrete strategies, contexts, or targets.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Implementation</h2></div></div></div><p>The implementation starts with defining the interfaces of objects we'll be playing with. We have two target types in string literal type <code class="literal">'a'</code> and <code class="literal">'b'</code>. Targets of type <code class="literal">'a'</code>  have a <code class="literal">result</code> property with type <code class="literal">string</code>, while targets of type <code class="literal">'b'</code> have a <code class="literal">value</code> property with type <code class="literal">number</code>.</p><p>The interfaces we'll have look, are like:</p><pre class="programlisting">type TargetType = 'a' | 'b'; &#13;
 &#13;
interface Target { &#13;
  type: TargetType; &#13;
} &#13;
 &#13;
interface TargetA extends Target { &#13;
  type: 'a'; &#13;
  result: string; &#13;
} &#13;
 &#13;
interface TargetB extends Target { &#13;
  type: 'b'; &#13;
  value: number; &#13;
} &#13;
 &#13;
interface Strategy&lt;TTarget extends Target&gt; { &#13;
  operationX(target: TTarget): void; &#13;
  operationY(target: TTarget): void; &#13;
} &#13;
</pre><p>Now we'll define the concrete strategy objects without a constructor:</p><pre class="programlisting">let strategyA: Strategy&lt;TargetA&gt; = { &#13;
  operationX(target) { &#13;
    target.result = target.result + target.result; &#13;
  }, &#13;
  operationY(target) { &#13;
    target.result = target &#13;
      .result &#13;
      .substr(Math.floor(target.result.length / 2)); &#13;
  } &#13;
}; &#13;
 &#13;
let strategyB: Strategy&lt;TargetB&gt; = { &#13;
  operationX(target) { &#13;
    target.value = target.value * 2; &#13;
  }, &#13;
  operationY(target) { &#13;
    target.value = Math.floor(target.value / 2); &#13;
  } &#13;
}; &#13;
</pre><p>To make it easier for a client to fetch those strategies, we'll put them into a hash table:</p><pre class="programlisting">let strategies: { &#13;
  [type: string]: Strategy&lt;Target&gt; &#13;
} = { &#13;
  a: strategyA, &#13;
  b: strategyB &#13;
}; &#13;
</pre><p>And now we can make them work with targets in different types:</p><pre class="programlisting">let targets: Target[] = [ &#13;
  { type: 'a' }, &#13;
  { type: 'a' }, &#13;
  { type: 'b' } &#13;
]; &#13;
 &#13;
for (let target of targets) { &#13;
  let strategy = strategies[target.type]; &#13;
 &#13;
  strategy.operationX(target); &#13;
  strategy.operationY(target); &#13;
} &#13;
</pre></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec95"/>Consequences</h2></div></div></div><p>Strategy Pattern makes the foreseeable addition of algorithms for contexts or targets under new categories easier. It also makes the outline of a process even cleaner by hiding trivial branches of behaviors selection.</p><p>However, the abstraction of algorithms defined by the <code class="literal">Strategy</code> interface may keep growing while we are trying to add more strategies and satisfy their requirements of parameters. This could be a problem for a Strategy Pattern with clients that are managing targets and strategies. But for the other structures which the references of strategy objects are stored by contexts themselves, we can manage to trade-off the interchangeability. This would result in Visitor Pattern, which we are going to talk about later in this chapter.</p><p>And as we've mentioned before, Strategy Pattern can also provide notable extensibility if an extendable strategy manager is available or the client of contexts is designed to.</p></div></div></div>
<div class="section" title="State Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>State Pattern</h1></div></div></div><p>It's possible for some objects to behave completely differently when they are in different states. Let's think about an easy example first. Consider rendering and interacting with a custom button in two states: enabled and disabled. When the button is enabled, it lights up and changes its style to active on a mouse hover, and of course, it handles clicks; when disabled, it dims and no longer cares about mouse events.</p><p>We may think of an abstraction with two operations: <code class="literal">render</code> (with a parameter that indicates whether the mouse is hovering) and <code class="literal">click</code>; along with two states: <span class="emphasis"><em>enabled</em></span> and <span class="emphasis"><em>disabled</em></span>. We can even divide deeper and have state <span class="emphasis"><em>active</em></span>, but that won't be necessary in our case.</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_003.jpg" alt="State Pattern"/></div><p>
</p><p>And now we can have <code class="literal">StateEnabled</code> with both <code class="literal">render</code> and <code class="literal">click</code> methods implemented, while having <code class="literal">StateDisabled</code> with only <code class="literal">render</code> method implemented because it does not care about the <code class="literal">hover</code> parameter. In this example, we are expecting every method of the states being callable. So we can have the abstract class <code class="literal">State</code> with empty <code class="literal">render</code> and <code class="literal">click</code> methods.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec96"/>Participants</h2></div></div></div><p>The participants of State Pattern include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>State</strong></span><p>Defines the interface of state objects that are being switched to internally.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete state</strong></span>: <code class="literal">StateEnabled</code> and <code class="literal">StateDisabled</code><p>Implements the <code class="literal">State</code> interface with behavior corresponding to a specific state of the context. May have an optional reference back to its context.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Context</strong></span><p>Manages references to different states, and makes operations defined on the active one.</p></li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec97"/>Pattern scope</h2></div></div></div><p>State Pattern usually applies to the code of scopes with the size of a feature. It does not specify whom to transfer the state of context: it could be either the context itself, the state methods, or code that controls context.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec98"/>Implementation</h2></div></div></div><p>Start with the <code class="literal">State</code> interface (it could also be an abstract class if there are operations or logic to share):</p><pre class="programlisting">interface State { &#13;
  render(hover: boolean): void; &#13;
  click(): void; &#13;
} &#13;
</pre><p>With the <code class="literal">State</code> interface defined, we can move to <code class="literal">Context</code> and sketch its outline:</p><pre class="programlisting">class Context { &#13;
  $element: JQuery; &#13;
 &#13;
  state: State; &#13;
 &#13;
  private render(hover: boolean): void { &#13;
    this.state.render(hover); &#13;
  } &#13;
 &#13;
  private click(): void { &#13;
    this.state.click(); &#13;
  } &#13;
   &#13;
  onclick(): void { &#13;
    console.log('I am clicked.'); &#13;
  } &#13;
} &#13;
</pre><p>Now we are going to have the two states, <code class="literal">StateEnabled</code> and <code class="literal">StateDisabled</code> implemented. First, let's address <code class="literal">StateEnabled</code>, it cares about <code class="literal">hover</code> status and handles <code class="literal">click</code> event:</p><pre class="programlisting">class StateEnabled implements State { &#13;
  constructor( &#13;
    public context: Context &#13;
  ) { } &#13;
 &#13;
  render(hover: boolean): void { &#13;
    this &#13;
      .context &#13;
      .$element &#13;
      .removeClass('disabled') &#13;
      .toggleClass('hover', hover); &#13;
  } &#13;
 &#13;
  click(): void { &#13;
    this.context.onclick(); &#13;
  } &#13;
} &#13;
</pre><p>Next, for <code class="literal">StateDisabled</code> it just ignores <code class="literal">hover</code> parameter and does nothing when <code class="literal">click</code> event emits:</p><pre class="programlisting">class StateDisabled implements State { &#13;
  constructor( &#13;
    public context: Context &#13;
  ) { } &#13;
 &#13;
  render(): void { &#13;
    this &#13;
      .context &#13;
      .$element &#13;
      .addClass('disabled') &#13;
      .removeClass('hover'); &#13;
  } &#13;
 &#13;
  click(): void { &#13;
    // Do nothing. &#13;
  } &#13;
} &#13;
</pre><p>Now we have classes of states <span class="emphasis"><em>enabled</em></span> and <span class="emphasis"><em>disabled</em></span> ready. As the instances of those classes are associated with the context, we need to initialize every state when a new <code class="literal">Context</code> is initiated:</p><pre class="programlisting">class Context { &#13;
  ... &#13;
 &#13;
  private stateEnabled = new StateEnabled(this); &#13;
  private stateDisabled = new StateDisabled(this); &#13;
 &#13;
  state: State = this.stateEnabled; &#13;
   &#13;
  ... &#13;
} &#13;
</pre><p>It is possible to use flyweights by passing context in when invoking every operation on the active state as well.</p><p>Now let's finish the <code class="literal">Context</code> by listening to and forwarding proper events:</p><pre class="programlisting">constructor() { &#13;
  this &#13;
    .$element &#13;
    .hover( &#13;
      () =&gt; this.render(true), &#13;
      () =&gt; this.render(false) &#13;
    ) &#13;
    .click(() =&gt; this.click()); &#13;
 &#13;
  this.render(false); &#13;
} &#13;
</pre></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec99"/>Consequences</h2></div></div></div><p>State Pattern reduces conditional branches in potentially multiple methods of context objects. As a trade-off, extra state objects are introduced, though it usually won't be a big problem.</p><p>The context object in State Pattern usually delegates operations and forwards them to the current state object. Thus operations defined by a concrete state may have access to the context itself. This makes reusing state objects possible with flyweights.</p></div></div>
<div class="section" title="Template Method Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Template Method Pattern</h1></div></div></div><p>When we are talking about subclassing or inheriting, the building is usually built from the bottom up. Subclasses inherit the basis and then provide more. However, it could be useful to reverse the structure sometimes as well.</p><p>Consider Strategy Pattern which defines the outline of a process and has interchangeable algorithms as strategies. If we apply this structure under the hierarchy of classes, we will have Template Method Pattern.</p><p>A template method is an abstract method (optionally with default implementation) and acts as a placeholder under the outline of a larger process. Subclasses override or implement related methods to modify or complete the behaviors. Imaging the skeleton of a <code class="literal">TextReader</code>, we are expecting its subclasses to handle text files from different storage media, detect different encodings and read all the text. We may consider a structure like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_004.jpg" alt="Template Method Pattern"/></div><p>
</p><p>The <code class="literal">TextReader</code> in this example has a method <code class="literal">readAllText</code> that reads all text from a resource by two steps: reading all bytes from the resource (<code class="literal">readAllBytes</code>), and then decoding those bytes with certain encoding (<code class="literal">decodeBytes</code>).</p><p>The structure also suggests the possibility of sharing implementations among concrete classes that implement template methods. We may create an abstract class <code class="literal">AsciiTextReader</code> that extends <code class="literal">TextReader</code> and implements method <code class="literal">decodeBytes</code>. And build concrete classes <code class="literal">FileAsciiTextReader</code> and <code class="literal">HttpAsciiTextReader</code> that extend <code class="literal">AsciiTextReader</code> and implement method <code class="literal">readAllBytes</code> to handle resources on different storage media.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec100"/>Participants</h2></div></div></div><p>The participants of Template Method Pattern include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Abstract class</strong></span>: <code class="literal">TextReader</code><p>Defines the signatures of template methods, as well as the outline of algorithms that weave everything together.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete classes</strong></span>: <code class="literal">AsciiTextReader</code>, <code class="literal">FileAsciiTextReader</code> and <code class="literal">HttpAsciiTextReader</code><p>Implements template methods defined in abstract classes. Typical concrete classes are <code class="literal">FileAsciiTextReader</code> and <code class="literal">HttpAsciiTextReader</code> in this example. However, compared to being abstract, <span class="emphasis"><em>defining the outline of algorithms</em></span> weighs more in the categorization.</p></li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec101"/>Pattern scope</h2></div></div></div><p>Template Method Pattern is usually applied in a relatively small scope. It provides an extendable way to implement features and avoid redundancy from the upper structure of a series of algorithms.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec102"/>Implementation</h2></div></div></div><p>There are two levels of the inheriting hierarchy: the <code class="literal">AsciiTextReader</code> will subclass <code class="literal">TextReader</code> as another abstract class. It implements method <code class="literal">decodeBytes</code> but leaves <code class="literal">readAllBytes</code> to its subclasses. Starting with the <code class="literal">TextReader</code>:</p><pre class="programlisting">abstract class TextReader { &#13;
  async readAllText(): Promise&lt;string&gt; { &#13;
    let bytes = await this.readAllBytes(); &#13;
    let text = this.decodeBytes(bytes); &#13;
 &#13;
    return text; &#13;
  } &#13;
 &#13;
  abstract async readAllBytes(): Promise&lt;Buffer&gt;; &#13;
 &#13;
  abstract decodeBytes(bytes: Buffer): string; &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip43"/>Tip</h3><p>We are using Promises with <code class="literal">async</code> and <code class="literal">await</code> which are coming to ECMAScript next. Please refer to the following links for more information:<a class="ulink" href="https://github.com/Microsoft/TypeScript/issues/1664">https://github.com/Microsoft/TypeScript/issues/1664</a>
<a class="ulink" href="https://tc39.github.io/ecmascript-asyncawait/">https://tc39.github.io/ecmascript-asyncawait/</a>
</p></div></div><p>And now let's subclass <code class="literal">TextReader</code> as <code class="literal">AsciiTextReader</code> which still remains abstract:</p><pre class="programlisting">abstract class AsciiTextReader extends TextReader { &#13;
  decodeBytes(bytes: Buffer): string { &#13;
    return bytes.toString('ascii'); &#13;
  } &#13;
} &#13;
</pre><p>For <code class="literal">FileAsciiTextReader</code>, we'll need to import filesystem (<code class="literal">fs</code>) module of Node.js to perform file reading:</p><pre class="programlisting">import * as FS from 'fs'; &#13;
 &#13;
class FileAsciiTextReader extends AsciiTextReader { &#13;
  constructor( &#13;
    public path: string &#13;
  ) { &#13;
    super(); &#13;
  } &#13;
 &#13;
  async readAllBytes(): Promise&lt;Buffer&gt; { &#13;
    return new Promise&lt;Buffer&gt;((resolve, reject) =&gt; { &#13;
      FS.readFile(this.path, (error, bytes) =&gt; { &#13;
        if (error) { &#13;
          reject(error); &#13;
        } else { &#13;
          resolve(bytes); &#13;
        } &#13;
      }); &#13;
    }); &#13;
  } &#13;
} &#13;
</pre><p>For <code class="literal">HttpAsciiTextReader</code>, we are going to use a popular package <code class="literal">request</code> to send HTTP requests:</p><pre class="programlisting">import * as request from 'request'; &#13;
 &#13;
class HttpAsciiTextReader extends AsciiTextReader { &#13;
  constructor( &#13;
    public url: string &#13;
  ) { &#13;
    super(); &#13;
  } &#13;
 &#13;
  async readAllBytes(): Promise&lt;Buffer&gt; { &#13;
    return new Promise&lt;Buffer&gt;((resolve, reject) =&gt; { &#13;
      request(this.url, { &#13;
        encoding: null &#13;
      }, (error, bytes, body) =&gt; { &#13;
        if (error) { &#13;
          reject(error); &#13;
        } else { &#13;
          resolve(body); &#13;
        } &#13;
      }); &#13;
    }); &#13;
  } &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip44"/>Tip</h3><p>Both concrete reader implementations pass resolver functions to the Promise constructor for converting asynchronous Node.js style callbacks to Promises. For more information, read more about the Promise constructor : <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a>.</p></div></div></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec103"/>Consequences</h2></div></div></div><p>Compared to Strategy Pattern, Template Method Pattern provides convenience for building objects with the same outline of algorithms outside of the existing system. This makes Template Method Pattern a useful way to build tooling classes instead of fixed processes built-in.</p><p>But Template Method Pattern has less runtime flexibility as it does not have a <span class="emphasis"><em>manager</em></span>. It also relies on the client who's using those objects to do the work. And as the implementation of Template Method Pattern relies on subclassing, it could easily result in hierarchies that have a similar code on different branches. Though this could be optimized by using techniques like <span class="emphasis"><em>mixin</em></span>.</p></div></div>
<div class="section" title="Observer Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Observer Pattern</h1></div></div></div><p>Observer Pattern is an important Pattern backed by an important idea in software engineering. And it is usually a key part of MVC architecture and its variants as well.</p><p>If you have ever written an application with a rich user interface without a framework like Angular or a solution with React, you might probably have struggled with changing class names and other properties of UI elements. More specifically, the code that controls those properties of the same group of elements lies every branch related to the elements in related event listeners, just to keep the elements being correctly updated.</p><p>Consider a "Do" button of which the <code class="literal">disabled</code> property should be determined by the status of a <code class="literal">WebSocket</code> connection to a server and whether the currently active item is done. Every time the status of either the connection or the active item gets updated, we'll need to update the button correspondingly. The most "handy" way could be two somewhat identical groups of code being put in two event listeners. But in this way, the amount of similar code would just keep growing as more relevant objects get involved.</p><p>The problem in this "Do" button example is that, the behavior of code that's controlling the button is driven by primitive events. The heavy load of managing the connections and behaviors among different events is directly taken by the developer who's writing that code. And unfortunately, the complexity in this case, grows exponentially, which means it could easily exceed our brain capacity. Writing code this way might result in more bugs and make maintaining much likely to introduce new bugs.</p><p>But the beautiful thing is, we can find the factors that multiply and output the desired result, and the reference for dividing those factors are groups of related states. Still speaking of the "Do" button example, what the button cares about is: connection status and the active item status (assuming they are booleans <code class="literal">connected</code> and <code class="literal">loaded</code>). We can have the code written as two parts: one part that changes those states, and another part that updates the button:</p><pre class="programlisting">let button = document.getElementById('do-button'); &#13;
 &#13;
let connected = false; &#13;
let loaded = false; &#13;
 &#13;
function updateButton() { &#13;
  let disabled = !connected &amp;&amp; !loaded; &#13;
  button.disabled = disabled; &#13;
} &#13;
 &#13;
connection.on('statuschange', event =&gt; { &#13;
  connected = event.connected; &#13;
  updateButton(); &#13;
}); &#13;
 &#13;
activeItem.on('statuschange', event =&gt; { &#13;
  loaded = event.loaded; &#13;
  updateButton(); &#13;
}); &#13;
</pre><p>The preceding sample code already has the embryo of Observer Pattern: the subjects (states <code class="literal">connected</code> and <code class="literal">loaded</code>) and the observer (<code class="literal">updateButton</code> function), though we still need to call <code class="literal">updateButton</code> manually every time any related state changes. An improved structure could look like the following figure:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_005.jpg" alt="Observer Pattern"/></div><p>
</p><p>But just like the example we've been talking about, observers in many situations care about more than one state. It could be less satisfying to have subjects attach observers separately.</p><p>A solution to this could be multi-state subjects, to achieve that, we can form a composite subject that contains sub-subjects. If a subject receives a <code class="literal">notify</code> call, it wakes up its observers and at the same time notifies its parent. Thus the observer can attach one composite subject for notifications of changes that happen to multiple states.</p><p>However, the process of creating the composite itself could still be annoying. In dynamic programming languages like JavaScript, we may have a state manager that contains specific states handling notifications and attaching observers directly with implicit creations of subjects:</p><pre class="programlisting">let stateManager = new StateManager({ &#13;
  connected: false, &#13;
  loaded: false, &#13;
  foo: 'abc', &#13;
  bar: 123 &#13;
}); &#13;
 &#13;
stateManager.on(['connected', 'loaded'], () =&gt; { &#13;
  let disabled = &#13;
    !stateManager.connected &amp;&amp; !stateManager.loaded; &#13;
  button.disabled = disabled; &#13;
}); &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>In many MV* frameworks, the states to be observed are analyzed automatically from related expressions by built-in parsers or similar mechanisms.</p></div></div><p>And now the structure gets even simpler:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_006.jpg" alt="Observer Pattern"/></div><p>
</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec104"/>Participants</h2></div></div></div><p>We've talked about the basic structure of Observer Pattern with subjects and observers, and a variant with implicit subjects. The participants of the basic structure include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Subject</strong></span><p>Subject to be observed. Defines methods to <code class="literal">attach</code> or <code class="literal">notify</code> observers. A subject could also be a composite that contains sub-subjects, which allows multiple states to be observed with the same interface.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete subject</strong></span>: <code class="literal">ConnectedSubject</code> and <code class="literal">LoadedSubject</code><p>Contains state related to the subject, and implements methods or properties to get and set their state.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Observer</strong></span><p>Defines the interface of an object that reacts when an observation notifies. In JavaScript, it could also be an interface (or signature) of a function.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete observer</strong></span>: <code class="literal">DoButtonObserver</code><p>Defines the action that reacts to the notifications of subjects being observed. Could be a callback function that matches the signature defined.</p></li></ul></div><p>In the variant version, the participants include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>State manager</strong></span><p>Manages a complex, possibly multi-level state object containing multiple states. Defines the interface to attach observers with subjects, and notifies those observers when a subject changes.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete subject</strong></span><p>Keys to specific states. For example, string <code class="literal">"connected"</code> may represent state <code class="literal">stateManager.connected</code>, while string <code class="literal">"foo.bar"</code> may represent state <code class="literal">stateManager.foo.bar</code>.</p></li></ul></div><p><span class="emphasis"><em>Observer</em></span> and <span class="emphasis"><em>concrete observer</em></span> are basically the same as described in the former structure. But observers are now notified by the state manager instead of subject objects.</p></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec105"/>Pattern scope</h2></div></div></div><p>Observer Pattern is a pattern that may easily structure half of the project. In MV* architectures, Observer Pattern can decouple the view from business logic. The concept of view can be applied to other scenarios related to displaying information as well.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec106"/>Implementation</h2></div></div></div><p>Both of the structures we've mentioned should not be hard to implement, though more details should be put into consideration for production code. We'll go with the second implementation that has a central state manager.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>To simplify the implementation, we will use <code class="literal">get</code> and <code class="literal">set</code> methods to access specific states by their keys. But many frameworks available might handle those through getters and setters, or other mechanisms.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>To learn about how frameworks like Angular handle states changing, please read their documentation or source code if necessary.</p></div></div><p>We are going to have <code class="literal">StateManager</code> inherit <code class="literal">EventEmitter</code>, so we don't need to care much about issues like multiple listeners. But as we are accepting multiple state keys as subjects, an overload to method <code class="literal">on</code> will be added. Thus the outline of <code class="literal">StateManager</code> would be as follows:</p><pre class="programlisting">type Observer = () =&gt; void; &#13;
 &#13;
class StateManager extends EventEmitter{ &#13;
  constructor( &#13;
    private state: any &#13;
  ) { &#13;
    super(); &#13;
  } &#13;
 &#13;
  set(key: string, value: any): void { } &#13;
 &#13;
  get(key: string): any { } &#13;
 &#13;
  on(state: string, listener: Observer): this; &#13;
  on(states: string[], listener: Observer): this; &#13;
  on(states: string | string[], listener: Observer): this { } &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip48"/>Tip</h3><p>You might have noticed that method <code class="literal">on</code> has the return type <code class="literal">this</code>, which may keep referring to the type of current instance. Type <code class="literal">this</code> is very helpful for chaining methods.</p></div></div><p>The keys will be <code class="literal">"foo"</code> and <code class="literal">"foo.bar"</code>, we need to split a key as separate identifiers for accessing the value from the <code class="literal">state</code> object. Let's have a private <code class="literal">_get</code> method that takes an array of <code class="literal">identifiers</code> as input:</p><pre class="programlisting">private _get(identifiers: string[]): any { &#13;
  let node = this.state; &#13;
 &#13;
  for (let identifier of identifiers) { &#13;
    node = node[identifier]; &#13;
  } &#13;
 &#13;
  return node; &#13;
} &#13;
</pre><p>Now we can implement method <code class="literal">get</code> upon <code class="literal">_get</code>:</p><pre class="programlisting">get(key: string): any { &#13;
  let identifiers = key.split('.'); &#13;
  return this._get(identifiers); &#13;
} &#13;
</pre><p>For method <code class="literal">set</code>, we can get the parent object of the last identifier of property to be set, so things work like this:</p><pre class="programlisting">set(key: string, value: any): void { &#13;
  let identifiers = key.split('.'); &#13;
  let lastIndex = identifiers.length - 1; &#13;
 &#13;
  let node = this._get(identifiers.slice(0, lastIndex)); &#13;
   &#13;
  node[identifiers[lastIndex]] = value; &#13;
} &#13;
</pre><p>But there's one more thing, we need to notify observers that are observing a certain subject:</p><pre class="programlisting">set(key: string, value: any): void { &#13;
  let identifiers = key.split('.'); &#13;
  let lastIndex = identifiers.length - 1; &#13;
 &#13;
  let node = this._get(identifiers.slice(0, lastIndex)); &#13;
   &#13;
  node[identifiers[lastIndex]] = value; &#13;
 &#13;
  <span class="strong"><strong>for (let i = identifiers.length; i &gt; 0; i--) { &#13;
    let key = identifiers.slice(0, i).join('.'); &#13;
    this.emit(key); &#13;
  }</strong></span> &#13;
} &#13;
</pre><p>When we're done with the notifying part, let's add an overload for method <code class="literal">on</code> to support multiple keys:</p><pre class="programlisting">on(state: string, listener: Observer): this; &#13;
on(states: string[], listener: Observer): this; &#13;
on(states: string | string[], listener: Observer): this { &#13;
  if (typeof states === 'string') { &#13;
    super.on(states, listener); &#13;
  } else { &#13;
    for (let state of states) { &#13;
      super.on(state, listener); &#13;
    } &#13;
  } &#13;
 &#13;
  return this; &#13;
} &#13;
</pre><p>Problem solved. Now we have a state manager that will work for simple scenarios.</p></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec107"/>Consequences</h2></div></div></div><p>Observer Pattern decouples subjects with observers. While an observer may be observing multiple states in subjects at the same time, it usually does not care about which state triggers the notification. As a result, the observer may make <span class="emphasis"><em>unnecessary</em></span> updates that actually do nothing to - for example - the view.</p><p>However, the impact on performance could be negligible most of the time, not even need to mention the benefits it brings.</p><p>By splitting view and logic apart, Observer Pattern may reduce possible branches significantly. This will help eliminate bugs caused at the coupling part between view and logic. Thus, by properly applying Observer Pattern, the project will be made much more robust and easier to maintain.</p><p>However, there are some details we still need care about:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The observer that updates the state could cause circular invocation.</li><li class="listitem">For more complex data structures like collections, it might be expensive to re-render everything. Observers in this scenario may need more information about the change to only perform necessary updates. View implementations like React do this in another way; they introduce a concept called <span class="strong"><strong>Virtual DOM</strong></span>. By updating and diffing the virtual DOM before re-rendering the actual DOM (which could usually be the bottleneck of performance), it provides a relatively general solution for different data structures.</li></ol></div></div></div>
<div class="section" title="Visitor Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Visitor Pattern</h1></div></div></div><p>Visitor Pattern provides a uniformed interface for <span class="emphasis"><em>visiting</em></span> different data or objects while allowing detailed operations in concrete visitors to vary. Visitor Pattern is usually used with composites, and it is widely used for walking through data structures like <span class="strong"><strong>abstract syntax tree</strong></span> (<span class="strong"><strong>AST</strong></span>). But to make it easier for those who are not familiar with compiler stuff, we will provide a simpler example.</p><p>Consider a DOM-like tree containing multiple elements to render:</p><pre class="programlisting">[ &#13;
  Text { &#13;
    content: "Hello, " &#13;
  }, &#13;
  BoldText { &#13;
    content: "TypeScript" &#13;
  }, &#13;
  Text { &#13;
    content: "! Popular editors:\n" &#13;
  }, &#13;
  UnorderedList { &#13;
    items: [ &#13;
      ListItem { &#13;
        content: "Visual Studio Code" &#13;
      }, &#13;
      ListItem { &#13;
        content: "Visual Studio" &#13;
      }, &#13;
      ListItem { &#13;
        content: "WebStorm" &#13;
      } &#13;
    ] &#13;
  } &#13;
] &#13;
</pre><p>The rendering result in HTML would look like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_007.jpg" alt="Visitor Pattern"/></div><p>
</p><p>While in Markdown, it would look like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_008.jpg" alt="Visitor Pattern"/></div><p>
</p><p>Visitor Pattern allows operations in the same category to be coded in the same place. We'll have concrete visitors, <code class="literal">HTMLVisitor</code> and <code class="literal">MarkdownVisitor</code> that take the responsibilities of transforming different nodes by visiting them respectively and recursively. The nodes being visited have a method <code class="literal">accept</code> for accepting a visitor to perform the transformation. An overall structure of Visitor Pattern could be split into two parts, the first part is the visitor abstraction and its concrete subclasses:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_009.jpg" alt="Visitor Pattern"/></div><p>
</p><p>The second part is the abstraction and concrete subclasses of nodes to be visited:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_010.jpg" alt="Visitor Pattern"/></div><p>
</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec108"/>Participants</h2></div></div></div><p>The participants of Visitor Pattern include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Visitor</strong></span>: <code class="literal">NodeVisitor</code><p>Defines the interface of operations corresponding to each element class. In languages with static types and method overloading, the method names can be unified. But as it takes extra runtime checking in JavaScript, we'll use different method names to distinguish them. The operation methods are usually named after <code class="literal">visit</code>, but here we use <code class="literal">append</code> as its more related to the context.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete visitor</strong></span>: <code class="literal">HTMLVisitor</code> and <code class="literal">MarkdownVisitor</code><p>Implements every operation of the concrete visitor, and handles internal states if any.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Element</strong></span>: <code class="literal">Node</code><p>Defines the interface of the element accepting the visitor instance. The method is usually named <code class="literal">accept</code>, though here we are using <code class="literal">appendTo</code> for a better matching with the context. Elements could themselves be composites and pass visitors on with their child elements.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete element</strong></span>: <code class="literal">Text</code>, <code class="literal">BoldText</code>, <code class="literal">UnorderedList</code> and <code class="literal">ListItem</code><p>Implements <code class="literal">accept</code> method and calls the method from the visitor instance corresponding to the element instance itself.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span>:<p>Enumerates elements and applies visitors to them.</p></li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec109"/>Pattern scope</h2></div></div></div><p>Visitor Pattern can form a large feature inside a system. For some programs under certain categories, it may also form the core architecture. For example, <span class="emphasis"><em>Babel</em></span> uses Visitor Pattern for AST transforming and a plugin for Babel is actually a visitor that can visit and transform elements it cares about.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec110"/>Implementation</h2></div></div></div><p>We are going to implement <code class="literal">HTMLVisitor</code> and <code class="literal">MarkdownVisitor</code> which may transform nodes to text, as we've talked about. Start with the upper abstraction:</p><pre class="programlisting">interface Node { &#13;
  appendTo(visitor: NodeVisitor): void; &#13;
} &#13;
 &#13;
interface NodeVisitor { &#13;
  appendText(text: Text): void; &#13;
  appendBold(text: BoldText): void; &#13;
  appendUnorderedList(list: UnorderedList): void; &#13;
  appendListItem(item: ListItem): void; &#13;
} &#13;
</pre><p>Continue with concrete nodes that do similar things, <code class="literal">Text</code> and <code class="literal">BoldText</code>:</p><pre class="programlisting">class Text implements Node { &#13;
  constructor( &#13;
    public content: string &#13;
  ) { } &#13;
 &#13;
  appendTo(visitor: NodeVisitor): void { &#13;
    visitor.appendText(this); &#13;
  } &#13;
} &#13;
 &#13;
class BoldText implements Node { &#13;
  constructor( &#13;
    public content: string &#13;
  ) { } &#13;
 &#13;
  appendTo(visitor: NodeVisitor): void { &#13;
    visitor.appendBold(this); &#13;
  } &#13;
} &#13;
</pre><p>And list stuff:</p><pre class="programlisting">class UnorderedList implements Node { &#13;
  constructor( &#13;
    public items: ListItem[] &#13;
  ) { } &#13;
 &#13;
  appendTo(visitor: NodeVisitor): void { &#13;
    visitor.appendUnorderedList(this); &#13;
  } &#13;
} &#13;
 &#13;
class ListItem implements Node { &#13;
  constructor( &#13;
    public content: string &#13;
  ) { } &#13;
 &#13;
  appendTo(visitor: NodeVisitor): void { &#13;
    visitor.appendListItem(this); &#13;
  } &#13;
} &#13;
</pre><p>Now we have the elements of a structure to be visited, we'll begin to implement concrete visitors. Those visitors will have an <code class="literal">output</code> property for the transformed string. <code class="literal">HTMLVisitor</code> goes first:</p><pre class="programlisting">class HTMLVisitor implements NodeVisitor { &#13;
  output = ''; &#13;
 &#13;
  appendText(text: Text) { &#13;
    this.output += text.content; &#13;
  } &#13;
 &#13;
  appendBold(text: BoldText) { &#13;
    this.output += `&lt;b&gt;${text.content}&lt;/b&gt;`; &#13;
  } &#13;
 &#13;
  appendUnorderedList(list: UnorderedList) { &#13;
    this.output += '&lt;ul&gt;'; &#13;
 &#13;
    for (let item of list.items) { &#13;
      item.appendTo(this); &#13;
    } &#13;
 &#13;
    this.output += '&lt;/ul&gt;'; &#13;
  } &#13;
 &#13;
  appendListItem(item: ListItem) { &#13;
    this.output += `&lt;li&gt;${item.content}&lt;/li&gt;`; &#13;
  } &#13;
} &#13;
</pre><p>Pay attention to the loop inside <code class="literal">appendUnorderedList</code>, it handles visiting of its own list items.</p><p>A similar structure applies to <code class="literal">MarkdownVisitor</code>:</p><pre class="programlisting">class MarkdownVisitor implements NodeVisitor { &#13;
  output = ''; &#13;
 &#13;
  appendText(text: Text) { &#13;
    this.output += text.content; &#13;
  } &#13;
 &#13;
  appendBold(text: BoldText) { &#13;
    this.output += `**${text.content}**`; &#13;
  } &#13;
 &#13;
  appendUnorderedList(list: UnorderedList) { &#13;
    this.output += '\n'; &#13;
 &#13;
    for (let item of list.items) { &#13;
      item.appendTo(this); &#13;
    } &#13;
  } &#13;
 &#13;
  appendListItem(item: ListItem) { &#13;
    this.output += `- ${item.content}\n`; &#13;
  } &#13;
} &#13;
</pre><p>Now the infrastructures are ready, let's create the tree-like structure we've been imagining since the beginning:</p><pre class="programlisting">let nodes = [ &#13;
  new Text('Hello, '), &#13;
  new BoldText('TypeScript'), &#13;
  new Text('! Popular editors:\n'), &#13;
  new UnorderedList([ &#13;
    new ListItem('Visual Studio Code'), &#13;
    new ListItem('Visual Studio'), &#13;
    new ListItem('WebStorm') &#13;
  ]) &#13;
]; &#13;
</pre><p>And finally, build the outputs with visitors:</p><pre class="programlisting">let htmlVisitor = new HTMLVisitor(); &#13;
let markdownVisitor = new MarkdownVisitor(); &#13;
 &#13;
for (let node of nodes) { &#13;
  node.appendTo(htmlVisitor); &#13;
  node.appendTo(markdownVisitor); &#13;
} &#13;
 &#13;
console.log(htmlVisitor.output); &#13;
console.log(markdownVisitor.output); &#13;
</pre></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec111"/>Consequences</h2></div></div></div><p>Both Strategy Pattern and Visitor Pattern could be applied to scenarios of processing objects. But Strategy Pattern relies on clients to handle all related arguments and contexts, this makes it hard to come out with an exquisite abstraction if the expected behaviors of different objects differ a lot. Visitor Pattern solves this problem by decoupling visit actions and operations to be performed.</p><p>By passing different visitors, Visitor Pattern can apply different operations to objects without changing other code although it usually means adding new elements and would result in adding related operations to an abstract visitor and all of its concrete subclasses.</p><p>Visitors like the <code class="literal">NodeVisitor</code> in the previous example may store state itself (in that example, we stored the output of transformed nodes) and more advanced operations can be applied based on the state accumulated. For example, it's possible to determine what has been appended to the output, and thus we can apply different behaviors with the node currently being visited.</p><p>However, to complete certain operations, extra public methods may need to be exposed from the elements.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Summary</h1></div></div></div><p>In this chapter, we've talked about other behavior design patterns as complements to the former chapter, including Strategy, State, Template Method, Observer and Visitor Pattern.</p><p>Strategy Pattern is so common and useful that it may appear in a project several times, with different forms. And you might not know you were using Observer Pattern with implementation in a daily framework.</p><p>After walking through those patterns, you might find there are many ideas in common behind each pattern. It is worth thinking what's behind them and even letting the outline go in your mind.</p><p>In the next chapter, we'll continue with some handy patterns related to JavaScript and TypeScript, and important scenarios of those languages.</p></div></body></html>