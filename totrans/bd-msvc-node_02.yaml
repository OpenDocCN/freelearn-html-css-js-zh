- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring the Core Principles of Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microservices** is an architectural style that aims to develop software systems
    as a collection of small, loosely coupled, and independently deployable services.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start this chapter with an exploration of the core principles of microservices.
    To learn to think in microservices, you need to understand the core principles
    and mindset behind this architectural style. Thinking in microservices is a shift
    from traditional monolithic thinking. It requires a mindset focused on breaking
    down complex systems into smaller, manageable parts and promoting independence
    and flexibility among teams. You should embrace the principles of microservices
    and continuously refine your understanding through practical experience and ongoing
    learning.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned the core principles of microservices
    and how to apply them in your everyday work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the core principles of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the fundamentals and identifying business capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining service contracts and decentralizing decision making
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritizing autonomy and ownership and designing for resilience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing communication strategies and ensuring scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing observability and continuously learning and improving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the core principles of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going learn about the core principles of microservices.
    Microservices are organized around specific business capabilities and communicate
    with one another through well-defined **application programming interfaces** (**APIs**).
    The core principles of microservices revolve around autonomy, bounded context,
    decentralization, and resilience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore each of these principles in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autonomy**: Each microservice within a system is designed to be autonomous.
    It means that each service can be developed, deployed, and scaled independently
    without relying on other services. Autonomy allows development teams to work independently,
    choose appropriate technologies, and make decisions regarding the service implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounded context**: Bounded context refers to the concept of defining clear
    boundaries and responsibilities for each microservice. Each service should have
    a specific business domain or functionality it focuses on. By defining these boundaries,
    the services can be developed and maintained independently, reducing dependencies
    and complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decentralization**: Microservices promote decentralization by distributing
    the system’s functionality across multiple services. Rather than building a monolithic
    application, microservices enable breaking down the system into smaller, manageable
    components. This distribution of functionality allows teams to develop and deploy
    services independently, enabling faster development and deployment cycles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience**: Resilience is a crucial principle of microservices, as failures
    in a distributed system are inevitable. Microservices are designed to handle failures
    gracefully and recover from them without affecting the overall system. Services
    are expected to be fault-tolerant, and failures are isolated within the affected
    service, minimizing the impact on other services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some additional principles and best practices associated with microservices
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility**: Each microservice should have a single responsibility
    or do one thing well. This principle helps in keeping services focused and manageable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication via APIs**: Microservices communicate with one another through
    well-defined APIs, typically using lightweight protocols such as **representational
    state transfer** (**REST**) or messaging systems such as RabbitMQ or Apache Kafka.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data management**: Each microservice should have its own database or data
    store, keeping data private to that service. This ensures loose coupling between
    services and prevents data access complexities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure automation**: Microservices benefit from infrastructure automation
    practices such as **continuous integration/continuous deployment** (**CI/CD**),
    containerization, and orchestration tools such as Docker and Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and observability**: Monitoring and observability are essential
    for microservices to gain insights into the system’s performance, health, and
    issues. Logging, metrics, and distributed tracing are key tools to achieve observability
    in a microservices architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evolutionary design**: Microservices should be designed with the expectation
    of change. The architecture should be flexible enough to accommodate new features,
    scale, and evolving business requirements without disrupting other services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding these principles is of great value for doing good work with microservices.
    These principles help you a lot to find a solution for every problem while you
    don’t waste time using old methodologies. With microservices, you will always
    do a great job, you can finish work on time, and debugging is so much easier.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.1* explains the core principles of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Core principles of microservices](img/B14980_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Core principles of microservices'
  prefs: []
  type: TYPE_NORMAL
- en: By adhering to these core principles, development teams can create scalable,
    modular, and maintainable software systems using the microservices architectural
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of the core principles of microservices, let’s
    move on to their fundamentals and business capabilities in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the fundamentals and identifying business capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the fundamentals and identifying the business capabilities of
    microservices are crucial steps in designing an effective microservices architecture.
    It involves analyzing the application’s requirements, breaking down the system
    into smaller functional components, and identifying the individual business capabilities
    that each microservice will encapsulate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key steps to understanding the fundamentals and identifying the
    business capabilities of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain-driven design** (**DDD**): DDD is an approach that emphasizes modeling
    the domain (business problem) in the application’s design. It involves collaborating
    with domain experts and stakeholders to gain a deep understanding of the business
    requirements, rules, and processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decomposition of monolithic systems**: If you are migrating from a monolithic
    architecture to microservices, you will need to analyze the monolithic application’s
    functionalities and break it down into smaller functional components. Each component
    can then potentially become a microservice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounded contexts**: In DDD, bounded contexts define clear boundaries around
    specific business capabilities. You will need to identify the bounded contexts
    in your application and consider them as candidates for microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identification of business capabilities**: Within each bounded context, you
    should identify the core business capabilities that need to be handled by microservices.
    These capabilities represent specific functionalities or services that microservices
    will provide.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independence and autonomy**: You must ensure that each microservice has a
    clear and independent responsibility, encapsulating a single business capability.
    This autonomy allows each service to be developed, deployed, and scaled independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loose coupling**: Microservices should have minimal dependencies on other
    services to achieve loose coupling. You need to identify the relationships and
    dependencies between different business capabilities and design services accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team ownership**: You must assign ownership of each microservice to a specific
    team. Teams should be cross functional and include all the skills necessary to
    develop, deploy, and maintain the microservice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API design**: You should define clear and well-documented APIs for each microservice,
    specifying how other services or clients can interact with the capabilities it
    offers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared libraries and components**: You need to identify common functionality
    or shared components that can be used across multiple microservices to promote
    code reuse and consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability considerations**: You should analyze the scalability requirements
    of each business capability to determine if it should be implemented as a separate
    microservice. Some capabilities may have higher demands and benefit from being
    independently scalable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data management**: You must consider the data needs of each business capability
    and decide whether each microservice will have its own database or if data should
    be shared between services through events or other mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the fundamentals and identifying business capabilities are crucial
    steps in building a successful microservices architecture. It involves gaining
    a deep understanding of the application’s requirements and breaking down the system
    into smaller, manageable components.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the fundamental aspects and identifying the business capabilities
    of microservices, you can design a scalable, maintainable, and resilient microservices
    architecture that aligns with the specific needs of your application and supports
    the agility and flexibility required for modern software development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn about defining service contracts and decentralized
    decision making.
  prefs: []
  type: TYPE_NORMAL
- en: Defining service contracts and decentralized decision making
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service contracts in microservices refer to the agreements and expectations
    that services establish with one another. Meanwhile, decentralized decision making
    is a fundamental principle of microservices architecture that empowers individual
    development teams to make decisions independently. Let’s learn about these concepts
    in detail. We’ll start with service contracts in microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Service contracts in microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Service contracts in microservices** refer to the agreements and expectations
    that services establish with one another. They define how different microservices
    interact, communicate, and exchange data. Service contracts play a crucial role
    in ensuring that microservices can work together seamlessly, even when they are
    developed and deployed independently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The common types of service contracts include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API contracts**: API contracts define the interfaces and data formats that
    microservices use to communicate. They include details about the request and response
    payloads, endpoints, authentication requirements, and supported operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral contracts**: Behavioral contracts specify the expected behavior
    and interactions of a microservice. They may include rules about error handling,
    response times, and business logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning contracts**: As microservices evolve, it is essential to have
    versioning contracts that allow backward compatibility. They ensure that changes
    to a microservice’s contract do not break the existing consumers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data contracts**: Data contracts outline the structure and validation rules
    for the data exchanged between microservices. They ensure that the services understand
    each other’s data format and avoid data inconsistencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security contracts**: Security contracts define the security requirements
    and constraints for interacting with a microservice. They include authentication
    and authorization mechanisms to protect sensitive data and resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service-level agreements (SLAs)**: SLAs specify the expected levels of service
    performance, availability, and response times between microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the most common service contracts used in microservices architecture.
    It enables the developers to guide a project better. In the context of microservices
    architecture, service contracts refer to the well-defined agreements and specifications
    that govern how microservices communicate with each other. These contracts define
    the input and output formats, protocols, data types, and error-handling mechanisms
    that services adhere to when interacting with one another. Clear and well-defined
    service contracts are crucial for ensuring seamless communication and collaboration
    between microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.2* shows the service contracts in a graphical manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Service contracts](img/B14980_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Service contracts'
  prefs: []
  type: TYPE_NORMAL
- en: By adhering to well-defined service contracts, microservices can communicate
    effectively, enabling a modular, scalable, and maintainable system. These contracts
    provide a clear interface for each microservice, allowing them to evolve independently
    without disrupting other parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: With the most common service contracts under our belt, let’s now take a look
    at the principle of decentralizing decision making in a microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized decision making in microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Decentralizing decision making** is a fundamental principle of microservices
    architecture that empowers individual development teams to make decisions independently.
    This approach promotes agility, autonomy, and faster development cycles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key aspects of decentralized decision making are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autonomous teams**: Each microservice is owned and managed by a dedicated
    team that has full control over its development, deployment, and operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain-oriented teams**: Teams are organized around specific business domains
    or capabilities, giving them deep expertise and a clear understanding of the microservices
    they are responsible for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology stack choice**: Teams have the freedom to choose their preferred
    technology stack, programming languages, frameworks, and tools that best suit
    the needs of their microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service independence**: Decentralization ensures that each microservice can
    evolve independently without impacting other services, reducing the risk of interdependencies
    and bottlenecks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast feedback loops**: Short feedback loops allow teams to iterate quickly
    and make informed decisions based on real-time data and user feedback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration and communication**: While teams operate autonomously, collaboration
    and communication between teams are vital for shared understanding and avoiding
    duplicated efforts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency through contracts**: Service contracts act as a mechanism to
    ensure that services can interact cohesively despite their autonomy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized decision making enables microservices to scale effectively, fosters
    innovation, and enables teams to respond rapidly to changing requirements. However,
    it requires strong communication, coordination, and a shared vision across the
    organization to ensure that the overall architecture aligns with the business
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.3* shows the diagram of a decentralized architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Decentralized architecture](img/B14980_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Decentralized architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Defining service contracts and decentralizing decision making are key principles
    in microservices architecture that promote effective communication and agility.
  prefs: []
  type: TYPE_NORMAL
- en: By defining service contracts and decentralizing decision making, microservices
    architecture can achieve effective communication, adaptability, and responsiveness,
    ensuring that the system evolves gracefully to meet changing business needs and
    technological advancements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll see how to prioritize autonomy and ownership and
    how to design microservices for resilience.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing autonomy and ownership and designing for resilience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prioritizing autonomy and ownership and designing for resilience are two essential
    principles in microservices architecture that contribute to the success and effectiveness
    of the system. Let’s explore these principles in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing autonomy and ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Autonomy and ownership** in microservices refer to empowering individual
    development teams with the responsibility for designing, developing, deploying,
    and maintaining their respective microservices. This principle allows teams to
    have control over their microservices and fosters a sense of ownership and accountability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key aspects of prioritizing autonomy and ownership include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain-oriented teams**: Organize teams around specific business domains
    or capabilities, enabling them to have deep expertise in the areas they are responsible
    for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end responsibility**: Development teams take full ownership of the
    entire lifecycle of their microservices, from development to production. This
    includes monitoring, troubleshooting, and scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology freedom**: Give teams the freedom to choose their preferred technology
    stack, tools, and development practices that best suit their microservices’ requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast iteration**: Empower teams to iterate quickly by removing bureaucratic
    hurdles and providing a streamlined development and deployment process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-functional teams**: Teams should be cross functional, including developers,
    testers, operations, and other necessary roles to ensure self-sufficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These key concepts for autonomy and ownership develop an entrepreneurial spirit
    in specialists, and every specialist, after mastering these concepts, will be
    better and more autonomous at work while considering the product as their own.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.4* depicts an autonomous architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Autonomous architecture](img/B14980_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Autonomous architecture'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 2**.4*, **Payments** and **Services** are microservices that rely
    on autonomous architecture while connecting to their respective database.
  prefs: []
  type: TYPE_NORMAL
- en: By prioritizing autonomy and ownership, microservices architecture can achieve
    greater agility, faster time-to-market, and improved innovation. Teams can respond
    quickly to business changes and make data-driven decisions for their microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for resilience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Designing for resilience** in microservices focuses on building a system
    that can withstand and recover gracefully from failures, ensuring high availability
    and fault tolerance. In a distributed microservices environment, failures are
    inevitable, so resilience is critical.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key aspects of designing for resilience include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redundancy**: Deploy multiple instances of critical microservices to ensure
    redundancy and avoid single points of failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit breakers**: Implement circuit breakers to isolate failing services
    and prevent cascading failures across the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bulkheads**: Use bulkheads to separate different parts of the system, ensuring
    that a failure in one part does not affect the entire system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graceful degradation**: Design services to degrade gracefully in the face
    of high load or failures, prioritizing critical functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeouts and retries**: Implement appropriate timeouts and retries for service-to-service
    communication to handle temporary network issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed tracing and logging**: Use distributed tracing and centralized
    logging to gain insights into the interactions and behaviors of microservices,
    aiding in debugging and monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chaos engineering**: Conduct controlled experiments, such as chaos engineering,
    to test the system’s resilience under real-world failure scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By designing for resilience, microservices architecture can maintain a high
    level of availability and provide a better user experience, even in the presence
    of failures or unpredictable conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.5* shows the design for a resilient system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Design for resilience](img/B14980_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Design for resilience'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.5* describes the connection between users and services, which rely
    their function on a load balancer to retrieve information from a database. In
    this case, the system itself, with the help of a load balancer, decides which
    of the services the users should connect to in order to avoid a high load and
    malfunctioning of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing autonomy and ownership and designing for resilience work hand in
    hand to create a robust, adaptive, and reliable microservices ecosystem. These
    principles help teams work efficiently, foster a culture of ownership and responsibility,
    and deliver a resilient system that meets the demands of modern software applications.
    In conclusion, prioritizing autonomy and ownership allows development teams to
    work independently and take ownership of their microservices, fostering agility
    and innovation. Designing for resilience ensures that the microservices ecosystem
    remains robust and reliable, enhancing overall performance and user satisfaction.
    By adhering to these principles, microservices architecture can deliver scalable,
    adaptable, and resilient systems that meet the demands of modern applications
    and provide a competitive edge in the market.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore strategies for communicating effectively and ensuring scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing communication strategies and ensuring scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing effective communication strategies and ensuring scalability are
    crucial aspects of microservices architecture that contribute to the seamless
    operation and growth of the system. Let’s delve into these two areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing communication strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a microservices architecture, services need to communicate with one another
    to fulfill various functionalities. Proper communication strategies ensure that
    services can interact efficiently and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common communication patterns in microservices include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous communication**: This involves direct request-response communication
    between microservices. It can be achieved through HTTP/HTTPS or gRPC-based APIs.
    However, it can lead to tight coupling between services and may result in cascading
    failures during high traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous communication**: Asynchronous communication decouples microservices,
    allowing them to work independently without waiting for responses. Message queues
    or event streaming platforms, such as Apache Kafka or RabbitMQ, facilitate asynchronous
    communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven architecture**: Microservices can communicate through events,
    where one service publishes events and other services subscribe to and react to
    those events. This pattern promotes loose coupling and scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API gateway**: An API gateway acts as a single entry point for clients to
    access multiple microservices. It centralizes request handling and load balancing
    and can provide additional security features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service discovery**: Service discovery mechanisms allow microservices to
    locate and communicate with each other dynamically. This is particularly useful
    in a dynamic environment where service instances may scale up or down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit breaker**: Implement circuit breakers to prevent cascading failures
    when a service is down or experiencing high latency. It isolates the failing service
    and provides fallback responses when necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing effective communication strategies is a critical way for the system
    to run in a perfect manner, without errors, and to assure availability. Every
    developer should design a system that communicates with services in a perfect
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to ensure the best coordination between microservices, we will learn about
    scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring scalability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scalability** is essential to handle varying workloads and ensure that a
    system can grow to meet increasing demands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following strategies for ensuring scalability in microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal scaling**: Scale microservices horizontally by adding more instances
    of a service to distribute the load. Container orchestration platforms such as
    Kubernetes can help with dynamic scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless services**: Design microservices to be stateless, meaning they
    don’t store any session or client-specific data. This allows them to be easily
    replicated and scaled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: Load balancers distribute incoming traffic across multiple
    instances of a service to ensure optimal resource utilization and avoid overloading
    individual instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared-nothing architecture**: Aim for a shared-nothing architecture, where
    each microservice has its own dedicated resources and does not rely on shared
    databases or storage. This avoids bottlenecks and contention points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Implement caching for frequently accessed data to reduce the load
    on databases and improve response times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto-scaling**: Use auto-scaling mechanisms to automatically adjust the number
    of instances based on real-time demand, ensuring optimal resource utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database sharding**: For databases, consider sharding data across multiple
    nodes to distribute the load and improve database performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the ever-growing request by users to access web applications, it is a crucial
    requirement to develop using scalability. This will let users rely on a trusted
    and fast-growing application and leave positive system feedback.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.6* depicts communication via APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Communication via APIs](img/B14980_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Communication via APIs'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.6* shows a system developed using microservices that allows different
    kinds of users and devices to connect to microservices with the help of an API.
    This will allow users to have the best user experience while operating on a fast
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.7* depicts database sharding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Database sharding](img/B14980_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Database sharding'
  prefs: []
  type: TYPE_NORMAL
- en: Database sharding is a great practice to develop while thinking in microservices.
    As shown in *Figure 2**.7*, every service has its own database and it displays
    its information on user request. If one service fails, the others should work
    correctly, regardless of the one that has failed.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing efficient communication strategies and ensuring scalability,
    microservices can handle varying workloads, provide a seamless user experience,
    and easily adapt to changing demands. These principles are essential in creating
    a resilient and high-performing microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing efficient communication strategies and ensuring scalability,
    microservices can work together seamlessly, handle varying workloads, and adapt
    to changing business needs. These practices support the development of responsive,
    high-performing, and reliable microservices architectures that align with modern
    software application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap up this chapter, we’ll learn about two crucial practices in microservice
    architecture: observability and continuous learning and improvement.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing observability and continuously learning and improving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing observability and continuously learning and improving are critical
    practices in microservices architecture to gain insights into the system’s behavior,
    monitor its health, and make data-driven decisions for ongoing enhancements. Let’s
    explore each aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing observability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Observability** in microservices refers to the ability to gain deep insights
    into the internal workings of the system through monitoring, logging, and distributed
    tracing. It helps in understanding the system’s performance, identifying bottlenecks,
    diagnosing issues, and ensuring reliability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key aspects of implementing observability include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitoring**: Set up comprehensive monitoring systems to collect real-time
    data on key metrics such as response times, error rates, CPU and memory usage,
    and service availability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging**: Implement structured logging to capture meaningful information
    about the behavior of microservices and the flow of requests between services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed tracing**: Use distributed tracing to track requests as they
    flow through multiple microservices, allowing you to identify latency and performance
    issues across service boundaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics Aggregation**: Aggregate metrics and logs centrally using tools such
    as Prometheus, Grafana, ELK stack (Elasticsearch, Logstash, and Kibana), or other
    observability platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alerting and notifications**: Set up proactive alerts based on predefined
    thresholds to be notified when specific metrics or events deviate from the expected
    behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dashboards and visualization**: Create informative dashboards and visualizations
    to provide a clear overview of the system’s health and performance to both developers
    and stakeholders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observability plays a crucial role while programming in microservices because
    it helps developers have a 360-degree dashboard about how their application is
    being used. Also, they can apply this knowledge to improve the application, as
    explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous learning and improving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Continuous learning and improvement** are essential for the success of a
    microservices-based application. This involves using data, feedback, and user
    insights to make informed decisions and iteratively enhance the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key aspects of continuous learning and improvement are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Feedback loops**: Establish feedback loops to gather insights from users,
    stakeholders, and developers to understand pain points and areas of improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-driven decisions**: Make decisions based on empirical evidence and data
    gathered through observability. Use metrics and performance data to identify areas
    for optimization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrospectives**: Conduct regular retrospectives to reflect on past iterations
    and identify what worked well and what needs improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Experimentation**: Encourage experimentation, such as A/B testing, to test
    new features or changes in a controlled manner and make decisions based on measurable
    outcomes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterative development**: Embrace an iterative development approach, allowing
    frequent releases and continuous improvement based on user feedback and business
    needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post-mortems**: Conduct post-mortems to analyze and learn from any major
    incidents or outages, identifying root causes and preventive measures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptive architecture**: Continuously assess the microservices architecture
    to ensure it aligns with evolving business requirements and technological advancements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the basics of these concepts and applying them is a great way to improve
    the application. The application will be better and the user will feel happier.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.8* shows information about monitoring and observability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: Monitoring and observability](img/B14980_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Monitoring and observability'
  prefs: []
  type: TYPE_NORMAL
- en: By implementing observability and continuously learning and improving, microservices-based
    applications can stay resilient, reliable, and responsive to changing business
    demands. These practices foster a culture of continuous improvement, driving the
    development teams toward delivering high-quality software that meets the needs
    of users and stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned a lot of core principles of microservices.
    In particular, exploring the core principles of microservices provides valuable
    insights into the fundamental concepts that underpin this architectural approach.
    These principles aim to create a modular, scalable, and maintainable system that
    aligns with modern software development practices and business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, exploring the core principles of microservices enables the creation
    of a modular and adaptable system that can meet the demands of modern software
    development and support the evolving needs of businesses. By adhering to these
    principles, organizations can build scalable, resilient, and customer-centric
    applications, driving innovation and staying competitive in a dynamic market.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to learn about the fundamentals of Node.js:
    its building blocks and key concepts. We’ll also learn how to build microservices
    projects in Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Quiz time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the core principles of microservices?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the key aspects of decentralized decision making?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For what is needed implementing observability and continuously learning and
    improving?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
