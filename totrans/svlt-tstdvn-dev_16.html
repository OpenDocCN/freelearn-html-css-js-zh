<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer048">
<h1 class="chapter-number" id="_idParaDest-176"><a id="_idTextAnchor175"/>16</h1>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/>Test-Driving Service Workers</h1>
<p>This chapter looks at <strong class="bold">service workers</strong>, which are bits of code that are installed on the browser and are invoked before any HTTP operation. That makes them useful for a certain set of features, such as enabling offline access to your app. The service worker implemented in this chapter provides exactly <span class="No-Break">that feature.</span></p>
<p>It’s almost always a good idea to use off-the-shelf service workers rather than rolling your own. But it’s instructive to see how you might test your own service workers, hence the inclusion in <span class="No-Break">this book.</span></p>
<p>The term <strong class="bold">testability</strong> is used to describe how straightforward it is to write tests for your application code. The way we structure our components and modules has a big impact on their testability. Service workers are a great example of taking something that, at first glance, is a highly complex thing to test and restructuring its implementation so that the tests become <span class="No-Break">almost trivial.</span></p>
<p>This chapter covers the following <span class="No-Break">key topics:</span></p>
<ul>
<li>Adding a Playwright test for <span class="No-Break">offline access</span></li>
<li>Implementing the <span class="No-Break">service worker</span></li>
</ul>
<p>By the end of the chapter, you’ll have learned how to test-drive service workers, plus you’ll have learned a new technique for making your application code <span class="No-Break">more testable.</span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor177"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter16/Complete"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter16/Complete</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor178"/>Adding a Playwright test for offline access</h1>
<p>Service workers tend to have <a id="_idIndexMarker498"/>a specific intent. In our case, the service worker enables the application to be used offline: loading the application causes it to be cached. If the network is no longer accessible, the next page load will be served from this cache, courtesy of the <span class="No-Break">service worker.</span></p>
<p>Therefore, the Playwright test needs to test the application’s behavior when there’s no <span class="No-Break">network connection.</span></p>
<p>At the time of writing, Playwright’s support for service worker events is experimental, so it needs to be enabled using the <strong class="source-inline">PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS</strong> flag in your <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
{
  "scripts": {
    ...,
  "test": "PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS=1
    playwright test",
  ...
  }
}</pre>
<p>Once that’s done, we’re ready to write our tests. We need two helper functions. The first, <strong class="source-inline">waitForServiceWorkerActivation</strong>, can be invoked by any Playwright test to ensure that subsequent commands don’t run until the service worker is actively caching <span class="No-Break">new requests.</span></p>
<p>This code can be found in <strong class="source-inline">tests/offline.test.js</strong>. I’ve parked it right next to the single test that uses it: there’s not much point in moving it to another file because I don’t expect to reuse this function anywhere else in the <span class="No-Break">test suite:</span></p>
<pre class="source-code">
const waitForServiceWorkerActivation = (page) =&gt;
  page.evaluate(async () =&gt; {
    const registration =
      await
        window.navigator.serviceWorker.getRegistration();
    if (registration.active?.state === 'activated')
      return;
    await new Promise((res) =&gt;
      window.navigator.serviceWorker.addEventListener(
        'controllerchange',
        res
      )
    );
  });</pre>
<p>Next, we need a <strong class="source-inline">disableNetwork</strong> function that<a id="_idIndexMarker499"/> will cause any network request to return a <span class="No-Break">network error:</span></p>
<pre class="source-code">
const disableNetwork = (context) =&gt;
  context.route('<strong class="bold">', (route) =&gt; route.abort());</strong></pre>
<p>Then we’re ready to write <span class="No-Break">the test:</span></p>
<pre class="source-code">
test('site is available offline', async ({
  page,
  context,
  browser
}) =&gt; {
  await page.goto('/birthdays');
  await waitForServiceWorkerActivation(page);
  await disableNetwork(context);
  await page.goto('/birthdays');
  await expect(
    page.getByText('Birthday list')
  ).toBeVisible();
});</pre>
<p>Without the service worker, this<a id="_idIndexMarker500"/> test will fail because the second <strong class="source-inline">page.goto</strong> call will error. In the next section, we’ll see how this service worker can <span class="No-Break">be implemented.</span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor179"/>Implementing the service worker</h1>
<p>Service workers have an <a id="_idIndexMarker501"/>odd interface. For one thing, they need to rely on a variable named <strong class="source-inline">self</strong> that is provided by the browser context. Then they need to attach listeners to certain events, and they need to use the <strong class="source-inline">event.waitUntil</strong> function to ensure that the browser waits for its operations to finish before assuming the worker <span class="No-Break">is ready.</span></p>
<p>It turns out that it’s quite difficult to set up a value for <strong class="source-inline">self</strong> together with fake events within your Vitest tests. Not impossible, but difficult <span class="No-Break">and laborious.</span></p>
<p>Given this complexity, the trick to implementing a testable service worker is to move most of the functionality into another module: each event becomes a simple function call, and we can test that function call rather than <span class="No-Break">the event.</span></p>
<p>Then, we leave the service worker module untested. We still have the Playwright test giving us coverage, and this code isn’t likely to change once it’s complete, so it’s no big deal that this particular file is without <span class="No-Break">unit tests.</span></p>
<p>This example, shown in the following code block, is stored in the <strong class="source-inline">src/service-worker.js</strong> file. It pushes almost all the functionality into the <strong class="source-inline">addFilesToCache</strong>, <strong class="source-inline">deleteOldCaches</strong>, and <span class="No-Break"><strong class="source-inline">fetchWithCacheOnError</strong></span><span class="No-Break"> functions:</span></p>
<pre class="source-code">
import {
  build,
  files,
  version
} from '$service-worker';
import {
  addFilesToCache,
  deleteOldCaches,
  fetchWithCacheOnError
} from './lib/service-worker.js';
const cacheId = `cache-${version}`;
const appFiles = ['/birthdays'];
const assets = [...build, ...files, ...appFiles];
self.addEventListener('install', (event) =&gt; {
  event.waitUntil(addFilesToCache(cacheId, assets));
});
self.addEventListener('activate', (event) =&gt; {
  event.waitUntil(deleteOldCaches(cacheId));
  event.waitUntil(self.clients.claim());
});
self.addEventListener('fetch', (event) =&gt; {
  if (event.request.method !== 'GET') return;
  event.respondWith(
    fetchWithCacheOnError(cacheId, event.request)
  );
});</pre>
<p>Let’s take a look at the implementation of the<a id="_idIndexMarker502"/> three functions located in the <strong class="source-inline">src/lib/service-worker.js</strong> file. Each of these functions makes use of the Cache API, which we’ll test by setting <span class="No-Break">up spies.</span></p>
<p>Here’s <strong class="source-inline">addFilesToCache</strong>, which simply opens the relevant cache and inserts all the <span class="No-Break">given assets:</span></p>
<pre class="source-code">
export const addFilesToCache = async (
  cacheId,
  assets
) =&gt; {
  const cache = await caches.open(cacheId);
  await cache.addAll(assets);
};</pre>
<p>To begin testing that, first we need to define a default value for <strong class="source-inline">caches</strong>. In the sample repository, the following code lives in the test suite in <strong class="source-inline">src/lib/service-worker.test.js</strong>, but you could also place it in a Vitest setup file, which would make better sense if you had more than one test suite using the <span class="No-Break">Cache API:</span></p>
<pre class="source-code">
global.caches = {
  open: () =&gt; {},
  keys: () =&gt; {},
  delete: () =&gt; {}
};</pre>
<p>Now let’s start off with a <strong class="source-inline">describe</strong> block for the <strong class="source-inline">addFilesToCache</strong> function. All it takes is a call to <strong class="source-inline">vi.spyOn</strong> together with a hand-rolled cache object. Both the <strong class="source-inline">caches</strong> spy and the <strong class="source-inline">cache</strong> stub implement just <a id="_idIndexMarker503"/>enough for the purposes of testing the <strong class="source-inline">addFilesToCache</strong> function, nothing more, <span class="No-Break">nothing less:</span></p>
<pre class="source-code">
describe('addFilesToCache', () =&gt; {
  let cache;
  beforeEach(() =&gt; {
    cache = {
      addAll: vi.fn()
    };
    vi.spyOn(global.caches, 'open');
    caches.open.mockResolvedValue(cache);
  });
});</pre>
<p>Then the tests themselves <span class="No-Break">are straightforward:</span></p>
<pre class="source-code">
it('opens the cache with the given id', async () =&gt; {
  await addFilesToCache('cache-id', []);
  expect(global.caches.open).toBeCalledWith(
    'cache-id'
  );
});
it('adds all provided assets to the cache', async () =&gt; {
  const assets = [1, 2, 3];
  await addFilesToCache('cache-id', assets);
  expect(cache.addAll).toBeCalledWith(assets);
});</pre>
<p>Next, here’s the definition of <strong class="source-inline">deleteOldCaches</strong>, which is a bit <span class="No-Break">more complex:</span></p>
<pre class="source-code">
export const deleteOldCaches = async (cacheId) =&gt; {
  for (const key of await caches.keys()) {
    if (key !== cacheId) await caches.delete(key);
  }
};</pre>
<p>It turns out that our spy setup for this is <span class="No-Break">much simpler:</span></p>
<pre class="source-code">
describe('deleteOldCaches', () =&gt; {
  beforeEach(() =&gt; {
    vi.spyOn(global.caches, 'keys');
    vi.spyOn(global.caches, 'delete');
  });</pre>
<p>Then, the tests themselves<a id="_idIndexMarker504"/> are fairly straightforward. Notice how each of the tests is self-contained, with their own stub values for the <span class="No-Break"><strong class="source-inline">cache.keys</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
it('calls keys to retrieve all keys', async () =&gt; {
  caches.keys.mockResolvedValue([]);
  await deleteOldCaches('cache-id');
  expect(caches.keys).toBeCalled();
});
it('delete all caches with the provided keys', async () =&gt; {
  caches.keys.mockResolvedValue([
    'cache-one',
    'cache-two'
  ]);
  await deleteOldCaches('cache-id');
  expect(caches.delete).toBeCalledWith('cache-one');
  expect(caches.delete).toBeCalledWith('cache-two');
});
it('does not delete the cache with the provided id', async () =&gt; {
  caches.keys.mockResolvedValue(['cache-id']);
  await deleteOldCaches('cache-id');
  expect(caches.delete).not.toBeCalledWith(
    'cache-id'
  );
});</pre>
<p>Finally, we come to the <strong class="source-inline">fetchWithCacheOnError</strong> function, the most complex of the three. This<a id="_idIndexMarker505"/> involves the Cache API and the Fetch API, so our tests will need to deal with the <strong class="source-inline">request</strong> and <span class="No-Break"><strong class="source-inline">response</strong></span><span class="No-Break"> objects:</span></p>
<pre class="source-code">
export const fetchWithCacheOnError = async (
  cacheId,
  request
) =&gt; {
  const cache = await caches.open(cacheId);
  try {
    const response = await fetch(request);
    if (response.status === 200) {
      cache.put(request, response.clone());
    }
    return response;
  } catch {
    return cache.match(request);
  }
};</pre>
<p>Let’s take a look at the test <a id="_idIndexMarker506"/>setup. In addition to the <strong class="source-inline">caches.open</strong> spy and the <strong class="source-inline">cache</strong> stub; there’s also a <strong class="source-inline">successResponse</strong> object and a <strong class="source-inline">request</strong> object. These have dummy values: calling <strong class="source-inline">successResponse.clone()</strong> doesn’t give you back a response, and <strong class="source-inline">request</strong> isn’t a real request object. They’re just strings. But that’s all we need for <span class="No-Break">the tests:</span></p>
<pre class="source-code">
describe('fetchWithCacheOnError', () =&gt; {
  const successResponse = {
    status: 200,
    clone: () =&gt; 'cloned response'
  };
  const request = 'request';
  let cache;
  beforeEach(() =&gt; {
    cache = {
      put: vi.fn(),
      match: vi.fn()
    };
    vi.spyOn(global.caches, 'open');
    caches.open.mockResolvedValue(cache);
    vi.spyOn(global, 'fetch');
    fetch.mockResolvedValue(successResponse);
  });
});</pre>
<p>Now let’s look at the four happy path tests. These tests assume a working network connection and a valid HTTP<a id="_idIndexMarker507"/> response with a <strong class="source-inline">200</strong> <span class="No-Break">status code:</span></p>
<pre class="source-code">
it('opens the cache with the given id', async () =&gt; {
  await fetchWithCacheOnError('cache-id', request);
  expect(global.caches.open).toBeCalledWith(
    'cache-id'
  );
});
it('calls fetch with the request', async () =&gt; {
  await fetchWithCacheOnError('cache-id', request);
  expect(global.fetch).toBeCalledWith(request);
});
it('caches the response after cloning', async () =&gt; {
  await fetchWithCacheOnError('cache-id', request);
  expect(cache.put).toBeCalledWith(
    request,
    'cloned response'
  );
});
it('returns the response', async () =&gt; {
  const result = await fetchWithCacheOnError(
    'cache-id',
    request
  );
  expect(result).toEqual(successResponse);
});</pre>
<p>Then we have a test for an<a id="_idIndexMarker508"/> HTTP status code of anything other <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">200</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
it('does not cache the response if the status code is not 200', async () =&gt; {
  fetch.mockResolvedValue({ status: 404 });
  await fetchWithCacheOnError('cache-id', request);
  expect(cache.put).not.toBeCalled();
});</pre>
<p>Finally, we have a nested <a id="_idIndexMarker509"/>context for the network error. Note the use of <strong class="source-inline">mockRejectedValue</strong> instead of <strong class="source-inline">mockResolvedValue</strong>, which will throw an exception and cause the <strong class="source-inline">catch</strong> block to <span class="No-Break">be executed:</span></p>
<pre class="source-code">
describe('when fetch returns a network error', () =&gt; {
  let cachedResponse = 'cached-response';
  beforeEach(() =&gt; {
    fetch.mockRejectedValue({});
    cache.match.mockResolvedValue(cachedResponse);
  });
  it('retrieve the cached value', async () =&gt; {
    await fetchWithCacheOnError(
      'cache-id',
      request
    );
    expect(cache.match).toBeCalledWith(request);
  });
  it('returns the cached value', async () =&gt; {
    const result = await fetchWithCacheOnError(
      'cache-id',
      request
    );
    expect(result).toEqual(cachedResponse);
  });
});</pre>
<p>And that’s it: we have a<a id="_idIndexMarker510"/> fully-tested service worker using a combination of Playwright and <span class="No-Break">Vitest tests.</span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor180"/>Summary</h1>
<p>We've finished the book by looking at how even a complex browser feature, such as service workers, can be fully covered <span class="No-Break">by tests.</span></p>
<p>You’ve seen how Playwright tests should always test the benefit provided by the implementation – in this case, checking that the page is available offline – rather than testing an implementation detail, such as whether the service worker is is available <span class="No-Break">or not.</span></p>
<p>You’ve also seen how the Vitest tests can avoid checking the awkward service worker interface by pushing the majority of the implementation into plain <span class="No-Break">JavaScript functions.</span></p>
<p>And with that, our tour of test-driven Svelte comes to an end. It’s now over to you to put what you’ve learned <span class="No-Break">into practice.</span></p>
<p>As this book has shown, there are many avenues that your testing practice can follow. I encourage you to experiment and find what works for you. Seek out the practices that make your life easier and allow you to build higher-quality software at a <span class="No-Break">steady rate.</span></p>
<p>Thank you for choosing to spend your time with this book. If you have any feedback, good or bad, I’d love to hear it. You can contact me via the book’s GitHub repository or via my website at <a href="http://www.danielirvine.com"><span class="No-Break">www.danielirvine.com</span></a><span class="No-Break">.</span></p>
</div>
</div></body></html>