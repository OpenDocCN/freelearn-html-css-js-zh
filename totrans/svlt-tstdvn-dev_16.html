<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-176"><a id="_idTextAnchor175"/>16</h1>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/>Test-Driving Service Workers</h1>
<p>This chapter looks at <strong class="bold">service workers</strong>, which are bits of code that are installed on the browser and are invoked before any HTTP operation. That makes them useful for a certain set of features, such as enabling offline access to your app. The service worker implemented in this chapter provides exactly that feature.</p>
<p>It’s almost always a good idea to use off-the-shelf service workers rather than rolling your own. But it’s instructive to see how you might test your own service workers, hence the inclusion in this book.</p>
<p>The term <strong class="bold">testability</strong> is used to describe how straightforward it is to write tests for your application code. The way we structure our components and modules has a big impact on their testability. Service workers are a great example of taking something that, at first glance, is a highly complex thing to test and restructuring its implementation so that the tests become almost trivial.</p>
<p>This chapter covers the following key topics:</p>
<ul>
<li>Adding a Playwright test for offline access</li>
<li>Implementing the service worker</li>
</ul>
<p>By the end of the chapter, you’ll have learned how to test-drive service workers, plus you’ll have learned a new technique for making your application code more testable.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor177"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter16/Complete">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter16/Complete</a>.</p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor178"/>Adding a Playwright test for offline access</h1>
<p>Service workers tend to have <a id="_idIndexMarker498"/>a specific intent. In our case, the service worker enables the application to be used offline: loading the application causes it to be cached. If the network is no longer accessible, the next page load will be served from this cache, courtesy of the service worker.</p>
<p>Therefore, the Playwright test needs to test the application’s behavior when there’s no network connection.</p>
<p>At the time of writing, Playwright’s support for service worker events is experimental, so it needs to be enabled using the <code>PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS</code> flag in your <code>package.json</code> file:</p>
<pre class="source-code">
{
  "scripts": {
    ...,
  "test": "PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS=1
    playwright test",
  ...
  }
}</pre>
<p>Once that’s done, we’re ready to write our tests. We need two helper functions. The first, <code>waitForServiceWorkerActivation</code>, can be invoked by any Playwright test to ensure that subsequent commands don’t run until the service worker is actively caching new requests.</p>
<p>This code can be found in <code>tests/offline.test.js</code>. I’ve parked it right next to the single test that uses it: there’s not much point in moving it to another file because I don’t expect to reuse this function anywhere else in the test suite:</p>
<pre class="source-code">
const waitForServiceWorkerActivation = (page) =&gt;
  page.evaluate(async () =&gt; {
    const registration =
      await
        window.navigator.serviceWorker.getRegistration();
    if (registration.active?.state === 'activated')
      return;
    await new Promise((res) =&gt;
      window.navigator.serviceWorker.addEventListener(
        'controllerchange',
        res
      )
    );
  });</pre>
<p>Next, we need a <code>disableNetwork</code> function that<a id="_idIndexMarker499"/> will cause any network request to return a network error:</p>
<pre class="source-code">
const disableNetwork = (context) =&gt;
  context.route('<strong class="bold">', (route) =&gt; route.abort());</strong></pre>
<p>Then we’re ready to write the test:</p>
<pre class="source-code">
test('site is available offline', async ({
  page,
  context,
  browser
}) =&gt; {
  await page.goto('/birthdays');
  await waitForServiceWorkerActivation(page);
  await disableNetwork(context);
  await page.goto('/birthdays');
  await expect(
    page.getByText('Birthday list')
  ).toBeVisible();
});</pre>
<p>Without the service worker, this<a id="_idIndexMarker500"/> test will fail because the second <code>page.goto</code> call will error. In the next section, we’ll see how this service worker can be implemented.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor179"/>Implementing the service worker</h1>
<p>Service workers have an <a id="_idIndexMarker501"/>odd interface. For one thing, they need to rely on a variable named <code>self</code> that is provided by the browser context. Then they need to attach listeners to certain events, and they need to use the <code>event.waitUntil</code> function to ensure that the browser waits for its operations to finish before assuming the worker is ready.</p>
<p>It turns out that it’s quite difficult to set up a value for <code>self</code> together with fake events within your Vitest tests. Not impossible, but difficult and laborious.</p>
<p>Given this complexity, the trick to implementing a testable service worker is to move most of the functionality into another module: each event becomes a simple function call, and we can test that function call rather than the event.</p>
<p>Then, we leave the service worker module untested. We still have the Playwright test giving us coverage, and this code isn’t likely to change once it’s complete, so it’s no big deal that this particular file is without unit tests.</p>
<p>This example, shown in the following code block, is stored in the <code>src/service-worker.js</code> file. It pushes almost all the functionality into the <code>addFilesToCache</code>, <code>deleteOldCaches</code>, and <code>fetchWithCacheOnError</code> functions:</p>
<pre class="source-code">
import {
  build,
  files,
  version
} from '$service-worker';
import {
  addFilesToCache,
  deleteOldCaches,
  fetchWithCacheOnError
} from './lib/service-worker.js';
const cacheId = `cache-${version}`;
const appFiles = ['/birthdays'];
const assets = [...build, ...files, ...appFiles];
self.addEventListener('install', (event) =&gt; {
  event.waitUntil(addFilesToCache(cacheId, assets));
});
self.addEventListener('activate', (event) =&gt; {
  event.waitUntil(deleteOldCaches(cacheId));
  event.waitUntil(self.clients.claim());
});
self.addEventListener('fetch', (event) =&gt; {
  if (event.request.method !== 'GET') return;
  event.respondWith(
    fetchWithCacheOnError(cacheId, event.request)
  );
});</pre>
<p>Let’s take a look at the implementation of the<a id="_idIndexMarker502"/> three functions located in the <code>src/lib/service-worker.js</code> file. Each of these functions makes use of the Cache API, which we’ll test by setting up spies.</p>
<p>Here’s <code>addFilesToCache</code>, which simply opens the relevant cache and inserts all the given assets:</p>
<pre class="source-code">
export const addFilesToCache = async (
  cacheId,
  assets
) =&gt; {
  const cache = await caches.open(cacheId);
  await cache.addAll(assets);
};</pre>
<p>To begin testing that, first we need to define a default value for <code>caches</code>. In the sample repository, the following code lives in the test suite in <code>src/lib/service-worker.test.js</code>, but you could also place it in a Vitest setup file, which would make better sense if you had more than one test suite using the Cache API:</p>
<pre class="source-code">
global.caches = {
  open: () =&gt; {},
  keys: () =&gt; {},
  delete: () =&gt; {}
};</pre>
<p>Now let’s start off with a <code>describe</code> block for the <code>addFilesToCache</code> function. All it takes is a call to <code>vi.spyOn</code> together with a hand-rolled cache object. Both the <code>caches</code> spy and the <code>cache</code> stub implement just <a id="_idIndexMarker503"/>enough for the purposes of testing the <code>addFilesToCache</code> function, nothing more, nothing less:</p>
<pre class="source-code">
describe('addFilesToCache', () =&gt; {
  let cache;
  beforeEach(() =&gt; {
    cache = {
      addAll: vi.fn()
    };
    vi.spyOn(global.caches, 'open');
    caches.open.mockResolvedValue(cache);
  });
});</pre>
<p>Then the tests themselves are straightforward:</p>
<pre class="source-code">
it('opens the cache with the given id', async () =&gt; {
  await addFilesToCache('cache-id', []);
  expect(global.caches.open).toBeCalledWith(
    'cache-id'
  );
});
it('adds all provided assets to the cache', async () =&gt; {
  const assets = [1, 2, 3];
  await addFilesToCache('cache-id', assets);
  expect(cache.addAll).toBeCalledWith(assets);
});</pre>
<p>Next, here’s the definition of <code>deleteOldCaches</code>, which is a bit more complex:</p>
<pre class="source-code">
export const deleteOldCaches = async (cacheId) =&gt; {
  for (const key of await caches.keys()) {
    if (key !== cacheId) await caches.delete(key);
  }
};</pre>
<p>It turns out that our spy setup for this is much simpler:</p>
<pre class="source-code">
describe('deleteOldCaches', () =&gt; {
  beforeEach(() =&gt; {
    vi.spyOn(global.caches, 'keys');
    vi.spyOn(global.caches, 'delete');
  });</pre>
<p>Then, the tests themselves<a id="_idIndexMarker504"/> are fairly straightforward. Notice how each of the tests is self-contained, with their own stub values for the <code>cache.keys</code> function:</p>
<pre class="source-code">
it('calls keys to retrieve all keys', async () =&gt; {
  caches.keys.mockResolvedValue([]);
  await deleteOldCaches('cache-id');
  expect(caches.keys).toBeCalled();
});
it('delete all caches with the provided keys', async () =&gt; {
  caches.keys.mockResolvedValue([
    'cache-one',
    'cache-two'
  ]);
  await deleteOldCaches('cache-id');
  expect(caches.delete).toBeCalledWith('cache-one');
  expect(caches.delete).toBeCalledWith('cache-two');
});
it('does not delete the cache with the provided id', async () =&gt; {
  caches.keys.mockResolvedValue(['cache-id']);
  await deleteOldCaches('cache-id');
  expect(caches.delete).not.toBeCalledWith(
    'cache-id'
  );
});</pre>
<p>Finally, we come to the <code>fetchWithCacheOnError</code> function, the most complex of the three. This<a id="_idIndexMarker505"/> involves the Cache API and the Fetch API, so our tests will need to deal with the <code>request</code> and <code>response</code> objects:</p>
<pre class="source-code">
export const fetchWithCacheOnError = async (
  cacheId,
  request
) =&gt; {
  const cache = await caches.open(cacheId);
  try {
    const response = await fetch(request);
    if (response.status === 200) {
      cache.put(request, response.clone());
    }
    return response;
  } catch {
    return cache.match(request);
  }
};</pre>
<p>Let’s take a look at the test <a id="_idIndexMarker506"/>setup. In addition to the <code>caches.open</code> spy and the <code>cache</code> stub; there’s also a <code>successResponse</code> object and a <code>request</code> object. These have dummy values: calling <code>successResponse.clone()</code> doesn’t give you back a response, and <code>request</code> isn’t a real request object. They’re just strings. But that’s all we need for the tests:</p>
<pre class="source-code">
describe('fetchWithCacheOnError', () =&gt; {
  const successResponse = {
    status: 200,
    clone: () =&gt; 'cloned response'
  };
  const request = 'request';
  let cache;
  beforeEach(() =&gt; {
    cache = {
      put: vi.fn(),
      match: vi.fn()
    };
    vi.spyOn(global.caches, 'open');
    caches.open.mockResolvedValue(cache);
    vi.spyOn(global, 'fetch');
    fetch.mockResolvedValue(successResponse);
  });
});</pre>
<p>Now let’s look at the four happy path tests. These tests assume a working network connection and a valid HTTP<a id="_idIndexMarker507"/> response with a <code>200</code> status code:</p>
<pre class="source-code">
it('opens the cache with the given id', async () =&gt; {
  await fetchWithCacheOnError('cache-id', request);
  expect(global.caches.open).toBeCalledWith(
    'cache-id'
  );
});
it('calls fetch with the request', async () =&gt; {
  await fetchWithCacheOnError('cache-id', request);
  expect(global.fetch).toBeCalledWith(request);
});
it('caches the response after cloning', async () =&gt; {
  await fetchWithCacheOnError('cache-id', request);
  expect(cache.put).toBeCalledWith(
    request,
    'cloned response'
  );
});
it('returns the response', async () =&gt; {
  const result = await fetchWithCacheOnError(
    'cache-id',
    request
  );
  expect(result).toEqual(successResponse);
});</pre>
<p>Then we have a test for an<a id="_idIndexMarker508"/> HTTP status code of anything other than <code>200</code>:</p>
<pre class="source-code">
it('does not cache the response if the status code is not 200', async () =&gt; {
  fetch.mockResolvedValue({ status: 404 });
  await fetchWithCacheOnError('cache-id', request);
  expect(cache.put).not.toBeCalled();
});</pre>
<p>Finally, we have a nested <a id="_idIndexMarker509"/>context for the network error. Note the use of <code>mockRejectedValue</code> instead of <code>mockResolvedValue</code>, which will throw an exception and cause the <code>catch</code> block to be executed:</p>
<pre class="source-code">
describe('when fetch returns a network error', () =&gt; {
  let cachedResponse = 'cached-response';
  beforeEach(() =&gt; {
    fetch.mockRejectedValue({});
    cache.match.mockResolvedValue(cachedResponse);
  });
  it('retrieve the cached value', async () =&gt; {
    await fetchWithCacheOnError(
      'cache-id',
      request
    );
    expect(cache.match).toBeCalledWith(request);
  });
  it('returns the cached value', async () =&gt; {
    const result = await fetchWithCacheOnError(
      'cache-id',
      request
    );
    expect(result).toEqual(cachedResponse);
  });
});</pre>
<p>And that’s it: we have a<a id="_idIndexMarker510"/> fully-tested service worker using a combination of Playwright and Vitest tests.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor180"/>Summary</h1>
<p>We've finished the book by looking at how even a complex browser feature, such as service workers, can be fully covered by tests.</p>
<p>You’ve seen how Playwright tests should always test the benefit provided by the implementation – in this case, checking that the page is available offline – rather than testing an implementation detail, such as whether the service worker is is available or not.</p>
<p>You’ve also seen how the Vitest tests can avoid checking the awkward service worker interface by pushing the majority of the implementation into plain JavaScript functions.</p>
<p>And with that, our tour of test-driven Svelte comes to an end. It’s now over to you to put what you’ve learned into practice.</p>
<p>As this book has shown, there are many avenues that your testing practice can follow. I encourage you to experiment and find what works for you. Seek out the practices that make your life easier and allow you to build higher-quality software at a steady rate.</p>
<p>Thank you for choosing to spend your time with this book. If you have any feedback, good or bad, I’d love to hear it. You can contact me via the book’s GitHub repository or via my website at <a href="http://www.danielirvine.com">www.danielirvine.com</a>.</p>
</div>
</div></body></html>