<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 9. Lay Them Out"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/><span class="koboSpan" id="kobo.1.1">Chapter 9. Lay Them Out</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we will cover:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.3.1">Building a pie chart</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">Building a stacked area chart</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Building a treemap</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Building a tree</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Building an enclosure diagram</span></li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec64"/><span class="koboSpan" id="kobo.8.1">Introduction</span></h1></div></div></div><p><span class="koboSpan" id="kobo.9.1">The D3 layout is the focus of this chapter-a concept we have not encountered before. </span><span class="koboSpan" id="kobo.9.2">As expected, D3 layouts are algorithms that calculate and generate placement information for a group of elements. </span><span class="koboSpan" id="kobo.9.3">However, there are a few critical properties worth mentioning before we dive deeper into the specifics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.10.1">Layouts are data</span></strong></span><span class="koboSpan" id="kobo.11.1">: Layouts are purely data centric and data driven; they do not generate any graphical or display-related output directly. </span><span class="koboSpan" id="kobo.11.2">This allows them to be used and reused with SVG or canvas or even when there is no graphical output.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.12.1">Abstract and reusable</span></strong></span><span class="koboSpan" id="kobo.13.1">: Layouts are abstract, allowing a high degree of flexibility and reusability. </span><span class="koboSpan" id="kobo.13.2">You can combine and reuse layouts in various different interesting ways.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.14.1">Layouts are different</span></strong></span><span class="koboSpan" id="kobo.15.1">: Each layout is different. </span><span class="koboSpan" id="kobo.15.2">Every layout provided by D3 focuses on a very special graphical requirement and data structure.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.16.1">Stateless</span></strong></span><span class="koboSpan" id="kobo.17.1">: Layouts are mostly stateless by design to simplify their usage. </span><span class="koboSpan" id="kobo.17.2">What statelessness means here is that generally layouts are like functions; they can be called multiple times with different input data and generate different layout output.</span></li></ul></div><p><span class="koboSpan" id="kobo.18.1">Layouts are interesting and powerful concepts in D3. </span><span class="koboSpan" id="kobo.18.2">In this chapter, we will explore some of the most commonly used layouts in D3 by creating a fully functional visualization leveraging these layouts.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Building a pie chart"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec65"/><span class="koboSpan" id="kobo.1.1">Building a pie chart</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">A pie chart or a circle graph is a circular graph that contains multiple sectors used to illustrate numerical proportion. </span><span class="koboSpan" id="kobo.2.2">We will explore techniques, involving D3 </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">pie layout</span></strong></span><span class="koboSpan" id="kobo.4.1">, to build a fully functional pie chart in this recipe. </span><span class="koboSpan" id="kobo.4.2">In </span><a class="link" href="ch07.html" title="Chapter 7. Getting into Shape"><span class="koboSpan" id="kobo.5.1">Chapter 7</span></a><span class="koboSpan" id="kobo.6.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Getting into Shape</span></em></span><span class="koboSpan" id="kobo.8.1">, it became clear that using the D3 arc generator directly is a very tedious job. </span><span class="koboSpan" id="kobo.8.2">Each arc generator expects the following data format:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">var data = [ 
  {startAngle: 0, endAngle: 0.6283185307179586},  
  {startAngle: 0.6283185307179586, endAngle: 1.2566370614359172}, 
  ... 
  </span><span class="koboSpan" id="kobo.9.2">{startAngle: 5.654866776461628, endAngle: 6.283185307179586} 
]; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">This essentially requires the calculation of the angle partition for each slice out of an entire circle of </span><code class="literal"><span class="koboSpan" id="kobo.11.1">2 * Math.PI</span></code><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">Obviously, this process can be automated by an algorithm, which is exactly what </span><code class="literal"><span class="koboSpan" id="kobo.13.1">d3.pie</span></code><span class="koboSpan" id="kobo.14.1"> is designed for. </span><span class="koboSpan" id="kobo.14.2">In this recipe, we will see how a pie layout can be used to implement a fully functional pie chart.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec184"/><span class="koboSpan" id="kobo.15.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.16.1">Open your local copy of the following file in your web browser: </span><a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html"><span class="koboSpan" id="kobo.17.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html
</span></a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec185"/><span class="koboSpan" id="kobo.18.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.19.1">A pie chart or a circle graph is a circular diagram divided into sectors (slices). </span><span class="koboSpan" id="kobo.19.2">Pie charts are popular in many fields and widely used to demonstrate relationships between different entities, though not without criticism. </span><span class="koboSpan" id="kobo.19.3">Let's take a look at how a pie chart is implemented using </span><code class="literal"><span class="koboSpan" id="kobo.20.1">d3.layout</span></code><span class="koboSpan" id="kobo.21.1"> first:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">&lt;script type="text/javascript"&gt; 
    function pieChart() { 
        var _chart = {}; 
 
        var _width = 500, _height = 500, 
                _data = [], 
                _colors = d3.scaleOrdinal(d3.schemeCategory10), 
                _svg, 
                _bodyG, 
                _pieG, 
                _radius = 200, 
                _innerRadius = 100, 
                _duration = 1000; 
 
        _chart.render = function () { 
            if (!_svg) { 
                _svg = d3.select("body").append("svg") 
                        .attr("height", _height) 
                        .attr("width", _width); 
            } 
 
            renderBody(_svg); 
        }; 
 
        function renderBody(svg) { 
            if (!_bodyG) 
                _bodyG = svg.append("g") 
                        .attr("class", "body"); 
 
            renderPie(); 
        } 
 
        function renderPie() { 
            var pie = d3.pie() // &lt;-A 
                    .sort(function (d) { 
                        return d.id; 
                    }) 
                    .value(function (d) { 
                        return d.value; 
                    }); 
 
            var arc = d3.arc() 
                    .outerRadius(_radius) 
                    .innerRadius(_innerRadius); 
 
            if (!_pieG) 
                _pieG = _bodyG.append("g") 
                        .attr("class", "pie") 
                        .attr("transform", "translate("  
                            + _radius  
                            + ","  
                            + _radius + ")"); 
 
            renderSlices(pie, arc); 
 
            renderLabels(pie, arc); 
        } 
 
  function renderSlices(pie, arc) { 
  // explained in detail in the'how it works...' </span><span class="koboSpan" id="kobo.22.2">section 
  ... 
  </span><span class="koboSpan" id="kobo.22.3">} 
 
  function renderLabels(pie, arc) { 
  // explained in detail in the 'how it works...' </span><span class="koboSpan" id="kobo.22.4">section 
  ... 
  </span><span class="koboSpan" id="kobo.22.5">} 
  ... 
  </span><span class="koboSpan" id="kobo.22.6">return _chart; 
} 
... 
</span><span class="koboSpan" id="kobo.22.7">&lt;/script&gt; 
</span></pre><p><span class="koboSpan" id="kobo.23.1">This recipe generates the following pie chart:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.24.1"><img src="graphics/image_09_001.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.25.1">Pie chart</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec186"/><span class="koboSpan" id="kobo.26.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.27.1">This recipe is built over what you have learned in the </span><a class="link" href="ch07.html" title="Chapter 7. Getting into Shape"><span class="koboSpan" id="kobo.28.1">Chapter 7</span></a><span class="koboSpan" id="kobo.29.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.30.1">Getting into Shape</span></em></span><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">One major difference is that you rely on </span><code class="literal"><span class="koboSpan" id="kobo.32.1">d3.pie</span></code><span class="koboSpan" id="kobo.33.1"> to transform the raw data into arcs data for us. </span><span class="koboSpan" id="kobo.33.2">The pie layout was created on line A with both sort and value accessors specified:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.34.1">var pie = d3.pie() // &lt;-A 
              .sort(function (d) { 
                  return d.id; 
              }) 
              .value(function (d) { 
                  return d.value; 
              }); 
</span></pre><p><span class="koboSpan" id="kobo.35.1">The </span><code class="literal"><span class="koboSpan" id="kobo.36.1">sort</span></code><span class="koboSpan" id="kobo.37.1"> function tells the pie layout to sort slices by its ID field, so that we can maintain stable order among slices. </span><span class="koboSpan" id="kobo.37.2">Without the sorting, by default, the pie layout will order the slices by value, resulting in the swapping of slices whenever we update the pie chart. </span><span class="koboSpan" id="kobo.37.3">The </span><code class="literal"><span class="koboSpan" id="kobo.38.1">value</span></code><span class="koboSpan" id="kobo.39.1"> function is used to provide value accessor, which, in our case, returns the </span><code class="literal"><span class="koboSpan" id="kobo.40.1">value</span></code><span class="koboSpan" id="kobo.41.1"> field. </span><span class="koboSpan" id="kobo.41.2">When rendering slices, now with the pie layout, we directly set the output of the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">pie</span></code><span class="koboSpan" id="kobo.43.1"> function call as data (remember, layouts are data) to generate the arc </span><code class="literal"><span class="koboSpan" id="kobo.44.1">svg:path</span></code><span class="koboSpan" id="kobo.45.1"> elements (refer to line </span><code class="literal"><span class="koboSpan" id="kobo.46.1">B</span></code><span class="koboSpan" id="kobo.47.1">):</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.48.1">function renderSlices(pie, arc) { 
    var slices = _pieG.selectAll("path.arc") 
            .data(pie(_data)); // &lt;-B 
 
    slices.enter() 
            .append("path") 
        .merge(slices) 
            .attr("class", "arc") 
            .attr("fill", function (d, i) { 
                return _colors(i); 
            }) 
        .transition() 
            .duration(_duration) 
            .attrTween("d", function (d) { 
                var currentArc = this.__current__; // &lt;-C 
 
                if (!currentArc) 
                    currentArc = {startAngle: 0,  
                                    endAngle: 0}; 
 
                var interpolate = d3.interpolate( 
                                    currentArc, d); 
                                     
                this.__current__ = interpolate(1);//&lt;-D 
                 
                return function (t) { 
                    return arc(interpolate(t)); 
                }; 
            }); 
} 
</span></pre><p><span class="koboSpan" id="kobo.49.1">At this point, you might be wondering what kind of data </span><code class="literal"><span class="koboSpan" id="kobo.50.1">d3.pie</span></code><span class="koboSpan" id="kobo.51.1"> generates. </span><span class="koboSpan" id="kobo.51.2">Here is what the output data looks like:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.52.1"><img src="graphics/image_09_002.jpg" alt="How it works..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.53.1">Pie output data</span></p><p><span class="koboSpan" id="kobo.54.1">As we can see clearly, this is exactly what the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">d3.arc</span></code><span class="koboSpan" id="kobo.56.1"> generator expects. </span><span class="koboSpan" id="kobo.56.2">This is why we can use this data directly with </span><code class="literal"><span class="koboSpan" id="kobo.57.1">d3.arc</span></code><span class="koboSpan" id="kobo.58.1"> without dealing with any detailed calculation for angles and partitions. </span><span class="koboSpan" id="kobo.58.2">The rest of the rendering logic is pretty much the same as what you have learned in </span><a class="link" href="ch07.html" title="Chapter 7. Getting into Shape"><span class="koboSpan" id="kobo.59.1">Chapter 7</span></a><span class="koboSpan" id="kobo.60.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.61.1">Getting into Shape</span></em></span><span class="koboSpan" id="kobo.62.1">, with one exception that can be seen on line C. </span><span class="koboSpan" id="kobo.62.2">On line C, we retrieve the current arc value from the element so the transition can start from the current angle instead of zero. </span><span class="koboSpan" id="kobo.62.3">Then, on line D, we reset the current arc value to the latest one; so, the next time when we update the pie chart data, we can repeat the stateful transition.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip75"/><span class="koboSpan" id="kobo.63.1">Tip</span></h3><p>
<span class="strong"><strong><span class="koboSpan" id="kobo.64.1">Technique - stateful visualization
</span></strong></span><span class="koboSpan" id="kobo.65.1">Technique of value injection on a DOM element is a common approach to introduce statefulness to your visualization. </span><span class="koboSpan" id="kobo.65.2">In other words, if you need your visualizations to remember what their previous states are, you can save them in DOM elements, as demonstrated on line </span><code class="literal"><span class="koboSpan" id="kobo.66.1">C</span></code><span class="koboSpan" id="kobo.67.1"> in this recipe.</span></p></div></div><p><span class="koboSpan" id="kobo.68.1">Finally, we also need to render labels on each slice so our user can understand what each slice is representing. </span><span class="koboSpan" id="kobo.68.2">This is done by the </span><code class="literal"><span class="koboSpan" id="kobo.69.1">renderLabels</span></code><span class="koboSpan" id="kobo.70.1"> function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.71.1">function renderLabels(pie, arc) { 
            var labels = _pieG.selectAll("text.label") 
                    .data(pie(_data)); // &lt;-E 
 
            labels.enter() 
                    .append("text") 
                .merge(labels) 
                    .attr("class", "label") 
                .transition() 
                    .duration(_duration) 
                    .attr("transform", function (d) { 
                        return "translate("  
                            + arc.centroid(d) + ")"; // &lt;-F 
                    }) 
                    .attr("dy", ".35em") 
                    .attr("text-anchor", "middle") 
                    .text(function (d) { 
                        return d.data.id; 
                    });         
} 
</span></pre><p><span class="koboSpan" id="kobo.72.1">Once again, we use the output of the </span><code class="literal"><span class="koboSpan" id="kobo.73.1">pie</span></code><span class="koboSpan" id="kobo.74.1"> function call as data to generate the </span><code class="literal"><span class="koboSpan" id="kobo.75.1">svg:text</span></code><span class="koboSpan" id="kobo.76.1"> elements. </span><span class="koboSpan" id="kobo.76.2">The placement of the labels is calculated using </span><code class="literal"><span class="koboSpan" id="kobo.77.1">arc.centroid</span></code><span class="koboSpan" id="kobo.78.1"> (refer to line </span><code class="literal"><span class="koboSpan" id="kobo.79.1">F</span></code><span class="koboSpan" id="kobo.80.1">). </span><span class="koboSpan" id="kobo.80.2">Additionally, the label placement is animated through the transition so they can be moved with arcs in unison.</span></p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec187"/><span class="koboSpan" id="kobo.81.1">There's more...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.82.1">Pie charts are very widely used in many different domains. </span><span class="koboSpan" id="kobo.82.2">However, they are also widely criticized due to the fact that they are difficult for the human eyes to compare different sections of a given pie chart as well as for their low information density. </span><span class="koboSpan" id="kobo.82.3">Therefore, it is highly recommended to limit the number of sections to less than three, with two considered to be ideal. </span><span class="koboSpan" id="kobo.82.4">Otherwise, you can always use a bar chart or a small table to replace a pie chart for better precision and communicative power.</span></p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec188"/><span class="koboSpan" id="kobo.83.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.84.1">The </span><span class="emphasis"><em><span class="koboSpan" id="kobo.85.1">Using arc generators</span></em></span><span class="koboSpan" id="kobo.86.1"> recipe in </span><a class="link" href="ch07.html" title="Chapter 7. Getting into Shape"><span class="koboSpan" id="kobo.87.1">Chapter 7</span></a><span class="koboSpan" id="kobo.88.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.89.1">Getting into Shape</span></em></span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.90.1">The </span><span class="emphasis"><em><span class="koboSpan" id="kobo.91.1">Implementing arc transition</span></em></span><span class="koboSpan" id="kobo.92.1"> recipe in </span><a class="link" href="ch07.html" title="Chapter 7. Getting into Shape"><span class="koboSpan" id="kobo.93.1">Chapter 7</span></a><span class="koboSpan" id="kobo.94.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.95.1">Getting into Shape</span></em></span></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Building a stacked area chart"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec66"/><span class="koboSpan" id="kobo.1.1">Building a stacked area chart</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">Creating an area chart</span></em></span><span class="koboSpan" id="kobo.4.1"> recipe in </span><a class="link" href="ch08.html" title="Chapter 8. Chart Them Up"><span class="koboSpan" id="kobo.5.1">Chapter 8</span></a><span class="koboSpan" id="kobo.6.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Chart Them Up</span></em></span><span class="koboSpan" id="kobo.8.1">, we explored how a basic layered area chart can be implemented using D3. </span><span class="koboSpan" id="kobo.8.2">In this recipe, we will build over what we covered in the area chart recipe to implement a stacked area chart. </span><span class="koboSpan" id="kobo.8.3">Stacked area chart is a variation of the standard area chart in which different areas are stacked on top of each other giving your audience the ability to compare not only different data series individually but also their relationship to the total in proportion.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec189"/><span class="koboSpan" id="kobo.9.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.10.1">Open your local copy of the following file in your web browser: </span><a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html"><span class="koboSpan" id="kobo.11.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html
</span></a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec190"/><span class="koboSpan" id="kobo.12.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.13.1">This recipe is built over what we had implemented in </span><a class="link" href="ch08.html" title="Chapter 8. Chart Them Up"><span class="koboSpan" id="kobo.14.1">Chapter 8</span></a><span class="koboSpan" id="kobo.15.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">Chart Them Up</span></em></span><span class="koboSpan" id="kobo.17.1">; therefore, in the following code example, only the parts that are particularly relevant to the stacked area chart are included:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.18.1">&lt;script type="text/javascript"&gt; 
function stackedAreaChart() { 
    var _chart = {}; 
 
    var _width = 900, _height = 450, 
            _margins = {top: 30, left: 30, right: 30, bottom: 30}, 
            _x, _y, 
            _data = [], 
            _colors = d3.scaleOrdinal(d3.schemeCategory10), 
            _svg, 
            _bodyG, 
            _line; 
 
    _chart.render = function () { 
        if (!_svg) { 
            _svg = d3.select("body").append("svg") 
                    .attr("height", _height) 
                    .attr("width", _width); 
 
            renderAxes(_svg); 
 
            defineBodyClip(_svg); 
        } 
 
    renderBody(_svg); 
}; 
... 
</span><span class="koboSpan" id="kobo.18.2">function renderBody(svg) { 
   if (!_bodyG) 
       _bodyG = svg.append("g") 
                    .attr("class", "body") 
                    .attr("transform", "translate(" 
                            + xStart() + "," 
                            + yEnd() + ")") 
                    .attr("clip-path", "url(#body-clip)"); 
 
    var stack = d3.stack() // &lt;-A 
                .keys(['value1', 'value2', 'value3']) 
                .offset(d3.stackOffsetNone); 
 
    var series = stack(_data); //&lt;-B 
 
    renderLines(series); 
 
    renderAreas(series); 
} 
 
function renderLines(stackedData) { 
  // explained in details in the'how it works...' </span><span class="koboSpan" id="kobo.18.3">section 
... 
</span><span class="koboSpan" id="kobo.18.4">} 
 
function renderAreas(stackedData) { 
  // explained in details in the 'how it works...' </span><span class="koboSpan" id="kobo.18.5">section 
... 
</span><span class="koboSpan" id="kobo.18.6">} 
... 
</span></pre><p><span class="koboSpan" id="kobo.19.1">This recipe generates the following visualization:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.20.1"><img src="graphics/image_09_003.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.21.1">Stacked area chart</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec191"/><span class="koboSpan" id="kobo.22.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.23.1">The main difference between this recipe and the standard area chart is the stacking, which is also the focus of this recipe. </span><span class="koboSpan" id="kobo.23.2">The stacking effect as illustrated in this recipe was achieved through </span><code class="literal"><span class="koboSpan" id="kobo.24.1">d3.stack</span></code><span class="koboSpan" id="kobo.25.1"> created on line </span><code class="literal"><span class="koboSpan" id="kobo.26.1">A</span></code><span class="koboSpan" id="kobo.27.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">var stack = dn3.stack() // &lt;-A 
                .keys(['value1', 'value2', 'value3']) // &lt;-B 
                .offset(d3.stackOffsetNone); 
... 
</span><span class="koboSpan" id="kobo.28.2">function update() { 
    data = d3.range(numberOfDataPoint).map(function (i) { 
        return {value1: randomData(),  
                value2: randomData(),  
                value3: randomData()}; 
    }); 
 
    chart.data(data).render(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.29.1">As we can see in this code snippet, the data points we generated in the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">update</span></code><span class="koboSpan" id="kobo.31.1"> function has three different series, </span><code class="literal"><span class="koboSpan" id="kobo.32.1">value1</span></code><span class="koboSpan" id="kobo.33.1">, </span><code class="literal"><span class="koboSpan" id="kobo.34.1">value2</span></code><span class="koboSpan" id="kobo.35.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.36.1">value3</span></code><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">This is why we need to specify their names to the </span><code class="literal"><span class="koboSpan" id="kobo.38.1">d3.stack</span></code><span class="koboSpan" id="kobo.39.1"> on line </span><code class="literal"><span class="koboSpan" id="kobo.40.1">B</span></code><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">The only other customization we have done on stack layout is setting its </span><code class="literal"><span class="koboSpan" id="kobo.42.1">offset</span></code><span class="koboSpan" id="kobo.43.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.44.1">d3.stackOffsetNone</span></code><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">D3 stack layout supports a few different offset modes, which determine the stacking algorithm to be used; this is something that we will explore in this and the next recipe. </span><span class="koboSpan" id="kobo.45.3">In this case, we use the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">zero</span></code><span class="koboSpan" id="kobo.47.1"> offset stacking, which generates a zero base-lined stacking algorithm, which is exactly what we want in this recipe. </span><span class="koboSpan" id="kobo.47.2">Next, on line </span><code class="literal"><span class="koboSpan" id="kobo.48.1">B</span></code><span class="koboSpan" id="kobo.49.1">, we invoked the stack layout on the given data array, which generates the following layout data:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.50.1"><img src="graphics/image_09_004.jpg" alt="How it works..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.51.1">Stacked data</span></p><p><span class="koboSpan" id="kobo.52.1">As shown, the stack layout automatically calculates a </span><code class="literal"><span class="koboSpan" id="kobo.53.1">y</span></code><span class="koboSpan" id="kobo.54.1"> baseline </span><code class="literal"><span class="koboSpan" id="kobo.55.1">0</span></code><span class="koboSpan" id="kobo.56.1"> for each data in our three different data series as well as the </span><code class="literal"><span class="koboSpan" id="kobo.57.1">y</span></code><span class="koboSpan" id="kobo.58.1"> topline </span><code class="literal"><span class="koboSpan" id="kobo.59.1">1</span></code><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">Now, with this stacked dataset in hand, we can easily generate stacked lines:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.61.1">function renderLines(series) { 
        _line = d3.line() 
                .x(function (d, i) { 
                    return _x(i); //&lt;-C 
                }) 
                .y(function (d) { 
                    return _y(d[1]); //&lt;-D 
                }); 
 
        var linePaths = _bodyG.selectAll("path.line") 
                .data(series); 
 
        linePaths.enter() 
                .append("path") 
            .merge(linePaths) 
                .style("stroke", function (d, i) { 
                    return _colors(i); 
                }) 
                .attr("class", "line") 
            .transition() 
                .attr("d", function (d) { 
                    return _line(d); 
                }); 
} 
</span></pre><p><span class="koboSpan" id="kobo.62.1">A </span><code class="literal"><span class="koboSpan" id="kobo.63.1">d3.line</span></code><span class="koboSpan" id="kobo.64.1"> generator function was created with its index count value </span><code class="literal"><span class="koboSpan" id="kobo.65.1">i</span></code><span class="koboSpan" id="kobo.66.1"> directly mapped to the </span><code class="literal"><span class="koboSpan" id="kobo.67.1">x</span></code><span class="koboSpan" id="kobo.68.1"> (refer to line </span><code class="literal"><span class="koboSpan" id="kobo.69.1">C</span></code><span class="koboSpan" id="kobo.70.1">) and its </span><code class="literal"><span class="koboSpan" id="kobo.71.1">y</span></code><span class="koboSpan" id="kobo.72.1"> topline value mapped to </span><code class="literal"><span class="koboSpan" id="kobo.73.1">d[1] </span></code><span class="koboSpan" id="kobo.74.1">(refer to line </span><code class="literal"><span class="koboSpan" id="kobo.75.1">D</span></code><span class="koboSpan" id="kobo.76.1">). </span><span class="koboSpan" id="kobo.76.2">This is all you need to do for line stacking. </span><span class="koboSpan" id="kobo.76.3">The rest of the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">renderLines</span></code><span class="koboSpan" id="kobo.78.1"> function is essentially the same as in the basic area chart implementation. </span><span class="koboSpan" id="kobo.78.2">The area stacking logic is slightly different:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.79.1">function renderAreas(series) { 
        var area = d3.area() 
                .x(function (d, i) { 
                    return _x(i); //&lt;-E 
                }) 
                .y0(function(d){return _y(d[0]);}) //&lt;-F 
                .y1(function (d) { 
                    return _y(d[1]); //&lt;-G 
                }); 
 
        var areaPaths = _bodyG.selectAll("path.area") 
                .data(series); 
 
        areaPaths.enter() 
                .append("path") 
            .merge(areaPaths) 
                .style("fill", function (d, i) { 
                    return _colors(i); 
                }) 
                .attr("class", "area") 
            .transition() 
                .attr("d", function (d) { 
                    return area(d); 
                }); 
} 
</span></pre><p><span class="koboSpan" id="kobo.80.1">Similar to the line rendering logic when rendering area, the only place we need to change is in the </span><code class="literal"><span class="koboSpan" id="kobo.81.1">d3.area</span></code><span class="koboSpan" id="kobo.82.1"> generator setting. </span><span class="koboSpan" id="kobo.82.2">For areas, the </span><code class="literal"><span class="koboSpan" id="kobo.83.1">x</span></code><span class="koboSpan" id="kobo.84.1"> value is still directly mapped to the index count </span><code class="literal"><span class="koboSpan" id="kobo.85.1">i</span></code><span class="koboSpan" id="kobo.86.1"> (line E) with its </span><code class="literal"><span class="koboSpan" id="kobo.87.1">y0</span></code><span class="koboSpan" id="kobo.88.1"> directly mapped with </span><code class="literal"><span class="koboSpan" id="kobo.89.1">y</span></code><span class="koboSpan" id="kobo.90.1"> baseline </span><code class="literal"><span class="koboSpan" id="kobo.91.1">d[0]</span></code><span class="koboSpan" id="kobo.92.1"> and finally again </span><code class="literal"><span class="koboSpan" id="kobo.93.1">y1</span></code><span class="koboSpan" id="kobo.94.1"> is the </span><code class="literal"><span class="koboSpan" id="kobo.95.1">y</span></code><span class="koboSpan" id="kobo.96.1"> topline </span><code class="literal"><span class="koboSpan" id="kobo.97.1">d[1]</span></code><span class="koboSpan" id="kobo.98.1"> (line G).</span></p><p><span class="koboSpan" id="kobo.99.1">As we saw so far, the D3 stack layout is nicely designed to be compatible with different D3 SVG generator functions. </span><span class="koboSpan" id="kobo.99.2">Hence, using it to generate the stacking effect is quite straightforward and convenient.</span></p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec192"/><span class="koboSpan" id="kobo.100.1">There's more...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.101.1">Let's take a look at a couple of variations of the stacked area chart.</span></p><div class="section" title="Expanded area chart"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec17"/><span class="koboSpan" id="kobo.102.1">Expanded area chart</span></h3></div></div></div><p><span class="koboSpan" id="kobo.103.1">We have mentioned that </span><code class="literal"><span class="koboSpan" id="kobo.104.1">d3.stack</span></code><span class="koboSpan" id="kobo.105.1"> supports different offset modes. </span><span class="koboSpan" id="kobo.105.2">In addition to the </span><code class="literal"><span class="koboSpan" id="kobo.106.1">d3.stackOffsetNone </span></code><span class="koboSpan" id="kobo.107.1">offset we saw so far, another very useful offset mode for the area chart is called </span><code class="literal"><span class="koboSpan" id="kobo.108.1">d3.stackOffsetExpand</span></code><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">With the </span><code class="literal"><span class="koboSpan" id="kobo.110.1">d3.stackOffsetExpand </span></code><span class="koboSpan" id="kobo.111.1">mode, stack layout will normalize different layers to fill the range of </span><code class="literal"><span class="koboSpan" id="kobo.112.1">[0, 1]</span></code><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">If we change the offset mode in this recipe and the y axis domain to </span><code class="literal"><span class="koboSpan" id="kobo.114.1">[0, 1]</span></code><span class="koboSpan" id="kobo.115.1">, we will get the following expanded (normalized) area chart; this visualization is very useful when your audience care more about the relative proportion of each data series more than their absolution values:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.116.1"><img src="graphics/image_09_005.jpg" alt="Expanded area chart"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.117.1">Expanded area chart</span></p><p><span class="koboSpan" id="kobo.118.1">For the complete companion code example, visit </span><a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html"><span class="koboSpan" id="kobo.119.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html
</span></a><span class="koboSpan" id="kobo.120.1">.</span></p></div><div class="section" title="Streamgraph"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec18"/><span class="koboSpan" id="kobo.121.1">Streamgraph</span></h3></div></div></div><p><span class="koboSpan" id="kobo.122.1">Another interesting variation of a stacked area chart is called streamgraph. </span><span class="koboSpan" id="kobo.122.2">Streamgraph is a stacked area chart displayed around a central axis, creating a flowing and organic shape. </span><span class="koboSpan" id="kobo.122.3">Streamgraph was initially developed by Lee Byron and popularized by its use in a New York Times article on movie box office revenues in 2008. </span><span class="koboSpan" id="kobo.122.4">The D3 stack layout has built-in support for this kind of stacking algorithm, and therefore, changing a zero-based stacked area chart to streamgraph is simple. </span><span class="koboSpan" id="kobo.122.5">The key difference is that streamgraph uses </span><code class="literal"><span class="koboSpan" id="kobo.123.1">d3.stackOffsetWiggle</span></code><span class="koboSpan" id="kobo.124.1"> as its layout offset mode. </span><span class="koboSpan" id="kobo.124.2">Stream graph is a useful visualization when you want to highlight the change of data or its trend over time rather than its absolute values.</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.125.1"><img src="graphics/image_09_006.jpg" alt="Streamgraph"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.126.1">Streamgraph</span></p><p><span class="koboSpan" id="kobo.127.1">For the complete companion code example, please visit </span><a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html"><span class="koboSpan" id="kobo.128.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html
</span></a><span class="koboSpan" id="kobo.129.1">.</span></p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec193"/><span class="koboSpan" id="kobo.130.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.131.1">d3.stack</span></code><span class="koboSpan" id="kobo.132.1"> function offers several additional functions to customize its behavior; for more information on stack layout, visit </span><a class="ulink" href="https://github.com/d3/d3/blob/master/API.md#stacks"><span class="koboSpan" id="kobo.133.1">https://github.com/d3/d3/blob/master/API.md#stacks
</span></a></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.134.1">The Creating an area chart recipe in </span><a class="link" href="ch08.html" title="Chapter 8. Chart Them Up"><span class="koboSpan" id="kobo.135.1">Chapter 8</span></a><span class="koboSpan" id="kobo.136.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.137.1">Chart Them Up</span></em></span></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Building a treemap"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec67"/><span class="koboSpan" id="kobo.1.1">Building a treemap</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Treemaps were introduced by Ben Shneiderman in 1991. </span><span class="koboSpan" id="kobo.2.2">A treemap displays hierarchical tree-structured data as a set of recursively subdivided rectangles. </span><span class="koboSpan" id="kobo.2.3">In other words, it displays each branch of the tree as a large rectangle, which is then tiled with smaller rectangles representing subbranches. </span><span class="koboSpan" id="kobo.2.4">This process continuously repeats itself till it reaches the leaves of the tree.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note76"/><span class="koboSpan" id="kobo.3.1">Note</span></h3><p><span class="koboSpan" id="kobo.4.1">For more information on treemaps, refer to treemaps for space-constrained visualization of hierarchies by Ben Shneiderman at </span><a class="ulink" href="http://www.cs.umd.edu/hcil/treemap-history"><span class="koboSpan" id="kobo.5.1">http://www.cs.umd.edu/hcil/treemap-history
</span></a><span class="koboSpan" id="kobo.6.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.7.1">Before we dive into the code example, let's first define what we mean by </span><span class="strong"><strong><span class="koboSpan" id="kobo.8.1">hierarchical data</span></strong></span><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">So far, we discussed many types of visualizations capable of representing flat data structure usually stored in one or two dimensional arrays. </span><span class="koboSpan" id="kobo.9.3">In the rest of this chapter, we will switch our focus onto another common type of data structure in data visualization-the hierarchical data structure. </span><span class="koboSpan" id="kobo.9.4">Instead of using arrays, as in the case of flat data structures, hierarchical data is usually structured as a rooted tree. </span><span class="koboSpan" id="kobo.9.5">The following JSON file shows a typical hierarchical data you would expect in a data visualization project:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">{ 
  "name": "flare", 
  "children": [ 
  { 
    "name": "analytics", 
    "children": [ 
    { 
      "name": "cluster", 
      "children": [ 
        {"name": "AgglomerativeCluster", "size": 3938}, 
        {"name": "CommunityStructure", "size": 3812}, 
        {"name": "MergeEdge", "size": 743} 
      ] 
    }, 
    { 
      "name": "graph", 
      "children": [ 
        {"name": "BetweennessCentrality", "size": 3534}, 
        {"name": "LinkDistance", "size": 5731} 
      ] 
    }, 
    { 
      "name": "optimization", 
      "children": [ 
        {"name": "AspectRatioBanker", "size": 7074} 
      ] 
    } 
  ]   
  ] 
} 
</span></pre><p><span class="koboSpan" id="kobo.11.1">This is a shortened version of a popular hierarchical dataset used in the D3 community for demonstration purposes. </span><span class="koboSpan" id="kobo.11.2">This data is extracted from a popular flash-based data visualization library-</span><code class="literal"><span class="koboSpan" id="kobo.12.1">flare</span></code><span class="koboSpan" id="kobo.13.1">, created by the UC Berkeley Visualization Lab. </span><span class="koboSpan" id="kobo.13.2">It shows the size and hierarchical relationship among different packages within the library.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note77"/><span class="koboSpan" id="kobo.14.1">Note</span></h3><p><span class="koboSpan" id="kobo.15.1">Refer to the official Flare site for more information on the project at </span><a class="ulink" href="http://flare.prefuse.org/"><span class="koboSpan" id="kobo.16.1">http://flare.prefuse.org/
</span></a><span class="koboSpan" id="kobo.17.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.18.1">As we can see quite easily, this particular JSON feed is structured as a typical singly-linked rooted tree with each node having a single parent and multiple child nodes stored in the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">children</span></code><span class="koboSpan" id="kobo.20.1"> array. </span><span class="koboSpan" id="kobo.20.2">This is a pretty common way to organize your hierarchical data in order to be consumed by the D3 hierarchical layouts. </span><span class="koboSpan" id="kobo.20.3">For the rest of this chapter, we will use this particular dataset for exploring different hierarchical data visualization techniques D3 has to offer.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec194"/><span class="koboSpan" id="kobo.21.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.22.1">Open your local copy of the following file in your web browser: </span><a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html"><span class="koboSpan" id="kobo.23.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html
</span></a><span class="koboSpan" id="kobo.24.1">.
</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec195"/><span class="koboSpan" id="kobo.25.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.26.1">Now let's take a look at how we can use the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">d3.treemap</span></code><span class="koboSpan" id="kobo.28.1"> function to visually represent this kind of hierarchical data:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.29.1">function treemapChart() { 
        var _chart = {}; 
 
        var _width = 1600, _height = 800, 
                _colors = d3.scaleOrdinal(d3.schemeCategory20c), 
                _svg, 
                _nodes, 
                _valueAccessor, 
                _treemap, 
                _bodyG; 
 
        _chart.render = function () { 
            if (!_svg) { 
                _svg = d3.select("body").append("svg") 
                        .attr("height", _height) 
                        .attr("width", _width); 
            } 
 
            renderBody(_svg); 
        }; 
 
        function renderBody(svg) { 
            // explained in the 'how it works...' </span><span class="koboSpan" id="kobo.29.2">section 
            ...  
 
            </span><span class="koboSpan" id="kobo.29.3">renderCells(cells); 
        } 
 
        function renderCells(cells){ 
            // explained in the 'how it works...' </span><span class="koboSpan" id="kobo.29.4">section 
            ... 
        </span><span class="koboSpan" id="kobo.29.5">} 
 
        // accessors omitted 
        ... 
 
        </span><span class="koboSpan" id="kobo.29.6">return _chart; 
} 
 
d3.json("flare.json", function (nodes) { 
  var chart = treemapChart(); 
  chart.nodes(nodes).render(); 
}); 
</span></pre><p><span class="koboSpan" id="kobo.30.1">This recipe generates the following </span><code class="literal"><span class="koboSpan" id="kobo.31.1">treemap</span></code><span class="koboSpan" id="kobo.32.1"> visualization:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.33.1"><img src="graphics/image_09_007.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.34.1">Treemap</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec196"/><span class="koboSpan" id="kobo.35.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.36.1">At this point, you might be surprised to know how little code is needed to implement a complex data visualization like this. </span><span class="koboSpan" id="kobo.36.2">This is because most of the heavy lifting is done by the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">d3.treemap </span></code><span class="koboSpan" id="kobo.38.1">and</span><code class="literal"><span class="koboSpan" id="kobo.39.1"> d3.hierarchy</span></code><span class="koboSpan" id="kobo.40.1"> functions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.41.1">function renderBody(svg) { 
        if (!_bodyG) { 
            _bodyG = svg.append("g") 
                    .attr("class", "body"); 
 
            _treemap = d3.treemap() //&lt;-A 
                    .size([_width, _height]) 
                    .round(true) 
                    .padding(1); 
        } 
 
        var root = d3.hierarchy(_nodes) // &lt;-B 
                .sum(_valueAccessor) 
                .sort(function(a, b) {  
                     return b.value - a.value;  
                }); 
 
        _treemap(root); //&lt;-C 
 
        var cells = _bodyG.selectAll("g") 
                .data(root.leaves()); // &lt;-D 
 
        renderCells(cells); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.42.1">The </span><code class="literal"><span class="koboSpan" id="kobo.43.1">d3.treemap</span></code><span class="koboSpan" id="kobo.44.1"> layout was defined on line A with some basic custom settings:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.45.1">round(true)</span></code><span class="koboSpan" id="kobo.46.1">: When rounding is on, the treemap layout will round to exact pixel boundaries. </span><span class="koboSpan" id="kobo.46.2">This is great when you want to avoid antialiasing artifacts in SVG.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.47.1">size([_width, _height])</span></code><span class="koboSpan" id="kobo.48.1">: It sets the layout boundary to the size of this SVG.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.49.1">padding(1)</span></code><span class="koboSpan" id="kobo.50.1">: We set the padding to 1 so the blocks generated in tree map will have some white space padded in between.</span></li></ul></div><p><span class="koboSpan" id="kobo.51.1">The </span><code class="literal"><span class="koboSpan" id="kobo.52.1">d3.hierarchy</span></code><span class="koboSpan" id="kobo.53.1"> function was used in this recipe on line B to restructure the input data into a format that can be consumed by </span><code class="literal"><span class="koboSpan" id="kobo.54.1">d3.treemap</span></code><span class="koboSpan" id="kobo.55.1"> and other D3 hierarchical data functions:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.56.1">sum(_valueAccessor)</span></code><span class="koboSpan" id="kobo.57.1">: One feature this recipe offers is the ability to switch the treemap value accessor on the fly. </span><span class="koboSpan" id="kobo.57.2">Value accessor is used by a </span><code class="literal"><span class="koboSpan" id="kobo.58.1">d3.hierachy</span></code><span class="koboSpan" id="kobo.59.1"> function to access value field on each node. </span><span class="koboSpan" id="kobo.59.2">In our case, it can be either one of the following functions:</span></li></ul></div><pre class="programlisting"><span class="koboSpan" id="kobo.60.1">function(d){ return d.size; } // visualize package size 
function(d){ return 1; } // visualize package count 
</span></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.61.1">sort(function(a, b) { return b.value - a.value; })</span></code><span class="koboSpan" id="kobo.62.1">: We have also instructed </span><code class="literal"><span class="koboSpan" id="kobo.63.1">d3.hierarch</span></code><span class="koboSpan" id="kobo.64.1"> to sort each node in the order of their value, effectively making the treemap arrange each block in the order of their size.</span></li></ul></div><p><span class="koboSpan" id="kobo.65.1">To apply the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">d3.hierarchy</span></code><span class="koboSpan" id="kobo.67.1"> transformation on Flare JSON datafeed, we simply set the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">nodes</span></code><span class="koboSpan" id="kobo.69.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.70.1">d3.hierarchy</span></code><span class="koboSpan" id="kobo.71.1"> function to the root node in our JSON tree (refer to line B). </span><span class="koboSpan" id="kobo.71.2">Then, we store the data after the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">d3.hierarchy</span></code><span class="koboSpan" id="kobo.73.1"> transformation using the variable </span><code class="literal"><span class="koboSpan" id="kobo.74.1">root</span></code><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">Here is how the data now looks like:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.76.1"><img src="graphics/image_09_008.jpg" alt="How it works..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.77.1">Treemap hierarchy transformation</span></p><p><span class="koboSpan" id="kobo.78.1">As we can see here, after the transformation, each node now has its value calculated based on the sum of all their children's values and also the depth and size computed, as follows:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.79.1">depth</span></code><span class="koboSpan" id="kobo.80.1">: It indicates the depth of the node</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.81.1">height</span></code><span class="koboSpan" id="kobo.82.1">: It indicates the height of the node in the tree</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.83.1">value</span></code><span class="koboSpan" id="kobo.84.1">: It indicates the sum of all sub-tree values</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.85.1">x0</span></code><span class="koboSpan" id="kobo.86.1">: It indicates the cell starting </span><span class="emphasis"><em><span class="koboSpan" id="kobo.87.1">x</span></em></span><span class="koboSpan" id="kobo.88.1"> coordinate</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.89.1">y0</span></code><span class="koboSpan" id="kobo.90.1">: It indicates the cell starting </span><span class="emphasis"><em><span class="koboSpan" id="kobo.91.1">y</span></em></span><span class="koboSpan" id="kobo.92.1"> coordinate</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.93.1">x1</span></code><span class="koboSpan" id="kobo.94.1">: It indicates the cell ending </span><span class="emphasis"><em><span class="koboSpan" id="kobo.95.1">x</span></em></span><span class="koboSpan" id="kobo.96.1"> coordinate</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.97.1">y1</span></code><span class="koboSpan" id="kobo.98.1">: It indicates the cell ending </span><span class="emphasis"><em><span class="koboSpan" id="kobo.99.1">y</span></em></span><span class="koboSpan" id="kobo.100.1"> coordinate</span></li></ul></div><p><span class="koboSpan" id="kobo.101.1">After this transformation, now we can pass the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">root</span></code><span class="koboSpan" id="kobo.103.1"> variable to the </span><code class="literal"><span class="koboSpan" id="kobo.104.1">_treemap</span></code><span class="koboSpan" id="kobo.105.1"> function on line C. </span><span class="koboSpan" id="kobo.105.2">Now, we are ready to generate the visualization. </span><span class="koboSpan" id="kobo.105.3">On line D, we generate cells using only the leaf nodes from the treemap:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.106.1">var cells = _bodyG.selectAll("g") 
                .data(root.leaves()); // &lt;-D 
</span></pre><p><span class="koboSpan" id="kobo.107.1">This is because firstly d3.selection.data expects flat data array instead of hierarchical tree. </span><span class="koboSpan" id="kobo.107.2">Secondly, the tree map actually only render leaf nodes anyway; the sub-tree grouping is visualized using color. </span><span class="koboSpan" id="kobo.107.3">If we look at the visualization carefully, it is not hard to see this.</span></p><p><span class="koboSpan" id="kobo.108.1">In </span><code class="literal"><span class="koboSpan" id="kobo.109.1">renderCells</span></code><span class="koboSpan" id="kobo.110.1"> function, a set of </span><code class="literal"><span class="koboSpan" id="kobo.111.1">svg:g</span></code><span class="koboSpan" id="kobo.112.1"> elements were created for the given nodes. </span><span class="koboSpan" id="kobo.112.2">The </span><code class="literal"><span class="koboSpan" id="kobo.113.1">renderCells</span></code><span class="koboSpan" id="kobo.114.1"> function is then responsible for creating rectangles and their labels:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.115.1">function renderCells(cells) { 
        var cellEnter = cells.enter().append("g") 
                .attr("class", "cell") 
                .attr("transform", function (d) { 
                    return "translate(" + d.x0 + ","  
                                     + d.y0 + ")"; //&lt;-E 
                }); 
 
        renderRect(cellEnter, cells); 
 
        renderText(cellEnter, cells); 
 
        cells.exit().remove(); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.116.1">Each rectangle is placed at its location </span><code class="literal"><span class="koboSpan" id="kobo.117.1">(x, y)</span></code><span class="koboSpan" id="kobo.118.1"> that's determined by the layout on line E:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.119.1">function renderRect(cellEnter, cells) { 
        cellEnter.append("rect"); 
 
        cellEnter.merge(cells) 
                .transition() 
                .attr("transform", function (d) { 
                    return "translate(" + d.x0 + "," + d.y0 + ")";  
                }) 
                .select("rect") 
                .attr("width", function (d) { //&lt;-F 
                    return d.x1 - d.x0; 
                }) 
                .attr("height", function (d) { 
                    return d.y1 - d.y0; 
                }) 
                .style("fill", function (d) { 
                    return _colors(d.parent.data.name); //&lt;-G 
                }); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.120.1">Then, in the </span><code class="literal"><span class="koboSpan" id="kobo.121.1">renderRect</span></code><span class="koboSpan" id="kobo.122.1"> function, we set its width and height to </span><code class="literal"><span class="koboSpan" id="kobo.123.1">d.x1 - d.x0</span></code><span class="koboSpan" id="kobo.124.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.125.1">d.y1 - d.y0</span></code><span class="koboSpan" id="kobo.126.1">, respectively on line F. </span><span class="koboSpan" id="kobo.126.2">On line G, we colored every cell using its parent's names, therefore making sure that all children belonging to the same parent are colored the same way. </span><span class="koboSpan" id="kobo.126.3">The next step is to render labels:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.127.1">function renderText(cellEnter, cells) { 
        cellEnter.append("text"); 
 
        cellEnter.merge(cells) 
                .select("text") //&lt;-H 
                .style("font-size", 11) 
                .attr("x", function (d) { 
                    return (d.x1 - d.x0) / 2; 
                }) 
                .attr("y", function (d) { 
                    return (d.y1 - d.y0) / 2; 
                }) 
                .attr("text-anchor", "middle") 
                .text(function (d) { 
                    return d.data.name; 
                }) 
                .style("opacity", function (d) { 
                    d.w = this.getComputedTextLength(); 
                    return d.w &lt; (d.x1 - d.x0) ? </span><span class="koboSpan" id="kobo.127.2">1 : 0; //&lt;-I 
                }); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.128.1">From line H onward, we created the label (</span><code class="literal"><span class="koboSpan" id="kobo.129.1">svg:text</span></code><span class="koboSpan" id="kobo.130.1">) element for each rectangle and set its text to the node name. </span><span class="koboSpan" id="kobo.130.2">One aspect worth mentioning here is that in order to avoid displaying label for the cells that are smaller than the label itself, the opacity of label is set to 0 if the label is larger than the cell width (refer to line I).</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip78"/><span class="koboSpan" id="kobo.131.1">Tip</span></h3><p>
<span class="strong"><strong><span class="koboSpan" id="kobo.132.1">Technique - auto-hiding label
</span></strong></span><span class="koboSpan" id="kobo.133.1">What we have seen here on line I is a useful technique in visualization to implement auto-hiding labels. </span><span class="koboSpan" id="kobo.133.2">This technique can be considered generally in the following form:
</span><code class="literal"><span class="koboSpan" id="kobo.134.1">.style("opacity", function (d) {</span></code>
<code class="literal"><span class="koboSpan" id="kobo.135.1">width = this.getComputedTextLength();</span></code>
<code class="literal"><span class="koboSpan" id="kobo.136.1">return d.dx &gt; width ? </span><span class="koboSpan" id="kobo.136.2">1 : 0;</span></code>
</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec197"/><span class="koboSpan" id="kobo.137.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.138.1">This recipe is inspired by Mike Bostock's treemap layout example, which you can find at </span><a class="ulink" href="http://mbostock.github.io/d3/talk/20111018/treemap.html"><span class="koboSpan" id="kobo.139.1">http://mbostock.github.io/d3/talk/20111018/treemap.html
</span></a><span class="koboSpan" id="kobo.140.1">.</span></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Building a tree"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec68"/><span class="koboSpan" id="kobo.1.1">Building a tree</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">When working with hierarchical data structures, a tree (tree graph) is probably one of the most natural and common visualizations typically used to demonstrate structural dependencies between different data elements. </span><span class="koboSpan" id="kobo.2.2">Tree is an undirected graph in which any two nodes (vertices) are connected by one and only one simple path. </span><span class="koboSpan" id="kobo.2.3">In this recipe, we will learn how to implement a tree visualization using D3 tree layout.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec198"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html
</span></a><span class="koboSpan" id="kobo.6.1">.
</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec199"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">Now let's see </span><code class="literal"><span class="koboSpan" id="kobo.9.1">d3.tree</span></code><span class="koboSpan" id="kobo.10.1"> in action:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.11.1">function tree() { 
        var _chart = {}; 
 
        var _width = 1600, _height = 1600, 
                _margins = {top: 30, left: 120, right: 30, bottom: 30}, 
                _svg, 
                _nodes, 
                _i = 0, 
                _duration = 300, 
                _bodyG, 
                _root; 
 
        _chart.render = function () { 
            if (!_svg) { 
                _svg = d3.select("body").append("svg") 
                        .attr("height", _height) 
                        .attr("width", _width); 
            } 
 
            renderBody(_svg); 
        }; 
 
        function renderBody(svg) { 
            if (!_bodyG) { 
                _bodyG = svg.append("g") 
                        .attr("class", "body") 
                        .attr("transform", function (d) { 
                            return "translate(" + _margins.left 
                                    + "," + _margins.top + ")"; 
                        }); 
            } 
 
            _root = d3.hierarchy(_nodes); // &lt;-A 
 
            render(_root); 
        } 
 
        function render(root) { 
            var tree = d3.tree() // &lt;-B 
                        .size([ 
                            (_height - _margins.top - _margins.bottom), 
                            (_width - _margins.left - _margins.right) 
                        ]); 
 
            tree(root); // &lt;-C 
 
            renderNodes(root); // &lt;-D 
 
            renderLinks(root); // &lt;-E 
        } 
 
  function renderNodes(nodes, source) { 
    // will be explained in the 'how it works...' </span><span class="koboSpan" id="kobo.11.2">section 
    ... 
  </span><span class="koboSpan" id="kobo.11.3">} 
 
  function renderLinks(nodes, source) { 
    // will be explained in the 'how it works...' </span><span class="koboSpan" id="kobo.11.4">section 
    ... 
  </span><span class="koboSpan" id="kobo.11.5">} 
 
  // accessors omitted 
  ... 
 
  </span><span class="koboSpan" id="kobo.11.6">return _chart; 
} 
</span></pre><p><span class="koboSpan" id="kobo.12.1">This recipe generates the following tree visualization:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.13.1"><img src="graphics/image_09_009.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.14.1">Tree</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec200"/><span class="koboSpan" id="kobo.15.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.16.1">As we have mentioned before, this recipe is built over the D3 tree layout. </span><span class="koboSpan" id="kobo.16.2">The </span><code class="literal"><span class="koboSpan" id="kobo.17.1">d3.tree</span></code><span class="koboSpan" id="kobo.18.1"> function is specifically designed to convert a hierarchical data structure into a visual layout data suitable for generating a tree graph. </span><span class="koboSpan" id="kobo.18.2">However, similar to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">Building a teemap</span></em></span><span class="koboSpan" id="kobo.20.1">recipe, the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">d3.tree</span></code><span class="koboSpan" id="kobo.22.1"> layout function only accepts structured D3 hierarchical data, meaning before we can use the layout function we need to use </span><code class="literal"><span class="koboSpan" id="kobo.23.1">d3.hierachy</span></code><span class="koboSpan" id="kobo.24.1"> to process and format our data first. </span><span class="koboSpan" id="kobo.24.2">Again, in this recipe, we are using the same Flare project package data we were using so far in this chapter. </span><span class="koboSpan" id="kobo.24.3">The raw JSON data source looks like this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">{ 
 "name": "flare", 
 "children": [ 
  { 
   "name": "analytics", 
   "children": [ 
    { 
     "name": "cluster", 
     "children": [ 
      {"name": "AgglomerativeCluster", "size": 3938}, 
      {"name": "CommunityStructure", "size": 3812}, 
      {"name": "HierarchicalCluster", "size": 6714}, 
      {"name": "MergeEdge", "size": 743} 
     ] 
}, 
... 
</span><span class="koboSpan" id="kobo.25.2">} 
</span></pre><p><span class="koboSpan" id="kobo.26.1">This data is loaded and passed into our chart object in the following function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">function flare() { 
        d3.json("../../data/flare.json", function (nodes) { 
            chart.nodes(nodes).render(); 
        }); 
} 
</span></pre><p><span class="koboSpan" id="kobo.28.1">Once the data is loaded, we first pass the loaded JSON data to d3.hierachy for processing (refer to line A):</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.29.1">_root = d3.hierarchy(_nodes); // &lt;-A 
</span></pre><p><span class="koboSpan" id="kobo.30.1">In this recipe, this is all we need since </span><code class="literal"><span class="koboSpan" id="kobo.31.1">d3.tree</span></code><span class="koboSpan" id="kobo.32.1"> layout only cares about the hierarchical relationship between nodes, therefore, there is no need to sum or order the data as we did in the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.33.1">Build a treemap</span></em></span><span class="koboSpan" id="kobo.34.1">recipe. </span><span class="koboSpan" id="kobo.34.2">Once processed, we can now create tree layout using the following code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.35.1">var tree = d3.tree() // &lt;-B 
                .size([ 
                    (_height - _margins.top - _margins.bottom), 
                    (_width - _margins.left - _margins.right) 
                ]); 
</span></pre><p><span class="koboSpan" id="kobo.36.1">The only setting we provided here is the size of our visualization, which is the size of our SVG image minus the margins. </span><span class="koboSpan" id="kobo.36.2">The </span><code class="literal"><span class="koboSpan" id="kobo.37.1">d3.tree</span></code><span class="koboSpan" id="kobo.38.1"> function will then take care of the rest and calculate every node's position accordingly. </span><span class="koboSpan" id="kobo.38.2">To use the tree layout, you simply need to invoke the layout function on line C.</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.39.1">tree(root); // &lt;-C 
</span></pre><p><span class="koboSpan" id="kobo.40.1">If you peek into the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">nodes</span></code><span class="koboSpan" id="kobo.42.1"> layout data, it contains node data that will look like this:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.43.1"><img src="graphics/image_09_010.jpg" alt="How it works..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.44.1">Tree layout data</span></p><p><span class="koboSpan" id="kobo.45.1">Tree nodes are rendered in the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">renderNode</span></code><span class="koboSpan" id="kobo.47.1"> function as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.48.1">function renderNodes(root) { 
            var nodes = root.descendants(); 
 
            var nodeElements = _bodyG.selectAll("g.node") 
                    .data(nodes, function (d) { 
                                    return d.id || (d.id = ++_i); 
                                }); 
 
            var nodeEnter = nodeElements.enter().append("g") 
                    .attr("class", "node") 
                    .attr("transform", function (d) {  // &lt;-F 
                        return "translate(" + d.y 
                                + "," + d.x + ")"; 
                    }) 
                    .on("click", function (d) { // &lt;-G 
                        toggle(d); 
                        render(_root); 
                    }); 
 
            nodeEnter.append("circle") // &lt;-H 
                    .attr("r", 4); 
 
            var nodeUpdate = nodeEnter.merge(nodeElements) 
                .transition().duration(_duration) 
                .attr("transform", function (d) { 
                    return "translate(" + d.y + "," + d.x + ")"; // &lt;-I 
                }); 
 
            nodeUpdate.select('circle') 
                .style("fill", function (d) { 
                  return d._children ? </span><span class="koboSpan" id="kobo.48.2">"lightsteelblue" : "#fff"; // &lt;-J 
                }); 
 
            var nodeExit = nodeElements.exit() 
                    .transition().duration(_duration) 
                    .attr("transform", function (d) { 
                        return "translate(" + d.y 
                                + "," + d.x + ")"; 
                    }) 
                    .remove(); 
 
            nodeExit.select("circle") 
                    .attr("r", 1e-6) 
                    .remove(); 
 
            renderLabels(nodeEnter, nodeUpdate, nodeExit); 
} 
</span></pre><p><span class="koboSpan" id="kobo.49.1">In this function, first we generate a set of </span><code class="literal"><span class="koboSpan" id="kobo.50.1">g.node</span></code><span class="koboSpan" id="kobo.51.1"> elements bound to </span><code class="literal"><span class="koboSpan" id="kobo.52.1">root.descendents()</span></code><span class="koboSpan" id="kobo.53.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">var nodes = root.descendants(); 
var nodeElements = _bodyG.selectAll("g.node") 
        .data(nodes, function (d) { 
            return d.id || (d.id = ++_i); 
        }); 
</span></pre><p><span class="koboSpan" id="kobo.55.1">The </span><code class="literal"><span class="koboSpan" id="kobo.56.1">root.descendents</span></code><span class="koboSpan" id="kobo.57.1"> function returns all nodes in the hierarchical data. </span><span class="koboSpan" id="kobo.57.2">This is different from the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">root.leaves</span></code><span class="koboSpan" id="kobo.59.1"> function we used in the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.60.1">Build a treemap</span></em></span><span class="koboSpan" id="kobo.61.1">recipe. </span><span class="koboSpan" id="kobo.61.2">The </span><code class="literal"><span class="koboSpan" id="kobo.62.1">root.leaves</span></code><span class="koboSpan" id="kobo.63.1"> function returns only the leaf nodes as a JavaScript array; however, with </span><code class="literal"><span class="koboSpan" id="kobo.64.1">d3.tree</span></code><span class="koboSpan" id="kobo.65.1"> layout, we not only care about the leaves but also any intermediary nodes in order to visualize the entire tree structure, and thus, we need to use </span><code class="literal"><span class="koboSpan" id="kobo.66.1">root.descendents</span></code><span class="koboSpan" id="kobo.67.1"> instead. </span><span class="koboSpan" id="kobo.67.2">At this point, we also assign an ID to each node using an index to obtain object constancy; refer to </span><a class="link" href="ch06.html" title="Chapter 6. Transition with Style"><span class="koboSpan" id="kobo.68.1">Chapter 6</span></a><span class="koboSpan" id="kobo.69.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.70.1">Transition with Style</span></em></span><span class="koboSpan" id="kobo.71.1"> for more information on object constancy in case this is a new concept to you;</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.72.1">var nodeEnter = nodeElements.enter().append("g") 
            .attr("class", "node") 
            .attr("transform", function (d) {  // &lt;-F 
                return "translate(" + d.y 
                        + "," + d.x + ")"; 
            }) 
            .on("click", function (d) { // &lt;-G 
                toggle(d); 
                render(_root); 
            }); 
</span></pre><p><span class="koboSpan" id="kobo.73.1">On line F, we created the nodes and moved them to the coordinates of </span><code class="literal"><span class="koboSpan" id="kobo.74.1">(d.y, d.x)</span></code><span class="koboSpan" id="kobo.75.1"> that the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">d3.tree</span></code><span class="koboSpan" id="kobo.77.1"> layout has calculated for us. </span><span class="koboSpan" id="kobo.77.2">We switched </span><code class="literal"><span class="koboSpan" id="kobo.78.1">x</span></code><span class="koboSpan" id="kobo.79.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.80.1">y</span></code><span class="koboSpan" id="kobo.81.1"> in this case since by default the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">d3.tree</span></code><span class="koboSpan" id="kobo.83.1"> layout calculates coordinates in portrait mode while we want to render them in the landscape mode in this recipe. </span><span class="koboSpan" id="kobo.83.2">On line G, we also created </span><code class="literal"><span class="koboSpan" id="kobo.84.1">onClick</span></code><span class="koboSpan" id="kobo.85.1"> event handler to handle user mouse click on tree nodes. </span><span class="koboSpan" id="kobo.85.2">The </span><code class="literal"><span class="koboSpan" id="kobo.86.1">toggle</span></code><span class="koboSpan" id="kobo.87.1"> function consists of the following code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.88.1">        function toggle(d) { 
            if (d.children) { 
                d._children = d.children; 
                d.children = null; 
            } else { 
                d.children = d._children; 
                d._children = null; 
            } 
        } 
</span></pre><p><span class="koboSpan" id="kobo.89.1">This function effectively hides the children field on a given data node temporarily. </span><span class="koboSpan" id="kobo.89.2">Doing this essentially remove all children from that node in visualization and hence gives the users the sense of collapsing its subtree when they click on a node:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.90.1">nodeEnter.append("circle") // &lt;-H 
            .attr("r", 4); 
 
    var nodeUpdate = nodeEnter.merge(nodeElements) 
            .transition().duration(_duration) 
                .attr("transform", function (d) { 
                    return "translate(" + d.y + "," + d.x + ")"; // &lt;-I 
                }); 
 
    nodeUpdate.select('circle') 
            .style("fill", function (d) { 
                return d._children ? </span><span class="koboSpan" id="kobo.90.2">"lightsteelblue" : "#fff"; // &lt;-J 
         }); 
</span></pre><p><span class="koboSpan" id="kobo.91.1">On line H, we created SVG circle element to represent each tree node, and again we position them at </span><code class="literal"><span class="koboSpan" id="kobo.92.1">(d.y, d.x)</span></code><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">Finally, on line J, we colored the node with different fill based on whether it is collapsed or open by checking the temporary </span><code class="literal"><span class="koboSpan" id="kobo.94.1">_children</span></code><span class="koboSpan" id="kobo.95.1"> file generated by the </span><code class="literal"><span class="koboSpan" id="kobo.96.1">toggle</span></code><span class="koboSpan" id="kobo.97.1"> function. </span><span class="koboSpan" id="kobo.97.2">The rest of the node and label rendering code are quite simple, so we will not cover them line by line here; refer to the source code on GitHub for more details.</span></p><p><span class="koboSpan" id="kobo.98.1">The next important function in this recipe is the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">renderLinks</span></code><span class="koboSpan" id="kobo.100.1"> function. </span><span class="koboSpan" id="kobo.100.2">This function draws all the links that connect all the tree nodes we just created:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.101.1">function renderLinks(root) { 
            var nodes = root.descendants().slice(1); 
 
            var link = _bodyG.selectAll("path.link") 
                .data(nodes, function (d) { 
                    return d.id || (d.id = ++_i); 
                }); 
 
            link.enter().insert("path", "g") // &lt;-M 
                        .attr("class", "link") 
                    .merge(link) 
                    .transition().duration(_duration) 
                       .attr("d", function (d) { 
                        return generateLinkPath(d, d.parent); // &lt;-N 
                    }); 
 
            link.exit().remove(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.102.1">First, for rendering links, we use </span><code class="literal"><span class="koboSpan" id="kobo.103.1">root.descendants().slice(1)</span></code><span class="koboSpan" id="kobo.104.1"> as its data instead of </span><code class="literal"><span class="koboSpan" id="kobo.105.1">root.descendants()</span></code><span class="koboSpan" id="kobo.106.1">. </span><span class="koboSpan" id="kobo.106.2">This is because for </span><code class="literal"><span class="koboSpan" id="kobo.107.1">n</span></code><span class="koboSpan" id="kobo.108.1"> nodes there are </span><code class="literal"><span class="koboSpan" id="kobo.109.1">n - 1</span></code><span class="koboSpan" id="kobo.110.1"> links since there is no link pointing to the root node in a tree. </span><span class="koboSpan" id="kobo.110.2">Once again, object constancy is used here to make our visualization more stable during re-rendering. </span><span class="koboSpan" id="kobo.110.3">Then, on line M, we created path elements to represent each link in our visualization. </span><span class="koboSpan" id="kobo.110.4">Now, the interesting part of this function lies in the </span><code class="literal"><span class="koboSpan" id="kobo.111.1">generateLinkPath</span></code><span class="koboSpan" id="kobo.112.1"> function on line N:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.113.1">function generateLinkPath(target, source) { 
    var path = d3.path(); 
    path.moveTo(target.y, target.x); 
    path.bezierCurveTo((target.y + source.y) / 2, target.x, 
            (target.y + source.y) / 2, source.x, source.y, source.x); 
    return path.toString(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.114.1">In this function, we use the </span><code class="literal"><span class="koboSpan" id="kobo.115.1">d3.path</span></code><span class="koboSpan" id="kobo.116.1"> generator to generate a Bezier curve that connects the source and target nodes. </span><span class="koboSpan" id="kobo.116.2">You can probably see that the usage of the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">d3.path</span></code><span class="koboSpan" id="kobo.118.1"> generator is almost like describing how the line should be drawn. </span><span class="koboSpan" id="kobo.118.2">In this case, we moved the starting point of such line to </span><code class="literal"><span class="koboSpan" id="kobo.119.1">(target.y, target.x)</span></code><span class="koboSpan" id="kobo.120.1"> and then draw a Bezier curve with the given control points from target to source, as shown in the following illustration:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.121.1"><img src="graphics/image_09_011.jpg" alt="How it works..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.122.1">Bezier curve</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note79"/><span class="koboSpan" id="kobo.123.1">Note</span></h3><p><span class="koboSpan" id="kobo.124.1">Of course, if you are familiar with the SVG path commands, then you can generate the d formula without using the </span><code class="literal"><span class="koboSpan" id="kobo.125.1">d3.path</span></code><span class="koboSpan" id="kobo.126.1"> generator. </span><span class="koboSpan" id="kobo.126.2">In this case, we are essentially using M and C commands. </span><span class="koboSpan" id="kobo.126.3">However, the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">d3.path</span></code><span class="koboSpan" id="kobo.128.1"> generator function is more readable and works well with both SVG and Canvas, hence, it yields more maintainable code in general. </span><span class="koboSpan" id="kobo.128.2">For more information on SVG path command, refer to </span><a class="ulink" href="https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands"><span class="koboSpan" id="kobo.129.1">https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands
</span></a><span class="koboSpan" id="kobo.130.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.131.1">At this point, we now have the entire tree graph visualized. </span><span class="koboSpan" id="kobo.131.2">As you can see with the help of the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">d3.tree</span></code><span class="koboSpan" id="kobo.133.1"> layout, drawing this kind of complex visualization is relatively straightforward if not easy.</span></p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec201"/><span class="koboSpan" id="kobo.134.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.135.1">The </span><code class="literal"><span class="koboSpan" id="kobo.136.1">d3.tree</span></code><span class="koboSpan" id="kobo.137.1"> offers several functions that allow customization. </span><span class="koboSpan" id="kobo.137.2">For more details, check out its API documentation at </span><a class="ulink" href="https://github.com/d3/d3-hierarchy/blob/master/README.md#tree"><span class="koboSpan" id="kobo.138.1">https://github.com/d3/d3-hierarchy/blob/master/README.md#tree
</span></a><span class="koboSpan" id="kobo.139.1">.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.140.1">The </span><code class="literal"><span class="koboSpan" id="kobo.141.1">d3.path</span></code><span class="koboSpan" id="kobo.142.1"> generator is capable of generating any arbitrary line on canvas and SVG; for more information, refer to its API document at </span><a class="ulink" href="https://github.com/d3/d3-path/blob/master/README.md#path"><span class="koboSpan" id="kobo.143.1">https://github.com/d3/d3-path/blob/master/README.md#path
</span></a><span class="koboSpan" id="kobo.144.1">.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.145.1">Refer to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.146.1">Animating multiple elements</span></em></span><span class="koboSpan" id="kobo.147.1"> recipe in </span><a class="link" href="ch06.html" title="Chapter 6. Transition with Style"><span class="koboSpan" id="kobo.148.1">Chapter 6</span></a><span class="koboSpan" id="kobo.149.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.150.1">Transition with Style</span></em></span><span class="koboSpan" id="kobo.151.1">, for explanations on object constancy.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.152.1">This recipe is inspired by Mike Bostock's Tidy Tree example, which you can find at </span><a class="ulink" href="http://bl.ocks.org/mbostock/4339184"><span class="koboSpan" id="kobo.153.1">http://bl.ocks.org/mbostock/4339184
</span></a><span class="koboSpan" id="kobo.154.1">.</span></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Building an enclosure diagram"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec69"/><span class="koboSpan" id="kobo.1.1">Building an enclosure diagram</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">An enclosure diagram is an interesting visualization of hierarchical data structures that use the recursive circle packing algorithm. </span><span class="koboSpan" id="kobo.2.2">It uses containment (nesting) to represent hierarchy. </span><span class="koboSpan" id="kobo.2.3">Circles are created for each leaf node in a data tree, while its size is proportional to a particular quantitative dimension of each data element. </span><span class="koboSpan" id="kobo.2.4">In this recipe, you will learn how to implement this kind of visualization using the D3 pack layout.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec202"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html
</span></a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec203"/><span class="koboSpan" id="kobo.6.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.7.1">In this recipe, let's see how we can implement an enclosure diagram using </span><code class="literal"><span class="koboSpan" id="kobo.8.1">d3.pack</span></code><span class="koboSpan" id="kobo.9.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">function pack() { 
        var _chart = {}; 
 
        var _width = 1280, _height = 800, 
                _svg, 
                _valueAccessor, 
                _nodes, 
                _bodyG; 
 
        _chart.render = function () { 
            if (!_svg) { 
                _svg = d3.select("body").append("svg") 
                        .attr("height", _height) 
                        .attr("width", _width); 
            } 
 
            renderBody(_svg); 
        }; 
 
        function renderBody(svg) { 
          if (!_bodyG) { 
              _bodyG = svg.append("g") 
                      .attr("class", "body"); 
          } 
 
          var pack = d3.pack() // &lt;-A 
                  .size([_width, _height]); 
 
          var root = d3.hierarchy(_nodes) // &lt;-B 
                        .sum(_valueAccessor) 
                        .sort(function(a, b) {  
                          return b.value - a.value;  
                        }); 
 
          pack(root); // &lt;-C 
 
          renderCircles(root.descendants()); 
 
          renderLabels(root.descendants()); 
       } 
 
    function renderCircles(nodes) { 
      // will be explained in the 'how it works...' </span><span class="koboSpan" id="kobo.10.2">section 
      ... 
    </span><span class="koboSpan" id="kobo.10.3">} 
 
    function renderLabels(nodes) { 
      // omitted 
      ... 
    </span><span class="koboSpan" id="kobo.10.4">} 
 
    // accessors omitted 
    ... 
 
    </span><span class="koboSpan" id="kobo.10.5">return _chart; 
} 
</span></pre><p><span class="koboSpan" id="kobo.11.1">This recipe generates the following visualization:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.12.1"><img src="graphics/image_09_012.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.13.1">Enclosure diagram</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec204"/><span class="koboSpan" id="kobo.14.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.15.1">In this recipe, we continue to use hierarchical JSON data source that describes Flare project package relationship. </span><span class="koboSpan" id="kobo.15.2">For more information on the data source, refer to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">Build a treemap</span></em></span><span class="koboSpan" id="kobo.17.1"> recipe in this chapter. </span><span class="koboSpan" id="kobo.17.2">The JSON data structure looks like the following:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.18.1">{ 
 "name": "flare", 
 "children": [ 
  { 
   "name": "analytics", 
   "children": [ 
    { 
     "name": "cluster", 
     "children": [ 
      {"name": "AgglomerativeCluster", "size": 3938}, 
      {"name": "CommunityStructure", "size": 3812}, 
      {"name": "HierarchicalCluster", "size": 6714}, 
      {"name": "MergeEdge", "size": 743} 
     ] 
    }, 
    ... 
   </span><span class="koboSpan" id="kobo.18.2">} 
  ] 
} 
</span></pre><p><span class="koboSpan" id="kobo.19.1">This data is loaded into the chart object in the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">flare</span></code><span class="koboSpan" id="kobo.21.1"> function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">function flare() { 
    d3.json("../../data/flare.json", function (nodes) { 
       chart.nodes(nodes).valueAccessor(size).render(); 
    }); 
} 
</span></pre><p><span class="koboSpan" id="kobo.23.1">In this visualization, the first thing we need to take care of is to define our layout; in this case, we need to use the </span><code class="literal"><span class="koboSpan" id="kobo.24.1">d3.pack</span></code><span class="koboSpan" id="kobo.25.1"> layout:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">var pack = d3.pack() // &lt;-A 
            .size([_width, _height]); 
</span></pre><p><span class="koboSpan" id="kobo.27.1">We set the size of our visualization on layout so it can calculate accordingly. </span><span class="koboSpan" id="kobo.27.2">After that, before we can pass our JSON data to the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">d3.pack</span></code><span class="koboSpan" id="kobo.29.1"> layout once again, we need to first process it using the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">d3.hierachy</span></code><span class="koboSpan" id="kobo.31.1"> function (refer to line B), which is a prerequisite for any D3 hierarchical visualization:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">var root = d3.hierarchy(_nodes) // &lt;-B 
                .sum(_valueAccessor) 
                .sort(function(a, b) { return b.value - a.value; }); 
pack(root); // &lt;-C 
</span></pre><p><span class="koboSpan" id="kobo.33.1">In this case, we </span><code class="literal"><span class="koboSpan" id="kobo.34.1">told d3.hierarchy</span></code><span class="koboSpan" id="kobo.35.1"> function to sum up all values using the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">_valueAccessor</span></code><span class="koboSpan" id="kobo.37.1"> function, which takes </span><code class="literal"><span class="koboSpan" id="kobo.38.1">d.size</span></code><span class="koboSpan" id="kobo.39.1"> as the value by default. </span><span class="koboSpan" id="kobo.39.2">Additionally, we also asked the </span><code class="literal"><span class="koboSpan" id="kobo.40.1">d3.hierachy</span></code><span class="koboSpan" id="kobo.41.1"> function to sort the nodes based on the values. </span><span class="koboSpan" id="kobo.41.2">Finally, we then pass the processed data to the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">pack</span></code><span class="koboSpan" id="kobo.43.1"> function on line C. </span><span class="koboSpan" id="kobo.43.2">The layout data after this process now look like this:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.44.1"><img src="graphics/image_09_013.jpg" alt="How it works..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.45.1">Pack layout data</span></p><p><span class="koboSpan" id="kobo.46.1">Circle rendering is done in the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">renderCircle</span></code><span class="koboSpan" id="kobo.48.1"> function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.49.1">function renderCircles(nodes) { // &lt;-C 
    var circles = _bodyG.selectAll("circle") 
            .data(nodes); 
    circles.enter().append("circle") 
            .merge(circles) 
            .transition() 
        .attr("class", function (d) { 
            return d.children ? </span><span class="koboSpan" id="kobo.49.2">"parent" : "child"; 
        }) 
        .attr("cx", function (d) {return d.x;}) // &lt;-D 
        .attr("cy", function (d) {return d.y;}) 
        .attr("r", function (d) {return d.r;}); 
    circles.exit().transition() 
            .attr("r", 0) 
            .remove(); 
} 
</span></pre><p><span class="koboSpan" id="kobo.50.1">Then, we simply bind the layout data and create the </span><code class="literal"><span class="koboSpan" id="kobo.51.1">svg:circle</span></code><span class="koboSpan" id="kobo.52.1"> elements for each node. </span><span class="koboSpan" id="kobo.52.2">For update, we set </span><code class="literal"><span class="koboSpan" id="kobo.53.1">cx</span></code><span class="koboSpan" id="kobo.54.1">, </span><code class="literal"><span class="koboSpan" id="kobo.55.1">cy</span></code><span class="koboSpan" id="kobo.56.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.57.1">radius</span></code><span class="koboSpan" id="kobo.58.1"> to the value that the pack layout has calculated for us for each circle (refer to line D). </span><span class="koboSpan" id="kobo.58.2">Finally, when removing  the circle, we reduce the size of the circle down to zero first, before removing them to generate a more smooth transition. </span><span class="koboSpan" id="kobo.58.3">Label rendering in this recipe is pretty straightforward with some help from the auto-hiding technique we introduced in this chapter, so we will not cover the function in detail here.</span></p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec205"/><span class="koboSpan" id="kobo.59.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.60.1">The </span><code class="literal"><span class="koboSpan" id="kobo.61.1">d3.pack</span></code><span class="koboSpan" id="kobo.62.1"> function offers several functions that allow customization. </span><span class="koboSpan" id="kobo.62.2">For more details, please check out its API documentation at </span><a class="ulink" href="https://github.com/d3/d3-hierarchy/blob/master/README.md#pack"><span class="koboSpan" id="kobo.63.1">https://github.com/d3/d3-hierarchy/blob/master/README.md#pack
</span></a><span class="koboSpan" id="kobo.64.1">.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.65.1">The </span><span class="emphasis"><em><span class="koboSpan" id="kobo.66.1">Building a treemap</span></em></span><span class="koboSpan" id="kobo.67.1"> recipe for auto label hiding technique.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.68.1">This recipe is inspired by Mike Bostock's pack layout example, which you can find at </span><a class="ulink" href="http://bl.ocks.org/mbostock/ca5b03a33affa4160321"><span class="koboSpan" id="kobo.69.1">http://bl.ocks.org/mbostock/ca5b03a33affa4160321
</span></a><span class="koboSpan" id="kobo.70.1">.</span></li></ul></div></div></div></div></div></body></html>