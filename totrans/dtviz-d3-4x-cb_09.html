<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Lay Them Out</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a pie chart</li><li class="listitem" style="list-style-type: disc">Building a stacked area chart</li><li class="listitem" style="list-style-type: disc">Building a treemap</li><li class="listitem" style="list-style-type: disc">Building a tree</li><li class="listitem" style="list-style-type: disc">Building an enclosure diagram</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Introduction</h1></div></div></div><p>The D3 layout is the focus of this chapter-a concept we have not encountered before. As expected, D3 layouts are algorithms that calculate and generate placement information for a group of elements. However, there are a few critical properties worth mentioning before we dive deeper into the specifics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Layouts are data</strong>: Layouts are purely data centric and data driven; they do not generate any graphical or display-related output directly. This allows them to be used and reused with SVG or canvas or even when there is no graphical output.</li><li class="listitem" style="list-style-type: disc"><strong>Abstract and reusable</strong>: Layouts are abstract, allowing a high degree of flexibility and reusability. You can combine and reuse layouts in various different interesting ways.</li><li class="listitem" style="list-style-type: disc"><strong>Layouts are different</strong>: Each layout is different. Every layout provided by D3 focuses on a very special graphical requirement and data structure.</li><li class="listitem" style="list-style-type: disc"><strong>Stateless</strong>: Layouts are mostly stateless by design to simplify their usage. What statelessness means here is that generally layouts are like functions; they can be called multiple times with different input data and generate different layout output.</li></ul></div><p>Layouts are interesting and powerful concepts in D3. In this chapter, we will explore some of the most commonly used layouts in D3 by creating a fully functional visualization leveraging these layouts.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Building a pie chart</h1></div></div></div><p>A pie chart or a circle graph is a circular graph that contains multiple sectors used to illustrate numerical proportion. We will explore techniques, involving D3 <strong>pie layout</strong>, to build a fully functional pie chart in this recipe. In <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>, it became clear that using the D3 arc generator directly is a very tedious job. Each arc generator expects the following data format:</p><pre class="programlisting">var data = [ 
  {startAngle: 0, endAngle: 0.6283185307179586},  
  {startAngle: 0.6283185307179586, endAngle: 1.2566370614359172}, 
  ... 
  {startAngle: 5.654866776461628, endAngle: 6.283185307179586} 
]; 
</pre><p>This essentially requires the calculation of the angle partition for each slice out of an entire circle of <code class="literal">2 * Math.PI</code>. Obviously, this process can be automated by an algorithm, which is exactly what <code class="literal">d3.pie</code> is designed for. In this recipe, we will see how a pie layout can be used to implement a fully functional pie chart.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec184"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser: <a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec185"/>How to do it...</h2></div></div></div><p>A pie chart or a circle graph is a circular diagram divided into sectors (slices). Pie charts are popular in many fields and widely used to demonstrate relationships between different entities, though not without criticism. Let's take a look at how a pie chart is implemented using <code class="literal">d3.layout</code> first:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    function pieChart() { 
        var _chart = {}; 
 
        var _width = 500, _height = 500, 
                _data = [], 
                _colors = d3.scaleOrdinal(d3.schemeCategory10), 
                _svg, 
                _bodyG, 
                _pieG, 
                _radius = 200, 
                _innerRadius = 100, 
                _duration = 1000; 
 
        _chart.render = function () { 
            if (!_svg) { 
                _svg = d3.select("body").append("svg") 
                        .attr("height", _height) 
                        .attr("width", _width); 
            } 
 
            renderBody(_svg); 
        }; 
 
        function renderBody(svg) { 
            if (!_bodyG) 
                _bodyG = svg.append("g") 
                        .attr("class", "body"); 
 
            renderPie(); 
        } 
 
        function renderPie() { 
            var pie = d3.pie() // &lt;-A 
                    .sort(function (d) { 
                        return d.id; 
                    }) 
                    .value(function (d) { 
                        return d.value; 
                    }); 
 
            var arc = d3.arc() 
                    .outerRadius(_radius) 
                    .innerRadius(_innerRadius); 
 
            if (!_pieG) 
                _pieG = _bodyG.append("g") 
                        .attr("class", "pie") 
                        .attr("transform", "translate("  
                            + _radius  
                            + ","  
                            + _radius + ")"); 
 
            renderSlices(pie, arc); 
 
            renderLabels(pie, arc); 
        } 
 
  function renderSlices(pie, arc) { 
  // explained in detail in the'how it works...' section 
  ... 
  } 
 
  function renderLabels(pie, arc) { 
  // explained in detail in the 'how it works...' section 
  ... 
  } 
  ... 
  return _chart; 
} 
... 
&lt;/script&gt; 
</pre><p>This recipe generates the following pie chart:</p><p>
</p><div><img src="img/image_09_001.jpg" alt="How to do it..."/></div><p>
</p><p>Pie chart</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec186"/>How it works...</h2></div></div></div><p>This recipe is built over what you have learned in the <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>. One major difference is that you rely on <code class="literal">d3.pie</code> to transform the raw data into arcs data for us. The pie layout was created on line A with both sort and value accessors specified:</p><pre class="programlisting">var pie = d3.pie() // &lt;-A 
              .sort(function (d) { 
                  return d.id; 
              }) 
              .value(function (d) { 
                  return d.value; 
              }); 
</pre><p>The <code class="literal">sort</code> function tells the pie layout to sort slices by its ID field, so that we can maintain stable order among slices. Without the sorting, by default, the pie layout will order the slices by value, resulting in the swapping of slices whenever we update the pie chart. The <code class="literal">value</code> function is used to provide value accessor, which, in our case, returns the <code class="literal">value</code> field. When rendering slices, now with the pie layout, we directly set the output of the <code class="literal">pie</code> function call as data (remember, layouts are data) to generate the arc <code class="literal">svg:path</code> elements (refer to line <code class="literal">B</code>):</p><pre class="programlisting">function renderSlices(pie, arc) { 
    var slices = _pieG.selectAll("path.arc") 
            .data(pie(_data)); // &lt;-B 
 
    slices.enter() 
            .append("path") 
        .merge(slices) 
            .attr("class", "arc") 
            .attr("fill", function (d, i) { 
                return _colors(i); 
            }) 
        .transition() 
            .duration(_duration) 
            .attrTween("d", function (d) { 
                var currentArc = this.__current__; // &lt;-C 
 
                if (!currentArc) 
                    currentArc = {startAngle: 0,  
                                    endAngle: 0}; 
 
                var interpolate = d3.interpolate( 
                                    currentArc, d); 
                                     
                this.__current__ = interpolate(1);//&lt;-D 
                 
                return function (t) { 
                    return arc(interpolate(t)); 
                }; 
            }); 
} 
</pre><p>At this point, you might be wondering what kind of data <code class="literal">d3.pie</code> generates. Here is what the output data looks like:</p><p>
</p><div><img src="img/image_09_002.jpg" alt="How it works..."/></div><p>
</p><p>Pie output data</p><p>As we can see clearly, this is exactly what the <code class="literal">d3.arc</code> generator expects. This is why we can use this data directly with <code class="literal">d3.arc</code> without dealing with any detailed calculation for angles and partitions. The rest of the rendering logic is pretty much the same as what you have learned in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>, with one exception that can be seen on line C. On line C, we retrieve the current arc value from the element so the transition can start from the current angle instead of zero. Then, on line D, we reset the current arc value to the latest one; so, the next time when we update the pie chart data, we can repeat the stateful transition.</p><div><div><h3 class="title"><a id="tip75"/>Tip</h3><p>
<strong>Technique - stateful visualization
</strong>Technique of value injection on a DOM element is a common approach to introduce statefulness to your visualization. In other words, if you need your visualizations to remember what their previous states are, you can save them in DOM elements, as demonstrated on line <code class="literal">C</code> in this recipe.</p></div></div><p>Finally, we also need to render labels on each slice so our user can understand what each slice is representing. This is done by the <code class="literal">renderLabels</code> function:</p><pre class="programlisting">function renderLabels(pie, arc) { 
            var labels = _pieG.selectAll("text.label") 
                    .data(pie(_data)); // &lt;-E 
 
            labels.enter() 
                    .append("text") 
                .merge(labels) 
                    .attr("class", "label") 
                .transition() 
                    .duration(_duration) 
                    .attr("transform", function (d) { 
                        return "translate("  
                            + arc.centroid(d) + ")"; // &lt;-F 
                    }) 
                    .attr("dy", ".35em") 
                    .attr("text-anchor", "middle") 
                    .text(function (d) { 
                        return d.data.id; 
                    });         
} 
</pre><p>Once again, we use the output of the <code class="literal">pie</code> function call as data to generate the <code class="literal">svg:text</code> elements. The placement of the labels is calculated using <code class="literal">arc.centroid</code> (refer to line <code class="literal">F</code>). Additionally, the label placement is animated through the transition so they can be moved with arcs in unison.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec187"/>There's more...</h2></div></div></div><p>Pie charts are very widely used in many different domains. However, they are also widely criticized due to the fact that they are difficult for the human eyes to compare different sections of a given pie chart as well as for their low information density. Therefore, it is highly recommended to limit the number of sections to less than three, with two considered to be ideal. Otherwise, you can always use a bar chart or a small table to replace a pie chart for better precision and communicative power.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec188"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using arc generators</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em></li><li class="listitem" style="list-style-type: disc">The <em>Implementing arc transition</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Building a stacked area chart</h1></div></div></div><p>In the <em>Creating an area chart</em> recipe in <a class="link" href="ch08.html" title="Chapter 8. Chart Them Up">Chapter 8</a>, <em>Chart Them Up</em>, we explored how a basic layered area chart can be implemented using D3. In this recipe, we will build over what we covered in the area chart recipe to implement a stacked area chart. Stacked area chart is a variation of the standard area chart in which different areas are stacked on top of each other giving your audience the ability to compare not only different data series individually but also their relationship to the total in proportion.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec189"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser: <a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec190"/>How to do it...</h2></div></div></div><p>This recipe is built over what we had implemented in <a class="link" href="ch08.html" title="Chapter 8. Chart Them Up">Chapter 8</a>, <em>Chart Them Up</em>; therefore, in the following code example, only the parts that are particularly relevant to the stacked area chart are included:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
function stackedAreaChart() { 
    var _chart = {}; 
 
    var _width = 900, _height = 450, 
            _margins = {top: 30, left: 30, right: 30, bottom: 30}, 
            _x, _y, 
            _data = [], 
            _colors = d3.scaleOrdinal(d3.schemeCategory10), 
            _svg, 
            _bodyG, 
            _line; 
 
    _chart.render = function () { 
        if (!_svg) { 
            _svg = d3.select("body").append("svg") 
                    .attr("height", _height) 
                    .attr("width", _width); 
 
            renderAxes(_svg); 
 
            defineBodyClip(_svg); 
        } 
 
    renderBody(_svg); 
}; 
... 
function renderBody(svg) { 
   if (!_bodyG) 
       _bodyG = svg.append("g") 
                    .attr("class", "body") 
                    .attr("transform", "translate(" 
                            + xStart() + "," 
                            + yEnd() + ")") 
                    .attr("clip-path", "url(#body-clip)"); 
 
    var stack = d3.stack() // &lt;-A 
                .keys(['value1', 'value2', 'value3']) 
                .offset(d3.stackOffsetNone); 
 
    var series = stack(_data); //&lt;-B 
 
    renderLines(series); 
 
    renderAreas(series); 
} 
 
function renderLines(stackedData) { 
  // explained in details in the'how it works...' section 
... 
} 
 
function renderAreas(stackedData) { 
  // explained in details in the 'how it works...' section 
... 
} 
... 
</pre><p>This recipe generates the following visualization:</p><p>
</p><div><img src="img/image_09_003.jpg" alt="How to do it..."/></div><p>
</p><p>Stacked area chart</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec191"/>How it works...</h2></div></div></div><p>The main difference between this recipe and the standard area chart is the stacking, which is also the focus of this recipe. The stacking effect as illustrated in this recipe was achieved through <code class="literal">d3.stack</code> created on line <code class="literal">A</code>:</p><pre class="programlisting">var stack = dn3.stack() // &lt;-A 
                .keys(['value1', 'value2', 'value3']) // &lt;-B 
                .offset(d3.stackOffsetNone); 
... 
function update() { 
    data = d3.range(numberOfDataPoint).map(function (i) { 
        return {value1: randomData(),  
                value2: randomData(),  
                value3: randomData()}; 
    }); 
 
    chart.data(data).render(); 
} 
</pre><p>As we can see in this code snippet, the data points we generated in the <code class="literal">update</code> function has three different series, <code class="literal">value1</code>, <code class="literal">value2</code>, and <code class="literal">value3</code>. This is why we need to specify their names to the <code class="literal">d3.stack</code> on line <code class="literal">B</code>. The only other customization we have done on stack layout is setting its <code class="literal">offset</code> to <code class="literal">d3.stackOffsetNone</code>. D3 stack layout supports a few different offset modes, which determine the stacking algorithm to be used; this is something that we will explore in this and the next recipe. In this case, we use the <code class="literal">zero</code> offset stacking, which generates a zero base-lined stacking algorithm, which is exactly what we want in this recipe. Next, on line <code class="literal">B</code>, we invoked the stack layout on the given data array, which generates the following layout data:</p><p>
</p><div><img src="img/image_09_004.jpg" alt="How it works..."/></div><p>
</p><p>Stacked data</p><p>As shown, the stack layout automatically calculates a <code class="literal">y</code> baseline <code class="literal">0</code> for each data in our three different data series as well as the <code class="literal">y</code> topline <code class="literal">1</code>. Now, with this stacked dataset in hand, we can easily generate stacked lines:</p><pre class="programlisting">function renderLines(series) { 
        _line = d3.line() 
                .x(function (d, i) { 
                    return _x(i); //&lt;-C 
                }) 
                .y(function (d) { 
                    return _y(d[1]); //&lt;-D 
                }); 
 
        var linePaths = _bodyG.selectAll("path.line") 
                .data(series); 
 
        linePaths.enter() 
                .append("path") 
            .merge(linePaths) 
                .style("stroke", function (d, i) { 
                    return _colors(i); 
                }) 
                .attr("class", "line") 
            .transition() 
                .attr("d", function (d) { 
                    return _line(d); 
                }); 
} 
</pre><p>A <code class="literal">d3.line</code> generator function was created with its index count value <code class="literal">i</code> directly mapped to the <code class="literal">x</code> (refer to line <code class="literal">C</code>) and its <code class="literal">y</code> topline value mapped to <code class="literal">d[1] </code>(refer to line <code class="literal">D</code>). This is all you need to do for line stacking. The rest of the <code class="literal">renderLines</code> function is essentially the same as in the basic area chart implementation. The area stacking logic is slightly different:</p><pre class="programlisting">function renderAreas(series) { 
        var area = d3.area() 
                .x(function (d, i) { 
                    return _x(i); //&lt;-E 
                }) 
                .y0(function(d){return _y(d[0]);}) //&lt;-F 
                .y1(function (d) { 
                    return _y(d[1]); //&lt;-G 
                }); 
 
        var areaPaths = _bodyG.selectAll("path.area") 
                .data(series); 
 
        areaPaths.enter() 
                .append("path") 
            .merge(areaPaths) 
                .style("fill", function (d, i) { 
                    return _colors(i); 
                }) 
                .attr("class", "area") 
            .transition() 
                .attr("d", function (d) { 
                    return area(d); 
                }); 
} 
</pre><p>Similar to the line rendering logic when rendering area, the only place we need to change is in the <code class="literal">d3.area</code> generator setting. For areas, the <code class="literal">x</code> value is still directly mapped to the index count <code class="literal">i</code> (line E) with its <code class="literal">y0</code> directly mapped with <code class="literal">y</code> baseline <code class="literal">d[0]</code> and finally again <code class="literal">y1</code> is the <code class="literal">y</code> topline <code class="literal">d[1]</code> (line G).</p><p>As we saw so far, the D3 stack layout is nicely designed to be compatible with different D3 SVG generator functions. Hence, using it to generate the stacking effect is quite straightforward and convenient.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec192"/>There's more...</h2></div></div></div><p>Let's take a look at a couple of variations of the stacked area chart.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec17"/>Expanded area chart</h3></div></div></div><p>We have mentioned that <code class="literal">d3.stack</code> supports different offset modes. In addition to the <code class="literal">d3.stackOffsetNone </code>offset we saw so far, another very useful offset mode for the area chart is called <code class="literal">d3.stackOffsetExpand</code>. With the <code class="literal">d3.stackOffsetExpand </code>mode, stack layout will normalize different layers to fill the range of <code class="literal">[0, 1]</code>. If we change the offset mode in this recipe and the y axis domain to <code class="literal">[0, 1]</code>, we will get the following expanded (normalized) area chart; this visualization is very useful when your audience care more about the relative proportion of each data series more than their absolution values:</p><p>
</p><div><img src="img/image_09_005.jpg" alt="Expanded area chart"/></div><p>
</p><p>Expanded area chart</p><p>For the complete companion code example, visit <a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html
</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec18"/>Streamgraph</h3></div></div></div><p>Another interesting variation of a stacked area chart is called streamgraph. Streamgraph is a stacked area chart displayed around a central axis, creating a flowing and organic shape. Streamgraph was initially developed by Lee Byron and popularized by its use in a New York Times article on movie box office revenues in 2008. The D3 stack layout has built-in support for this kind of stacking algorithm, and therefore, changing a zero-based stacked area chart to streamgraph is simple. The key difference is that streamgraph uses <code class="literal">d3.stackOffsetWiggle</code> as its layout offset mode. Stream graph is a useful visualization when you want to highlight the change of data or its trend over time rather than its absolute values.</p><p>
</p><div><img src="img/image_09_006.jpg" alt="Streamgraph"/></div><p>
</p><p>Streamgraph</p><p>For the complete companion code example, please visit <a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html
</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec193"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d3.stack</code> function offers several additional functions to customize its behavior; for more information on stack layout, visit <a class="ulink" href="https://github.com/d3/d3/blob/master/API.md#stacks">https://github.com/d3/d3/blob/master/API.md#stacks
</a></li><li class="listitem" style="list-style-type: disc">The Creating an area chart recipe in <a class="link" href="ch08.html" title="Chapter 8. Chart Them Up">Chapter 8</a>, <em>Chart Them Up</em></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Building a treemap</h1></div></div></div><p>Treemaps were introduced by Ben Shneiderman in 1991. A treemap displays hierarchical tree-structured data as a set of recursively subdivided rectangles. In other words, it displays each branch of the tree as a large rectangle, which is then tiled with smaller rectangles representing subbranches. This process continuously repeats itself till it reaches the leaves of the tree.</p><div><div><h3 class="title"><a id="note76"/>Note</h3><p>For more information on treemaps, refer to treemaps for space-constrained visualization of hierarchies by Ben Shneiderman at <a class="ulink" href="http://www.cs.umd.edu/hcil/treemap-history">http://www.cs.umd.edu/hcil/treemap-history
</a>.</p></div></div><p>Before we dive into the code example, let's first define what we mean by <strong>hierarchical data</strong>. So far, we discussed many types of visualizations capable of representing flat data structure usually stored in one or two dimensional arrays. In the rest of this chapter, we will switch our focus onto another common type of data structure in data visualization-the hierarchical data structure. Instead of using arrays, as in the case of flat data structures, hierarchical data is usually structured as a rooted tree. The following JSON file shows a typical hierarchical data you would expect in a data visualization project:</p><pre class="programlisting">{ 
  "name": "flare", 
  "children": [ 
  { 
    "name": "analytics", 
    "children": [ 
    { 
      "name": "cluster", 
      "children": [ 
        {"name": "AgglomerativeCluster", "size": 3938}, 
        {"name": "CommunityStructure", "size": 3812}, 
        {"name": "MergeEdge", "size": 743} 
      ] 
    }, 
    { 
      "name": "graph", 
      "children": [ 
        {"name": "BetweennessCentrality", "size": 3534}, 
        {"name": "LinkDistance", "size": 5731} 
      ] 
    }, 
    { 
      "name": "optimization", 
      "children": [ 
        {"name": "AspectRatioBanker", "size": 7074} 
      ] 
    } 
  ]   
  ] 
} 
</pre><p>This is a shortened version of a popular hierarchical dataset used in the D3 community for demonstration purposes. This data is extracted from a popular flash-based data visualization library-<code class="literal">flare</code>, created by the UC Berkeley Visualization Lab. It shows the size and hierarchical relationship among different packages within the library.</p><div><div><h3 class="title"><a id="note77"/>Note</h3><p>Refer to the official Flare site for more information on the project at <a class="ulink" href="http://flare.prefuse.org/">http://flare.prefuse.org/
</a>.</p></div></div><p>As we can see quite easily, this particular JSON feed is structured as a typical singly-linked rooted tree with each node having a single parent and multiple child nodes stored in the <code class="literal">children</code> array. This is a pretty common way to organize your hierarchical data in order to be consumed by the D3 hierarchical layouts. For the rest of this chapter, we will use this particular dataset for exploring different hierarchical data visualization techniques D3 has to offer.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec194"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser: <a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html
</a>.
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec195"/>How to do it...</h2></div></div></div><p>Now let's take a look at how we can use the <code class="literal">d3.treemap</code> function to visually represent this kind of hierarchical data:</p><pre class="programlisting">function treemapChart() { 
        var _chart = {}; 
 
        var _width = 1600, _height = 800, 
                _colors = d3.scaleOrdinal(d3.schemeCategory20c), 
                _svg, 
                _nodes, 
                _valueAccessor, 
                _treemap, 
                _bodyG; 
 
        _chart.render = function () { 
            if (!_svg) { 
                _svg = d3.select("body").append("svg") 
                        .attr("height", _height) 
                        .attr("width", _width); 
            } 
 
            renderBody(_svg); 
        }; 
 
        function renderBody(svg) { 
            // explained in the 'how it works...' section 
            ...  
 
            renderCells(cells); 
        } 
 
        function renderCells(cells){ 
            // explained in the 'how it works...' section 
            ... 
        } 
 
        // accessors omitted 
        ... 
 
        return _chart; 
} 
 
d3.json("flare.json", function (nodes) { 
  var chart = treemapChart(); 
  chart.nodes(nodes).render(); 
}); 
</pre><p>This recipe generates the following <code class="literal">treemap</code> visualization:</p><p>
</p><div><img src="img/image_09_007.jpg" alt="How to do it..."/></div><p>
</p><p>Treemap</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec196"/>How it works...</h2></div></div></div><p>At this point, you might be surprised to know how little code is needed to implement a complex data visualization like this. This is because most of the heavy lifting is done by the <code class="literal">d3.treemap </code>and<code class="literal"> d3.hierarchy</code> functions:</p><pre class="programlisting">function renderBody(svg) { 
        if (!_bodyG) { 
            _bodyG = svg.append("g") 
                    .attr("class", "body"); 
 
            _treemap = d3.treemap() //&lt;-A 
                    .size([_width, _height]) 
                    .round(true) 
                    .padding(1); 
        } 
 
        var root = d3.hierarchy(_nodes) // &lt;-B 
                .sum(_valueAccessor) 
                .sort(function(a, b) {  
                     return b.value - a.value;  
                }); 
 
        _treemap(root); //&lt;-C 
 
        var cells = _bodyG.selectAll("g") 
                .data(root.leaves()); // &lt;-D 
 
        renderCells(cells); 
    } 
</pre><p>The <code class="literal">d3.treemap</code> layout was defined on line A with some basic custom settings:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">round(true)</code>: When rounding is on, the treemap layout will round to exact pixel boundaries. This is great when you want to avoid antialiasing artifacts in SVG.</li><li class="listitem" style="list-style-type: disc"><code class="literal">size([_width, _height])</code>: It sets the layout boundary to the size of this SVG.</li><li class="listitem" style="list-style-type: disc"><code class="literal">padding(1)</code>: We set the padding to 1 so the blocks generated in tree map will have some white space padded in between.</li></ul></div><p>The <code class="literal">d3.hierarchy</code> function was used in this recipe on line B to restructure the input data into a format that can be consumed by <code class="literal">d3.treemap</code> and other D3 hierarchical data functions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sum(_valueAccessor)</code>: One feature this recipe offers is the ability to switch the treemap value accessor on the fly. Value accessor is used by a <code class="literal">d3.hierachy</code> function to access value field on each node. In our case, it can be either one of the following functions:</li></ul></div><pre class="programlisting">function(d){ return d.size; } // visualize package size 
function(d){ return 1; } // visualize package count 
</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sort(function(a, b) { return b.value - a.value; })</code>: We have also instructed <code class="literal">d3.hierarch</code> to sort each node in the order of their value, effectively making the treemap arrange each block in the order of their size.</li></ul></div><p>To apply the <code class="literal">d3.hierarchy</code> transformation on Flare JSON datafeed, we simply set the <code class="literal">nodes</code> on the <code class="literal">d3.hierarchy</code> function to the root node in our JSON tree (refer to line B). Then, we store the data after the <code class="literal">d3.hierarchy</code> transformation using the variable <code class="literal">root</code>. Here is how the data now looks like:</p><p>
</p><div><img src="img/image_09_008.jpg" alt="How it works..."/></div><p>
</p><p>Treemap hierarchy transformation</p><p>As we can see here, after the transformation, each node now has its value calculated based on the sum of all their children's values and also the depth and size computed, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">depth</code>: It indicates the depth of the node</li><li class="listitem" style="list-style-type: disc"><code class="literal">height</code>: It indicates the height of the node in the tree</li><li class="listitem" style="list-style-type: disc"><code class="literal">value</code>: It indicates the sum of all sub-tree values</li><li class="listitem" style="list-style-type: disc"><code class="literal">x0</code>: It indicates the cell starting <em>x</em> coordinate</li><li class="listitem" style="list-style-type: disc"><code class="literal">y0</code>: It indicates the cell starting <em>y</em> coordinate</li><li class="listitem" style="list-style-type: disc"><code class="literal">x1</code>: It indicates the cell ending <em>x</em> coordinate</li><li class="listitem" style="list-style-type: disc"><code class="literal">y1</code>: It indicates the cell ending <em>y</em> coordinate</li></ul></div><p>After this transformation, now we can pass the <code class="literal">root</code> variable to the <code class="literal">_treemap</code> function on line C. Now, we are ready to generate the visualization. On line D, we generate cells using only the leaf nodes from the treemap:</p><pre class="programlisting">var cells = _bodyG.selectAll("g") 
                .data(root.leaves()); // &lt;-D 
</pre><p>This is because firstly d3.selection.data expects flat data array instead of hierarchical tree. Secondly, the tree map actually only render leaf nodes anyway; the sub-tree grouping is visualized using color. If we look at the visualization carefully, it is not hard to see this.</p><p>In <code class="literal">renderCells</code> function, a set of <code class="literal">svg:g</code> elements were created for the given nodes. The <code class="literal">renderCells</code> function is then responsible for creating rectangles and their labels:</p><pre class="programlisting">function renderCells(cells) { 
        var cellEnter = cells.enter().append("g") 
                .attr("class", "cell") 
                .attr("transform", function (d) { 
                    return "translate(" + d.x0 + ","  
                                     + d.y0 + ")"; //&lt;-E 
                }); 
 
        renderRect(cellEnter, cells); 
 
        renderText(cellEnter, cells); 
 
        cells.exit().remove(); 
    } 
</pre><p>Each rectangle is placed at its location <code class="literal">(x, y)</code> that's determined by the layout on line E:</p><pre class="programlisting">function renderRect(cellEnter, cells) { 
        cellEnter.append("rect"); 
 
        cellEnter.merge(cells) 
                .transition() 
                .attr("transform", function (d) { 
                    return "translate(" + d.x0 + "," + d.y0 + ")";  
                }) 
                .select("rect") 
                .attr("width", function (d) { //&lt;-F 
                    return d.x1 - d.x0; 
                }) 
                .attr("height", function (d) { 
                    return d.y1 - d.y0; 
                }) 
                .style("fill", function (d) { 
                    return _colors(d.parent.data.name); //&lt;-G 
                }); 
    } 
</pre><p>Then, in the <code class="literal">renderRect</code> function, we set its width and height to <code class="literal">d.x1 - d.x0</code> and <code class="literal">d.y1 - d.y0</code>, respectively on line F. On line G, we colored every cell using its parent's names, therefore making sure that all children belonging to the same parent are colored the same way. The next step is to render labels:</p><pre class="programlisting">function renderText(cellEnter, cells) { 
        cellEnter.append("text"); 
 
        cellEnter.merge(cells) 
                .select("text") //&lt;-H 
                .style("font-size", 11) 
                .attr("x", function (d) { 
                    return (d.x1 - d.x0) / 2; 
                }) 
                .attr("y", function (d) { 
                    return (d.y1 - d.y0) / 2; 
                }) 
                .attr("text-anchor", "middle") 
                .text(function (d) { 
                    return d.data.name; 
                }) 
                .style("opacity", function (d) { 
                    d.w = this.getComputedTextLength(); 
                    return d.w &lt; (d.x1 - d.x0) ? 1 : 0; //&lt;-I 
                }); 
    } 
</pre><p>From line H onward, we created the label (<code class="literal">svg:text</code>) element for each rectangle and set its text to the node name. One aspect worth mentioning here is that in order to avoid displaying label for the cells that are smaller than the label itself, the opacity of label is set to 0 if the label is larger than the cell width (refer to line I).</p><div><div><h3 class="title"><a id="tip78"/>Tip</h3><p>
<strong>Technique - auto-hiding label
</strong>What we have seen here on line I is a useful technique in visualization to implement auto-hiding labels. This technique can be considered generally in the following form:
<code class="literal">.style("opacity", function (d) {</code>
<code class="literal">width = this.getComputedTextLength();</code>
<code class="literal">return d.dx &gt; width ? 1 : 0;</code>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec197"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This recipe is inspired by Mike Bostock's treemap layout example, which you can find at <a class="ulink" href="http://mbostock.github.io/d3/talk/20111018/treemap.html">http://mbostock.github.io/d3/talk/20111018/treemap.html
</a>.</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Building a tree</h1></div></div></div><p>When working with hierarchical data structures, a tree (tree graph) is probably one of the most natural and common visualizations typically used to demonstrate structural dependencies between different data elements. Tree is an undirected graph in which any two nodes (vertices) are connected by one and only one simple path. In this recipe, we will learn how to implement a tree visualization using D3 tree layout.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec198"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html
</a>.
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec199"/>How to do it...</h2></div></div></div><p>Now let's see <code class="literal">d3.tree</code> in action:</p><pre class="programlisting">function tree() { 
        var _chart = {}; 
 
        var _width = 1600, _height = 1600, 
                _margins = {top: 30, left: 120, right: 30, bottom: 30}, 
                _svg, 
                _nodes, 
                _i = 0, 
                _duration = 300, 
                _bodyG, 
                _root; 
 
        _chart.render = function () { 
            if (!_svg) { 
                _svg = d3.select("body").append("svg") 
                        .attr("height", _height) 
                        .attr("width", _width); 
            } 
 
            renderBody(_svg); 
        }; 
 
        function renderBody(svg) { 
            if (!_bodyG) { 
                _bodyG = svg.append("g") 
                        .attr("class", "body") 
                        .attr("transform", function (d) { 
                            return "translate(" + _margins.left 
                                    + "," + _margins.top + ")"; 
                        }); 
            } 
 
            _root = d3.hierarchy(_nodes); // &lt;-A 
 
            render(_root); 
        } 
 
        function render(root) { 
            var tree = d3.tree() // &lt;-B 
                        .size([ 
                            (_height - _margins.top - _margins.bottom), 
                            (_width - _margins.left - _margins.right) 
                        ]); 
 
            tree(root); // &lt;-C 
 
            renderNodes(root); // &lt;-D 
 
            renderLinks(root); // &lt;-E 
        } 
 
  function renderNodes(nodes, source) { 
    // will be explained in the 'how it works...' section 
    ... 
  } 
 
  function renderLinks(nodes, source) { 
    // will be explained in the 'how it works...' section 
    ... 
  } 
 
  // accessors omitted 
  ... 
 
  return _chart; 
} 
</pre><p>This recipe generates the following tree visualization:</p><p>
</p><div><img src="img/image_09_009.jpg" alt="How to do it..."/></div><p>
</p><p>Tree</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec200"/>How it works...</h2></div></div></div><p>As we have mentioned before, this recipe is built over the D3 tree layout. The <code class="literal">d3.tree</code> function is specifically designed to convert a hierarchical data structure into a visual layout data suitable for generating a tree graph. However, similar to the <em>Building a teemap</em>recipe, the <code class="literal">d3.tree</code> layout function only accepts structured D3 hierarchical data, meaning before we can use the layout function we need to use <code class="literal">d3.hierachy</code> to process and format our data first. Again, in this recipe, we are using the same Flare project package data we were using so far in this chapter. The raw JSON data source looks like this:</p><pre class="programlisting">{ 
 "name": "flare", 
 "children": [ 
  { 
   "name": "analytics", 
   "children": [ 
    { 
     "name": "cluster", 
     "children": [ 
      {"name": "AgglomerativeCluster", "size": 3938}, 
      {"name": "CommunityStructure", "size": 3812}, 
      {"name": "HierarchicalCluster", "size": 6714}, 
      {"name": "MergeEdge", "size": 743} 
     ] 
}, 
... 
} 
</pre><p>This data is loaded and passed into our chart object in the following function:</p><pre class="programlisting">function flare() { 
        d3.json("../../data/flare.json", function (nodes) { 
            chart.nodes(nodes).render(); 
        }); 
} 
</pre><p>Once the data is loaded, we first pass the loaded JSON data to d3.hierachy for processing (refer to line A):</p><pre class="programlisting">_root = d3.hierarchy(_nodes); // &lt;-A 
</pre><p>In this recipe, this is all we need since <code class="literal">d3.tree</code> layout only cares about the hierarchical relationship between nodes, therefore, there is no need to sum or order the data as we did in the <em>Build a treemap</em>recipe. Once processed, we can now create tree layout using the following code:</p><pre class="programlisting">var tree = d3.tree() // &lt;-B 
                .size([ 
                    (_height - _margins.top - _margins.bottom), 
                    (_width - _margins.left - _margins.right) 
                ]); 
</pre><p>The only setting we provided here is the size of our visualization, which is the size of our SVG image minus the margins. The <code class="literal">d3.tree</code> function will then take care of the rest and calculate every node's position accordingly. To use the tree layout, you simply need to invoke the layout function on line C.</p><pre class="programlisting">tree(root); // &lt;-C 
</pre><p>If you peek into the <code class="literal">nodes</code> layout data, it contains node data that will look like this:</p><p>
</p><div><img src="img/image_09_010.jpg" alt="How it works..."/></div><p>
</p><p>Tree layout data</p><p>Tree nodes are rendered in the <code class="literal">renderNode</code> function as follows:</p><pre class="programlisting">function renderNodes(root) { 
            var nodes = root.descendants(); 
 
            var nodeElements = _bodyG.selectAll("g.node") 
                    .data(nodes, function (d) { 
                                    return d.id || (d.id = ++_i); 
                                }); 
 
            var nodeEnter = nodeElements.enter().append("g") 
                    .attr("class", "node") 
                    .attr("transform", function (d) {  // &lt;-F 
                        return "translate(" + d.y 
                                + "," + d.x + ")"; 
                    }) 
                    .on("click", function (d) { // &lt;-G 
                        toggle(d); 
                        render(_root); 
                    }); 
 
            nodeEnter.append("circle") // &lt;-H 
                    .attr("r", 4); 
 
            var nodeUpdate = nodeEnter.merge(nodeElements) 
                .transition().duration(_duration) 
                .attr("transform", function (d) { 
                    return "translate(" + d.y + "," + d.x + ")"; // &lt;-I 
                }); 
 
            nodeUpdate.select('circle') 
                .style("fill", function (d) { 
                  return d._children ? "lightsteelblue" : "#fff"; // &lt;-J 
                }); 
 
            var nodeExit = nodeElements.exit() 
                    .transition().duration(_duration) 
                    .attr("transform", function (d) { 
                        return "translate(" + d.y 
                                + "," + d.x + ")"; 
                    }) 
                    .remove(); 
 
            nodeExit.select("circle") 
                    .attr("r", 1e-6) 
                    .remove(); 
 
            renderLabels(nodeEnter, nodeUpdate, nodeExit); 
} 
</pre><p>In this function, first we generate a set of <code class="literal">g.node</code> elements bound to <code class="literal">root.descendents()</code>:</p><pre class="programlisting">var nodes = root.descendants(); 
var nodeElements = _bodyG.selectAll("g.node") 
        .data(nodes, function (d) { 
            return d.id || (d.id = ++_i); 
        }); 
</pre><p>The <code class="literal">root.descendents</code> function returns all nodes in the hierarchical data. This is different from the <code class="literal">root.leaves</code> function we used in the <em>Build a treemap</em>recipe. The <code class="literal">root.leaves</code> function returns only the leaf nodes as a JavaScript array; however, with <code class="literal">d3.tree</code> layout, we not only care about the leaves but also any intermediary nodes in order to visualize the entire tree structure, and thus, we need to use <code class="literal">root.descendents</code> instead. At this point, we also assign an ID to each node using an index to obtain object constancy; refer to <a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em> for more information on object constancy in case this is a new concept to you;</p><pre class="programlisting">var nodeEnter = nodeElements.enter().append("g") 
            .attr("class", "node") 
            .attr("transform", function (d) {  // &lt;-F 
                return "translate(" + d.y 
                        + "," + d.x + ")"; 
            }) 
            .on("click", function (d) { // &lt;-G 
                toggle(d); 
                render(_root); 
            }); 
</pre><p>On line F, we created the nodes and moved them to the coordinates of <code class="literal">(d.y, d.x)</code> that the <code class="literal">d3.tree</code> layout has calculated for us. We switched <code class="literal">x</code> and <code class="literal">y</code> in this case since by default the <code class="literal">d3.tree</code> layout calculates coordinates in portrait mode while we want to render them in the landscape mode in this recipe. On line G, we also created <code class="literal">onClick</code> event handler to handle user mouse click on tree nodes. The <code class="literal">toggle</code> function consists of the following code:</p><pre class="programlisting">        function toggle(d) { 
            if (d.children) { 
                d._children = d.children; 
                d.children = null; 
            } else { 
                d.children = d._children; 
                d._children = null; 
            } 
        } 
</pre><p>This function effectively hides the children field on a given data node temporarily. Doing this essentially remove all children from that node in visualization and hence gives the users the sense of collapsing its subtree when they click on a node:</p><pre class="programlisting">nodeEnter.append("circle") // &lt;-H 
            .attr("r", 4); 
 
    var nodeUpdate = nodeEnter.merge(nodeElements) 
            .transition().duration(_duration) 
                .attr("transform", function (d) { 
                    return "translate(" + d.y + "," + d.x + ")"; // &lt;-I 
                }); 
 
    nodeUpdate.select('circle') 
            .style("fill", function (d) { 
                return d._children ? "lightsteelblue" : "#fff"; // &lt;-J 
         }); 
</pre><p>On line H, we created SVG circle element to represent each tree node, and again we position them at <code class="literal">(d.y, d.x)</code>. Finally, on line J, we colored the node with different fill based on whether it is collapsed or open by checking the temporary <code class="literal">_children</code> file generated by the <code class="literal">toggle</code> function. The rest of the node and label rendering code are quite simple, so we will not cover them line by line here; refer to the source code on GitHub for more details.</p><p>The next important function in this recipe is the <code class="literal">renderLinks</code> function. This function draws all the links that connect all the tree nodes we just created:</p><pre class="programlisting">function renderLinks(root) { 
            var nodes = root.descendants().slice(1); 
 
            var link = _bodyG.selectAll("path.link") 
                .data(nodes, function (d) { 
                    return d.id || (d.id = ++_i); 
                }); 
 
            link.enter().insert("path", "g") // &lt;-M 
                        .attr("class", "link") 
                    .merge(link) 
                    .transition().duration(_duration) 
                       .attr("d", function (d) { 
                        return generateLinkPath(d, d.parent); // &lt;-N 
                    }); 
 
            link.exit().remove(); 
} 
</pre><p>First, for rendering links, we use <code class="literal">root.descendants().slice(1)</code> as its data instead of <code class="literal">root.descendants()</code>. This is because for <code class="literal">n</code> nodes there are <code class="literal">n - 1</code> links since there is no link pointing to the root node in a tree. Once again, object constancy is used here to make our visualization more stable during re-rendering. Then, on line M, we created path elements to represent each link in our visualization. Now, the interesting part of this function lies in the <code class="literal">generateLinkPath</code> function on line N:</p><pre class="programlisting">function generateLinkPath(target, source) { 
    var path = d3.path(); 
    path.moveTo(target.y, target.x); 
    path.bezierCurveTo((target.y + source.y) / 2, target.x, 
            (target.y + source.y) / 2, source.x, source.y, source.x); 
    return path.toString(); 
} 
</pre><p>In this function, we use the <code class="literal">d3.path</code> generator to generate a Bezier curve that connects the source and target nodes. You can probably see that the usage of the <code class="literal">d3.path</code> generator is almost like describing how the line should be drawn. In this case, we moved the starting point of such line to <code class="literal">(target.y, target.x)</code> and then draw a Bezier curve with the given control points from target to source, as shown in the following illustration:</p><p>
</p><div><img src="img/image_09_011.jpg" alt="How it works..."/></div><p>
</p><p>Bezier curve</p><div><div><h3 class="title"><a id="note79"/>Note</h3><p>Of course, if you are familiar with the SVG path commands, then you can generate the d formula without using the <code class="literal">d3.path</code> generator. In this case, we are essentially using M and C commands. However, the <code class="literal">d3.path</code> generator function is more readable and works well with both SVG and Canvas, hence, it yields more maintainable code in general. For more information on SVG path command, refer to <a class="ulink" href="https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands">https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands
</a>.</p></div></div><p>At this point, we now have the entire tree graph visualized. As you can see with the help of the <code class="literal">d3.tree</code> layout, drawing this kind of complex visualization is relatively straightforward if not easy.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec201"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">d3.tree</code> offers several functions that allow customization. For more details, check out its API documentation at <a class="ulink" href="https://github.com/d3/d3-hierarchy/blob/master/README.md#tree">https://github.com/d3/d3-hierarchy/blob/master/README.md#tree
</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">d3.path</code> generator is capable of generating any arbitrary line on canvas and SVG; for more information, refer to its API document at <a class="ulink" href="https://github.com/d3/d3-path/blob/master/README.md#path">https://github.com/d3/d3-path/blob/master/README.md#path
</a>.</li><li class="listitem" style="list-style-type: disc">Refer to the <em>Animating multiple elements</em> recipe in <a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em>, for explanations on object constancy.</li><li class="listitem" style="list-style-type: disc">This recipe is inspired by Mike Bostock's Tidy Tree example, which you can find at <a class="ulink" href="http://bl.ocks.org/mbostock/4339184">http://bl.ocks.org/mbostock/4339184
</a>.</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Building an enclosure diagram</h1></div></div></div><p>An enclosure diagram is an interesting visualization of hierarchical data structures that use the recursive circle packing algorithm. It uses containment (nesting) to represent hierarchy. Circles are created for each leaf node in a data tree, while its size is proportional to a particular quantitative dimension of each data element. In this recipe, you will learn how to implement this kind of visualization using the D3 pack layout.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec202"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec203"/>How to do it...</h2></div></div></div><p>In this recipe, let's see how we can implement an enclosure diagram using <code class="literal">d3.pack</code>:</p><pre class="programlisting">function pack() { 
        var _chart = {}; 
 
        var _width = 1280, _height = 800, 
                _svg, 
                _valueAccessor, 
                _nodes, 
                _bodyG; 
 
        _chart.render = function () { 
            if (!_svg) { 
                _svg = d3.select("body").append("svg") 
                        .attr("height", _height) 
                        .attr("width", _width); 
            } 
 
            renderBody(_svg); 
        }; 
 
        function renderBody(svg) { 
          if (!_bodyG) { 
              _bodyG = svg.append("g") 
                      .attr("class", "body"); 
          } 
 
          var pack = d3.pack() // &lt;-A 
                  .size([_width, _height]); 
 
          var root = d3.hierarchy(_nodes) // &lt;-B 
                        .sum(_valueAccessor) 
                        .sort(function(a, b) {  
                          return b.value - a.value;  
                        }); 
 
          pack(root); // &lt;-C 
 
          renderCircles(root.descendants()); 
 
          renderLabels(root.descendants()); 
       } 
 
    function renderCircles(nodes) { 
      // will be explained in the 'how it works...' section 
      ... 
    } 
 
    function renderLabels(nodes) { 
      // omitted 
      ... 
    } 
 
    // accessors omitted 
    ... 
 
    return _chart; 
} 
</pre><p>This recipe generates the following visualization:</p><p>
</p><div><img src="img/image_09_012.jpg" alt="How to do it..."/></div><p>
</p><p>Enclosure diagram</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec204"/>How it works...</h2></div></div></div><p>In this recipe, we continue to use hierarchical JSON data source that describes Flare project package relationship. For more information on the data source, refer to the <em>Build a treemap</em> recipe in this chapter. The JSON data structure looks like the following:</p><pre class="programlisting">{ 
 "name": "flare", 
 "children": [ 
  { 
   "name": "analytics", 
   "children": [ 
    { 
     "name": "cluster", 
     "children": [ 
      {"name": "AgglomerativeCluster", "size": 3938}, 
      {"name": "CommunityStructure", "size": 3812}, 
      {"name": "HierarchicalCluster", "size": 6714}, 
      {"name": "MergeEdge", "size": 743} 
     ] 
    }, 
    ... 
   } 
  ] 
} 
</pre><p>This data is loaded into the chart object in the <code class="literal">flare</code> function:</p><pre class="programlisting">function flare() { 
    d3.json("../../data/flare.json", function (nodes) { 
       chart.nodes(nodes).valueAccessor(size).render(); 
    }); 
} 
</pre><p>In this visualization, the first thing we need to take care of is to define our layout; in this case, we need to use the <code class="literal">d3.pack</code> layout:</p><pre class="programlisting">var pack = d3.pack() // &lt;-A 
            .size([_width, _height]); 
</pre><p>We set the size of our visualization on layout so it can calculate accordingly. After that, before we can pass our JSON data to the <code class="literal">d3.pack</code> layout once again, we need to first process it using the <code class="literal">d3.hierachy</code> function (refer to line B), which is a prerequisite for any D3 hierarchical visualization:</p><pre class="programlisting">var root = d3.hierarchy(_nodes) // &lt;-B 
                .sum(_valueAccessor) 
                .sort(function(a, b) { return b.value - a.value; }); 
pack(root); // &lt;-C 
</pre><p>In this case, we <code class="literal">told d3.hierarchy</code> function to sum up all values using the <code class="literal">_valueAccessor</code> function, which takes <code class="literal">d.size</code> as the value by default. Additionally, we also asked the <code class="literal">d3.hierachy</code> function to sort the nodes based on the values. Finally, we then pass the processed data to the <code class="literal">pack</code> function on line C. The layout data after this process now look like this:</p><p>
</p><div><img src="img/image_09_013.jpg" alt="How it works..."/></div><p>
</p><p>Pack layout data</p><p>Circle rendering is done in the <code class="literal">renderCircle</code> function:</p><pre class="programlisting">function renderCircles(nodes) { // &lt;-C 
    var circles = _bodyG.selectAll("circle") 
            .data(nodes); 
    circles.enter().append("circle") 
            .merge(circles) 
            .transition() 
        .attr("class", function (d) { 
            return d.children ? "parent" : "child"; 
        }) 
        .attr("cx", function (d) {return d.x;}) // &lt;-D 
        .attr("cy", function (d) {return d.y;}) 
        .attr("r", function (d) {return d.r;}); 
    circles.exit().transition() 
            .attr("r", 0) 
            .remove(); 
} 
</pre><p>Then, we simply bind the layout data and create the <code class="literal">svg:circle</code> elements for each node. For update, we set <code class="literal">cx</code>, <code class="literal">cy</code>, and <code class="literal">radius</code> to the value that the pack layout has calculated for us for each circle (refer to line D). Finally, when removing  the circle, we reduce the size of the circle down to zero first, before removing them to generate a more smooth transition. Label rendering in this recipe is pretty straightforward with some help from the auto-hiding technique we introduced in this chapter, so we will not cover the function in detail here.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec205"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">d3.pack</code> function offers several functions that allow customization. For more details, please check out its API documentation at <a class="ulink" href="https://github.com/d3/d3-hierarchy/blob/master/README.md#pack">https://github.com/d3/d3-hierarchy/blob/master/README.md#pack
</a>.</li><li class="listitem" style="list-style-type: disc">The <em>Building a treemap</em> recipe for auto label hiding technique.</li><li class="listitem" style="list-style-type: disc">This recipe is inspired by Mike Bostock's pack layout example, which you can find at <a class="ulink" href="http://bl.ocks.org/mbostock/ca5b03a33affa4160321">http://bl.ocks.org/mbostock/ca5b03a33affa4160321
</a>.</li></ul></div></div></div></div></div></body></html>