- en: '[CHAPTER 5](toc.xhtml#c05)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[REST API for User Module](toc.xhtml#c05)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction](toc.xhtml#s142a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of any application lies the User module, a foundational component
    that orchestrates the management of user-centric features. This module allows
    users to administer the user accounts, enables authentication and authorization,
    and various user-specific operations, such as adding or registering users, updating
    user profiles, deleting users, password management, role-based permission, logging,
    and many more. The User module enhances the user experience and promotes the seamless
    operation of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s143a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Base Controller and Base Service for REST API development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role Management with Input Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User Management with Input Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User Onboarding
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: User Sign-In
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and Authorization Mechanism
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Update User Data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete User Account
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Password Management and Recovery with Email Notification
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Base Controller](toc.xhtml#s144a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in the previous chapter how we constructed individual controllers
    for each module. For each controller, there were some common methods, such as
    handlers for add, get all, get one, update, and so on. Since there is one controller
    for each entity, this set of common functions must be implemented by each controller.
    We could write an abstract class for the controllers to extend and force them
    to provide an implementation. Therefore, adhering to established norms, we are
    now introducing a foundational concept known as **Base Controller**. It is an
    abstract class that serves as a blueprint for other classes to inherit its predefined
    methods that facilitate operations like creating, updating, retrieving all, retrieving
    one, and deleting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `**base_controller.ts**` in the utils directory using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// base_controller.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { Request, Response } from ''express'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export abstract class BaseController {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public abstract addHandler(req: Request, res: Response): void;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public abstract getAllHandler(req: Request, res: Response): void;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public abstract getOneHandler(req: Request, res: Response): void;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public abstract updateHandler(req: Request, res: Response): void;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public abstract deleteHandler(req: Request, res: Response): void;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this abstract class is to furnish a uniform framework that other
    classes (controllers) can adhere to while implementing these methods. When a class
    extends the `**BaseController**`, it becomes obligatory to furnish implementations
    for these abstract methods. This practice guarantees that controllers across various
    routes maintain consistent method names and parameters, even though the specific
    execution details might vary.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that an individual controller can still write their own additional
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be downloaded from [https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/tree/main/ch-05-code-files](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/tree/main/ch-05-code-files)
  prefs: []
  type: TYPE_NORMAL
- en: '[Base Service](toc.xhtml#s145a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Base Service is a foundational structure that provides common functionalities
    for managing data operations in an application. It serves as a blueprint that
    other services can inherit to avoid repetitive code and ensure consistent patterns
    for data manipulation. The primary purpose of a base service is to encapsulate
    commonly used data operations, such as create, read, update, and delete, and make
    them available to other services. This reduces code duplication and enforces consistent
    practices across different modules of an application. Other services requiring
    data operations can inherit from the base service. By extending the base service,
    these child services gain access to the common methods defined in the base service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `**base_service.ts**` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/base_service.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/base_service.ts)`'
  prefs: []
  type: TYPE_NORMAL
- en: If you had downloaded the source code for this chapter, then you can find the
    `**base_service.ts**` inside. We have added comments for each method to explain
    what it does and how it works. This base service class provides common CRUD operations,
    `**findbyIds**`, and a custom query runner along with handling API responses and
    error cases. This service class can be inherited by other services.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to manage database connections efficiently. If we make separate
    database connections for each operation, the application would likely crash during
    high loads. Using a database pool is the best practice to limit and reuse the
    connections from a pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `**db.ts**` file using the following code for adding a database
    pool and to use a single connection in the whole app:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/db.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/db.ts)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `**connectDatabase**` function is responsible for establishing a database
    connection or returning an existing connection if available. It first checks if
    a valid connection already exists, and if not, it initializes a new connection
    and stores it for future use.
  prefs: []
  type: TYPE_NORMAL
- en: The `**getInstance**` function retrieves a database instance, ensuring it is
    connected before providing access. Unlike the `**connectDatabase**` function,
    `**getInstance**` waits until the connection is established before returning,
    ensuring that it can only be used once the connection is ready.
  prefs: []
  type: TYPE_NORMAL
- en: The `**getRepository**` function is designed to retrieve a repository instance
    for a given entity. It checks if a valid database connection exists and creates
    the repository instance if it doesn't already exist. If there's no valid connection,
    it returns null.
  prefs: []
  type: TYPE_NORMAL
- en: '[Role Management](toc.xhtml#s146a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Role management is a critical aspect of application security that involves controlling
    and defining the access and permissions of users within a system. It ensures that
    users have the appropriate rights to perform specific actions based on their roles
    or responsibilities. Role management is essential in preventing unauthorized access
    and data breaches and maintaining the overall integrity of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Different users have different levels of access and privileges. For example,
    an application might have different user roles such as `**Super Admin**`, `**Project
    Manager**`, and `**Guest**`, each with distinct sets of permissions. Admins typically
    have access to all features and functionalities, project managers have limited
    access, and guests might have very restricted access.
  prefs: []
  type: TYPE_NORMAL
- en: '[Role Service](toc.xhtml#s147a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Role Service will be used to perform role-based operations in a database that
    extends from the base service. So, let''s create the `**roles_service.ts**` file
    in the roles component using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// role_service.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { Repository } from ''typeorm'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { BaseService } from ''../../utils/base_service'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { DatabaseUtil } from ''../../utils/db'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { Roles } from ''./roles_entity'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export class RolesService extends BaseService<Roles> {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor() {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Create an instance of DatabaseUtil`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const databaseUtil = new DatabaseUtil();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Get the repository for the Roles entity`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const roleRepository: Repository<Roles> = databaseUtil.getRepository(Roles);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Call the constructor of the BaseService class with the`'
  prefs: []
  type: TYPE_NORMAL
- en: '`repository as a parameter`'
  prefs: []
  type: TYPE_NORMAL
- en: '`super(roleRepository);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: The `**RolesService**` class is designed to extend the functionality provided
    by the `**BaseService**` class. It uses the `**DatabaseUtil**` class to get the
    repository for the `**Roles**` entity and then passes that repository to the constructor
    of the `**BaseService**` class. This allows the `**RolesService**` class to inherit
    and use the CRUD methods defined in the `**BaseService**` class for working with
    the `**Roles**` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will develop the REST API for roles as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add Roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get All Roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GetOne Role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update Role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete Role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before developing the actual **Add Role** API, we need to define input validation
    for roles while adding them to the database. So, let's use an Express Validator
    to validate input requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[Input Validation](toc.xhtml#s148a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, install the Express Validator module so paste the following command
    in `**cmd**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm i express-validator --save`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create the `**validator.ts**` file in the utils directory using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/validator.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/validator.ts)`'
  prefs: []
  type: TYPE_NORMAL
- en: The provided code exports a function named `**validate**` that generates `**middleware**`
    for validating request data using the express-validator package. This middleware
    function runs the provided validation functions, checks for validation errors
    using `**validationResult**`, and sends a response with a 400 status and error
    messages if validation fails. The structure of the error messages aligns with
    the `**IValidationError**` interface. This approach is commonly used to handle
    request validation in Express applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the `**validRoleInput**` in the `**roles_routers.ts**` file using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// roles_routers.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { Express } from ''express'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { RoleController, RolesUtil } from ''./roles_controller'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { validate } from ''../../utils/validator'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { body } from ''express-validator'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const validRoleInput = [`'
  prefs: []
  type: TYPE_NORMAL
- en: '`body(''name'').trim().notEmpty().withMessage(''It should be required''),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`body(''description'').isLength({ max: 200 }).withMessage(''It has`'
  prefs: []
  type: TYPE_NORMAL
- en: '`maximum limit of 200 characters''),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`];`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export class RoleRoutes {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`private baseEndPoint = ''/api/roles'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor(app: Express) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const controller = new RoleController();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.route(this.baseEndPoint)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.get(controller.getAllHandler)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.post(validate(validRoleInput), controller.addHandler);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.route(this.baseEndPoint + ''/:id'')`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.get(controller.getOneHandler)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.put(validate(validRoleInput), controller.updateHandler)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.delete(controller.deleteHandler);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding class, the `**baseEndPoint**` variable is used. This is part
    of the API endpoints, which is going to be the same for all of the role APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `**validRoleInput**` variable, which is an array. This array contains
    a series of validation checks for each input field expected in a role. Each element
    of this array is a validator function that checks a specific aspect of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The validator for the `**name**` field in request body would be processed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`body(''name'').trim().notEmpty().withMessage(''It should be required'')`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This validator is applied to the `**name**` field in the request body and performs
    the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**trim()**`: Removes any leading and trailing whitespace from the input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**notEmpty()**`: Checks that the input is not empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**withMessage(''It should be required'')**`: If the validation fails, this
    message will be included in the error response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, the validator for the `**description**` field would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`body(''description'').isLength({ max: 200 }).withMessage(''It has a maximum
    limit of 200 characters'')`'
  prefs: []
  type: TYPE_NORMAL
- en: This validator is applied to the `**description**` field in the request body.
    It checks that the length of the input does not exceed `**200**` characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, this code defines a set of validation rules for different fields of
    role data, including checking for the presence, length, and validity of access
    rights. If any of the validations fail, the corresponding error message will be
    included in the error response with status code `**400: bad**` request.'
  prefs: []
  type: TYPE_NORMAL
- en: Each role consists of a set of rights. These rights are nothing but string keys,
    which can help us to understand whether a logged-in user has a particular right
    assigned to let them do a corresponding task. A right for adding a task could
    be as simple as `**add_task**`, which could be added to the role assigned to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define all of the necessary application rights in `**common.ts**` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/common.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/common.ts)`'
  prefs: []
  type: TYPE_NORMAL
- en: These rights are application rights, which are used to check permission during
    user login based on the assigned Role. When a role is created, it has a rights
    value that is saved as comma-separated from these application rights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `**RolesUtil**` class with `**getAllPermissionsFromRights**`
    function in the `**role_controller.ts**` file using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// role_controller.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export class RolesUtil {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/**`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* Retrieves all possible permissions from the defined rights in the Rights
    object.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* @returns {string[]} An array of permissions`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static getAllPermissionsFromRights(): string[] {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Initialize an empty array to collect values;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let permissions = [];`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Iterate through each section of the Rights object`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for (const module in Rights) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Check if rights for ALL are defined for the current module`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (Rights[module][''ALL'']) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let sectionValues = Rights[module][''ALL''];`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sectionValues = sectionValues.split('','');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`permissions = […permissions, …sectionValues];`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Return the collected permissions`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return permissions;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: This function effectively compiles all the available permissions from the defined
    Rights object, which can then be used for validation and other purposes in the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add validation for the `**rights**` field in `**validRoleInput**` using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const validRoleInput = [`'
  prefs: []
  type: TYPE_NORMAL
- en: '`body(''name'').trim().notEmpty().withMessage(''It should be required''),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`body(''description'').isLength({ max: 200 }).withMessage(''It has maximum
    limit of 200 characters''),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`body(''rights'').custom((value: string) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const accessRights = value?.split('','');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (accessRights?.length > 0) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const validRights = RolesUtil.getAllPermissionsFromRights();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const areAllRightsValid = accessRights.every(right =>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`validRights.includes(right));`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (!areAllRightsValid) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`throw new Error(''Invalid permission'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return true; // Validation passed`'
  prefs: []
  type: TYPE_NORMAL
- en: '`})`'
  prefs: []
  type: TYPE_NORMAL
- en: '`];`'
  prefs: []
  type: TYPE_NORMAL
- en: Based on the provided code, the custom validation function ensures the validity
    of rights during the process of adding or updating a role. It evaluates the rights
    received in the request and verifies whether they are valid or not. If any of
    the rights are found to be invalid, an error is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[Add Role](toc.xhtml#s149a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the REST API to add a role, you typically provide the necessary data
    in the request body, such as the role's name, description, and the rights it should
    have. The API endpoint responsible for this action is designed to receive this
    data, validate it according to predefined rules, and create a new role based on
    the provided information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already created `**roles_controller.ts**` as a skeleton class. Now,
    let''s change it with an extended Base Controller and use the base service to
    perform database operations using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// roles_controller.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { Response, Request } from ''express'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { RolesService } from ''./roles_service'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { BaseController } from ''../../utils/base_controller'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { Rights } from ''../../utils/common'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export class RoleController extends BaseController {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public async addHandler(req: Request, res: Response): Promise<void> {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const role = req.body;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const service = new RolesService();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const result = await service.create(role);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.status(result.statusCode).json(result);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0][PRE1]``js[PRE2]`` `{`    `"statusCode": 200,`    `"status": "success",`    `"data":
    [`    `{`    `"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",`    `"name":
    "visitor",`    `"description": null,`    `"rights": null,`    `"created_at": "2023-08-15T13:04:50.314Z",`    `"updated_at":
    "2023-08-15T13:04:50.314Z"`    `}`    `]`    `}`    **Note**: In base service,
    query params will now be applicable for only exact matches. We will explore search
    functionality later on.    # [GetOne Role](toc.xhtml#s151a)    GetOne role endpoint
    is a fundamental part of role management systems, allowing users to view specific
    role information without having to retrieve the entire list of roles. It''s essential
    for providing targeted insights into each role''s attributes and permissions.    To
    implement the GetOne Role API, make the following changes in the `**getOneHandler**`
    code in the role controller:    `// roles_controller.ts`    `public async getOneHandler(req:
    Request, res: Response): Promise<void> {`    `const service = new RolesService();`    `const
    result = await service.findOne(req.params.id);`    `res.status(result.statusCode).json(result);`    `}`    The
    `**getOneHandler**` function serves as the bridge between the incoming client
    request, the service layer that interacts with the database, and the outgoing
    HTTP response. It retrieves a single role''s details from the database based on
    the provided role ID and sends the role information back to the client.    This
    method called from the routes file with making a new route for it as follows:    `//
    roles_routes.ts`    `app.route(this.baseEndPoint + ''/:id'')`    `.get(controller.getOneHandler);`    Here**,**
    `**/:id**` will be a request parameter meant to capture the ID of the role that
    the user wants to retrieve.    **REST API** `**GetOne**` **Role**    **Request**    `URL:
    http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238`    `Method:
    GET`    **Response**    `{`    `"statusCode": 200,`    `"status": "success",`    `"data":
    {`    `"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",`    `"name": "visitor",`    `"description":
    null,`    `"rights": null,`    `"created_at": "2023-08-15T13:04:50.314Z",`    `"updated_at":
    "2023-08-15T13:04:50.314Z"`    `}`    `}`    Providing a valid role ID will yield
    a successful response, while inputting an ID that doesn''t correspond to an existing
    database entry will result in a `**404 error**`, signifying that the requested
    entity was not found.    `{`    `"statusCode": 404,`    `"status": "error",`    `"message":
    "Not Found"`    `}`    # [Update Role](toc.xhtml#s152a)    Updating a role involves
    modifying the existing data of a specific role stored in the database. This process
    allows you to adjust the attributes of a role, such as its name, description,
    and associated rights. By performing an update, you can ensure that the role''s
    information remains accurate and up-to-date. This operation is particularly useful
    when there are changes in a role''s permissions, and you need to reflect those
    changes in the database.    To implement the Update Role API, make the following
    changes in the `**updateHandler**` code in the role controller:    `// roles_controller.ts`    `public
    async updateHandler(req: Request, res: Response) : Promise<void> {`    `const
    role = req.body;`    `const service = new RolesService();`    `const result =
    await service.update(req.params.id, role);`    `res.status(result.statusCode).json(result);`    `}`    The
    `**updateHandler**` function is intended to handle the updating of a role in the
    database.    It operates by retrieving data from the incoming HTTP request body,
    which is then utilized to update the corresponding role data in the database based
    on the role''s unique identifier (`**role_id**`) as request parameter ID. The
    function subsequently generates a response indicating whether the update operation
    was successful or unsuccessful, providing details about the updated data or an
    appropriate error message if needed.    This method called from the routes file
    with making a new route for it as follows:    `// roles_routes.ts`    `app.route(this.baseEndPoint
    + ''/:id'')`    `.get(controller.getOneHandler)`    `.put(validate(validRoleInput),
    controller.updateHandler);`    Here, `**/:id**` will be a request parameter meant
    to capture the ID of the role that the user wants to retrieve, and it also validates
    data before updating in the database.    **REST API Update Role**    **Request**    `URL:
    http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238`    `Method:
    PUT`    `body :`    `{`    `"name":"visitor",`    `"Description":"Allow read projects",`    `"rights":
    "get_all_projects,get_details_project"`    `}`    **Response**    `{`    `"statusCode":
    200,`    `"status": "success",`    `"data": {`    `"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",`    `"name":
    "visitor",`    `"description": null,`    `"created_at": "2023-08-15T13:04:50.314Z",`    `"updated_at":
    "2023-08-18T07:35:06.238Z",`    `"rights": "get_all_projects,get_details_project"`    `}`    `}`    Providing
    a valid role ID will yield a successful response, while inputting an ID that doesn''t
    correspond to an existing database entry will result in a `**404 error**`, signifying
    that the requested entity was not found.    `{`    `"statusCode": 404,`    `"status":
    "error",`    `"message": "Not Found"`    `}`    # [Delete Role](toc.xhtml#s153a)    The
    `**delete**` functionality for roles in a REST API involves the removal of a specific
    role from the database. This process is managed through an endpoint dedicated
    to role deletion. When a request is made to this endpoint, it triggers a function
    that handles the deletion process. The incoming request typically contains the
    unique identifier (`**role_id**`) of the role that needs to be deleted.    To
    implement `**Delete**` Role API, make the following changes in the `**deleteHandler**`
    code in the role controller:    `// roles_controller.ts`    `public async deleteHandler(req:
    Request, res: Response) : Promise<void> {`    `const service = new RolesService();`    `const
    result = await service.delete(req.params.id);`    `res.status(result.statusCode).json(result);`    `}`    The
    `**deleteHandler**` processes the request by utilizing a service that interacts
    with the database. This service is responsible for executing the deletion operation.
    If the requested role exists in the database and the deletion is successful, the
    function responds with a success message and an appropriate status code, such
    as `**200 OK**`. If the role does not exist, the function returns an error response
    with a status code of 404 Not Found, indicating that the role was not located
    in the database.    This method called from the routes file with making a new
    route for it as follows:    `// roles_routes.ts`    `app.route(this.baseEndPoint
    + ''/:id'')`    `.get(controller.getOneHandler)`    `.put(validate(validRoleInput),
    controller.updateHandler)`    `.delete(controller.deleteHandler);`    Here, `**/:id**`
    will be a request parameter meant to capture the ID of the role that the user
    wants to delete.    **REST API Delete Role**    **Request**    `URL: http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238`    `Method:
    DELETE`    **Response**    `{`    `"statusCode": 200,`    `"status": "success"`    `}`    In
    case of already deleted or not exist in database:    `{`    `"statusCode": 404,`    `"status":
    "error",`    `"message": "Not Found"`    `}`    # [Add Default Role from System](toc.xhtml#s154a)    After
    implementing APIs related to roles, let''s add a feature to create a default role
    for `**SuperAdmin**` who has all rights in the system during project initialization.
    This additional functionality can be utilized later for authorization purposes.    Create
    one file in utils directory with name `**ddl_util.ts**` with the following code:    `[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/ddl_util.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/ddl_util.ts)`    This
    DDLUtil class contains a static method addDefaultRole() responsible for adding
    a default role to the system.    Now do following changes in main.ts file:    `[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/main.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/main.ts)`    As
    per code, it checks if command-line arguments are provided and if the first argument
    is `**--init**`. If these conditions are met, an asynchronous function is immediately
    invoked using an async function. It awaits the execution of `**DDLUtil.addDefaultRole()**`,
    which presumably initializes a default role in the system. Once `**addDefaultRole()**`
    completes, `**process.exit()**` is called to terminate the Node.js process. In
    summary, this code block is responsible for initializing a default role in the
    system when the program is run with the `**--init**` flag, and then exiting the
    process afterward.  ![](img/5.2.jpg)  **Figure 5.2:** Invoke Add Default Role
    Script    **Output:**  ![](img/5.3.jpg)  **Figure 5.3:** Postgres Added Role Output    In
    summary, role management plays a critical role in ensuring the security and controlled
    access of users within a system. It allows organizations to define and assign
    specific permissions and rights to different user roles, ensuring that each user
    can only perform actions that are relevant to their role and responsibilities.    #
    [User Management](toc.xhtml#s155a)    User management refers to the process of
    handling user-related functionalities in an application. This includes creating,
    updating, retrieving, and deleting user accounts, as well as managing user roles,
    permissions, and authentication. User management is a crucial aspect of many applications,
    especially those that require user registration, authentication, and authorization.    #
    [User Service](toc.xhtml#s156a)    Let''s create the first user service to perform
    user table operations. Create `**users_service.ts**` using the following code:    `//
    users_service.ts`    `import { Repository } from ''typeorm'';`    `import { BaseService
    } from ''../../utils/base_service'';`    `import { DatabaseUtil } from ''../../utils/db'';`    `import
    { Users } from ''./users_entity'';`    `export class UsersService extends BaseService<Users>
    {`   [PRE3]`` `constructor() {`    `let userRepository: Repository<Users> | null
    = null;`    `userRepository = new DatabaseUtil().getRepository(Users);`    `super(userRepository);`    `}`    `}`    The
    `**UsersService**` class is designed to extend the functionality provided by the
    `**BaseService**` class. It uses the `**DatabaseUtil**` class to get the repository
    for the User entity and then passes that repository to the constructor of the
    `**BaseService**` class. This allows the `**UsersService**` class to inherit and
    use the CRUD methods defined in the `**BaseService**` class for working with the
    Users entity.    # [Input Validation](toc.xhtml#s157a)    User input validation
    is a crucial aspect of developing web applications to ensure data integrity, security,
    and a smooth user experience. It involves checking and sanitizing the data submitted
    by users through various input fields, such as `**email**`, `**username**`, `**password**`,
    `**role**`, and so on.    Now add `**validUserInput**` in the `**users_routes.ts**`
    file using the following code:    `// user_routes.ts`    `import { body } from
    ''express-validator'';`    `import { validate } from ''../../utils/validator'';`    `const
    validUserInput = [`    `body(''username'').trim().notEmpty().withMessage(''It
    should be required''),`    `body(''email'').isEmail().withMessage(''It should
    be valid emailId''),`    `body(''password'')`    `.isLength({ min: 6, max: 12
    }).withMessage(''It must be between 6 and 12 characters in length'')`    `.isStrongPassword({
    minLowercase: 1, minUppercase: 1,`    `minSymbols: 1, minNumbers: 1 })`    `.withMessage(''It
    should include at least one uppercase letter, one lowercase letter, one special
    symbol, and one numerical digit.''),`    `body(''role_ids'').isArray().withMessage(''It
    must be an array of uuids of roles'')`    `.custom((value: string[]) => {`    `if
    (value?.length > 0 && value instanceof Array) {`    `const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;`    `const
    isValid = value?.every(uuid => uuidPattern.test(uuid.trim()));`    `if (!isValid)
    {`    `throw new Error(''It has invalid uuids for role'');`    `}`    `}`    `return
    true; // Validation passed`    `})`    `];`    *   `**validUserInput**` array:
    This array contains a series of validation checks for each input field expected
    in a user. Each element of this array is a validator function that checks a specific
    aspect of the data. *   `**body(''username'').trim().notEmpty().withMessage(''It
    should be required'')**`: This validator is applied to the username field in the
    request body. It removes any leading and trailing whitespace from the input and
    checks that the input is not empty. If the validation fails, this message will
    be included in the error response. *   `**body(''email'').isEmail().withMessage(''It
    should be valid emailId'')**`: This validator is applied to the email field in
    the request body. It checks if a valid email ID is provided or not. If the validation
    fails, it displays a message as given in `**withMessage**`. *   `**body(''password'').isLength({
    min: 6, max: 12 }).withMessage(''It must be between 6 and 12 characters in length'').isStrongPassword({
    minLowercase: 1, minUppercase: 1, minSymbols: 1, minNumbers: 1 }).withMessage(''It
    should include at least one uppercase letter, one lowercase letter, one special
    symbol, and one numerical digit.'')**`: This validator is applied to the password
    field. It checks that the password should be between 6 and 12 characters long
    and have strong passwords as specified in the given option. If the validation
    fails, it gives a defined error message. *   `**body(''role_ids'')…**` : It validates
    the given `**role_ids**` array of UUIDs or not. If any of them are not matched
    in the db, it gives an error.    # [User Onboarding](toc.xhtml#s158a)    In PMS,
    a user onboarding facility is provided by a super admin or someone who has permission
    to add users to the system. First, we create one master or super admin user who
    has all rights, meaning we assign a role that has each and every right. We have
    already created a super admin role, so we will assign that `**role_id**` to the
    user and create a super admin user.    We will store the user''s password in the
    database in an encrypted form instead of plain text for security reasons. So,
    we will install an npm package and encryption function, and then compare encrypted
    password validation during login.    To begin, open the terminal with the root
    directory of the project and paste the following command:    `npm install bcrypt
    --save`    Next, open the `**common.ts**` file and add the following functions:    `//
    common.ts`    `/**`    `* Encrypts a string using bcrypt hashing.`    `*`    `*
    @param {string} s - The string to be encrypted.`    `* @returns {Promise<string>}
    - The encrypted string.`    `*/`    `export const encryptString = async (s: string)
    => {`    `const encryptedString = await bcrypt.hash(s, 8);`    `return encryptedString;`    `};`    `/**`    `*
    Compares a plain string with a bcrypt hash to determine if they match.`    `*`    `*
    @param {string} s - The plain string to be compared.`    `* @param {string} hash
    - The bcrypt hash to compare against.`    `* @returns {Promise<boolean>} - A promise
    that resolves to true if the comparison is successful, otherwise false.`    `*/`    `export
    const bcryptCompare = async (s, hash) => {`    `return await bcrypt.compare(s,
    hash);`    `};`    The `**encryptString**` function takes a string as input and
    uses the `**bcrypt.hash**` function to perform a one-way hashing with a cost factor
    of 8\. The result is an encrypted string that can be stored securely, The async
    keyword indicates that the function is asynchronous, meaning it returns a promise
    that resolves to the encrypted string once the hashing is complete.    The `**bcryptCompare**`
    function takes a plain string and a `**bcrypt**` hash as input. It uses the `**bcrypt.compare**`
    function to compare the plain string with the provided hash. The function returns
    a promise that resolves to true if the comparison is successful (that is, the
    plain string matches the hash), and false otherwise. This comparison is used for
    verifying passwords during authentication processes. The async keyword indicates
    that the function is asynchronous, meaning it returns a promise that holds the
    comparison result.    In `**validUserInput**`, we have seen that we just check
    if the `**role_ids**` field has a value in array form. However, it is necessary
    to check whether these role IDs exist in the db or not before user insertion in
    the db. So, we will create the `**checkValidRoleIds**` function in `**RolesUtil**`
    class.    `public static async checkValidRoleIds(role_ids: string[]) {`    `const
    roleService = new RolesService();`    `// Query the database to check if all role_ids
    are valid`    `const roles = await roleService.findByIds(role_ids);`    `// Check
    if all role_ids are found in the database`    `return roles.data.length === role_ids.length;`    `}`    It
    queries the database using the `**findByIds**` method from the `**roleService**`
    instance to retrieve roles based on the provided role IDs, and then it checks
    whether the number of roles retrieved from the database matches the number of
    input role IDs. If they match, it indicates that all the provided role IDs are
    valid; otherwise, it implies that it is not valid `**role_ids**`.    Let''s update
    the `**users_controller.ts**` file using the following code:    `[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/components/users/users_controller.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/components/users/users_controller.ts)`    This
    function appears to handle the addition of a new user by processing the user data,
    encrypting the password, and checking the validity of role IDs before creating
    the user using a service class. It also handles errors gracefully by providing
    appropriate error responses.    Now call `**addHandler**` in user routes with
    change in the `**users_router.ts**` file as follows:    `// users_routes.ts`    `export
    class UserRoutes {`    `private baseEndPoint = ''/api/users'';`    `constructor(app:
    Express) {`    `const controller = new UserController();`    `app.route(this.baseEndPoint)`    `.post(validate(validUserInput),
    controller.addHandler);`    `}`    This way we created an add user router with
    input validation for user onboarding through middleware of validation. If validation
    happens successfully, then the user is inserted in the database.    **REST API
    Add User**    **Request**    `URL: http://127.0.0.1:`    `Method: POST`    `body
    :`    `{`    `"fullname":"Super Admin",`    `"username":"pms-admin",`    `"email":"admin@pms.com",`    `"password":"Admin@pms1",`    `"role_ids":["b88cc70d-ab0a-4464-9562-f6320df519f6"]`    `}`    **Response**    `{`    `"statusCode":
    201,`    `"status": "success",`    `"data": {`    `"user_id": "f249e681-57d8-4f91-addd-a8c615b43a37",`    `"fullname":
    "Super Admin",`    `"username": "pms-admin",`    `"email": "admin@pms.com",`    `"password":
    "$2b$08$pSsEBELbLrXjDfqBJY/7EuyygVuqDzLyBA0JO8pPnWDYJYp5.O15G",`    `"role_ids":
    [`    `"b88cc70d-ab0a-4464-9562-f6320df519f6"`    `],`    `"created_at": "2023-08-19T18:12:55.315Z",`    `"updated_at":
    "2023-08-19T18:12:55.315Z"`    `}`    `}`    In case, if the `**role_id**` has
    the wrong UUID or does not exist in the role table, then it gives an error with
    status `**400**` as follows:    `{`    `"statusCode": 400,`    `"status": "error",`    `"message":
    "Invalid role_ids"`    `}`    Here, we onboarded super admin. This admin similarly
    adds other users and shares their credentials manually with them. Afterward, users
    can change their own password, which we will cover later on.    # [Add Default
    User from System](toc.xhtml#s159a)    After establishing the default role, let''s
    proceed to create a default user with super admin privileges, granting access
    to all APIs associated with the default role.    Create one `**addDefaultUser**`
    method in `**ddl_util.ts**` file with the following code:    `public static async
    addDefaultUser(): Promise<boolean> {`    `try {`    `await DatabaseUtil.getInstance();`    `const
    service = new UsersService();`    `const user: Users = {`    `user_id: v4(),`    `fullname:
    ''Super Admin'',`    `username: ''superadmin'',`    `email: config.default_user.email,`    `password:
    await encryptString(config.default_user.password),`    `role_id: this.superAdminRoleId,`    `created_at:
    new Date(),`    `updated_at: new Date()`    `};`    `const result = await service.create(user);`    `console.log(''Add
    Default User Result'', result);`    `if (result.statusCode === 201) {`    `return
    true;`    `}`    `return false;`    `} catch (error) {`    ``console.error(`Error
    while addDefaultRole() =>``    ``${error.message}`);``    `return false;`    `}`    `}`    Here,
    we added the default user''s email and password in `**server_config.json**` file
    and used it from there, so you can add it in a similar manner as per your convenience.    This
    function is invoked from the `**main.ts**` file, after creating the default role,
    as follows:    `if (args.length > 0 && args[0] === ''--init'') {`    `(async ()
    => {`    `await DatabaseUtil.getInstance();`    `await DDLUtil.addDefaultRole();`    `await
    DDLUtil.addDefaultUser();`    `process.exit();`    `})();`    `}`    Now run the
    script and see the following output:  ![](img/5.4.jpg)  **Figure 5.4:** Add Default
    User from Script    Output:  ![](img/5.5.jpg)  **Figure 5.5:** Postgres Database
    Added User Output    # [User Sign-In](toc.xhtml#s160a)    Once the user registration
    process is completed, users should have the capability to log into the application.
    As a component of the user sign-in procedure, an API will be established to enable
    users to request the server using their email and password. The server''s role
    is to verify whether the user exists and if the provided password is valid. If
    the validation fails, an error response is generated. However, if the validation
    is successful, the server responds with both an access token and a refresh token.
    This entire process is known as **authentication**.    Upon successful login,
    each subsequent API request must incorporate the access token in the request header.
    The server''s task at this point is to verify the validity of the token. If the
    token is invalid, an error response is generated, preventing further actions.
    Conversely, if the token is valid, the server grants permission for the requested
    actions to be executed. This aspect of validating the access token and permitting
    or denying actions is referred to as **authorization**.    To create `**AccessToken**`,
    we will use the `**jsonwebtoken**`, also known as JWT token. First, you will need
    to install the npm package. For more information, please visit [https://www.npmjs.com/package/jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken)    Open
    the terminal with the root directory and paste the following command:    `npm
    install jsonwebtoken -- save`    `npm install @types/jsonwebtoken -D`    Here
    is a general overview of how JWT works:    *   **Token Structure**: A JWT consists
    of three parts: header, payload, and signature. These parts are base64-encoded
    and combined with periods.     *   **Header**: Contains info about the signing
    algorithm and token type.     *   **Payload**: Contains claims (user info, expiration
    time, and so on).     *   **Signature**: Used for verification and to ensure data
    integrity. *   **Token Creation**: When a user logs in, the server constructs
    the header and payload, including user details and other info. The server signs
    the JWT using a secret key or private key. *   **Token Issuance**: The server
    sends the JWT to the client after successful login. The client stores it, often
    in cookies or local storage. *   **Token Usage**: In subsequent requests, the
    client sends the JWT in the Authorization header or as a parameter. This helps
    the server verify the request''s authenticity and identify the user by decoding
    the payload. *   **Token Verification:** The server verifies the JWT by recalculating
    the signature using the same key. If the recalculated signature matches the JWT''s
    signature, the token is valid. *   **Token Expiration**: JWTs usually have an
    expiration time (exp claim) to prevent indefinite validity. Servers can reject
    expired tokens by checking the expiration time in the payload. *   **Token Revocation
    (Optional)**: JWTs are stateless, meaning the server doesn''t keep track of them
    after issuing. If you need to revoke a JWT before it expires, extra measures like
    maintaining a list of revoked tokens are required.    Remember, the security of
    JWTs relies on protecting the secret key (or private key) and ensuring proper
    token verification on the server side.    Let''s define constants for JWT secret
    and expiration times in the `**common.ts**` file as follows:    `// common.ts`    `export
    const SERVER_CONST = {`    `JWTSECRET: ''SecretKeyOfPMS-SECRET'',`    `ACCESS_TOKEN_EXPIRY_TIME_SECONDS:
    1 * 8 * 60 * 60, // 8 hours`    `REFRESH_TOKEN_EXPIRY_TIME_SECONDS: 5 * 7 * 24
    * 60 * 60, // one week`    `};`    The mentioned parameters are flexible and adaptable
    according to your needs.    # [Authentication](toc.xhtml#s161a)    In the standard
    login process, two tokens are usually created: an access token and a refresh token,
    each having distinct expiration times. The access token has a shorter lifespan,
    while the refresh token has a longer one. If the access token expires, the refresh
    token can be used to generate a new access token, facilitating seamless reauthentication
    without requiring manual login. This approach ensures continuous access without
    interruption.    This process is called **Authentication** in terms of generation
    of tokens.    Let''s create login function in the `**users_controller.ts**` file
    as follows:    `// user_controller.ts`    `import * as jwt from ''jsonwebtoken'';`   [PRE4]`
    `/**`    `* Handles user login by checking credentials, generating tokens, and
    responding with tokens.`    `*`    `* @param {Request} req - The request object.`    `*
    @param {Response} res - The response object.`    `*/`    `public async login(req:
    Request, res: Response): Promise<void> {`    `const { email, password } = req.body;`    `const
    service = new UsersService();`    `// Find user by email`    `const result = await
    service.findAll({ email: email });`    `if (result.data.length < 1) {`    `res.status(404).json({
    statusCode: 404, status: ''error'', message: ''Email`    `not found'' });`    `return;`    `}
    else {`    `const user = result.data[0];`    `// Compare provided password with
    stored hashed password`    `const comparePasswords = await bcryptCompare(password,
    user.password);`    `if (!comparePasswords) {`    `res.status(400).json({ statusCode:
    400, status: ''error'', message: ''Password is not valid'' });`    `return;`    `}`    `//
    Generate access and refresh tokens`    `const accessToken: string = jwt.sign({`    `email:
    user.email,`    `username: user.username`    `}, SERVER_CONST.JWTSECRET, { expiresIn:`    `SERVER_CONST.ACCESS_TOKEN_EXPIRY_TIME_SECONDS
    });`    `const refreshToken: string = jwt.sign({`    `email: user.email,`    `username:
    user.username`    `}, SERVER_CONST.JWTSECRET, { expiresIn:`    `SERVER_CONST.REFRESH_TOKEN_EXPIRY_TIME_SECONDS
    });`    `// Respond with tokens`    `res.status(200).json({ statusCode: 200, status:
    ''success'', data: {`    `accessToken, refreshToken } });`    `return;`    `}`    `}`    In
    this code, the login function handles user login functionality using the following
    steps:    *   It receives the email and password from the request body. *   It
    creates an instance of the `**UsersService**` class to interact with user data.
    *   It queries the database to find a user based on the provided email. *   If
    no user is found with the provided email, it sends a 404 error response. *   If
    a user is found, it compares the provided password with the hashed password stored
    in the user''s data. If the passwords don''t match, it sends a 400 error response.
    *   If the passwords match, it generates an access token and a refresh token using
    the `**jwt.sign**` function. The access token contains user information and has
    a short expiration time, while the refresh token has a longer expiration time.
    *   It sends a success response (status `**200**`) containing the generated access
    and refresh tokens.    Now add another function `**getAccessTokenFromRefreshToken**`
    in the same file using the following code:    `/**`    `* Generates a new access
    token using a valid refresh token.`    `*`    `* @param {Request} req - The request
    object.`    `* @param {Response} res - The response object.`    `*/`    `public
    async getAccessTokenFromRefreshToken(req: Request, res:`    `Response): Promise<void>
    {`    `// Get the refresh token from the request body`    `const refreshToken
    = req.body.refreshToken;`    `// Verify the refresh token`    `jwt.verify(refreshToken,
    SERVER_CONST.JWTSECRET, (err, user) => {`    `if (err) {`    `// If refresh token
    is invalid, send a 403 error response`    `res.status(403).json({ statusCode:
    403, status:`    `''error'', message: ''Invalid Refresh Token'' });`    `return;`    `}`    `//
    Generate a new access token using user information from the refresh token`    `const
    accessToken = jwt.sign(user, SERVER_CONST.JWTSECRET, { expiresIn: SERVER_CONST.ACCESS_TOKEN_EXPIRY_TIME_SECONDS
    });`    `// Respond with the new access token`    `res.status(200).json({ statusCode:
    200, status: ''success'', data: { accessToken } });`    `return;`    `});`    `}`    The
    `**getAccessTokenFromRefreshToken**` function handles the generation of a new
    access token using a valid refresh token. It retrieves the refresh token from
    the request body. It uses the `**jwt.verify**` function to verify the refresh
    token. If the refresh token is invalid or has expired, an error will be caught
    in the `**err**` parameter. If the refresh token is invalid, it sends a 403 error
    response indicating an invalid refresh token. If the refresh token is valid, it
    uses the user information decoded from the refresh token to generate a new access
    token using the same `**jwt.sign**` function. The new access token is signed with
    the same secret key and has a shorter expiration time. It sends a success response
    (status `**200**`) containing the newly generated access token.    These two functions
    are called from routes for HTTP requests, so let''s add two routes in the `**users_router.ts**`
    file as follows:    `// users_router.ts`    `app.route(''/api/login'')`    `.post(controller.login);`    `app.route(''/api/refresh_token'')`    `.post(controller.getAccessTokenFromRefreshToken);`    **Sign
    In API**    **REST API Login**    **Request**    `URL: http://127.0.0.1:`    `Method:
    POST`    `body :`    `{`    `"email":"admin@pms.com",`    `"password":"Admin@pms1"`    `}`    **Response**    `{`    `"statusCode":
    200,`    `"status": "success",`    `"data": {`    `"accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJ1c2VybmFtZSI6InlhbWluaSIsInR5cCI6IkJlYXJlciIsImlhdCI6MTY5MjY0MjgwNywiZXhwIjoxNjkyNjcxNjA3fQ.LzYu6ZZT501MvRbuiZGNCv-kMD9UdWMG_iNYCuI3ta4",`    `"refreshToken":
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJ1c2VybmFtZSI6InlhbWluaSIsInR5cCI6IlJlZnJlc2giLCJpYXQiOjE2OTI2NDI4MDcsImV4cCI6MTY5NTY2NjgwN30.bbbVs_7AUTpwqDxOhyx66A59uV-CIrkPvEdJsDWD-OM"`    `}`    `}`    In
    case of a wrong email ID passed in a request, the server will respond with the
    following error message:    `{`    `"statusCode": 404,`    `"status": "error",`    `"message":
    "Email not found"`    `}`    Similarly, if a wrong password is sent in the request,
    then it will result in a `**400 error**` code, as follows:    `{`    `"statusCode":
    400,`    `"status": "error",`    `"message": "Password is not valid"`    `}`    In
    this manner, users can effortlessly and securely log into the application.    #
    [Authorization](toc.xhtml#s162a)    Authorization is the process of determining
    whether a user or entity has the right permissions to access certain resources
    or perform specific actions within an application. It is a critical component
    of security that ensures that users can only access the data and functionality
    they are allowed to while protecting sensitive information and preventing unauthorized
    actions.    We are going to create a middleware function responsible for authorizing
    whether the JWT token is valid or not. If it is valid, then only pass it to the
    next function or the actual API; otherwise, we will restrict and give an error
    as 401 unauthorized.    Create `**custom.d.ts**` file in the `**src**` directory
    with the following code:    `// custom.d.ts`    `declare namespace Express {`    `interface
    Request {`    `user?: {`    `username?: string;`    `email?: string;`    `rights?:
    string[];`    `user_id?: string;`    `};`    `// Add any other custom properties
    you need`    `}`    `}`    In this part of the code, a `**TypeScript**` namespace
    declaration is used to extend the Request interface provided by the `**Express.js**`
    framework. It adds a custom property called user to the Request object. This user
    property is an optional object that can contain properties such as username, email,
    and rights. The comment suggests that you can add any other custom properties
    you might need here.    Now, let''s make `**UsersUtils**` in the `**users_controller.ts**`
    file with the following code:    `// users_controller.ts`    `export class UsersUtil
    {`    `public static async getUserFromUsername(username: string) {`    `try {`    `if
    (username) {`    `const service = new UsersService();`    ``const users = await
    service.customQuery(`username = ''${username}''`);``    `if (users && users.length
    > 0) {`    `return users[0];`    `}`    `}`    `} catch (error) {`    ``console.error(`Error
    while getUserFromToken() => ${error.message}`);``    `}`    `return null;`    `}`    `}`    The
    `**getUserFromUsername**` function accepts a username as its input parameter and
    retrieves the corresponding user from the database. If the provided username does
    not have a match in the database, the function returns a null response.    After
    that, add one method in `**RolesUtil**` to get rights from roles:    `public static
    async getAllRightsFromRoles(role_ids: string[]):`    `Promise<string[]> {`    `//
    Create an instance of RolesService to interact with the roles`    `const roleService
    = new RolesService();`    `// Initialize an array to store the collected rights`    `let
    rights: string[] = [];`    `// Query the database to validate the provided role_ids`    `const
    queryData = await roleService.findByIds(role_ids);`    `const roles: Roles[] =
    queryData.data ? queryData.data : [];`    `// Extract rights from each role and
    add them to the rights array`    `roles.forEach((role) => {`    `const rightFromRole:
    string[] = role.rights.split('','');`    `rights = […new Set(rights.concat(rightFromRole))];`    `});`    `//
    Return the accumulated rights`    `return rights;`    `}`    The `**getAllRightsFromRoles**`
    is designed to retrieve and consolidate rights associated with a collection of
    role IDs. The function queries the database using the provided role IDs to fetch
    corresponding role data. For each retrieved role, the associated rights are extracted
    by splitting the rights string. These rights are then added to the rights array
    while avoiding duplicates using a set-based approach. Finally, the function returns
    an array containing the accumulated and unique rights gathered from all the roles.    Let''s
    create `**auth_util.ts**` in the utils directory using the following code:    `[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/auth_util.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/auth_util.ts)`    The
    `**authorize**` middleware function is responsible for verifying the authorization
    token, decoding it, and attaching user-related information to the `**req.user**`
    object. It first checks if the authorization token exists in the request headers.
    If not, it returns a 401 Unauthorized response indicating a missing token. The
    token is split to extract the actual token value after the “Bearer” prefix. The
    token is then verified using the provided JWT secret. If the token is successfully
    decoded, it extracts the username and email from the decoded token and assigns
    them to `**req.user.username**` and `**req.user.email**`, respectively. If a valid
    username exists, it fetches the user''s information and assigned it to `**req.user**`.
    Finally, if everything is successful, the middleware proceeds to the next middleware
    using the `**next()**` function.    The `**hasPermission**` function takes an
    array of user rights and a desired right as parameters. It checks if the array
    of user rights includes the desired right. If the desired right is found in the
    user rights, the function returns true; otherwise, it returns false.    We created
    raw functions of authorization, and now change call the `**authorize**` function
    in the routes file for each API, as follows:    `// users_routes.ts`    `export
    class UserRoutes {`    `private baseEndPoint = ''/api/users'';`    `constructor(app:
    Express) {`    `const controller = new UserController();`    `app.route(this.baseEndPoint)`    `.all(authorize)
    // Apply authorization middleware to all routes under this endpoint`    `.get(controller.getAllHandler)`    `.post(validate(validUserInput),
    controller.addHandler);`    `app.route(this.baseEndPoint + ''/:id'')`    `.all(authorize)
    // Apply authorization middleware to all routes under this endpoint`    `.get(controller.getOneHandler)`    `.put(controller.updateHandler)`    `.delete(controller.deleteHandler);`    `app.route(''/api/login'')`    `.post(controller.login);`    `app.route(''/api/refresh_token'')`    `.post(controller.getAccessTokenFromRefreshToken);`    `}`    `}`    Authorization
    is not required for the login and refresh token API since it falls under the category
    of authentication APIs:    `// roles_routes.ts`    `export class RoleRoutes {`    `private
    baseEndPoint = ''/api/roles'';`    `constructor(app: Express) {`    `const controller
    = new RoleController();`    `app.route(this.baseEndPoint)`    `.all(authorize)`    `.post(validate(validRoleInput),
    controller.addHandler)`    `.get(controller.getAllHandler);`    `app.route(this.baseEndPoint
    + ''/:id'')`    `.all(authorize)`    `.get(controller.getOneHandler)`    `.put(validate(validRoleInput),
    controller.updateHandler)`    `.delete(controller.deleteHandler);`   [PRE5] `}`    `}`    From
    now onwards, make sure, except for the login and refresh token APIs, you have
    to pass the access token with bearer type in the header as Authorization in the
    request; otherwise, it gives an error:    `{`    `"statusCode": 401,`    `"status":
    "error",`    `"message": "Missing Authorization Token"`    `}`    Checking for
    valid rights of permission is also a part of Authorization. We have already created
    a `**hasPermission**` method that will be the first call in each API controller
    with respective rights.    In the User Controller, add the following checks with
    their respective methods:    `// addHandler`    `public async addHandler(req:
    Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''add_user'')) {`    `res.status(403).json({ statusCode: 403, status: ''error'',`    `message:
    ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `// getAllHandler`    `public
    async getAllHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_all_users'')) {`    `res.status(403).json({ statusCode: 403, status: ''error'',`    `message:
    ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `// getOneHandler`    `public
    async getOneHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_details_user'')) {`    `res.status(403).json({ statusCode: 403, status:
    ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `//
    updateHandler`    `public async updateHandler(req: Request, res: Response): Promise<void>
    {`    `if (!hasPermission(req.user.rights, ''edit_user'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `//
    deleteHandler`    `public async deleteHandler(req: Request, res: Response): Promise<void>
    {`    `if (!hasPermission(req.user.rights, ''delete_user'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    Similarly,
    add in the Role controller to check permission for roles API:    `// addHandler`    `public
    async addHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''add_role'')) {`    `res.status(403).json({ statusCode: 403, status: ''error'',`    `message:
    ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `// getAllHandler`    `public
    async getAllHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_all_roles'')) {`    `res.status(403).json({ statusCode: 403, status: ''error'',`    `message:
    ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `// getOneHandler`    `public
    async getOneHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_details_role'')) {`    `res.status(403).json({ statusCode: 403, status:
    ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `//
    updateHandler`    `public async updateHandler(req: Request, res: Response): Promise<void>
    {`    `if (!hasPermission(req.user.rights, ''edit_role'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `//
    deleteHandler`    `public async deleteHandler(req: Request, res: Response): Promise<void>
    {`    `if (!hasPermission(req.user.rights, ''delete_role'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    This
    is how middleware functions for authorization and permissions work in an `**Express.js**`
    application. It extends the Request interface to include a user object with properties
    such as username, email, and rights. The `**authorize**` middleware verifies JSON
    Web Tokens (JWTs) from the request header, extracts user information, and checks
    permissions. The `**hasPermission**` function checks if a user''s rights include
    the desired permission. Moving forward, except for the login and refresh token
    APIs, the access token should be passed in the header as a bearer type using the
    **Authorization** field.    # [GetAll Users](toc.xhtml#s163a)    After successfully
    onboarding users, we can proceed to retrieve the newly inserted users from the
    database. So, update the `**getAllHandler**` method in the `**users_controller.ts**`
    file using the following code:    `public async getAllHandler(req: Request, res:
    Response): Promise<void> {`    `if (!hasPermission(req.user.rights, ''get_all_users''))
    {`    `res.status(403).json({ statusCode: 403, status: ''error'', message: ''Unauthorised''
    });`    `return;`    `}`    `const service = new UsersService();`    `const result
    = await service.findAll(req.query);`    `if (result.statusCode === 200) {`    `//
    Remove password field to send in response`    `result.data.forEach(i => delete
    i.password);`    `}`    `res.status(result.statusCode).json(result);`    `return;`    `}`    The
    `**getAllHandler**` method uses the `**UsersService**` class to retrieve all users
    from the database based on the query parameters in the request. The resulting
    data is then sent back to the client with an appropriate HTTP status code and
    formatted as JSON.    This controller method call in routes with a change in `**roles_routes.ts**`
    as follows:    `app.route(this.baseEndPoint)`    `.all(authorize) // Apply authorization
    middleware to all routes under this endpoint`    `.get(controller.getAllHandler)`    `.post(validate(validUserInput),
    controller.addHandler);`    By employing this approach, we establish a GET route
    that fetches all roles stored in the database, effectively functioning as a REST
    API endpoint for retrieving role data.    **REST API GetAll Roles**    **Request**    `URL:
    http://127.0.0.1:3000/api/users`    `Method: GET`    `Query Params: {}`    **Response**    `{`    `"statusCode":
    200,`    `"status": "success",`    `"data": [`    `{`    `"user_id": "b930d02c-43af-4875-b7e9-546c9f4c23dd",`    `"fullname":
    "Super Admin",`    `"username": "pms-admin",`    `"email": "admin@pms.com",`    `"role_ids":
    [`    `"dbda47e4-f843-4263-a4d6-69ef80156f81"`    `],`    `"created_at": "2023-08-22T17:08:24.722Z",`    `"updated_at":
    "2023-08-22T17:08:24.722Z"`    `}, {`    `"user_id": "d166945a-f85d-485c-bdac-0c8056b3188a",`    `"fullname":
    "Yami Panchal",`    `"username": "yamini",`    `"email": "yami@gmail.com",`    `"role_ids":
    [`    `"b88cc70d-ab0a-4464-9562-f6320df519f6"`    `],`    `"created_at": "2023-08-18T17:57:38.744Z",`    `"updated_at":
    "2023-08-24T16:57:19.110Z"`    `}`    `]`    `}`    If you want to filter or search
    by exact name, you can change query params as follows:    `URL: http://127.0.0.1:3000/api/users?username=pms-admin`    It
    gives only matched data as a response, as follows    `{`    `"statusCode": 200,`    `"status":
    "success",`    `"data": [`    `{`    `"user_id": "b930d02c-43af-4875-b7e9-546c9f4c23dd",`    `"fullname":
    "Super Admin",`    `"username": "pms-admin",`    `"email": "admin@pms.com",`    `"role_ids":
    [`    `"dbda47e4-f843-4263-a4d6-69ef80156f81"`    `],`    `"created_at": "2023-08-22T17:08:24.722Z",`    `"updated_at":
    "2023-08-22T17:08:24.722Z"`    `}`    `]`    `}`    # [GetOne User](toc.xhtml#s164a)    This
    endpoint offers a valuable function by providing specific user information. It
    serves as a crucial tool for users to access their own details and also enables
    administrators to retrieve specific user information whenever necessary.    To
    implement the `**GetOne**` User API, make the following changes in the `**getOneHandler**`
    code in the user controller:    `// users_controller.ts`    `public async getOneHandler(req:
    Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_details_user'')) {`    `res.status(403).json({ statusCode: 403, status:
    ''error'', message: ''Unauthorised'' });`    `return;`    `}`    `const service
    = new UsersService();`    `const result = await service.findOne(req.params.id);`    `if
    (result.statusCode === 200) {`    `delete result.data.password;`    `}`    `res.status(result.statusCode).json(result);`    `return;`    `}`    The
    `**getOneHandler**` function serves as the bridge between the incoming client
    request, the service layer that interacts with the database, and the outgoing
    HTTP response. It retrieves a single user''s details from the database based on
    the provided user ID and sends the user information back to the client, except
    password data for security reasons.    This method is called from the routes file
    by creating a new route for it as follows:    `app.route(this.baseEndPoint + ''/:id'')`    `.all(authorize)
    // Apply authorization middleware to all routes under this endpoint`    `.get(controller.getOneHandler)`    Here**,**
    `**/:id**` will be a request parameter meant to capture the ID of the user that
    wants to retrieve.    **REST API GetOne Role**    **Request**    `URL: http://127.0.0.1:5000/api/users/b930d02c-43af-4875-b7e9-546c9f4c23dd`    `Method:
    GET`    **Response**    `{`    `"statusCode": 200,`    `"status": "success",`    `"data":
    {`    `"user_id": "b930d02c-43af-4875-b7e9-546c9f4c23dd",`    `"fullname": "Super
    Admin",`    `"username": "pms-admin",`    `"email": "admin@pms.com",`    `"role_ids":
    [`    `"dbda47e4-f843-4263-a4d6-69ef80156f81"`    `],`    `"created_at": "2023-08-22T17:08:24.722Z",`    `"updated_at":
    "2023-08-22T17:08:24.722Z"`    `}`    `}`    Providing a valid role ID will yield
    a successful response, while inputting an ID that doesn''t correspond to an existing
    database entry will result in a `**404**` `**error**`, signifying that the requested
    entity was `**Not found**`.    `{`    `"statusCode": 404,`    `"status": "error",`    `"message":
    "Not Found"`    `}`    # [Update User](toc.xhtml#s165a)    In updating user information,
    it''s important to note that the username and email fields won''t be modified.
    These fields are unique identifiers and will retain their initial values as set
    during creation. Additionally, to change the password, a separate API will be
    implemented specifically for that purpose, known as the `**change password**`
    API.    Let''s develop `**updateHandler**` in the `**users_controller.ts**` using
    the following code:    `public async updateHandler(req: Request, res: Response):
    Promise<void> {`    `if (!hasPermission(req.user.rights, ''edit_user'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'', message: ''Unauthorised'' });`    `return;`    `}`    `const
    service = new UsersService();`    `const user = req.body;`    `// we will not
    update email and username once inserted so remove it from body`    `delete user?.email;`    `delete
    user?.username;`    `// we will also not update password from here it will be
    from changePassword function separate`    `delete user?.password;`   [PRE6]`js
    [PRE7]js`` [PRE8]js[PRE9]````'
  prefs: []
  type: TYPE_NORMAL
