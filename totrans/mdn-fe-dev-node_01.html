<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-17" lang="en-GB"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-18" lang="en-GB"><a id="_idTextAnchor016"/>Learning about the Internals of Node.js</h1>
<p lang="en-GB">For years, being a frontend developer meant writing a bit of HTML and putting some styling with CSS on it. However, since the last decade, this job description barely holds true. In contrast, the majority of frontend work is now done using <strong class="bold" lang="">JavaScript</strong>.</p>
<p lang="en-GB">Initially used to make cosmetic enhancements to websites (such as the toggling of elements) possible, frontend development is now the glue of the web. Websites are no longer just written in HTML and CSS. Instead, in many cases, web pages are programmed with JavaScript using modern techniques such as dependency management and bundling of resources. The <strong class="bold" lang="">Node.js</strong> framework provides an ideal foundation <a id="_idIndexMarker000"/>for this movement. It enables developers to use JavaScript not only inside websites running in a browser but also within the tooling to write web pages – outside of a browser.</p>
<p lang="en-GB">When Node.js was released in May 2009, it did not seem like a big deal. JavaScript was working on the server too. However, the cross-platform nature of Node.js and the size of the JavaScript community provided the basis for one of the greatest disruptions in the history of computing. People started adopting the framework so quickly that many existing frameworks either disappeared or had to be reworked to stay attractive to developers. Soon, JavaScript was used in the browser and on the server and was also part of every frontend developer’s toolbox.</p>
<p lang="en-GB">With the rise of new development frameworks <a id="_idIndexMarker001"/>such as <strong class="bold" lang="">Angular</strong> or <strong class="bold" lang="">React</strong>, the <a id="_idIndexMarker002"/>need for attractive frontend tooling became apparent. The new frameworks always relied on some build steps – otherwise, websites and applications using these frameworks would have been far too inconvenient to write for developers. Since the vast Node.js ecosystem seemed to have figured out a suitable approach for reusability, these new frameworks adopted it and made it an integral part of their development story. This way, using Node.js became the de facto standard for frontend projects of any kind.</p>
<p lang="en-GB">Today, it is pretty much impossible to start a frontend development project without having Node.js installed. In this book, we’ll take the journey of learning about Node.js from the inside out together. We will not be focusing on writing server applications or walking over the integrated functionality of Node.js. Instead, we’ll look at how we – as frontend developers – can leverage the best that Node.js brings to the table.</p>
<p lang="en-GB">In this first chapter, we discuss the internals of Node.js. This will help you understand how Node.js works and how you can actually use it. After this chapter, you will be able to run and debug simple scripts using the Node.js command-line application.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Looking at the Node.js architecture in detail</li>
<li lang="en-GB">Understanding the event loop</li>
<li lang="en-GB">Using Node.js from the command line</li>
<li lang="en-GB">CommonJS</li>
</ul>
<h1 id="_idParaDest-19" lang="en-GB"><a id="_idTextAnchor017"/>Technical requirements</h1>
<p lang="en-GB">To follow the code samples in this book, you need knowledge of JavaScript and how to use the command line. You should have Node.js installed using the instructions at <a href="https://nodejs.org">https://nodejs.org</a>.</p>
<p lang="en-GB">The complete source code for this chapter is available at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter01">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter01</a>.</p>
<p lang="en-GB">The Code in Action (CiA) videos for this chapter can be accessed at <a href="http://bit.ly/3fPPdtb">http://bit.ly/3fPPdtb</a>.</p>
<h1 id="_idParaDest-20" lang="en-GB"><a id="_idTextAnchor018"/>Looking at the Node.js architecture in detail</h1>
<p lang="en-GB">The principal foundations of<a id="_idIndexMarker003"/> Node.js have been inspired by a few things:</p>
<ul>
<li lang="en-GB">The single worker thread featured in browsers was already quite successful in the server space. Here, the <a id="_idIndexMarker004"/>popular <strong class="bold" lang="">nginx</strong> web server showed that the event loop pattern (explained later in this chapter) was actually a blessing for performance – eliminating the need to use a dedicated thread pool for handling requests.</li>
<li lang="en-GB">The idea of packaging everything in a file-centric structure <a id="_idIndexMarker005"/>called <strong class="bold" lang="">modules</strong>. This allowed Node.js to avoid many of the pitfalls of other languages and frameworks – including JavaScript in the browser.</li>
<li lang="en-GB">The idea of avoiding creating a huge framework and leaving everything extensible and easy to get via package managers.</li>
</ul>
<p class="callout-heading" lang="en-GB">Threads</p>
<p class="callout" lang="en-GB">Modern computers offer a lot of computing power. However, for an application to really use the available computing power, we need to have multiple things working in parallel. Modern operating systems know about different independently running tasks via so-called threads. A <strong class="bold" lang="">thread</strong> is a<a id="_idIndexMarker006"/> group of operations running sequentially, which means in a given order. The operating system then schedules when threads run and where (i.e., on which CPU core) they are placed.</p>
<p lang="en-GB">These <a id="_idIndexMarker007"/>principles together form a platform that seems easy to create, but hard to replicate. After all, there are plenty of JavaScript engines and useful libraries available. For Ryan Dahl, the original creator and maintainer of Node.js, the basis of the framework had to be rock solid.</p>
<p lang="en-GB">Ryan Dahl selected an existing <a id="_idIndexMarker008"/>JavaScript engine (<strong class="bold" lang="">V8</strong>) to take over the responsibility of parsing and running the code written in JavaScript. The V8 engine was chosen for two good reasons. On the one hand, the engine was available as an open source project under a permissive license – usable by projects such as Node.js. On the other hand, V8 was also the engine used by Google for its web browser <strong class="bold" lang="">Chrome</strong>. It is<a id="_idIndexMarker009"/> very fast, very reliable, and under active development.</p>
<p lang="en-GB">One of the drawbacks of using V8 is that it was written in C++ using custom-built tooling called <strong class="bold" lang="">GYP</strong>. While<a id="_idIndexMarker010"/> GYP was replaced in V8 years later, the transition was not so easy for Node.js. As of today, Node.js is still relying on GYP as a build system. The fact that V8 is written in C++ seems like a side note at first, but might be pretty important if you ever intend to write<a id="_idIndexMarker011"/> so-called <strong class="bold" lang="">native modules</strong>.</p>
<p lang="en-GB">Native modules allow you to go beyond JavaScript and Node.js – making full use of the available hardware and system capabilities. One drawback of native modules is that they must be built on each platform. This is <a id="_idIndexMarker012"/>against the <strong class="bold" lang="">cross-platform</strong> nature of Node.js.</p>
<p lang="en-GB">Let’s take a step back to arrange the parts mentioned so far in an architecture diagram. <em class="italic" lang="">Figure 1</em><em class="italic" lang="">.1</em> shows how Node.js is composed internally:</p>
<div><div><img alt="Figure 1.1 – Internal composition of Node.js " src="img/Figure_1.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Internal composition of Node.js</p>
<p lang="en-GB">The most important component in Node.js’s architecture – besides the JavaScript engine – is the <strong class="bold" lang="">libuv</strong> library. libuv<a id="_idIndexMarker013"/> is a multi-platform, low-level library that provides support for asynchronous <strong class="bold" lang="">input/output</strong> (<strong class="bold" lang="">I/O</strong>) based <a id="_idIndexMarker014"/>on an <strong class="bold" lang="">event loop</strong>. I/O happens in multiple forms, such as writing files or<a id="_idIndexMarker015"/> handling <strong class="bold" lang="">HTTP requests</strong>. In general, I/O refers to anything that is handled in a dedicated area of the operating system.</p>
<p lang="en-GB">Any <a id="_idIndexMarker016"/>application running Node.js is written in JavaScript or some flavor of it. When Node.js starts running the application, the JavaScript is parsed and evaluated by V8. All the standard objects, such as <code>console</code>, expose some bindings that are part of the Node.js API. These low-level functions (such as <code>console.log</code> or <code>fetch</code>) make use of libuv. Therefore, some simple script that only works against language features such as primitive calculations (<em class="italic" lang="">2 + 3</em>) does not require anything from the Node API and will remain independent of libuv. In contrast, once a low-level function (for example, a function to access the network) is used, libuv can be the workforce behind it.</p>
<p lang="en-GB">In <em class="italic" lang="">Figure 1</em><em class="italic" lang="">.2</em>, a block diagram illustrating the various API layers is shown. The beauty of this diagram is that it reveals what Node.js actually is: a JavaScript runtime allowing access to low-level functionality <a id="_idIndexMarker017"/>from state-of-the-art <strong class="bold" lang="">C/C++</strong> libraries. The Node.js API consists of the included Node.js bindings and some C/C++ addons:</p>
<div><div><img alt="Figure 1.2 – Composition of Node.js in terms of building blocks " src="img/Figure_1.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Composition of Node.js in terms of building blocks</p>
<p lang="en-GB">One thing <a id="_idIndexMarker018"/>that would need explanation in the preceding diagram is how the event loop is implemented in relation to all the blocks. When talking about Node.js’s internal architecture, a broader discussion of what an event loop is and why it matters for Node.js is definitely required. So let’s get into these details.</p>
<h1 id="_idParaDest-21" lang="en-GB"><a id="_idTextAnchor019"/>Understanding the event loop</h1>
<p lang="en-GB">An event loop<a id="_idIndexMarker019"/> is a runtime model that enables users to run all operations from a single thread – irrespective of whether the operations access long-running external resources or not. For this to work, the event loop needs to make requests to an event provider, which calls the specified event handlers. In Node.js, the libuv library is used for event loop implementation.</p>
<p lang="en-GB">The reason for giving libuv the most space in <em class="italic" lang="">Figure 1</em><em class="italic" lang="">.1</em> is to highlight the importance of this library. Internally, libuv is used for everything regarding I/O, which arguably is the most crucial piece of any framework. I/O lets a framework communicate with other resources, such as files, servers, or databases. By default, dealing with I/O is done in a blocking manner. This means that the sequence of operations in our application is essentially stopped, waiting for the I/O operation to finish.</p>
<p lang="en-GB">Two strategies for mitigating the performance implications of blocking I/O exist.</p>
<p lang="en-GB">The first strategy is to create new threads for actually performing these blocking I/O operations. Since a thread contains an independent group of operations, it can run concurrently, eventually not stopping the operations running in the original thread of the application.</p>
<p lang="en-GB">The <a id="_idIndexMarker020"/>second strategy is to not <a id="_idIndexMarker021"/>use <strong class="bold" lang="">blocking I/O</strong> at all. Instead, use an alternative variant, which is usually called non-blocking I/O or asynchronous I/O. <strong class="bold" lang="">Non-blocking I/O</strong> works <a id="_idIndexMarker022"/>with callbacks, that is, functions that are called under certain conditions – for instance when the I/O operation is finished. Node.js uses libuv to make extensive use of this second strategy. This allows Node.js to run all code in a single thread, while I/O operations run concurrently.</p>
<p lang="en-GB">In <em class="italic" lang="">Figure 1</em><em class="italic" lang="">.3</em>, the building blocks of libuv are displayed. The key part is that libuv already comes with a lot of functionality to handle network I/O. Furthermore, file and DNS operations are also covered well:</p>
<div><div><img alt="Figure 1.3 – Building blocks of libuv " src="img/Figure_1.3_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Building blocks of libuv</p>
<p lang="en-GB">In addition to the different I/O operations, the library comes with a set of different options for handling asynchronous user code.</p>
<p lang="en-GB">The event loop itself follows<a id="_idIndexMarker023"/> the <strong class="bold" lang="">reactor design pattern</strong>. Wikipedia describes the pattern as follows:</p>
<p class="author-quote" lang="en-GB">The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers. (https://en.wikipedia.org/wiki/Reactor_pattern)</p>
<p lang="en-GB">Importantly, this definition mentions synchronous dispatch. This means that code that is run through the event loop is guaranteed to not run into any conflicts. The event loop makes <a id="_idIndexMarker024"/>sure that code is always run sequentially. Even though the I/O operations may concurrently run, our callbacks will never be invoked in parallel. From our perspective, even though Node.js will internally (through libuv) use multiple threads, the whole application is single-threaded.</p>
<p lang="en-GB">The following is a simple script that shows you the basic behavior of the event loop at play – we’ll discuss how to run this in the <em class="italic" lang="">Using Node.js from the command </em><em class="italic" lang="">line</em> section:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">events.js</p>
<pre class="source-code" lang="en-GB">console.log('A [start]');
setTimeout(() =&gt; console.log('B [timeout]'), 0);
Promise.resolve().then(() =&gt; console.log('C [promise]'));
console.log('D [end]');</pre>
<p lang="en-GB">We will run <a id="_idIndexMarker025"/>this script in the next section when we learn about the command line usage of Node.js. In the meantime, put some thought into the preceding code and write down the order in which you’ll see the <code>console</code> output. Do you think it will print in an “<code>A</code> <code>B</code> <code>C</code> <code>D</code>” order, or something else?</p>
<p lang="en-GB">The algorithm of the implementation of the event loop in libuv is displayed in <em class="italic" lang="">Figure 1</em><em class="italic" lang="">.4</em>:</p>
<div><div><img alt="Figure 1.4 – The implementation of the event loop in libuv " src="img/Figure_1.4_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – The implementation of the event loop in libuv</p>
<p lang="en-GB">While the code snippet only deals with JavaScript-related constructs (such as <code>console</code>, <code>Promise</code>, and <code>setTimeout</code>), in general, the callbacks are associated with resources that go beyond Node.js, such as file system changes or network requests. Some of these resources may have an operating system equivalent; others only exist in form of blocking I/O.</p>
<p lang="en-GB">Consequently, the<a id="_idIndexMarker026"/> event loop implementation always considers its thread pool and polls for progressed I/O operations. Timers (such as <code>setTimeout</code> in the example script) are only run in the beginning. To know whether a timer needs to be run, its due time is compared with the current time. The current time is synced with the system time initially. If there is nothing to be done anymore (that is, no active timer, no resource waiting to finish, etc.), then the loop exits.</p>
<p lang="en-GB">Let’s see how we can run Node.js to solidify our knowledge about the event loop.</p>
<h1 id="_idParaDest-22" lang="en-GB"><a id="_idTextAnchor020"/>Using Node.js from the command line</h1>
<p lang="en-GB">Using JavaScript for<a id="_idIndexMarker027"/> a web application just requires you to open the website in a browser. The browser will evaluate the included JavaScript and run it. When you want to use JavaScript as a scripting language, you need to find a new way of running JavaScript. Node.js offers this new way – running JavaScript in a terminal, inside our computer, or from a server.</p>
<p lang="en-GB">When Node.js is installed, it comes with a set of command-line tools that will be available in the terminal of your choice. For this book, you’ll need to know about three different executables that we’ll use throughout the chapters:</p>
<ul>
<li lang="en-GB"><strong class="bold" lang="">node</strong>: The <a id="_idIndexMarker028"/>main application to run a Node.js script</li>
<li lang="en-GB"><strong class="bold" lang="">npm</strong>: The<a id="_idIndexMarker029"/> default package manager – more on that later</li>
<li lang="en-GB"><strong class="bold" lang="">npx</strong>: A very <a id="_idIndexMarker030"/>convenient utility to run npm binaries</li>
</ul>
<p lang="en-GB">For now, we only need to know about <code>node</code>. If we want to run the <code>events.js</code> script from the previous section, we need to execute the following command in the directory in which the script (<code>events.js</code>) has been placed. You can place it there by just inserting the content from the previous <code>events.js</code> listing:</p>
<pre class="console" lang="en-GB">
$ node events.js

A [start]

D [end]

C [promise]

B [timeout]</pre>
<p lang="en-GB">The command is shown after the conventional <code>$</code> sign indicating the command prompt. The output of running the script is shown below the <code>node </code><code>events.js</code> command.</p>
<p lang="en-GB">As you can see, the order is “<code>A</code> <code>D</code> <code>C</code> <code>B</code>” – that is, Node.js first handled all the sequential operations before the callbacks of the promise were handled. Finally, the timeout callback was handled.</p>
<p lang="en-GB">The reason for handling the promise callback before the timeout callback lies in the event loop. In JavaScript, promises spawn so-called micro tasks, which are placed in the pending callback section of the libuv event loop from <em class="italic" lang="">Figure 1</em><em class="italic" lang="">.4</em>. The timeout callback, however, is treated like a full task. The difference between them lies within the event loop. Micro tasks are placed in an optimized queue that is actually peeked multiple times per event loop iteration.</p>
<p lang="en-GB">According <a id="_idIndexMarker031"/>to libuv, the timeout callback can only be run when its timer is due. Since we only placed it in the event loop during the idle handles (i.e., main section) of the event loop, we need to wait until the next iteration of the event loop.</p>
<p lang="en-GB">The <code>node</code> command-line application can also receive additional parameters. The official documentation goes into all details (<a href="https://nodejs.org/api/cli.html">https://nodejs.org/api/cli.html</a>). A helpful one is <code>-e</code> (short version of <code>--eval</code>) to just evaluate a script directly from the command-line input without requiring a file to run:</p>
<pre class="console" lang="en-GB">
$ node -e "console.log(new Date())"

2022-04-29T09:20:44.401</pre>
<p lang="en-GB">Another very helpful command line flag is <code>--inspect</code>. This opens the standard port for graphical inspection, for example, via the Chrome web browser.</p>
<p lang="en-GB">Let’s run an application with a bit of continuous logic to justify an inspection session. In the terminal on your machine, run the following:</p>
<pre class="console" lang="en-GB">
$ node -e "setInterval(() =&gt; console.log(Math.random()), 60 * 1000)" --inspect

Debugger listening on ws://127.0.0.1:9229/64c26b8a-0ba9-484f-902d-759135ad76a2

For help, see: https://nodejs.org/en/docs/inspector</pre>
<p lang="en-GB">Now we can run a graphical application. Let’s use the Chrome web browser. Open it and go to <a href="https://chrome://inspect">chrome://inspect</a>. This is a special Chrome-internal URL that allows us to see the available targets.</p>
<p lang="en-GB">The following figure (<em class="italic" lang="">Figure 1</em><em class="italic" lang="">.5</em>) shows how inspecting the Node.js application in the Chrome web browser may look:</p>
<div><div><img alt="Figure 1.5 – Inspecting the Node.js application in the Chrome web browser " src="img/Figure_1.5_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Inspecting the Node.js application in the Chrome web browser</p>
<p lang="en-GB">In this<a id="_idIndexMarker032"/> case, Chrome detected our application with the process ID <code>3420</code> running. On your machine, the process ID will most likely be different. No filename was given, as we started with the <code>-e</code> command-line option.</p>
<p lang="en-GB">When you click on <code>console</code> output that you see in the command line.</p>
<p lang="en-GB">When you follow the link to the evaluated script from the DevTools console, you’ll get the ability to<a id="_idIndexMarker034"/> place <strong class="bold" lang="">breakpoints</strong> or pause the execution. Pausing the execution may not work immediately, as an active JavaScript operation is required for that.</p>
<p lang="en-GB">In <em class="italic" lang="">Figure 1</em><em class="italic" lang="">.6</em>, you see how debugging a Node.js script in the Chrome DevTools can look:</p>
<div><div><img alt="Figure 1.6 – Debugging a Node.js script in the Chrome DevTools " src="img/Figure_1.6_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Debugging a Node.js script in the Chrome DevTools</p>
<p lang="en-GB">In the <a id="_idIndexMarker035"/>preceding example, JavaScript is only run every minute. When the pause occurs, you should end up in the <code>internal/timers.js</code> part of Node.js itself. This is a different JavaScript file, but it’s part of the whole Node.js framework. The file can be integrated because it follows certain conventions and rules that are known as CommonJS.</p>
<h1 id="_idParaDest-23" lang="en-GB"><a id="_idTextAnchor021"/>CommonJS</h1>
<p lang="en-GB">One thing that<a id="_idIndexMarker036"/> Node.js got right from the beginning was to introduce an explicit way of obtaining and using functionality. JavaScript in the browser suffered from the <em class="italic" lang="">global scope</em> problem, which caused many headaches for developers.</p>
<p class="callout-heading" lang="en-GB">Global scope</p>
<p class="callout" lang="en-GB">In JavaScript, the global scope <a id="_idIndexMarker037"/>refers to functionality that is accessible from every script running in the same application. On a website, the global scope is usually the same as the <code>window</code> variable. Attaching variables to the global scope may be convenient and sometimes even necessary, but it may also lead to conflicts. For instance, two independent functions could both try to write and read from the same variable. The resulting behavior can then be hard to debug and very tricky to resolve. The standard recommendation is to avoid using the global scope as much as possible.</p>
<p lang="en-GB">The idea that other functionalities are explicitly imported was certainly not new when Node.js was introduced. While an import mechanism existed in other programming languages or frameworks for quite some time, similar options have also been available for JavaScript in the browser – via third-party libraries such <a id="_idIndexMarker038"/>as <strong class="bold" lang="">RequireJS</strong>.</p>
<p lang="en-GB">Node.js introduced its <strong class="bold" lang="">module system</strong> with the<a id="_idIndexMarker039"/> name <strong class="bold" lang="">CommonJS</strong>. The basis for Node.js’s implementation was actually a project developed at Mozilla. In that project, Mozilla worked on a range of proposals that started with non-browser use but later on expanded to a generic set of JavaScript specifications for a module system.</p>
<p class="callout-heading" lang="en-GB">CommonJS implementations</p>
<p class="callout" lang="en-GB">Besides the <a id="_idIndexMarker040"/>implementation in Node.js, many other runtimes or frameworks use CommonJS. As an example, the JavaScript that can be used in<a id="_idIndexMarker041"/> the <strong class="bold" lang="">MongoDB</strong> database leverages a module system using the CommonJS specifications. The implementation in Node.js is actually only partially fulfilling the full specification.</p>
<p lang="en-GB">A module system is crucial for allowing the inclusion of more functionality in a very transparent and explicit manner. In addition to a set of more advanced functionality, a module system gives us the following:</p>
<ul>
<li lang="en-GB">A way of including more functionality (in CommonJS, via the global <code>require</code> function)</li>
<li lang="en-GB">A way of exposing functionality, which can then be included somewhere else (in CommonJS, via the module-specific <code>module</code> or <code>exports</code> variables)</li>
</ul>
<p lang="en-GB">At its core, the way CommonJS works is quite simple. Imagine you have a file called <code>a.js</code>, which contains the following code:</p>
<pre class="source-code" lang="en-GB">const b = require('./b.js');
console.log('The value of b is:', b.myValue);</pre>
<p lang="en-GB">Now the<a id="_idIndexMarker042"/> job of Node.js would be to actually make this work, that is, give the <code>b</code> variable a value that represents the so-called exports of the module. Right now, the script would error out saying that a <code>b.js</code> file is missing.</p>
<p lang="en-GB">The <code>b.js</code> file, which should be adjacent to <code>a.js</code>, reads as follows:</p>
<pre class="source-code" lang="en-GB">exports.myValue = 42;</pre>
<p lang="en-GB">When Node.js evaluates the file, it will remember the defined exports. In this case, Node.js will know that <code>b.js</code> is actually just an object with a <code>myValue</code> key with a value of <code>42</code>.</p>
<p lang="en-GB">From the perspective of <code>a.js</code>, the code can therefore be read like this:</p>
<pre class="source-code" lang="en-GB">const b = {
  myValue: 42,
};
console.log('The value of b is:', b.myValue);</pre>
<p lang="en-GB">The advantage of using the module system is that there is no need to write the outputs of the module again. The call to <code>require</code> does that for us.</p>
<p class="callout-heading" lang="en-GB">Side effects</p>
<p class="callout" lang="en-GB">Replacing the call to <code>require</code> with the module’s outputs is only meant for illustrative purposes. In general, this cannot be done as the module evaluation can have some so-called <a id="_idIndexMarker043"/>side effects. A <code>require</code> call with the imported module’s exports, we would not run the side effects, which would miss a crucial aspect of the module.</p>
<p lang="en-GB">In the given example, we used the name of the file directly, but importing a module can be more subtle than that. Let’s see a refined version of the code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">a.js</p>
<pre class="source-code" lang="en-GB">const b = require('./b');
console.log('The value of b is:', b.myValue);</pre>
<p lang="en-GB">The<a id="_idIndexMarker044"/> call to<code>./b.js</code> has been replaced by <code>./b</code>. This will still work, as Node.js will<a id="_idIndexMarker045"/> try various combinations for the given import. Not only will it append certain known extensions (such as <code>.js</code>) but it will also look at whether <code>b</code> is actually a directory with an <code>index.js</code> file.</p>
<p lang="en-GB">Therefore, with the preceding code, we could actually move <code>b.js</code> from a file adjacent to <code>a.js</code> to an <code>index.js</code> file in the adjacent directory, <code>b</code>.</p>
<p lang="en-GB">The greatest advantage, however, is that this syntax also allows us to import functionality from third-party packages. As we will explore later in <a href="B18989_02.xhtml#_idTextAnchor023"><em class="italic" lang="">Chapter 2</em></a>, <em class="italic" lang="">Dividing Code into Modules and Packages</em>, our code has to be divided into different modules and packages. A <strong class="bold" lang="">package</strong> contains <a id="_idIndexMarker046"/>a set of reusable modules.</p>
<p lang="en-GB">Node.js already comes with a set of packages that don’t even need to be installed. Let’s see a simple example:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">host.js</p>
<pre class="source-code" lang="en-GB">const os = require('os');
console.log('The current hostname is:', os.hostname());</pre>
<p lang="en-GB">The <a id="_idIndexMarker047"/>preceding example uses the integrated <code>os</code> package to obtain the current computer’s network name.</p>
<p lang="en-GB">We can run this script with <code>node</code> in the command line:</p>
<pre class="console" lang="en-GB">
$ node host.js

The current hostname is: DESKTOP-3JMIDHE</pre>
<p lang="en-GB">This script works on every computer that has Node.js installed.</p>
<h1 id="_idParaDest-24" lang="en-GB"><a id="_idTextAnchor022"/>Summary</h1>
<p lang="en-GB">In this chapter, we discovered Node.js for the first time. You should now have a good idea of the core principles (such as event loop, threads, modules, and packages) upon which Node.js was built. You have read a bit about Node.js’s history and why V8 was chosen as the JavaScript engine.</p>
<p lang="en-GB">One of the key things to take away from this chapter is how the event loop works. Note that part of this knowledge is not exclusive to Node.js. The distinction between micro tasks and tasks is an integral part of how JavaScript engines, even the JavaScript engine of your browser, work.</p>
<p lang="en-GB">Lastly, you are now equipped to use the <code>node</code> command-line application, for example, to run or debug simple scripts, which can export and import functionality using the CommonJS module system. You learned how to use the Chrome web browser to inspect Node.js scripts as you can with websites.</p>
<p lang="en-GB">In the next chapter, we will increase our knowledge about CommonJS by learning how we can efficiently divide code into modules and packages.</p>
</div>
</body></html>