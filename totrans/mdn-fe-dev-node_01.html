<html><head></head><body>
<div id="_idContainer014">
<h1 class="chapter-number" id="_idParaDest-17" lang="en-GB"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-18" lang="en-GB"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">Learning about the Internals of Node.js</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.3.1">For years, being a frontend developer meant writing a bit of HTML and putting some styling with CSS on it. </span><span class="koboSpan" id="kobo.3.2">However, since the last decade, this job description barely holds true. </span><span class="koboSpan" id="kobo.3.3">In contrast, the majority of frontend work is now done </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.4.1">using </span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.5.1">JavaScript</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.6.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.7.1">Initially used to make cosmetic enhancements to websites (such as the toggling of elements) possible, frontend development is now the glue of the web. </span><span class="koboSpan" id="kobo.7.2">Websites are no longer just written in HTML and CSS. </span><span class="koboSpan" id="kobo.7.3">Instead, in many cases, web pages are programmed with JavaScript using modern techniques such as dependency management and bundling of resources. </span><span class="koboSpan" id="kobo.7.4">The </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.8.1">Node.js</span></strong><span class="koboSpan" id="kobo.9.1"> framework provides an ideal foundation </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.10.1">for this movement. </span><span class="koboSpan" id="kobo.10.2">It enables developers to use JavaScript not only inside websites running in a browser but also within the tooling to write web pages – outside of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.11.1">a browser.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.12.1">When Node.js was released in May 2009, it did not seem like a big deal. </span><span class="koboSpan" id="kobo.12.2">JavaScript was working on the server too. </span><span class="koboSpan" id="kobo.12.3">However, the cross-platform nature of Node.js and the size of the JavaScript community provided the basis for one of the greatest disruptions in the history of computing. </span><span class="koboSpan" id="kobo.12.4">People started adopting the framework so quickly that many existing frameworks either disappeared or had to be reworked to stay attractive to developers. </span><span class="koboSpan" id="kobo.12.5">Soon, JavaScript was used in the browser and on the server and was also part of every frontend </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.13.1">developer’s toolbox.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.14.1">With the rise of new development frameworks </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.15.1">such as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.16.1">Angular</span></strong><span class="koboSpan" id="kobo.17.1"> or </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.18.1">React</span></strong><span class="koboSpan" id="kobo.19.1">, the </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.20.1">need for attractive frontend tooling became apparent. </span><span class="koboSpan" id="kobo.20.2">The new frameworks always relied on some build steps – otherwise, websites and applications using these frameworks would have been far too inconvenient to write for developers. </span><span class="koboSpan" id="kobo.20.3">Since the vast Node.js ecosystem seemed to have figured out a suitable approach for reusability, these new frameworks adopted it and made it an integral part of their development story. </span><span class="koboSpan" id="kobo.20.4">This way, using Node.js became the de facto standard for frontend projects of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.21.1">any kind.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.22.1">Today, it is pretty much impossible to start a frontend development project without having Node.js installed. </span><span class="koboSpan" id="kobo.22.2">In this book, we’ll take the journey of learning about Node.js from the inside out together. </span><span class="koboSpan" id="kobo.22.3">We will not be focusing on writing server applications or walking over the integrated functionality of Node.js. </span><span class="koboSpan" id="kobo.22.4">Instead, we’ll look at how we – as frontend developers – can leverage the best that Node.js brings to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.23.1">the table.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.24.1">In this first chapter, we discuss the internals of Node.js. </span><span class="koboSpan" id="kobo.24.2">This will help you understand how Node.js works and how you can actually use it. </span><span class="koboSpan" id="kobo.24.3">After this chapter, you will be able to run and debug simple scripts using the Node.js </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.25.1">command-line application.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.26.1">We will cover the following key topics in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.27.1">this chapter:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.28.1">Looking at the Node.js architecture </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.29.1">in detail</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.30.1">Understanding the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.31.1">event loop</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.32.1">Using Node.js from the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.33.1">command line</span></span></li>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.34.1">CommonJS</span></span></li>
</ul>
<h1 id="_idParaDest-19" lang="en-GB"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.35.1">Technical requirements</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.36.1">To follow the code samples in this book, you need knowledge of JavaScript and how to use the command line. </span><span class="koboSpan" id="kobo.36.2">You should have Node.js installed using the instructions </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.37.1">at </span></span><a href="https://nodejs.org"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.38.1">https://nodejs.org</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.39.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.40.1">The complete source code for this chapter is available </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.41.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter01"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter01</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.44.1">The Code in Action (CiA) videos for this chapter can be accessed </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.45.1">at </span></span><a href="http://bit.ly/3fPPdtb"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.46.1">http://bit.ly/3fPPdtb</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.47.1">.</span></span></p>
<h1 id="_idParaDest-20" lang="en-GB"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.48.1">Looking at the Node.js architecture in detail</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.49.1">The principal foundations of</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.50.1"> Node.js have been inspired by a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.51.1">few things:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.52.1">The single worker thread featured in browsers was already quite successful in the server space. </span><span class="koboSpan" id="kobo.52.2">Here, the </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.53.1">popular </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.54.1">nginx</span></strong><span class="koboSpan" id="kobo.55.1"> web server showed that the event loop pattern (explained later in this chapter) was actually a blessing for performance – eliminating the need to use a dedicated thread pool for </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.56.1">handling requests.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.57.1">The idea of packaging everything in a file-centric structure </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.58.1">called </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.59.1">modules</span></strong><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">This allowed Node.js to avoid many of the pitfalls of other languages and frameworks – including JavaScript in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.61.1">the browser.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.62.1">The idea of avoiding creating a huge framework and leaving everything extensible and easy to get via </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.63.1">package managers.</span></span></li>
</ul>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.64.1">Threads</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.65.1">Modern computers offer a lot of computing power. </span><span class="koboSpan" id="kobo.65.2">However, for an application to really use the available computing power, we need to have multiple things working in parallel. </span><span class="koboSpan" id="kobo.65.3">Modern operating systems know about different independently running tasks via so-called threads. </span><span class="koboSpan" id="kobo.65.4">A </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.66.1">thread</span></strong><span class="koboSpan" id="kobo.67.1"> is a</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.68.1"> group of operations running sequentially, which means in a given order. </span><span class="koboSpan" id="kobo.68.2">The operating system then schedules when threads run and where (i.e., on which CPU core) they </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.69.1">are placed.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.70.1">These </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.71.1">principles together form a platform that seems easy to create, but hard to replicate. </span><span class="koboSpan" id="kobo.71.2">After all, there are plenty of JavaScript engines and useful libraries available. </span><span class="koboSpan" id="kobo.71.3">For Ryan Dahl, the original creator and maintainer of Node.js, the basis of the framework had to be </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.72.1">rock solid.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.73.1">Ryan Dahl selected an existing </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.74.1">JavaScript engine (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.75.1">V8</span></strong><span class="koboSpan" id="kobo.76.1">) to take over the responsibility of parsing and running the code written in JavaScript. </span><span class="koboSpan" id="kobo.76.2">The V8 engine was chosen for two good reasons. </span><span class="koboSpan" id="kobo.76.3">On the one hand, the engine was available as an open source project under a permissive license – usable by projects such as Node.js. </span><span class="koboSpan" id="kobo.76.4">On the other hand, V8 was also the engine used by Google for its web browser </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.77.1">Chrome</span></strong><span class="koboSpan" id="kobo.78.1">. </span><span class="koboSpan" id="kobo.78.2">It is</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.79.1"> very fast, very reliable, and under </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.80.1">active development.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.81.1">One of the drawbacks of using V8 is that it was written in C++ using custom-built tooling called </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.82.1">GYP</span></strong><span class="koboSpan" id="kobo.83.1">. </span><span class="koboSpan" id="kobo.83.2">While</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.84.1"> GYP was replaced in V8 years later, the transition was not so easy for Node.js. </span><span class="koboSpan" id="kobo.84.2">As of today, Node.js is still relying on GYP as a build system. </span><span class="koboSpan" id="kobo.84.3">The fact that V8 is written in C++ seems like a side note at first, but might be pretty important if you ever intend to write</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.85.1"> so-called </span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.86.1">native modules</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.87.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.88.1">Native modules allow you to go beyond JavaScript and Node.js – making full use of the available hardware and system capabilities. </span><span class="koboSpan" id="kobo.88.2">One drawback of native modules is that they must be built on each platform. </span><span class="koboSpan" id="kobo.88.3">This is </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.89.1">against the </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.90.1">cross-platform</span></strong><span class="koboSpan" id="kobo.91.1"> nature </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.92.1">of Node.js.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.93.1">Let’s take a step back to arrange the parts mentioned so far in an architecture diagram. </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.94.1">Figure 1</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.95.1">.1</span></em><span class="koboSpan" id="kobo.96.1"> shows how Node.js is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.97.1">composed internally:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.98.1"><img alt="Figure 1.1 – Internal composition of Node.js " src="image/Figure_1.1_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.99.1">Figure 1.1 – Internal composition of Node.js</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.100.1">The most important component in Node.js’s architecture – besides the JavaScript engine – is the </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.101.1">libuv</span></strong><span class="koboSpan" id="kobo.102.1"> library. </span><span class="koboSpan" id="kobo.102.2">libuv</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.103.1"> is a multi-platform, low-level library that provides support for asynchronous </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.104.1">input/output</span></strong><span class="koboSpan" id="kobo.105.1"> (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.106.1">I/O</span></strong><span class="koboSpan" id="kobo.107.1">) based </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.108.1">on an </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.109.1">event loop</span></strong><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">I/O happens in multiple forms, such as writing files or</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.111.1"> handling </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.112.1">HTTP requests</span></strong><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">In general, I/O refers to anything that is handled in a dedicated area of the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.114.1">operating system.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.115.1">Any </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.116.1">application running Node.js is written in JavaScript or some flavor of it. </span><span class="koboSpan" id="kobo.116.2">When Node.js starts running the application, the JavaScript is parsed and evaluated by V8. </span><span class="koboSpan" id="kobo.116.3">All the standard objects, such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.117.1">console</span></strong><span class="koboSpan" id="kobo.118.1">, expose some bindings that are part of the Node.js API. </span><span class="koboSpan" id="kobo.118.2">These low-level functions (such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.119.1">console.log</span></strong><span class="koboSpan" id="kobo.120.1"> or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.121.1">fetch</span></strong><span class="koboSpan" id="kobo.122.1">) make use of libuv. </span><span class="koboSpan" id="kobo.122.2">Therefore, some simple script that only works against language features such as primitive calculations (</span><em class="italic" lang=""><span class="koboSpan" id="kobo.123.1">2 + 3</span></em><span class="koboSpan" id="kobo.124.1">) does not require anything from the Node API and will remain independent of libuv. </span><span class="koboSpan" id="kobo.124.2">In contrast, once a low-level function (for example, a function to access the network) is used, libuv can be the workforce </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.125.1">behind it.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.126.1">In </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.127.1">Figure 1</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.128.1">.2</span></em><span class="koboSpan" id="kobo.129.1">, a block diagram illustrating the various API layers is shown. </span><span class="koboSpan" id="kobo.129.2">The beauty of this diagram is that it reveals what Node.js actually is: a JavaScript runtime allowing access to low-level functionality </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.130.1">from state-of-the-art </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.131.1">C/C++</span></strong><span class="koboSpan" id="kobo.132.1"> libraries. </span><span class="koboSpan" id="kobo.132.2">The Node.js API consists of the included Node.js bindings and some </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.133.1">C/C++ addons:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.134.1"><img alt="Figure 1.2 – Composition of Node.js in terms of building blocks " src="image/Figure_1.2_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.135.1">Figure 1.2 – Composition of Node.js in terms of building blocks</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.136.1">One thing </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.137.1">that would need explanation in the preceding diagram is how the event loop is implemented in relation to all the blocks. </span><span class="koboSpan" id="kobo.137.2">When talking about Node.js’s internal architecture, a broader discussion of what an event loop is and why it matters for Node.js is definitely required. </span><span class="koboSpan" id="kobo.137.3">So let’s get into </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.138.1">these details.</span></span></p>
<h1 id="_idParaDest-21" lang="en-GB"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.139.1">Understanding the event loop</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.140.1">An event loop</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.141.1"> is a runtime model that enables users to run all operations from a single thread – irrespective of whether the operations access long-running external resources or not. </span><span class="koboSpan" id="kobo.141.2">For this to work, the event loop needs to make requests to an event provider, which calls the specified event handlers. </span><span class="koboSpan" id="kobo.141.3">In Node.js, the libuv library is used for event </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.142.1">loop implementation.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.143.1">The reason for giving libuv the most space in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.144.1">Figure 1</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.145.1">.1</span></em><span class="koboSpan" id="kobo.146.1"> is to highlight the importance of this library. </span><span class="koboSpan" id="kobo.146.2">Internally, libuv is used for everything regarding I/O, which arguably is the most crucial piece of any framework. </span><span class="koboSpan" id="kobo.146.3">I/O lets a framework communicate with other resources, such as files, servers, or databases. </span><span class="koboSpan" id="kobo.146.4">By default, dealing with I/O is done in a blocking manner. </span><span class="koboSpan" id="kobo.146.5">This means that the sequence of operations in our application is essentially stopped, waiting for the I/O operation </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.147.1">to finish.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.148.1">Two strategies for mitigating the performance implications of blocking </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.149.1">I/O exist.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.150.1">The first strategy is to create new threads for actually performing these blocking I/O operations. </span><span class="koboSpan" id="kobo.150.2">Since a thread contains an independent group of operations, it can run concurrently, eventually not stopping the operations running in the original thread of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.151.1">the application.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.152.1">The </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.153.1">second strategy is to not </span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.154.1">use </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.155.1">blocking I/O</span></strong><span class="koboSpan" id="kobo.156.1"> at all. </span><span class="koboSpan" id="kobo.156.2">Instead, use an alternative variant, which is usually called non-blocking I/O or asynchronous I/O. </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.157.1">Non-blocking I/O</span></strong><span class="koboSpan" id="kobo.158.1"> works </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.159.1">with callbacks, that is, functions that are called under certain conditions – for instance when the I/O operation is finished. </span><span class="koboSpan" id="kobo.159.2">Node.js uses libuv to make extensive use of this second strategy. </span><span class="koboSpan" id="kobo.159.3">This allows Node.js to run all code in a single thread, while I/O operations </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.160.1">run concurrently.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.161.1">In </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.162.1">Figure 1</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.163.1">.3</span></em><span class="koboSpan" id="kobo.164.1">, the building blocks of libuv are displayed. </span><span class="koboSpan" id="kobo.164.2">The key part is that libuv already comes with a lot of functionality to handle network I/O. </span><span class="koboSpan" id="kobo.164.3">Furthermore, file and DNS operations are also </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.165.1">covered well:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.166.1"><img alt="Figure 1.3 – Building blocks of libuv " src="image/Figure_1.3_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.167.1">Figure 1.3 – Building blocks of libuv</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.168.1">In addition to the different I/O operations, the library comes with a set of different options for handling asynchronous </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.169.1">user code.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.170.1">The event loop itself follows</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.171.1"> the </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.172.1">reactor design pattern</span></strong><span class="koboSpan" id="kobo.173.1">. </span><span class="koboSpan" id="kobo.173.2">Wikipedia describes the pattern </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.174.1">as follows:</span></span></p>
<p class="author-quote" lang="en-GB"><span class="koboSpan" id="kobo.175.1">The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. </span><span class="koboSpan" id="kobo.175.2">The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers. </span><span class="koboSpan" id="kobo.175.3">(https://en.wikipedia.org/wiki/Reactor_pattern)</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.176.1">Importantly, this definition mentions synchronous dispatch. </span><span class="koboSpan" id="kobo.176.2">This means that code that is run through the event loop is guaranteed to not run into any conflicts. </span><span class="koboSpan" id="kobo.176.3">The event loop makes </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.177.1">sure that code is always run sequentially. </span><span class="koboSpan" id="kobo.177.2">Even though the I/O operations may concurrently run, our callbacks will never be invoked in parallel. </span><span class="koboSpan" id="kobo.177.3">From our perspective, even though Node.js will internally (through libuv) use multiple threads, the whole application </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.178.1">is single-threaded.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.179.1">The following is a simple script that shows you the basic behavior of the event loop at play – we’ll discuss how to run this in the </span><em class="italic" lang=""><span class="koboSpan" id="kobo.180.1">Using Node.js from the command </span></em><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.181.1">line</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.182.1"> section:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.183.1">events.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.184.1">console.log('A [start]');
setTimeout(() =&gt; console.log('B [timeout]'), 0);
Promise.resolve().then(() =&gt; console.log('C [promise]'));
console.log('D [end]');</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.185.1">We will run </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.186.1">this script in the next section when we learn about the command line usage of Node.js. </span><span class="koboSpan" id="kobo.186.2">In the meantime, put some thought into the preceding code and write down the order in which you’ll see the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.187.1">console</span></strong><span class="koboSpan" id="kobo.188.1"> output. </span><span class="koboSpan" id="kobo.188.2">Do you think it will print in an “</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.189.1">A</span></strong> <strong class="source-inline" lang=""><span class="koboSpan" id="kobo.190.1">B</span></strong> <strong class="source-inline" lang=""><span class="koboSpan" id="kobo.191.1">C</span></strong> <strong class="source-inline" lang=""><span class="koboSpan" id="kobo.192.1">D</span></strong><span class="koboSpan" id="kobo.193.1">” order, or </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.194.1">something else?</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.195.1">The algorithm of the implementation of the event loop in libuv is displayed in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.196.1">Figure 1</span></em></span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.197.1">.4</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.198.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.199.1"><img alt="Figure 1.4 – The implementation of the event loop in libuv " src="image/Figure_1.4_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.200.1">Figure 1.4 – The implementation of the event loop in libuv</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.201.1">While the code snippet only deals with JavaScript-related constructs (such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.202.1">console</span></strong><span class="koboSpan" id="kobo.203.1">, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.204.1">Promise</span></strong><span class="koboSpan" id="kobo.205.1">, and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.206.1">setTimeout</span></strong><span class="koboSpan" id="kobo.207.1">), in general, the callbacks are associated with resources that go beyond Node.js, such as file system changes or network requests. </span><span class="koboSpan" id="kobo.207.2">Some of these resources may have an operating system equivalent; others only exist in form of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.208.1">blocking I/O.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.209.1">Consequently, the</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.210.1"> event loop implementation always considers its thread pool and polls for progressed I/O operations. </span><span class="koboSpan" id="kobo.210.2">Timers (such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.211.1">setTimeout</span></strong><span class="koboSpan" id="kobo.212.1"> in the example script) are only run in the beginning. </span><span class="koboSpan" id="kobo.212.2">To know whether a timer needs to be run, its due time is compared with the current time. </span><span class="koboSpan" id="kobo.212.3">The current time is synced with the system time initially. </span><span class="koboSpan" id="kobo.212.4">If there is nothing to be done anymore (that is, no active timer, no resource waiting to finish, etc.), then the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.213.1">loop exits.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.214.1">Let’s see how we can run Node.js to solidify our knowledge about the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.215.1">event loop.</span></span></p>
<h1 id="_idParaDest-22" lang="en-GB"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.216.1">Using Node.js from the command line</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.217.1">Using JavaScript for</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.218.1"> a web application just requires you to open the website in a browser. </span><span class="koboSpan" id="kobo.218.2">The browser will evaluate the included JavaScript and run it. </span><span class="koboSpan" id="kobo.218.3">When you want to use JavaScript as a scripting language, you need to find a new way of running JavaScript. </span><span class="koboSpan" id="kobo.218.4">Node.js offers this new way – running JavaScript in a terminal, inside our computer, or from </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.219.1">a server.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.220.1">When Node.js is installed, it comes with a set of command-line tools that will be available in the terminal of your choice. </span><span class="koboSpan" id="kobo.220.2">For this book, you’ll need to know about three different executables that we’ll use throughout </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.221.1">the chapters:</span></span></p>
<ul>
<li lang="en-GB"><strong class="bold" lang=""><span class="koboSpan" id="kobo.222.1">node</span></strong><span class="koboSpan" id="kobo.223.1">: The </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.224.1">main application to run a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.225.1">Node.js script</span></span></li>
<li lang="en-GB"><strong class="bold" lang=""><span class="koboSpan" id="kobo.226.1">npm</span></strong><span class="koboSpan" id="kobo.227.1">: The</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.228.1"> default package manager – more on </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.229.1">that later</span></span></li>
<li lang="en-GB"><strong class="bold" lang=""><span class="koboSpan" id="kobo.230.1">npx</span></strong><span class="koboSpan" id="kobo.231.1">: A very </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.232.1">convenient utility to run </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.233.1">npm binaries</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.234.1">For now, we only need to know about </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.235.1">node</span></strong><span class="koboSpan" id="kobo.236.1">. </span><span class="koboSpan" id="kobo.236.2">If we want to run the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.237.1">events.js</span></strong><span class="koboSpan" id="kobo.238.1"> script from the previous section, we need to execute the following command in the directory in which the script (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.239.1">events.js</span></strong><span class="koboSpan" id="kobo.240.1">) has been placed. </span><span class="koboSpan" id="kobo.240.2">You can place it there by just inserting the content from the previous </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.241.1">events.js</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.242.1"> listing:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.243.1">
$ node events.js

A [start]

D [end]

C [promise]

B [timeout]</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.244.1">The command is shown after the conventional </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.245.1">$</span></strong><span class="koboSpan" id="kobo.246.1"> sign indicating the command prompt. </span><span class="koboSpan" id="kobo.246.2">The output of running the script is shown below the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.247.1">node </span></strong><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.248.1">events.js</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.249.1"> command.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.250.1">As you can see, the order is “</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.251.1">A</span></strong> <strong class="source-inline" lang=""><span class="koboSpan" id="kobo.252.1">D</span></strong> <strong class="source-inline" lang=""><span class="koboSpan" id="kobo.253.1">C</span></strong> <strong class="source-inline" lang=""><span class="koboSpan" id="kobo.254.1">B</span></strong><span class="koboSpan" id="kobo.255.1">” – that is, Node.js first handled all the sequential operations before the callbacks of the promise were handled. </span><span class="koboSpan" id="kobo.255.2">Finally, the timeout callback </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.256.1">was handled.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.257.1">The reason for handling the promise callback before the timeout callback lies in the event loop. </span><span class="koboSpan" id="kobo.257.2">In JavaScript, promises spawn so-called micro tasks, which are placed in the pending callback section of the libuv event loop from </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.258.1">Figure 1</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.259.1">.4</span></em><span class="koboSpan" id="kobo.260.1">. </span><span class="koboSpan" id="kobo.260.2">The timeout callback, however, is treated like a full task. </span><span class="koboSpan" id="kobo.260.3">The difference between them lies within the event loop. </span><span class="koboSpan" id="kobo.260.4">Micro tasks are placed in an optimized queue that is actually peeked multiple times per event </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.261.1">loop iteration.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.262.1">According </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.263.1">to libuv, the timeout callback can only be run when its timer is due. </span><span class="koboSpan" id="kobo.263.2">Since we only placed it in the event loop during the idle handles (i.e., main section) of the event loop, we need to wait until the next iteration of the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.264.1">event loop.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.265.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.266.1">node</span></strong><span class="koboSpan" id="kobo.267.1"> command-line application can also receive additional parameters. </span><span class="koboSpan" id="kobo.267.2">The official documentation goes into all details (</span><a href="https://nodejs.org/api/cli.html"><span class="koboSpan" id="kobo.268.1">https://nodejs.org/api/cli.html</span></a><span class="koboSpan" id="kobo.269.1">). </span><span class="koboSpan" id="kobo.269.2">A helpful one is </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.270.1">-e</span></strong><span class="koboSpan" id="kobo.271.1"> (short version of </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.272.1">--eval</span></strong><span class="koboSpan" id="kobo.273.1">) to just evaluate a script directly from the command-line input without requiring a file </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.274.1">to run:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.275.1">
$ node -e "console.log(new Date())"

2022-04-29T09:20:44.401</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.276.1">Another very helpful command line flag is </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.277.1">--inspect</span></strong><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">This opens the standard port for graphical inspection, for example, via the Chrome </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.279.1">web browser.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.280.1">Let’s run an application with a bit of continuous logic to justify an inspection session. </span><span class="koboSpan" id="kobo.280.2">In the terminal on your machine, run </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.281.1">the following:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.282.1">
$ node -e "setInterval(() =&gt; console.log(Math.random()), 60 * 1000)" --inspect

Debugger listening on ws://127.0.0.1:9229/64c26b8a-0ba9-484f-902d-759135ad76a2

For help, see: https://nodejs.org/en/docs/inspector</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.283.1">Now we can run a graphical application. </span><span class="koboSpan" id="kobo.283.2">Let’s use the Chrome web browser. </span><span class="koboSpan" id="kobo.283.3">Open it and go to </span><a href="https://chrome://inspect"><span class="koboSpan" id="kobo.284.1">chrome://inspect</span></a><span class="koboSpan" id="kobo.285.1">. </span><span class="koboSpan" id="kobo.285.2">This is a special Chrome-internal URL that allows us to see the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.286.1">available targets.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.287.1">The following figure (</span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.288.1">Figure 1</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.289.1">.5</span></em><span class="koboSpan" id="kobo.290.1">) shows how inspecting the Node.js application in the Chrome web browser </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.291.1">may look:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.292.1"><img alt="Figure 1.5 – Inspecting the Node.js application in the Chrome web browser " src="image/Figure_1.5_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.293.1">Figure 1.5 – Inspecting the Node.js application in the Chrome web browser</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.294.1">In this</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.295.1"> case, Chrome detected our application with the process ID </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.296.1">3420</span></strong><span class="koboSpan" id="kobo.297.1"> running. </span><span class="koboSpan" id="kobo.297.2">On your machine, the process ID will most likely be different. </span><span class="koboSpan" id="kobo.297.3">No filename was given, as we started with the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.298.1">-e</span></strong> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.299.1">command-line option.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.300.1">When you click on </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.301.1">inspect</span></strong><span class="koboSpan" id="kobo.302.1">, you’ll open the standard</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.303.1"> Chrome </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.304.1">DevTools</span></strong><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">Instead of debugging a website, you can now debug the Node.js application. </span><span class="koboSpan" id="kobo.305.3">For instance, you’ll already get the same </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.306.1">console</span></strong><span class="koboSpan" id="kobo.307.1"> output that you see in the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.308.1">command line.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.309.1">When you follow the link to the evaluated script from the DevTools console, you’ll get the ability to</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.310.1"> place </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.311.1">breakpoints</span></strong><span class="koboSpan" id="kobo.312.1"> or pause the execution. </span><span class="koboSpan" id="kobo.312.2">Pausing the execution may not work immediately, as an active JavaScript operation is required </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.313.1">for that.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.314.1">In </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.315.1">Figure 1</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.316.1">.6</span></em><span class="koboSpan" id="kobo.317.1">, you see how debugging a Node.js script in the Chrome DevTools </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.318.1">can look:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.319.1"><img alt="Figure 1.6 – Debugging a Node.js script in the Chrome DevTools " src="image/Figure_1.6_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.320.1">Figure 1.6 – Debugging a Node.js script in the Chrome DevTools</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.321.1">In the </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.322.1">preceding example, JavaScript is only run every minute. </span><span class="koboSpan" id="kobo.322.2">When the pause occurs, you should end up in the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.323.1">internal/timers.js</span></strong><span class="koboSpan" id="kobo.324.1"> part of Node.js itself. </span><span class="koboSpan" id="kobo.324.2">This is a different JavaScript file, but it’s part of the whole Node.js framework. </span><span class="koboSpan" id="kobo.324.3">The file can be integrated because it follows certain conventions and rules that are known </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.325.1">as CommonJS.</span></span></p>
<h1 id="_idParaDest-23" lang="en-GB"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.326.1">CommonJS</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.327.1">One thing that</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.328.1"> Node.js got right from the beginning was to introduce an explicit way of obtaining and using functionality. </span><span class="koboSpan" id="kobo.328.2">JavaScript in the browser suffered from the </span><em class="italic" lang=""><span class="koboSpan" id="kobo.329.1">global scope</span></em><span class="koboSpan" id="kobo.330.1"> problem, which caused many headaches </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.331.1">for developers.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.332.1">Global scope</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.333.1">In JavaScript, the global scope </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.334.1">refers to functionality that is accessible from every script running in the same application. </span><span class="koboSpan" id="kobo.334.2">On a website, the global scope is usually the same as the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.335.1">window</span></strong><span class="koboSpan" id="kobo.336.1"> variable. </span><span class="koboSpan" id="kobo.336.2">Attaching variables to the global scope may be convenient and sometimes even necessary, but it may also lead to conflicts. </span><span class="koboSpan" id="kobo.336.3">For instance, two independent functions could both try to write and read from the same variable. </span><span class="koboSpan" id="kobo.336.4">The resulting behavior can then be hard to debug and very tricky to resolve. </span><span class="koboSpan" id="kobo.336.5">The standard recommendation is to avoid using the global scope as much </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.337.1">as possible.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.338.1">The idea that other functionalities are explicitly imported was certainly not new when Node.js was introduced. </span><span class="koboSpan" id="kobo.338.2">While an import mechanism existed in other programming languages or frameworks for quite some time, similar options have also been available for JavaScript in the browser – via third-party libraries such </span><a id="_idIndexMarker038"/><span class="No-Break" lang=""><span class="koboSpan" id="kobo.339.1">as </span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.340.1">RequireJS</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.341.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.342.1">Node.js introduced its </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.343.1">module system</span></strong><span class="koboSpan" id="kobo.344.1"> with the</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.345.1"> name </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.346.1">CommonJS</span></strong><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">The basis for Node.js’s implementation was actually a project developed at Mozilla. </span><span class="koboSpan" id="kobo.347.3">In that project, Mozilla worked on a range of proposals that started with non-browser use but later on expanded to a generic set of JavaScript specifications for a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.348.1">module system.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.349.1">CommonJS implementations</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.350.1">Besides the </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.351.1">implementation in Node.js, many other runtimes or frameworks use CommonJS. </span><span class="koboSpan" id="kobo.351.2">As an example, the JavaScript that can be used in</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.352.1"> the </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.353.1">MongoDB</span></strong><span class="koboSpan" id="kobo.354.1"> database leverages a module system using the CommonJS specifications. </span><span class="koboSpan" id="kobo.354.2">The implementation in Node.js is actually only partially fulfilling the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.355.1">full specification.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.356.1">A module system is crucial for allowing the inclusion of more functionality in a very transparent and explicit manner. </span><span class="koboSpan" id="kobo.356.2">In addition to a set of more advanced functionality, a module system gives us </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.357.1">the following:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.358.1">A way of including more functionality (in CommonJS, via the global </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.359.1">require</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.360.1"> function)</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.361.1">A way of exposing functionality, which can then be included somewhere else (in CommonJS, via the module-specific </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.362.1">module</span></strong><span class="koboSpan" id="kobo.363.1"> or </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.364.1">exports</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.365.1"> variables)</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.366.1">At its core, the way CommonJS works is quite simple. </span><span class="koboSpan" id="kobo.366.2">Imagine you have a file called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.367.1">a.js</span></strong><span class="koboSpan" id="kobo.368.1">, which contains the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.369.1">following code:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.370.1">const b = require('./b.js');
console.log('The value of b is:', b.myValue);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.371.1">Now the</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.372.1"> job of Node.js would be to actually make this work, that is, give the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.373.1">b</span></strong><span class="koboSpan" id="kobo.374.1"> variable a value that represents the so-called exports of the module. </span><span class="koboSpan" id="kobo.374.2">Right now, the script would error out saying that a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.375.1">b.js</span></strong><span class="koboSpan" id="kobo.376.1"> file </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.377.1">is missing.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.378.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.379.1">b.js</span></strong><span class="koboSpan" id="kobo.380.1"> file, which should be adjacent to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.381.1">a.js</span></strong><span class="koboSpan" id="kobo.382.1">, reads </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.383.1">as follows:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.384.1">exports.myValue = 42;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.385.1">When Node.js evaluates the file, it will remember the defined exports. </span><span class="koboSpan" id="kobo.385.2">In this case, Node.js will know that </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.386.1">b.js</span></strong><span class="koboSpan" id="kobo.387.1"> is actually just an object with a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.388.1">myValue</span></strong><span class="koboSpan" id="kobo.389.1"> key with a value </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.390.1">of </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.391.1">42</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.392.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.393.1">From the perspective of </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.394.1">a.js</span></strong><span class="koboSpan" id="kobo.395.1">, the code can therefore be read </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.396.1">like this:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.397.1">const b = {
  myValue: 42,
};
console.log('The value of b is:', b.myValue);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.398.1">The advantage of using the module system is that there is no need to write the outputs of the module again. </span><span class="koboSpan" id="kobo.398.2">The call to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.399.1">require</span></strong><span class="koboSpan" id="kobo.400.1"> does that </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.401.1">for us.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.402.1">Side effects</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.403.1">Replacing the call to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.404.1">require</span></strong><span class="koboSpan" id="kobo.405.1"> with the module’s outputs is only meant for illustrative purposes. </span><span class="koboSpan" id="kobo.405.2">In general, this cannot be done as the module evaluation can have some so-called </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.406.1">side effects. </span><span class="koboSpan" id="kobo.406.2">A </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.407.1">side effect</span></strong><span class="koboSpan" id="kobo.408.1"> happens when implicit or explicit global variables are manipulated. </span><span class="koboSpan" id="kobo.408.2">For instance, already writing something to the console or outputting a file in the module evaluation is a side effect. </span><span class="koboSpan" id="kobo.408.3">If we’d only replace the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.409.1">require</span></strong><span class="koboSpan" id="kobo.410.1"> call with the imported module’s exports, we would not run the side effects, which would miss a crucial aspect of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.411.1">the module.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.412.1">In the given example, we used the name of the file directly, but importing a module can be more subtle than that. </span><span class="koboSpan" id="kobo.412.2">Let’s see a refined version of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.413.1">the code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.414.1">a.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.415.1">const b = require('./b');
console.log('The value of b is:', b.myValue);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.416.1">The</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.417.1"> call to</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.418.1">./b.js</span></strong><span class="koboSpan" id="kobo.419.1"> has been replaced by </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.420.1">./b</span></strong><span class="koboSpan" id="kobo.421.1">. </span><span class="koboSpan" id="kobo.421.2">This will still work, as Node.js will</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.422.1"> try various combinations for the given import. </span><span class="koboSpan" id="kobo.422.2">Not only will it append certain known extensions (such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.423.1">.js</span></strong><span class="koboSpan" id="kobo.424.1">) but it will also look at whether </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.425.1">b</span></strong><span class="koboSpan" id="kobo.426.1"> is actually a directory with an </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.427.1">index.js</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.428.1"> file.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.429.1">Therefore, with the preceding code, we could actually move </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.430.1">b.js</span></strong><span class="koboSpan" id="kobo.431.1"> from a file adjacent to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.432.1">a.js</span></strong><span class="koboSpan" id="kobo.433.1"> to an </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.434.1">index.js</span></strong><span class="koboSpan" id="kobo.435.1"> file in the adjacent </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.436.1">directory, </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.437.1">b</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.438.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.439.1">The greatest advantage, however, is that this syntax also allows us to import functionality from third-party packages. </span><span class="koboSpan" id="kobo.439.2">As we will explore later in </span><a href="B18989_02.xhtml#_idTextAnchor023"><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.440.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.441.1">, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.442.1">Dividing Code into Modules and Packages</span></em><span class="koboSpan" id="kobo.443.1">, our code has to be divided into different modules and packages. </span><span class="koboSpan" id="kobo.443.2">A </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.444.1">package</span></strong><span class="koboSpan" id="kobo.445.1"> contains </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.446.1">a set of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.447.1">reusable modules.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.448.1">Node.js already comes with a set of packages that don’t even need to be installed. </span><span class="koboSpan" id="kobo.448.2">Let’s see a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.449.1">simple example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.450.1">host.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.451.1">const os = require('os');
console.log('The current hostname is:', os.hostname());</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.452.1">The </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.453.1">preceding example uses the integrated </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.454.1">os</span></strong><span class="koboSpan" id="kobo.455.1"> package to obtain the current computer’s </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.456.1">network name.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.457.1">We can run this script with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.458.1">node</span></strong><span class="koboSpan" id="kobo.459.1"> in the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.460.1">command line:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.461.1">
$ node host.js

The current hostname is: DESKTOP-3JMIDHE</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.462.1">This script works on every computer that has </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.463.1">Node.js installed.</span></span></p>
<h1 id="_idParaDest-24" lang="en-GB"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.464.1">Summary</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.465.1">In this chapter, we discovered Node.js for the first time. </span><span class="koboSpan" id="kobo.465.2">You should now have a good idea of the core principles (such as event loop, threads, modules, and packages) upon which Node.js was built. </span><span class="koboSpan" id="kobo.465.3">You have read a bit about Node.js’s history and why V8 was chosen as the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.466.1">JavaScript engine.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.467.1">One of the key things to take away from this chapter is how the event loop works. </span><span class="koboSpan" id="kobo.467.2">Note that part of this knowledge is not exclusive to Node.js. </span><span class="koboSpan" id="kobo.467.3">The distinction between micro tasks and tasks is an integral part of how JavaScript engines, even the JavaScript engine of your </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.468.1">browser, work.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.469.1">Lastly, you are now equipped to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.470.1">node</span></strong><span class="koboSpan" id="kobo.471.1"> command-line application, for example, to run or debug simple scripts, which can export and import functionality using the CommonJS module system. </span><span class="koboSpan" id="kobo.471.2">You learned how to use the Chrome web browser to inspect Node.js scripts as you can </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.472.1">with websites.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.473.1">In the next chapter, we will increase our knowledge about CommonJS by learning how we can efficiently divide code into modules </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.474.1">and packages.</span></span></p>
</div>
</body></html>