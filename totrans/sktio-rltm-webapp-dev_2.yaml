- en: Chapter 2. Getting Started with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The definition of Node.js that is given on the Node.js website ([http://nodejs.org/](http://nodejs.org/)),
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is a platform built on Chrome's JavaScript runtime for easily building
    fast, scalable network applications. Node.js uses an event-driven, non-blocking
    I/O model that makes it lightweight and efficient, perfect for data-intensive
    real-time applications that run across distributed devices.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What matters to us is, Node.js as a part of the platform, provides a scalable
    and high-performance web application development framework, which allows programming
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Many of us got introduced to JavaScript while building websites or web applications
    for DOM manipulation, AJAX, and related stuff. But JavaScript is much more than
    that. Just like C, Java, Python, and so on, JavaScript is also a full-fledged
    programming language. In all browsers, JavaScript is executed in a virtual machine
    (VM), in the context of the browser. But it can also be executed in another context—as
    in the case of a Node.js backend—without the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js uses Google Chrome's JavaScript VM to execute JavaScript applications
    outside the browser, on the server. Along with this runtime environment, Node.js
    also provides a library of modules, which provides a framework for building network
    applications. Node.js is not a web server like the Apache HTTP server, or an application
    server like Tomcat; but as part of its modules library, Node.js does provide an
    HTTP Server, which can be used to build web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from having JavaScript as the programming language for the applications,
    one thing that sets Node.js (and most of the Node.js modules and applications)
    apart from the traditional servers and applications is the asynchronous event-driven
    development model, which we will see in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: The origin of Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is not the first time that JavaScript has been used for server-side programming.
    Netscape launched Netscape Enterprise Server in 1996, which allowed server-side
    programming in JavaScript. Since then, many servers, such as **RingoJS** ([http://ringojs.org/](http://ringojs.org/)),
    **Persevere** ([http://www.persvr.org/](http://www.persvr.org/)), Mozilla's Rhino-based
    servers, and others have tried to follow suit.
  prefs: []
  type: TYPE_NORMAL
- en: A major reason for these servers not being taken seriously was the pitiful performance
    of the JavaScript VMs used by them. JavaScript performance in browsers was also
    not very good. That was until Google launched its Chrome web browser.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of its launch, Chrome's JavaScript VM, called **V8**, was almost
    10-20 times faster than any other JavaScript VM, and has since then been the fastest.
  prefs: []
  type: TYPE_NORMAL
- en: It was based on this VM that Ryan Dahl developed Node.js in 2008\. He wanted
    to build a server that would enable and empower real-time interactive web applications
    like Gmail. But Node.js was not the first server he built. Ryan built Ebb, a web
    server based on Ruby and C, but realized that it wasn't working as fast as he
    wanted it to. This was followed by several experiments in building a number of
    small web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the knowledge gained from his experiments and the study of various
    platforms, he decided to develop an event-driven or asynchronous server. In the
    January of 2008, he came up with the idea of building a small web server based
    on JavaScript. He was inclined towards JavaScript because it was independent of
    the OS and came without any I/O APIs. He quit his job and worked on Node.js for
    6 months. In November 2009, he presented Node.js in JSConf, and has been working
    for Joyent since then. Initially, Node.js worked only on Unix-based systems; later,
    it came with support for Windows OS too.
  prefs: []
  type: TYPE_NORMAL
- en: Why Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is a new platform and is still evolving (not even a version 1.0 has
    been released yet), but even in its infancy, it is probably one of the most popular
    platforms on the Web. It is already powering a large number of popular services.
    Let us take a look at what makes Node.js such a tempting and popular proposition.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript everywhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and foremost advantage of Node.js is JavaScript. If you know and code
    in JavaScript regularly, you already know most of Node.js; all that's left to
    learn can be thought of as APIs and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js—built over Google Chrome's V8 JavaScript engine—allows entire applications
    to be written using JavaScript. We have already been writing frontends in JavaScript;
    with Node.js, we write the backend as well, in the same language that we have
    honed our skills on and grown to love. It saves every frontend developer from
    learning one more language or relying on some other developer to expose the RESTful
    APIs required by their application.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js was designed around events and callbacks. As a JavaScript developer,
    you would already be familiar with the concept of listening to events and using
    callbacks. Node.js incorporates this philosophy in each and every aspect of the
    platform. Be it in server request handling, I/O, or database interactions, everything
    in Node.js will ideally be handled by a callback attached to an event by a listener.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to one of the most important concepts behind Node.js, that is,
    the *event loop*. I like the fast food restaurant analogy by Dan York ([http://code.danyork.com](http://code.danyork.com))
    for explaining event loop-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a restaurant where you go to the cashier, place your order, and wait
    till your food is ready. In this case, the cashier cannot serve the other customers
    till you have your order, and the queue is blocked. If the restaurant has a large
    inflow of customers and needs to scale up, they will have to invest in hiring
    more number of cashiers, creating more cash counters, and so on. This is similar
    to the traditional multithreading model.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, let us see the model many other restaurants use. In this case,
    you go to the cashier and place your order (which he/she hands over to the kitchen);
    he/she then accepts your payment and gives you a token. You then step aside, and
    the cashier moves on to the next customer. When your order is ready, the kitchen
    server announces this by calling your name or flashing your token number, and
    you walk up and fetch your order. This event-oriented approach optimizes the work
    of the cashier and lets you wait on the side, freeing up the relevant resources
    to service others until your work is done.
  prefs: []
  type: TYPE_NORMAL
- en: In Node.js, the server is the cashier, and all the handlers are the kitchen
    crew. The server accepts a request and spins it off to a handler. It then moves
    on to accept other requests. When the request is processed and the results are
    in place, the response is queued on the server and sent back to the client when
    it reaches the front of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: As opposed to the traditional approach of launching the threads or processes
    of the server (which is similar to adding more cashiers), this method is more
    efficient, as the workers launched have dedicated responsibilities. This is much
    lighter and cheaper than replicating the entire server.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections ahead, we will see that we register the handlers or the workers
    with the server to handle certain requests, and all the server does is delegate
    the requests to these workers.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the event-driven design is that everything we design is non-blocking.
    "You don't wait on me, I call you" is the mantra that relieves us from the pain
    involved in waiting on a request to be fulfilled. It frees up the system resources
    that would have otherwise been spent in waiting on the request, so that they can
    be used for the other tasks in the queue. This allows the Node.js applications
    to give a very high performance and capability of handling a very high load.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is a modular framework with a modern module system from the ground up.
    Everything in Node.js is built as modules running in the V8 JavaScript engine.
    Every functionality in the platform is provided by means of modules. This keeps
    the platform lean and brings in only that what is required. Having a native module
    system also helps in keeping our applications modular.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has become one of the most widely-used languages in the past few
    years and has a vibrant community. Node.js provides developers with a good platform
    that assists them in developing end-to-end applications in JavaScript. Node.js
    has also brought in many revolutionary concepts, namely, always asynchronous,
    non-blocking I/O, event-oriented servers, and so on. This has resulted in a very
    vibrant, large, and active community. New modules are coming up continuously,
    and the community provides active support and is very helpful. Most of the popular
    modules and frameworks built for Node.js generally come from the community and
    are mostly open source.
  prefs: []
  type: TYPE_NORMAL
- en: Corporate backing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many companies have invested heavily in Node.js in the past couple of years.
    From Ryan Dahl's employer, Joyent, to the creators of the Mojito framework (Internet
    giant Yahoo!), many companies have built products, platforms, frameworks, and
    services around Node.js. This kind of corporate commitment assures a stable future.
  prefs: []
  type: TYPE_NORMAL
- en: How to get Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the popularity of Node.js, it is very easy to get it working on any operating
    system. You can go to [http://nodejs.org/](http://nodejs.org/) and download the
    appropriate distribution for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though Node.js works on any OS, as it comes from the *nix background, many modules
    might only work on Linux or other Unix systems; so it is best to use such a system
    if you have one at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Linux, in most cases, you should be able to install Node.js
    using your distribution''s package manager. As this information keeps changing,
    I''ll just point out the location instead. You''ll find the instructions for installing
    Node.js using package manager here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Mac OS or Windows, you should know that Node.js now provides
    an installer for these platforms, which is the recommended installation approach.
    You can also install using the source. Instead of repeating that process here,
    which is again subject to change, I'll suggest that you follow the official installation
    instructions on the Node.js wiki, on GitHub ([https://github.com/joyent/node/wiki/Installation](https://github.com/joyent/node/wiki/Installation)).
  prefs: []
  type: TYPE_NORMAL
- en: Node.js package manager (npm)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you installed Node.js using the installer from the Node.js website, you will
    already have npm installed.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you followed the instructions to build from the source, you will probably
    have installed npm. If that is a yes, very good! If no, please do so now. For
    this, I recommend that you follow the instructions mentioned in the npm installation
    documentation ([https://github.com/isaacs/npm/](https://github.com/isaacs/npm/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check if you have npm installed by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This should display the version of npm installed.
  prefs: []
  type: TYPE_NORMAL
- en: For those who are wondering what npm is and why you would need a package manager
    for Node.js, npm is just what its name says; it provides an infrastructure in
    Node.js to distribute and manage packages. As I said earlier, Node.js is very
    modular. Node.js apps are built using many modules and third-party packages because
    npm provides an easy way of adding and managing third-party dependencies for our
    applications. We will see more on its use in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, the obligatory Hell World example uses Node.js. Write the following line
    in a file called `helloworld.js` and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And now to run it, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This should print **Hello World** on the console. All the JavaScript developers
    will immediately recognize that these are the steps we follow to print anything
    on the console while developing a web application.
  prefs: []
  type: TYPE_NORMAL
- en: What happens is that Node.js loads the JavaScript file in the JavaScript VM,
    provides an environment for its execution, and the VM interprets the script. When
    it gets `console.log`, it checks the environment for the console, which in this
    case is `STDOUT`, and writes **Hello World** to it.
  prefs: []
  type: TYPE_NORMAL
- en: But we are here to develop web applications, correct? So let's say hello to
    the Web!
  prefs: []
  type: TYPE_NORMAL
- en: Hello Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us make a very simple web application that greets the user with a hello.
    Write the following code in a file, and name it `helloweb.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the previous piece of code, execute `helloweb.js` in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And then open `http://localhost:9999/` in your browser. You should see a page
    saying **Hello Web**. There is a lot going on here! So let us walk through the
    code and understand what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: The very first line of code introduces us to one of the fundamental building
    blocks of Node.js, the module system. Node.js has a very simple module system
    built on CommonJS. Those familiar with frontend development using RequireJS with
    **Asynchronous Module Definition (AMD)** will immediately relate to this. All
    the functionality in Node.js is built as modules and you need to import it in
    your code using `require`. Node.js has several modules compiled in a binary form,
    called core modules, HTTP being one of them. We can also create and include our
    own custom or third-party modules using `require`. In case of file modules, there
    is one-to-one mapping between a file and a module; so we write every module in
    its own file. We will see more on writing our own modules later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this statement, Node.js will load the core HTTP module, and it will be
    available in a variable called `http`. The next task is to create a server using
    the HTTP module. This is done using the `createServer` method from the module.
    The `createServer` method accepts `requestListener`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `requestListener` is a function that handles the incoming requests. In our
    case, this function is passed *inline*. Just like JavaScript in a browser, Node.js
    also runs a single process and a single thread. This is different from the traditional
    application servers, which create a new thread or process to handle new requests.
    So to scale and handle multiple requests, Node.js uses asynchronous event handling.
    So every request that comes in triggers an event, which is then handled by the
    event handler asynchronously. This is the mechanism of the event loop explained
    in earlier sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: The way `createServer` works is similar to any event handler in JavaScript.
    The event in this case is receiving a request to serve. As we can see, `requestListener`
    takes two arguments, `request` and `response`. The `request` object is an instance
    of `http.ServerRequest`, and will have all the information about the request,
    such as URL, method, headers, and data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `response` object is an instance of `ServerResponse`, which implements
    a `WritableStream`. It exposes various methods to write the response to the client;
    the ones we are most interested in, for now, are `writeHead`, `write` and `end`.
    Let us first see `writeHead`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `statusCode` is the HTTP response code, `reasonPhrase` is the optional
    human-readable response phrase, and `headers` is the object that has the headers,
    which are to be sent in the response. This function should be called only once,
    before calling `response.end`. If we call `response.write` or `response.end` before
    this, the implicit/mutable headers will be calculated and the following function
    will be called automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this call, we are setting the status code to `200`, that is, HTTP OK, and
    we are only setting the `Content-Type` header to `text/html`. The next method
    here is `response.write`, it''s used to write the response content to the client.
    The call to this method is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this call, `chunk` is the content to write and `encoding` is the content
    encoding to use. If the chunk is a string and the encoding is not specified, UTF-8
    will be used by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, the first time `write` is called, Node.js sends the response
    headers and the chunk of the body. But the `write` method can then be called multiple
    times. Node.js will assume that we are streaming data, and will keep sending the
    chunk whenever the calls are made. And the last call on the response is made to
    tell Node.js that we are done. This is just what `response.end` does.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`response.end` signals to the server that all the response headers and body
    content have been sent and that the server should consider this message complete.
    We *must* call this method for every message.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we call `response.end` without any of the optional arguments. If
    we do pass in the parameters, it is equivalent to calling `response.write` with
    the parameters, followed by `response.end`. I prefer keeping them separate, and
    hence, explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to tell the HTTP server which port it should listen on. In
    this case, we tell it to listen on port 9999.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Routing the requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost any web application serves more than a single resource. So now we know
    how to serve content using an HTTP server; but how do we handle multiple resources?
    Routing is the name of the game. We need to understand the incoming request and
    map it to the appropriate request handler. This is a bit more complicated than
    the previous example, so we will build it step by step, improving it with every
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the routing of requests, let us build a simple application that
    serves two resources at `/start` and `/finish`, displaying **Hello** and **Goodbye**
    respectively. To simplify the code, we will serve plain text. So before anything
    else, let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the previous code snippet in a file called `routing.js` and execute it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we access `http://localhost:9999/start`, we will see **Hello** in
    the browser. Similarly, when we access `http://localhost:9999/finish`, we will
    see a message saying **Goodbye**. If we try to access any other path, we will
    get an HTTP 404 or Not Found error. Let us now try and understand the new things
    we are introducing in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we need in order to route a request, is to parse the URL;
    for this we will introduce another inbuilt module called `url`. When a URL string
    is parsed using the `url` module, it returns an instance of the URL. In this case,
    we are interested in the pathname.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous line of code, we are passing the `url` string from the request,
    and parsing it using the `url` module, to get the `pathname`. The next step is
    to send an appropriate response, based on the path being accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here we are comparing the pathname with the one we are expected to handle, and
    accordingly an appropriate response is sent out. And what happens to the requests
    we don't handle? That is what the last part of the if-else-if ladder does. It
    sends an HTTP 404 error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us think about extending this application. To handle more paths, we
    will have to add more if-else conditions. But that doesn''t look clean, is difficult
    to read, and is very inefficient in execution. Think about the route handled in
    the last step of the if-else ladder; the process still has to go through the entire
    ladder, checking for every condition. Also, adding new routes to this will require
    us to go through and edit this if-else ladder, which will be at the very least,
    confusing, and can also easily result in errors, typos, and a high chance of unintentional
    modification to the existing routes. So let us make it a bit cleaner by putting
    the handlers in an object mapped by their paths, and also provide an API to extend
    it. So let us change our code to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this code snippet, execute the file with Node.js, using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The functionality of the application will be the same as the result of the previous
    example. When we access either `/start` or `/finish`, it will respond with **Hello**
    for the former, and **Goodbye** for the latter. On trying to access any other
    path, we will get an HTTP 404 message.
  prefs: []
  type: TYPE_NORMAL
- en: The change we have made here is that we have thrown out the if-else-if ladder
    in favor of a clean and efficient design approach. In this approach, we don't
    need to play around with existing routes and can add new routes by calling the
    `route.for` method from any module. The route has a map of the path to the `handler`
    function and also has a `on` method to add new routes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we are adding two new handlers for the paths `/start` and `/finish`. The
    signature for the handlers is similar to the main request handler. We expect the
    handlers to get the request and response, so that the handler has everything it
    needs to process the request and send the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the if condition, we check whether the route for the pathname is present,
    and whether it is a function. If we find a handler for the requested path, we
    execute the `handler` function, passing the request and response to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If it is not found, we respond with an HTTP 404 error. Now, to add a new path,
    we can call the `route.on` method with the path and its handler to register it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: HTTP Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP is not only about the path, we also have to think about the HTTP methods.
    In this section, we will enhance our app to handle the different HTTP methods:
    `GET`, `POST`, `PUT`, and `DEL` `TE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first step towards this, we will add the ability to add different handlers
    for different methods. We will add the methods in the mapping in resources.js,
    which is a minor change. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and execute with Node.js. The functionality still remains the
    same, but we will be able to handle different methods using different handlers.
    Let us create a new handler to echo the incoming data on `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are adding a new handler for the `POST` request on the `/echo` path.
    We again see the use of the event-driven approach of Node.js, this time in handling
    the data that comes in with `POST`. Since `request` is an event emitter, we attach
    an event handler to it for each task: for handling chunks of incoming data and
    for completing the request processing once all the data is received.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the previous piece of code, we add a listener on the request to handle chunks
    of incoming data. In this case, all we do is accumulate the incoming data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The event handler on `end` will be invoked once all the data sent in `POST`
    has been received. This is the time at which we finish receiving all the data.
    To build an echo service, we will send back all the accumulated data. We will
    now create a form to post the request to this handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We will add an event handler to the same path (`/echo`), but this time, to handle
    a `GET` request. In the handler, we will return an HTML page with a form to post
    to the same path.
  prefs: []
  type: TYPE_NORMAL
- en: Add these two handlers to our `route-handlers.js` and execute it with Node.js.
    To open our form, go to `http://localhost:9999/echo`; then, to trigger our handler,
    type in a message in the form's textbox and click on the **echo** button. This
    will post the content of the form, and in response we will see `msg=<your text>`
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modules are the basic building blocks of Node.js applications. With all our
    changes, our file is becoming a bit clumsy; moreover, we are putting our infrastructure
    (server and router) with the application logic (the handlers) in the same place.
    As mentioned earlier, Node.js builds on the CommonJS module system. In Node.js,
    a module and a file have a one-to-one relation. Let us move the server and router
    to their own modules. Save the following in a file called `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Most of the logical aspects of the code remain the same, but we have made some
    very subtle structural changes. The first one is that we have taken the routes
    out of the `route` object. Any variables declared in the file are available within
    the module and are not accessible from outside the module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As the `route` object is gone, we can now directly access the routes within
    the module and not through the `route` object.
  prefs: []
  type: TYPE_NORMAL
- en: The other and more obvious change is `exports`. Since nothing from within the
    module is available outside the module, we have to add the methods/objects that
    we want to expose to the implicit `exports` object. Ideally, you should expose
    only those methods relevant to the end user of your module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We are exposing two methods from our module: the `forRoute` method (originally,
    the `on` method in the `route` object), and the `start` method that wraps the
    code to start the HTTP server. We also move the application logic to its own module
    called `app.js`, which is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Again, the logical aspects remain unchanged; the changes are only in the structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous line, which is also the first line in the previous code snippet,
    shows us how our server module is loaded. This is similar to loading core modules
    like HTTP or URL, but here we are loading the module and passing its filename.
    The object created by this `require` method, the `server` object, will have two
    methods that will be exposed: `forRoute` and `start`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we replace all the calls to `route.on` with the `server.forRoute` method.
    . And finally, we call the `server.start` method to start the HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Serving files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see that it''s not very intuitive or easy to write HTML pages with our
    current infrastructure. Writing the HTML in the JS code as strings is not fun.
    We would like to serve the HTML content from the HTML files. We will begin with
    taking in two modules, which we will need to read from a file (on the disk) in
    our `app` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first one, `path`, is the module we use to work with paths, and `fs` is
    the module used to interact with the filesystem. The next step is to get the path
    to the application's root.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`__dirname` is a variable managed by Node.js and has the absolute path to the
    directory of the Node.js application script. Now, we add the method that will
    be doing the heavy work of reading the file and sending it to the browser. Add
    this method to `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `serveStatic` method that we have created accepts two arguments, the HTTP
    response object and the file path to serve.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We append the file path to our root path to build the absolute path of the file
    to serve. Here we are implicitly assuming that all the files to be served are
    relative to the Node.js application root; this will prevent a file outside the
    application from being served by mistake. Node.js handles I/O as streams. We can
    see that this is similar to the way it handles the incoming `POST` data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We use `createReadStream` from the `fs` module to create a stream that reads
    from the file. This stream again demonstrates the non-blocking, asynchronous,
    and event-driven approach of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The stream works as an event emitter, triggering the `'data'` event when there
    is new data on the stream. This allows the application to continue with the other
    processing activities, without having to wait for the data to be read. What we
    are doing here is, we are writing the data we receive on every `read` to the `response`
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Once all the data from the file is read and the stream gets an EOF, it will
    trigger the `'end'` event. We will call `end` on our response as well. Finally,
    we will modify the `GET` handler `"/echo"` to serve from a file called `echo.html`,
    and write the content of the HTML to be served to that file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We have removed all the code to build the `response` string, replacing it with
    a call to `serveStatic` to serve `echo.html`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The content that we were previously building as a string is now written to this
    file. Once we make these changes and run `app.js` with Node.js, you should be
    able to see the form on `http://localhost:9999/echo` retaining its original functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Those familiar with Unix-like operating systems will realize that the functionality
    we just implemented to read from one stream and write to another can also implemented
    by using pipes (`|`). It shouldn't come as a surprise that Node.js provides a
    high-level function to do exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `pipe` method provided on `stream` in Node, we can modify the `serveStatic`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we are replacing the data and end event handlers using `stream.pipe(response)`.
  prefs: []
  type: TYPE_NORMAL
- en: Third party modules and Express JS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have built a router of our own and understand the basics of Node.js,
    it is time to get introduced to one of the most widely-used frameworks for Node.js,
    Express ([http://expressjs.com](http://expressjs.com)). Node.js provides the infrastructural
    components to build a web application, but there is too much stuff to handle.
    Therein lies the role of the web frameworks. There are quite a few web frameworks
    that provide a higher level of abstraction for building applications on Node.
    You can see a list of most of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/joyent/node/wiki/Modules#wiki-web-frameworks-full](https://github.com/joyent/node/wiki/Modules#wiki-web-frameworks-full)'
  prefs: []
  type: TYPE_NORMAL
- en: Express is a web application framework for Node, built over the Connect middleware,
    that provides many more helpers and structural aspects to build our web applications.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with the Express framework, we need to install it using npm,
    the Node.js package manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will install Express as a global (`-g`) module and make
    `express` available as a command. Let us create an Express app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This will create a folder called `hello-express` with certain files and folders
    in it. Let us see and understand these files.
  prefs: []
  type: TYPE_NORMAL
- en: The first file to understand is `package.json`. This is the file that defines
    a Node.js application package. It has the application metadata such as the name,
    description, and version. More importantly, it has the module dependencies listed.
    The dependency list is used by npm to download the required modules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important things in your `package.json` are the `name` and `version`
    fields. These fields are required, and together, they form a unique identifier
    for a particular release of the package. To begin with, let us change the name
    of our package to `hello-express`. The `version` field consists of the following
    (in the same order):'
  prefs: []
  type: TYPE_NORMAL
- en: A number (major version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number (minor version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number (patch version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: a hyphen, followed by a number (build)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: a collection of pretty much any non-whitespace characters (tag)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we set `private` to true, npm will not publish it to a repository. This ensures
    that you don't end up publishing your code to a public repository by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: The `scripts` object has a mapping of commands to those points in the application
    lifecycle at which they should be run. In this package, we are telling Node.js
    that it should run the `node app` command when the application is started with
    npm. There are some predefined lifecycle commands, such as `start`, `stop`, `restart`,
    and `test`, which can be run using `npm <command>` like `npm start`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run arbitrary commands using `run-script`. For this, you add the
    command to the `scripts` object and then run it as `npm run-script <command>`.
  prefs: []
  type: TYPE_NORMAL
- en: And finally—the most interesting part of the package that brings in the magic—`dependencies`.
    This object is a mapping of the name and version of your dependency packages and
    will be used by npm to pull in all the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our package, `express` has already defined the dependency on Express and
    Jade. To pull in these dependencies, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The output will list all the dependencies it downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: '**jade@0.27.2 node_modules/jade**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── commander@0.6.1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**└── mkdirp@0.3.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**express@3.0.0rc2 node_modules/express**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── methods@0.0.1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── fresh@0.1.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── range-parser@0.0.4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── cookie@0.0.4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── crc@0.2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── commander@0.6.1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── debug@0.7.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── mkdirp@0.3.3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**├── send@0.0.3 (mime@1.2.6)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**└── connect@2.4.2 (pause@0.0.1, bytes@0.1.0, qs@0.4.2, formidable@1.0.11)**'
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies will be placed in a folder called `node_modules`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will take a look at the application file `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first few lines, Node.js loads the modules required for us to work with.
    We are already familiar with `http` and `path`. The `express` module brings in
    the Express framework. And one more module that we are loading in is `./routes`,
    which will load the module defined in the local `routes` folder, defined by `./routes/index.js`.
    The following code snippet focuses on the first few lines of the previous code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next line, it instantiates the Express framework as an app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then comes the application configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the previous few lines, we are defining a function that will configure the
    app. The signature for `app.configure` is `app.configure([env], callback)`, where
    `env` is the runtime environment variable *or* the production environment variable,
    as is defined by `process.env.NODE_ENV`. When we don't specify `env`, it will
    be set for all environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following settings have been provided to alter how Express behaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '`env`: Environment mode, defaults to `process.env.NODE_ENV` or "development"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trust proxy`: Enables reverse proxy support, disabled by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsonp callback`: Enables JSONP callback support, enabled by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsonp callback name`: Changes the default callback name of `?callback=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json replacer`: JSON replacer callback, `null` by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json spaces`: JSON response spaces for formatting; defaults to `2` in development,
    `0` in production'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case sensitive routing`: Enables case sensitivity, disabled by default, treating
    `/Foo` and `/foo` as the same'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strict routing`: Enables strict routing, by default `/foo` and `/foo/` are
    treated the same by the router'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view cache`: Enables view template compilation caching, enabled in production
    by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view engine`: The default engine extension to use when omitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views`: The view directory path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how to assign settings to an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The settings used by the application here are `port`, `views`, and `view engine`,
    specifying that the application should run on port `3000`, the views will be placed
    in the `views` folder, and the engine to be used is Jade. We will see more about
    views later. Certain features can also be specified, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As Express builds over Connect middleware, it brings in a lot of existing functionality
    from Connect. Connect's `use` method configures the app to utilize the given middleware
    handle for the given route, where the route defaults to `/`. You can see the list
    of middleware provided by Connect at [http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/).
  prefs: []
  type: TYPE_NORMAL
- en: Let us walk through the middleware components being used here. The Favicon middleware
    will serve the favicon for the application. The Logger middleware logs requests
    in a custom format.
  prefs: []
  type: TYPE_NORMAL
- en: The Body parser parses the request bodies supporting different formats; this
    includes `application/json`, `application/x-www-form-urlencoded`, and `multipart/form-data`.
  prefs: []
  type: TYPE_NORMAL
- en: Method Override enables the faux HTTP method support. This means that if we
    would like to stimulate the `DELETE` and `PUT` method calls to our application,
    we can do it by adding a `_method` parameter to the request.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.router` provides an enhanced version of Connect''s `router` module. Basically,
    this is the component that determines what to do when we use routing methods like
    `app.get`. The last middleware, Static, provides a static file server and configures
    it, serving files from the `public` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: For the development environment, the following two lines of code show how to
    set up the Error handler middleware so as to provide stack traces and error messages
    in the responses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line configures the router to route `/` to be handled by the `index`
    method in the `routes` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: At the end, we start the HTTP server configured to use the app instance that
    we just configured.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the configuration of the app, we saw some folders coming into play, namely,
    `routes`, `views`, and `public`.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes` is a module that we will be writing all our handlers to. In the case
    of `/`, we have mapped it to serve from the index method, using the `routes.index`
    method. If you open `routes/index.js`, you will see that `index` is a method exposed
    from this module.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This function signature is similar to the handlers we wrote. It is a function
    that takes a request and response as parameters. Here we are using the Express
    method `response.render`, which will render the mentioned view using the second
    parameter as the model or data.
  prefs: []
  type: TYPE_NORMAL
- en: The views are present in the `views` folder and use the Jade ([http://jade-lang.com/](http://jade-lang.com/))
    view engine. Jade is a high-performance template engine, heavily influencedby
    Haml ([http://haml.info/](http://haml.info/)), and implemented with JavaScript
    for Node.js. Like many modern HTML generation engines, Jade tries to make the
    UI code easier, cleaner, and simpler, getting rid of the inline code and the HTML
    tags noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now see the views defined in our Express app. There are two files to
    see here: `layout.jade` and `index.jade`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout.jade`, as the name suggests, is the template for the layout that will
    be used by the different pages in our application. It may be used to place the
    common code of the skeleton for the pages in our application, which is shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In Jade, we don''t need the `start` and `end` tags because it identifies the
    start and end of the tags by the indented blocks. So when we render this Jade
    file, it will generate the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous piece of code, two things are left undefined, `{TITLE}` and
    `{CONTENT}`. In the Jade template, we define the title as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We tell Jade to use the title from the data passed to `render` as `title`. The
    second thing, `{CONTENT}`, is defined as block in Jade.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`block content` is a plugin point provided in the layout template, which can
    be described by any template extending from it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.jade` inherits from `layout.jade`. In our index handler, we render the
    index view using the data `{title: ''Express''}`. Take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous file, we define the content block to have a `h1` and `p` tags.
    So, with the given input and because it extends the layout, the Jade engine will
    generate the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We will see more functionality and syntax in Jade as we work on our chat application
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the HTML code generated, we can see that `/stylesheets/style.css` is being
    referred to; this file is served by the static file server we configured in the
    app. We can find this and the other files in the public folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this application, we will use npm. Run the following command on the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Then go to `http://localhost:3000/`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we were introduced to the Node.js and Express web frameworks.
    As mentioned earlier, this is in no way a complete introduction to Node.js or
    Express. To learn more, please refer to the vast documentation available online
    or any of the books written on Node.js web development.
  prefs: []
  type: TYPE_NORMAL
