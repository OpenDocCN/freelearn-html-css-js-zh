<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building the Frontend</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will build the web pages of our demo application. The objective here is not to teach frontend development, but to demonstrate that you can use modern tools along with serverless. For this demo, we will use React, but you could use Angular, Vue.js, or any other tool, and still take advantage of the serverless features. <span>Also, we will discuss the pros and cons of</span> SPA <span>from a serverless perspective and let's take a look at how we can prerender SPA pages for better <strong>Search Engine Optimization</strong> (<strong>SEO</strong>).</span></p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to use React to build our web pages</li>
<li>Pros and cons of Single-Page Applications</li>
<li>Prerendering pages for a better SEO</li>
</ul>
<p>After this chapter, you'll have built the frontend of our serverless online store.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with React</h1>
                </header>
            
            <article>
                
<p>Teaching frontend tools is not the objective of this book, but we need to build something useful to <span>see how serverless deals with modern frontend development. We will use React here because it is currently one of the most popular tools.</span> <span>If you don't know what React is or how to use it, I'll guide you to understand the basic concepts.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">React principles</h1>
                </header>
            
            <article>
                
<p>The first thing you should note is that React is a library and not a framework. The difference is that a library provides a set of functionalities to solve a <em>specific</em> problem, and a framework provides a set of libraries centered on a particular methodology.</p>
<p>React is only responsible for the view layer of your application. That's the problem React solves. If you need to make Ajax calls or handle page routes, you need to add other libraries. When you develop with React, you need to think in components. Your user interface is a composition of simple components, where each one of them has an inner state and an HTML definition. When using React, you don't manipulate the web page directly. You change the component's state and React will render it again to match the current state. This approach promotes predictability. For a given state, you always know how the component will render. This is very important for testing and maintaining complex applications.</p>
<p>Another important concept is the virtual DOM. The <strong>Document Object Model</strong> (<strong>DOM</strong>) is a representation of all nodes of an HTML page. If something changes on a page and you need to render a different view, the DOM needs to be manipulated. The problem is when you have hundreds of nodes. Recreating the entire view has a performance cost that can be perceived by the user.</p>
<p>The virtual DOM is an abstract version of the real DOM. React tracks the state of all components and knows when one of them was modified. Instead of rerendering the entire view, it compares the modified virtual DOM with the real DOM and makes a small patch containing only the differences. This patch is applied with a much better performance.</p>
<p>In summary, you need to know that React is a <strong>library</strong> with the specific purpose of handling the <strong>view layer,</strong> it is based on <strong>components</strong>, where each one of them has an internal <strong>state</strong> and a <strong>view</strong> definition, and you can't modify the DOM directly because that's the responsibility of the virtual DOM.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Flux pattern</h1>
                </header>
            
            <article>
                
<p>Flux is a pattern for application-state management, and Redux is the most popular Flux-inspired implementation. If you are building a complex React application, you should learn Redux or another Flux-like framework. However, <em>You Might Not Need Redux</em>, as Dan Abramov, the creator of Redux, has blogged about (<a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367">https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367</a>): “<em>People often choose Redux before they need it</em>.”</p>
<p>Redux is a great framework, but it adds complexity to your project. As we are building a small frontend application, we will not use it here, and this decision makes sense for applications that have a short component tree. Again, the objective of this book is to focus on serverless and not on frontend development, so Redux is out of scope for us. In a real-world application, you need to consider the pros and cons. Most of the time, you will choose to use Redux, but not always.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">React hello-world</h1>
                </header>
            
            <article>
                
<p>React promotes the usage of JSX, a syntax that mixes JavaScript with XML. You don't need to use JSX, but you <em>should</em> use it to improve the readability of the code. For example, take a look at the following JSX:</p>
<pre>
    class HelloReact extends React.Component {<br/>      render() {<br/>        return &lt;div&gt;Hello, {this.props.name}!&lt;/div&gt;;<br/>      }<br/>    }<br/><br/>    ReactDOM.render(<br/>      &lt;HelloReact name="World"/&gt;,<br/>      document.getElementById('root')<br/>    );
</pre>
<p>This example defines a <kbd>&lt;HelloReact/&gt;</kbd> HTML element and the rendered output will use the value of the <kbd>name</kbd> property. If the input is <kbd>World</kbd>, the rendered result will be <kbd>&lt;div&gt;Hello, World!&lt;/div&gt;</kbd>.</p>
<p>However, the browser can't execute this code because JSX doesn't have native support. You need to use a JSX transpiler that will translate this example into the following JavaScript code:</p>
<pre>
    class HelloReact extends React.Component {<br/>      render() {<br/>        return React.createElement(<br/>          "div", null,<br/>          "Hello, ", this.props.name, "!"<br/>        );<br/>      }<br/>    }<br/><br/>    ReactDOM.render(<br/>      React.createElement(HelloReact, { name: "World" }),<br/>      document.getElementById('root')<br/>    );
</pre>
<p>Mixing JavaScript code with HTML sounds strange, but we can get used to it. In the end, most people find it more enjoyable and easier to maintain.</p>
<p>To make this piece of code work, we need to add two dependencies such as React and ReactDOM. The former is the core, which lets us create components, and the latter is the library that renders the components and attaches them into an HTML node.</p>
<p>You can find these dependencies at <a href="https://unpkg.com/react/">https://unpkg.com/react/</a> and <a href="https://unpkg.com/react-dom/">https://unpkg.com/react-dom/</a>. You will find the necessary files inside the <kbd>dist</kbd> folder.</p>
<p>The following code is a working hello-world example:</p>
<pre>
    &lt;!DOCTYPE html&gt;<br/>    &lt;html&gt;<br/>      &lt;head&gt;<br/>        &lt;title&gt;Hello, World!&lt;/title&gt;<br/>      &lt;/head&gt;<br/>      &lt;body&gt;<br/>        &lt;div id="root"&gt; &lt;!-- this is where we'll hook React --&gt;<br/>        &lt;/div&gt;<br/><strong>        &lt;script src="react.min.js"&gt;&lt;/script&gt;</strong><br/><strong>        &lt;script src="react-dom.min.js"&gt;&lt;/script&gt;</strong><br/>        &lt;script type="text/javascript"&gt;<br/>          <strong>class HelloReact extends React.Component {</strong><br/><strong>            render() {</strong><br/><strong>              return React.createElement(</strong><br/><strong>                "div", null,</strong><br/><strong>                "Hello, ", this.props.name, "!"</strong><br/><strong>              );</strong><br/><strong>            }</strong><br/><strong>          }</strong><br/><br/>          <strong>ReactDOM.render(</strong><br/><strong>            React.createElement(HelloReact, { name: "World" }),</strong><br/><strong>            document.getElementById('root')</strong><br/><strong>          );</strong><br/>        &lt;/script&gt;<br/>      &lt;/body&gt;<br/>    &lt;/html&gt;
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a shopping cart</h1>
                </header>
            
            <article>
                
<p>To understand React, we need to see how props and states work, and how we can compose an interface with different components. For a practical example, we will build a shopping cart. This example will be the foundation of our <span class="packt_screen">Serverless Store</span> and the objective now is to achieve the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/9c362541-15c1-48bf-8da3-c5b107ee0a9c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the development environment</h1>
                </header>
            
            <article>
                
<p>One of the criticisms of React is the need of external tools for development. In fact, one can use plain JavaScript, but as we saw, JSX is easier to understand. So, the first tool that you need to add to your project is a JSX transpiler.</p>
<p>When you browse a React project or any other modern web project, you will also find that people use many other tools such as Babel (ES6 to ES5 transpiler), Webpack (module bundler), ESLint (code analysis), and others. Also, each tool has many competitors. You may prefer to use Browserify instead of Webpack, for example. Understanding and configuring these tools takes a long time. If you are learning React, you need to understand first how React works and not how the environment is configured.</p>
<p>With this in mind, the tool <strong>Create React App</strong> offers an opinionated configuration that uses well-established tools and practices. You don't need to worry about the environment anymore, you just follow what others have suggested.</p>
<p>Take a look at the following steps to start a new project using this tool:</p>
<ol>
<li>Install the Create React App tool using the following npm command:</li>
</ol>
<pre>
<strong>        npm install create-react-app@1.3.1 --global</strong>
</pre>
<div class="packt_infobox">The <kbd>@1.3.1</kbd> term means that it will download the exact version that was used for this book's examples. If you prefer, you can remove this <kbd>@1.3.1</kbd> restriction to get the latest features, but that may introduce breaking changes to the examples.</div>
<ol start="2">
<li>Now, create a new application using the following command:</li>
</ol>
<pre>
<strong>        create-react-app react-shopping-cart</strong>
</pre>
<ol start="3">
<li>Change the directory to the new folder and start the application using the following command:</li>
</ol>
<pre>
<strong>        cd react-shopping-cart</strong><br/><strong>        npm start</strong>
</pre>
<ol start="4">
<li>You can see the application running at <a href="http://localhost:3000">http://localhost:3000</a>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/3293096b-db79-49c5-88d8-58796decd663.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizing the solution</h1>
                </header>
            
            <article>
                
<p>This application will create the following structure:</p>
<pre>
    node_modules<br/>    public<br/>      |- favicon.ico<br/>      |- index.html<br/>      |- manifest.json<br/>    src<br/>      |- App.css<br/>      |- App.js<br/>      |- App.test.js<br/>      |- index.css<br/>      |- index.js<br/>      |- logo.svg<br/>      |- registerServiceWorker.js<br/>    .gitignore<br/>    package.json<br/>    README.md
</pre>
<div class="packt_infobox">The <kbd>public/manifest.json</kbd> and <kbd>src/registerServiceWorker.js</kbd> files are used to support <strong>Progressive Web App</strong> (<strong>PWA</strong>), which is a great feature to build fast and more reliable web pages as it caches static assets and allows offline access. However, PWA is not so useful for an online store and is out of scope of this book, so it will be removed from the examples.</div>
<p>We will make the following changes here to adapt the example to our project:</p>
<ol>
<li><strong>Remove PWA support</strong>: Delete the <kbd>public/manifest.json</kbd> and <kbd>src/registerServiceWorker.js</kbd> files.</li>
<li><strong>Remove src files that won't be used</strong>: Delete the files <kbd>App.css</kbd>, <kbd>App.js</kbd>, <kbd>App.test.js</kbd>, <kbd>index.css</kbd>, and <kbd>logo.svg</kbd></li>
<li><strong>Create folders</strong>: Under <kbd>src/</kbd>, create the <kbd>css/</kbd>, <kbd>components/</kbd>, and <kbd>images/</kbd> folders.</li>
<li><strong>Add components</strong>: Under <kbd>components/</kbd>, add the files <kbd>App.js</kbd>, <kbd>ShoppingCart.js</kbd>, <kbd>ShoppingCartItem.js</kbd>, <kbd>Product.js</kbd>, and <kbd>ProductList.js</kbd>.</li>
<li><strong>Add CSS</strong>: Under <kbd>css/</kbd>, create a file named <kbd>site.css</kbd> that will serve as our custom styles.</li>
<li><strong>Add images</strong>: Add two images that will be used as our products. I've used free images (Creative Commons CC0) from Pixabay (<a href="https://pixabay.com">https://pixabay.com</a>).</li>
</ol>
<div class="packt_infobox">You can browse the Packt resources for this chapter (<a href="https://github.com/PacktPublishing/Building-Serverless-Web-Applications">https://github.com/PacktPublishing/Building-Serverless-Web-Applications</a>) to see the final result. This project is available under a folder named <kbd>react-shopping-cart</kbd>.</div>
<p>Now you should have the following project tree:</p>
<pre>
    node_modules<br/>    public<br/>      |- favicon.ico<br/>      |- index.html<br/>    src<br/><strong>      |- components</strong><br/><strong>         |- App.js</strong><br/><strong>         |- Product.js</strong><br/><strong>         |- ProductList.js<br/>         |- ShoppingCart.js</strong><br/><strong>         |- ShoppingCartItem.js</strong><br/><strong>      |- css</strong><br/><strong>         |- site.css</strong><br/><strong>      |- images</strong><br/><strong>         |- &lt;images&gt;</strong><br/>      |- index.js<br/>    .gitignore<br/>    package.json<br/>    README.md
</pre>
<p>Before starting to code the components, we need to make a few changes in the <kbd>index.js</kbd> file to match the new project tree. Use the following code:</p>
<pre>
    import React from 'react';<br/>    import ReactDOM from 'react-dom';<br/><strong>    import App from './components/App';<br/></strong><strong>    import './css/site.css';<br/><br/></strong>    ReactDOM.render(<br/>      &lt;App/&gt;,<br/>      document.getElementById('root')<br/>    );
</pre>
<p>For a responsive website, I've included the Twitter Bootstrap 3 (<a href="https://getbootstrap.com">https://getbootstrap.com</a>) styles in the <kbd>public/index.html</kbd> file:</p>
<div>
<pre>
<span>    &lt;!</span><span>doctype html</span><span>&gt;<br/></span><span>    &lt;</span><span>html</span><span> </span><span>lang</span><span>=</span><span>"en"</span><span>&gt;<br/></span><span>      &lt;</span><span>head</span><span>&gt;<br/></span><span>        &lt;</span><span>meta</span><span> </span><span>charset</span><span>=</span><span>"utf-8"</span><span>&gt;<br/>        &lt;title&gt;Serverless Store&lt;/title&gt;<br/></span><span>        &lt;</span><span>link</span><span> </span><span>rel</span><span>=</span><span>"shortcut icon"</span><span> </span><span>href</span><span>=</span><span>"%PUBLIC_URL%/favicon.ico"</span><span>&gt;<br/></span><strong>        &lt;link rel="stylesheet" href="bootstrap.min.css"</strong><span><strong>&gt;    </strong> </span><span><br/></span><span>      &lt;/</span><span>head</span><span>&gt;<br/></span><span>      &lt;</span><span>body</span><span>&gt;<br/></span><span>        &lt;</span><span>div</span><span> </span><span>id</span><span>=</span><span>"root"</span><span>&gt;&lt;/</span><span>div</span><span>&gt;<br/></span><span>      &lt;/</span><span>body</span><span>&gt;<br/></span><span>    &lt;/</span><span>html</span><span>&gt;</span>
</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composing components</h1>
                </header>
            
            <article>
                
<p>The user interface is a composition of components. To make this clearer, the following diagram shows how we will compose our components to create the application design:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="229" src="assets/c8f88913-3138-4d40-8cd6-6a56a565faa7.png" width="401"/></div>
<p>The <strong>App</strong> component holds the entire view and is responsible for positioning the <strong>Product List</strong> and <strong>Shopping Cart</strong> components. The <strong>Product List</strong> component has a list of <strong>Product</strong> components, and the Shopping Cart will list the selected products as <strong>Cart Item</strong>.</p>
<p>In React, there is no interaction between components, except by passing properties from parent to child components. These properties are called props. The child can't pass data to the parent unless the parent gives a handler function as a property and the child executes this handler when an event occurs. For example, the parent can give a <kbd>handleClick</kbd> function that will be triggered by the child when a button is clicked.</p>
<p>Due to the restriction that you can have only parent-child interactions, the Product List and Shopping Cart components need a common parent. When a product is selected, it will trigger a function in Product List, which in turn will trigger another in the App component. This handler will change the App component's state, and by consequence, the state of the Shopping Cart component will also be changed because the App component will be defined to pass data to the cart through <kbd>props</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a component</h1>
                </header>
            
            <article>
                
<p>In the following code extract, the skeleton of a component is presented. This format will be used to implement all components. To focus on the content, further examples will show only the <kbd>constructor()</kbd> and <kbd>render()</kbd> implementations. Full code examples can be downloaded from the Packt resources associated with this book:</p>
<pre>
    // import React and other dependencies<br/>    import React, { Component } from 'react';<br/>    import AnotherComponent from './AnotherComponent';<br/><br/>    // define the Component as a class<br/><strong>    class MyComponent extends Component {</strong><br/>      // optional method<br/>      <strong>constructor() {</strong><br/><strong>        super();</strong><br/><strong>        this.state = {</strong><br/><strong>          // state<br/></strong><strong>        };</strong><br/><strong>      }</strong><br/><br/>      // this method must be implemented<br/>      <strong>render() {</strong><br/><strong>        return (</strong><br/><strong>          // HTML definition</strong><br/><strong>        );</strong><br/><strong>      }</strong><br/>    }<br/><br/>    // export the component, so it can be used by others    <br/><strong>    export default MyComponent;</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The App component</h1>
                </header>
            
            <article>
                
<p>The App is a component with the responsibility of organizing the page's layout. It uses Bootstrap's grid system to position the two other main components such as Product List and Shopping Cart. It should be rendered with the following:</p>
<pre>
    render() {<br/>      return (<br/>        &lt;div className="container"&gt;<br/>          &lt;div className="row"&gt;<br/>            &lt;div className="col-md-12"&gt;<br/>              &lt;h1&gt;Serverless Store&lt;/h1&gt;<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>          &lt;div className="row"&gt;<br/>            &lt;div className="col-md-8"&gt;<br/>              &lt;h3&gt;Products&lt;/h3&gt;<br/>              <strong>&lt;ProductList<br/></strong><strong>                products={this.state.products}<br/></strong><strong>                onSelect={this.handleSelect}/&gt;<br/></strong>            &lt;/div&gt;<br/>            &lt;div className="col-md-4"&gt;<br/>              &lt;h3&gt;Shopping Cart&lt;/h3&gt;<br/>              <strong>&lt;ShoppingCart <br/>                selectedProducts=</strong><strong>{<br/>                  this.state<br/>                      .products<br/></strong><strong>                      .filter(p =&gt; p.isSelected)<br/>                } <br/>                onDeselect={this.handleDeselect}/&gt;<br/></strong>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }
</pre>
<div class="packt_infobox">When using JSX, you add a class to an HTML element with the <kbd>className</kbd> property, for example:<br/>
<kbd>&lt;div className="container"&gt;&lt;/div&gt;</kbd></div>
<p>In this code, we can see the Product List component being set with two properties such as <kbd>products</kbd> and <kbd>onSelect</kbd>:</p>
<pre>
<strong>    &lt;ProductList<br/></strong><strong>      products={this.state.products}<br/></strong><strong>      onSelect={this.handleSelect}/&gt;</strong>
</pre>
<p>The <kbd>products</kbd> property will receive a list of products that is controlled by the state of the App component. The <kbd>onSelect</kbd> property will receive a handler function, which will be used by the children to trigger the parent component when a product is selected.</p>
<p>We can also see that the Shopping Cart component has two properties such as <kbd>selectedProducts</kbd> and <kbd>onDeselect</kbd>:</p>
<pre>
<strong>    &lt;ShoppingCart <br/></strong><strong>      selectedProducts=</strong><strong>{<br/>        this.state<br/>            .products<br/></strong><strong>            .filter(p =&gt; p.isSelected)<br/>      } <br/></strong><strong>      </strong><strong>onDeselect={this.handleDeselect}/&gt;</strong>
</pre>
<p>The <kbd>selectedProducts</kbd> property will receive a list of products that were selected, while the <kbd>onDeselect</kbd> property defines a handler function that should be triggered by the Shopping Cart component when a product is deselected.</p>
<p>So, in this component, the App component is sharing its state with the Product List and the Shopping Cart components, thus App is responsible for defining the products objects and for keeping track of the selected products. The initial list of products is defined in the following piece of code:</p>
<pre>
    import lonelyBird from '../images/lonely-bird.jpg';<br/>    import solidFriendship from '../images/solid-friendship.jpg';<br/><br/>    const products = [{<br/>        id: 1,<br/>        name: 'Lonely Bird',<br/>        image: lonelyBird,<br/>        price: 29.99,<br/>        isSelected: false<br/>    }, {<br/>        id: 2,<br/>        name: 'Solid Friendship',<br/>        image: solidFriendship,<br/>        price: 19.99,<br/>        isSelected: false<br/>    }];
</pre>
<div class="packt_infobox">The preceding code snippet is a simplified example. In the next chapter, we will retrieve this list from a Lambda function.</div>
<p>The initial state is defined inside the class constructor. Also, you need to bind the component's <kbd>this</kbd> instance to the callback functions. Otherwise, <kbd>this.state</kbd> will not be found when the function gets called inside another component:</p>
<pre>
    constructor() {<br/>       super();<br/>       <strong>this.state = {<br/></strong><strong>         products: products<br/></strong><strong>       };<br/><br/></strong>       // bind the component's "this" to the callback<br/>       <strong>this.handleSelect = this.handleSelect.bind(this);<br/></strong>       <strong>this.handleDeselect = this.handleDeselect.bind(this);</strong><strong><br/></strong>     }
</pre>
<p>The <kbd>handleSelect</kbd> function should be defined inside the class and it will receive a product as an argument to set its <kbd>isSelected</kbd> state:</p>
<pre>
    handleSelect(product) {<br/>      // create a copy of the products array<br/>      <strong>const products = this.state.products.slice();<br/><br/></strong>      // find the index of the product to modify<br/><strong>      const index = products.map(i =&gt; i.id)</strong><strong>.indexOf(product.id);</strong><br/><br/>      // modify the selection state<br/><strong>      products[index].isSelected = product.isSelected;<br/><br/></strong>      // make React aware that the state has changed<br/>      <strong>this.setState({products: products});<br/>    }<br/></strong>
</pre>
<p>There are a couple of things to observe in this example: <kbd>slice()</kbd> was used to create another array, instead of mutating the current array, and <kbd>setState()</kbd> was used instead of directly changing the reference to <kbd>products</kbd>. This is because working with immutable objects has performance benefits. It's easier to identify a modified object by checking whether its reference has changed than by looking into all of its property values. Regarding <kbd>setState()</kbd>, it is used to make React aware of the need to rerender the component.</p>
<p>To finish, as the <kbd>handleSelect</kbd> function is taking the <kbd>isSelected</kbd> property and setting the state, regardless of whether the property is true or false, we can use the <kbd>handleSelect</kbd> function to define the <kbd>handleDeselect</kbd> function:</p>
<div>
<div>
<pre>
<span>    handleDeselect</span><span>(</span><span>product</span><span>) {<br/></span><span>      this.handleSelect</span><span>(</span><span>product</span><span>);<br/></span><span>    }</span>
</pre></div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Product List component</h1>
                </header>
            
            <article>
                
<p>This component accesses the data provided by its parent through the <kbd>props</kbd> variable. It will use the <kbd>products</kbd> array to iterate and create a new Product component for each item of the array. Also, it will set the <kbd>onSelect</kbd> handler with the function passed by its parent:</p>
<pre>
    render() {<br/><strong>      const onSelect = this.props.onSelect;</strong><br/>      const productList = <br/><strong>        this.props.products.map(product =&gt; {<br/></strong>          return (<br/>            &lt;div key={product.id} <br/>                 className="product-box"&gt;<br/>              <strong>&lt;Product<br/></strong><strong>                product={product}<br/></strong><strong>                onSelect={onSelect}/&gt;<br/></strong>            &lt;/div&gt;<br/>          )<br/>        });<br/><br/>      return (<br/>        &lt;div&gt;<br/>          {productList}<br/>        &lt;/div&gt;<br/>      );<br/>    }
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Product component</h1>
                </header>
            
            <article>
                
<p>This component is responsible for rendering the details of the product, such as the image, description, price, and a button that allows the user to add the product to the cart. As you can see, the <kbd>onClick</kbd> event of the button will change the <kbd>isSelected</kbd> state and trigger the <kbd>onSelect</kbd> function:</p>
<pre>
    render() {<br/>      return (<br/>        &lt;div&gt;<br/>          &lt;img src={this.props.product.image}/&gt;<br/>          &lt;div&gt;<br/>            &lt;h3&gt;{this.props.product.name}&lt;/h3&gt;<br/>            &lt;div&gt;US$ {this.props.product.price}&lt;/div&gt;<br/>            &lt;div&gt;<br/>              <strong>&lt;button onClick={() =&gt; {<br/></strong><strong>                const product = this.props.product;<br/></strong><strong>                product.isSelected = !product.isSelected;<br/></strong><strong>                this.props.onSelect(product); <br/></strong><strong>              }}&gt;<br/></strong>                {this.props<br/>                     .product<br/>                     .isSelected ? 'Remove' : 'Add to cart'}<br/>              &lt;/button&gt;<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Shopping Cart component</h1>
                </header>
            
            <article>
                
<p>The Shopping Cart component is responsible for rendering the selected products and showing the total value. Let's take a look at the following code snippet to see how this is done:</p>
<pre>
    render() {<br/>      const<span> </span><span>onDeselect</span><span> </span><span>=</span><span> </span><span>this</span><span>.</span><span>props</span><span>.</span><span>onDeselect</span><span>;<br/></span>      <span>const</span><span> </span><span>products</span><span> </span><span>=</span><span> <br/></span><strong>        this.props.selectedProducts.map(product =&gt; {<br/>          return (<br/>            &lt;ShoppingCartItem key={product.id}<br/>                              product={product}<br/>                              onDeselect={onDeselect}/&gt;<br/>          )</strong><br/><strong>        });</strong><br/>      <br/><span>      const</span><span> </span><span>empty</span><span> </span><span>=</span><span> <br/></span><span>        &lt;</span><span>div</span><span> </span><span>className</span><span>=</span><span>"alert alert-warning"</span><span>&gt;<br/></span><span>          Cart is empty<br/></span><span>        &lt;/</span><span>div</span><span>&gt;</span><span>;<br/></span> <br/><span>      return</span><span> (<br/></span>        <span>&lt;</span><span>div</span><span> </span><span>className</span><span>=</span><span>"panel panel-default"</span><span>&gt;<br/></span>          <span>&lt;</span><span>div</span><span> </span><span>className</span><span>=</span><span>"panel-body"</span><span>&gt;<br/></span><strong>            {products.length &gt; 0 ? products : empty}<br/>            &lt;div&gt;Total: US$ {this.getTotal()}&lt;/div&gt;<br/></strong>          <span>&lt;/</span><span>div</span><span>&gt;<br/></span>        <span>&lt;/</span><span>div</span><span>&gt;<br/></span>      );<br/>    }
</pre>
<p>The <kbd>getTotal</kbd> function uses a <kbd>map</kbd>/<kbd>reduce</kbd> operation to get the aggregated total value. The <kbd>map</kbd> operation will transform the input, creating an array of numbers, and <kbd>reduce</kbd> will sum all values:</p>
<pre>
    getTotal() {<br/>      return this.props<br/>                 .selectedProducts<br/>                 .map(p =&gt; p.price)<br/>                 .reduce((a, b) =&gt; a + b, 0);<br/>    }
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Cart Item component</h1>
                </header>
            
            <article>
                
<p>The last component is the Cart Item. For each selected product, a cart item will be added to the Shopping Cart component. This component is rendered with the product name and value, along with a Glyphicon for an X mark icon. Glyphicon is a set of icons that are available through Bootstrap.</p>
<p>Also, when the user clicks on the icon, we need to trigger the <kbd>onDeselect</kbd> function. Take a look at the following code snippet to see how it is done:</p>
<pre>
    render() {<br/>      const product = this.props.product;<br/>      return (<br/>        &lt;div&gt;<br/>          &lt;span&gt;<br/>            {product.name}: US$ {product.price}<br/>          &lt;/span&gt;<br/>          &lt;a <br/>            <strong>onClick={() =&gt; {</strong><br/><strong>              product.isSelected = false;</strong><br/><strong>              this.props.onDeselect(product); </strong><br/><strong>            }}&gt;</strong><br/>            &lt;span className="glyphicon glyphicon-remove"&gt;<br/>            &lt;/span&gt;<br/>          &lt;/a&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publishing our demo</h1>
                </header>
            
            <article>
                
<p>Publishing the static files requires a processing phase due to the fact that we have used JSX to build the React demo. <span>In this case, the Create React App module will help us again.</span></p>
<p>Take a look at the following steps to learn about publishing our demo:</p>
<ol>
<li>Before publishing, we need to test it locally to confirm that everything is working as expected, which can be done using the following command:</li>
</ol>
<pre>
<strong>        npm start</strong>
</pre>
<ol start="2">
<li>Now we can prepare our frontend project to be published using the following command:</li>
</ol>
<pre>
<strong>        npm run build</strong>
</pre>
<ol start="3">
<li>The resulting files will be processed, minimized, and bundled. You can find all files inside the <kbd>build</kbd> folder. Now upload them to Amazon S3 using the following command:</li>
</ol>
<pre>
<strong>        aws s3 sync ./build s3://my-bucket-name --acl public-read</strong>
</pre>
<ol start="4">
<li>Now, reupload the <kbd>index.html</kbd> file, adding the <kbd>Cache-Control: no-cache</kbd> header just to this file using the following command:</li>
</ol>
<pre>
<strong>        aws s3 cp ./build/index.html s3://my-bucket-name \<br/></strong><strong>          --cache-control no-cache --acl public-read</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making Ajax requests</h1>
                </header>
            
            <article>
                
<p>React is responsible for just the view layer. React is <em>not</em> concerned with how data is fetched from the server. So, there are no restrictions and you can retrieve the server data using many different approaches. Redux offers a pattern using <em>Async Actions</em> and Relay, which is another JavaScript framework, uses <em>GraphQL</em> to handle data.</p>
<p>In our sample application, we will use the simplest approach: the <em>Root component</em>. This pattern is simple and can be very useful for small projects where you have a shallow component tree. What we will do is to concentrate all Ajax requests in a single component and the best option for this is to use the Root component because it's the only component that can communicate with all the others.</p>
<p>When the Root component retrieves some data from the server, the children components will be updated <span>through</span> <em>properties,</em> <span>and React, as expected, will render again only the ones that were changed. And whenever a component needs to perform an action, it will execute a function that was passed as a property by the</span> parent <span>component. This information will go up until it reaches the root level, where it can be sent to the server.</span></p>
<div class="packt_infobox">In our examples, we will consider the App component as the Root component. The <kbd>index.js</kbd> file is technically the root since it is the first to load, but <kbd>index</kbd> is only responsible for appending the React application to the HTML page. As the App component is loaded by <kbd>index</kbd> and App is a common parent for all other components, it will be defined as our root.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving data from the server</h1>
                </header>
            
            <article>
                
<p>In the following example, we will build a page that will request a list of products on load. This request will be done in the Root component, but we need to define where exactly it will be executed. The <kbd>render</kbd> function is <em>never</em> a good choice because <kbd>render</kbd> is always considered as a <em>pure function</em>: for a given input, the output will always be the same, which means that side effects are not allowed.</p>
<p>Excluding <kbd>render</kbd>, we have two candidates: <kbd>componentWillMount</kbd> and <kbd>componentDidMount</kbd>, both of them execute <em>just once</em> and before (<kbd>componentWillMount</kbd>) or after (<kbd>componentDidMount</kbd>) the first <kbd>render</kbd> execution. Since the asynchronous call will take some time to execute, and the component rendering will take place before the result is received, it doesn't help to use the <kbd>componentWillMount</kbd> option. The first rendering will always be done with empty data. So, it makes more sense to use the <kbd>componentWillMount</kbd> function to set the initial state as empty (and avoid undefined values in your properties) and the <kbd>componentDidMount</kbd> function to fetch data from the server.</p>
<p>Another question is whether the initial state should be set in the <kbd>constructor</kbd> function or the <kbd>componentWillMount</kbd> function. They are technically equivalent, but it is much more common to use the <kbd>constructor</kbd> function for this task. In practice, <span><kbd>componentWillMount</kbd> is hardly used at all.</span></p>
<p>The last thing to decide is: which Ajax library will be used? I like to use <strong>axios</strong> for this task, but if you prefer, you can use another library for this such as <strong>Fetch</strong> or <strong>SuperAgent</strong>. Some people like to use <strong>jQuery</strong> for Ajax calls, but adding a full-featured library for just one task doesn't make much sense.</p>
<p>To install axios, run the following command:</p>
<pre>
<strong>    npm install axios --save</strong>
</pre>
<p>To include axios in a component, add the following import:</p>
<pre>
<strong>    import axios from 'axios';</strong>
</pre>
<p>The first part of the example shows how the initial state is defined inside the constructor. It sets an empty array of products and a Boolean variable, <kbd>ready</kbd>, with the value <kbd>false</kbd>. This Boolean will be set to <kbd>true</kbd> once the request completes. Using this approach, we can control the rendering state and display a loading icon while the page is still fetching data:</p>
<pre>
    constructor() {<br/>      super();<br/><br/>      // empty initial state<br/>      <strong>this.state = {</strong><br/><strong>        products: [],</strong><br/><strong>        ready: false</strong><br/><strong>      };</strong>  <br/>    }    
</pre>
<p class="mce-root">Checking the <kbd>ready: false</kbd> state, we can display a <kbd>glyphicon-refresh</kbd> icon instead of the list of products:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="178" src="assets/c52b0347-de96-4eec-b2e8-a800b0dce48b.png" width="384"/></div>
<p>Take a look at the <kbd>componentDidMount</kbd> implementation in the following code snippet. The API address is used to trigger a Lambda function:</p>
<pre>
    componentDidMount() {<br/>      const apiAddress =<br/>        'https://abc123.execute-api.us-east-1.amazonaws.com';<br/>      const stage = 'prod';<br/>      const service = 'store/products';<br/>    <br/>      <strong>axios</strong><br/><strong>        .get(`${apiAddress}/${stage}/${service}`)</strong><br/><strong>        .then(res =&gt; {</strong><br/><strong>          this.setState({ </strong><br/><strong>            products: res.data.products, </strong><br/><strong>            ready: true </strong><br/><strong>          });</strong><br/><strong>        })</strong><br/><strong>        .catch(error =&gt; {</strong><br/><strong>          console.log(error);</strong><br/><strong>        });</strong><br/>    }
</pre>
<p>After getting the results, we set the <kbd>ready</kbd> state with the <kbd>true</kbd> value and the list of products with what we have received:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="450" src="assets/f5d14552-fbe7-4592-8f3d-b8ce430dd89e.png" width="477"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending data to the server</h1>
                </header>
            
            <article>
                
<p>In the previous example, we have placed the Ajax request inside the <kbd>componentDidMount</kbd> function because we wanted the data on page load. However, in the following example, the Ajax request will be executed when a button is clicked, so we don't have the same restriction. Take a look at the following steps, which describe the process step-by-step:</p>
<ol>
<li>The request will be defined as a function of the component:</li>
</ol>
<pre>
        handleSave(products) {       <br/>          <strong>axios</strong><br/><strong>            .post(`${apiAddress}/${stage}/${service}`, </strong><br/><strong>                  products) // data to send</strong><br/><strong>            .then(res =&gt; {</strong><br/><strong>              this.setState({ </strong><br/><strong>                products: this.state.products, </strong><br/><strong>                hasSaved: true </strong><br/><strong>              });</strong><br/><strong>           })</strong><br/><strong>           .catch(error =&gt; {</strong><br/><strong>             console.log(error);</strong><br/><strong>           });</strong><br/>       }
</pre>
<ol start="2">
<li>The <kbd>handleSave</kbd> function is passed through properties to the children components:</li>
</ol>
<pre>
        &lt;ShoppingCart <br/>          products={this.state.products} <br/>          hasSaved={this.state.hasSaved}<br/><strong>          onSave={this.handleSave}</strong>/&gt;
</pre>
<ol start="3">
<li>And, to finish, the children will trigger the <kbd>save</kbd> function when a button is clicked. After the request finishes, the parent component will change the state of the <kbd>hasSaved</kbd> property to <kbd>true</kbd>, and we can use this value in the children components to display a message:</li>
</ol>
<pre>
        return (<br/>          &lt;div&gt;<br/>            {products}<br/>            &lt;div&gt;Total: US$ {this.getTotal()}&lt;/div&gt;<br/>            &lt;button<br/>              <strong>onClick={() =&gt; {this.props.onSave();}}</strong>&gt;<br/>              Save<br/>            &lt;/button&gt;<br/><strong>            {this.props.hasSaved ? </strong><strong>&lt;div&gt;saved&lt;/div&gt; : ''</strong><strong>}</strong><br/>          &lt;/div&gt;<br/>        );
</pre>
<ol start="4">
<li>After saving, the word <span class="packt_screen">saved</span> will appear under the button:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="363" src="assets/5a40098f-4964-472e-8e3b-ae465f27630d.png" width="436"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling the page routes</h1>
                </header>
            
            <article>
                
<p>Later in this chapter, we will discuss the pros and cons of SPA, but first we will take a look at how to build one. An SPA is an application that loads just one HTML file, but it will dynamically update that page while the user interacts with it. Also, the content will render differently to match the URL. For example, browsing the <kbd>example.com</kbd> address will render the <kbd>Home</kbd> component, while browsing <kbd>example.com/about</kbd> will render the <kbd>About</kbd> component.</p>
<p>To implement this, we will use the React Router module. Let's take a look at the following steps to build an SPA:</p>
<ol>
<li>Create a new application using the Create React App tool, or modify the previous Shopping Cart application.</li>
<li>Install the React Router module by running the following:</li>
</ol>
<pre>
<strong>        npm install react-router-dom@4.x --save</strong>
</pre>
<div class="packt_infobox">The <kbd>@4.x</kbd> term means that it will download a version that is compatible with the one used for this book's examples.</div>
<ol start="3">
<li>The <kbd>App.js</kbd> file will be modified to define the application routes. First, we need to import the React Router module components:</li>
</ol>
<pre>
        import React, { Component } from 'react';<br/><strong>        import { </strong><br/><strong>          BrowserRouter as Router, Route, Switch </strong><br/><strong>        } from 'react-router-dom';</strong>
</pre>
<ol start="4">
<li>Next, we need to import our App components. In this example, we will use the following components:<br/>
<ul>
<li><kbd>Header</kbd>: This is the component that will render the text <kbd>"Serverless Store"</kbd> for all pages</li>
<li><kbd>Footer</kbd>: This is the component that will render a footer text for all pages</li>
<li><kbd>ProductList</kbd>: This is a list of products, where each product links to the <kbd>Product</kbd> component</li>
<li><kbd>Product</kbd>: This component gives details of a specific product</li>
<li><kbd>ShoppingCart</kbd>: This is a list of products that were selected by the user</li>
<li><kbd>NoMatch</kbd>: This is a component that will render the text "Page not found"</li>
</ul>
</li>
<li>The <kbd>App</kbd> component will render the page using the following components:<br/>
<ul>
<li><kbd>Router</kbd>: This is the Root component for the page routing.</li>
<li><kbd>Switch</kbd>: This renders the first child route that matches the URL path. If there is no match, it will render the <kbd>NoMatch</kbd> component.</li>
<li><kbd>Route</kbd>: This renders the component for the specified path.</li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">Let's take a look at the preceding mentioned components in the following code snippet:</p>
<pre>
        render() {<br/>          return (<br/><strong>            &lt;Router&gt;</strong><br/>              &lt;div&gt;<br/>                &lt;Header/&gt;<br/><strong>                &lt;Switch&gt;</strong><br/>                  <strong>&lt;Route path="/" exact </strong><strong>component={ProductList}/&gt;</strong><br/><strong>                  &lt;Route path="/product/:id" </strong><strong>component={Product}/&gt;</strong><br/><strong>                  &lt;Route path="/shopping-cart" </strong><strong>component={ShoppingCart}/&gt;</strong><br/><strong>                  &lt;Route component={NoMatch}/&gt;</strong><br/><strong>                &lt;/Switch&gt;</strong><br/>                &lt;Footer/&gt;<br/>              &lt;/div&gt;<br/><strong>            &lt;/Router&gt;</strong><br/>          );<br/>        }
</pre>
<ol start="6">
<li>Run the application and test the URLs. If it doesn't match any path, the <kbd>NoMatch</kbd> component will be rendered and it will display the <span class="packt_screen">Page not found</span> <span>message</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="237" src="assets/9a7fb41b-bbb7-41ab-b1cc-42a00d2ccdd3.png" width="376"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linking pages</h1>
                </header>
            
            <article>
                
<p>Linking one page to another is done using the React Router's Link component:</p>
<pre>
    import { Link } from 'react-router-dom';
</pre>
<p>Link is just a wrapper for the HTML anchor element. In the following example, the implementation of the Product List component shows how to link to a page of a specific Product:</p>
<pre>
    render() {<br/>      return (<br/>        &lt;div&gt;<br/>          &lt;ul&gt;<br/>            &lt;li&gt;<br/>              <strong>&lt;Link to='/product/1'&gt;</strong><br/><strong>                Product 1</strong><br/><strong>              &lt;/Link&gt;</strong><br/>            &lt;/li&gt;<br/>            &lt;li&gt;<br/>              <strong>&lt;Link to='/product/2'&gt;</strong><br/><strong>                Product 2</strong><br/><strong>              &lt;/Link&gt;</strong><br/>            &lt;/li&gt;<br/>          &lt;/ul&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }
</pre>
<p>This component will be rendered as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="222" src="assets/62617504-e3f1-4fdc-b98d-86bb7abb8c34.png" width="363"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the query parameters</h1>
                </header>
            
            <article>
                
<p>When we have declared the routes of our application, we have defined the route of the Product component as follows:</p>
<pre>
<strong>    &lt;Route path="/product/:id" </strong><strong>component={Product}/&gt;</strong>
</pre>
<p>The colon sign defines the parameter that can be used by the related component. In this case, <kbd>:id</kbd> defines a parameter with the name <kbd>id</kbd>, which can be used as follows:</p>
<pre>
    render() {<br/>      return (<br/>        &lt;div&gt;<br/>          &lt;h4&gt;<br/><strong>            Product Details for ID: {this.props.match.params.id}</strong><br/>          &lt;/h4&gt;<br/>        &lt;/div&gt;<br/>      );<br/>    }
</pre>
<p>This Product component will render as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="270" src="assets/157cb9b8-e127-457e-94ec-5cfd0e43d806.png" width="333"/></div>
<p>Note that the <kbd>localhost:3000/product/1</kbd> path defined an <kbd>id</kbd> parameter with value <kbd>1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single-Page Applications</h1>
                </header>
            
            <article>
                
<p>In a traditional multipage website, each URL loads a different HTML page. If you are at the <kbd>example.com</kbd> page and need to navigate to <kbd>example.com/about</kbd>, the entire view will blink with a page reload because it will need to be rendered again. The problem is that, usually, a page reload is a waste of time since both pages share similar content, such as the page header and footer. Also, CSS and JavaScript dependencies may be exactly the same.</p>
<p>In a Single-Page Application, there is a base HTML file that will be loaded for every URL and, depending on the given URL, the inner content will be dynamically loaded to match the address. Also, the URL browsing is controlled at the client-side using JavaScript. Changing from one URL to another will not cause a full page reload. Instead of loading an entire new file, a request is made to the server to retrieve only what is necessary for the new address and just a part of the page will be rendered again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pros and cons of Single-Page Applications</h1>
                </header>
            
            <article>
                
<p>SPA is a modern approach that has the objective to provide a better user experience, but it's not perfect. There are pros and cons that you need to know before using it. While this topic can be extensive, we will highlight only the most relevant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pros</h1>
                </header>
            
            <article>
                
<p>Let's list the main benefits of this approach:</p>
<ul>
<li><strong>No page refresh</strong>: This is an obvious benefit. When the user changes to another view, the page will not blink. The browsing experience becomes more pleasant with a fluid navigation.</li>
<li><strong>Decoupling</strong>: You have a better separation of frontend and backend code.</li>
<li><strong>Reduce the server-side code</strong>: We are building a serverless website, so we must consider that cold start delays at the backend may impact the user experience. In SPA, there is much more logic at the client side to make the dynamism feasible, and we can use this approach to reduce the size of the server-side code and improve the performance by reducing the number of requests to the backend.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cons</h1>
                </header>
            
            <article>
                
<p>SPA has a few drawbacks, we can consider the following cons:</p>
<ul>
<li><strong>Larger file sizes</strong>: As we have more logic at the client side, the applications usually have larger JavaScript dependencies. This is a big problem, especially with mobile clients with poor network conditions. The first load of the site will take more time.</li>
<li><strong>Requires JavaScript</strong>: There is yet a small percentage of users that disable JavaScript due to security reasons. If you have a simple site that doesn't need any fancy features, your SPA is forcing JavaScript support that would otherwise be optional.</li>
<li><strong>Search Engine Optimization</strong>: An SPA application relies heavily on JavaScript. Google crawlers can execute some JavaScript code in special conditions, but Bing and others won't execute. If we want the search engines to correctly index our website, we need to prerender the content especially for them.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Considerations</h1>
                </header>
            
            <article>
                
<p>Some may argue that a low-end mobile device may have a poor performance with SPA because of the increased amount of JavaScript code. While that might have been true in the past, it may not be the reality at present and won't be in the future. Nowadays, even low-end devices have a powerful CPU that can perfectly execute most operations seamlessly. The real issue with mobile devices is not the computational power, but the network performance to download a larger size of code.</p>
<p>In this book, we will stick with SPA, and the main reason is that it fits well with the serverless approach. SPA is a modern approach to offload to clients some of the computing costs needed to run a website.</p>
<p>Lambda is cheap, but not free. On the other hand, client-side executions are limitless. Using the premise that more logic at the client won't significantly hurt the performance, I prefer avoiding making Lambda requests to handle the application state. Lambda should be used only to retrieve or save data and not to control UI logic.</p>
<p>However, as with most things in our field, each case should be treated separately. You may benefit from a multipage application and there is nothing wrong with it. With multipage, you just need to configure the Lambda function to return HTML content instead of JSON data, as we saw in an example in <a href="436e582c-0a4c-4257-b8eb-aa2c1dbd98c4.xhtml">Chapter 3</a>, <em>Using the Serverless Framework</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prerendering pages</h1>
                </header>
            
            <article>
                
<p>In our frontend approach, the layout is entirely composed by JavaScript code using React components. Prerendering a web page means executing this JavaScript code and saving the output HTML file.</p>
<p>As discussed in the previous section, to improve <strong>Search Engine Optimization</strong> (<strong>SEO</strong>), we need to prerender pages because the majority of crawlers can't execute JavaScript code, and the ones that can, such as Google, won't execute all kinds of code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using PhantomJS</h1>
                </header>
            
            <article>
                
<p>PhantomJS is a headless web browser, based on WebKit, which can be used to make HTTP requests and save the HTML output. It is not a Node.js module, but it can use Node.js modules. It runs in its own process, which is not the same as a Node runtime. You can download it from the official site: <a href="http://phantomjs.org">http://phantomjs.org</a>.</p>
<p>As we discussed in the previous chapter, you can configure the S3 bucket to return the <kbd>index.html</kbd> page whenever an error of HTTP 404 <em>Not Found</em> occurs. So, when the user browses the address <kbd>example.com/page1</kbd>, S3 will look for a <kbd>page1.html</kbd> file. It will not find it, but it will load the <kbd>index.html</kbd> file instead. As we have developed an SPA, it will be able to render the contents of the corresponding <kbd>page1</kbd> file, keeping the browser address as <kbd>example.com/page1</kbd>.</p>
<p class="CDPAlignLeft CDPAlign">When we prerender the <kbd>page1</kbd> file, the output HTML must be uploaded to the S3 bucket. This means that the next time we try to fetch the address <kbd>example.com/page1</kbd>, S3 will find a <kbd>page1.html</kbd> file and load it directly. Loading a prerendered page for a real user is not a problem, it's even better from a performance perspective. This user will load the HTML with the React dependencies. After a few instants, the React application will take control and further requests will be handled as a normal SPA.</p>
<p class="CDPAlignLeft CDPAlign">The script to prerender a page is quite simple. You can follow this example:</p>
<pre>
    const fs = require('fs');<br/>    const webPage = require('webpage');<br/>    const page = webPage.create();<br/><br/>    const path = 'page1';<br/>    const url = 'https://example.com/' + path;<br/><br/>    page.open(url, (status) =&gt; {<br/><br/>      if (status != 'success') {<br/>        console.log('Error trying to prerender ' + url);<br/>        phantom.exit();<br/>      }<br/><br/>      const content = page.content;<br/>      fs.write(path + '.html', content, 'w');<br/><br/>      console.log("The file was saved.");<br/>      phantom.exit();<br/>    });
</pre>
<p class="CDPAlignLeft CDPAlign">To test, add the PhantomJS binary to PATH and execute the following command:</p>
<pre>
<strong>    phantomjs prerender.js</strong>
</pre>
<p class="CDPAlignLeft CDPAlign">One of the problems of this approach is that you need to keep track of all the pages of your application. If a new page is added, you need to remember to include it in this list of pages to process. Also, you need to prerender your application's root file (<kbd>index.html</kbd>) and replace it in the S3 bucket.</p>
<p class="CDPAlignLeft CDPAlign">Serving the output HTML file will make the content visible for all web crawlers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Lambda functions for prerendering</h1>
                </header>
            
            <article>
                
<p>If your application is a static website, you can prerender all pages just once. However, for dynamic applications such as our Serverless Store, we need to have a routine of prerendering pages to avoid serving outdated content to crawlers. For example, the <kbd>https://serverless-store.com/products/lonely-bird</kbd> page shows the details of the <span class="packt_screen">Lonely Bird</span> product. If the product is modified or deleted, we need to apply the changes to the <kbd>/products/lonely-bird.html</kbd> file. You have the following two options for this:</p>
<ul>
<li>Whenever some content is modified, trigger a Lambda function to update the page</li>
<li>Schedule a Lambda function to execute daily to update all pages</li>
</ul>
<p>In both cases, Lambda functions will be used, but how to call the PhantomJS binary if it is not a Node module? For this, we can install the <kbd>phantomjs-lambda-pack</kbd> Node module, which provides binary files compatible with Amazon Linux AMI machines to run on Lambda. It can be used as a Node module because it will spawn a child process to execute PhantomJS.</p>
<p>The <kbd>prerender.js</kbd> file that is loaded in the next example is the code implemented in the previous section. It must be placed in the same folder as the <kbd>serverless.yml</kbd> file.</p>
<p>The following code can be used as our Lambda handler:</p>
<pre>
<span class="pl-k">    const</span> <span class="pl-c1">phantomjsLambdaPack</span> <span class="pl-k">=</span> <br/><span class="pl-c1">      require</span>(<span class="pl-s"><span class="pl-pds">'</span>phantomjs-lambda-pack<span class="pl-pds">'</span></span>);<br/><span class="pl-k">    const</span> <span class="pl-c1">exec</span> <span class="pl-k">=</span> <span class="pl-smi">phantomjsLambdaPack</span>.<span class="pl-smi">exec</span>;<br/><br/><span class="pl-c1">    exports</span>.<span class="pl-en">handler</span> <span class="pl-k">=</span> (<span class="pl-c1">event</span>, <span class="pl-smi">context</span>, <span class="pl-smi">callback</span>) <span class="pl-k">=&gt;</span> {<br/>      <span class="pl-en">exec</span>(<span class="pl-s"><span class="pl-pds">'prerender.js</span><span class="pl-pds">'</span></span>, (<span class="pl-smi">err</span>, <span class="pl-smi">stdout</span>, <span class="pl-smi">stderr</span>) <span class="pl-k">=&gt;</span> {<br/>        console.log(err, 'finished'); <br/>        <span class="pl-en">callback</span>(err, <span class="pl-s"><span class="pl-pds">'finished</span><span class="pl-pds">'</span></span>);<br/>      });<br/>    };
</pre>
<div class="packt_infobox">This PhantomJS wrapper requires the Lambda function to use at least 1,024 MB of RAM and a timeout of 180 seconds. So, instead of requiring one Lambda function for each page, it's better to call the Lambda to handle multiple pages.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering on the fly</h1>
                </header>
            
            <article>
                
<p>Instead of prerendering a web page, you can also render it on the fly. You need to detect that the request was made from a crawler and execute some logic to render the HTML page. Detecting a crawler can be done by checking the user-agent string and comparing it with a known list of common crawlers. This method works, but requires periodic maintenance and will not cover all crawlers, just the most popular.</p>
<p>There is a website, <a href="https://prerender.io">https://prerender.io</a>, which offers a service to prerender sites on the fly when a crawler is detected. You install a middleware in your server and it will be responsible for checking the requests to find crawlers and provide them a cached prerendered version of your page. As we don't have a server, and we are using CloudFront/S3 to host the frontend, we can't execute code on demand.</p>
<p>To solve problems like this one, AWS released a new service named <strong>Lambda@Edge</strong>, which is currently in preview phase. This service will execute Lambda functions in edge locations in response to <em>all</em> <em>page requests</em>. AWS promised a very short latency to execute those Lambda functions, and you can use it to prerender on the fly if an agent is a crawler. You can also use it for other use cases such as modifying response headers or adding content depending on the agent, IP address, or referrer.</p>
<p>Rendering on the fly has the obvious drawback that it will be slower to answer the requests, but as the Lambda function has direct access to the database, the rendered page will always be updated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building an online store</h1>
                </header>
            
            <article>
                
<p>We will use the previous Shopping Cart demo to begin our application. Now, we know how to set page routes and how to make Ajax requests, so we have everything to continue. One important difference is that the Shopping Cart component will be in a different page than the Product List component. Also, we need to create other pages. The following is a list of the pages:</p>
<ul>
<li><strong>Home page</strong>: This presents a list of all available products where the user can add them to the Shopping Cart component</li>
<li><strong>Product details</strong>: This <span>is a dedicated page that provides more details of a specific product where users can see and add new comments</span></li>
<li><strong>Shopping Cart</strong>: This shows all of the selected products and is responsible for handling payments</li>
<li><strong>Signup page</strong>: This handles account creation</li>
<li><strong>Login page</strong>: This allows the user to log in</li>
<li><strong>Page not found</strong>: This is a page that will be displayed when the address doesn't exist</li>
<li><strong>Error page</strong>: This is a page that will be displayed when an error occurs</li>
</ul>
<p>This book will not cover all the code for the online store sample. There are too many parts that are simple to implement or are unrelated to the serverless concept. You can find the entire code in the Packt resources associated with this book or on my GitHub repo: <a href="https://github.com/zanon-io/serverless-store">https://github.com/zanon-io/serverless-store</a>. For a running demo, access: <a href="https://serverless-store.zanon.io">https://serverless-store.zanon.io</a>. Instead of dumping all the code here, we are focusing on the important parts. The following sections will describe what each page implements along with a screenshot of the result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Navbar component</h1>
                </header>
            
            <article>
                
<p>The Navbar component is like the header component that should appear for all pages. For its implementation, let's perform the following steps:</p>
<ol>
<li>First, we need to install two Node modules: <kbd>react-bootstrap</kbd> and <kbd>react-router-bootstrap</kbd>. Install them using the following npm command:</li>
</ol>
<pre>
<strong>        npm install react-boostrap --save<br/></strong><strong>        npm install react-router-bootstrap --save</strong>
</pre>
<ol start="2">
<li>Import the necessary components using the following code:</li>
</ol>
<pre>
        import { <br/><strong>          Navbar, Nav, NavItem </strong><br/>        } from 'react-bootstrap';<br/>        import { <br/><strong>          IndexLinkContainer, LinkContainer </strong><br/>        } from 'react-router-bootstrap';
</pre>
<ol start="3">
<li>Implement the Navbar component to set the links using the following code:</li>
</ol>
<pre>
        &lt;Navbar&gt;<br/>          &lt;Nav&gt;<br/>            <strong>&lt;IndexLinkContainer to="/"&gt;</strong><br/><strong>              &lt;NavItem&gt;Home&lt;/NavItem&gt;</strong><br/><strong>            &lt;/IndexLinkContainer&gt;</strong><br/><strong>            &lt;LinkContainer to="/shopping-cart"&gt;</strong><br/><strong>              &lt;NavItem&gt;Shopping Cart&lt;/NavItem&gt;</strong><br/><strong>            &lt;/LinkContainer&gt;</strong><br/>          &lt;/Nav&gt;<br/>          &lt;Nav pullRight&gt;<br/>            <strong>&lt;LinkContainer to="/signup"&gt;</strong><br/><strong>              &lt;NavItem&gt;Signup&lt;/NavItem&gt;</strong><br/><strong>            &lt;/LinkContainer&gt;</strong><br/><strong>            &lt;LinkContainer to="/login"&gt;</strong><br/><strong>              &lt;NavItem&gt;Login&lt;/NavItem&gt;</strong><br/><strong>            &lt;/LinkContainer&gt;</strong><br/>            &lt;NavItem&gt;<br/>              &lt;span className="glyphicon glyphicon-bell"&gt;<br/>              &lt;/span&gt;<br/>            &lt;/NavItem&gt;<br/>          &lt;/Nav&gt;<br/>        &lt;/Navbar&gt;
</pre>
<p style="padding-left: 60px">We will get the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="43" src="assets/3e16e9d5-7817-4700-a5dd-c00e66c29ecc.png" width="506"/></div>
<p>The last item is a notification icon. We will implement it in <a href="ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml">Chapter 9</a>, <em>Handling Serverless Notifications</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Home page</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">Home</span> page will render the Product List component that we have defined in this chapter. One important observation is how the page router will select this component. Previously, we used the following code:</p>
<pre>
<strong>    &lt;Route path="/" exact component={ProductList}/&gt;</strong> 
</pre>
<p>However, we need to pass some properties from the App component to the Product List component, since the App component is responsible for managing the application state. In this case, we need to use the <kbd>render</kbd> attribute:</p>
<pre>
    &lt;Route path="/" exact <strong>render</strong>={ <br/>      () =&gt; <strong>&lt;ProductList </strong><br/><strong>              products={this.state.products} </strong><br/><strong>              onSelect={this.handleSelect}</strong>/&gt; <br/>    }/&gt;
</pre>
<p>The same applies for all other components that need to share their state with the App component.</p>
<p>Take a look at the result in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/81e7a258-ec13-436e-8c4f-0c207e6ad2f6.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The product details page</h1>
                </header>
            
            <article>
                
<p>The product details page will be accessed by clicking on the image of a product. On this page, the user will be able to see the product and customer reviews:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/61478952-bcc3-45e5-86e2-3aa9f9ff1d98.png"/></div>
<p>The <em>customer reviews</em> feature will be implemented later in this book, in <a href="ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml">Chapter 9</a>, <em>Handling Serverless Notifications</em>.</p>
<p>To display the product details page, we need to add a link in the product image using the <kbd>Link</kbd> tag, as shown in the following code snippet:</p>
<pre>
<strong>    &lt;Link to={`/product/${this.props.product.id}`}&gt;</strong><br/>      &lt;img src={this.props.product.image}/&gt;<br/><strong>    &lt;/Link&gt;</strong>
</pre>
<p>Another change that is required is how the page route will be able to identify which product to render. In this case, we will modify the <kbd>Route</kbd> component to render the <kbd>Product</kbd> component using the URL parameter available at the <kbd>props.match.param</kbd> object:</p>
<pre>
    &lt;Route path="/product/:id" render={<br/>      (props) =&gt; &lt;Product <br/>                   product={<br/>                     this.state<br/>                         .products<br/>                         .find(x =&gt; <br/>                           x.id === props.match.params.id)<br/>                   }<br/>                   onSelect={this.handleSelect}/&gt;<br/>     }/&gt;
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Shopping Cart page</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">Shopping Cart</span> page will be implemented like we did previously in this chapter. The only modification here is the addition of a checkout button, which will be used to process the request:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/098ef750-002f-49f9-82a2-ddaf4f33d2e9.png"/></div>
<p>However, handling payments is a complex feature for a restricted audience, thus it will not be discussed here. If you need a serverless service for this, I recommend that you take a look at Stripe (<a href="https://stripe.com">https://stripe.com</a>).</p>
<p><span>When the user clicks on this button, we will display a modal, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e24d2e4e-15fb-4c03-b97e-d8f2601d7330.png"/></div>
<p>This modal is implemented using the <kbd>react-bootstrap</kbd> component, as shown in the following example:</p>
<pre>
    &lt;Modal show={this.state.showModal} onHide={this.closeModal}&gt;<br/>      &lt;Modal.Header closeButton&gt;<br/>        &lt;Modal.Title&gt;Your order has been sent&lt;/Modal.Title&gt;<br/>      &lt;/Modal.Header&gt;<br/>      &lt;Modal.Body&gt;<br/>        &lt;p&gt;However, this is a demo...&lt;/p&gt;<br/>      &lt;/Modal.Body&gt;<br/>    &lt;/Modal&gt;
</pre>
<p>In the following code snippet, <kbd>closeModal</kbd> is a method to set the <kbd>showModal</kbd> state to <kbd>false</kbd>:</p>
<pre>
    closeModal() {<br/>      this.setState({ showModal: false });<br/>    }
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Login and Signup pages</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">Login</span> and <span class="packt_screen">Signup</span> pages will be implemented as simple forms, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/b14959ee-7c53-452c-a179-c9b9ba7efa5a.png"/></div>
<p>The only difference between them is that the <span class="packt_screen">Signup</span> page has an extra field to request the user to type the password a second time for confirmation.</p>
<p>Both features will be implemented in <a href="5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml">Chapter 8</a>, <em>Securing the Serverless Application</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The error pages</h1>
                </header>
            
            <article>
                
<p>We have to support two types of errors: <kbd>HTTP 404 <em>Not Found</em></kbd> and <kbd>HTTP 500 <em>Internal Server Error</em></kbd>. The <kbd>Not Found</kbd> status code will be rendered when the URL doesn't match any page and <kbd>Internal Server Error</kbd> is a page that we can display when an error occurs in the backend. Both pages will be implemented to show an error message.</p>
<p>Take a look at the error page in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="216" src="assets/262d0091-8ad8-4bce-89f1-d57f816e31c2.png" width="532"/></div>
<p class="CDPAlignLeft CDPAlign">Take a look at the page not found in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="215" src="assets/4028c152-ae5a-49c0-a907-935d440dcc98.png" width="530"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have covered the basics of React to demonstrate how to use modern tools to build a serverless frontend. We discussed SPA and how to prerender pages to improve SEO. We have finished defining how to build the frontend of our Serverless Store.</p>
<p>In the next chapter, we will build the serverless backend of the online store, learning more about serverless architectures and RESTful APIs.</p>


            </article>

            
        </section>
    </body></html>