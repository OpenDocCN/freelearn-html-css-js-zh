- en: Chapter 14. Deploying and Scaling the SPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having built the core functionality of the application, now it's time to move
    the SPA into a production-like environment that is accessible from the Internet.
    For this, we will be using **Platform as a Service** (**PaaS**).
  prefs: []
  type: TYPE_NORMAL
- en: PaaS is a type of a cloud-based service that allows developers to launch applications
    on managed infrastructure. Before PaaS, developers or operations engineers had
    to perform a lot of setup and maintenance tasks, such as provisioning hardware,
    installing operating software, and insuring uptime.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of PaaS providers, but I have chosen Heroku. One reason for
    this is that you can stand up an application for free on a sandbox, which will
    allow you to experiment on the app and scale up when you're ready. Deploying an
    app to Heroku is also quite easy, as, you'll see, Heroku uses Git to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: We will also set up a production database in the cloud. We will use MongoLab,
    which also has a free sandbox tier with enough memory to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll finish this chapter by briefly discussing the following concerns for
    scaling your application:'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging the application with the Grunt task runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a production database online
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the SPA into the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considerations for scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging for deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is still quite small and not complicated, but we will begin
    by setting up an automated process for packaging our application up for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Grunt for deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the Grunt JavaScript task runner to set up some automated tasks
    to package up our files for deployment. There's not a lot for us to do here, but
    you'll get a sense of what can be done and be able to explore the rich selection
    of Grunt plugins to further customize your automated tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Grunt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you haven''t already, install the grunt CLI using NPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For Grunt to run correctly, you''ll need two files in your project root directory.
    The first one is a `package.json` file to declare dependencies. You already have
    one in your root directory. The next file you need is `Gruntfile.js`, where you
    will load grunt modules and configure the tasks that Grunt can run. Go ahead and
    create this file in your root directory and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the framework for `Gruntfile`. We export a function that expects to
    receive a reference to the grunt object as its argument. Inside that function,
    we call the `grunt.initConfig()` function, passing it a configuration object.
    Currently, that configuration object has a single property, that is, a reference
    to the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: The power of Grunt comes from employing any number of the thousands of plugins
    made available by its active community. At the time of writing this book, there
    were over 5,000 Grunt plugins listed at [http://gruntjs.com/plugins](http://gruntjs.com/plugins).
    If there's some automated task you want to run, chances are that somebody's already
    created a plugin to support it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Grunt plugins, which are officially maintained, are always named `grunt-contrib-X`.
    You can generally trust the quality of these plugins, although there are many
    great unofficially maintained plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Grunt plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A nice feature of Grunt is that plugins are installed using NPM. Let''s install
    a few useful plugins that we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We installed Grunt plugins for `clean`, `uglify`, `htmlmin`, and `copy` tasks.
    Clean will clean files out of a directory. Uglify minimizes JavaScript files.
    `Htmlmin` minifies HTML files. The `Copy` task copies files. The `--save-dev`
    flag will add these modules to your `package.json` file as d`evdependecies`. You
    need these packages only in your development environment, not in your production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, let's create a `dist` folder in the root of our project.
    This is where our production-ready assets will be found.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Gruntfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we need to modify our `Gruntfile` to load the plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use a call to `grunt.loadNPMTasks()` for each Grunt plugin we want
    to load, passing it the name of the module to be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to configure each of our tasks inside our `Gruntfile`. Note that
    every plugin will have its own configuration properties. Consult the documentation
    for each plugin you use to see how it is configured. Open up your `Gruntfile.js`
    and make the following edits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first change we made was adding a number of task configuration properties
    inside the `grunt.InitConfig()` function. Each of these properties decorates the
    grunt object when grunt is run and tells the various tasks how to execute.
  prefs: []
  type: TYPE_NORMAL
- en: The first task configuration is for clean. This task is configured to delete
    all the files and folders in the `dist` folder. The clean configuration takes
    an array of paths; the syntax of the path definition is pretty standard for the
    `grunt-contrib` plugins. For more information on Grunt's URL globbing, refer to
    [http://gruntjs.com/configuring-tasks#globbing-patterns](http://gruntjs.com/configuring-tasks#globbing-patterns).
  prefs: []
  type: TYPE_NORMAL
- en: The other task configurations are similar, but take objects, and can include
    some options, a target, and lists of files to operate on. For configuration options
    for grunt plugins, find the plugin you're interested in at [http://gruntjs.com/plugins](http://gruntjs.com/plugins)
    and click on the name of the plugin to get the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The next section after the configuration is where we load each plugin that will
    be used by this `Gruntfile`. We do this by passing the name of the plugin as an
    argument to the `grunt.loadNPMTasks()` function. Grunt will look for these plugins
    in our `node_modules` folder. If we were to use custom tasks, such as the one
    we wrote ourselves, we could load them using calls to `grunt.loadTasks()`, passing
    in a path.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we did was to register a task. We did this by calling `grunt.registerTask()`.
    This took two arguments. The first is a string, the name of the task. In our case,
    this is the default task. Grunt requires that all `Gruntfiles` register a default
    task. The next argument is an array of strings containing the name of any tasks
    and targets required to run as part of this task.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we are just running tasks without listing any individual targets.
    If we had targets we wished to run on the tasks, the syntax would be `task:target`.
    For example, if we defined a test target for our `uglify` task, we would register
    it in our array as `['uglify:test']`.
  prefs: []
  type: TYPE_NORMAL
- en: Running Grunt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running grunt couldn't be simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure that the grunt CLI is installed, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the directory where your `Gruntfile` lives, simply run grunt followed
    by the name of the task you wish to run. To run the default task, you can omit
    the `taskname`. Now, let''s try running grunt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you look in your `dist` folder now, you'll notice it's no longer empty. Grunt
    has cleaned it, moved a bunch of files in, and minified some things. Note that
    the first time you run this with an empty `dist` folder, the clean task will report
    0 paths cleaned. When you run this subsequently, you should see the number of
    files in the `dist` folder actually being cleaned.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you might notice is that each task is running a target. Copy is
    running main, `uglify` is running `my_target`. By default, if no target is specified,
    Grunt will run the first-defined target.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open up your `dist/public/javascripts/giftapp.js` file, you should see
    that it has been minified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Code minification makes our files smaller and somewhat harder to read. It can
    improve the files' performance on the web significantly. For a more significant
    performance improvement, we might have to look into concatenating script files
    and use tools such as the Closure compiler to make them even more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no need to minify server-side JavaScript code. The main reason for
    minification is reduced data transfer with a client.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our config for production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One issue we're going to run into when moving our application into a production
    environment is that there will be a difference between our development and our
    production environment. Right now, all our database references point to our local
    MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use Git to push our files to production later on, and we also
    don't want to store configuration variables in Git repositories. We also don't
    want to store `node_modules` in Git or push them to production environment since
    they can be fetched on the fly using our `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Create a .gitignore file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the root of your project, create a file called `.gitignore`. This file contains
    a list of files and paths that we don''t want Git to store or track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Line by line we just list the files and folders we want Git to ignore. The first
    is `node_modules`. Again, there's no reason to store these. I then want to ignore
    anything in my `config` folder, which contains sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: In here, I ignore `.idea`. You may or may not have this folder. This is a folder
    created by my development environment to store project information. I'm using
    `JetBrains` IDE for JavaScript called Webstorm. Whatever you're using, you'll
    want to exclude your IDE files, if any. Finally, I explicitly exclude `dist/config`,
    which will be a copy of `config`.
  prefs: []
  type: TYPE_NORMAL
- en: Create an environment-based configuration module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What we want is for the configuration to be handled dynamically. If you're in
    the development environment, use our configuration for your local machine. If
    you're in the production environment, you would want to use appropriate configuration
    variables for that environment.
  prefs: []
  type: TYPE_NORMAL
- en: The safest way to do that in the production environment setting up environment
    variables that can be read in the application. We will set them up when we set
    up our deployment environment, but we can set the stage now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your root `giftapp` folder, create a new file called `appconfig.js`, using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We first check to see whether there is a `NODE_ENV` environment variable and
    whether it is set to *production*. If it is, we will have to grab our database
    and our Facebook and Twitter authorization information from environment variables.
    We will set up our environment variables later on when we set up our deployment
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: If our test fails, we assume we're in our development environment and then manually
    set our database. We grab our `authorization.js` file out of the `config` directory
    and use that to set up our Twitter and Facebook authorization variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new config file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we need to employ our configuration file. Open up your main `app.js` file
    and make a couple of edits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we load our `appconfig.js` file and assign it to the variable `appconfig`.
    Remember, our `appconfig` module exports a function. We need to invoke that function
    to run the code and get access to the dynamically set properties. So, we invoke
    `appconnfig()` and assign the returned object to the variable `config`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `config.db` in the call to `monk()` to create the database object.
    You should now be able to start up your database and server, and there should
    be no difference in the functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to use the `appconfig` in our passport `OAuth` strategies. Let''s
    start with `passport`/`facebook.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we require `appconfig.js` from the root of our application. We then
    invoke the returned function and assign it to the variable `auth`. We should require
    no additional changes, and restarting our server should show that our changes
    have worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s do the same thing to our `passport/twitter.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've made exactly the same change to the Twitter authorization
    strategy file. Once again, give it a test and it should work exactly the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a cloud database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our SPA will soon live in the cloud, and it needs to be connected to a database.
    Moving our application to the cloud requires our database also to be accessible
    from the Web. Having a database running on your local machine isn't going to cut
    it.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of cloud-based database services, but I have found that MongoLab
    is one of the easiest to set up, use, and maintain. They offer a free sandbox
    database, which is perfect for development and experimentation. For production-level
    applications, you'd want to look into a higher subscription rate.
  prefs: []
  type: TYPE_NORMAL
- en: The PaaS we will use to deploy our application, Heroku, plays really well with
    MongoLab, and even offers Mongolab as a one-click add-on. We will set things up
    manually for now so you can learn how things work a little better.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MongoLab account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you need to do is to set up your account on MongoLab. This
    couldn''t be simpler. Go to [https://mongolab.com/signup/](https://mongolab.com/signup/)
    and fill in the form. After you''ve signed up, you''ll be taken to a dashboard
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a MongoLab account](img/image_14_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Currently, I have two databases provisioned in my account. If you've just signed
    up, you won't see anything here. It's from this dashboard that you can set up
    and manage databases and your account.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, you have an account on MongoLab, but you don''t have a database.
    We need to create a new database. Fortunately, MongoLab makes this super easy
    for us. On your dashboard, click on the button that says **Create New**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a database](img/image_14_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the Create a new subscription page, there are a lot of different choices
    for setting up a new deployment. We want to set up a sandbox deployment, which
    is free and will give you 500 MB of storage. I chose Amazon Web Services for storage
    in the US East region, and **Single-node** | **Sandbox**.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll down to the bottom of the page, name your database and click on the button
    marked Create new MongoDB deployment. I named mine `giftapp`. Voila! You are now
    the proud owner of a shiny and new cloud-based MongoDB deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a user to access the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can''t connect to the database from our application yet. To do so, you''ll
    need to set up a username and password for the database access. From your dashboard,
    click on the name of your new database, and on the next screen, click on the **Users**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a user to access the database](img/image_14_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, make note of the standard MongoDB URI, which will include the username
    and password you''re about to set up. Click on **Add database user**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a user to access the database](img/image_14_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You'll get the preceding pop-up window. Fill it out; do not check read-only.
    Now, you have a database and a user who can access the data. Make a note of the
    URI; you will have to use this to access this database. If you want to test it
    out, you can plug it into your `appconfig` file in place of your local database.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application to Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have most of the pieces in place for web deployment. We will deploy
    our app to Heroku, a PaaS that supports Node.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready to use Heroku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are just a few steps that are required to deploy your application to Heroku.
    You'll have to install Git, set up a Heroku account, create a new project on Heroku,
    and then it will be ready for deploying.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deployment to Heroku is done using Git, so you will need to have it installed.
    If you don't already have Git installed, go to [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
    and follow the instructions for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have Git installed, you need to initialize a Gitrepository in your
    `giftapp` folder. From the root, in your command line, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have initialized Git, you''ll want to add all your files and commit
    them to your repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's it for now.
  prefs: []
  type: TYPE_NORMAL
- en: Signing up for a Heroku account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next thing you need to do is to sign up for a Heroku account, if you don''t
    already have one. Like MongoLab, this is simple. Go to [https://signup.heroku.com/login](https://signup.heroku.com/login)
    and fill out the form shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Signing up for a Heroku account](img/image_14_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you're all set with a free Heroku account.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the HerokuToolbelt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Heroku provides a CLI app for managing apps called HerokuToolbelt. You'll need
    to install this to deploy your application to Heroku. To install for your operating
    system, go to [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/) and
    follow the instructions for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, you can log in to Heroku from your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, you're good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Heroku project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to actually set up your `giftapp` project to be deployed to Heroku.
    In your terminal, make sure you are in the root directory of your `giftapp` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The create command has created a Heroku app for us. In this case, the app will
    be accessed at [https://guarded-lake-23534.herokuapp.com/](https://guarded-lake-23534.herokuapp.com/).
    Navigating to that URL now won't be very exciting, since we haven't actually deployed
    anything yet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Heroku generates a random app name for you. You can pass an app name you would
    like as part of the call to create, and, as long as it's unique, your app will
    live there. You can also point a custom domain to your Heroku app, but only if
    you have a paid account-refer to the Heroku documentation for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing the create command has done is to create a remote Git repository
    for us. This is how we will get our files deployed. There are a couple more steps
    we need to perform in order to deploy our app.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Heroku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that most of the setup work is done, it's time to take the final steps to
    move our application online.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Procfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need a **Procfile** to tell Heroku what to run when we deploy. A Procfile
    is a file that tells the dynos at Heroku which commands to run. For Heroku to
    read this file, you must name the file Procfile (without any extension) and include
    it in the top-level directory of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `Procfile` in the root of your `giftapp` project and add
    the following line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This tells Heroku to run the www script out of our `dist` directory.
  prefs: []
  type: TYPE_NORMAL
- en: App environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you remember, our application is expected to use a number of environment
    variables to operate correctly. To set these up, log into your Heroku account
    and navigate to your dashboard at [https://dashboard.heroku.com/login](https://dashboard.heroku.com/login).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the name of your app to access its dashboard. Click on the settings
    tab, which will then reveal the `config` variables. This is where we will add
    all of the environment variables we need, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![App environment variables](img/image_14_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see I've added variables for **NODE_ENV**, **PORT**, and **facebookClientID**.
    You'll do the same and add one for each of the environment variables used in your
    `appconfig.js` file, including DB.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to adjust your Facebook and Twitter callback IDs to use your new Heroku
    domain. If you're confused about what it is, scroll down to the bottom of the
    settings page and it will be revealed.
  prefs: []
  type: TYPE_NORMAL
- en: Another step I'll leave you to do is to authorize your Heroku domain for your
    Facebook and Twitter apps. Just go into your app settings and add the new domain.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deploying is very easy, now that everything is completely ready. We will use
    a simple Gitpush. First let''s make sure that our `dist` files are ready to go
    and everything is committed to `git` properly by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Great, everything is checked in. If you want a sanity check, you can always
    try `git status`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s push everything we just committed to Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And we're live! I omitted a significant portion of the output of the push. It's
    a very long output. If you go through what's here, you can see what **HerokuToolbelt**
    will do when we push it. You can see our application starting. You can see that
    the deployment was a success.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the SPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I want to conclude with a few ideas about scaling the application. Scaling an
    application is a bit of a black art, but you do want to be prepared should you
    build out an application and it gets very popular very fast.
  prefs: []
  type: TYPE_NORMAL
- en: One of the really nice things about using PaaS tools is that they simplify scaling
    significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of options and considerations for scaling the database. You
    can see this just by looking at the different packages offered by MongoLab. MongoDB
    itself supports sharding and replication, as it was built for scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Concerns about scaling include the size of the database - how much storage,
    and performance - usually a factor of RAM or using dedicated clusters.
  prefs: []
  type: TYPE_NORMAL
- en: MongoLab and other providers offer numerous combinations of high-storage and
    high-performance plans along with several steps, allowing you to incrementally
    increase your scaling without missing a beat, or installing or configuring a new
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand its usage, which only comes over time with an application,
    and how that's going to affect the storage. If your application is growing and
    making many hits on your database, you'll want to think about its performance.
    As your database fills up, you'll want to manage its storage.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heroku makes it extremely easy to scale your app to exactly the right size that
    you need; it's one of the things they built their business around. On Heroku,
    apps are run inside dynos. Think of a dyno as a lightweight container that runs
    your app.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku has a number of different dynos running at different performance levels,
    and you can add and remove them, even at different levels of performance, from
    the command line or from your dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku also offers a number of add-ons, for a fee of course, for doing things
    such as performance monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Not to be a sales pitch for Heroku, other PaaS providers offer similar options.
    Amazon Web Services is a popular choice for Node.js. There are others, such as
    Modulus and Digital Ocean. If you're deploying a real-world commercial app, it
    pays to shop around to find the right solution for you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter by using Grunt to package up our app into a dist folder.
    We used Grunt plugins, installed using NPM, to do things such as minify our code.
    We spent a little time exploring the Grunt plugin ecosystem, which is quite vast
    and well supported.
  prefs: []
  type: TYPE_NORMAL
- en: We then prepared to deploy our app to the web by setting up a cloud-based database.
    We created an account on MongoLab, and then created a new database. We then added
    a user to the database so that we could access it from our application.
  prefs: []
  type: TYPE_NORMAL
- en: We then set up an account on Heroku, and prepared our application for deployment.
    We installed the HerokuToolbelt, which allowed us to create a new Heroku application
    deployment. We accessed our application through the Heroku dashboard and added
    our environment variables. Finally, we pushed our project to Heroku using Git.
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped up by briefly touching on topics such as scaling the database and
    the server. Using PaaS and a web-based database management system, we are well
    set up for when our application becomes as popular as Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading all the way through the book. If you have followed all of
    the instructions, you have a cloud-deployed, tested, SPA written in JavaScript.
    You now have all the skills to build an application front-to-back, database-to-presentation
    tier, in modern JavaScript. You should have a firm grasp of SPA architecture,
    modular code, and separation of concerns, and should have worked with every aspect
    of the MEAN stack. Congratulations, and good work!
  prefs: []
  type: TYPE_NORMAL
