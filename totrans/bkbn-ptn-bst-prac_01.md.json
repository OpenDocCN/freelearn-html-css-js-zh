["```js\nvar User = Backbone.Model.extend({\n  defaults: {\n    name: 'John Doe'\n  }\n});\n\nvar UserItemView = Backbone.View.extend({\n  template: '<span><%= name %></span>',\n  render: function () {\n    var tpl = _.template(this.template),\n      html = tpl(this.model.toJSON());\n\n    this.$el.html(html);\n    return this;\n  }\n});\n\n// Create a view instance passing a new model instance\nvar userItem = new UserItemView({\n  model: new User\n});\n\n$(document.body).append(userItem.render().el);\n```", "```js\n// Parent view which has the render function\nvar BaseView = Backbone.View.extend({\n  render: function () {\n    var tpl = _.template(this.template),\n      data = (this.model) ? this.model.toJSON() : {},\n      html = tpl(data);\n\n    this.$el.html(html);\n    return this;\n  }\n});\n```", "```js\n// A simpler view class\nvar UserItemView = BaseView.extend({\n  template: '<span><%= name %></span>'\n});\n```", "```js\nvar UserItemView = BaseView.extend({\n  tagName: 'div',\n  template: '<span><%= name %></span>',\n  render: function () {\n    // Call the parent view's render function\n    BaseView.prototype.render.apply(this, arguments);\n\n    // Add your code here\n    this.anotherFn();\n    return this;\n  },\n\n  anotherFn: function () {}\n});\n```", "```js\nvar BaseView = Backbone.View.extend({\n  render: function () {\n    var tpl = _.template(this.template),\n      data = (this.model) ? this.model.toJSON() : {},\n      html = tpl(data);\n\n    this.$el.html(html);\n    return this;\n  },\n\n  close: function () {\n    // Extra stuff goes here\n\n    // Remove the view\n    this.remove();\n  }\n});\n// This is not production-ready code, but it clearly gives you the concept of using custom widgets to reduce boilerplate in your code. It will not always be necessary to extend a Backbone class to create a plugin.\n```", "```js\n// Pagination constructor function\nvar Pagination = function (collection, noOfItemsInPage) {\n  if (!collection) {\n    throw \"No collection is passed\";\n  }\n  this.currentPage = 1;\n  this.noOfItemsInPage = noOfItemsInPage || 10;\n  this.collection = collection;\n}\n\n// Use Underscore's extend method to add properties to your plugin\n_.extend(Pagination.prototype, {\n  nextPage: function () {},\n  prevPage: function () {}\n});\n\nvar User = Backbone.Model.extend({\n  defaults: {\n    name: 'John Doe'\n  }\n});\n\nvar Users = Backbone.Collection.extend({\n  model: User\n});\n\nvar paging1 = new Pagination(10, new Users());\nvar paging2 = new Pagination(20, new Users());\n```", "```js\n// A simple object with some methods\nvar DraggableMixin = {\n  startDrag: function () {\n    // It will have the context of the main class \n    console.log('Context = ', this);\n  },\n  onDrag: function () {}\n}\n\n// UserItemView already extends BaseView\nvar UserItemView = BaseView.extend({\n  tagName: 'div',\n  template: '<%= name %>'\n});\n```", "```js\n// We just copy the Mixin's properties into the View\n_.extend(UserItemView.prototype, DraggableMixin, {\n  otherFn: function () {}\n});\n\nvar itemView = new UserItemView();\n\n// Call the mixin's method\nitemView.startDrag();\n```", "```js\nUserItemView.prototype.startDrag = DraggableMixin.startDrag;\n```", "```js\n// Functional mixin\nvar DraggableMixin = function (config) {\n  this.startDrag = function () {};\n  this.onDrag = function () {};\n\n  return this;\n}\n\n// DraggableMixin method is called passing the config object \nDraggableMixin.call(UserItemView.prototype, {\n  foo: 'bar'\n});\n// SortableMixin.call(UserItemView.prototype);\n\nnew UserItemView().startDrag();\n```", "```js\n// Functional mixin with cache\nvar DraggableMixin = (function () {\n  var startDrag = function () {};\n  var onDrag = function () {};\n\n  return function (config) {\n    this.startDrag = startDrag;\n    this.onDrag = onDrag;\n\n    return this;\n  };\n})(); \n```", "```js\n// Simple function\nfunction foo(){\n  console.log(arguments);\n}\n\n// We want this bar object to be available in the foo() function\nvar bar = {\n  name: 'Saswata Guha'\n};\n\n// Calling foo() without passing anything. Using curry, the \n// function will have the bar object in its scope\nfoo();  \n```", "```js\n// Definition of curry\nFunction.prototype.curry = function () {\n  var slice = Array.prototype.slice,\n    args = slice.apply(arguments),\n    that = this;\n  return function () {\n    return that.apply(null, args.concat(slice.apply(arguments)));\n  };\n};\n```", "```js\n// Functional mixin with cache\nvar DraggableMixin = (function () {\n  var startDrag = function (options) {\n    console.log('Options = ', options);\n  };\n  var onDrag = function () {};\n\n  return function (config) {\n    this.startDrag = startDrag.curry(config);\n    this.onDrag = onDrag;\n\n    return this;\n  };\n})();\n\nDraggableMixin.call(UserItemView.prototype, {\n  foo: 'bar'\n});\n```"]