- en: Chapter 3. Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a collection of models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a model from a collection by its index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a model from a collection by its ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a model to a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a model from a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a collection as a stack or as a queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering models in a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running No SQL queries on a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing models of various types in the same collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a one-to-many relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing applications with Backbone, you often need to work with a number
    of models, which can be organized in a collection. A collection is more than just
    a JavaScript array. Backbone provides various useful methods to work with it.
    Moreover, Backbone collection can easily communicate with a REST server to get
    or post a number of models.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn common operations to work with collections,
    and will discover new extensions which provide amazing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a collection of models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to create a collection of models.
    Collection is an object used for organizing models into an ordered set. There
    are specific methods to sort, filter, and iterate through a collection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `Backbone.Collection` object and pass the model's object name as
    an option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Initialize a new collection instance and pass the initial array of models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Backbone.Collection` knows which model object to use when creating new instances,
    because we specified it in the `model` property. Internally, models are stored
    in the `models` array.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also initialize a collection with the existing models. Here is how it
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Getting a model from a collection by its index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with a collection, we may need to get a model at the specific index,
    because it is stored inside the collection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `at()` method to get a model from a collection at the specific index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internally, models are stored in the `models` array, so the first element starts
    with a zero index. `Backbone.Collection` keeps this array in the accurate state
    when we add a new model to a collection, remove one model, or perform sorting.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Be careful when sorting a collection**'
  prefs: []
  type: TYPE_NORMAL
- en: When performing a collection, sorting it can update the model indexes, so the
    `at()` method with the same parameter can get different models before and after
    sorting.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn some interesting details about models
    in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an index of a collection model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get an index of a model stored in a collection, use the `indexOf()` method
    inherited from `Underscore.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting an independent copy of a model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The model object that is retrieved from a collection is the same object stored
    there, so if we modify this object, one object in the collection gets updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we need to get an independent copy of the model object, we can use the `clone()`
    method of a returned model. Changing the attributes of the cloned model does not
    affect the attributes of the original model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Getting the length of a collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a way to get the length of a collection. It is done with the help
    of the `length()` method. The following example gets a collection length and then
    obtains the last model from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Getting a model from a collection by its ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, we may need to request a model from a collection by its
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to get a model from a collection by its ID:'
  prefs: []
  type: TYPE_NORMAL
- en: To get a model from a collection by its identifier, use the `get()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To get a model from a collection by its client identifier, you can again use
    the `get()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When getting a model by its ID, `Backbone.Collection` searches for the model
    in the `_byId` array, which stores models mapped to their IDs. Such an implementation
    guarantees the best performance, because there is no need to loop through all
    the models in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Extending an application with plugins* in [Chapter 2](ch02.html "Chapter 2. Models"),
    *Models*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a model to a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn different ways of adding new models to
    a collection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Call the `add()` method to add a new model to the end of a collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in the `add()` method prevents duplicates from being added to the collection.
    A unique model is inserted into the `models` array and is mapped to its ID in
    the `_byId` array. Also, a reference to the collection is created in the model
    object in the `collection` property.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a new model is added to the end of the collection. But in case sorting
    is enabled, or insertion index is specified, the model can be inserted at a different
    position.
  prefs: []
  type: TYPE_NORMAL
- en: When adding a new model to a collection, the `add` event is being triggered.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn different ways to add a model(s) into
    a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a model at a specific position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a model at a specific position, we need to pass `{at: index}` as an
    option.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding multiple models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also add multiple models at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Adding existing models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use existing model objects as the arguments for the `add()` method.
    We can pass a single object as well as an array of existing objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Handling events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events
    and Bindings"), *Events and Bindings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a model from a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn about removing a model from a collection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Call the `remove()` method to remove a model from a collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we can pass the model's `id`, `cid`, or even the model object as a parameter.
    We can either pass a single value or an array of values.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When calling the `remove()` method, a model is removed from the `models` array,
    and any references between them are removed as well. Thus, the model object itself
    is not destroyed, and we can still work with it if the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we may need to delete all the existing models from a collection and
    add some others. There is a useful `reset()` method, which does both these jobs
    simultaneously. Here is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Working with a collection as a stack or as a queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are special methods in Backbone that allow working with a collection as
    a stack or as a queue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to work with a collection as a stack or as a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `push()` method to add a model to the end of a collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Call the `pop()` method to remove and return the last model from a collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Call the `unshift()` method to add a model at the beginning of a collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Call the `shift()` method to remove and return the first model from a collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To organize a stack also known as LIFO (last in, first out), we need to use
    the `push` and `pop` (`unshift` and `shift`) methods. To organize a queue also
    known as FIFO (first in, first out), we need to use the `unshift` and `pop` (`push`
    and `shift`) methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image illustrates the difference between a stack and a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2728OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sorting a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Backbone.js` provides a sorting mechanism, out of the box, which we are going
    to learn in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to sort a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign the `comparator` callback to the `comparator` property of a collection
    to maintain the correct order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `comparator` callback accepts a single parameter, which is a model object.
    It should return a value according to which the collection is sorted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, call the `sort()` method to force sorting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `comparator` callback is defined, Backbone uses it to insert a new
    model in the `models` array so that it is inserted in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: If you assign a new `comparator` callback to a collection with existing models,
    you need to trigger sorting manually by calling the `sort()` method.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to call the `sort()` method if the model in the collection gets
    updated. This can be done automatically if you bind sorting on the model's `change`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to define a comparator in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing a pair of models in the comparator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to implement a comparator is to evaluate a pair of models passed
    as parameters and return one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: -1 (or any negative value), if the first model should come before the second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0, if they are of the same rank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 (or any positive value), if the first model should come after the second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates sorting by the length of the `description`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Handling events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events
    and Bindings"), *Events and Bindings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering models in a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone provides a simple filtering mechanism out of the box, which we can
    use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To filter models in a collection, use the `where()` method. It accepts a search
    criteria and returns an array of found models.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to pass multiple criteria together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Running No SQL queries on a collection* recipe to learn more about
    advanced filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to discuss various ways of iterating through a
    collection to implement the functionality we need.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to iterate through a collection is to use the `each()` method
    provided by `Underscore.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `each()` method, we pass an iterator function, which is executed for
    each model. It accepts the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**model**: The model that is being iterated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**index**: This is the model index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**list**: This is the whole model array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Backbone.js` is based on `Underscore.js`, which provides various useful tools,
    including methods to work with the collections and arrays. Backbone collections
    support some of those functions.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn some methods that rely on the iteration
    method but are more specific.
  prefs: []
  type: TYPE_NORMAL
- en: Checking every model to match a specific condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check every model in a collection that fulfills a specific criteria, use
    the `every()` method. It accepts a callback parameter which should return a `Boolean`
    value if the condition is fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Checking any model to match a specific condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check any model in a collection that fulfills a specific criteria, use the
    `some()` method. It accepts a callback parameter which should return a `Boolean`
    value if the condition is fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Getting the attribute from each model in a collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous examples, we used the `pluck()` method, which returns an array
    of values for the specified attribute from each model in a collection. Let's see
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Performing specific calculations to each model in a collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To perform specific calculations to each model in a collection, use the `map()`
    method. It takes callback as a parameter, executes it for each model in a collection,
    and returns an array of results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Boiling down models in a collection into a single value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Models in a collection can be boiled down to a single value using the `reduce()`
    method. Here is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many helpful methods from `Underscore.js` that can be used with Backbone
    collections. You can find them in `Underscore.js` official docs from [http://documentcloud.github.com/underscore/#collections](http://documentcloud.github.com/underscore/#collections).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to perform several Underscore methods in a row, a good way of doing
    it is by chaining one method to the other method.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a simple MapReduce example, which calculates the total amount.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, `amounts` is a JavaScript array, and it does not provide the `reduce()`
    method that we can call. To solve this problem, we are calling the `reduce()`
    method provided by `Underscore.js`, which takes an array as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With chaining, it is possible to call one method right after another using the
    `dot` syntax. Here is an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `chain()` method wraps a value into an object, which provides different
    methods that can be executed, which return their result as a wrapped value. To
    unwrap a result, use the `value()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see more chaining examples, please visit [http://documentcloud.github.com/underscore/#chain](http://documentcloud.github.com/underscore/#chain)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running No SQL queries on a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe we described several techniques, including the one about
    searching the models in a collection with the `where()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There are more advanced ways of searching the models in a collection, which
    can be done with the help of a Backbone extension named **Backbone Query**. It
    allows running No SQL (such as MongoDB) queries for searching, sorting, and paging
    the models in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the Backbone Query extension from its GitHub page by going
    to [https://github.com/davidgtonge/backbone_query](https://github.com/davidgtonge/backbone_query).
    To include this extension into your project, save the `backbone-query.js` file
    into the `lib` folder and include the reference to it in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including the Backbone extension into your project is described in detail in
    the *Extending an application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to perform a No SQL query to a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: To allow a No SQL query to be executed, extend a collection from the `Backbone.QueryCollection`
    object instead of a `Backbone.Collection` one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the query with the `query()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Optionally, run the `pluck` attribute from the resulting array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Backbone.QueryCollection` extends `Backbone.Collection` and provides the new
    `query()` method, which parses the base query into subqueries recursively and
    uses the `reduce()` method of `Underscore.js` to run queries of the same group
    sequentially.'
  prefs: []
  type: TYPE_NORMAL
- en: Backbone Query is written initially in CoffeeScript and compiled into JavaScript
    later. So, if you are interested in understanding its source code, see `backbone-query.coffee`.
    It looks quite similar though.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section describes No SQL operators and covers some advanced topics, such
    as grouping, sorting, paging, and caching.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following operators are common and applied to the attributes of the models
    stored in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: $equal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This performs a strict equality test using `===`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If no operator is provided, and the query value is neither a regex nor an array,
    then `$equal` is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: $ne
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This means not equal, which is the opposite of `$equal`, and returns all the
    models that are not equal to the query value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: $in
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An array of possible values can be supplied using `$in`; a model will be returned
    if any of the supplied values is matched.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: $nin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This means not in, which is the opposite of `$in`, and a model will be returned
    if none of the supplied values is matched.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: $exists or $has
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This checks for the existence of an attribute, and can be supplied as either
    `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Combining queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiple queries can be combined together. There are the `$and`, `$or`, `$nor`,
    and `$not` operators, which we are going to learn shortly.
  prefs: []
  type: TYPE_NORMAL
- en: $and
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a logical AND operator. The following query selects all the buyers
    named John and who live in Alexandria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `$and` operator is used as a glue if no combining operator is supplied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: $or
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a logical OR operator. The following query selects all the buyers named
    John or whether the buyers live in Alexandria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: $nor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is the opposite of `$or`. The following query selects all the buyers with
    a name other than John or if they do not live in Alexandria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: $not
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is the opposite of `$and`. The following query selects all buyers except
    anyone whose name is John and who lives in Alexandria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Multiple queries on the same key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we need to perform multiple queries on the same key, then we can supply
    the query as an array. The following query returns all the clients with the name
    John or Joe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Sorting query results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To sort results by a property, we need to pass it with the `sortBy` key in
    a second argument. We can also specify the order by passing the `asc` or `desc`
    value with the `sort` key. By default, `asc` is assumed as the value. The following
    code shows how sorting is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Paging query results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a way to split a big result array on several pages and return a specified
    one. Let's see how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify the following properties in the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`limit`: It limits the resulting array size to a given number. The first N
    elements are returned. It is a required property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`: It returns a specified resulting page. The page size is set by the
    limit property. It is an optional property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset`: It skips the first N result items. It is an optional property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For performance reasons, we may want to cache our results. This can greatly
    decrease the query execution time, especially if using paging, because unpaged
    results are saved in the cache and a user can quickly navigate through its pages.
  prefs: []
  type: TYPE_NORMAL
- en: To enable caching, simply use the `cache` property in the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Caching is not set by default, because there is no automatic way to flush the
    cache, so when caching is enabled and the collection is being updated, the cache
    becomes outdated.
  prefs: []
  type: TYPE_NORMAL
- en: You should be aware of this problem, and manually perform cache flushing every
    time the collections or models in it are updated. This can be done by calling
    the `reset_query_cache()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We can bind the collection's `change` event to the `reset_query_cache()` method,
    and thus, provide automatic cache flushing when the collection gets updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please see more information about Backbone query operators from [https://github.com/davidgtonge/backbone_query#query-api](https://github.com/davidgtonge/backbone_query#query-api)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling events of Backbone objects* in [Chapter 5](ch05.html "Chapter 5. Events
    and Bindings"), *Events and Bindings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing models of various types in the same collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building complex Backbone applications, you may need to work with models
    of different types, which should be processed in a similar way, so you may want
    them to be stored in the same collection. Fortunately, there is a `Backbone.Chosen`
    extension that allow us to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find and download `Backbone.Chosen` from the following page: [https://github.com/asciidisco/Backbone.Chosen](https://github.com/asciidisco/Backbone.Chosen).
    To include `Backbone.Chosen` into your project, save the `backbone.chosen.js`
    file into the `lib` folder and include the reference to it in `index.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including Backbone extension into your project is described in detail in the
    *Extending an application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we have two different model classes, namely `IndividualContactModel`
    and `OrganizationContactModel`, and we want to organize them into a single collection.
    We can do this by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, these models have different attributes, but share a common `name()`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Define collection with a `chosen` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a collection instance and specify the mapping attribute in the incoming
    JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check the result. The newly added models to the collection should be the instance
    of the correct model class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Backbone.Chosen` overrides the `_prepareModel` method of `Backbone.Collection`
    to select the proper model object that depends on its mapping attribute value.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains how to perform advanced mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping deeply nested attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Backbone.Chosen` also supports nested attributes. You can specify the value
    for the `attr` property with a `dot` syntax, for example, `options.type`, if your
    incoming JSON looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Use a function to map the models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we may need to use more complex calculations to map the models. This
    can be done with the help of the mapping function. Here is how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a one-to-many relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Models"), *Models*, there is a recipe about
    creating a one-to-one relationship between two models. In this recipe, we are
    going to learn about creating one-to-many relationships.
  prefs: []
  type: TYPE_NORMAL
- en: A one-to-many relationship can be used if the association between a single model
    and a collection of models of another type takes place. In our invoice application,
    the relationship between `InvoiceModel` and `InvoiceItemModel` is one such relationship.
    InvoiceItem Model can be multiple and thus is stored in `InvoiceItemCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the Backbone-relational extension from its GitHub page at [https://github.com/PaulUithol/Backbone-relational](https://github.com/PaulUithol/Backbone-relational).
    To include `Backbone.Relational` into your project, save the `backbone-relational.js`
    file into the `lib` folder and include the reference to it in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including Backbone extension into your project is described in detail in the
    *Extending an application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementation of a one-to-many relationship is similar to an implementation
    of a one-to-one relationship, except that we need to use `Backbone.HasMany` as
    a type and specify `collectionType`, because multiple models should be stored
    in the collection. We can do this by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the new model object from `Backbone.RelationalModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the collection for this model type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Extend another model object from `Backbone.RelationalModel` and pass the `relations`
    property with a relationship definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To initialize models with a one-to-many relationship, pass the invoice items'
    data in a single JSON when creating a new `InvoiceModel` object instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add new records into this relation with the help of the `add()` method when
    accessing the related collection using the `items` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Or we can also create an instance of `invoiceItemModel` and set the invoice
    attribute with an instance of `invoiceModel`; thus, a new relation in both the
    directions will be created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each `Backbone.RelationalModel` registers itself with `Backbone.Store` upon
    creation, and is removed from `Store` when destroyed. When creating or updating
    an attribute that is a key in a relation, the removed related objects are notified
    of their removal, and new related objects are looked up in `Store`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn some advanced usages of `Backbone.Relational`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a many-to-many relationship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no way to create a many-to-many relationship between two models out
    of the box, but it can be easily done with the help of a pair of one-to-many relationships
    between those models and a new intermediate model.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting related models to JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When exporting a model to JSON, it does include related models. This is how
    we can export `InvoiceModel` to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: And here is a result of such an export.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is how we can export the `InvoiceItemModel` model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And the result is the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `toJSON()` method also exports reversed relationships, but
    we can control the attributes of the related models that need to be exported by
    specifying an array of such attributes in the `includeInJSON` property for direct
    and reverse relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing a one-to-one relationship* in [Chapter 2](ch02.html "Chapter 2. Models"),
    *Models*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about exporting to JSON is described in the *Synchronizing
    models and collections with a RESTful service* recipe in [Chapter 7](ch07.html
    "Chapter 7. REST and Storage"), *REST and Storage*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete documentation of the Backbone-relational extension can be found on
    its GitHub page at [https://github.com/PaulUithol/Backbone-relational](https://github.com/PaulUithol/Backbone-relational)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, there is an alternative to the Backbone-relational extension, which is
    Backbone-associations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
