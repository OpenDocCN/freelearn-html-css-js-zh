<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Adding and Modifying Elements with Views</h1></div></div></div><p>In this chapter, we'll take a look at how to do the following:</p><div><ul class="itemizedlist"><li class="listitem">Create new <code class="literal">View</code> classes and instances</li><li class="listitem">Use Views to render DOM elements</li><li class="listitem">Connect Views to Models and Collections</li><li class="listitem">Respond to DOM events using Views</li><li class="listitem">Decide the rendering style(s) that best fits your project</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Views are the core of Backbone-powered sites</h1></div></div></div><p>While data is certainly important in any application, you can't have an application without a user interface at all. On the web, this means that you have a combination of DOM elements (to display information to the user) and event handlers (to receive input from the user). In Backbone, both of these things are managed by Views; in fact, it's only fair to say that <a id="id169" class="indexterm"/>Views pretty much control all the input and output on a Backbone-powered site.</p><p>Just as Models wrap an <code class="literal">attributes</code> object and Collections wrap a <code class="literal">models</code> array, <code class="literal">Views</code> wrap a DOM element inside a property called <code class="literal">el</code>. Unlike attributes and models, however, <code class="literal">el</code> is not hidden, and Backbone doesn't watch it for changes, so there's nothing wrong with referencing a View's <code class="literal">el</code> directly:</p><div><pre class="programlisting">someModel.attributes.foo = 'bar'; // don't do this
$('#foo').append(someView.el); // feel free to do this</pre></div><p>To create a new <code class="literal">View</code> subclass, simply extend <code class="literal">Backbone.View</code> in the same way as you created new <code class="literal">Model</code> and <code class="literal">Collection</code> subclasses, as shown here:</p><div><pre class="programlisting">var MyView = Backbone.View.extend({
    // instance properties and methods of MyView go here
}, {
    // static properties and methods of MyView go here
});</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec20"/>Instantiating Views</h2></div></div></div><p>As we mentioned<a id="id170" class="indexterm"/> in <a class="link" title="Chapter 2. Object-Oriented JavaScript with Backbone Classes" href="part0021.xhtml#aid-K0RQ1">Chapter 2</a>, <em>Object-oriented JavaScript with Backbone Classes</em>, Views take only a single <code class="literal">options</code> argument when instantiated. The most important part of these options is the <code class="literal">el</code> property, which defines the DOM element that the View will wrap as its <code class="literal">el</code>. A View's <code class="literal">el</code> option can be defined in one of the following three ways:</p><div><ul class="itemizedlist"><li class="listitem">HTML (<code class="literal">new Backbone.View ({el: &lt;div id='foo'&gt;&lt;/div&gt;})</code>)</li><li class="listitem">jQuery Selector (<code class="literal">new Backbone.View ({el: '#foo'})</code>)</li><li class="listitem">DOM element (<code class="literal">new Backbone.View ({el: document.getElementById('foo')})</code>)</li></ul></div><p>You can also choose not to provide an <code class="literal">el</code> option, in which case Backbone will create the View's <code class="literal">el</code> option for you. By default, Backbone will simply create an empty <code class="literal">DIV</code> element (<code class="literal">&lt;div&gt;&lt;/div&gt;</code>), although you can change this by providing other options when you create your view. You can provide the following options:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">tagName</code>: This changes <a id="id171" class="indexterm"/>the generated elements' tag from <code class="literal">div</code> to the specified value</li><li class="listitem"><code class="literal">className</code>: This <a id="id172" class="indexterm"/>specifies the HTML <code class="literal">class</code> attribute that the element should have</li><li class="listitem"><code class="literal">id</code>: This <a id="id173" class="indexterm"/>specifies the HTML <code class="literal">id</code> attribute that the element should have</li><li class="listitem"><code class="literal">attributes</code>: This specifies<a id="id174" class="indexterm"/> the HTML attributes that the element should have</li></ul></div><p>Technically, you can specify both the class and ID of a View's element using the <code class="literal">attributes</code> option, but because they are important to the definition of a View, Backbone provides separate <code class="literal">id</code> and <code class="literal">className</code> options.</p><p>Instead of defining the preceding options when you instantiate your View, you can also choose to define them in a <code class="literal">View</code> class. For instance, if you want to create a <code class="literal">View</code> class that generates a <code class="literal">&lt;form&gt;</code> element with a class of <code class="literal">nifty</code>, you should do the following:</p><div><pre class="programlisting">var NiftyFormView = Backbone.View.extend({
    className: 'nifty',
    tagName: 'form'
});
var niftyFormView = new NiftyFormView();
var niftyFormView2 = new Backbone.View({
    className: 'nifty',
    tagName: 'form'});
// niftyFormView and niftyFormView2 have identical "el" properties</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec21"/>Rendering view content</h2></div></div></div><p>While Views can take <a id="id175" class="indexterm"/>an <code class="literal">el</code> option to define their initial element, it is rare for them to leave this <code class="literal">el</code> option unchanged. For instance, a <code class="literal">list</code> View might take an <code class="literal">&lt;ul&gt;</code> element as its <code class="literal">el</code> option but then fill this list with the <code class="literal">&lt;li&gt;</code> elements (possibly using data from a Collection). In Backbone, this generation of inner HTML is done inside the View's <code class="literal">render</code> method.</p><p>However, when you try to use the <code class="literal">render</code> method of an unmodified View, you quickly notice a problem with Backbone's default implementation, as follows:</p><div><pre class="programlisting">render: function() {
    return this;
}</pre></div><p>As you can see, the default <code class="literal">render</code> method doesn't actually render anything. This is because different Views can have entirely different content, so it doesn't make sense for Backbone to provide only one way of generating that content. Instead, Backbone leaves the implementation of your View's <code class="literal">render</code> method entirely up to you.</p><p>Later on, in this chapter, we'll consider the various strategies for how you might want to implement <code class="literal">render</code> methods on your site, but before we get to that, let's first examine how to connect Models and Collections to Views as well as how Views handle event bindings.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec22"/>Connecting Views to Models and Collections</h2></div></div></div><p>When a View is <a id="id176" class="indexterm"/>created, it can take two important options: <code class="literal">Model</code> and <code class="literal">Collection</code>. Both of these options are simple property options, which is to say that<a id="id177" class="indexterm"/> Backbone doesn't actually do anything with them <a id="id178" class="indexterm"/>other than add them as properties to the View. Even <a id="id179" class="indexterm"/>so, these properties can be very useful when you want to display or edit data that you've previously generated. For instance, if you want to associate a View with a <code class="literal">book</code> Model that you have created, you can do the following:</p><div><pre class="programlisting">var book = new Backbone.Model({ 
    title: 'Another Fake Title? Why?'
});
var bookView = new Backbone.View({model: book});
// book == bookView.model;</pre></div><p>When you write the <code class="literal">render</code> method for your <code class="literal">book</code> View, you can use that Model in order to get the data to generate the appropriate HTML. For instance, here's a simple implementation of <code class="literal">render</code>, loosely borrowed from the Backbone documentation:</p><div><pre class="programlisting">render: function() {
    this.$el.html(this.template(this.model.toJSON()));
    return this;
}</pre></div><p>As you can see, the <a id="id180" class="indexterm"/>imaginary <code class="literal">render</code> method passes the output of the <a id="id181" class="indexterm"/>Model's <code class="literal">toJSON</code> to the View's templating system, presumably<a id="id182" class="indexterm"/> so that the templating system can use <a id="id183" class="indexterm"/>the Model's attributes to render the View.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec23"/>Accessing a View's el element</h2></div></div></div><p>Once you've created a View, you<a id="id184" class="indexterm"/> can access the element that it wraps at any time by<a id="id185" class="indexterm"/> referring to its <code class="literal">el</code> property. You can also access a jQuery-wrapped version of the same element by referring to the View's <code class="literal">$el</code> property. Take an example of the following code:</p><div><pre class="programlisting">var formView = new Backbone.View({tagName: 'form'});
formView.$el.is('form'); // returns true</pre></div><p>Backbone also provides another convenient shortcut when you want to access elements inside a View's element: the <code class="literal">$</code> method. When you use this method, it's effectively the same as calling jQuery's <code class="literal">find</code> method from the View's element. Because the search for the element is localized to only look through the View's <code class="literal">el</code> element and not through the entire page's DOM, it will perform much better than a global jQuery selection.</p><p>For example, if you create a View of a <code class="literal">&lt;form&gt;</code> element with an <code class="literal">&lt;input&gt;</code> element inside it, you can use the View's <code class="literal">$</code> method to access the <code class="literal">&lt;input&gt;</code> element , as shown here:</p><div><pre class="programlisting">var formView = new Backbone.View({
    el: '&lt;form&gt;&lt;input value="foo" /&gt;&lt;/form&gt;'
});
var $input = formView.$('input');
$input.val(); // == "foo"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec24"/>A brief aside on $Variable names</h2></div></div></div><p>When working with<a id="id186" class="indexterm"/> jQuery objects in Backbone (or even just in JavaScript, in general), it may<a id="id187" class="indexterm"/> often be difficult to tell whether a given variable refers to a <code class="literal">View</code> element or to its <code class="literal">el</code> element. In order to avoid confusion, many programmers (including the authors of both Backbone and jQuery) preface any variable that points to a jQuery object with the <code class="literal">$</code> symbol, as follows:</p><div><pre class="programlisting">var fooForm = new Backbone.View({id: 'foo', tagName: 'form'});
var $fooForm = fooForm.$el;</pre></div><p>While this practice is <a id="id188" class="indexterm"/>certainly not necessary to use Backbone, adopting it will likely save you from confusion in the future.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Handling events</h1></div></div></div><p>While the Views we've <a id="id189" class="indexterm"/>described so far are great for creating and/or wrapping existing HTML elements, they're not very good at responding when a user interacts with them. One approach to solve this problem will be to hook up event handlers inside a View's <code class="literal">initialize</code> method, as follows:</p><div><pre class="programlisting">var FormView = Backbone.View.extend({
    id: 'clickableForm',
    initialize: function() {
        this.$el.on('click', _.bind(this.handleClick, this));
    },
    handleClick: function() {
        alert('You clicked on ' + this.id + '!');
    }
});
var $form = new FormView().$el;
$form.click(); // alerts "You clicked on clickableForm!"</pre></div><p>However, there are two problems with this approach, as follows:</p><div><ul class="itemizedlist"><li class="listitem">It's not terribly readable</li><li class="listitem">We have to bind the event handler when we create it so that we can still reference <code class="literal">this</code> from inside it</li></ul></div><p>Luckily, Backbone offers a better way, in the form of an optional property called <code class="literal">events</code>. We can use this <code class="literal">events</code> property to simplify our previous example:</p><div><pre class="programlisting">var FormView = Backbone.View.extend({
    events: {'click': 'handleClick'},
    id: 'clickableForm',

    handleClick: function() {
        alert('You clicked on ' + this.id + '!');
    }
});
var $form = new FormView().$el;
$form.click(); // alerts "You clicked on clickableForm!"</pre></div><p>As you can see, using the <code class="literal">events</code> property saves us from even having to write an <code class="literal">initialize</code> method at all, while at the same time, it also takes care of binding the <code class="literal">handleClick</code> event handler to the View itself. In addition, by defining the event handlers in this way, we let Backbone know about them so that it can manage to remove or rebind them as needed.</p><p>When you instantiate a <a id="id190" class="indexterm"/>View, Backbone calls a <code class="literal">delegateEvents</code> method, which checks the <code class="literal">events</code> property, binds all the handlers found in it, and then creates listeners for the appropriate events using jQuery. There is also a corresponding <code class="literal">undelegateEvents</code> method, which can be used to remove all the event handlers. Normally, you won't need to call either of these methods yourself because Backbone will call them for you.</p><p>However, if you change a View's <code class="literal">el</code> element without telling Backbone (for example, <code class="literal">yourView.el = $('#foo')[0]</code>), Backbone won't know that it needs to hook up the events to the new element, and you will have to call <code class="literal">delegateEvents</code> yourself.</p><p>Alternatively, instead of changing a View's <code class="literal">el</code> element manually and then calling <code class="literal">delegateEvents</code> afterwards, you can use a View's <code class="literal">setElement</code> method to do both at the same time, as follows:</p><div><pre class="programlisting">var formView = new Backbone.View({el: '#someForm'});
formView.setElement($('#someOtherForm'));
// formView.el == someOtherForm</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Rendering strategies</h1></div></div></div><p>Now that we've<a id="id191" class="indexterm"/> covered all of View's capabilities, it's time to return to the question of how to render a View. Specifically, let's look at the main options available to you, which are explained in the sections that follow, when you overwrite the <code class="literal">render</code> method.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec25"/>Simple templating</h2></div></div></div><p>The first, and perhaps the <a id="id192" class="indexterm"/>most obvious, approach for rendering is to use a simple, logic-less templating system. The <code class="literal">render</code> method provided in the Backbone documentation is a perfect example of this, as it relies on the Underscore library's <code class="literal">template</code> method:</p><div><pre class="programlisting">render: function() {
    this.$el.html(this.template(this.model.toJSON()));
    return this;
}</pre></div><p>The <code class="literal">template</code> method takes a string, which contains one or more specially designated sections, and then combines this string with an object, filling in the designated sections with that object's values. This is best explained with the following example:</p><div><pre class="programlisting">var author ={
    firstName: 'Isaac',
    lastName: 'Asimov',
    genre: 'science-fiction'
};
var templateString = '&lt;%= firstName %&gt; &lt;%= lastName %&gt; was a '+
                     'great &lt;%= genre %&gt; author.';
var template = _.template(templateString);
alert(template(author));
// will alert "Isaac Asimov was a great science-fiction author."</pre></div><p>While the <code class="literal">template</code> function<a id="id193" class="indexterm"/> works with any string and data source, when used as part of a Backbone View, it is typically used with an HTML string and a <code class="literal">Backbone.Model</code> data source. Underscore's <code class="literal">template</code> function lets us combine the two to easily create a <code class="literal">render</code> method.</p><p>For instance, if you want to create a <code class="literal">&lt;div&gt;</code> tag with an <code class="literal">&lt;h1&gt;</code> tag inside containing an author's name and genre and then add an emphasis (in other words, an <code class="literal">&lt;em&gt;</code> tag) around the genre, you can create a <code class="literal">template</code> string with the desired HTML and placeholders for the first name, last name, and genre. We can then use the <code class="literal">_.</code> template to create a <code class="literal">template</code> function and then use this <code class="literal">template</code> function in a <code class="literal">render</code> method with an author Model's attributes.</p><p>Of course, as we mentioned in <a class="link" title="Chapter 3. Accessing Server Data with Models" href="part0029.xhtml#aid-RL0A1">Chapter 3</a>, <em>Accessing Server Data with Models</em>, it's safer if we don't access a Model's attributes directly; so, we'll want to use the Model's <code class="literal">toJSON</code> method instead. Putting all of this together, we get the following block of code:</p><div><pre class="programlisting">var authorTemplate =  _.template(
    '&lt;h1&gt;' +
        '&lt;%= firstName %&gt; &lt;%= lastName %&gt; was a ' +
        '&lt;em&gt;&lt;%= genre %&gt;&lt;/em&gt; author.' +
    '&lt;/h1&gt;'
);
var AuthorView = Backbone.View.extend({
  template: authorTemplate,
  render: function() {
    this.$el.html(this.template(this.model.toJSON()));
    return this;
  }
});
var tolkien = new Backbone.Model({
    firstName: 'J.R.R.', // Tolkien's actual first name was John
    lastName: 'Tolkien',
    genre: 'fantasy'
});
var tolkienView = new AuthorView({model: tolkien});
var tolkientHtml = tolkienView.render().$el.html();
alert(tolkienHtml);
// alerts "&lt;h1&gt;J.R.R. Tolkien was a &lt;em&gt;fantasy&lt;/em&gt; author.&lt;/h1&gt;"</pre></div><p>One major advantage of this <a id="id194" class="indexterm"/>approach is that because our HTML is completely separated into a string, we can optionally choose to move it out into a separate file and then bring it in using jQuery or a dependency library, such as <code class="literal">Require.js</code>. HTML that is stored separately like this can be easier for a designer to work with, if you have such a person in your team.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec26"/>Advanced templating</h2></div></div></div><p>Instead of using <a id="id195" class="indexterm"/>Underscore's <code class="literal">template</code> method, you can also employ one of the many quality third-party templating libraries available, such as Handlebars, Mustache, Hamljs, or Eco. All these libraries offer the same basic ability to combine a data object with a template string, but they also offer the possibility to include logic inside the template. For instance, here's an example of a Handlebars template string that uses an <code class="literal">if</code> statement, which is based on a provided <code class="literal">isMale</code> data property, to select the correct gender pronoun inside a template:</p><div><pre class="programlisting">var heOrShe = '{{#if isMale }}he{{else}}she{{/if}}';</pre></div><p>If we use Handlebars' <code class="literal">compile</code> method to turn that into a template, we can then use it just as we will use an Underscore template:</p><div><pre class="programlisting">var heOrSheTemplate = Handlebars.compile(heOrShe);
alert(heOrSheTemplate({isMale: false})); // alerts "she"</pre></div><p>We'll discuss more about Handlebars in <a class="link" title="Chapter 11. (Not) Re-Inventing the Wheel – Utilizing Third-Party Libraries" href="part0095.xhtml#aid-2QJ5E1">Chapter 11</a>, <em>(Not) Re-inventing the Wheel: Utilizing Third-Party Libraries</em> but the important thing to understand for now is that no matter which templating library you choose, you can easily incorporate it as part of your View's <code class="literal">render</code> method. The difficult part is deciding whether or not you want to allow logic inside your templates and if so, how much.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Logic-based</h2></div></div></div><p>Instead of relying on templating<a id="id196" class="indexterm"/> libraries, another option is to use Backbone's View logic, jQuery methods, and/or string concatenation to power your <code class="literal">render</code> methods. For instance, you can reimplement the preceding <code class="literal">AuthorView</code> without using templates at all:</p><div><pre class="programlisting">var AuthorView = Backbone.View.extend({
  render: function() {
    var h1View = new Backbone.View({tagName: 'h1'});
    var emView = new Backbone.View({tagName: 'em'});
    emView.text(this.model.get('genre'));
    h1View.$el.html(this.model.get('firstName') + ' ' +
                    this.model.get('lastName') + ' was a ');
    h1View.$el.append(emView.el, ' author.');
    this.$el.html(h1View.el);
    return this;
  }
});</pre></div><p>As you can see, there are <a id="id197" class="indexterm"/>both advantages and disadvantages to a purely logic-based approach. The main advantage, of course, is that we don't have to deal with a template at all. This means that we can see exactly what logic is being used, because nothing is hidden inside the template library's code. Also, there is no limit on this logic; you can do anything that you will normally do in JavaScript code.</p><p>However, we also lost a good deal of readability by not using a template, and if we had a designer on our team who wanted to edit the HTML, they would find <code class="literal">that</code> code very difficult to work with. In the first version, they will see a familiar HTML structure, but in the second version, they will have to work with the JavaScript code even though they (probably) aren't familiar with programming. Yet another downside is that because we've mixed the logic with the HTML code, there's no way to store the HTML in a separate file, the way we can if it were a template.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec28"/>The combined approach</h2></div></div></div><p>All three preceding approaches<a id="id198" class="indexterm"/> have advantages and disadvantages, and rather than settling for just one, you can choose to combine some of them instead. There's no reason why, for instance, you can't use a templating system (either Underscore's for simplicity or an external one for power) and then switch to using logic when you want to do something that doesn't fit neatly into a template.</p><p>For example, let's say you want to render a <code class="literal">&lt;ul&gt;</code> with a <code class="literal">class</code> HTML attribute derived from the attributes of a Model—this sounds like something that will be easier with JavaScript logic. However, let's say you also want this <code class="literal">&lt;ul&gt;</code> to contain <code class="literal">&lt;li&gt;</code> elements with text based on a template and filled in with the attributes of Models in a Collection; that sounds like something we can best handle with a template. Luckily, there is nothing stopping you from combining the two approaches, as shown here:</p><div><pre class="programlisting">var ListItemView = Backbone.View({
    tagName: 'li',
    template: _.template('&lt;%= value1 %&gt; &lt;%= value2 %&gt; are both ' +
                         'values, just like &lt;%= value3 %&gt;'),
    render: function() {
        this.$el.html(this.template(this.model.toJSON()));
        return this;
    }
});
var ListView = Backbone.View.extend({
  tagName: 'ul',
  render: function() {
    this.$el.toggleClass('boldList', this.model.get('isBold'));
    this.$el.toggleClass('largeFontList',
                         this.model.get('useLargeFont'));
    this.$el.empty();
    this.collection.each(function(model) {
        var itemView = new ListItemView({model: model});
        this.$el.append(itemView.render().el);
    }, this);
    this.$el.html(this.template(this.model.toJSON()));
    return this;
  }
});</pre></div><p>Of course, mixing <a id="id199" class="indexterm"/>approaches means that you won't always get the full benefits of both. The most notable issue will be that any HTML that you render via Backbone's Views or other JavaScript logic won't be accessible to a non-programming designer. If you don't have such a role in your team, then this limitation won't bother you, but if you do, you should probably try to keep as much HTML inside templates as possible.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec29"/>Other render considerations</h2></div></div></div><p>In addition to <a id="id200" class="indexterm"/>deciding whether you can rely on templates and how much you can rely on them in your render methods, there are a few other things that you need to consider when writing them. None of these choices are completely binary, but you should strive for as consistent an approach as possible. This means that the real question isn't about which one you should choose, as it is about when you will choose one over the other. Ultimately, a consistent strategy will make it such that both you and your co-workers don't have to think in order to decide which approach to use when writing new <code class="literal">render</code> methods or editing existing ones.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec01"/>Child views</h3></div></div></div><p>Very often, in <a id="id201" class="indexterm"/>Backbone, you will want to create one View for a container element, such as a <code class="literal">&lt;ul&gt;</code> element, and another View for its child elements, such as its <code class="literal">&lt;li&gt;</code> element. When creating these child Views, you can either choose to have a child View create the child elements, or you can have the parent View create them and pass a jQuery selector as the child View's <code class="literal">el</code> element, as shown here:</p><div><pre class="programlisting">var ListView1 = Backbone.View.extend({
    render: function() {
        this.$el.append(new ListItemView().render().el);
    }
});
var ListView2 = Backbone.View.extend({
    render: function() {
        this.$el.append('&lt;li&gt;');
        new ListItemView({el: this.$('li')}).render();
    }
});</pre></div><p>The primary advantage of generating the child element in the View is encapsulation. By taking this approach, you can keep all the logic related to the child element within the child View. This will make the code easier to work with, as you won't have to think about both the child and parent Views at the same time.</p><p>On the other hand, when<a id="id202" class="indexterm"/> you are using templates, it may be inconvenient to split the template into parts in order to render the overall container element. Also, rendering the child elements in the parent view provides a good separation between DOM-generating Views and purely event handling Views, which can help you to sort your logic better.</p><p>Neither approach has to be taken to the extreme. While you can have a single page View with a single template for all your content or you can have every single child View generate its DOM elements, you can also choose to have a mix of approaches in your Views. In fact, unless you want to have a single page template for a top-level render, which generates the entire DOM, you will probably want to take a combined approach, so the real question is how much do you want to rely on each technique? The more you rely on the parent View, the easier it is to see the big picture; but the more you rely on DOM generation in child Views, the easier it will be to encapsulate your logic.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Repeatable versus one-time renders</h3></div></div></div><p>Another thing that <a id="id203" class="indexterm"/>you'll want to consider is whether to design your <code class="literal">render</code> methods to be rendered once (usually when the View is first created), or whether you want to be able to call your <code class="literal">render</code> method multiple times in response to changes. The render methods that are designed to render only once are the simplest to write and the simplest to work with; when something needs to change with your View's DOM element, you simply call the View's <code class="literal">render</code> method again and the DOM gets updated.</p><p>However, this approach can also lead to performance issues, particularly if the View involved contains a great number of child Views. To avoid this, you might instead want to write <code class="literal">render</code> methods that don't blindly replace their content but instead update them in response to changes. For instance, if you have a <code class="literal">&lt;ul&gt;</code> elements where you want some of the child <code class="literal">&lt;li&gt;</code> elements to appear or disappear in response to user actions, you might want to have your <code class="literal">render</code> method check whether the <code class="literal">&lt;li&gt;</code> elements already exist first and then simply apply changes to their display style rather than rebuilding the entire <code class="literal">&lt;ul&gt;</code> from scratch every time.</p><p>Again, you'll probably want to mix the two approaches based on the type of View you are writing. If performance is a high priority for you, then you'll likely want to think carefully about how you can reuse <a id="id204" class="indexterm"/>previously-generated DOM elements in your <code class="literal">render</code> methods. On the other hand, if performance is less important, designing your <code class="literal">render</code> method for one-time DOM generation will keep its logic a lot simpler. Also, if performance problems crop up, you can always change the <code class="literal">render</code> method in question to reuse existing elements.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec03"/>Return value – this or this.$el</h3></div></div></div><p>The sample <code class="literal">render</code> method from <a id="id205" class="indexterm"/>the Backbone documentation returns <code class="literal">this</code> when it completes. This approach allows you to easily access the <code class="literal">el</code> property of the render by simply calling it on the <code class="literal">render</code> method's return value, as follows:</p><div><pre class="programlisting">var ViewThatReturnsThis = Backbone.View.extend({render: function() {
        // do the rendering
        return this;
    }
});
var childView = new ViewThatReturnsThis();
parentView.$el.append(childView.render().$el);</pre></div><p>However, you can make it even easier to access the View's <code class="literal">el</code> by returning that <code class="literal">el</code> instead of this:</p><div><pre class="programlisting">var ViewThatReturns$el = Backbone.View.extend({render: function() {
        // do the rendering
        return this.$el;
    }
});
var childView = new ViewThatReturns$el();
parentView.$el.append(childView.render());</pre></div><p>The downside of returning the <code class="literal">$el</code> from a <code class="literal">render</code> method is that you can no longer chain other View methods from the return value of the render method:</p><div><pre class="programlisting">parentView.$el.append(childView.render().nextMethod());// won't work</pre></div><p>So, what this choice<a id="id206" class="indexterm"/> really comes down to is how much you plan to post-render your Views and how much you plan to call those post-rendering methods from outside the View itself (if you call them from within the render method, their return values are irrelevant). If you're not sure, the safest bet is to follow the <code class="literal">render</code> method in Backbone's documentation and return <code class="literal">this</code>, as it offers maximum flexibility (at the cost of a slightly less-concise code).</p><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Whatever you choose, you'll likely want to keep it consistent across all your Views. If you don't, you will find yourself constantly having to look up a View's <code class="literal">render</code> method every time you want to use it.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, we explored Backbone's <code class="literal">View</code> class. You learned how to create DOM elements by instantiating a View as well as how to pass in existing elements to new Views. You also learned how to use Views to hook up event handlers on the View's <code class="literal">el</code> and how to remove/reattach these handlers to the <code class="literal">undelegate</code> and <code class="literal">delegate</code> methods. Finally, we considered how Backbone's (deliberately) empty implementation of the <code class="literal">render</code> method leaves us many different options for how to implement our own <code class="literal">render</code> method and what factors influence those choices.</p><p>In the next chapter, we'll take a look at Backbone's final class, the <code class="literal">Router</code> class. This class lets us simulate traditional web pages, only using Views instead of separate HTML files to generate those pages.</p></div></body></html>