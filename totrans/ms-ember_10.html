<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;Testing Your Application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Testing Your Application</h1></div></div></div><p class="calibre7">Testing is <a id="id472" class="calibre1"/>an important activity conducted on any software project. Tests automate bug checks and ensure <a id="id473" class="calibre1"/>that new features not only work as expected but also don't introduce undesired behavior. Ambitious Ember.js projects, therefore, need to be well<a id="id474" class="calibre1"/> tested in order to guarantee their stability and ensure satisfying user experiences. Therefore, by the end of this chapter, we should be able to:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Test object-computed properties</li><li class="listitem">Test object observers</li><li class="listitem">Test controllers</li><li class="listitem">Test views</li><li class="listitem">Test components</li><li class="listitem">Test user journeys</li></ul></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Testing Your Application">
<div class="book" title="Writing tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec105" class="calibre1"/>Writing tests</h1></div></div></div><p class="calibre7">Ember.js<a id="id475" class="calibre1"/> supports writing the following two common types of tests:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Unit</li><li class="listitem">Integration</li></ul></div><p class="calibre7">Unit tests<a id="id476" class="calibre1"/> test a<a id="id477" class="calibre1"/> specific attribute of a class (or instance) defined in an application. For example, think of scenarios such as the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A created user object has a name</li><li class="listitem">A user's full name is computed properly from their first and last name</li><li class="listitem">A book model is validated properly before being saved to the server</li><li class="listitem">An observer reacts to changes correctly</li></ul></div><p class="calibre7">Integration tests, on<a id="id478" class="calibre1"/> the other hand, test user journeys and important <a id="id479" class="calibre1"/>application workflows; for example:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Only authenticated users can access the app</li><li class="listitem">Submitting a form persists the form data to a store, and redirects the user back to a listing</li><li class="listitem">Clicking on a checkout button adds the product to a cart</li></ul></div><p class="calibre7">In this chapter, we <a id="id480" class="calibre1"/>will be testing a simple implementation of a typical e-commerce site that you <a id="id481" class="calibre1"/>can load via the <code class="email">index.html</code> file located in the chapter sample.</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Writing tests" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The site in the preceding screenshot has the following features:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Users can order meals to be delivered at specified locations</li><li class="listitem">Admins can log in to the site to add new meals</li><li class="listitem">Admins can see orders</li></ul></div><p class="calibre7">To test the <a id="id482" class="calibre1"/>admin interface, log in with the username <code class="email">admin</code> and password <code class="email">pass</code>. The application has been tested with the help of the following libraries:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Mocha.js (<a class="calibre1" href="http://visionmedia.github.io/mocha">http://visionmedia.github.io/mocha</a>): This<a id="id483" class="calibre1"/> is a testing library</li><li class="listitem">Sinon.js (<a class="calibre1" href="http://sinonjs.org/">http://sinonjs.org/</a>): This <a id="id484" class="calibre1"/>is the spies, stubs, and mocks library</li><li class="listitem">Chai.js (<a class="calibre1" href="http://chaijs.com">http://chaijs.com</a>): This is <a id="id485" class="calibre1"/>an assertion library</li><li class="listitem">The<a id="id486" class="calibre1"/> Ember mocha adapter (<a class="calibre1" href="https://github.com/teddyzeenny/ember-mocha-adapter">https://github.com/teddyzeenny/ember-mocha-adapter</a>)</li></ul></div><p class="calibre7">Loading <code class="email">test.html</code> in <a id="id487" class="calibre1"/>the browser runs the two types of tests located at <code class="email">test.integration.js</code> and <code class="email">test.unit.js</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="Writing tests" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">If we examine the test loader file content, we see that the testing framework required the following element to be created:</p><div class="informalexample"><pre class="programlisting">&lt;div id='mocha'&gt;&lt;/div&gt; </pre></div><p class="calibre7">This is the element in which the test report was rendered. We also needed to create our application's root element in the same way:</p><div class="informalexample"><pre class="programlisting">&lt;div id='ember'&gt;&lt;/div&gt; </pre></div><p class="calibre7">Near the bottom of the file, the application scripts were loaded in order, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="lib/jquery.js"&gt;&lt;/script&gt; 
&lt;script src="lib/bootstrap.min.js"&gt;&lt;/script&gt; 
&lt;script src="lib/handlebars.js"&gt;&lt;/script&gt; 
&lt;script src="lib/ember.js"&gt;&lt;/script&gt; 
&lt;script src="lib/ember-data.js"&gt;&lt;/script&gt; 
&lt;script src="app.js"&gt;&lt;/script&gt; 
&lt;script src="fixtures.js"&gt;&lt;/script&gt; </pre></div><p class="calibre7">Finally, the <a id="id488" class="calibre1"/>testing libraries were loaded:</p><div class="informalexample"><pre class="programlisting">&lt;script src='lib/mocha.js'&gt;&lt;/script&gt; 
&lt;script src='lib/ember-mocha-adapter.js'&gt;&lt;/script&gt; 
&lt;script src='lib/chai.js'&gt;&lt;/script&gt; 
&lt;script src='lib/sinon.js'&gt;&lt;/script&gt; </pre></div><p class="calibre7">Ember.js comes with test utilities that help write these tests. These test helpers are meant to be used with any testing library of your choice. In our case, we used Mocha.js, a popular, easy-to-use library. The first task we needed to do was set up the test environment. This was done by first defining the root element of the Ember.js application. This ensured that the Ember.js application was only executed within the element and didn't affect other parts of the testing environment:</p><div class="informalexample"><pre class="programlisting">App.rootElement = '#ember';</pre></div><p class="calibre7">We then needed to run the <code class="email">setupForTesting</code> method of the application. This deferred the readiness of the application for later execution during testing. It also prevented the tests from manipulating the window's location:</p><div class="informalexample"><pre class="programlisting">App.setupForTesting();</pre></div><p class="calibre7">We also needed to call another method, <code class="email">injectTestHelpers</code>, which injected Ember.js test helpers into the test environment:</p><div class="informalexample"><pre class="programlisting">App.injectTestHelpers();</pre></div><p class="calibre7">We finally loaded and executed the tests included in the two files, as follows:</p><div class="informalexample"><pre class="programlisting">Em.$(function() { 
  mocha.run(); 
});

&lt;script src='test.unit.js'&gt;&lt;/script&gt; 
&lt;script src='test.integration.js'&gt;&lt;/script&gt;</pre></div><p class="calibre7">You will notice that, for each of the tests, we defined <code class="email">beforeEach</code> and <code class="email">afterEach</code> hooks that got called before and after the test was executed, respectively:</p><div class="informalexample"><pre class="programlisting"> beforeEach(App.beforeEach); 
 afterEach(App.afterEach);</pre></div><p class="calibre7">For example, the default pre-test run hook used the <code class="email">visit</code> helper to transition the app into the <code class="email">index</code> route, as follows:</p><div class="informalexample"><pre class="programlisting">App.beforeEach = function() { 
  visit('/'); 
}</pre></div><p class="calibre7">The post-test hook, on the other hand, resets the application state after each test by destroying such instances as the Ember-data store:</p><div class="informalexample"><pre class="programlisting">App.afterEach = function() {
  App.reset();
}</pre></div><p class="calibre7">Ember.js comes <a id="id489" class="calibre1"/>with a number of test helpers that we will be using to help us in writing tests.</p></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Testing Your Application">
<div class="book" title="Writing tests">
<div class="book" title="Asynchronous test helpers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec45" class="calibre1"/>Asynchronous test helpers</h2></div></div></div><p class="calibre7">These <a id="id490" class="calibre1"/>helpers are<a id="id491" class="calibre1"/> used to perform asynchronous operations. This means that, if used, the next bunch of tests needs then to be wrapped in a run loop function. They include the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">visit(url)</code>: This performs<a id="id492" class="calibre1"/> an asynchronous application transition into the provided URL route.</li><li class="listitem"><code class="email">fillIn(selector, text)</code>: This<a id="id493" class="calibre1"/> is used to asynchronously set the value of an input that matches the given selector with the given text.</li><li class="listitem"><code class="email">click(selector)</code>: This is<a id="id494" class="calibre1"/> used to trigger a click event on an element that matches the given selector. This is good for the <code class="email">triggerEvent(selector, "click")</code> helper.</li><li class="listitem"><code class="email">keyEvent(selector, type, keyCode)</code>: This <a id="id495" class="calibre1"/>is used to trigger a key event on the given selector.</li><li class="listitem"><code class="email">triggerEvent(selector, type, options)</code>: This <a id="id496" class="calibre1"/>is used to trigger other DOM events on the given selector.</li></ul></div></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Testing Your Application">
<div class="book" title="Writing tests">
<div class="book" title="Synchronous test helpers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec46" class="calibre1"/>Synchronous test helpers</h2></div></div></div><p class="calibre7">These<a id="id497" class="calibre1"/> helpers<a id="id498" class="calibre1"/> are used to perform synchronous operations. They include the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">find(selector, context)</code>: This <a id="id499" class="calibre1"/>helper is used to perform an element selection within the given optional context</li><li class="listitem"><code class="email">currentPath()</code>: This <a id="id500" class="calibre1"/>is used to get the current application's route path</li><li class="listitem"><code class="email">currentRouteName()</code>: This<a id="id501" class="calibre1"/> is used to get the name of the current application route</li><li class="listitem"><code class="email">currentURL()</code>: This<a id="id502" class="calibre1"/> is used to get the URL of the current route</li></ul></div></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Testing Your Application">
<div class="book" title="Writing tests">
<div class="book" title="Wait helpers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec47" class="calibre1"/>Wait helpers</h2></div></div></div><p class="calibre7">There is <a id="id503" class="calibre1"/>currently <a id="id504" class="calibre1"/>only one helper of this type: <code class="email">andThen</code>. It is<a id="id505" class="calibre1"/> used to run a block of test operations after the previous asynchronous operations have been completed.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Writing unit tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec106" class="calibre1"/>Writing unit tests</h1></div></div></div><p class="calibre7">Unit testing<a id="id506" class="calibre1"/> involves testing object-computed properties, observers, and method calls.</p></div>

<div class="book" title="Writing unit tests">
<div class="book" title="Testing computed properties"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec48" class="calibre1"/>Testing computed properties</h2></div></div></div><p class="calibre7">Let's start <a id="id507" class="calibre1"/>by looking at the first tested object-computed <a id="id508" class="calibre1"/>property in the chapter sample, the <code class="email">total</code> property of <code class="email">App.CartItem</code>, that is applied from <code class="email">App.TotalMixin</code>:</p><div class="informalexample"><pre class="programlisting">App.CartItem = Em.Object.extend(App.TotalMixin, { 
  product: null, 
  quantity: null, 
  price: null 
});</pre></div><p class="calibre7">When a user clicks on the order button of a meal, we expect the cart to be filled by the new item. We also expect the item's <code class="email">total</code> property to be incremented, which is ascertained as follows:</p><div class="informalexample"><pre class="programlisting">describe('App.CartItem', function() {

  describe('total', function(){

    beforeEach(App.beforeEach);

    afterEach(App.afterEach);

    it('should be computed from .price and .quantity', function() {

      andThen(function(){
        var order = App.CartItem.create();
        order.get('total').should.equal(0);
        order.set('price', 10);
        order.get('total').should.equal(0);
        order.set('quantity', 1);
        order.get('total').should.equal(10);
        order.set('quantity', 2);
        order.get('total').should.equal(20);
        order.set('price', 20);
        order.get('total').should.equal(40);

      });

    });

  });

  

});</pre></div><p class="calibre7">First, we<a id="id509" class="calibre1"/> created an order and verified that its total defaulted <a id="id510" class="calibre1"/>to zero. We then updated its quantity and price and ascertained that the total was computed properly in each case. We also did the same for the <code class="email">App.Order</code> model, this time creating the order from the store:</p><div class="informalexample"><pre class="programlisting">var store = App.__container__.lookup('store:main');
var order = store.createRecord('order', {});</pre></div><p class="calibre7">Note how the store instance was referenced from the main application container.</p></div></div>

<div class="book" title="Writing unit tests">
<div class="book" title="Testing method calls"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec49" class="calibre1"/>Testing method calls</h2></div></div></div><p class="calibre7">The app<a id="id511" class="calibre1"/> contains a mixin <code class="email">App.OnhasMixin</code> that defines<a id="id512" class="calibre1"/> a function <code class="email">onhas</code> that invokes a given callback if the property being bound is defined or as soon as it gets set. This is comparable to a situation where you can either buy a new computer now if you have the money or wait till you get a pay check. We started by testing the first case:</p><div class="informalexample"><pre class="programlisting">var object = Em.Object.createWithMixins(App.OnhasMixin, {
  id: 1
});
object.onhas('id', done);</pre></div><p class="calibre7">In this case, the function fired as the object already contained the <code class="email">id</code> property. We simply needed to pass the callback <code class="email">done</code> provided by the Mocha test runner. The second test case asserts that the callback is called only when the bound property gets set as follows:</p><div class="informalexample"><pre class="programlisting">var object = Em.Object.createWithMixins(App.OnhasMixin, {
  id: null
});
object.onhas('id', andThen.bind(null, done.bind(null, null)));
object.set('id', 1);</pre></div></div></div>

<div class="book" title="Writing unit tests">
<div class="book" title="Testing observers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec50" class="calibre1"/>Testing observers</h2></div></div></div><p class="calibre7">One <a id="id513" class="calibre1"/>of the <a id="id514" class="calibre1"/>observers, <code class="email">App.UserController#storeUser</code>, stores the username of the current logged-in user to the local storage:</p><div class="informalexample"><pre class="programlisting">storeUser: function(){
  var username = this.get('content.username');
  window.localStorage.setItem('user', username);
}.observes('content.username')</pre></div><p class="calibre7">To test the observer, we first cleared any stored user in the local storage in the pre-test hook:</p><div class="informalexample"><pre class="programlisting">window.localStorage.setItem('user', null);</pre></div><p class="calibre7">We then created the user controller, set the user, and asserted that the user is actually stored in the browser's local store:</p><div class="informalexample"><pre class="programlisting">var controller = App.UserController.create({
  content: {}
});

// spy
var spy = sinon.spy(controller, 'storeUser');

controller.set('username', 'username-1');  // 1
window.localStorage.getItem('user').should.equal('username-1');</pre></div><p class="calibre7">We also set<a id="id515" class="calibre1"/> up a spy using <a id="id516" class="calibre1"/>
<span class="strong"><strong class="calibre8">Sinon.js</strong></span> to record the observer invocations:</p><div class="informalexample"><pre class="programlisting">spy.callCount.should.to.equal(2);
spy.restore();</pre></div><p class="calibre7">The spy, as<a id="id517" class="calibre1"/> shown in the preceding code, enabled us to verify that the observer subscribed properly to the property changes.</p></div></div>
<div class="book" title="Writing integration tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec107" class="calibre1"/>Writing integration tests</h1></div></div></div><p class="calibre7">We <a id="id518" class="calibre1"/>now already know that integration tests test the import workflows and user journeys in an application. The Ember.js framework is well tested; reviewing<a id="id519" class="calibre1"/> these tests can help a great deal in learning how to write tests for your application. Many features such as bindings and observers are already tested, so you will be writing more integration tests than unit tests. The integration tests in the chapter sample cover virtually all user interactions in the application. We will first go through all consumer-related cases, the first of which ascertains that users can see the available meals on the first page:</p><div class="informalexample"><pre class="programlisting">find('.products li').length.should.equal(4);</pre></div><p class="calibre7">This example shows the use of the synchronous <code class="email">find</code> helper, which returned the elements that listed the meals. We also checked whether the meal attributes were being displayed correctly to the user:</p><div class="informalexample"><pre class="programlisting">// name label

find('.products li:nth-of-type(1) .product-name')
  .text()
  .trim()
  .should
  .equal(product.get('name'));

// price label

find('.products li:nth-of-type(1) .product-price')
  .text()
  .trim()
  .should
  .equal('$'+product.get('price'));

// order button

find('.products li:nth-of-type(1) .product-add-to-cart')
  .text()
  .trim()
  .should
  .equal('order now');</pre></div><p class="calibre7">Our next check <a id="id520" class="calibre1"/>verified that the cart link on the navigation bar indicated that the cart was empty:</p><div class="informalexample"><pre class="programlisting">find('.nav-cart').text().should.equal('cart 0');</pre></div><p class="calibre7">Next to the cart link, we also ascertained that users were able to see the login link:</p><div class="informalexample"><pre class="programlisting">find('.nav-login').text().should.equal('login');</pre></div><p class="calibre7">Finally, we checked whether the customer was also able to see the site branding:</p><div class="informalexample"><pre class="programlisting">find('.brand').text().should.equal('LocalLunch.io');</pre></div><p class="calibre7">The next set of test cases verified that users would be able to add products to the cart. Before each test case, we triggered a click event on the checkout button of the first meal to add the meal to the cart:</p><div class="informalexample"><pre class="programlisting">click('.products li:nth-of-type(1) .product-add-to-cart');</pre></div><p class="calibre7">The first test checked whether the desired meal was actually added to the cart:</p><div class="informalexample"><pre class="programlisting">var store = App.__container__.lookup('store:main');
var controller = App.__container__.lookup('controller:cart');

store
  .find('product', 1)
  .then(function(product){

    controller.get('length').should.equal(1);

    var item = controller.objectAt(0);
    item.get('product.id').should.equal(product.get('id'));
    item.get('price').should.equal(product.get('price'));
    item.get('quantity').should.equal(1);

  });</pre></div><p class="calibre7">We first queried this product from the store and then asserted that it was indeed added to the cart controller. We also asserted that the cart item contained the expected attributes: <code class="email">product</code>, <code class="email">price</code>, and <code class="email">quantity</code>.</p><p class="calibre7">By then, we expected the cart link counter indicator to be incremented:</p><div class="informalexample"><pre class="programlisting">find('.nav-cart').text().should.equal('cart 1');</pre></div><p class="calibre7">We also expected the user to have been transitioned to the cart page:</p><div class="informalexample"><pre class="programlisting">currentPath().should.equal('cart');</pre></div><p class="calibre7">The proceeding tests tested the cart page to which our user has transitioned. First, we tested that viewing an empty cart page presents an appropriate message:</p><div class="informalexample"><pre class="programlisting">find('.message').text().should.equal('Cart is empty.');</pre></div><p class="calibre7">We then tested the page for when the cart was filled, by first adding two items to the cart in the pre-test hook:</p><div class="informalexample"><pre class="programlisting">var controller = App.__container__.lookup('controller:cart');
var store = App.__container__.lookup('store:main');

store
  .find('product', 1)
  .then(function(product){
    controller.addItem(product);
    controller.addItem(product);
  });</pre></div><p class="calibre7">We used <a id="id521" class="calibre1"/>the <code class="email">controller.addItem</code> method to add the two products to the cart. Just as in the preceding test case, we asserted that the cart link indicated that two cart items had been added to the cart, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">find('.nav-cart').text().should.equal('cart 2');</pre></div><p class="calibre7">The cart page contains a table that shows the cart details. It also contains additional information to the left; one of these is the cart total:</p><div class="informalexample"><pre class="programlisting">var store = App.__container__.lookup('store:main');
store
  .find('product', 1)
  .then(function(product){

    var total = product.get('price') * 2;
    find('label.checkout')
    .text()
    .trim()
    .should
    .equal(total.toString());

  });</pre></div><p class="calibre7">The <code class="email">find</code> helper returned the label that displayed the order total. We got its <code class="email">textContent</code> and asserted that it was equal to the order total. We then proceeded to test the cart table by first ensuring that the relevant table header cells were displayed in the right order:</p><div class="informalexample"><pre class="programlisting">[
  'Product',
  'Price',
  'Quantity'
].forEach(function(cell, i){
  find(find('thead td')[i]).text().should.equal(cell);
});</pre></div><p class="calibre7">Then we tested the table body:</p><div class="informalexample"><pre class="programlisting">find(find('tbody td'[0])
  .text()
  .should
  .equal(product.get('name'));
find(find('tbody td')[1])
  .text()
  .should
  .equal(product.get('price').toString());
find(find('tbody input'))
  .val()
  .should
  .equal('2');</pre></div><p class="calibre7">The preceding <a id="id522" class="calibre1"/>code tests the first row of the table by asserting that it displays the expected values. For the third cell, we test that the input contains the expected product quantity. The user is free to adjust the product amount using this input. We test this in the next test case. First, we update the input to a new value, as follows:</p><div class="informalexample"><pre class="programlisting">fillIn(find('tbody input'), 4);</pre></div><p class="calibre7">We then allow any triggered operations to finish before we assert that the quantity in the cart was updated:</p><div class="informalexample"><pre class="programlisting">andThen(function(){

  find('.nav-cart')
  .text()
  .should
  .equal('cart 4');

});</pre></div><p class="calibre7">This assertion shows how to use the <code class="email">fillIn</code> helper to asynchronously update the value of an input. We also asserted that the cart total was updated as a result:</p><div class="informalexample"><pre class="programlisting">  var total = product.get('price') * 4;
  find('label.checkout')
  .text()
  .trim()
  .should
  .equal(total.toString());</pre></div><p class="calibre7">Once the user is satisfied with the order details, they should be able to go to the payment page by clicking on the pay button:</p><div class="informalexample"><pre class="programlisting">click('.pay');
andThen(function(){
  currentPath().should.equal('checkout');
});</pre></div><p class="calibre7">Once the user <a id="id523" class="calibre1"/>is on the checkout page, if their cart is empty an appropriate message will be shown:</p><div class="informalexample"><pre class="programlisting">find('.message').text().should.equal('Cart is empty.');</pre></div><p class="calibre7">If the cart is not empty, the user sees a table that summarizes the order:</p><div class="informalexample"><pre class="programlisting">[
  'Name',
  'Quantity'
].forEach(function(cell, i){
  find(find('thead td')[i]).text().should.equal(cell);
});</pre></div><p class="calibre7">The table body lists the order's product name alongside its quantity:</p><div class="informalexample"><pre class="programlisting">[
  product.get('name'),
  '2'
].forEach(function(cell, i){
  find(find('tbody td')[i]).text().should.equal(cell);
});</pre></div><p class="calibre7">The table also displays the order total:</p><div class="informalexample"><pre class="programlisting">var total = product.get('price') * 2;
find('.checkout').text().trim().should.equal(total.toString());</pre></div><p class="calibre7">The table tested sits on the left-hand side of the page. The main page contains a form in which the user enters their payment information before submission. We use the <code class="email">triggerEvent</code> helper to invoke this event:</p><div class="informalexample"><pre class="programlisting">triggerEvent('.form-pay', 'submit');</pre></div><p class="calibre7">A success message is displayed to the user, notifying them that the order will be delivered to them shortly:</p><div class="informalexample"><pre class="programlisting">find('.message')
  .text()
  .should
  .equal('Success! Your order will arrive in 20 minutes. Thank you.');</pre></div><p class="calibre7">This tests the payment action defined in the checkout controller:</p><div class="informalexample"><pre class="programlisting">pay: function(model){
  var self = this;
  var controller = self.get('controllers.cart');
  controller.forEach(function(item){
    self.store.createRecord('order', item).save();
  });
  model.set('success', true);
  controller.set('content', []);
}</pre></div><p class="calibre7">As shown, the<a id="id524" class="calibre1"/> cart items are converted to actual orders that the shop admin can see:</p><div class="informalexample"><pre class="programlisting">store
  .find('order')
  .then(function(orders){

    orders.get('length').should.equal(1);

    var order = orders.objectAt(0);
    order.get('product.id').should.equal(product.get('id'));
    order.get('quantity').should.equal(2);
    order.get('price').should.equal(product.get('price'));

  });</pre></div><p class="calibre7">As a recap, you can see the preceding test cases tested the user's journey from the index page to the checkout page through the cart page. This is what constitutes integration tests.</p><p class="calibre7">The next case will test the admin's user journey. Admins can get access to the admin dashboard by logging into the app on the login page with the right credentials:</p><div class="informalexample"><pre class="programlisting">fillIn('.input-username', user.get('username'));
fillIn('.input-password', user.get('password'));
triggerEvent('.form-login', 'submit');

andThen(function(){
  currentPath().should.equal('index');
});</pre></div><p class="calibre7">A successful login redirects the user to the index route. We also tested the case when a user tries to access the admin dashboard with the wrong credentials:</p><div class="informalexample"><pre class="programlisting">fillIn('.input-username', 'username');
fillIn('.input-password', 'password');
triggerEvent('.form-login', 'submit');

andThen(function(){
  currentPath().should.equal('login');
});</pre></div><p class="calibre7">We expect the user to remain in the login route on login failure.</p><p class="calibre7">Once logged in, the admin should be able to add meals as well as edit or remove existing ones. These are covered in the next tests where we first log in as an admin into the site via the login helper defined at the bottom of the file:</p><div class="informalexample"><pre class="programlisting">fillIn('.input-username', username);
fillIn('.input-password', 'pass');
triggerEvent('.form-login', 'submit');

andThen(function(){
  if (done){
    done();
  } else {
    visit('/');
  }
});</pre></div><p class="calibre7">The application<a id="id525" class="calibre1"/> contains a hidden form whose file input prompts the user to select a meal image when the list-product component is clicked:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/x-handlebars" id="components/list-product"&gt;
  add
&lt;/script&gt;
  
&lt;script type="text/x-handlebars"&gt;
  &lt;form class="list-product-form"&gt;
  &lt;input
    class='list-product-form-input'
    type="file"
    style="top: -1000px; position: absolute"
    aria-hidden="true"&gt;
  &lt;/form&gt;
&lt;/script&gt;</pre></div><p class="calibre7">The corresponding <code class="email">App.ListProductComponent</code> defines a click event handler that gets invoked when the component is clicked:</p><div class="informalexample"><pre class="programlisting">var self = this;

// submit

var input = Em.$('.list-product-form input');
input.one('change', upload);

// show file chooser

input.click();

// upload

function upload(event){

  var file = input[0].files[0];
  var reader = new FileReader;
  reader.onload = post.bind(this, reader);
  reader.readAsDataURL(file);

};

// post

function post(reader){
  self.sendAction('action', reader.result);
}</pre></div><p class="calibre7">Once the user<a id="id526" class="calibre1"/> selects a file, the preceding <code class="email">post</code> method is called with a <code class="email">FileReader</code> instance argument, from which we get the URL representation of the selected image for storage. You would obviously upload this file to a storage service such as S3 or Google Cloud Storage in an actual application, instead. We finally create the product, which gets automatically listed in the page. Since it's not possible to update the value of a file input, our next test spec partially confirms this by manually adding a product to the cart:</p><div class="informalexample"><pre class="programlisting">Em.run(function(){

  var controller = App.__container__.lookup('controller:index');
  controller.send('createProduct', 'data:');

  Em.run.next(function(){     
    find('.products li').length.should.equal(5);
    done();
  });

});</pre></div><p class="calibre7">Here, we triggered the <code class="email">createProduct</code> action on the index controller, which adds a product to the cart. Note that this is the same action that is called by the <code class="email">post</code> function. In the next run loop, we asserted that a new product was added to the listing. This product's name and price are undefined, so the next test case checks whether the admin can actually edit these products:</p><div class="informalexample"><pre class="programlisting">var name = 'test';
var price = 1000;

fillIn('.products li:nth-of-type(1) .product-name', name);
fillIn('.products li:nth-of-type(1) .product-price', price);

andThen(function(){
  product.get('name').should.equal(name);
  product.get('price').should.equal(price.toString());
});</pre></div><p class="calibre7">The preceding<a id="id527" class="calibre1"/> test case showed that the admin is able to update the product's name and price via the provided corresponding inputs. In an actual app, you would probably add a <code class="email">save</code> button that persisted the changes to the backend.</p><p class="calibre7">In the navigation bar, there's an <code class="email">orders</code> link that the user can click on to transition to the orders page:</p><div class="informalexample"><pre class="programlisting">{{#link-to "orders" class='nav-orders'}}orders{{/link-to}}</pre></div><p class="calibre7">The next test ascertains that clicking on the link transitions the user to the orders page:</p><div class="informalexample"><pre class="programlisting">click('.nav-orders');

andThen(function(){
  find('.message')
  .text()
  .should
  .equal('No new orders have been made.');
});</pre></div><p class="calibre7">Lastly, the admin is presented with a message if no orders have been made yet. However, if orders have been made, the admin should be able to see a table that lists them:</p><div class="informalexample"><pre class="programlisting">visit('/orders');

[
  'ID',
  'Product',
  'Price',
  'Quantity',
  'Total'
].forEach(function(cell, i){
  find(find('thead td')[i]).text().should.equal(cell);
});

[
  product.get('name'),
  product.get('price').toString(),
  order.get('quantity').toString(),
  order.get('total').toString()
].forEach(function(cell, i){
  find(find('tbody td')[++i]).text().trim().should.equal(cell);
});</pre></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec108" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">We just learned the various test techniques you can use to ensure the stability of your application. Since you will mostly be writing integration tests, the best approach would be to break your app into clear user journeys. Then, test any expected interactions as well as transitions. This would obviously be done when developing new features. When testing against external resources, you can use libraries such as Sinon to stub these services or extend the test timeout, shown as follows:</p><div class="informalexample"><pre class="programlisting">describe('visit /orders', function(){
  this.timeout(5000);
});</pre></div><p class="calibre7">In the next chapter, we will learn how to build Ember.js applications that are backed by external real-time data and service resources. We will specifically learn how to use the popular <span class="strong"><strong class="calibre8">socket.io</strong></span> library within Ember.js applications.</p></div></body></html>