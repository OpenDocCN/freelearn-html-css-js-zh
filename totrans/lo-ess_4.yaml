- en: Chapter 4. Transformations Using Map/Reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding three chapters alluded to transformation possibilities with Lo-Dash.
    Whether you're working with collections, objects, or functions, a common pattern
    with Lo-Dash functions is transformation of the input by generating a new, albeit
    slightly altered, version. The idea of transforming values is central to applicative
    programming, where much of the code you write is a series of transformations.
    Beginning with this chapter, we're going to shift gears and look at transformations
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Particularly, we'll be looking at all the interesting things we can do with
    Lo-Dash and the map/reduce programming model. We'll start off with the basics,
    getting our feet wet with some basic mappings and basic reductions. As we progress
    through the chapter, we'll start introducing more advanced techniques to think
    about in terms of map/reduce with Lo-Dash.
  prefs: []
  type: TYPE_NORMAL
- en: The goal, once you've reached the end of this chapter, is to have a solid understanding
    of the Lo-Dash functions available that aid in mapping and reducing collections.
    Additionally, you'll start to notice how disparate Lo-Dash functions work together
    in the map/reduce domain. Ready?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Plucking values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map/reduce patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plucking values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen how values can be plucked from collections using the `pluck()`
    function in [Chapter 1](ch01.html "Chapter 1. Working with Arrays and Collections"),
    *Working with Arrays and Collections*. Consider that your informal introduction
    to mapping, because that''s essentially what it''s doing. It''s taking an input
    collection and mapping it to a new collection, plucking only the properties we''re
    interested in. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is about as simple a mapping operation as you''ll find. In fact, you can
    do the same thing with `map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you'd expect, the output here is exactly the same as it would be with `pluck()`.
    In fact, `pluck()` is actually using the `map()` function under the hood. The
    callback passed to `map()` is constructed using `property()`, which just returns
    the specified property value. The `map()` function falls back to this plucking
    behavior when passed a string instead of a function.
  prefs: []
  type: TYPE_NORMAL
- en: With that brief introduction to the nature of mapping, let's dig a little deeper
    and see what's possible in mapping collections.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll explore mapping collections. Mapping one collection to
    another ranges from composing simple—as we saw in the preceding section—to sophisticated
    callbacks. Callbacks that map each item in the collection can include or exclude
    properties and can calculate new values. We'll also address the issue of filtering
    collections and how this can be done in conjunction with mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Including and excluding properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When applied to an object, the `pick()` function generates a new object containing
    only the specified properties. The opposite function, `omit()`, generates an object
    with every property except those specified. Since these functions work fine for
    individual object instances, why not use them with a collection? You can use both
    of these functions to shed properties from collections by mapping them to new
    ones, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating a new collection using the `map()` function. The callback
    function supplied to `map()` is applied to each item in the collection. The `item`
    argument is the original item from the collection. The callback is expected to
    return the mapped version of that item and this version could be anything, including
    the original item itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when manipulating the original item in `map()` callbacks. If the
    item is an object and it's referenced elsewhere in your application, it could
    have unintended consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re returning a new object as the mapped item in the preceding code. This
    is done using the `pick()` function. We only care about the `first` and the `last`
    properties. Our newly mapped collection looks identical to the original, except
    that no item has an `age` property. This newly-mapped collection is seen in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code follows the exact same approach as the previous `pick()` code. The
    only difference is that we're excluding the `first` property from the newly-created
    collection. You'll also notice that we're passing a string containing a single
    property name instead of an array of property names.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to passing strings or arrays as the argument to `pick()` or `omit()`,
    we can pass in a function callback. This is suitable when it''s not very clear
    which objects in a collection should have which properties. Using a callback like
    this inside a `map()` callback lets us perform detailed comparisons and transformations
    on collections with very little code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The new collection generated by this code excludes the `age` property for items
    where the `age` value is less than `40`. The callback supplied to `omit()` is
    applied to each key-value pair in the object. This code is a good illustration
    of the conciseness achievable with Lo-Dash. There's a lot of iterative code running
    here, and there is no `for` or `while` statement in sight.
  prefs: []
  type: TYPE_NORMAL
- en: Performing calculations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time now to turn our attention to performing calculations in our `map()`
    callbacks. This entails looking at the item and, based on its current state, computing
    a new value that will be ultimately mapped to the new collection. This could mean
    extending the original item''s properties or replacing one with a newly computed
    value. Whichever the case, it''s a lot easier to map these computations than to
    write your own logic that applies these functions to every item in your collection.
    This is explained using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're mapping each item in the original collection to an extended version
    of it. Particularly, we're computing two new values for each item—`experience`
    and `specialty`. The `experience` property is simply the sum of the `jqueryYears`
    and `cssYears` properties. The `specialty` property is computed based on the larger
    value of the `jqueryYears` and `cssYears` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, I mentioned the need to be careful when modifying items in `map()`
    callbacks. In general, it''s a bad idea. It''s helpful to try and remember that
    `map()` is used to generate new collections, not to modify existing collections.
    Here''s an illustration of the horrific consequences of not being careful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The destructive nature of this callback is not obvious at all and next to impossible
    for programmers to track down and diagnose. It is essentially resetting the `supervisor`
    property for each item. If these items are used anywhere else in the application,
    the `supervisor` property value will be clobbered whenever this map job is executed.
    If you need to reset values like this, ensure that the change is mapped to the
    new value and not made to the original.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapping also works with primitive values as the item. Often, we''ll have an
    array of primitive values that we''d like transformed into an alternative representation.
    For example, let''s say you have an array of sizes, expressed in bytes. You can
    map those arrays to a new collection with those sizes expressed as human-readable
    values, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `bytes()` function takes a numerical argument, which is the number of bytes
    to be formatted. This is the starting unit. We just keep incrementing the `target`
    unit until we have something that is less than `1024`. For example, the last item
    in our collection maps to `'114.6MB'`. The `bytes()` function can be passed directly
    to `map()` since it's expecting values in our collection as they are.
  prefs: []
  type: TYPE_NORMAL
- en: Calling functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We don''t always have to write our own callback functions for `map()`. Wherever
    it makes sense, we''re free to leverage Lo-Dash functions to map our collection
    items. For example, let''s say we have a collection and we''d like to know the
    size of each item. There''s a `size()` Lo-Dash function we can use as our `map()`
    callback, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has the added benefit that the `size()` function returns consistent
    results, no matter what kind of argument is passed to it. In fact, any function
    that takes a single argument and returns a new value based on that argument is
    a valid candidate for a `map()` callback. For instance, we could also map the
    minimum and maximum value of each item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to map each item of our collection to a sorted version? Since
    we do not sort the collection itself, we don''t care about the item positions
    within the collection, but the items themselves, if they''re arrays, for instance.
    Let''s see what happens with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `compose()` function to construct a `map()` callback. The
    first function returns the sorted version of the item by passing it to `sortBy()`.
    The `first()` item of this sorted list is then returned as the mapped item. The
    end result is a new collection containing the alphabetically-first item from each
    array in our collection, with three lines of code. Not bad.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering and mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filtering and mapping are two closely related collection operations. Filtering
    extracts only those collection items that are of particular interest. Mapping
    transforms collections to produce new collections. But what if we only want to
    map a certain subset of our collection? Then it would make sense to chain together
    the filtering and mapping operations, right? Here''s an example of what that might
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This map is executed using `compose()` to build a function that is called right
    away, with our `collection` as the argument. The function is composed of two partials.
    We're using `partialRight()` on both arguments because we want the collection
    supplied as the leftmost argument in both cases. The first partial function is
    `filter()`. We're partially applying the `enabled` argument. So this function
    will filter our collection before it's passed to `map()`. The result of filtering
    the collection is passed to `map()`, which has the `name` argument partially applied.
    The end result is a collection with enabled `name` strings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The important thing to note about the preceding code is that the filtering operation
    takes place *before* the `map()` function is run. We could have stored the filtered
    collection in an intermediate variable instead of streamlining with `compose()`.
    Regardless of flavor, it's important that the items in your mapped collection
    correspond to the items in the source collection. It's conceivable to filter out
    the items in the `map()` callback by not returning anything, but this is ill-advised
    as it doesn't map well, both figuratively and literally.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section focused on collections and how to map them. But wait, objects
    are collections too, right? That is indeed correct, but it's worth differentiating
    between arrays and plain objects. The main reason is that there are implications
    with ordering and keys when performing map/reduce. At the end of the day, arrays
    and objects serve different use cases with map/reduce, and this chapter tries
    to acknowledge these differences.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll start looking at some techniques Lo-Dash programmers employ when working
    with objects and mapping them to collections. There are a number of factors to
    consider, such as the keys within an object, and calling methods on objects. We'll
    take a look at the relationship between key-value pairs and how they can be used
    in a mapping context.
  prefs: []
  type: TYPE_NORMAL
- en: Working with keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the keys of a given object in interesting ways to map the object
    to a new collection. For example, we can use the `keys()` function to extract
    the keys of an object and map them to values other than the property value, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code builds an array of property values from `object`. It does
    this using `map()`, which is actually mapping the `keys()` array of `object`.
    These keys are sorted using `sortBy()`. So `Packt` is the first element of the
    resulting array because `employer` is alphabetically-first in the `object` keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it''s desirable to perform lookups in other objects and map those
    values to a target object. For example, not all APIs return everything you need
    for a given page, packaged in a neat little object. You have to do joins and build
    the data you need. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This example builds two objects, `users` and `preferences`. In the case of each
    object, the keys are user identifiers that we're generating with `uniqueId()`.
    The `user` objects just have some dummy attribute in them, while the `preferences`
    objects have an `emailme` attribute, set to a random Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's say we need quick access to this preference for all users in the `users`
    object. As you can see, it's straightforward to implement using `map()` on the
    `users` object. The callback function returns a new object with the user ID. We
    extend this object with the preference for that particular user by looking them
    up by `key`.
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Object properties aren''t limited to storing primitive strings and numbers.
    Properties can store functions as their values, or methods, as they''re commonly
    referred. However, depending on the context where you''re using your object, methods
    aren''t always callable, especially if you have little or no control over the
    context where your objects are used. One technique that''s helpful in situations
    such as these is mapping the result of calling these methods and using this result
    in the context in question. Let''s see how this can be done with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an object with both primitive property values and methods that
    use these properties. Now we'd like to map the results of calling those methods
    and we will experiment with two different approaches. The first approach uses
    the `isFunction()` function to determine whether the property value is callable
    or not. If it is, we call it and return that value. The second approach is a little
    easier to implement and achieves the same outcome. The `result()` function is
    applied to the object using the current key. This tests whether we're working
    with a function or not, so our code doesn't have to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the first approach to mapping method invocations, you might have noticed
    that we're calling the method using `object[key]()` instead of `value()`. The
    former retains the context as the object variable, but the latter loses the context,
    since it is invoked as a plain function without any object. So when you're writing
    mapping callbacks that call methods and not getting the expected results, make
    sure the method's context is intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps you have an object but you''re not sure which properties are methods.
    You can use `functions()` to figure this out and then map the results of calling
    each method to an array, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `object` variable has two methods, `first()` and `last()`. Assuming we didn't
    know about these methods, we can find them using `functions()`. Here, we're building
    a `methods` array using `map()`. The input is an array containing the names of
    all the methods of the given object. The value we're returning is interesting.
    It's a single-value array; you'll see why in a moment. The value of this array
    is a function built by passing the object and the name of the method to `bindKey()`.
    This function, when invoked, will always use `object` as its context.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we use `invoke()` to invoke each method in our `methods` array, building
    a new result array. Recall that our `map()` callback returned an array. This was
    a simple hack to make `invoke()` work, since it's a convenient way to call methods.
    It generally expects a key as the second argument, but a numerical index works
    just as well, since they're both looked up the same.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping key-value pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just because you''re working with an object doesn''t mean it''s ideal, or even
    necessary. That''s what `map()` is for—mapping what you''re given to what you
    need. For instance, the property values are sometimes all that matter for what
    you''re doing, and you can dispense with the keys entirely. For that, we have
    the `values()` function and we feed the values to `map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: All we want from the `object` variable here is a list of property values, which
    are strings, so that we can format them. In other words, the fact that the keys
    are `first`, `last`, and `age` is irrelevant. So first, we call `values()` to
    build an array of values. Next, we pass that array to `filter()`, removing anything
    that's not a string. We then pass the output of this to `map()`, where we're able
    to map the string using `<strong/>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite might also be true—the value is completely meaningless without
    its key. If that''s the case, it may be fitting to map key-value pairs to a new
    collection, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We're passing the result of running our object through the `pairs()` function
    to `map()`. The argument passed to our `map` callback function is an array, the
    first element being the key and the second being the value. It so happens that
    the `format()` function expects a key and a value to format the given string,
    so we're able to use `format.apply()` to call the function, passing it the `pair`
    array. This approach is just a matter of taste. There's no need to call `pairs()`
    before `map()`. We could just as easily have called `format` directly. But sometimes,
    this approach is preferred, and the reasons, not least of which is the style of
    the programmer, are wide and varied.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to look at reducing collections. Lo-Dash helps a lot here too,
    supplying functions that help us reduce arrays, objects, and anything that's thrown
    our way. Aside from primitives, all data structures can be reduced to something
    simpler.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start off by looking at the common reduce cases, summing values, and such.
    This will be followed by the topic of filtering collections and how it relates
    to reducing. Then, we'll look at some more advanced computational techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Summing values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike other programming languages, JavaScript has no built-in mechanism to
    sum together an array of values. The closest we get to summing is the native `Array.reduce()`
    method, which is actually general purpose and not specifically for summing values.
    The Lo-Dash version of `reduce` is even more general purpose, and here''s an example
    of how to use it in summing values in a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a simple collection that we''re reducing to two values. The first
    call to `reduce()` has a callback that sums together the **accumulator** and the
    `ram` property of the current item. The second `reduce()` call does the same thing,
    except that it works on the `storage` property. We''re essentially reducing the
    collection to a number, hence the term. You''ll also notice that we passed a `0`
    value to `reduce()` after the callback function. This is the accumulator. As the
    name suggests, its job is to accumulate data as each item is passed through the
    callback. This is also called the result and is always passed as the first argument
    to the `reduce` callback. Let''s look at a different kind of accumulator now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This accumulator is an object and it initializes two properties to `0`. The
    callback function just keeps returning a new accumulator object with computed
    sums of `hits` and `misses`. A nice side effect to this approach is that there''s
    only one call to `reduce()` instead of two. However, accumulators aren''t strictly
    necessary. In simple cases of summing items, there''s actually no point in using
    them. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This example uses a generic `reduce` callback function that returns the sum
    of its two arguments. Then we have a basic collection of objects, each with two
    properties. The first call to `reduce()` passes an array of numbers to the `add()`
    callback. The next two calls first use `pluck()` to build an array of numbers,
    using their respective key name strings. These calls use the same callback. The
    thing to notice about this code is that there is no explicit accumulator in the
    call to `reduce()`. The default, when none is specified by the caller, is the
    first element of the collection. With arrays that have primitive values such as
    these, this is fine and can actually simplify the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering and reducing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You won''t always need or want to reduce entire collections to a single value.
    Instead, it''s a filtered subset that''s required. Sometimes, your code is passed
    a collection that''s the result of applying a filter to some larger collection.
    Or, you need to apply the filter itself. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter()` function is used only to feed enabled objects to the `reduce()`
    call. This is called filtering *then* reducing. However, there''s an alternative
    approach that could be applied here. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This approach performs the necessary filtering inside the callback. This is
    called filtering *and* reducing. If the item isn't enabled, we simply return the
    last result. If it's enabled, we do the regular reduce work. So it's as though
    we're simply skipping items that would have been filtered anyway. This has the
    advantage that with big collections, you're not doing a linear operation through
    the collection twice, but only once. The downside is the added complexity in the
    `reduce` callback. But wherever this can be minimized, such as in the preceding
    case, shift the filtering work to the `reduce` callback to optimize your code.
  prefs: []
  type: TYPE_NORMAL
- en: Min, max, and average operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lo-Dash has functions that help in more complex operations and simultaneously
    let you write clean and concise code. For example, the `min()` and `max()` functions
    accept callbacks that let them be used in a variety of situations, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `score()` function defined in this code reduces the passed-in item to the
    sum of its `scores` property, assumed to be an array. This is meant to be used
    as a callback to the `min()` and `max()` functions. The idea is that `score()`
    is applied to each object in our collection and the minimum or maximum value is
    returned. So we're actually doing two reduce jobs, one for the `scores` property
    and another for the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reducing collections to averages is a little trickier because there''s no Lo-Dash
    function called `avg()` that reduces a collection to an average. Let''s see if
    we can implement something that doesn''t require much more code than the preceding
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Like the `scores()` callback function before this example, we have an `average()`
    function. This reduces the passed-in items to their average value. Our collection
    is composed of objects, each of which has a `scores` array. We're interested in
    finding the average of the entire collection. So, we'll call `reduce()` on our
    collection. The callback uses the `average()` function to compute the average
    score for each item. This result is then added to the `reduce()` accumulator.
    If we've reached the last item, average is done by checking the collection length.
    Then it's time to compute the final average—an average of averages. Since the
    accumulator is an array of numbers, we can simply return the value generated by
    passing it to `average()`.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will turn our attention to reducing objects and working
    with object accumulators. Reducing objects is a lot like reducing arrays, the
    difference being that you have a key instead of an index. Oh yeah, there's also
    the ordering, which is kind of important—arrays are ordered, objects aren't.
  prefs: []
  type: TYPE_NORMAL
- en: Previously in the chapter, we caught a glimpse of what accumulators are. Here
    we'll take a deeper look at object accumulators, including some of the built-in
    Lo-Dash functions that utilize this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can reduce an object to something different based solely on its keys. For
    example, if there are only certain properties you need, you can reduce the object
    to include only those properties, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `allowed` array contains the names of allowed property keys, and we're using
    the `reduce()` function to check whether the given key is allowed or not. If it
    is allowed, it gets added to the object accumulator. Otherwise, it's skipped.
    You'll notice that we can achieve the same effect by passing the `allowed` array
    to the `pick()` function. So check what Lo-Dash does out of the box before writing
    your own callback. On the other hand, your own code lends itself to changeability.
  prefs: []
  type: TYPE_NORMAL
- en: Object accumulators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an alternative to `reduce()`, the `transform()` function is used to transform
    a source object into a target object. The main difference is that with `transform`,
    there''s an implied accumulator. This accumulator object is created when the `transform()`
    function is first called. It''s then passed as a reference to the `callback` function
    for each property, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here we have an object with two string properties. The `callback` function we
    passed to `transform()` looks for string properties and uses `unescape()` to replace
    any HTML character codes. The `result` argument is here, just as it was in the
    `reduce()` callbacks, but we don't need to return it. We also don't need to supply
    an accumulator object because it is created for us. Let's take a closer look at
    how the accumulator is created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The downside to using `transform()` is that it looks as though you're transforming
    and returning the object that was passed in, which isn't the case. The `transform()`
    function does not touch the source object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we''re transforming an instance of a class, rather than just a plain
    object. This can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `object` variable holds an instance of `Person`. Our `transform()` callback
    simply looks for strings and transforms them into their uppercase equivalents.
    When we call the `name()` function on the transformed object, we get the uppercase
    result we expect. Notice that the `name()` method is on the `Person` prototype.
    The `transform()` function constructs the transformed instance properly using
    the appropriate constructor function. This ensures that the prototypical methods
    and properties are where they should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lo-Dash has other functions that work along the same lines in terms of object
    accumulators, the difference being that the source is a collection instead of
    an object. For example, you can take a collection and group or index the items,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `groupBy()` function groups items of the collection according to the value
    of the specified property. That is, if the same two items have the same `position`
    property value, they'll be grouped together under the same object key. On the
    other hand, `indexBy()` will put only one item in a given key. So this function
    is better suited for unique properties such as identifiers. Instead of a `property`
    string, we can pass a function that generates the value if we're so inclined.
    The result of running the `indexBy()` call is an object with unique keys that
    we can use to look up items.
  prefs: []
  type: TYPE_NORMAL
- en: Binding contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might not always want to use anonymous functions, or Lo-Dash functions,
    as your `map()` callback. This is the same case with `reduce()`. Luckily, you
    can easily bind the callback function context in both cases. For example, let''s
    say that you have an application object that is not global. You can still make
    it the context of your callback function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example uses the `partialRight()` function to compose a callback
    function. We're partially applying arguments to the `map()` function. The first
    is the callback function and the second is the context of the function, the `app`
    instance in this case. This basically enables the callback function to refer to
    the `this` keyword as the application, despite it not being in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same context-binding principle can be applied to the `reduce()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `reduce` callback is a partial function that has a `settings` object
    as its context. This object has a `tax` property that's used to reduce the collection,
    by multiplying its value by each item in the collection. This result is then added
    to the accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: Map/reduce patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll close the chapter with an introduction to some basic map/reduce patterns,
    applicable to everything you've learned in this chapter so far. First, we'll take
    a look at what generic callback functions look like and why they're useful. Then
    we'll introduce the notion of map/reduce chains.
  prefs: []
  type: TYPE_NORMAL
- en: Generic callback functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the development of your frontend application progresses, you'll start to
    notice that there is some commonality between all of your map/reduce callback
    functions. In other words, you could probably factor the generic aspects of the
    callbacks into a single generic callback. As you've seen throughout this chapter
    and the previous chapter, it's easy to partially apply and compose new functions
    with Lo-Dash. This is especially helpful when you have a handful of generic functions
    that you'd like to use as callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s create some generic `map()` callback functions and see
    how they can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two generic functions, `add()` and `upper()`. They both follow
    similar patterns. For example, both refer to the `this.prop` property. So they're
    both context dependent. However, this is a strength, not a weakness. The `add()`
    callback uses `this.prop` to determine which property to manipulate. The `this.value`
    property determines the value to add. As we've seen, it's easy to supply context
    to these functions and that's how we get specific information to these callbacks.
    The `upper()` callback does the same thing, but it transforms the existing property
    to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: The `mapAdd()` and `mapUpper()` functions are created as partials, pre-supplying
    the collection and the generic callback function. All that's missing is the context
    and that is supplied when the function is called. This means these functions have
    the potential to be useful throughout the application, getting new contexts when
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's tempting, as with any other programming endeavor to try and create generic
    map/reduce callback functions up-front, that is, trying to foresee where you'll
    need similar but slightly different functionality. The truth is that **hindsight**
    is a powerful tool. It's much easier to see where generic functions become useful
    after you've started to repeat yourself. **Foresight**, on the other hand, tends
    to lead to conceptually useful callback functions that aren't actually needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the ideas that apply to generic functions for `map()` callback functions
    also apply to `reduce()` callback functions. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The generic `sum()` function returns the sum of the two arguments. However,
    it uses `this.prop` to determine which property should be added. Then we proceed
    to create the `reduceSum()` function using `partial()`. Now we can call `reduceSum()`
    with any context we want.
  prefs: []
  type: TYPE_NORMAL
- en: Map/reduce chains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final pattern we'll look at in this chapter is the notion of a map/reduce
    chain. This is closely related to the map/reduce programming model introduced
    by Google. The idea is that with large datasets, it's easier to tackle computationally
    intensive problems when you can break the problem into a set of mapping operations.
    These operations are then fed to a set of reducing operations. From this perspective,
    it's much easier to distribute the computation across nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re interested in, however, is the handoff that takes place between
    the map job and the reduce job. The map job is responsible for mapping the source
    data to something that is consumable by the reduce job. This pattern might actually
    repeat several times. For example, a dataset is mapped and then reduced. The result
    of reducing it is then further mapped, and further reduced, and so on. Let''s
    see how something like this looks in Lo-Dash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we map the collection by computing the amount after adding a `bonus` property
    to the `balance` item for each item. This newly mapped collection is stored in
    the `mapped` variable. Then we reduce the collection to the average rate of increase.
    Note that the reduce callback expects a mapped collection since it makes use of
    the `bonus` property, which isn't in the original collection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the map/reduce programming model and how Lo-Dash
    tools can help to realize it in your application. First, we examined mapping collections,
    including how to choose which properties get included and how to perform calculations.
    We then moved on to mapping objects. Keys have an important role in how objects
    get mapped to new objects and collections. There are also methods and functions
    to consider when mapping.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the chapter covered reducing, including how to sum items,
    how to transform objects, and how to formulate generic callback functions that
    can be used in a variety of contexts. The chapter closed with a brief look at
    what chaining map/reduce operations together looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Map/reduce is an important topic because Lo-Dash supports many variations of
    the programming model. It's now time to expand on the chaining concept, and it
    turns out that there's a lot more than just map/reduce functions that can be glued
    together.
  prefs: []
  type: TYPE_NORMAL
