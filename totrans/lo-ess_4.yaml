- en: Chapter 4. Transformations Using Map/Reduce
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用Map/Reduce进行转换
- en: The preceding three chapters alluded to transformation possibilities with Lo-Dash.
    Whether you're working with collections, objects, or functions, a common pattern
    with Lo-Dash functions is transformation of the input by generating a new, albeit
    slightly altered, version. The idea of transforming values is central to applicative
    programming, where much of the code you write is a series of transformations.
    Beginning with this chapter, we're going to shift gears and look at transformations
    in more detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前三章都提到了Lo-Dash的转换可能性。无论你是在处理集合、对象还是函数，Lo-Dash函数的一个常见模式是通过生成一个新的（尽管略有不同）版本来转换输入。转换值的思想是应用编程的核心，其中你编写的大部分代码都是一系列的转换。从本章开始，我们将转换方向，更详细地研究转换。
- en: Particularly, we'll be looking at all the interesting things we can do with
    Lo-Dash and the map/reduce programming model. We'll start off with the basics,
    getting our feet wet with some basic mappings and basic reductions. As we progress
    through the chapter, we'll start introducing more advanced techniques to think
    about in terms of map/reduce with Lo-Dash.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们将探讨所有我们可以使用Lo-Dash和map/reduce编程模型完成的有趣事情。我们将从基础知识开始，通过一些基本的映射和基本的减少来湿脚。随着我们通过本章的进展，我们将开始介绍更多高级技术，这些技术可以从map/reduce的角度来考虑。
- en: The goal, once you've reached the end of this chapter, is to have a solid understanding
    of the Lo-Dash functions available that aid in mapping and reducing collections.
    Additionally, you'll start to notice how disparate Lo-Dash functions work together
    in the map/reduce domain. Ready?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你读完本章，目标是牢固地理解可帮助映射和减少集合的Lo-Dash函数。此外，你将开始注意到不同的Lo-Dash函数如何在map/reduce领域中协同工作。准备好了吗？
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Plucking values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取值
- en: Mapping collections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射集合
- en: Mapping objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射对象
- en: Reducing collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少集合
- en: Reducing objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少对象
- en: Binding contexts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定上下文
- en: Map/reduce patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map/reduce模式
- en: Plucking values
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取值
- en: 'We''ve already seen how values can be plucked from collections using the `pluck()`
    function in [Chapter 1](ch01.html "Chapter 1. Working with Arrays and Collections"),
    *Working with Arrays and Collections*. Consider that your informal introduction
    to mapping, because that''s essentially what it''s doing. It''s taking an input
    collection and mapping it to a new collection, plucking only the properties we''re
    interested in. This is shown in the following example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第1章](ch01.html "第1章. 处理数组和集合") *处理数组和集合* 中看到了如何使用 `pluck()` 函数从集合中提取值。考虑这是你对映射的非正式介绍，因为这正是它在做的事情。它接受一个输入集合，将其映射到一个新的集合，只提取我们感兴趣的属性。以下是一个示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is about as simple a mapping operation as you''ll find. In fact, you can
    do the same thing with `map()`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常简单的映射操作。实际上，你可以用 `map()` 做同样的事情：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you'd expect, the output here is exactly the same as it would be with `pluck()`.
    In fact, `pluck()` is actually using the `map()` function under the hood. The
    callback passed to `map()` is constructed using `property()`, which just returns
    the specified property value. The `map()` function falls back to this plucking
    behavior when passed a string instead of a function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，这里的输出与使用 `pluck()` 的输出完全相同。事实上，`pluck()` 实际上是在底层使用 `map()` 函数。传递给 `map()`
    的回调是通过 `property()` 构造的，它只返回指定的属性值。当传递一个字符串而不是一个函数给 `map()` 函数时，`map()` 函数会回退到这种提取行为。
- en: With that brief introduction to the nature of mapping, let's dig a little deeper
    and see what's possible in mapping collections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在对映射的本质进行简要介绍之后，让我们进一步深入探讨映射集合中可能实现的内容。
- en: Mapping collections
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射集合
- en: In this section, we'll explore mapping collections. Mapping one collection to
    another ranges from composing simple—as we saw in the preceding section—to sophisticated
    callbacks. Callbacks that map each item in the collection can include or exclude
    properties and can calculate new values. We'll also address the issue of filtering
    collections and how this can be done in conjunction with mapping.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨映射集合。将一个集合映射到另一个集合的范围从简单的组合——正如我们在上一节中看到的——到复杂的回调。映射集合中每个项目的回调可以包括或排除属性，并可以计算新值。我们还将讨论过滤集合的问题以及如何与映射结合进行。
- en: Including and excluding properties
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包括和排除属性
- en: 'When applied to an object, the `pick()` function generates a new object containing
    only the specified properties. The opposite function, `omit()`, generates an object
    with every property except those specified. Since these functions work fine for
    individual object instances, why not use them with a collection? You can use both
    of these functions to shed properties from collections by mapping them to new
    ones, as shown in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于一个对象时，`pick()` 函数会生成一个新的对象，其中只包含指定的属性。与之相反的函数 `omit()` 会生成一个对象，除了指定的属性外，包含所有属性。由于这些函数对单个对象实例工作良好，为什么不使用它们与集合一起使用呢？你可以使用这两个函数通过映射到新的属性来从集合中去除属性，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we're creating a new collection using the `map()` function. The callback
    function supplied to `map()` is applied to each item in the collection. The `item`
    argument is the original item from the collection. The callback is expected to
    return the mapped version of that item and this version could be anything, including
    the original item itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用 `map()` 函数创建一个新的集合。提供给 `map()` 的回调函数应用于集合中的每个项目。`item` 参数是集合中的原始项目。回调函数预期返回该项目的映射版本，而这个版本可以是任何东西，包括原始项目本身。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when manipulating the original item in `map()` callbacks. If the
    item is an object and it's referenced elsewhere in your application, it could
    have unintended consequences.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `map()` 回调中操作原始项目时要小心。如果项目是一个对象并且它在应用程序的其他地方被引用，它可能会产生意外的后果。
- en: 'We''re returning a new object as the mapped item in the preceding code. This
    is done using the `pick()` function. We only care about the `first` and the `last`
    properties. Our newly mapped collection looks identical to the original, except
    that no item has an `age` property. This newly-mapped collection is seen in the
    following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们返回一个新的对象作为映射的项目。这是使用 `pick()` 函数完成的。我们只关心 `first` 和 `last` 属性。我们新映射的集合看起来与原始集合相同，只是没有任何项目有
    `age` 属性。这个新映射的集合在以下代码中可以看到：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code follows the exact same approach as the previous `pick()` code. The
    only difference is that we're excluding the `first` property from the newly-created
    collection. You'll also notice that we're passing a string containing a single
    property name instead of an array of property names.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的 `pick()` 代码采用完全相同的方法。唯一的区别是我们排除了新创建的集合中的 `first` 属性。你也会注意到我们传递了一个包含单个属性名的字符串，而不是属性名数组。
- en: 'In addition to passing strings or arrays as the argument to `pick()` or `omit()`,
    we can pass in a function callback. This is suitable when it''s not very clear
    which objects in a collection should have which properties. Using a callback like
    this inside a `map()` callback lets us perform detailed comparisons and transformations
    on collections with very little code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将字符串或数组作为 `pick()` 或 `omit()` 的参数传递之外，我们还可以传递一个函数回调。这在不清楚集合中哪些对象应该具有哪些属性时很合适。在
    `map()` 回调中使用这样的回调允许我们对具有非常少的代码的集合执行详细的比较和转换：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The new collection generated by this code excludes the `age` property for items
    where the `age` value is less than `40`. The callback supplied to `omit()` is
    applied to each key-value pair in the object. This code is a good illustration
    of the conciseness achievable with Lo-Dash. There's a lot of iterative code running
    here, and there is no `for` or `while` statement in sight.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由这段代码生成的新集合排除了 `age` 属性，对于 `age` 值小于 `40` 的项目。提供给 `omit()` 的回调函数应用于对象中的每个键值对。这段代码是
    Lo-Dash 实现简洁性的良好示例。这里运行着大量的迭代代码，而且没有看到任何 `for` 或 `while` 语句。
- en: Performing calculations
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行计算
- en: 'It''s time now to turn our attention to performing calculations in our `map()`
    callbacks. This entails looking at the item and, based on its current state, computing
    a new value that will be ultimately mapped to the new collection. This could mean
    extending the original item''s properties or replacing one with a newly computed
    value. Whichever the case, it''s a lot easier to map these computations than to
    write your own logic that applies these functions to every item in your collection.
    This is explained using the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的注意力转向在 `map()` 回调中执行计算了。这包括查看项目并根据其当前状态计算一个新值，该值最终将被映射到新集合中。这可能意味着扩展原始项目的属性或用新计算出的值替换一个。无论哪种情况，映射这些计算都比编写应用于集合中每个项目的逻辑要容易得多。以下示例解释了这一点：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we're mapping each item in the original collection to an extended version
    of it. Particularly, we're computing two new values for each item—`experience`
    and `specialty`. The `experience` property is simply the sum of the `jqueryYears`
    and `cssYears` properties. The `specialty` property is computed based on the larger
    value of the `jqueryYears` and `cssYears` properties.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将原始集合中的每个项目映射到其扩展版本。特别是，我们为每个项目计算两个新值——`经验`和`专长`。`经验`属性仅仅是`jqueryYears`和`cssYears`属性的简单总和。`专长`属性是基于`jqueryYears`和`cssYears`属性中较大值的计算结果。
- en: 'Earlier, I mentioned the need to be careful when modifying items in `map()`
    callbacks. In general, it''s a bad idea. It''s helpful to try and remember that
    `map()` is used to generate new collections, not to modify existing collections.
    Here''s an illustration of the horrific consequences of not being careful:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到了在`map()`回调中修改项目时需要小心。一般来说，这是一个坏主意。记住`map()`是用来生成新集合的，而不是修改现有集合，这会有所帮助。以下是不小心操作带来的可怕后果的说明：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The destructive nature of this callback is not obvious at all and next to impossible
    for programmers to track down and diagnose. It is essentially resetting the `supervisor`
    property for each item. If these items are used anywhere else in the application,
    the `supervisor` property value will be clobbered whenever this map job is executed.
    If you need to reset values like this, ensure that the change is mapped to the
    new value and not made to the original.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调的破坏性性质并不明显，对程序员来说几乎不可能追踪和诊断。它实际上是为每个项目重置`supervisor`属性。如果这些项目在应用程序的其他地方被使用，每当这个映射任务执行时，`supervisor`属性值就会被覆盖。如果你需要重置这样的值，确保更改被映射到新值，而不是对原始值进行更改。
- en: 'Mapping also works with primitive values as the item. Often, we''ll have an
    array of primitive values that we''d like transformed into an alternative representation.
    For example, let''s say you have an array of sizes, expressed in bytes. You can
    map those arrays to a new collection with those sizes expressed as human-readable
    values, using the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 映射也可以使用原始值作为项目。通常，我们会有一组原始值数组，我们希望将其转换成另一种表示形式。例如，假设你有一个表示字节的尺寸数组。你可以使用以下代码将这些数组映射到一个新集合中，其中尺寸以可读的值表示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `bytes()` function takes a numerical argument, which is the number of bytes
    to be formatted. This is the starting unit. We just keep incrementing the `target`
    unit until we have something that is less than `1024`. For example, the last item
    in our collection maps to `'114.6MB'`. The `bytes()` function can be passed directly
    to `map()` since it's expecting values in our collection as they are.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes()`函数接受一个数值参数，即要格式化的字节数。这是起始单位。我们只是不断递增`target`单位，直到我们得到一个小于`1024`的值。例如，我们集合中的最后一个项目映射到`''114.6MB''`。`bytes()`函数可以直接传递给`map()`，因为它期望我们的集合中的值是它们当前的值。'
- en: Calling functions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'We don''t always have to write our own callback functions for `map()`. Wherever
    it makes sense, we''re free to leverage Lo-Dash functions to map our collection
    items. For example, let''s say we have a collection and we''d like to know the
    size of each item. There''s a `size()` Lo-Dash function we can use as our `map()`
    callback, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不总是需要为`map()`编写自己的回调函数。在合理的地方，我们可以自由地利用Lo-Dash函数来映射我们的集合项目。例如，假设我们有一个集合，我们想知道每个项目的大小。我们可以使用`size()`
    Lo-Dash函数作为我们的`map()`回调，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code has the added benefit that the `size()` function returns consistent
    results, no matter what kind of argument is passed to it. In fact, any function
    that takes a single argument and returns a new value based on that argument is
    a valid candidate for a `map()` callback. For instance, we could also map the
    minimum and maximum value of each item:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的额外好处是`size()`函数返回一致的结果，无论传递给它的参数是什么。实际上，任何接受单个参数并根据该参数返回新值的函数都是`map()`回调的有效候选者。例如，我们也可以映射每个项目的最小值和最大值：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What if we want to map each item of our collection to a sorted version? Since
    we do not sort the collection itself, we don''t care about the item positions
    within the collection, but the items themselves, if they''re arrays, for instance.
    Let''s see what happens with the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将集合中的每个项目映射到一个排序版本呢？由于我们不排序集合本身，所以我们不关心项目在集合中的位置，而是关心项目本身，例如，如果它们是数组。让我们看看以下代码会发生什么：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code uses the `compose()` function to construct a `map()` callback. The
    first function returns the sorted version of the item by passing it to `sortBy()`.
    The `first()` item of this sorted list is then returned as the mapped item. The
    end result is a new collection containing the alphabetically-first item from each
    array in our collection, with three lines of code. Not bad.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 `compose()` 函数构建一个 `map()` 回调。第一个函数通过传递给 `sortBy()` 来返回项目的排序版本。然后，这个排序列表的第一个项目作为映射项目返回。最终结果是包含我们集合中每个数组按字母顺序排列的第一个项目的新集合，仅用三行代码。不错。
- en: Filtering and mapping
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和映射
- en: 'Filtering and mapping are two closely related collection operations. Filtering
    extracts only those collection items that are of particular interest. Mapping
    transforms collections to produce new collections. But what if we only want to
    map a certain subset of our collection? Then it would make sense to chain together
    the filtering and mapping operations, right? Here''s an example of what that might
    look like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤和映射是两个紧密相关的集合操作。过滤只提取那些特别感兴趣的集合项目。映射将集合转换以产生新的集合。但如果我们只想映射集合的某个子集呢？那么将过滤和映射操作链在一起是有意义的，对吧？以下是一个可能看起来像这样的例子：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This map is executed using `compose()` to build a function that is called right
    away, with our `collection` as the argument. The function is composed of two partials.
    We're using `partialRight()` on both arguments because we want the collection
    supplied as the leftmost argument in both cases. The first partial function is
    `filter()`. We're partially applying the `enabled` argument. So this function
    will filter our collection before it's passed to `map()`. The result of filtering
    the collection is passed to `map()`, which has the `name` argument partially applied.
    The end result is a collection with enabled `name` strings.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个映射是通过使用 `compose()` 来构建一个立即调用的函数来执行的，我们的 `collection` 作为参数。这个函数由两个部分组成。我们在两个参数上都使用了
    `partialRight()`，因为我们希望在这两种情况下提供的集合作为最左边的参数。第一个部分函数是 `filter()`。我们部分应用了 `enabled`
    参数。因此，这个函数将在传递给 `map()` 之前过滤我们的集合。过滤集合的结果传递给 `map()`，它部分应用了 `name` 参数。最终结果是包含启用
    `name` 字符串的集合。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The important thing to note about the preceding code is that the filtering operation
    takes place *before* the `map()` function is run. We could have stored the filtered
    collection in an intermediate variable instead of streamlining with `compose()`.
    Regardless of flavor, it's important that the items in your mapped collection
    correspond to the items in the source collection. It's conceivable to filter out
    the items in the `map()` callback by not returning anything, but this is ill-advised
    as it doesn't map well, both figuratively and literally.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面代码的重要一点是，过滤操作发生在 `map()` 函数运行之前。我们本可以将过滤后的集合存储在一个中间变量中，而不是通过 `compose()`
    流程化。无论哪种风格，确保你映射集合中的项目与源集合中的项目相对应是很重要的。通过不返回任何内容来过滤 `map()` 回调中的项目是可行的，但这并不明智，因为这在字面意义上和比喻意义上都不太合适。
- en: Mapping objects
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射对象
- en: The previous section focused on collections and how to map them. But wait, objects
    are collections too, right? That is indeed correct, but it's worth differentiating
    between arrays and plain objects. The main reason is that there are implications
    with ordering and keys when performing map/reduce. At the end of the day, arrays
    and objects serve different use cases with map/reduce, and this chapter tries
    to acknowledge these differences.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节主要关注集合以及如何映射它们。但是等等，对象也是集合，对吧？这确实是正确的，但区分数组和普通对象是值得的。主要原因在于在执行映射/归约操作时，顺序和键有影响。最终，数组和对象在映射/归约方面有不同的用途，本章试图承认这些差异。
- en: Now we'll start looking at some techniques Lo-Dash programmers employ when working
    with objects and mapping them to collections. There are a number of factors to
    consider, such as the keys within an object, and calling methods on objects. We'll
    take a look at the relationship between key-value pairs and how they can be used
    in a mapping context.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开始探讨 Lo-Dash 程序员在处理对象并将它们映射到集合时所采用的一些技术。有许多因素需要考虑，例如对象内的键，以及在对象上调用方法。我们将研究键值对之间的关系以及它们如何在映射上下文中使用。
- en: Working with keys
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理键
- en: 'We can use the keys of a given object in interesting ways to map the object
    to a new collection. For example, we can use the `keys()` function to extract
    the keys of an object and map them to values other than the property value, as
    shown in the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用有趣的方式来使用给定对象的键，将对象映射到一个新的集合中。例如，我们可以使用`keys()`函数来提取对象的键，并将它们映射到除了属性值之外的其他值，如下面的示例所示：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code builds an array of property values from `object`. It does
    this using `map()`, which is actually mapping the `keys()` array of `object`.
    These keys are sorted using `sortBy()`. So `Packt` is the first element of the
    resulting array because `employer` is alphabetically-first in the `object` keys.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从`object`中构建了一个属性值数组。它是通过使用`map()`来实现的，实际上是将`object`的`keys()`数组进行映射。这些键是通过`sortBy()`进行排序的。因此，“Packt”是结果数组的第一个元素，因为在`object`键中，“employer”是按字母顺序排在第一位的。
- en: 'Sometimes, it''s desirable to perform lookups in other objects and map those
    values to a target object. For example, not all APIs return everything you need
    for a given page, packaged in a neat little object. You have to do joins and build
    the data you need. This is shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，执行其他对象的查找并将这些值映射到目标对象是有用的。例如，并非所有API都返回给定页面所需的所有内容，打包在一个整洁的小对象中。你必须进行连接并构建所需的数据。以下代码展示了这一点：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This example builds two objects, `users` and `preferences`. In the case of each
    object, the keys are user identifiers that we're generating with `uniqueId()`.
    The `user` objects just have some dummy attribute in them, while the `preferences`
    objects have an `emailme` attribute, set to a random Boolean value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例构建了两个对象，`users`和`preferences`。在每个对象的情况下，键是我们使用`uniqueId()`生成的用户标识符。`user`对象中只有一些虚拟属性，而`preferences`对象有一个`emailme`属性，设置为随机的布尔值。
- en: Now let's say we need quick access to this preference for all users in the `users`
    object. As you can see, it's straightforward to implement using `map()` on the
    `users` object. The callback function returns a new object with the user ID. We
    extend this object with the preference for that particular user by looking them
    up by `key`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们需要快速访问`users`对象中所有用户的这个偏好。如您所见，使用`map()`在`users`对象上实现这一点非常直接。回调函数返回一个包含用户ID的新对象。我们通过`key`查找来扩展这个对象，以获取特定用户的偏好。
- en: Calling methods
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用方法
- en: 'Object properties aren''t limited to storing primitive strings and numbers.
    Properties can store functions as their values, or methods, as they''re commonly
    referred. However, depending on the context where you''re using your object, methods
    aren''t always callable, especially if you have little or no control over the
    context where your objects are used. One technique that''s helpful in situations
    such as these is mapping the result of calling these methods and using this result
    in the context in question. Let''s see how this can be done with the following
    code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对象属性不仅限于存储原始字符串和数字。属性可以存储作为其值的函数，或者称为方法。然而，根据你使用对象的环境，方法并不总是可调用的，特别是如果你对对象使用的环境几乎没有或没有控制权。在这些情况下，一种有用的技术是将调用这些方法的结果进行映射，并在相关环境中使用这个结果。让我们看看以下代码是如何做到这一点的：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have an object with both primitive property values and methods that
    use these properties. Now we'd like to map the results of calling those methods
    and we will experiment with two different approaches. The first approach uses
    the `isFunction()` function to determine whether the property value is callable
    or not. If it is, we call it and return that value. The second approach is a little
    easier to implement and achieves the same outcome. The `result()` function is
    applied to the object using the current key. This tests whether we're working
    with a function or not, so our code doesn't have to.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含原始属性值和这些属性值使用的方法的对象。现在我们希望映射调用这些方法的结果，我们将尝试两种不同的方法。第一种方法使用`isFunction()`函数来确定属性值是否可调用。如果是，我们调用它并返回该值。第二种方法更容易实现，并达到相同的效果。`result()`函数被应用于对象和当前键。这测试了我们是否正在处理一个函数，因此我们的代码不必这样做。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the first approach to mapping method invocations, you might have noticed
    that we're calling the method using `object[key]()` instead of `value()`. The
    former retains the context as the object variable, but the latter loses the context,
    since it is invoked as a plain function without any object. So when you're writing
    mapping callbacks that call methods and not getting the expected results, make
    sure the method's context is intact.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射方法调用的第一种方法中，你可能已经注意到我们使用`object[key]()`而不是`value()`来调用方法。前者保留了对象变量的上下文，但后者失去了上下文，因为它作为一个没有任何对象的普通函数被调用。所以当你编写调用方法的映射回调但没有得到预期结果时，确保方法的上下文是完整的。
- en: 'Perhaps you have an object but you''re not sure which properties are methods.
    You can use `functions()` to figure this out and then map the results of calling
    each method to an array, as shown in the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你有一个对象，但你不确定哪些属性是方法。你可以使用`functions()`来找出这一点，然后映射调用每个方法的结果到一个数组，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `object` variable has two methods, `first()` and `last()`. Assuming we didn't
    know about these methods, we can find them using `functions()`. Here, we're building
    a `methods` array using `map()`. The input is an array containing the names of
    all the methods of the given object. The value we're returning is interesting.
    It's a single-value array; you'll see why in a moment. The value of this array
    is a function built by passing the object and the name of the method to `bindKey()`.
    This function, when invoked, will always use `object` as its context.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`变量有两个方法，`first()`和`last()`。假设我们不知道这些方法，我们可以使用`functions()`来找到它们。在这里，我们使用`map()`构建一个`methods`数组。输入是一个包含给定对象所有方法名称的数组。我们返回的值很有趣。它是一个单值数组；你很快就会明白原因。这个数组的值是通过将对象和方法名称传递给`bindKey()`构建的函数。这个函数在调用时，将始终使用`object`作为其上下文。'
- en: Lastly, we use `invoke()` to invoke each method in our `methods` array, building
    a new result array. Recall that our `map()` callback returned an array. This was
    a simple hack to make `invoke()` work, since it's a convenient way to call methods.
    It generally expects a key as the second argument, but a numerical index works
    just as well, since they're both looked up the same.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`invoke()`来调用`methods`数组中的每个方法，构建一个新的结果数组。回想一下，我们的`map()`回调返回了一个数组。这是一个简单的技巧，让`invoke()`工作，因为它是一种方便调用方法的方式。它通常期望一个键作为第二个参数，但一个数字索引同样有效，因为它们都是通过相同的方式查找的。
- en: Mapping key-value pairs
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射键值对
- en: 'Just because you''re working with an object doesn''t mean it''s ideal, or even
    necessary. That''s what `map()` is for—mapping what you''re given to what you
    need. For instance, the property values are sometimes all that matter for what
    you''re doing, and you can dispense with the keys entirely. For that, we have
    the `values()` function and we feed the values to `map()`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为你正在处理一个对象，并不意味着它是理想的，甚至可能是必要的。这正是`map()`的作用——将你拥有的映射到你需要的。例如，属性值有时对你所做的事情来说可能就是全部，你可以完全不用键。为此，我们有`values()`函数，并将值传递给`map()`：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All we want from the `object` variable here is a list of property values, which
    are strings, so that we can format them. In other words, the fact that the keys
    are `first`, `last`, and `age` is irrelevant. So first, we call `values()` to
    build an array of values. Next, we pass that array to `filter()`, removing anything
    that's not a string. We then pass the output of this to `map()`, where we're able
    to map the string using `<strong/>` tags.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里从`object`变量中想要的只是一个属性值的列表，这些值都是字符串，这样我们就可以对它们进行格式化。换句话说，键是`first`、`last`和`age`的事实是不相关的。因此，首先我们调用`values()`来构建一个值数组。接下来，我们将该数组传递给`filter()`，移除任何不是字符串的内容。然后我们将这个输出传递给`map()`，在那里我们可以使用`<strong/>`标签映射字符串。
- en: 'The opposite might also be true—the value is completely meaningless without
    its key. If that''s the case, it may be fitting to map key-value pairs to a new
    collection, as shown in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也可能成立——没有键，值完全没有意义。如果是这样，可能将键值对映射到一个新的集合中是合适的，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We're passing the result of running our object through the `pairs()` function
    to `map()`. The argument passed to our `map` callback function is an array, the
    first element being the key and the second being the value. It so happens that
    the `format()` function expects a key and a value to format the given string,
    so we're able to use `format.apply()` to call the function, passing it the `pair`
    array. This approach is just a matter of taste. There's no need to call `pairs()`
    before `map()`. We could just as easily have called `format` directly. But sometimes,
    this approach is preferred, and the reasons, not least of which is the style of
    the programmer, are wide and varied.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行对象通过 `pairs()` 函数的结果传递给 `map()`。传递给我们的 `map` 回调函数的参数是一个数组，第一个元素是键，第二个是值。碰巧的是，`format()`
    函数期望一个键和一个值来格式化给定的字符串，因此我们可以使用 `format.apply()` 来调用该函数，传递给它 `pair` 数组。这种方法纯粹是个人喜好问题。没有必要在
    `map()` 之前调用 `pairs()`。我们同样可以直接调用 `format`。但有时，这种方法更受欢迎，原因很多，其中之一就是程序员的风格，这些原因广泛而多样。
- en: Reducing collections
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化集合
- en: It's now time to look at reducing collections. Lo-Dash helps a lot here too,
    supplying functions that help us reduce arrays, objects, and anything that's thrown
    our way. Aside from primitives, all data structures can be reduced to something
    simpler.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看如何简化集合了。Lo-Dash 在这里也提供了很多帮助，提供了帮助我们简化数组、对象以及任何向我们抛来的东西的函数。除了原始数据类型之外，所有数据结构都可以简化为更简单的东西。
- en: We'll start off by looking at the common reduce cases, summing values, and such.
    This will be followed by the topic of filtering collections and how it relates
    to reducing. Then, we'll look at some more advanced computational techniques.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看常见的简化情况开始，例如求和值等。接下来，我们将讨论过滤集合的主题以及它与简化的关系。然后，我们将探讨一些更高级的计算技术。
- en: Summing values
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 求和值
- en: 'Unlike other programming languages, JavaScript has no built-in mechanism to
    sum together an array of values. The closest we get to summing is the native `Array.reduce()`
    method, which is actually general purpose and not specifically for summing values.
    The Lo-Dash version of `reduce` is even more general purpose, and here''s an example
    of how to use it in summing values in a collection:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言不同，JavaScript 没有内置机制来对值数组进行求和。我们所能达到的求和程度是原生的 `Array.reduce()` 方法，它实际上是通用的，并不专门用于求和值。Lo-Dash
    版本的 `reduce` 更加通用，以下是一个如何在集合中求和值的示例：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have a simple collection that we''re reducing to two values. The first
    call to `reduce()` has a callback that sums together the **accumulator** and the
    `ram` property of the current item. The second `reduce()` call does the same thing,
    except that it works on the `storage` property. We''re essentially reducing the
    collection to a number, hence the term. You''ll also notice that we passed a `0`
    value to `reduce()` after the callback function. This is the accumulator. As the
    name suggests, its job is to accumulate data as each item is passed through the
    callback. This is also called the result and is always passed as the first argument
    to the `reduce` callback. Let''s look at a different kind of accumulator now:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的集合，我们将其简化为两个值。第一次调用 `reduce()` 有一个回调函数，它将累加器和当前项的 `ram` 属性相加。第二次
    `reduce()` 调用执行相同的事情，但它作用于 `storage` 属性。我们实际上是将集合简化为一个数字，因此得名。你还会注意到，在回调函数之后，我们向
    `reduce()` 传递了一个 `0` 值。这就是累加器。正如其名所示，它的任务是随着每个项目通过回调函数而累积数据。这也被称为结果，并且总是作为第一个参数传递给
    `reduce` 回调。现在让我们看看不同类型的累加器：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This accumulator is an object and it initializes two properties to `0`. The
    callback function just keeps returning a new accumulator object with computed
    sums of `hits` and `misses`. A nice side effect to this approach is that there''s
    only one call to `reduce()` instead of two. However, accumulators aren''t strictly
    necessary. In simple cases of summing items, there''s actually no point in using
    them. This is shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个累加器是一个对象，它初始化两个属性为 `0`。回调函数只是不断返回一个新的累加器对象，其中包含计算出的 `hits` 和 `misses` 的总和。这种方法的副作用之一是，我们只需要一个
    `reduce()` 调用而不是两个。然而，累加器并不是必需的。在简单的求和项的情况下，实际上使用它们并没有意义。以下代码展示了这一点：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This example uses a generic `reduce` callback function that returns the sum
    of its two arguments. Then we have a basic collection of objects, each with two
    properties. The first call to `reduce()` passes an array of numbers to the `add()`
    callback. The next two calls first use `pluck()` to build an array of numbers,
    using their respective key name strings. These calls use the same callback. The
    thing to notice about this code is that there is no explicit accumulator in the
    call to `reduce()`. The default, when none is specified by the caller, is the
    first element of the collection. With arrays that have primitive values such as
    these, this is fine and can actually simplify the callback function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用一个通用的 `reduce` 回调函数，该函数返回其两个参数的总和。然后我们有一个基本的对象集合，每个对象有两个属性。`reduce()` 的第一次调用将一个数字数组传递给
    `add()` 回调。接下来的两次调用首先使用 `pluck()` 构建一个数字数组，使用它们各自的键名字符串。这些调用使用相同的回调。要注意的是，此代码中没有在
    `reduce()` 调用中显式指定累加器。当调用者未指定时，默认值是集合的第一个元素。对于具有这些原始值的数组，这是可以的，实际上可以简化回调函数。
- en: Filtering and reducing
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和缩减
- en: 'You won''t always need or want to reduce entire collections to a single value.
    Instead, it''s a filtered subset that''s required. Sometimes, your code is passed
    a collection that''s the result of applying a filter to some larger collection.
    Or, you need to apply the filter itself. Consider the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您并不总是需要或想要将整个集合缩减到单个值。相反，需要一个过滤后的子集。有时，您的代码接收到的集合是应用过滤后的较大集合的结果。或者，您需要应用过滤本身。考虑以下代码：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `filter()` function is used only to feed enabled objects to the `reduce()`
    call. This is called filtering *then* reducing. However, there''s an alternative
    approach that could be applied here. This is shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 函数仅用于将启用的对象传递给 `reduce()` 调用。这被称为过滤然后缩减。然而，这里可以应用另一种方法。如下面的代码所示：'
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This approach performs the necessary filtering inside the callback. This is
    called filtering *and* reducing. If the item isn't enabled, we simply return the
    last result. If it's enabled, we do the regular reduce work. So it's as though
    we're simply skipping items that would have been filtered anyway. This has the
    advantage that with big collections, you're not doing a linear operation through
    the collection twice, but only once. The downside is the added complexity in the
    `reduce` callback. But wherever this can be minimized, such as in the preceding
    case, shift the filtering work to the `reduce` callback to optimize your code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在回调函数内部执行必要的过滤。这被称为过滤和缩减。如果项目未启用，我们只需返回最后一个结果。如果已启用，我们执行常规的缩减工作。所以这就像我们只是在跳过那些无论如何都会被过滤的项目。这个优点是，对于大型集合，您不需要两次通过集合进行线性操作，而只需一次。缺点是
    `reduce` 回调函数中增加了复杂性。但是，无论在哪里可以最小化这种复杂性，例如在前面的例子中，将过滤工作转移到 `reduce` 回调函数以优化您的代码。
- en: Min, max, and average operations
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小值、最大值和平均值操作
- en: 'Lo-Dash has functions that help in more complex operations and simultaneously
    let you write clean and concise code. For example, the `min()` and `max()` functions
    accept callbacks that let them be used in a variety of situations, as shown in
    the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 提供了帮助进行更复杂操作的功能，同时让您编写干净、简洁的代码。例如，`min()` 和 `max()` 函数接受回调函数，使它们能够在各种情况下使用，如下面的示例所示：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `score()` function defined in this code reduces the passed-in item to the
    sum of its `scores` property, assumed to be an array. This is meant to be used
    as a callback to the `min()` and `max()` functions. The idea is that `score()`
    is applied to each object in our collection and the minimum or maximum value is
    returned. So we're actually doing two reduce jobs, one for the `scores` property
    and another for the collection.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中定义的 `score()` 函数将传入的项目缩减为其 `scores` 属性的总和，假设它是一个数组。这旨在用作 `min()` 和 `max()`
    函数的回调。想法是 `score()` 被应用于我们集合中的每个对象，并返回最小值或最大值。所以实际上我们正在进行两个缩减工作，一个用于 `scores`
    属性，另一个用于集合。
- en: 'Reducing collections to averages is a little trickier because there''s no Lo-Dash
    function called `avg()` that reduces a collection to an average. Let''s see if
    we can implement something that doesn''t require much more code than the preceding
    example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将集合缩减到平均值稍微复杂一些，因为没有名为 `avg()` 的 Lo-Dash 函数可以将集合缩减到平均值。让我们看看我们是否可以实施一些不需要比前面示例更多代码的方法：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Like the `scores()` callback function before this example, we have an `average()`
    function. This reduces the passed-in items to their average value. Our collection
    is composed of objects, each of which has a `scores` array. We're interested in
    finding the average of the entire collection. So, we'll call `reduce()` on our
    collection. The callback uses the `average()` function to compute the average
    score for each item. This result is then added to the `reduce()` accumulator.
    If we've reached the last item, average is done by checking the collection length.
    Then it's time to compute the final average—an average of averages. Since the
    accumulator is an array of numbers, we can simply return the value generated by
    passing it to `average()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本例之前的`scores()`回调函数一样，我们还有一个`average()`函数。这个函数将传入的项目减少到它们的平均值。我们的集合由对象组成，每个对象都有一个`scores`数组。我们感兴趣的是找到整个集合的平均值。因此，我们将对集合调用`reduce()`。回调函数使用`average()`函数计算每个项目的平均分数。然后将这个结果添加到`reduce()`累加器中。如果我们已经到达最后一个项目，通过检查集合长度来完成平均。然后是计算最终平均值的时刻——平均的平均值。由于累加器是一个数字数组，我们可以简单地通过将其传递给`average()`函数来返回生成的值。
- en: Reducing objects
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少对象
- en: In this section, we will turn our attention to reducing objects and working
    with object accumulators. Reducing objects is a lot like reducing arrays, the
    difference being that you have a key instead of an index. Oh yeah, there's also
    the ordering, which is kind of important—arrays are ordered, objects aren't.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注减少对象和与对象累加器一起工作。减少对象与减少数组非常相似，区别在于你有键而不是索引。哦，对了，还有顺序，这也很重要——数组是有序的，对象则不是。
- en: Previously in the chapter, we caught a glimpse of what accumulators are. Here
    we'll take a deeper look at object accumulators, including some of the built-in
    Lo-Dash functions that utilize this concept.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们瞥见了累加器是什么。在这里，我们将更深入地研究对象累加器，包括一些利用这个概念的内置Lo-Dash函数。
- en: Reducing keys
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少键
- en: 'You can reduce an object to something different based solely on its keys. For
    example, if there are only certain properties you need, you can reduce the object
    to include only those properties, using the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据对象的键将其减少为不同的内容。例如，如果你只需要某些属性，你可以使用以下代码将对象减少到只包含这些属性：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `allowed` array contains the names of allowed property keys, and we're using
    the `reduce()` function to check whether the given key is allowed or not. If it
    is allowed, it gets added to the object accumulator. Otherwise, it's skipped.
    You'll notice that we can achieve the same effect by passing the `allowed` array
    to the `pick()` function. So check what Lo-Dash does out of the box before writing
    your own callback. On the other hand, your own code lends itself to changeability.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowed`数组包含允许的属性键名，我们使用`reduce()`函数来检查给定的键是否允许。如果是允许的，它将被添加到对象累加器中。否则，它将被跳过。你会注意到，我们可以通过将`allowed`数组传递给`pick()`函数来实现相同的效果。所以，在编写自己的回调函数之前，先检查Lo-Dash默认做了什么。另一方面，你自己的代码更容易改变。'
- en: Object accumulators
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象累加器
- en: 'As an alternative to `reduce()`, the `transform()` function is used to transform
    a source object into a target object. The main difference is that with `transform`,
    there''s an implied accumulator. This accumulator object is created when the `transform()`
    function is first called. It''s then passed as a reference to the `callback` function
    for each property, as shown in the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`reduce()`函数的替代方案，`transform()`函数用于将源对象转换为目标对象。主要区别在于使用`transform`时，存在一个隐含的累加器。这个累加器对象是在第一次调用`transform()`函数时创建的。然后，它作为引用传递给每个属性的`callback`函数，如下例所示：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we have an object with two string properties. The `callback` function we
    passed to `transform()` looks for string properties and uses `unescape()` to replace
    any HTML character codes. The `result` argument is here, just as it was in the
    `reduce()` callbacks, but we don't need to return it. We also don't need to supply
    an accumulator object because it is created for us. Let's take a closer look at
    how the accumulator is created.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个具有两个字符串属性的对象。我们传递给`transform()`的`callback`函数寻找字符串属性，并使用`unescape()`替换任何HTML字符代码。`result`参数在这里，就像在`reduce()`回调中一样，但我们不需要返回它。我们也不需要提供累加器对象，因为它为我们创建了。让我们更仔细地看看累加器是如何创建的。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The downside to using `transform()` is that it looks as though you're transforming
    and returning the object that was passed in, which isn't the case. The `transform()`
    function does not touch the source object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `transform()` 的缺点是它看起来像是在转换并返回传入的对象，但实际上并非如此。`transform()` 函数不会修改源对象。
- en: 'Let''s say we''re transforming an instance of a class, rather than just a plain
    object. This can be done using the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在转换一个类的实例，而不仅仅是普通对象。这可以通过以下代码完成：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `object` variable holds an instance of `Person`. Our `transform()` callback
    simply looks for strings and transforms them into their uppercase equivalents.
    When we call the `name()` function on the transformed object, we get the uppercase
    result we expect. Notice that the `name()` method is on the `Person` prototype.
    The `transform()` function constructs the transformed instance properly using
    the appropriate constructor function. This ensures that the prototypical methods
    and properties are where they should be.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`object` 变量持有 `Person` 的一个实例。我们的 `transform()` 回调函数简单地查找字符串并将它们转换为它们的大写等效形式。当我们对转换后的对象调用
    `name()` 函数时，我们得到预期的结果。请注意，`name()` 方法是在 `Person` 原型上。`transform()` 函数使用适当的构造函数正确地构建了转换后的实例。这确保了原型方法和属性位于它们应该的位置。'
- en: 'Lo-Dash has other functions that work along the same lines in terms of object
    accumulators, the difference being that the source is a collection instead of
    an object. For example, you can take a collection and group or index the items,
    as shown in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 有其他一些函数在对象累加器方面与上述函数类似，区别在于源是一个集合而不是一个对象。例如，你可以对集合进行分组或索引项，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `groupBy()` function groups items of the collection according to the value
    of the specified property. That is, if the same two items have the same `position`
    property value, they'll be grouped together under the same object key. On the
    other hand, `indexBy()` will put only one item in a given key. So this function
    is better suited for unique properties such as identifiers. Instead of a `property`
    string, we can pass a function that generates the value if we're so inclined.
    The result of running the `indexBy()` call is an object with unique keys that
    we can use to look up items.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy()` 函数根据指定属性的值对集合中的项进行分组。也就是说，如果两个相同的项具有相同的 `position` 属性值，它们将一起被分组在同一个对象键下。另一方面，`indexBy()`
    将仅将一个项放入给定的键中。因此，这个函数更适合唯一属性，如标识符。如果我们愿意，我们可以传递一个函数来生成值，而不是传递一个 `property` 字符串。`indexBy()`
    调用的结果是具有唯一键的对象，我们可以使用这些键来查找项。'
- en: Binding contexts
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定上下文
- en: 'You might not always want to use anonymous functions, or Lo-Dash functions,
    as your `map()` callback. This is the same case with `reduce()`. Luckily, you
    can easily bind the callback function context in both cases. For example, let''s
    say that you have an application object that is not global. You can still make
    it the context of your callback function, as shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能并不总是想使用匿名函数或 Lo-Dash 函数作为你的 `map()` 回调。`reduce()` 也是如此。幸运的是，你可以轻松地将回调函数的上下文绑定在这两种情况下。例如，假设你有一个不是全局的应用程序对象。你仍然可以将其作为回调函数的上下文，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding example uses the `partialRight()` function to compose a callback
    function. We're partially applying arguments to the `map()` function. The first
    is the callback function and the second is the context of the function, the `app`
    instance in this case. This basically enables the callback function to refer to
    the `this` keyword as the application, despite it not being in the global scope.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用 `partialRight()` 函数来组合回调函数。我们正在部分应用 `map()` 函数的参数。第一个是回调函数，第二个是函数的上下文，在这个例子中是
    `app` 实例。这基本上使得回调函数能够将 `this` 关键字作为应用程序来引用，尽管它不在全局作用域中。
- en: 'The same context-binding principle can be applied to the `reduce()` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的上下文绑定原则也可以应用于 `reduce()` 函数：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the `reduce` callback is a partial function that has a `settings` object
    as its context. This object has a `tax` property that's used to reduce the collection,
    by multiplying its value by each item in the collection. This result is then added
    to the accumulator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`reduce` 回调是一个部分函数，其上下文是 `settings` 对象。该对象有一个 `tax` 属性，用于通过将每个集合中的项的值乘以累加器来减少集合。然后将此结果添加到累加器中。
- en: Map/reduce patterns
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map/reduce 模式
- en: We'll close the chapter with an introduction to some basic map/reduce patterns,
    applicable to everything you've learned in this chapter so far. First, we'll take
    a look at what generic callback functions look like and why they're useful. Then
    we'll introduce the notion of map/reduce chains.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一些基本的 map/reduce 模式来结束这一章，这些模式适用于你到目前为止在本章中学到的所有内容。首先，我们将看看通用回调函数是什么样的，以及为什么它们是有用的。然后我们将介绍
    map/reduce 链的概念。
- en: Generic callback functions
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用回调函数
- en: As the development of your frontend application progresses, you'll start to
    notice that there is some commonality between all of your map/reduce callback
    functions. In other words, you could probably factor the generic aspects of the
    callbacks into a single generic callback. As you've seen throughout this chapter
    and the previous chapter, it's easy to partially apply and compose new functions
    with Lo-Dash. This is especially helpful when you have a handful of generic functions
    that you'd like to use as callbacks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你前端应用程序的发展，你将开始注意到你的所有 map/reduce 回调函数之间有一些共同之处。换句话说，你可能会将回调的通用方面提取到一个单一的通用回调中。正如你在本章和上一章中看到的，使用
    Lo-Dash 部分应用和组合新函数很容易。当你有一系列通用函数想要用作回调时，这特别有帮助。
- en: 'For instance, let''s create some generic `map()` callback functions and see
    how they can be used:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一些通用的 `map()` 回调函数，看看它们如何被使用：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we have two generic functions, `add()` and `upper()`. They both follow
    similar patterns. For example, both refer to the `this.prop` property. So they're
    both context dependent. However, this is a strength, not a weakness. The `add()`
    callback uses `this.prop` to determine which property to manipulate. The `this.value`
    property determines the value to add. As we've seen, it's easy to supply context
    to these functions and that's how we get specific information to these callbacks.
    The `upper()` callback does the same thing, but it transforms the existing property
    to uppercase.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个通用函数，`add()` 和 `upper()`。它们都遵循相似的模式。例如，它们都引用 `this.prop` 属性。因此，它们都是上下文相关的。然而，这是一个优点，而不是缺点。`add()`
    回调使用 `this.prop` 来确定要操作哪个属性。`this.value` 属性确定要添加的值。正如我们所见，为这些函数提供上下文很容易，这就是我们如何将这些特定信息传递给回调的方式。`upper()`
    回调做同样的事情，但它将现有的属性转换为大写。
- en: The `mapAdd()` and `mapUpper()` functions are created as partials, pre-supplying
    the collection and the generic callback function. All that's missing is the context
    and that is supplied when the function is called. This means these functions have
    the potential to be useful throughout the application, getting new contexts when
    called.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapAdd()` 和 `mapUpper()` 函数被创建为部分函数，预先提供了集合和通用的回调函数。唯一缺少的是上下文，这将在函数被调用时提供。这意味着这些函数在整个应用程序中都有可能是有用的，当被调用时可以获取新的上下文。'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's tempting, as with any other programming endeavor to try and create generic
    map/reduce callback functions up-front, that is, trying to foresee where you'll
    need similar but slightly different functionality. The truth is that **hindsight**
    is a powerful tool. It's much easier to see where generic functions become useful
    after you've started to repeat yourself. **Foresight**, on the other hand, tends
    to lead to conceptually useful callback functions that aren't actually needed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他编程任务一样，尝试提前创建通用的 map/reduce 回调函数很诱人，也就是说，试图预见你需要类似但略有不同的功能的地方。但事实是，**事后诸葛亮**是一个强大的工具。在你开始重复自己之后，你会发现通用函数在哪里变得有用要容易得多。另一方面，**先见之明**往往会导致概念上有用的回调函数，但实际上并不需要。
- en: 'All the ideas that apply to generic functions for `map()` callback functions
    also apply to `reduce()` callback functions. Here''s an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于 `map()` 回调函数的通用函数的所有想法也适用于 `reduce()` 回调函数。以下是一个例子：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The generic `sum()` function returns the sum of the two arguments. However,
    it uses `this.prop` to determine which property should be added. Then we proceed
    to create the `reduceSum()` function using `partial()`. Now we can call `reduceSum()`
    with any context we want.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 `sum()` 函数返回两个参数的和。然而，它使用 `this.prop` 来确定应该添加哪个属性。然后我们使用 `partial()` 创建 `reduceSum()`
    函数。现在我们可以用我们想要的任何上下文调用 `reduceSum()`。
- en: Map/reduce chains
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Map/reduce 链
- en: The final pattern we'll look at in this chapter is the notion of a map/reduce
    chain. This is closely related to the map/reduce programming model introduced
    by Google. The idea is that with large datasets, it's easier to tackle computationally
    intensive problems when you can break the problem into a set of mapping operations.
    These operations are then fed to a set of reducing operations. From this perspective,
    it's much easier to distribute the computation across nodes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的最后一个模式是 map/reduce 链的概念。这与 Google 介绍的 map/reduce 编程模型密切相关。想法是，对于大型数据集，当您可以将问题分解为一系列映射操作时，解决计算密集型问题更容易。然后这些操作被馈送到一系列减少操作。从这个角度来看，跨节点分布计算要容易得多。
- en: 'What we''re interested in, however, is the handoff that takes place between
    the map job and the reduce job. The map job is responsible for mapping the source
    data to something that is consumable by the reduce job. This pattern might actually
    repeat several times. For example, a dataset is mapped and then reduced. The result
    of reducing it is then further mapped, and further reduced, and so on. Let''s
    see how something like this looks in Lo-Dash:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们感兴趣的是在映射作业和减少作业之间发生的手续转移。映射作业负责将源数据映射为减少作业可以消费的东西。这种模式实际上可能重复多次。例如，数据集被映射然后减少。减少的结果随后进一步映射，再进一步减少，依此类推。让我们看看在
    Lo-Dash 中这样的操作看起来是什么样子：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we map the collection by computing the amount after adding a `bonus` property
    to the `balance` item for each item. This newly mapped collection is stored in
    the `mapped` variable. Then we reduce the collection to the average rate of increase.
    Note that the reduce callback expects a mapped collection since it makes use of
    the `bonus` property, which isn't in the original collection.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过为每个项目添加一个 `bonus` 属性到 `balance` 项来计算金额，从而映射集合。这个新映射的集合存储在 `mapped` 变量中。然后我们将集合减少到平均增长率。请注意，减少回调期望一个映射集合，因为它使用了
    `bonus` 属性，而这个属性不在原始集合中。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the map/reduce programming model and how Lo-Dash
    tools can help to realize it in your application. First, we examined mapping collections,
    including how to choose which properties get included and how to perform calculations.
    We then moved on to mapping objects. Keys have an important role in how objects
    get mapped to new objects and collections. There are also methods and functions
    to consider when mapping.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了 map/reduce 编程模型以及 Lo-Dash 工具如何帮助您在应用程序中实现它。首先，我们检查了映射集合，包括如何选择包含哪些属性以及如何执行计算。然后我们转向映射对象。键在对象映射到新对象和集合的方式中起着重要作用。在映射时还需要考虑方法和函数。
- en: The second part of the chapter covered reducing, including how to sum items,
    how to transform objects, and how to formulate generic callback functions that
    can be used in a variety of contexts. The chapter closed with a brief look at
    what chaining map/reduce operations together looks like.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分涵盖了减少的内容，包括如何求和项，如何转换对象，以及如何制定通用的回调函数，这些函数可以在各种环境中使用。章节以简要介绍将 map/reduce
    操作链式连接起来的样子结束。
- en: Map/reduce is an important topic because Lo-Dash supports many variations of
    the programming model. It's now time to expand on the chaining concept, and it
    turns out that there's a lot more than just map/reduce functions that can be glued
    together.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Map/reduce 是一个重要的话题，因为 Lo-Dash 支持许多编程模型的变体。现在是时候扩展链式概念了，结果发现，不仅仅是 map/reduce
    函数可以被粘合在一起。
