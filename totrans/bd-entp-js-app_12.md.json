["```js\nconst digest = MD5(message);\n```", "```js\nfunction simpleHash(password) {\n  return SHA256(password);\n}\n\nfunction repeatedHash(password) {\n  const iterations = 64000;\n  let x = 0;\n  let hash = password;\n  while (x < iterations) {\n    hash = SHA256(hash);\n    x++;\n  }\n  return hash;\n}\n```", "```js\nconst salt = crypto.randomBytes(128).toString('base64');\nconst saltedPasswordDigest = MD5(password + salt);\n```", "```js\n--- a/spec/cucumber/features/users/create/main.feature\n+++ b/spec/cucumber/features/users/create/main.feature\n@@ -34,9 +34,9 @@ Feature: Create User\n\n     Examples:\n\n- | missingFields | message                          |\n- | email         | The '.email' field is missing    |\n- | password      | The '.password' field is missing |\n+ | missingFields | message                        |\n+ | email         | The '.email' field is missing  |\n+ | digest        | The '.digest' field is missing |\n```", "```js\n$ yarn add bcryptjs --dev\n```", "```js\nimport { genSaltSync, hashSync } from 'bcryptjs';\n...\nasync function createUser() {\n  ...\n  user.password = crypto.randomBytes(32).toString('hex');\n user.salt = genSaltSync(10);\n user.digest = hashSync(user.password, user.salt);\n  const result = await client.index({ index, type, refresh, \n    body: {\n      email: user.email,\n      digest: user.digest,\n    },\n  });\n  ...\n}\n```", "```js\ngenSaltSync([rounds, seed_length])\n```", "```js\nScenario Outline: Request Payload with invalid digest format\n  When the client creates a POST request to /users\n  And attaches a Create User payload where the digest field is exactly <digest>\n  And sends the request\n  Then our API should respond with a 400 HTTP status code\n  And the payload of the response should be a JSON object\n  And contains a message property which says \"The '.digest' field should be a valid bcrypt digest\"\n\n  Examples:\n\n  | digest                                                       |\n  | jwnY3Iq1bpT5RTsAXKOLnr3ee423zWFU23efwXF27bVKJ4VrDmWA0hZi6YI0 |\n  | $2y$10$a7iPlM2ORVOPr0QNvDf.a.0QKEWwSGRKBaKSqv,40KFGcBuveazjW |\n  | #2y$10$a7iPlM2ORVOPr0QNvDf.a.0QKEWwSGRKBaKSqv.40KFGcBuveazjW |\n```", "```js\n{\n  \"properties\": {\n    \"email\": { ... },\n    \"digest\": { \"type\": \"string\" },\n    \"profile\": { ... }\n  },\n  \"required\": [\"email\", \"digest\"],\n}\n```", "```js\n^\\$2[aby]?\\$\\d{1,2}\\$[.\\/A-Za-z0-9]{53}$\n```", "```js\n\"digest\": {\n  \"type\": \"string\",\n  \"pattern\": \"^\\\\$2[aby]?\\\\$\\\\d{1,2}\\\\$[.\\\\/A-Za-z0-9]{53}$\"\n}\n```", "```js\nif (error.keyword === 'pattern') {\n  return `The '${pathPrefix}${error.dataPath}' field should be a valid bcrypt digest`;\n}\n```", "```js\nit('should return the correct string when error.keyword is \"pattern\"', function () {\n  const errors = [{\n    keyword: 'pattern',\n    dataPath: '.test.path',\n  }];\n  const actualErrorMessage = generateValidationErrorMessage(errors);\n  const expectedErrorMessage = \"The '.test.path' field should be a valid bcrypt digest\";\n  assert.equal(actualErrorMessage, expectedErrorMessage);\n});\n```", "```js\ndb.get({\n  index: process.env.ELASTICSEARCH_INDEX,\n  type: 'user',\n  id: req.params.userId,\n  _sourceExclude: 'digest',\n})\n```", "```js\nFeature: Retrieve Salt and Parameters\n\n  Test that we can create a user using a digest and then retrieve information about the digest's salt and parameters successfully\n\n  Scenario: Retrieve Salt without specifying Email\n\n    When the client creates a GET request to /salt\n    And sends the request\n    Then our API should respond with a 400 HTTP status code\n    And the payload of the response should be a JSON object\n    And contains a message property which says \"The email field must be specified\"\n\n  Scenario: Send Digest and Retrieve Salt\n\n    Given a new user is created with random password and email\n    When the client creates a GET request to /salt\n    And set a valid Retrieve Salt query string\n    And sends the request\n    Then our API should respond with a 200 HTTP status code\n    And the payload of the response should be a string\n    And the payload should be equal to context.salt\n```", "```js\nconst NO_RESULTS_ERROR_MESSAGE = 'no-results';\n\nfunction retrieveSalt(req, db, getSalt) {\n  if (!req.query.email) {\n    return Promise.reject(new Error('Email not specified'));\n  }\n  return db.search({\n    index: process.env.ELASTICSEARCH_INDEX,\n    type: 'user',\n    body: {\n      query: {\n        match: {\n          email: req.query.email,\n        },\n      },\n    },\n    _sourceInclude: 'digest',\n  }).then((res) => {\n    const user = res.hits.hits[0];\n    return user\n      ? user._source.digest\n      : Promise.reject(new Error(NO_RESULTS_ERROR_MESSAGE));\n  }).then(getSalt);\n}\n\nexport default retrieveSalt;\n\n```", "```js\nfunction retrieveSalt(req, res, db, engine, _validator, getSalt) {\n  return engine(req, db, getSalt).then((result) => {\n    res.status(200);\n    res.set('Content-Type', 'text/plain');\n    return res.send(result);\n  }, (err) => {\n    if (err.message === 'Email not specified') {\n      res.status(400);\n      res.set('Content-Type', 'application/json');\n      return res.json({ message: 'The email field must be specified' });\n    }\n    throw err;\n  }).catch(() => {\n    res.status(500);\n    res.set('Content-Type', 'application/json');\n    return res.json({ message: 'Internal Server Error' });\n  });\n}\n\nexport default retrieveSalt;\n```", "```js\nimport { getSalt } from 'bcryptjs';\nimport retrieveSaltHandler from './handlers/auth/salt/retrieve';\nimport retrieveSaltEngine from './engines/auth/salt/retrieve';\nconst handlerToEngineMap = new Map([\n  [retrieveSaltHandler, retrieveSaltEngine],\n  ...\n]);\napp.get('/salt', injectHandlerDependencies(retrieveSaltHandler, client, handlerToEngineMap, handlerToValidatorMap, getSalt));\n\n```", "```js\n$ yarn remove bcryptjs\n$ yarn add bcryptjs\n```", "```js\nfunction injectHandlerDependencies(\n  handler, db, handlerToEngineMap, handlerToValidatorMap, ...remainingArguments\n) {\n  const engine = handlerToEngineMap.get(handler);\n  const validator = handlerToValidatorMap.get(handler);\n  return (req, res) => { handler(req, res, db, engine, validator, ...remainingArguments); };\n}\n\nexport default injectHandlerDependencies;\n```", "```js\n.catch(err => {\n  if (err.status === 404) {\n    return bcrypt.genSaltSync(10);\n  }\n  return Promise.reject(new Error('Internal Server Error'));\n});\n```", "```js\nScenario: Retrieve Salt of Non-Existent User\n\n When the client creates a GET request to /salt\n And set \"email=non@existent.email\" as a query parameter\n And sends the request\n Then our API should respond with a 200 HTTP status code\n And the payload of the response should be a string\n And the response string should satisfy the regular expression /^\\$2a\\$10\\$[a-zA-Z0-9\\.\\/]{22}$/\n\nScenario: Retrieve the same Salt of Non-Existent User over multiple requests\n\n Given the client creates a GET request to /salt\n And set \"email=non@existent.email\" as a query parameter\n And sends the request\n And the payload of the response should be a string\n And saves the response text in the context under salt\n\n When the client creates a GET request to /salt\n And set \"email=non@existent.email\" as a query parameter\n And sends the request\n And the payload of the response should be a string\n And the payload should be equal to context.salt\n```", "```js\nThen(/^the response string should satisfy the regular expression (.+)$/, function (regex) {\n const re = new RegExp(regex.trim().replace(/^\\/|\\/$/g, ''));\n assert.equal(re.test(this.responsePayload), true);\n});\n```", "```js\n$ yarn add random-seed\n```", "```js\nimport randomseed from 'random-seed';\n\nfunction generateFakeSalt(seed) {\n  const salt = randomseed\n\n    // Seed the pseudo-random number generator with a seed so the \n    // output is deterministic\n    .create(seed)\n\n    // Instead of a number, generate a string of sufficient length,\n    // so that even when invalid characters are stripped out,\n    // there will be enough characters to compose the salt\n    .string(110)\n\n    // Replace all characters outside the character range of a valid    \n    //bcrypt salt\n    .replace(/[^a-zA-Z0-9./]/g, '')\n\n    // Extract only the first 22 characters for the salt\n    .slice(0, 22);\n\n  // Prepend the bcrypt algorithm version and cost parameters\n  return `$2a$10$${salt}`;\n}\n\nexport default generateFakeSalt;\n```", "```js\nfunction retrieveSalt(req, db, getSalt, generateFakeSalt) {\n  ...\n    .then(bcrypt.getSalt)\n    .catch((err) => {\n if (err.message === NO_RESULTS_ERROR_MESSAGE) {\n return generateFakeSalt(req.query.email);\n }\n return Promise.reject(new Error('Internal Server Error'));\n });\n}\n```", "```js\nFeature: Login User\n\n  Test that we can create a user using a digest and then perform a login that returns successfully\n\n  Background: Create User with email and password digest\n\n    Given 1 new user is created with random password and email\n\n  Scenario Outline: Bad Client Requests\n    ...\n  Scenario Outline: Bad Request Payload\n    ...\n  Scenario Outline: Request Payload with Properties of Unsupported Type\n    ...\n  Scenario Outline: Request Payload with invalid email format\n    ...\n  Scenario Outline: Request Payload with invalid digest format\n    ...\n```", "```js\n  Scenario: Login without supplying credentials\n    When the client creates a POST request to /login\n    And sends the request\n    Then our API should respond with a 400 HTTP status code\n\n  Scenario: Login attaching a well-formed payload\n\n    When the client creates a POST request to /login\n    And attaches a valid Login payload\n    And sends the request\n    Then our API should respond with a 200 HTTP status code\n    And the payload of the response should be a string\n\n  Scenario Outline: Login attaching a well-formed payload but invalid credentials\n\n    When the client creates a POST request to /login\n    And attaches a Login payload where the <field> field is exactly <value>\n    And sends the request\n    Then our API should respond with a 403 HTTP status code\n\n    Examples:\n\n    | field  | value                                                        |\n    | email  | non@existent.email                                           |\n    | digest | $2a$10$enCaroMp4gMvEmvCe4EuP.0d5FZ6yc0yUuSJ0pQTt4EO5MXvonUTm |\n```", "```js\nimport specialEscape from 'special-escape';\n\nconst specialChars = ['+', '-', '=', '&&', '||', '>', '<', '!', '(', ')', '{', '}', '[', ']', '^', '\"', '~', '*', '?', ':', '\\\\', '/'];\n\nfunction loginUser(req, db, validator, ValidationError) {\n  const validationResults = validator(req);\n  if (validationResults instanceof ValidationError) {\n    return Promise.reject(validationResults);\n  }\n  return db.search({\n    index: process.env.ELASTICSEARCH_INDEX,\n    type: 'user',\n    q: `(email:${specialEscape(req.body.email, specialChars)}) AND (digest:${specialEscape(req.body.digest, specialChars)})`,\n    defaultOperator: 'AND',\n  }).then((res) => {\n    if (res.hits.total > 0) {\n      return 'IDENTIFIER';\n    }\n    return Promise.reject(new Error('Not Found'));\n  });\n}\n\nexport default loginUser;\n```", "```js\n$ yarn add special-escape\n```", "```js\nfunction login(req, res, db, engine, validator, ValidationError) {\n  return engine(req, db, validator, ValidationError)\n    .then((result) => {\n      res.status(200);\n      res.set('Content-Type', 'text/plain');\n      return res.send(result);\n    })\n    .catch((err) => {\n      res.set('Content-Type', 'application/json');\n      if (err instanceof ValidationError) {\n        res.status(400);\n        return res.json({ message: err.message });\n      }\n      if (err.message === 'Not Found') {\n        res.status(401);\n        return res.json({ message: 'There are no records of an user with this email and password combination' });\n      }\n      res.status(500);\n      return res.json({ message: 'Internal Server Error' });\n    });\n}\n\nexport default login;\n```", "```js\nimport validate from '../users/create';\nexport default validate;\n```", "```js\nimport loginValidator from './validators/auth/login';\nimport loginHandler from './handlers/auth/login';\nimport loginEngine from './engines/auth/login';\nconst handlerToEngineMap = new Map([\n  [loginHandler, loginEngine],\n  ...\n]);\nconst handlerToValidatorMap = new Map([\n  [loginHandler, loginValidator],\n]);\napp.post('/login', injectHandlerDependencies(\n  loginHandler, client, handlerToEngineMap, handlerToValidatorMap, ValidationError,\n));\n```", "```js\n<header>.<payload>.<signature>\n```", "```js\neyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9\n.\neyJzdWIiOiJlQG1hLmlsIn0\n.\nm5ZdZVXkUvur6kYndOAtp3nFdhGSqiK5S13s53y0N5EJukYE1pWdaSOY_a3lZEOsDSJ5xsUw5ACxG8VyCWUleQ\n```", "```js\n{ \"alg\": \"HS512\", \"typ\": \"JWT\" }  # Header\n{ \"sub\": \"e@ma.il\" }              # Payload\n```", "```js\n{\n  \"jti\": \"a8f0c4e8e\",\n  \"iss\": \"hobnob.social\",\n  \"sub\": \"e@ma.il\",\n  \"nbf\": 1508886000,\n  \"exp\": 1508972400,\n  \"iat\": 1508274036,\n  \"social.hobnob.permissions\": {\n    \"profile\": {\n      \"delete\": [\"e@ma.il\"]\n    }\n  }\n}\n```", "```js\nconst header = {\n  alg: [algorithm],\n  typ: \"JWT\"\n}\n\nconst payload = {\n  admin: true\n}\n\nconst base64Header = btoa(header);\nconst base64Payload = btoa(payload);\n\nconst jwsSignature = alg(`${base64Header}.${base64Payload}`, [k])\n```", "```js\nAnd the response string should satisfy the regular expression /^[\\w-]+\\.[\\w-]+\\.[\\w-.+\\/=]*$/\nAnd the JWT payload should have a claim with name sub equal to context.userId\n```", "```js\n$ yarn add jsonwebtoken\n```", "```js\nimport assert, { AssertionError } from 'assert';\nimport { decode } from 'jsonwebtoken';\n\nThen(/^the JWT payload should have a claim with name (\\w+) equal to context.([\\w-]+)$/, function (claimName, contextPath) {\n const decodedTokenPayload = decode(this.responsePayload);\n if (decodedTokenPayload === null) {\n throw new AssertionError();\n }\n assert.equal(decodedTokenPayload[claimName], objectPath.get(this, contextPath));\n});\n```", "```js\n$ mkdir keys && ssh-keygen -t rsa -b 4096 -f ./keys/key\n```", "```js\n-----BEGIN RSA PRIVATE KEY-----\nMIIJKAIBAAKCAgEAsTwK1Tireh3TVaJ66yUEAtLPP5tNuqwZW/kA64t7hgIRVKee\n1WjbKLcHIJcAcioHJnqME96M+YRaj/xvlIFSwIbY1CRPgRkqH7kHs6mnrOIvmiRT\n...\n...\n/cH3z0iGJh6WPrrw/xhil4VQ7UUSrD/4GC64r1sFS9wZ6d+PHPtcmlbkbWVQb/it\n2goH/g6WLIKABZNz2uWxmEnT7wOO+++tIPL8q4u1p9pabuO8tsgHX4Tl6O4=\n-----END RSA PRIVATE KEY-----\n```", "```js\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAA....7j7CyQ== username@hostname\n```", "```js\n$ ssh-keygen -f ./keys/key.pub -e -m pem > ./keys/key.pub.pem\n```", "```js\n-----BEGIN RSA PUBLIC KEY-----\nMIICCgKCAgEAsTwK1Tireh3TVaJ66yUEAtLPP5tNuqwZW/kA64t7hgIRVKee1Wjb\nKLcHIJcAcioHJnqME96M+YRaj/xvlIFSwIbY1CRPgRkqH7kHs6mnrOIvmiRTPxSO\n...\nXjxHHzaebcsy1ccp3cUHP2/3WOAz35x1UdFvYwQ/Qjh9Ud1Yoe4+wskCAwEAAQ==\n-----END RSA PUBLIC KEY-----\n```", "```js\nPRIVATE_KEY=\"-----BEGIN RSA PRIVATE KEY-----\\nMIIJKAIBAAKCAgEAsTwK1Tireh3TVaJ66yUEAtLPP5tNuqwZW/kA64t7hgIRVKee\\n1WjbKLcHIJcAcioHJnqME96M+YRaj/xvlIFSwIbY1CRPgRkqH7kHs6mnrOIvmiRT\\nPxSOtzy........tsgHX4Tl6O4=\\n-----END RSA PRIVATE KEY-----\"\nPUBLIC_KEY=\"-----BEGIN RSA PUBLIC KEY-----\\nMIICCgKCAgEAsTwK1Tireh3TVaJ66yUEAtLPP5tNuqwZW/kA64t7hgIRVKee1Wjb\\nKLcHIJcAcioHJnqME96M+YRaj/xvlIFSwIbY1CRPgRkqH7kHs6mnrOIvmiRTPxSO\\ntzydJxN........+wskCAwEAAQ==\\n-----END RSA PUBLIC KEY-----\"\n```", "```js\nfunction loginUser(req, db, validator, ValidationError, sign) {\n  ...\n  return client.search( ... )\n    .then((res) => {\n      if (res.hits.total > 0) {\n const payload = { sub: res.hits.hits[0]._id };\n const options = { algorithm: 'RS512' };\n const token = sign(payload, process.env.PRIVATE_KEY, options);\n return token;\n      }\n      return Promise.reject(new Error('Not Found'));\n    });\n}\n```", "```js\nSet-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>; Expires=<date>\n```", "```js\nCookie: name1=value1; name2=value2\n```", "```js\ndocument.write('<img src=\"img/collect.gif?cookie=' + document.cookie + '\" />')\n```", "```js\n<img src=\"img/?newPassword=foobar\">\n```", "```js\nAuthorization: <type> <credentials>\n```", "```js\nAuthorization: Bearer eyJhbGciOiJSUzUxMiIsInR5cCI6I...2ufQdDkg\n```", "```js\nFeature: Delete User by ID\n\n  Clients should be able to send a request to our API in order to delete a user.\n\n  Background: Create two Users and logs in with the first user's account\n\n    Given 2 new users are created with random password and email\n    And the client creates a POST request to /login\n    And attaches a valid Login payload\n    And sends the request\n    And saves the response text in the context under token\n\n  Scenario Outline: Wrong Authorization Header Scheme\n\n    When the client creates a DELETE request to /users/:userId\n    And set the HTTP header field \"Authorization\" to \"<header>\"\n    And sends the request\n    Then our API should respond with a 400 HTTP status code\n    And the payload of the response should be a JSON object\n    And contains a message property which says \"The Authorization header should use the Bearer scheme\"\n\n    Examples:\n\n    | header                |\n    | Basic e@ma.il:hunter2 |\n\n  Scenario Outline: Invalid Token Format\n\n    When the client creates a DELETE request to /users/:userId\n    And set the HTTP header field \"Authorization\" to \"Bearer <token>\"\n    And sends the request\n    Then our API should respond with a 400 HTTP status code\n    And the payload of the response should be a JSON object\n    And contains a message property which says \"The credentials used in the Authorization header should be a valid bcrypt digest\"\n\n    Examples:\n\n    | token                                                        |\n    |                                                              |\n    | 6g3$d21\"dfG9),Ol;UD6^UG4D£SWerCSfgiJH323£!AzxDCftg7yhjYTEESF |\n    | $2a$10$BZze4nPsa1D8AlCue76.sec8Z/Wn5BoG4kXgPqoEfYXxZuD27PQta |\n\n  Scenario: Delete Self with Token with Wrong Signature\n\n    The user is trying to delete its own account, the token contains the correct payload, but the signature is wrong.\n\n    When the client creates a DELETE request to /users/:userId\n    And sets the Authorization header to a token with wrong signature\n    And sends the request\n    Then our API should respond with a 400 HTTP status code\n    And the payload of the response should be a JSON object\n    And contains a message property which says \"Invalid signature in token\"\n\n  Scenario: Delete Self\n\n    When the client creates a DELETE request to /users/:userId\n    And sets the Authorization header to a valid token\n    And sends the request\n    Then our API should respond with a 200 HTTP status code\n\n    When the client creates a GET request to /users/:userId\n    And sends the request\n    Then our API should respond with a 404 HTTP status code\n\n  Scenario: Delete Non-existing User\n\n    When the client creates a DELETE request to /users/:userId\n    And sets the Authorization header to a valid token\n    And sends the request\n    Then our API should respond with a 200 HTTP status code\n\n    When the client creates a DELETE request to /users/:userId\n    And sets the Authorization header to a valid token\n    And sends the request\n    Then our API should respond with a 404 HTTP status code\n\n  Scenario: Delete Different User\n\n    A user can only delete him/herself. When trying to delete another user, it should return with 403 Forbidden.\n\n    When the client creates a DELETE request to /users/:users.1.id\n    And sets the Authorization header to a valid token\n    And sends the request\n    Then our API should respond with a 403 HTTP status code\n    And the payload of the response should be a JSON object\n    And contains a message property which says \"Permission Denied. Can only delete yourself, not other users.\"\n```", "```js\nWhen(/^set the HTTP header field (?:\"|')?([\\w-]+)(?:\"|')? to (?:\"|')?(.+)(?:\"|')?$/, function (headerName, value) {\n  this.request.set(headerName, value);\n});\n\nWhen(/^sets the Authorization header to a valid token$/, function () {\n  this.request.set('Authorization', `Bearer ${this.token}`);\n});\n\nWhen(/^sets the Authorization header to a token with wrong signature$/, function () {\n  // Appending anything to the end of the signature will invalidate it\n  const tokenWithInvalidSignature = `${this.token}a`;\n  this.request.set('Authorization', `Bearer ${tokenWithInvalidSignature}`);\n});\n```", "```js\nfunction authenticate (req, res, next) {}\nexport default authenticate;\n```", "```js\nif (req.method === 'GET') { return next(); }\n```", "```js\nif (req.method === 'GET' || req.method === 'OPTIONS') { return next(); }\n```", "```js\nif (req.method === 'POST' && req.path === '/users') { return next(); }\nif (req.method === 'POST' && req.path === '/login') { return next(); }\n```", "```js\nconst authorization = req.get('Authorization');\n\nif (authorization === undefined) {\n  res.status(401);\n  res.set('Content-Type', 'application/json');\n  return res.json({ message: 'The Authorization header must be set' });\n}\n```", "```js\nconst [scheme, token] = authorization.split(' ');\nif (scheme !== 'Bearer') {\n  res.status(400);\n  res.set('Content-Type', 'application/json');\n  return res.json({ message: 'The Authorization header should use the Bearer scheme' });\n}\n```", "```js\nconst jwtRegEx = /^[\\w-]+\\.[\\w-]+\\.[\\w-.+/=]*$/;\n\n// If no token was provided, or the token is not a valid JWT token, return with a 400\nif (!token || !jwtRegEx.test(token)) {\n  res.status(400);\n  res.set('Content-Type', 'application/json');\n  return res.json({ message: 'The credentials used in the Authorization header should be a valid bcrypt digest' });\n}\n```", "```js\nimport { JsonWebTokenError, verify } from 'jsonwebtoken';\n\nverify(token, process.env.PUBLIC_KEY, { algorithms: ['RS512'] }, (err, decodedToken) => {\n  if (err) {\n    if (err instanceof JsonWebTokenError && err.message === 'invalid signature') {\n      res.status(400);\n      res.set('Content-Type', 'application/json');\n      return res.json({ message: 'Invalid signature in token' });\n    }\n    res.status(500);\n    res.set('Content-Type', 'application/json');\n    return res.json({ message: 'Internal Server Error' });\n  }\n  req.user = Object.assign({}, req.user, { id: decodedToken.sub });\n  return next();\n});\n```", "```js\nimport authenticate from './middlewares/authenticate';\n...\napp.use(bodyParser.json({ limit: 1e6 }));\napp.use(authenticate);\napp.get('/salt', ...);\n...\n```", "```js\nif (req.params.userId !== req.user.id) {\n return Promise.reject(new Error('Forbidden'));\n}\n```", "```js\nfunction del(req, res) {\n  return engine(req)\n    .then(() => { ... })\n    .catch((err) => {\n      if (err.message === 'Not Found') { ... }\n      if (err.message === 'Forbidden') {\n        res.status(403);\n        res.set('Content-Type', 'application/json');\n        res.json({ message: 'Permission Denied. Can only delete yourself, not other users.' });\n        return err;\n      }\n      ...\n    })\n}\n```", "```js\nconst ciphertext = encrypt(plaintext, key);\n```", "```js\nconst plaintext = decrypt(ciphertext, key);\n```"]