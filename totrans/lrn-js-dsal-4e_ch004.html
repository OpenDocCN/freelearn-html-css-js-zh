<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning JavaScript Data Structures and Algorithms - Fourth Edition</title>


</head>
<body>
<div><div><h1 data-number="4">3 Arrays</h1>
<p><strong>Before you begin: Join our book community on Discord</strong></p>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p>
<img style="width:10rem;" src="img/file0.png" width="200" height="200"/>
</p>
<a href="https://packt.link/EarlyAccess/">https://packt.link/EarlyAccess/</a>
<p>An <strong>array</strong> is the simplest memory data structure. For this reason, all programming languages have a built-in array datatype. JavaScript also supports arrays natively, even though its first version was released without array support. In this chapter, we will dive into the array data structure and its capabilities.</p>
<p>An array stores values sequentially that are all the same datatype. Although JavaScript allows us to create arrays with values from different datatypes, we will follow best practices and assume that we cannot do this (most languages do not have this capability).</p>

<h2 data-number="4.1">Why should we use arrays?</h2>
<p>Let's consider that we need to store the average temperature of each month of the year of the city that we live in. We could use something like the following code snippet to store this information:</p>
<div><pre><code>const averageTempJan = 12;
const averageTempFeb = 15;
const averageTempMar = 18;
const averageTempApr = 20;
const averageTempMay = 25;</code></pre>
</div>
<p>However, this is not the best approach. If we store the temperature for only one year, we could manage 12 variables. However, what if we need to store the average temperature for 50 years? Fortunately, this is why arrays were created, and we can easily represent the same information mentioned earlier as follows:</p>
<div><pre><code>const averageTemp = [12, 15, 18, 20, 25];
// or
averageTemp[0] = 12;
averageTemp[1] = 15;
averageTemp[2] = 18;
averageTemp[3] = 20;
averageTemp[4] = 25;</code></pre>
</div>
<p>We can also represent the <code>averageTemp</code> array graphically:</p>
<figure>
<img src="img/file9.png" alt="Figure 3.1:" width="1212" height="248"/><figcaption aria-hidden="true">Figure 3.1:</figcaption>
</figure>


<h2 data-number="4.2">Creating and initializing arrays</h2>
<p>Declaring, creating, and initializing an array in JavaScript is straightforward, as shown in the following example:</p>
<div><pre><code>let daysOfWeek = new Array(); // {1}
daysOfWeek = new Array(7); // {2}
daysOfWeek = new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'); // {3}
// preferred
daysOfWeek = []; // {4}
daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; // {5}</code></pre>
</div>
<p>We can:</p>
<ul>
<li>Line <code>{1}</code>: declare and instantiate a new array using the keyword <code>new</code> – this will create an empty array.</li>
<li>Line <code>{2}</code>: create an empty array specifying the <em>length</em> of the array (how many elements we are planning to store in the array).</li>
<li>Line <code>{3}</code>: create and initialize the array, passing the elements directly in the constructor.</li>
<li>Line <code>{4}</code>: create an empty array assigning empty brackets (<code>[]</code>). Using the keyword <code>new</code> is not considered a best practice, therefore, using brackets is the preferred way.</li>
<li>Line <code>{5}</code>: create and initialize the array using brackets as a best practice.</li>
</ul>
<p>If we want to know how many elements are in the array (its size), we can use the <code>length</code> property. The following code will give an output of <code>7</code>:</p>
<div><pre><code>console.log('daysOfWeek.length', daysOfWeek.length); // output: 7</code></pre>
</div>


<h2 data-number="4.3">Accessing elements and iterating an array</h2>
<p>To access a specific position of the array, we can also use brackets, passing the index of the position we would like to access. For example, let's say we want to output all the elements from the <code>daysOfWeek</code> array. To do so, we need to loop the array and print the elements, starting from index 0 as follows:</p>
<div><pre><code>for (let i = 0; i &lt; daysOfWeek.length; i++) {
  console.log(`daysOfWeek[${i}]`, daysOfWeek[i]);
}</code></pre>
</div>
<p>Let's look at another example. Suppose that we want to find out the first 20 numbers of the <em>Fibonacci</em> sequence. The first two numbers of the Fibonacci sequence are 1 and 2, and each subsequent number is the sum of the previous two numbers:</p>
<div><pre><code>// Fibonacci: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
const fibonacci = []; // {1}
fibonacci[1] = 1; // {2}
fibonacci[2] = 1; // {3}
// create the fibonacci sequence starting from the 3rd element
for (let i = 3; i &lt; 20; i++) {
  fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2]; // //{4}
}
// display the fibonacci sequence
for (let i = 1; i &lt; fibonacci.length; i++) { // {5}
  console.log(`fibonacci[${i}]`, fibonacci[i]); // {6}
}</code></pre>
</div>
<p>The following is the explanation for the preceding code:</p>
<ol>
<li>In line <code>{1}</code>, we declared and created an array.</li>
<li>In lines <code>{2}</code> and <code>{3}</code>, we assigned the first two numbers of the Fibonacci sequence to the second and third positions of the array (in JavaScript, the first position of the array is always referenced by 0 (zero), and since as there is no zero in the Fibonacci sequence, we will skip it).</li>
<li>Then, all we need to do is create the third to the 20th number of the sequence (as we know the first two numbers already). To do so, we can use a loop and assign the sum of the previous two positions of the array to the current position (line <code>{4}</code>, starting from index 3 of the array to the 19th index).</li>
<li>Then, to take a look at the output (line <code>{6}</code>), we just need to loop the array from its first position to its length (line <code>{5}</code>).</li>
</ol>
<blockquote>
<p>We can use <code>console.log</code> to output each index of the array (lines <code>{5}</code> and <code>{6}</code>), or we can also use <code>console.log(fibonacci)</code> to output the array itself.</p>
</blockquote>
<p>If you would like to generate more than 20 numbers of the Fibonacci sequence, just change the number 20 to whatever number you like.</p>

<h3 data-number="4.3.1">Using the for..in loop</h3>
<p>The benefit of using the <code>for..in</code> loop, is we do not have to keep track of the length of the array, as the loop will iterate through all the array indexes. The following code achieves the same output as the previous <code>for</code> loop.</p>
<div><pre><code>for (const i in fibonacci) {
  console.log(`fibonacci[${i}]`, fibonacci[i]);
}</code></pre>
</div>
<p>It is another way to write the loop, and you can use the one you feel most comfortable with.</p>


<h3 data-number="4.3.2">Using the for…of loop</h3>
<p>Another approach, in case you would like to directly extract the values of the array, is to use the <code>for..of</code> loop as follows:</p>
<div><pre><code>for (const value of fibonacci) {
  console.log('value', value);
}</code></pre>
</div>
<p>With this loop, we do not need to access each index of the array to retrieve the value, as the value present in each position can be accessed directly in the loop.</p>



<h2 data-number="4.4">Adding elements</h2>
<p>Adding and removing elements from an array is not that difficult; however, it can be tricky. For the examples we will create in this section, let's consider that we have the following numbers array initialized with numbers from 0 to 9:</p>
<div><pre><code>let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</code></pre>
</div>

<h3 data-number="4.4.1">Inserting an element at the end of the array</h3>
<p>If we want to add a new element to this array (for example, the number 10), all we have to do is reference the last free position of the array and assign a value to it:</p>
<div><pre><code>numbers[numbers.length] = 10;</code></pre>
</div>
<blockquote>
<p>In JavaScript, an array is a mutable object. We can easily add new elements to it. The object will grow dynamically as we add new elements to it. In many other languages, such as C and Java, we need to determine the size of the array, and if we need to add more elements to the array, we need to create a completely new array; we cannot simply add new elements to it as we need them.</p>
</blockquote>

<h4 data-number="4.4.1.1">Using the push method</h4>
<p>The JavaScript API also has a method called <code>push</code> that allows us to add new elements to the end of an array. We can add as many elements as we want as arguments to the push method:</p>
<div><pre><code>numbers.push(11); 
numbers.push(12, 13);</code></pre>
</div>
<p>The output of the numbers array will be the numbers from 0 to 13.</p>



<h3 data-number="4.4.2">Inserting an element in the first position</h3>
<p>Suppose we need to add a new element to the array (the number <code>-1</code>) and would like to insert it in the first position, not the last one. To do so, first we need to free the first position by shifting all the elements to the right. We can loop all the elements of the array, starting from the last position (value of <code>length</code> will be the end of the array) and shifting the previous element (<code>i-1</code>) to the new position (<code>i</code>) to finally assign the new value we want to the first position (index 0). We can create a function to represent this logic or even add a new method directly to the Array prototype, making the <code>insertAtBeginning</code> method available to all array instances. The following code represents the logic described here:</p>
<div><pre><code>Array.prototype.insertAtBeginning = function(value) { 
    for (let i = this.length; i &gt;= 0; i--) { 
      this[i] = this[i - 1]; 
    } 
    this[0] = value; 
  };  
numbers.insertAtBeginning(-1);</code></pre>
</div>
<p>We can represent this action with the following diagram:</p>
<figure>
<img src="img/file10.png" alt="Figure 3.2:" width="584" height="364"/><figcaption aria-hidden="true">Figure 3.2:</figcaption>
</figure>

<h4 data-number="4.4.2.1">Using the unshift method</h4>
<p>The JavaScript Array class also has a method called <code>unshift</code>, which inserts the values passed in the method's arguments at the start of the array (the logic behind-the-scenes has the same behavior as the <code>insertAtBeginning </code>method):</p>
<div><pre><code>numbers.unshift(-2); 
numbers.unshift(-4, -3); </code></pre>
</div>
<p>So, using the <code>unshift</code> method, we can add the value -2 and then -3 and -4 to the beginning of the <code>numbers</code> array. The output of this array will be the numbers from -4 to 13.</p>




<h2 data-number="4.5">Removing elements</h2>
<p>So far, you have learned how to add elements in the array. Let's look at how we can remove a value from an array.</p>

<h3 data-number="4.5.1">Removing an element from the end of the array</h3>
<p>To remove a value from the end of an array, we can use the pop method:</p>
<div><pre><code>numbers.pop(); // number 13 is removed</code></pre>
</div>
<p>The <code>pop</code> method also returns the value that is being removed and it returns <code>undefined</code> in case no element is being removed (the array is empty). So, if needed, we can also capture the value that is being returned into a variable or into the console instead:</p>
<div><pre><code>console.log('Removed element: ', numbers.pop());</code></pre>
</div>
<p>The output of our array will be the numbers from -4 to 12 (after removing one number). The length (size) of our array is 17.</p>
<blockquote>
<p>The <code>push</code> and <code>pop</code> methods allow an array to emulate a basic <code>stack</code> data structure, which is the subject of the next chapter.</p>
</blockquote>


<h3 data-number="4.5.2">Removing an element from the first position</h3>
<p>To manually remove a value from the beginning of the array, we can use the following code:</p>
<div><pre><code>for (let i = 0; i &lt; numbers.length; i++) { 
  numbers[i] = numbers[i + 1]; 
} </code></pre>
</div>
<p>We can represent the previous code using the following diagram:</p>
<figure>
<img src="img/file11.png" alt="Figure 3.3:" width="624" height="371"/><figcaption aria-hidden="true">Figure 3.3:</figcaption>
</figure>
<p>We shifted all the elements one position to the left. However, the length of the array is still the same (<code>16</code>), meaning we still have an extra element in our array (with an <code>undefined</code> value). The last time the code inside the loop was executed, <code>i+1</code> was a reference to a position that does not exist. In some languages, such as Java, C/C++, or C#, the code would throw an exception, and we would have to end our loop at <code>numbers.length -1</code>.</p>
<p>We have only overwritten the array's original values, and we did not really remove the value (as the length of the array is still the same and we have this extra <code>undefined</code> element).</p>
<p>To remove the value from the array, we can also create a <code>removeFromBeginning</code> method with the logic described in this topic. However, to really remove the element from the array, we need to create a new array and copy all values other than <code>undefined</code> values from the original array to the new one and assign the new array to our variable. To do so, we can also create a <code>reIndex</code> method as follows:</p>
<div><pre><code>Array.prototype.reIndex = function(myArray) {  
    const newArray = []; 
    for(let i = 0; i &lt; myArray.length; i++ ) { 
        if (myArray[i] !== undefined) { 
            newArray.push(myArray[i]); 
        } 
    } 
    return newArray; 
} 
// remove first position manually and reIndex 
Array.prototype.removeFromBeginning = function() { 
    for (let i = 0; i &lt; this.length; i++) { 
        this[i] = this[i + 1]; 
    } 
    return this.reIndex(this); 
}; 
numbers = numbers.removeFromBeginning();</code></pre>
</div>
<blockquote>
<p>The preceding code should be used only for educational purposes and should not be used in real projects. To remove the first element from the array, we should always use the <code>shift</code> method, which is presented in the next section.</p>
</blockquote>

<h4 data-number="4.5.2.1">Using the shift method</h4>
<p>To remove an element from the beginning of the array, we can use the shift method, as follows:</p>
<div><pre><code>numbers.shift(); </code></pre>
</div>
<p>If we consider that our array has the values -4 to 12 and a length of 17 after we execute the previous code, the array will contain the values -3 to 12 and have a length of 16.</p>
<blockquote>
<p>The <code>shift</code> and <code>unshift</code> methods allow an array to emulate a basic <code>queue</code> data structure, which is the subject of <em>Chapter 5, Queues and Deques.</em></p>
</blockquote>




<h2 data-number="4.6">Adding and removing elements from a specific position</h2>
<p>So far, we have learned how to add elements at the end and at the beginning of an array, and we have also learned how to remove elements from the beginning and end of an array. What if we also want to add or remove elements from any position in our array? How can we do this?</p>
<p>We can use the <code>splice</code> method to remove an element from an array by specifying the position/index that we would like to delete from and how many elements we would like to remove, as follows:</p>
<div><pre><code>numbers.splice(5,3); </code></pre>
</div>
<p>This code will remove three elements, starting from index <code>5</code> of our array. This means the elements <code>numbers[5]</code>, <code>numbers[6]</code>, and <code>numbers[7]</code> will be removed from the numbers array. The content of our array will be <code>-3, -2, -1, 0, 1, 5, 6, 7, 8, 9, 10, 11</code>, and <code>12</code> (as the numbers <code>2</code>, <code>3</code>, and <code>4</code> have been removed).</p>
<blockquote>
<p>As with JavaScript arrays and objects, we can also use the <code>delete</code> operator to remove an element from the array, for example, <code>delete numbers[0]</code>. However, position <code>0</code> of the array will have the value <code>undefined</code>, meaning that it would be the same as doing <code>numbers[0] = undefined</code> and we would need to re-index the array. For this reason, we should always use the <code>splice</code>, <code>pop</code>, or <code>shift</code> methods to remove elements.</p>
</blockquote>
<p>Now, let's say we want to insert numbers 2, 3 and 4 back into the array, starting from position 5. We can again use the splice method to do this:</p>
<div><pre><code>numbers.splice(5, 0, 2, 3, 4); </code></pre>
</div>
<p>The first argument of the method is the index we want to remove elements from or insert elements into. The second argument is the number of elements we want to remove (in this case, we do not want to remove any, so we will pass the value 0 (zero)). And from the third argument onward we have the values we would like to insert into the array (the elements 2, 3, and 4). The output will be values from -3 to 12 again.</p>
<p>Finally, let's execute the following code:</p>
<div><pre><code>numbers.splice(5, 3, 2, 3, 4); </code></pre>
</div>
<p>The output will be values from -3 to 12. This is because we are removing three elements, starting from the index 5, and we are also adding the elements 2, 3, and 4, starting at index 5.</p>


<h2 data-number="4.7">Iterator methods</h2>
<p>JavaScript also has some built in methods as part of the Array API that are extremely useful in the day-to-day coding tasks. These methods accept a callback function that we can use to manipulate the data in the array as needed.</p>
<p>Let's look at these methods. Consider the following array used as a base for the examples in this section:</p>
<div><pre><code>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</code></pre>
</div>

<h3 data-number="4.7.1">Iterating using the forEach method</h3>
<p>If we need the array to be completely iterated no matter what, we can use the <code>forEach</code> function. It has the same result as using a <code>for</code> loop with the function's code inside it, as follows:</p>
<div><pre><code>numbers.forEach((value, index) =&gt; {
  console.log(`numbers[${index}]`, value);
});</code></pre>
</div>
<p>Most of the times, we are only interested in using the value coming from each position of the array, without having to access each position as the preceding example. Following is a more concise example:</p>
<div><pre><code>numbers.forEach(value =&gt; console.log(value));</code></pre>
</div>
<p>Depending on personal preference you can use this method or the traditional <code>for</code> loop. Performance wise, both approaches are <em>O(n)</em>, meaning linear time, as it will iterate through all the values of the array.</p>


<h3 data-number="4.7.2">Iterating using the every method</h3>
<p>The <code>every</code> method iterates each element of the array until the function returns <code>false</code>. Let's see an example:</p>
<div><pre><code>const isBelowSeven = numbers.every(value =&gt; value &lt; 7);
console.log('All values are below 7?:', isBelowSeven); // false</code></pre>
</div>
<p>The method will iterate through every value within the array until it finds a value equal or bigger than 7. For the preceding example, it returns <code>false</code> as we have the value 7 within our array of numbers. If we did not have values bigger or equal to 7, the variable <code>isBelowSeven</code> would have the value <code>true</code>.</p>
<p>We can rewrite this example using a for loop to understand how it works internally:</p>
<div><pre><code>let isBelowSevenForLoop = true;
for (let i = 0; i &lt; numbers.length; i++) {
  if (numbers[i] &gt;= 7) {
    isBelowSevenForLoop = false;
    break;
  }
}
console.log('All values are below 7?:', isBelowSevenForLoop);</code></pre>
</div>
<p>The <code>break</code> statement will stop the loop at the moment that a value equal or bigger to 7 is found.</p>
<p>By using the <code>every</code> method, we can have more concise code to achieve the same result.</p>


<h3 data-number="4.7.3">Iterating using the some method</h3>
<p>The <code>some</code> method has the opposite behavior to the <code>every</code> method. However, the <code>some</code> method iterates each element of the array until the return of the function is <code>true</code>. Here's an example:</p>
<div><pre><code>const isSomeValueBelowSeven = numbers.some(value =&gt; value &lt; 7);
console.log('Is any value below 7?:', isSomeValueBelowSeven); // true</code></pre>
</div>
<p>In this example, the first number of the array is 1, and it will return true right away, stopping the execution of the code.</p>
<p>We can rewrite the preceding code using a for loop <code>for</code> better understanding of the logic:</p>
<div><pre><code>let isSomeValueBelowSevenForLoop = false;
for (let i = 0; i &lt; numbers.length; i++) {
  if (numbers[i] &lt; 7) {
    isSomeValueBelowSevenForLoop = true;
    break;
  }
}</code></pre>
</div>



<h2 data-number="4.8">Searching an array</h2>
<p>The JavaScript API provides a few different methods we can use to search or find elements in an array. Although we will learn how to re-create classic algorithms to search elements in <em>Chapter 15, Searching and Shuffling Algorithms</em>, it is always good to know we can use existing APIs without having to write the code ourselves.</p>
<p>Let's take a look at the existing JavaScript methods that allows us to search elements in an array.</p>

<h3 data-number="4.8.1">Searching with indexOf, lastIndexOf and includes methods</h3>
<p>The methods <code>indexOf</code>, <code>lastIndexOf</code> and <code>includes</code> have a very similar sintax as follows:</p>
<ul>
<li><code>indexOf(element, fromIndex)</code>: searches for the <code>element</code> starting from the index <code>fromIndex</code>, and in case the element exists, returns its index, otherwise returns the value <code>-1</code>.</li>
<li><code>includes(element, fromIndex)</code>: searches for the <code>element</code> starting from the index <code>fromIndex</code>, and in case the element exists, returns <code>true</code>, otherwise returns <code>false</code>.</li>
</ul>
<p>If we try to search for a number in our <code>numbers</code> array, let's check if the number 5 exists:</p>
<div><pre><code>console.log('Index of 5:', numbers.indexOf(5)); // 4
console.log('Index of 11:', numbers.indexOf(11)); // -1
console.log('Is 5 included?:', numbers.includes(5)); // true
console.log('Is 11 included?:', numbers.includes(11)); // false</code></pre>
</div>
<p>If we would like to search in the entire array, we can omit the <code>fromIndex</code>, and by default, the index 0 will be used.</p>
<p>The <code>lastIndexOf</code> is similar as well, however, it will return the index of the last element found that matches the element we are searching. Think about it as a search from the end of the array towards the beginning of the array instead:</p>
<div><pre><code>console.log('Last index of 5:', numbers.lastIndexOf(5)); // 4
console.log('Last index of 11:', numbers.lastIndexOf(11)); // -1</code></pre>
</div>
<p>This method is useful when we have duplicate elements in the array.</p>


<h3 data-number="4.8.2">Searching with find, findIndex and findLastIndex methods</h3>
<p>In real world tasks, we often work with more complex objects. The <code>find</code> and <code>findIndex</code> methods are especially useful for more complex scenarios, but it does not mean we cannot use them for simpler cases.</p>
<p>Both <code>find</code> and <code>findIndex</code> methods receive a callback function that will search for an element that satisfies the condition presented in the testing function (callback). Let's start with a simple example: suppose you want to find the first number in the array that has a value below 7. We can use the following code:</p>
<div><pre><code>const firstValueBelowSeven = numbers.find(value =&gt; value &lt; 7);
console.log('First value below 7:', firstValueBelowSeven); // 1</code></pre>
</div>
<p>We are using a callback function that is an arrow function to test every element of the array (<code>value &lt; 7</code>), and the first element that returns <code>true</code> will be returned. That is why the output is <code>1</code>, as it is the first element of the array.</p>
<p>The <code>findIndex</code> method is similar, however it will return the index of the element instead of the element itself:</p>
<div><pre><code>console.log('Index: ', numbers.findIndex(value =&gt; value &lt; 7)); // 0</code></pre>
</div>
<p>Likewise, there is also a findLastIndex method, which will return the last index of the element that matches the callback function:</p>
<div><pre><code>console.log('Index of last value below 7:', numbers.findLastIndex(value =&gt; value &lt; 7)); // 5</code></pre>
</div>
<p>In the preceding example, the index 5 is returned because the number 6 is the last element in the array lower than 7.</p>
<p>Now let's check a more complex example, closer to real life. Consider the following array, a collection of books:</p>
<div><pre><code>const books = [
    { id: 1, title: 'The Fellowship of the Ring' },
    { id: 2, title: 'Fourth Wing' },
    { id: 3, title: 'A Court of Thorns and Roses' }
];</code></pre>
</div>
<p>If we need to find the book with <code>id</code> 2, we can use the find method:</p>
<div><pre><code>console.log('Book with id 2:', books.find(book =&gt; book.id === 2));</code></pre>
</div>
<p>It will output <code>{ id: 2, title: 'Fourth Wing' }</code>. If we try to find the book "The Hobbit," we will get the output undefined, because this book is not present in the array:</p>
<div><pre><code>console.log(books.find(book =&gt; book.title === 'The Hobbit'));</code></pre>
</div>
<p>Suppose we would like to remove the book with <code>id</code> 3 from our array. We can find the index of the book first, and then use the method <code>splice</code> to remove the book in the given index:</p>
<div><pre><code>const bookIndex = books.findIndex(book =&gt; book.id === 3);
if (bookIndex !== -1) {
    books.splice(bookIndex, 1);
}</code></pre>
</div>
<p>And of course, it is always good to check if the book was found first (the <code>bookIndex</code> is different than -1) before trying to remove the book from the list to avoid any errors in our logic.</p>


<h3 data-number="4.8.3">Filtering elements</h3>
<p>Let's revisit the following example one more time:</p>
<div><pre><code>const firstValueBelowSeven = numbers.find(value =&gt; value &lt; 7);
console.log('First value below 7:', firstValueBelowSeven); // 1</code></pre>
</div>
<p>The <code>find</code> method returns the first element that matches the given condition. What if we would like to know all elements below 7 in the array? That is when the <code>filter</code> method comes in handy:</p>
<div><pre><code>const valuesBelowSeven = numbers.filter(value =&gt; value &lt; 7);
console.log('Values below 7:', valuesBelowSeven); // [1, 2, 3, 4, 5, 6]</code></pre>
</div>
<p>The <code>filter</code> method returns an array of all matching elements, and the output will be: <code>[1, 2, 3, 4, 5, 6]</code>.</p>



<h2 data-number="4.9">Sorting elements</h2>
<p>Throughout this book, you will learn how to write the most used sorting algorithms. However, JavaScript also has a sorting method available which we can use without having to write our own logic whenever we need to sort arrays.</p>
<p>First, let's take our numbers array and put the elements out of order (<code>[1, 2, 3, ... 10]</code> is already sorted). To do this, we can apply the <code>reverse</code> method, in which the last item will be the first and vice versa, as follows:</p>
<div><pre><code>numbers.reverse();</code></pre>
</div>
<p>So now, the output for the numbers array will be [<code>10, 9, 8, 7, 6, 5, 4, 3, 2, 1</code>]. Then, we can apply the sort method as follows:</p>
<div><pre><code>numbers.sort();</code></pre>
</div>
<p>However, if we output the array, the result will be [<code>1, 10, 2, 3, 4, 5, 6, 7, 8, 9</code>]. This is not ordered correctly. This is because the <code>sort</code> method in JavaScript sorts the elements <em>lexicographically</em>, and it assumes all the elements are <em>strings</em>.</p>
<p>We can also write our own comparison function. As our array has numeric elements, we can write the following code:</p>
<div><pre><code>numbers.sort((a, b) =&gt; a - b);</code></pre>
</div>
<p>This code will return a negative number if <code>b</code> is bigger than <code>a</code>, a positive number if <code>a</code> is bigger than <code>b</code>, and 0 (zero) if they are equal. This means that if a negative value is returned, it implies that <code>a</code> is smaller than <code>b</code>, which is further used by the <code>sort</code> function to arrange the elements.</p>
<p>The previous code can be represented by the following code as well:</p>
<div><pre><code>function compareNumbers(a, b) {
    if (a &lt; b) {
      return -1;
    }
    if (a &gt; b) {
      return 1;
    }
    // a must be equal to b
    return 0;
  }
  numbers.sort(compareNumbers);</code></pre>
</div>
<p>This is because the <code>sort</code> function from the JavaScript Array class can receive a parameter called <code>compareFunction</code>, which is responsible for sorting the array. In our example, we declared a function that will be responsible for comparing the elements of the array, resulting in an array sorted in ascending order.</p>

<h3 data-number="4.9.1">Custom sorting</h3>
<p>We can sort an array with any type of object in it, and we can also create a <code>compareFunction</code> to compare the elements as required. For example, suppose we have an object, Person, with name and age, and we want to sort the array based on the age of the person. We can use the following code:</p>
<div><pre><code>const friends = [
  { name: 'Frodo', age: 30 },
  { name: 'Violet', age: 18 },
  { name: 'Aelin', age: 20 }
];
const compareFriends = (friendA, friendB =&gt; friendA.age - friendB.age;
friends.sort(compareFriends);
console.log('Sorted friends:', friends);</code></pre>
</div>
<p>In this case, the output from the previous code will be Violet (18), Aelin (20), and Frodo (30).</p>


<h3 data-number="4.9.2">Sorting Strings</h3>
<p>Suppose we have the following array:</p>
<div><pre><code>let names = ['Ana', 'ana', 'john', 'John'];
console.log(names.sort());</code></pre>
</div>
<p>What do you think would be the output? The answer is as follows:</p>
<div><pre><code>["Ana", "John", "ana", "john"]</code></pre>
</div>
<p>Why does <code>ana</code> come after <code>John</code> when <code>a</code> comes first in the alphabet? The answer is because JavaScript compares each character according to its <strong>ASCII</strong> value (<a href="http://www.asciitable.com">http://www.asciitable.com</a>).</p>
<p>For example, A, J, a, and j have the decimal ASCII values of A: 65, J: 74, a: 97, and j: 106. Therefore, J has a lower value than a, and because of this, it comes first in the alphabet.</p>
<p>Now, if we pass a function to the <code>sort</code> method, which contains the code to ignore the case of the letter, we will have the output [<code>"Ana", "ana", "john", "John"</code>], as follows:</p>
<div><pre><code>names = ['Ana', 'ana', 'john', 'John']; // reset the array to its original state
names.sort((a, b) =&gt;  {
  const nameA = a.toLowerCase();
  const nameB = b.toLowerCase();
  if (nameA &lt; nameB) {
    return -1;
  }
  if (nameA &gt; nameB) {
    return 1;
  }
  return 0;
});</code></pre>
</div>
<p>In this case, the sort function will not have any effect; it will obey the current order of lower and uppercase letters.</p>
<p>If we want lowercase letters to come first in the sorted array, then we need to use the <code>localeCompare</code> method:</p>
<div><pre><code>names.sort((a, b) =&gt; a.localeCompare(b));</code></pre>
</div>
<p>The output will be <code>['ana', 'Ana', 'john', 'John']</code>.</p>
<p>For accented characters, we can use the <code>localeCompare</code> method as well:</p>
<div><pre><code>const names2 = ['Maève', 'Maeve'];
console.log(names2.sort((a, b) =&gt; a.localeCompare(b)));</code></pre>
</div>
<p>The output will be <code>['Maeve', 'Maève']</code>.</p>



<h2 data-number="4.10">Transforming an array</h2>
<p>JavaScript also has support to methods that can modify the elements of the array or change its order. We have covered two transformative methods so far: <code>reverse</code> and <code>sort</code>. Let's learn about other useful methods that can transform the array.</p>

<h3 data-number="4.10.1">Mapping values of an array</h3>
<p>The <code>map</code> method is one of the most used methods in daily coding tasks when using JavaScript or TypeScript. Let's see it in action:</p>
<div><pre><code>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const squaredNumbers = numbers.map(value =&gt; value * value);
console.log('Squared numbers:', squaredNumbers);</code></pre>
</div>
<p>Suppose we would like to find the square of each number in an array. We can use the map method to transform each value within the array and return an array with the results. For our example, the output will be: <code>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code>.</p>
<p>We could rewrite the preceding code using a <code>for</code> loop to achieve the same result:</p>
<div><pre><code>const squaredNumbersLoop = [];
for (let i = 0; i &lt; numbers.length; i++) {
  squaredNumbersLoop.push(numbers[i] * numbers[i]);
}</code></pre>
</div>
<p>And this is why the map method is often used, as it saves time when we have to modify all the values within the array.</p>


<h3 data-number="4.10.2">Splitting into an array and joining into a string</h3>
<p>Imagine we have a CSV file with different names, delimited by a comma, and we would like to have each of these values and added to an array for processing (maybe they need to be persisted in a database by an API). We can use the String <code>split</code> method, which will return an array of the values:</p>
<div><pre><code>const namesFromCSV = 'Aelin,Gandalf,Violet,Poppy';
const names = namesFromCSV.split(',');
console.log('Names:', names); // ['Aelin', 'Gandalf', 'Violet', 'Poppy']</code></pre>
</div>
<p>And if instead of a comma separated file we need to use a semi-colon, we can use the <code>join</code> method of the JavaScript array class to output a single string with the array values:</p>
<div><pre><code>const namesCSV = names.join(';');
console.log('Names CSV:', namesCSV); // 'Aelin;Gandalf;Violet;</code></pre>
</div>


<h3 data-number="4.10.3">Using the reduce method for calculations</h3>
<p>The <code>reduce</code> method is used to calculate a value out of the array. The method receives a callback function with the following arguments: <code>accumulator</code> (the result of the calculation), the <code>element</code> of the array, the <code>index</code> and the <code>array</code> itself, and the second argument is the initial value. Usually, the index and the array are not used very often and can be omitted. Let's see a few examples.</p>
<p>The <code>reduce</code> method is often used when we want to calculate totals. For example, let's say we would like to know what is the sum of all numbers in a given array:</p>
<div><pre><code>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const sum = numbers.reduce((acc, value) =&gt; acc + value, 0); // 55</code></pre>
</div>
<p>Where <code>0</code> is the initial value, and <code>acc</code> is the sum. We can rewrite the preceding code using a loop to understand the logic behind it:</p>
<div><pre><code>let sumLoop = 0;
for (let i = 0; i &lt; numbers.length; i++) {
  sumLoop += numbers[i];
}</code></pre>
</div>
<p>We can also use the <code>reduce</code> method to find the minimum or maximum values within an array:</p>
<div><pre><code>const scores = [30, 70, 85, 90, 100];
const highestScore = scores.reduce((max, score) =&gt; score &gt; max ? score : max, scores[0]); // 100</code></pre>
</div>
<p>There is also the <code>reduceRight</code> method, which will execute the same logic, however, it will iterate the array from its end to the beginning.</p>
<blockquote>
<p>These methods <code>map</code>, <code>filter</code>, and <code>reduce</code> are the basis of <em>functional programming</em> in JavaScript.</p>
</blockquote>



<h2 data-number="4.11">References for other JavaScript array methods</h2>
<p>JavaScript arrays are remarkably interesting because they are powerful and have more capabilities available than primitive arrays in other languages. This means that we do not need to write basic capabilities ourselves, and we can take advantage of these powerful features.</p>
<p>We have already covered many different methods within this chapter. Let's look at other useful methods.</p>

<h3 data-number="4.11.1">Using the isArray method</h3>
<p>In JavaScript, we can check the type of a variable or object using the <code>typeof</code> operator as follows:</p>
<div><pre><code>console.log(typeof 'Learning Data Structures'); // string
console.log(typeof 123); // number
console.log(typeof { id: 1 }); // object
console.log(typeof [1, 2, 3]); // object</code></pre>
</div>
<p>Note that both the object <code>{ id: 1}</code> and the array <code>[1, 2, 3]</code> have types as <code>object</code>.</p>
<p>But what if we would like to double check the type is array so we can evoke any specific array method? Thankfully, JavaScript also provides a method for that through <code>Array.isArray</code>:</p>
<div><pre><code>console.log(Array.isArray([1, 2, 3])); // true</code></pre>
</div>
<p>This way we can always check in case we receive some data we do not know its type. For example, when working with JavaScript on the front-end, we often receive JSON objects from an API from the server. We can parse the data received into an object, and check if the object received is an array so we can use the methods we learned to find specific information:</p>
<div><pre><code>const jsonString = JSON.stringify('[{"id":1,"title":"The Fellowship of the Ring"},{"id":2,"title":"Fourth Wing"}]');
const dataReceived = JSON.parse(jsonString);
if (Array.isArray(dataReceived)) {
  console.log('It is an array');
  // check if The Fellowship of the Ring is in the array
  const fellowship = dataReceived.find((item) =&gt; {
    return item.title === 'The Fellowship of the Ring';
  });  
  if (fellowship) {
    console.log('We received the book we were looking for!');
  } else {
    console.log('We did not receive the book we were looking for!');
  }
}</code></pre>
</div>
<p>This is helpful to ensure our code will not throw errors and a good practice when handling data structures, so we have not created ourselves within our code.</p>


<h3 data-number="4.11.2">Using the from method</h3>
<p>The <code>Array.from</code> method creates a new array from an existing one. For example, if we want to copy the array <code>numbers</code> into a new one, we can use the following code:</p>
<div><pre><code>const numbers = [1, 2, 3, 4, 5];
const numbersCopy = Array.from(numbers);
console.log(numbersCopy); // [1, 2, 3, 4, 5]</code></pre>
</div>
<p>It is also possible to pass a function so that we can determine which values we want to map. Consider the following code:</p>
<div><pre><code>const evens = Array.from(numbers, x =&gt; (x % 2 == 0)); 
console.log(evens); // [false, true, false, true, false]</code></pre>
</div>
<p>The preceding code created a new array named evens, and a value true if in the original array the number is even, and false otherwise.</p>
<p>It is important to note that the <code>Array.from()</code> method creates a new, <em>shallow</em> copy. Let's see another example:</p>
<div><pre><code>const friends = [
  { name: 'Frodo', age: 30 },
  { name: 'Violet', age: 18 },
  { name: 'Aelin', age: 20 }
];
const friendsCopy = Array.from(friends);</code></pre>
</div>
<p>With the copy done, let's modify the name of the first friend to Sam:</p>
<div><pre><code>friends[0].name = 'Sam';
console.log(friendsCopy[0].name); // Sam</code></pre>
</div>
<p>The name of the first friend of the copied array also gets updated, so we have to be careful when using this method.</p>
<p>If we need to copy the array, and have different instances of its content there is a workaround that can be used via JSON:</p>
<div><pre><code>const friendsDeepCopy = JSON.parse(JSON.stringify(friends));
friends[0].name = 'Frodo';
console.log(friendsDeepCopy[0].name); // Sam</code></pre>
</div>
<p>By transforming all the content of the array into a string in JSON format, and then parsing this content back to the array structure, we create brand new data. However, depending on what we need to achieve, there are more robust ways of doing this.</p>


<h3 data-number="4.11.3">Using the Array.of method</h3>
<p>The <code>Array.of</code> method creates a new array from the arguments passed to the method. For example, let's consider the following example:</p>
<div><pre><code>const numbersArray = Array.of(1, 2, 3, 4, 5);
console.log(numbersArray); // [1, 2, 3, 4, 5]</code></pre>
</div>
<p>The preceding code would be the same as performing the following:</p>
<div><pre><code>const numbersArray = [1, 2, 3, 4, 5];</code></pre>
</div>
<p>We can also use this method to make a copy of an existing array. The following is an example:</p>
<div><pre><code>let numbersCopy2 = Array.of(...numbersArray);</code></pre>
</div>
<p>The preceding code is the same as using <code>Array.from(numbersArray)</code>. The difference here is that we are using the spread operator. The spread operator (<code>...</code>) will spread each of the values of the <code>numbersArray</code> into arguments.</p>


<h3 data-number="4.11.4">Using the fill method</h3>
<p>The <code>fill</code> method fills the array with a value. For example, suppose a new game tournament will start and we want to store all the results in an array. As the games are over, we can update each of the results.</p>
<div><pre><code>const tornamentResults = new Array(5).fill('pending');</code></pre>
</div>
<p>The <code>tornamentResults</code> array has the length 5, meaning we have five positions. Each position has been initialized with the value <code>pending</code>.</p>
<p>Now, suppose games 1 and 2 were a win. We can also use the <code>fill</code> method to populate these two positions by passing the start position (inclusive) and the end position (exclusive):</p>
<div><pre><code>tornamentResults.fill('win', 1, 3);
console.log(tornamentResults);
// ['pending', 'win', 'win', 'pending', 'pending']</code></pre>
</div>
<p>This method is useful as it provides a compact way to initialize arrays with a single value and it is often faster (in terms of the time we will spend writing the code) than manually looping to fill an array.</p>


<h3 data-number="4.11.5">Joining multiple arrays</h3>
<p>Consider a scenario where you have different arrays and you need to join all of them into a single array. We could iterate each array and add each element to the final array. Fortunately, JavaScript already has a method that can do this for us, named the concat method, which looks as follows:</p>
<div><pre><code>const zero = 0;
const positiveNumbers = [1, 2, 3];
const negativeNumbers = [-3, -2, -1];
let allNumbers = negativeNumbers.concat(zero, positiveNumbers); </code></pre>
</div>
<p>We can pass as many arrays and objects/elements to this array as we desire. The arrays will be concatenated to the specified array in the order that the arguments are passed to the method. In this example, zero will be concatenated to <code>negativeNumbers</code>, and then <code>positiveNumbers</code> will be concatenated to the resulting array. The output of the numbers array will be the values <code>[-3, -2, -1, 0, 1, 2, 3]</code>.</p>



<h2 data-number="4.12">Two-dimensional arrays</h2>
<p>At the beginning of this chapter, we used a temperature measurement example. We will now use this example one more time. Let's consider that we need to measure the temperature hourly for a few days. Now that we already know we can use an array to store the temperatures, we can easily write the following code to store the temperatures over 2 days:</p>
<div><pre><code>let averageTempDay1 = [72, 75, 79, 79, 81, 81]; 
let averageTempDay2 = [81, 79, 75, 75, 73, 72];</code></pre>
</div>
<p>However, this is not the best approach; we can do better! We can use a <strong>matrix</strong> (a two-dimensional array or an <em>array of arrays</em>) to store this information, in which each row will represent the day, and each column will represent an hourly measurement of temperature, as follows:</p>
<div><pre><code>let averageTempMultipleDays = [];
averageTempMultipleDays[0] = [72, 75, 79, 79, 81, 81];
averageTempMultipleDays[1] = [81, 79, 75, 75, 73, 73];</code></pre>
</div>
<p>JavaScript only supports one-dimensional arrays; it does not support matrices. However, we can implement matrices or any multi-dimensional array using an array of arrays, as in the previous code. The same code can also be written as follows:</p>
<div><pre><code>averageTempMultipleDays = [
  [72, 75, 79, 79, 81, 81],
  [81, 79, 75, 75, 73, 73]
];</code></pre>
</div>
<p>Or, if you prefer to assign a value for each position separately, we can also rewrite the code as the following snippet:</p>
<div><pre><code>// day 1
averageTemp[0] = [];
averageTemp[0][0] = 72;
averageTemp[0][1] = 75;
averageTemp[0][2] = 79;
averageTemp[0][3] = 79;
averageTemp[0][4] = 81;
averageTemp[0][5] = 81;
// day 2
averageTemp[1] = [];
averageTemp[1][0] = 81;
averageTemp[1][1] = 79;
averageTemp[1][2] = 75;
averageTemp[1][3] = 75;
averageTemp[1][4] = 73;
averageTemp[1][5] = 73;</code></pre>
</div>
<p>We specified the value of each day and hour separately. We can also represent this two-dimensional array as the following diagram:</p>
<figure>
<img src="img/file12.png" alt="Figure 3.4:" width="433" height="162"/><figcaption aria-hidden="true">Figure 3.4:</figcaption>
</figure>
<p>Each row represents a day, and each column represents the temperature for each hour of the day.</p>
<p>Another way of visualizing a two-dimensional array is thinking about an Excel file (or Google Sheets). We can store any kind of tabular data using a two-dimensional array such as chess board, theater seating and even representing images, where each position of the array can store the color value for each pixel.</p>

<h3 data-number="4.12.1">Iterating the elements of two-dimensional arrays</h3>
<p>If we want to verify the output of the matrix, we can create a generic function to log its output:</p>
<div><pre><code>function printMultidimensionalArray(myArray) {
  for (let i = 0; i &lt; myArray.length; i++) {
    for (let j = 0; j &lt; myArray[i].length; j++) {
      console.log(myArray[i][j]);
    }
  }
}</code></pre>
</div>
<p>We need to loop through all the rows and columns. To do this, we need to use a nested <code>for</code> loop, in which the variable <code>i</code> represents rows, and <code>j</code> represents the columns. In this case, each <code>myMatrix[i]</code> also represents an array, therefore we also need to iterate each position of <code>myMatrix[i]</code> in the nested for loop.</p>
<p>We can output the contents of the <code>averageTemp</code> matrix using the following code:</p>
<div><pre><code>printMatrix(averageTemp);</code></pre>
</div>
<blockquote>
<p>We can also use the <code>console.table(averageTemp)</code> statement to output a two-dimensional array. This will provide a more user-friendly output, showing the tabular data format.</p>
</blockquote>



<h2 data-number="4.13">Multi-dimensional arrays</h2>
<p>We can also work with multi-dimensional arrays in JavaScript. For example, suppose we need to store the average temperature for multiple days and for multiple locations. We can use a 3D matrix to do so:</p>
<ul>
<li>Dimension 1 (<code>i</code>): each day</li>
<li>Dimension 2 (<code>j</code>): location</li>
<li>Dimension 3 (<code>z</code>): temperature</li>
</ul>
<p>Let's say we will only store the last 3 days, for 3 distinct locations and 3 different weather conditions. We can represent a 3 x 3 x 3 matrix with a cube diagram, as follows:</p>
<figure>
<img src="img/file13.png" alt="Figure 3.5:" width="433" height="421"/><figcaption aria-hidden="true">Figure 3.5:</figcaption>
</figure>
<p>We can represent a 3 x 3 matrix, as follows:</p>
<div><pre><code>let averageTempMultipleDaysAndLocation = [];
// day 1
averageTempMultipleDaysAndLocation[0] = [];
averageTempMultipleDaysAndLocation[0][0] = [19, 20, 21]; // location 1
averageTempMultipleDaysAndLocation[0][1] = [20, 22, 23]; // location 2
averageTempMultipleDaysAndLocation[0][2] = [30, 31, 32]; // location 3
// day 2
averageTempMultipleDaysAndLocation[1] = [];
averageTempMultipleDaysAndLocation[1][0] = [21, 22, 23]; // location 1
averageTempMultipleDaysAndLocation[1][1] = [22, 23, 24]; // location 2
averageTempMultipleDaysAndLocation[1][2] = [29, 30, 30]; // location 3
// day 3
averageTempMultipleDaysAndLocation[2] = [];
averageTempMultipleDaysAndLocation[2][0] = [22, 23, 24]; // location 1
averageTempMultipleDaysAndLocation[2][1] = [23, 24, 23]; // location 2
averageTempMultipleDaysAndLocation[2][2] = [30, 31, 31]; // location 3</code></pre>
</div>
<p>And, if we would like to output the content of this matrix, we will need to iterate each dimension (<code>i</code>, <code>j</code> and <code>z</code>):</p>
<div><pre><code>function printMultidimensionalArray3D(myArray) {
  for (let i = 0; i &lt; myArray.length; i++) {
    for (let j = 0; j &lt; myArray[i].length; j++) {
      for (let z = 0; z &lt; myArray[i][j].length; z++) {
        console.log(myArray[i][j][z]);
      }
    }
  }
}</code></pre>
</div>
<p>Performance wise, the preceding code is <em>O(nˆ3)</em>, cubic time, as we have three nested loops.</p>
<p>We can use 3D matrices to represent medical images such as MRI scans, which is a series of 2D image slides of the body. Each slide is a grid if pixel, and combining these slides, we have a 3D representation of a scanned area of the body. Another usage is visualizing models for a 3D printer, or even video data (each frame is a 2D array of pixels, with the third dimension being time).</p>
<p>If we had a 3 x 3 x 3 x 3 matrix, we would have four nested <code>for</code> statements in our code and so on. You will rarely need a four-dimensional array in your career as a developer as it has very specialized use cases such as traffic pattern analysis. Two-dimensional arrays are most common in daily activities that developers will work on most projects.</p>


<h2 data-number="4.14">The TypedArray class</h2>
<p>We can store any datatype in JavaScript arrays. This is because JavaScript arrays are not strongly typed as in other languages such as C and Java.</p>
<p><strong>TypedArray</strong> was created so that we could work with arrays with a single datatype. Its syntax is <code>let myArray = new TypedArray(length)</code>, where <code>TypedArray</code> needs to be replaced with one specific class, as defined in the following table:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>TypedArray</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>Int8Array</code></td>
<td>8-bit two's complement signed integer</td>
</tr>
<tr class="odd">
<td><code>Uint8Array</code></td>
<td>8-bit unsigned integer</td>
</tr>
<tr class="even">
<td><code>Uint8ClampedArray</code></td>
<td>8-bit unsigned integer</td>
</tr>
<tr class="odd">
<td><code>Int16Array</code></td>
<td>16-bit two's complement signed integer</td>
</tr>
<tr class="even">
<td><code>Uint16Array</code></td>
<td>16-bit unsigned integer</td>
</tr>
<tr class="odd">
<td><code>Int32Array</code></td>
<td>32-bit two's complement signed integer</td>
</tr>
<tr class="even">
<td><code>Uint32Array</code></td>
<td>32-bit unsigned integer</td>
</tr>
<tr class="odd">
<td><code>Float32Array</code></td>
<td>32-bit IEEE floating point number</td>
</tr>
<tr class="even">
<td><code>Float64Array</code></td>
<td>64-bit IEEE floating point number</td>
</tr>
<tr class="odd">
<td><code>BigInt64Array</code></td>
<td>64-bit big integer</td>
</tr>
<tr class="even">
<td><code>BigUint64Array</code></td>
<td>64-bit unsigned big integer</td>
</tr>
</tbody>
</table>
Table 3.1:
<p>The following is an example:</p>
<div><pre><code>const arrayLength = 5;
const int16 = new Int16Array(arrayLength);
for (let i = 0; i &lt; arrayLength; i++) {
  int16[i] = i + 1;
}
console.log(int16);</code></pre>
</div>
<p>Typed arrays are great for working with WebGL APIs, manipulating bits, and manipulating files, images, and audios. Typed arrays work exactly like simple arrays, and we can also use the same methods and functionalities that we have learned in this chapter.</p>
<p>One practical example of when to use <code>TypedArray</code> is when working with <strong>TensorFlow</strong> (<a href="https://www.tensorflow.org">https://www.tensorflow.org</a>), which is a library used to create <strong>Machine Learning</strong> models. TensorFlow has the concept of <strong>Tensors</strong>, which is the core data structure of TensorFlow.js. It utilizes <code>TypedArrays</code> internally to represent tensor data. This contributes to the efficiency and performance of the library, especially when dealing with large datasets or complex models.</p>


<h2 data-number="4.15">Arrays in TypeScript</h2>
<p>All the source code from this chapter is valid TypeScript code. The difference is that TypeScript will do type checking at compile time to make sure we are only manipulating arrays in which all values have the same datatype.</p>
<p>Let's review one of the previous examples mentioned earlier this chapter:</p>
<div><pre><code>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</code></pre>
</div>
<p>Due to the type inference, TypeScript understands that the declaration of the numbers array is the same as <code>const numbers: number[]</code>. For this reason, we do not need to always declare the variable type explicitly if we initialize it during its declaration.</p>
<p>If we go back to the sorting example of the <code>friends</code> array, we can refactor the code to the following in TypeScript:</p>
<div><pre><code>interface Friend {
  name: string;
  age: number;
}
const friends = [
  { name: 'Frodo', age: 30 },
  { name: 'Violet', age: 18 },
  { name: 'Aelin', age: 20 }
];
const compareFriends = (friendA: Friend, friendB: Friend) =&gt; {
  return friendA.age - friendB.age;
};
friends.sort(compareFriends);</code></pre>
</div>
<p>By declaring the <code>Friend</code> interface, we make sure the <code>compareFriend</code> function receives only objects that have the properties <code>name</code> and <code>age</code>. The friends array does not have an explicit type, so in this case, if we wanted, we could explicitly declare its type using <code>const friends: Friend[]</code>.</p>
<p>In summary, if we want to type our JavaScript variables using TypeScript, we simply need to use <code>const</code> or <code>let variableName: &lt;type&gt;[]</code> or, when using files with a <code>.js</code> extension, we can also have the type checking by adding the comment <code>// @ts-check</code> in the first line of the JavaScript file.</p>
<p>At runtime, the output will be exactly the same as if we were using pure JavaScript.</p>


<h2 data-number="4.16">Creating a simple TODO list using arrays</h2>
<p>Arrays is one of the most used data structures in general, it does not matter if we are using JavaScript, .NET, Java, Python, or any other language. This is one of the reasons most languages have native support to this data structure and JavaScript has an excellent API (<em>Application Programming Interface</em>) for the <code>Array</code> class.</p>
<p>Whenever we access the database, we will get a collection of records back, and we can use arrays to manage the information retrieved from the database. If we are using JavaScript in the frontend, and we make a call to a server API, we usually will get back a collection of records in <strong>JSON</strong> (<em>JavaScript Object Notation</em>) format, and we can parse the JSON into an array so we can manage and manipulate the data as needed so we can display it on the screen for the user.</p>
<p>Let's see a simple example of an HTML page using JavaScript where we can create tasks, complete tasks, and remove tasks. Of course, we will use arrays to manage our TODO list:</p>
<div><pre><code>&lt;!-- Path: src/03-array/10-todo-list-example.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Simple TODO List (Array-Based)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;My TODO List&lt;/h1&gt;
  &lt;input type="text" id="newTaskInput" placeholder="Add new task"&gt;
  &lt;button onclick="addTask()"&gt;Add&lt;/button&gt;
  &lt;ul id="taskList"&gt;&lt;/ul&gt;
  &lt;script&gt;
    const taskList = document.getElementById('taskList');
    const newTaskInput = document.getElementById('newTaskInput');
    let tasks = []; // Initialize empty task array
    function addTask() {}
    function renderTasks() {}
    function toggleComplete(index) {}
    function removeTask(index) {}
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
<p>This HTML code will help us to render a basic TODO application. Once we complete the development of this page, and if we open it in a browser, we will have the following application:</p>
<figure>
<img src="img/file14.png" width="1000" height="515"/>
</figure>
Figure 3.6:
<p>Let's check out the code used to render the task bullet point list:</p>
<div><pre><code>function addTask() {
  const taskText = newTaskInput.value.trim(); // {1}
  if (taskText !== "") {
    tasks.push({ text: taskText, completed: false }); // {2}
    renderTasks(); // Update the displayed list
    newTaskInput.value = ""; // Clear input
  }
}</code></pre>
</div>
<p>When we click on the <strong>Add</strong> button, the function <code>addTask</code> will be called. We will use the <code>trim</code> method to remove all the additional spaces at the beginning and the end of the text (<code>{1}</code>), and if the text is not empty, we will add it to our array (<code>{2}</code>) in the format of an object containing the text and also saying the task is not completed. Then we will evoke the <code>renderTasks</code> function and we will clear the input so we can enter more tasks.</p>
<p>Next, let's see the <code>renderTasks</code> function:</p>
<div><pre><code>function renderTasks() {
  taskList.innerHTML = ''; // Clear the list
  tasks.forEach((task, index) =&gt; { // {3}
    const listItem = document.createElement("li");
    listItem.innerHTML = `
      &lt;input type="checkbox" ${task.completed ? "checked" : ""}
        onchange="toggleComplete(${index})"&gt;
      &lt;span class="${task.completed ? "completed" : ""}"&gt;
        ${task.text}&lt;/span&gt;
      &lt;button onclick="removeTask(${index})"&gt;Delete&lt;/button&gt;
    `;
    taskList.appendChild(listItem);
  });
}</code></pre>
</div>
<p>Every time we add a new task or remove one, we will call this <code>renderTasks</code> function. First, we will clear the list by rendering an empty space in the screen, then, for each task we have in the array (<code>{3}</code>), we will create an element in the HTML list, that contains a checkbox that is checked in case the task is completed, the task text and a button that we can use the remove task, passing the index of the task in the array.</p>
<p>Finally, let's check the <code>toggleComplete</code> function (which is called whenever the check or uncheck the checkbox) and the <code>removeTask</code> function:</p>
<div><pre><code>function toggleComplete(index) { // Toggle task completion status
  tasks[index].completed = !tasks[index].completed; // {4}
  renderTasks();
}
function removeTask(index) {
  tasks.splice(index, 1); // {5} Remove from array
  renderTasks();
}</code></pre>
</div>
<p>Both functions receive the <code>index</code> of the array as parameter, so we can easily access the task that is being toggled or removed. For the toggle, we can access the array position directly and mark the task as completed or not completed (<code>{4}</code>), and to remove the task, we can use the splice method as we learned in this chapter to remove the task from the array (<code>{5}</code>), and of course, whenever we make a change, we will render the tasks again.</p>
<p>Arrays are everywhere, hence the importance to master this data structure.</p>


<h2 data-number="4.17">Exercises</h2>
<p>We will resolve a few array exercises from <strong>Hackerrank</strong> using the concepts we learned in this chapter.</p>

<h3 data-number="4.17.1">Reversing an array</h3>
<p>The first exercise we will resolve the is reverse array problem available at <a href="https://www.hackerrank.com/challenges/arrays-ds/problem">https://www.hackerrank.com/challenges/arrays-ds/problem</a>.</p>
<p>When resolving the problem using JavaScript or TypeScript, we will need to add our logic inside the function <code>reverseArray(a: number[]): number[] {}</code>, which receives an array of numbers and it is also expecting an array of numbers to be returned.</p>
<p>The sample input that is given is <code>[1,4,3,2]</code> and the expected output is <code>[2,3,4,1]</code>.</p>
<p>The logic we need to implement is to reverse the array, meaning the first element will become the last and so on.</p>
<p>The most straightforward solution is using the existing <code>reverse</code> method:</p>
<div><pre><code>function reverseArray(a: number[]): number[] {
  return a.reverse();
}</code></pre>
</div>
<p>This is a solution that passes all the tests and resolves the problem. However, if this exercise is being used in technical interviews, the interviews probably will ask you to try a different solution that does not include using the existing <code>reverse</code> method so they can evaluate how you think and communicate the resolution.</p>
<p>A second solution is to manually code reversing the array.</p>
<div><pre><code>function reverseArray2(a: number[]): number[] {
  const result = [];
  for (let i = a.length - 1; i &gt;= 0; i--) {
    result.push(a[i]);
  }
  return result;
}</code></pre>
</div>
<p>We will create a brand new array, we will iterate the given array starting from the end (since we have to reverse it) until we reach the first index which is 0. Then, for each element, we will add (<code>push</code>) to the new array and we can return the <code>result</code>. This solution is <em>O(n)</em> as we need to iterate through the length of the array.</p>
<p>Speaking of <em>Big O notation</em>, as you might have noticed, we often need to iterate an array. Iterating an array is linear time, and accessing the elements directly is <em>O(1)</em>, as we can access any position of the array by accessing its index.</p>
<p>If you prefer to iterate the array from its beginning until its last position, we can use the <code>unshift</code> method:</p>
<div><pre><code>function reverseArray3(a: number[]): number[] {
  const result = [];
  for (let i = 0; i &lt; a.length; i++) {
    result.unshift(a[i]);
  }
  return result;
}</code></pre>
</div>
<p>However, this is one of worst solutions. Given we need to iterate the array, we are talking about <em>O(n)</em> complexity. The <code>unshift</code> method also has <em>O(n)</em> complexity as it needs to move all the existing elements already in the array, making this solution <em>O(nˆ2)</em>, quadratic time.</p>
<p>Can you think of a solution that does not require iterating through all the array? What if we iterate only half of the array and swap the elements, meaning we swap the first element with the last, the second element with the second last, and so on:</p>
<div><pre><code>function reverseArray4(a: number[]): number[] {
  for (let i = 0; i &lt; a.length / 2; i++) {
    const temp = a[i];
    a[i] = a[a.length - 1 - i];
    a[a.length - 1 - i] = temp;
  }
  return a;
}</code></pre>
</div>
<p>The loop of this function would run approximately <em>n/2</em> times, where <code>n</code> is the length of the array. In Big O notation, this would still be an algorithm of complexity <em>O(n)</em>, as we ignore constant factors and lower order terms, however, <em>n/2</em> is better than <em>n</em>, so this last solution might be slightly faster.</p>


<h3 data-number="4.17.2">Array left rotation</h3>
<p>The next exercise we will resolve is the array left rotation available at https://www.hackerrank.com/challenges/array-left-rotation/problem.</p>
<p>When resolving the problem using JavaScript or TypeScript, we will need to add our logic inside the function <code>function rotLeft(a: number[], d: number): number[] {}</code> , which receives an array of numbers, a number <code>d</code> which is the number of left rotations and it is also expecting an array of numbers to be returned.</p>
<p>The sample input that is given is <code>[1,2,3,4,5]</code>, <code>d</code> is 2 and the expected output is <code>[3,4,5,1,2]</code>.</p>
<p>The logic we need to implement is to remove the first element of the array and add it to the end of the array, doing this <code>d</code> times.</p>
<p>Let's check with first solution:</p>
<div><pre><code>function rotLeft(a: number[], d: number): number[] {
  return a.concat(a.splice(0, d));
}</code></pre>
</div>
<p>We are using the existing methods available in JavaScript, by removing the number of elements we need to rotate using the <code>splice</code> method, which returns the array with removed elements. Then, we are concatenating the original array with the array of the removed elements. Basically, we are splitting the original array into two arrays and swapping the order.</p>
<p>The complexity of this solution is <em>O(n)</em> because:</p>
<ul>
<li><code>a.splice(0, d)</code>: this operation has a time complexity of <em>O(n)</em> because it needs to shift all the remaining elements of the array after removing the first <code>d</code> elements.</li>
<li><code>a.concat()</code>: this operation also has a time complexity of <em>O(n)</em> because it needs to iterate over all elements in the two arrays (the original array and the spliced array) to create a new array.</li>
</ul>
<p>Since these operations are performed sequentially (not nested), the time complexities add up, resulting in a total time complexity of <em>O(n + n) = O(2n)</em>. However, in Big O notation, we drop the constants, so the final time complexity is <em>O(n)</em>.</p>
<p>Another similar solution would be as follows:</p>
<div><pre><code>function rotLeft2(a: number[], d: number): number[] {
  return [...a.slice(d), ...a.slice(0, d)];
}</code></pre>
</div>
<p>Where we are creating a new array starting from the element at index <code>d</code> (<code>a.slice(d)</code>), and creating a new array by removing the number of elements we were asked to rotate (<code>a.slice(0, d)</code>). The spread operator (<code>…</code>) is used to unpack the elements of the two new arrays, and when surrounded by <code>[]</code>, we create a new array.</p>
<p>Let's review the complexity of this solution, which is also <em>O(n)</em>:</p>
<ul>
<li><code>a.slice(d)</code>: this operation has a time complexity of <em>O(n - d)</em> because it needs to create a new array with the elements from index d to the end of the array.</li>
<li><code>a.slice(0, d)</code>: this operation has a time complexity of <em>O(d)</em> because it needs to create a new array with the first d elements of the array.</li>
<li>The spread operator (<code>...</code>): this operation has a time complexity of <em>O(n)</em> because it needs to iterate over all elements in the two arrays to create a new array.</li>
</ul>
<p>Since these operations are performed sequentially (not nested), the time complexities add up, resulting in a total time complexity of <em>O((n - d) + d + n) = O(2n)</em>. So the final time complexity is <em>O(n)</em>.</p>
<p>Again, during an interview, we can be asked to implement a manual solution, so let's review a third possible solution:</p>
<div><pre><code>function rotLeft3(a: number[], d: number): number[] {
  for (let i = 0; i &lt; d; i++) {
    const temp = a[0]; // {1}
    for (let j = 0; j &lt; a.length - 1; j++) {
      a[j] = a[j + 1]; // {2}
    }
    a[a.length - 1] = temp; // {3}
  }
  return a;
}</code></pre>
</div>
<p>The outer loop will run <code>d</code> times as we need to rotate the elements. For each element we need to rotate, we will keep it in a temporary variable (<code>{1}</code>). Then, we will iterate the array and move the element in the next position to the current index (<code>{2}</code>). And at the end we will move the element we had stored in the temporary variable to the last position of the array (<code>{3}</code>). This is remarkably like the algorithm we created to remove an element from the first position. The difference here is we are not removing the element from the beginning of array and throwing it away, we are moving it to the end of the array.</p>
<p>The time complexity of this solution is <em>O(n*d)</em>. The first solutions presented are likely to be faster as they are <em>O(n)</em>.</p>



<h2 data-number="4.18">Summary</h2>
<p>In this chapter, we covered the most-used data structure: arrays. We learned how to declare, initialize, and assign values as well as add and remove elements. We learned about two-dimensional and multi-dimensional arrays as well as the main methods of an array, which will be particularly useful when we start creating our own algorithms in later chapters.</p>
<p>We also learned how to make sure the array only contains values of the same type by using TypeScript or the TypeScript compile-time checking capability for JavaScript files.</p>
<p>And finally, we resolved a few exercises that can be the topic of technical interviews and reviewed their complexity.</p>
<p>In the next chapter, we will learn about stacks, which can be treated as arrays with a special behavior.</p>


</div>
</div>
</body>
</html>