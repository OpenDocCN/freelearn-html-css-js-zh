<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Working with Events</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a side-by-side map comparator</li><li class="listitem" style="list-style-type: disc">Implementing a work in progress indicator for map layers</li><li class="listitem" style="list-style-type: disc">Listening for vector layer features' events</li><li class="listitem" style="list-style-type: disc">Listening for non-OpenLayers events</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Introduction</h1></div></div></div><p>This chapter is focused on events, which is an important concept in any JavaScript program. Although this chapter is brief, the concepts explained here are very important to understand when working with OpenLayers.<a class="indexterm" id="id158"/>
</p><p>Events are the heart of JavaScript. They are the impulses that allow us to produce a reaction. As programmers of a mapping application, we are interested in reacting when the map zoom changes, when a layer is loaded, or when a feature is added to a layer. Every class susceptible to emit events is responsible for managing its listeners (those interested in being notified when an event is fired) and also to emit events under certain circumstances.</p><p>For example, we can register a function listening for the<code class="literal"> zoomend</code> event on the<code class="literal"> OpenLayers.Map</code> instance. Every time the map instance changes its zoom, it is responsible to trigger the<code class="literal"> zoomend</code> event, so all its listeners will be notified by the new event.<a class="indexterm" id="id159"/>
</p><p>To help in all this process, OpenLayers has the<code class="literal"> OpenLayers.Events</code> class, that takes care of registering listeners and simplifying the action of firing an event to all of them. In concrete, it allows to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Define event</li><li class="listitem" style="list-style-type: disc">Register listeners</li><li class="listitem" style="list-style-type: disc">Trigger events to notify all listeners</li></ul></div><p>Many classes, such as<code class="literal"> OpenLayers.Map</code> and<code class="literal"> OpenLayers.Layer</code>, have an<code class="literal"> events</code> property, which is an instance of<code class="literal"> OpenLayers.Events</code> that takes care of registering the listeners interested to be notified on their event.</p><p>In addition, these classes commonly define an<code class="literal"> EVENT_TYPES</code> array property (which is constant) and list the available events you can register for that class. For example, for the<code class="literal"> OpenLayers.Map</code> class the<code class="literal"> EVENT_TYPES</code> is set as follows:</p><div><pre class="programlisting">    EVENT_TYPES: [ 
        "preaddlayer", "addlayer","preremovelayer", "removelayer", 
        "changelayer", "movestart",
        "move", "moveend", "zoomend", "popupopen", "popupclose",
        "addmarker", "removemarker", "clearmarkers", "mouseover",
        "mouseout", "mousemove", "dragstart", "drag", "dragend",
        "changebaselayer"]
</pre></div><p>As a programmer you need to look at the OpenLayers API documentation (<a class="ulink" href="http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Map-js.html">http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Map-js.html</a>) or you can also refer to the source code to know the available events that you can register on each class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Creating a side-by-side map comparator</h1></div></div></div><p>We are going to create a map comparator. The goal is to have two maps side- by-side from different providers and using some of the events that<code class="literal"> OpenLayers.Map</code> instance provides to keep the maps synchronized at the same position and zoom level.<a class="indexterm" id="id160"/>
</p><div><img alt="Creating a side-by-side map comparator" src="img/7843_ch04_01.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec01"/>How to do it...</h2></div></div></div><p>To have two maps side-by-side, perform the following steps:<a class="indexterm" id="id161"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Start creating an HTML with OpenLayers library dependency.</li><li class="listitem">Now, add the HTML code required to have two maps side-by-side. Here we are using a table with a row and two columns:<div><pre class="programlisting">&lt;table style="width: 100%; height: 95%;"&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;div id="ch04_map_a" style="width: 100%; height: 100%;"&gt;&lt;/div&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;div id="ch04_map_b" style="width: 100%; height: 100%;"&gt;&lt;/div&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</pre></div></li><li class="listitem">Now, let's write the JavaScript code. Create the two maps and initialize with the desired image provider. Here we have used<code class="literal"> OpenStreetMap</code> and<code class="literal"> Bing:</code><a class="indexterm" id="id162"/><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    // Create left hand side map
    var map_a = new OpenLayers.Map("ch04_map_a");    
    var layer_a = new OpenLayers.Layer.OSM("OpenStreetMap");
    map_a.addLayer(layer_a);
    map_a.setCenter(new OpenLayers.LonLat(0,0), 2);
    
    // Create right hand side map
    var map_b = new OpenLayers.Map("ch04_map_b");    
    var bingApiKey = "AvcVU_Eh1H2_xVcK0EeRO70MD7Zm6qwLhrVC12C3D997DylUewCWaKR9XTZgWwu6";
    var layer_b = new OpenLayers.Layer.Bing({
        name: "Road",
        type: "Road",
        key: bingApiKey
    });
    map_b.addLayer(layer_b);
    map_b.setCenter(new OpenLayers.LonLat(0,0), 2);
</pre></div></li><li class="listitem">Now, register the<code class="literal"> move</code> and<code class="literal"> zoomend</code> events on both layers:<div><pre class="programlisting">    // Register events on map_a using 'on':
    map_a.events.on({
        "move": moveListener,
        "zoomend": zoomListener
    });
    
    // Register events on map_a using 'register':
    map_b.events.register("move", null, moveListener);
    map_b.events.register("zoomend", null, zoomListener);
</pre></div></li><li class="listitem">Finally, implement the<code class="literal"> listener</code> functions that are called every time an event occurs:<div><pre class="programlisting">    // Listener functions
    function moveListener(event) {
        if(event.object == map_a) {
            map_b.setCenter(map_a.getCenter());
        } else {
            map_a.setCenter(map_b.getCenter());
        }
    }
    function zoomListener(event) {
        if(event.object == map_a) {
            map_b.zoomTo(map_a.getZoom()-1);
        } else {
            map_a.zoomTo(map_b.getZoom()+1);
        }
    }
&lt;/script&gt;
<a class="indexterm" id="id163"/>
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec02"/>How it works...</h3></div></div></div><p>To keep the two maps always in synchronization at the same position and zoom level, we need to know when the map has moved and when the zoom level has changed.<a class="indexterm" id="id164"/>
</p><p>The<code class="literal"> move</code> event is triggered every time the map is moved. Additionally, there are the<code class="literal"> movestart</code> and<code class="literal"> moveend</code> events, which are fired only when the<code class="literal"> move</code> action starts or ends, but they are not useful here because we need to catch every movement.<a class="indexterm" id="id165"/>
</p><p>The<code class="literal"> zoomend</code> event is triggered when the map's zoom level changes. So, how can we listen for events in the map? This is achieved through the<code class="literal"> events</code> property, which is an instance of<code class="literal"> OpenLayers.Events</code>.</p><p>There are two ways (really there is also a third one that we will see in the<em> There's more</em> section) to register event listeners for the map events—using the<code class="literal"> on</code> or the<code class="literal"> register</code> methods.</p><p>On the first map, we have used the<code class="literal"> on</code> method to register multiple events at once:</p><div><pre class="programlisting">    map_a.events.on({
        "move": moveListener,
        "zoomend": zoomListener
    });
</pre></div><p>The<code class="literal"> on</code> method requires an object in which its properties' names are the event names and the values are the listener functions to be called when events are triggered.</p><p>The<code class="literal"> on</code> method accepts a special property called<code class="literal"> scope</code>. This allows us to register all the specified events to be executed within the same context. That is, when the<code class="literal"> listener</code> function is executed, the<code class="literal"> this</code> keyword will point to the object specified in the<code class="literal"> scope</code> property.<a class="indexterm" id="id166"/>
</p><div><h3 class="title"><a id="note38"/>Note</h3><p>Contexts can be an advanced topic for someone who has just initiated in JavaScript. An interesting conversation can be found at<a class="ulink" href="http://stackoverflow.com/questions/1798881/javascript-context"> http://stackoverflow.com/questions/1798881/javascript-context</a>.</p></div><p>In the second map, we have used the<code class="literal"> register</code> method, which allows us to register an event listener one at a time:</p><div><pre class="programlisting">    map_b.events.register("move", null, moveListener);
    map_b.events.register("zoomend", null, zoomListener);
</pre></div><p>The<code class="literal"> events.register()</code> function accepts four parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">type:</code> This is the event we want to listen for.</li><li class="listitem" style="list-style-type: disc"><code class="literal">object:</code> This is the context where the function is executed (similar to the<code class="literal"> scope</code> property in the<code class="literal"> on</code> method).</li><li class="listitem" style="list-style-type: disc"><code class="literal">function:</code> This is the function to be executed when the event is triggered.</li><li class="listitem" style="list-style-type: disc"><code class="literal">priority:</code> This is a Boolean value. If it is<code class="literal"> true</code>, the listener is queued at the front of the event's queue instead of at the end.</li></ul></div><p>Now, we will be notified for any<code class="literal"> move</code> or<code class="literal"> zoomend</code> event that any of the two maps will produce.</p><p>It is important to note that OpenLayers event's mechanism always calls the<code class="literal"> listener</code> function by passing an<code class="literal"> event</code> parameter. This<code class="literal"> event</code> object contains any information that is written by the<code class="literal"> source</code> object that triggers the event, plus the following three properties that are always added automatically:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">type:</code> Contains the event name (move,<code class="literal"> zoomend</code>, and so on)</li><li class="listitem" style="list-style-type: disc"><code class="literal">object:</code> Points to the object that fires the event</li><li class="listitem" style="list-style-type: disc"><code class="literal">element:</code> The<code class="literal"> DOM</code> element related to the event</li></ul></div><p>Let's take a look at our listener functions. The<code class="literal"> moveListener</code> function checks which map has fired the event, then gets the map's<code class="literal"> center</code>, and assigns the same<code class="literal"> center</code> to the other map:</p><div><pre class="programlisting">    function moveListener(event) {
        if(event.object == map_a) {
            map_b.setCenter(map_a.getCenter());
        } else {
            map_a.setCenter(map_b.getCenter());
        }
    }
</pre></div><p>As you can see, we can get a reference to the map that triggers the event with<code class="literal"> event.object.</code>
<a class="indexterm" id="id167"/>
</p><p>Similarly, the<code class="literal"> zoomListener</code> function gets the zoom level on the source event map and applies it on the other map.</p><div><pre class="programlisting">    function zoomListener(event) {
        if(event.object == map_a) {
            map_b.zoomTo(map_a.getZoom()-1);
        } else {
            map_a.zoomTo(map_b.getZoom()+1);
        }
    }
</pre></div><div><h3 class="title"><a id="note39"/>Note</h3><p>Bing maps have different resolution levels on their imagery than<code class="literal"> OpenStreetMap</code>. We can say it differs by one zoom level with respect to other imagery providers because we are adding or subtracting this to/from the zoom level.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec03"/>There's more...</h3></div></div></div><p>As we can be interested in listening events, in the same way, we can also be interested in stopping the notifications.<a class="indexterm" id="id168"/>
</p><p>The<code class="literal"> OpenLayers.Events</code> class has the<code class="literal"> un</code> and<code class="literal"> unregister</code> methods, which allow us to unregister our listener functions from notifying when certain events are triggered.</p><p>Similar to the<code class="literal"> on</code> method, the<code class="literal"> un</code> method allows to unregister multiple listeners, while the<code class="literal"> unregister</code> method allows to unregister only one listener at a time. Taking this recipe as a sample, we could unregister events on maps as follows:</p><div><pre class="programlisting">    map_a.events.un({
        "move": moveListener,
        "zoomend": zoomListener
    });
    map_b.events.unregister("move", null, moveListener);
</pre></div><div><div><div><div><h4 class="title"><a id="ch04lvl3sec01"/>Another way to register an event listener</h4></div></div></div><p>In addition to the<code class="literal"> on</code> and<code class="literal"> register</code> methods, there is a third way to register event listeners.<a class="indexterm" id="id169"/>
</p><p>When creating<code class="literal"> OpenLayers.Map, OpenLayers.Layer</code>, and<code class="literal"> OpenLayers.Control</code> instances, we can use the<code class="literal"> eventListeners</code> property, in the same way as we use the<code class="literal"> on</code> method to register a set of listeners. For example:</p><div><pre class="programlisting">map = new OpenLayers.Map('map', { 
    eventListeners: { 
        "move": moveListener, 
        "zoomend": zoomListener 
    } 
});
</pre></div><p>What really happens is the object passed to the<code class="literal"> eventListener</code> property is directly used to initialize the listeners by using the<code class="literal"> on</code> method.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec04"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Using Bing imagery</em> recipe in<a class="link" href="ch02.html" title="Chapter 2. Adding Raster Layers"> Chapter 2</a>, <em> Adding Raster Layers</em></li><li class="listitem" style="list-style-type: disc">The<em> Implementing a work in progress indicator for map layers</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Listening for vector layer features' events</em> recipe</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Implementing a work in progress indicator for map layers</h1></div></div></div><p>In the art of creating great applications, the most important thing to take into account is the user experience. A good application does what it must do, but by making the user feel comfortable.<a class="indexterm" id="id170"/>
</p><p>When working with remote server, most of the time the user is waiting for data retrieval. For example, when working with a WMS layer, every time we change the zoom level, the user has to wait for some seconds till data is obtained from the server and the tiles start rendering.</p><p>It would be great to show some feedback to the users by using an icon, a progress bar, and so on, to inform that the application is working but needs some time.</p><p>This recipe shows how we can give some feedback to the user by informing when the application is loading content from different servers, making use of some layer events.<a class="indexterm" id="id171"/>
</p><div><h3 class="title"><a id="note40"/>Note</h3><p>Like in many other recipes in this book, we have used the Dojo toolkit framework (<a class="ulink" href="http://dojotoolkit.org">http://dojotoolkit.org</a>) for a better user experience. The main difference we can see is that a basic HTML page is the set of rich widgets (buttons, toolbar, progress bar, and so on) it offers. Do not worry if something on the HTML page is not clear, the goal of the book is not teaching Dojo, and that does not alter the explanations about OpenLayers concepts.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec05"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create an HTML file with OpenLayers dependency.</li><li class="listitem">First we are going to add the HTML code required to show a progress bar. Note how simply it can be created by using the Dojo framework. Tag a normal<code class="literal"> span</code> element with the<code class="literal"> data-dojo-type</code> and<code class="literal"> data-dojo-props</code> attributes.<div><pre class="programlisting">&lt;span data-dojo-type="dijit.ProgressBar" style="width: 100px;" id="progress"
      data-dojo-props="'indeterminate': true, 
      label:''"&gt;&lt;/span&gt;
</pre></div></li><li class="listitem">As always, place the<code class="literal"> div</code> element to hold the map:<div><pre class="programlisting">&lt;div id="ch04_work_progress" style="width: 100%; height: 100%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">For starting the JavaScript section code, we need to take into account that we are requesting features from a remote WFS server, because this is the first thing we need to do for setting the proxy URL to be used:<div><pre class="programlisting">&lt;!-- The magic comes here --&gt;
&lt;script type="text/javascript"&gt;
    OpenLayers.ProxyHost = "./utils/proxy.php?url=";
</pre></div></li><li class="listitem">Now, create the map and two layers—a WMS layer, which is the base layer, and a WFS layer:<a class="indexterm" id="id172"/><div><pre class="programlisting">    // Create left map
    var map = new OpenLayers.Map("ch04_work_progress");   
    var wms = new OpenLayers.Layer.WMS("Basic", 
    "http://labs.metacarta.com/wms/vmap0",
    {
        layers: 'basic'
    });        
    var wfs = new OpenLayers.Layer.Vector("States", {
        protocol: new OpenLayers.Protocol.WFS({
            url: "http://demo.opengeo.org/geoserver/wfs",
            featureType: "states",
            featureNS: "http://www.openplans.org/topp"
        }),
        strategies: [new OpenLayers.Strategy.BBOX()]
    });
    map.addLayers([wms, wfs]);
</pre></div></li><li class="listitem">Add a layer switcher control and centralize the map:<div><pre class="programlisting">    map.addControl(new 
    OpenLayers.Control.LayerSwitcher());
    map.setCenter(new OpenLayers.LonLat(-100, 41), 8);
</pre></div></li><li class="listitem">Register event listeners on WMS and WFS layers:<div><pre class="programlisting">    // Register events on layers using 'on':
    wms.events.on({
        "loadstart": updateLoader,
        "loadend": updateLoader, 
        "loadcancel": updateLoader
    });
    wfs.events.on({
        "loadstart": updateLoader,
        "loadend": updateLoader, 
        "loadcancel": updateLoader
    });
</pre></div></li><li class="listitem">Finally, implement the listener function to show the progress bar when any of the two layers is loading its content:<div><pre class="programlisting">    // Listener functions
    var wmsLoading = false;
    var wfsLoading = false;
    function updateLoader(event) {
        var progress = dijit.byId('progress');
        if(event.type == "loadstart") {
            if(event.object == wms) {
                wmsLoading = true;
            }
            if(event.object == wfs) {
                wfsLoading = true;
            }
            
            var label = "";
            if(wmsLoading) {
                label += "WMS ";
            }
            if(wfsLoading) {
                label += "+ WFS";
            }
                
            progress.set('value', 'Infinity');
            progress.set('label', label);
            dojo.style(progress.domNode, "visibility", "visible");
        } else {
            if(event.object == wms) {
                wmsLoading = false;
            }
            if(event.object == wfs) {
                wfsLoading = false;
            }
            progress.set('value', '0');
            dojo.style(progress.domNode, "visibility", "hidden");
        }
    }
&lt;/script&gt;
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec06"/>How it works...</h3></div></div></div><p>After creating the map and the two layers, register our listener functions for the events<code class="literal"> loadstart, loadend</code>, and<code class="literal"> loadcancel</code> on both layers:<a class="indexterm" id="id174"/>
</p><div><pre class="programlisting">    wms.events.on({
        "loadstart": updateLoader,
        "loadend": updateLoader, 
        "loadcancel": updateLoader
    });
    wfs.events.on({
        "loadstart": updateLoader,
        "loadend": updateLoader, 
        "loadcancel": updateLoader
    });
</pre></div><p>These are common events to all layers, because they are inherited from the<code class="literal"> OpenLayers.Layer</code> class.</p><p>The<code class="literal"> loadstart</code> event is triggered when the layer starts the process of loading data, while<code class="literal"> loadend</code> or<code class="literal"> loadcancel</code> are triggered because the process ends or is canceled.</p><p>With this in mind, the cumbersome<code class="literal"> updateLoader</code> listener function is responsible for showing an indeterminate progress bar with a text message when any of the two layers is loading data. The text message can be WMS, WFS, or WMS WFS, depending on the layers that are loading the content.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec07"/>There's more...</h3></div></div></div><p>As we mentioned earlier, the events used in this recipe are common for all layers.</p><p>Concrete subclasses of the<code class="literal"> OpenLayers.Layer</code> class can have their own events, as in the case of<code class="literal"> OpenLayers.Layer.Vector</code> that has events to notify when features are added, removed, and so on.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec08"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Adding WMS layer</em> recipe in<a class="link" href="ch02.html" title="Chapter 2. Adding Raster Layers"> Chapter 2</a>, <em> Adding Raster Layers</em></li><li class="listitem" style="list-style-type: disc">The<em> Adding features from a WFS server</em> recipe in<a class="link" href="ch03.html" title="Chapter 3. Working with Vector Layers"> Chapter 3</a>, <em>Working with Vector Layers</em></li><li class="listitem" style="list-style-type: disc">The<em> Creating a side-by-side map comparator</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Listening for vector layer features' events</em> recipe</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Listening for vector layer features' events</h1></div></div></div><p>When working with vector layers, it is common to find a situation where you need to know what is happening, that is, when a new feature is going to be added to the layers or when a feature has been modified, deleted, and so on. Fortunately, vector layer has the capability to trigger a great fan of events.</p><p>The goal of this recipe is to show how easy it is to listen for events in a vector layer and know what is happening on it.<a class="indexterm" id="id175"/>
</p><p>We are going to load a GML file with some cities around the world, and we will style its fill color depending on some feature attribute.</p><div><img alt="Listening for vector layer features' events" src="img/7843_ch04_04.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec09"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create an HTML file and add the OpenLayers library dependency files. Then, add a<code class="literal"> div</code> element to define where to hold the map instance:<a class="indexterm" id="id176"/><div><pre class="programlisting">&lt;div id="ch04_vector_layer_listener" style="width: 100%; height: 100%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">Initialize the map instance, add a base layer, and centralize the viewport:<div><pre class="programlisting">&lt;!-- The magic comes here --&gt;
&lt;script type="text/javascript"&gt;
    // Create map
    var map = new 
    OpenLayers.Map("ch04_vector_layer_listener");    
    var layer = new 
    OpenLayers.Layer.OSM("OpenStreetMap");
    map.addLayer(layer);
    map.setCenter(new OpenLayers.LonLat(0,0), 4);
</pre></div></li><li class="listitem">Create a vector layer to read a GML file. Also, initialize it by registering an event listener for the<code class="literal"> beforefeatureadded</code> event:<a class="indexterm" id="id177"/><div><pre class="programlisting">    var vectorLayer = new 
    OpenLayers.Layer.Vector("States", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/openlayers-
            cookbook/recipes/data/world_cities.json",
            format: new OpenLayers.Format.GeoJSON()
        }),
        strategies: [new OpenLayers.Strategy.Fixed()],
        eventListeners: {
            "beforefeatureadded": featureAddedListener
        }
    });
    map.addLayer(vectorLayer);
</pre></div></li><li class="listitem">Write the code for the listener function. Define a color palette that assigns a fill color to every feature depending on the<code class="literal"> POP_RANK</code> attribute:<div><pre class="programlisting">    // Define color palette
    var colors = [
        "#CC0000",
        "#FF0000",
        "#FF3300",
        "#FF6600",
        "#FF9900",
        "#FFCC00",
        "#FFFF00"
    ];
    function featureAddedListener(event){
        // Set feature color depending on the rank attribute
        var feature = event.feature;
        var rank = feature.attributes.POP_RANK;
        feature.style = OpenLayers.Util.extend({}, OpenLayers.Feature.Vector.style['default']);
        feature.style.fillColor = colors[rank-1];
    }
&lt;/script&gt;
<a class="indexterm" id="id178"/>
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec10"/>How it works...</h3></div></div></div><p>After initializing the map and the base layer, we have to create a vector layer:<a class="indexterm" id="id179"/>
</p><div><pre class="programlisting">    var vectorLayer = new OpenLayers.Layer.Vector("States", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/openlayers-cookbook/recipes/data/world_cities.json",
            format: new OpenLayers.Format.GeoJSON()
        }),
        strategies: [new OpenLayers.Strategy.Fixed()],
        eventListeners: {
            "beforefeatureadded": featureAddedListener
        }
    });
</pre></div><p>As a protocol, we are using the<code class="literal"> OpenLayers.Protocol.HTTP</code> instance that will get data from the specified URL, via HTTP protocol and will read it by using the<code class="literal"> OpenLayers.Format.GeoJSON</code> format reader.</p><p>The vector layer uses<code class="literal"> OpenLayers.Strategy.Fixed</code>, which means the content is loaded only once, no matter whether we move the map's viewport or not.</p><p>There are some ways to register the event listeners. One of those ways is using the<code class="literal"> on</code> or<code class="literal"> register</code> methods, but we have chosen to register the event listener at the same time when we initialize the layer by using the<code class="literal"> eventListener</code> property.</p><p>This way, every time when a feature is going to be added to the layer (before it was added), the listener function will be called by receiving an<code class="literal"> event</code> object as a parameter, with some information related to the layer's event:</p><div><pre class="programlisting">    function featureAddedListener(event){
        var feature = event.feature;
        var rank = feature.attributes.POP_RANK;
        feature.style = OpenLayers.Util.extend({}, OpenLayers.Feature.Vector.style['default']);
        feature.style.fillColor = colors[rank-1];
    }
</pre></div><p>From the event, we can get a reference to the feature and its attributes. Here we are using the<code class="literal"> POP_RANK</code> attribute to select the fill color of the feature.<a class="indexterm" id="id180"/>
</p><div><h3 class="title"><a id="note41"/>Note</h3><p>More information about the feature style properties, which we can change, is available at<a class="ulink" href="http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Feature/Vector-js.html#OpenLayers.Feature.Vector.OpenLayers.Feature.Vector.style"> http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Feature/Vector-js.html#OpenLayers.Feature.Vector.OpenLayers.Feature.Vector.style</a>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec11"/>There's more...</h3></div></div></div><p>In this recipe, we can use the<code class="literal"> OpenLayers.Util.extend</code> method to set the initial style of the feature and then set the desired fill color:</p><div><pre class="programlisting">feature.style = OpenLayers.Util.extend(
    {},
    OpenLayers.Feature.Vector.style['default']
);
</pre></div><p>The<code class="literal"> OpenLayers.Util.extend</code> method requires two parameters—the destination and the source objects. Its function is to copy all the properties found in the source object to the destination.</p><div><h3 class="title"><a id="note42"/>Note</h3><p>The<code class="literal"> OpenLayers.Util.extend</code> method is very important to create hierarchy and inheritance in OpenLayers. However, its namespace is<code class="literal"> OpenLayers.Util</code> and it is located in the<code class="literal"> OpenLayers/BaseTypes/Class.js</code> file, which talks about its importance.</p></div><p>On the other hand,<code class="literal"> OpenLayers.Feature.Vector.style</code> is an object with some predefined styles for features such as<code class="literal"> default, selected, delete</code>, and so on.</p><p>So, the preceding line means that a new object extending an empty object with all the properties in the<code class="literal"> OpenLayers.Feature.Vector.style['default']</code> object can be created.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec12"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Styling features using symbolizers</em> recipe in<a class="link" href="ch07.html" title="Chapter 7. Styling Features"> Chapter 7</a>, <em> Styling Features</em></li><li class="listitem" style="list-style-type: disc">The<em> Adding a GML layer</em> recipe in<a class="link" href="ch03.html" title="Chapter 3. Working with Vector Layers"> Chapter 3</a>, <em> Working with Vector Layers.</em></li><li class="listitem" style="list-style-type: disc">The<em> Creating a side-by-side map comparator</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Listening for non-OpenLayers events</em> recipe</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Listening for non-OpenLayers events</h1></div></div></div><p>When developing a web mapping application, the use of OpenLayers is only a piece among the set of tools that we need to use. Adding other components, such as buttons, images, lists, and so on, and interacting with them are other tasks that we must work on.<a class="indexterm" id="id181"/>
</p><p>Interacting with a<code class="literal"> OpenLayers.Map</code> instance or<code class="literal"> OpenLayers.Layer</code> subclass is easy because they trigger specific events, but what if we want to listen for events on a button or any<code class="literal"> DOM</code> element?</p><p>For this purpose, OpenLayers offers us the<code class="literal"> OpenLayers.Event</code> class (do not get confused with the plural<code class="literal"> OpenLayers.Events</code> class). This is a helper class, which, among other things, allows us to listen for events in non-OpenLayers elements in a browser-independent way.</p><div><h3 class="title"><a id="note43"/>Note</h3><p>Unfortunately the way to register event listeners in JavaScript is not the same in all browsers. Also, Microsoft differs from W3C (the WWW Consortium) in the way to register listeners. You can find more information at<a class="ulink" href="http://www.quirksmode.org/js/events_advanced.html"> http://www.quirksmode.org/js/events_advanced.html</a>.</p></div><p>If your project uses a library or framework such as jQuery, Dojo, or ExtJS, you will probably use their features to access DOM elements, register for events, and so on.</p><p>If you are working on a simpler project without the aforementioned libraries, it is a good idea to register events through the<code class="literal"> OpenLayers.Event</code> class, because it is browser-independent, which means your application will be compatible with more browsers.</p><p>In addition, there is one more reason to read this recipe and the reason is that OpenLayers uses the<code class="literal"> OpenLayers.Event</code> class internally to implement many handlers and controls, which we will see in the future chapters.</p><p>Let's have a look at how we can listen for events on HTML elements through the<code class="literal"> OpenLayers.Event</code> class.</p><div><img alt="Listening for non-OpenLayers events" src="img/7843_ch04_02.jpg"/></div><p>The idea is to create six buttons and add six point features to a vector layer. Then highlight the feature when mouse enters a button or unselect if mouse leaves it.<a class="indexterm" id="id182"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec13"/>How to do it...</h2></div></div></div><p>To listen for non-OpenLayers events, follow the next steps:<a class="indexterm" id="id183"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Create an HTML with OpenLayers library dependency. Start adding some CSS styles for the buttons. The following code defines a style when the buttons are not selected (the mouse is out) and also a style with different background color when mouse is hovered over the buttons:<div><pre class="programlisting">&lt;style&gt;
    .square {
        border: 1px solid #888;
        background-color: #0099FF;
        color: #fff;
        padding: 3px;
    }
    .square:hover {
        background-color: #0086d2;
    }
&lt;/style&gt;
</pre></div></li><li class="listitem">Create a table to hold the six buttons. A button will be represented by a<code class="literal"> span</code> element with an identifier:<div><pre class="programlisting">&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;span id="f0" class="square"&gt;Feature 
        1&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;&lt;span id="f1" class="square"&gt;Feature 
        2&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;&lt;span id="f2" class="square"&gt;Feature 
        3&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;&lt;span id="f3" class="square"&gt;Feature 
        4&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;&lt;span id="f4" class="square"&gt;Feature 
        5&lt;/span&gt;&lt;/td&gt;
        &lt;td&gt;&lt;span id="f5" class="square"&gt;Feature 
        6&lt;/span&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;br/&gt;
</pre></div></li><li class="listitem">Add a<code class="literal"> div</code> element to hold the map:<a class="indexterm" id="id184"/><div><pre class="programlisting">&lt;div id="ch04_dom_events" style="width: 100%; height: 100%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">Now, add the JavaScript code required to instantiate the map object, set a base layer, and add a vector layer:<div><pre class="programlisting">&lt;!-- The magic comes here --&gt;
&lt;script type="text/javascript"&gt;
    // Create left map
    var map = new OpenLayers.Map("ch04_dom_events");    
    var osm = new OpenLayers.Layer.OSM();        
    // Create a vector layer with one feature for each 
    previous SPAN element
    var vectorLayer = new 
    OpenLayers.Layer.Vector("Features");
</pre></div></li><li class="listitem">Populate the vector layer with six features. Each one will contain the identifier of the button that represents it:<div><pre class="programlisting">    var pointFeatures = [];
    for(var i=0; i&lt; 6; i++) {
        // Create the ID
        var id = "f"+i;
        // Regiter listeners to handle when mouse enters 
        and leaves the DOM element
        OpenLayers.Event.observe(OpenLayers.Util.
        getElement(id), 'mouseover', mouseOverListener);
        OpenLayers.Event.observe(OpenLayers.Util.
        getElement(id), 'mouseout', mouseOutListener);
        
        // Create a random point
        var px = Math.random()*360-180;
        var py = Math.random()*160-80;
        var pointGeometry = new 
        OpenLayers.Geometry.Point(px, py);
        OpenLayers.Projection.transform(pointGeometry, 
        new OpenLayers.Projection("EPSG:4326"), new 
        OpenLayers.Projection("EPSG:900913"));
        var pointFeature = new 
        OpenLayers.Feature.Vector(pointGeometry, {
            elem_id: id
        });
        pointFeatures.push(pointFeature);
    }
    vectorLayer.addFeatures(pointFeatures);
    
    map.addLayers([osm, vectorLayer]);
    map.setCenter(new OpenLayers.LonLat(0, 0), 1);
</pre></div></li><li class="listitem">Finally, add the code that implements the event listeners:<a class="indexterm" id="id185"/><div><pre class="programlisting">    // Listeners
    function mouseOverListener(event) {
        var id = event.target.id;
        var feature = vectorLayer.
        getFeaturesByAttribute('elem_id', id);
        vectorLayer.drawFeature(feature[0], "select");
    }
    function mouseOutListener(event) {
        var id = event.target.id;
        var feature = vectorLayer.
        getFeaturesByAttribute('elem_id', id);
        vectorLayer.drawFeature(feature[0], "default");
    }
&lt;/script&gt;
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec14"/>How it works...</h3></div></div></div><p>We have created six buttons, identified from<code class="literal"> f0</code> to<code class="literal"> f5</code>, and we want to create six features that represent them. To do this, in the<code class="literal"> for</code> loop, first we create a string with an identifier:<a class="indexterm" id="id186"/>
</p><div><pre class="programlisting">        var id = "f"+i;
</pre></div><p>Then, register an event listener function for the<code class="literal"> mouseover</code> and<code class="literal"> mouseout</code> events:</p><div><pre class="programlisting">        OpenLayers.Event.observe(OpenLayers.Util.getElement(id), 
        'mouseover', mouseOverListener);
        OpenLayers.Event.observe(OpenLayers.Util.getElement(id), 
        'mouseout', mouseOutListener);
</pre></div><p>This is done by using the<code class="literal"> OpenLayers.Event.observe</code> method, which requires three parameters. These parameters are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">elementParam:</code> The<code class="literal"> DOM</code> element reference, or its identifier, which we want to listen to for<code class="literal"> tis</code> events</li><li class="listitem" style="list-style-type: disc"><code class="literal">name:</code> The event you want to listen to</li><li class="listitem" style="list-style-type: disc"><code class="literal">observer:</code> The function that will act as a listener</li></ul></div><p>Because we need to pass the<code class="literal"> DOM</code> element reference, we need to get it first. To get an element reference when its identifier is available, we can use the helper method<code class="literal"> OpenLayers.Util.getElement</code>.</p><p>From the<code class="literal"> elementParam</code> definition, you can see that the use of<code class="literal"> OpenLayers.Util.getElement</code> is not strictly necessary. If we pass an ID, the<code class="literal"> OpenLayers.Event.observe</code> method will internally use the<code class="literal"> OpenLayers.Util.getElement</code> function to get the element reference, so the next two lines will have the same result:</p><div><pre class="programlisting">        OpenLayers.Event.observe(id, 'mouseover', mouseOverListener);
        OpenLayers.Event.observe(OpenLayers.Util.getElement(id), 'mouseover', mouseOverListener);
</pre></div><div><h3 class="title"><a id="note44"/>Note</h3><p>The<code class="literal"> OpenLayers.Util</code> class has plenty of methods to help in working with the<code class="literal"> DOM</code> elements, arrays, and many more functions. We encourage you to take a look.</p></div><p>Once the listeners are registered, we create a random point feature and add it to the vector layer:</p><div><pre class="programlisting">        var px = Math.random()*360-180;
        var py = Math.random()*160-80;
        var pointGeometry = new OpenLayers.Geometry.Point(px, py);
</pre></div><p>Remember to transform the point coordinates to the projection used by the map. In this case, because the base layer is OSM and the map has no specified projection property, the OSM projection will be used:<a class="indexterm" id="id187"/>
</p><div><pre class="programlisting">        OpenLayers.Projection.transform(pointGeometry, new 
        OpenLayers.Projection("EPSG:4326"), new 
        OpenLayers.Projection("EPSG:900913"));
        var pointFeature = new 
        OpenLayers.Feature.Vector(pointGeometry, {
            elem_id: id
        });
        pointFeatures.push(pointFeature);
</pre></div><p>We have created the feature by passing a custom attribute<code class="literal"> elem_id</code>, which will store the identifier of the button that represents the feature. This way we have a reference to connect the feature and the button.</p><p>The following screenshot shows how custom attributes are stored within the feature<code class="literal"> attributes</code> property:</p><div><img alt="How it works..." src="img/7843_ch04_03.jpg"/></div><p>At this point we have six buttons and six features, which store the corresponding button identifiers as the custom attributes. Now, the task is to implement the listener function. Let's have a look at the<code class="literal"> mouseOverListener</code> function.</p><div><pre class="programlisting">    function mouseOverListener(event) {
        var id = event.target.id;
        var feature = 
        vectorLayer.getFeaturesByAttribute('elem_id', id);
        vectorLayer.drawFeature(feature[0], "select");
    }
</pre></div><p>From the event, which is a browser<code class="literal"> MouseEvent</code>, we get the identifier of the target element that has triggered the event:<a class="indexterm" id="id188"/>
</p><div><pre class="programlisting">        var id = event.target.id;
</pre></div><p>Next, using the<code class="literal"> OpenLayers.Layers.Vector.getFeatureByAttribute</code> method, we get an array of features within the vector layer that has the<code class="literal"> elem_id</code> with the value<code class="literal"> id</code>. Of course, here it will always return an array with only one element:</p><div><pre class="programlisting">        var feature = 
        vectorLayer.getFeaturesByAttribute('elem_id', id);
</pre></div><p>Now, we have the feature. Simply redraw it with a different render intent. Select to highlight the feature as selected and put its style back to default:</p><div><pre class="programlisting">        vectorLayer.drawFeature(feature[0], "select");
</pre></div><div><h3 class="title"><a id="note45"/>Note</h3><p>We will see more about styling features in<a class="link" href="ch07.html" title="Chapter 7. Styling Features"> Chapter 7</a>,<em> Styling Features</em>. Meanwhile, consider render intents as predefined styles to render features.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec15"/>There's more...</h3></div></div></div><p>OpenLayers defines a global variable<code class="literal"> $</code>, which points to the<code class="literal"> OpenLayers.Util.getElement</code> function, if it does not exist. This way we can get a reference to an element in a short way.</p><p>For example, the next two lines have the same result:</p><div><pre class="programlisting">$("some_ID")
OpenLayers.Util.getElement("some_ID")
</pre></div><p>Be careful with the use of the<code class="literal"> $</code> function. Many JavaScript libraries, one of the most known is jQuery library (<a class="ulink" href="http://jquery.com">http://jquery.com</a>), also define the global<code class="literal"> $</code> object as a common way to operate with it. So, check twice the order in which you have imported libraries on your application and where the<code class="literal"> $</code> function really points.</p><p>As a curiosity, while getting an element reference by its identifier with<code class="literal"> OpenLayers.Util.getElement</code> written:</p><div><pre class="programlisting">$("some_ID")
</pre></div><p>jQuery library requires you to use the<code class="literal"> #</code> character:</p><div><pre class="programlisting">$("#some_ID")
</pre></div><div><div><div><div><h4 class="title"><a id="ch04lvl3sec02"/>Stop observing</h4></div></div></div><p>We can be interested in observing some event, in the same way, we can also have a desire to stop observing it.<a class="indexterm" id="id189"/>
</p><p>Similar to the<code class="literal"> OpenLayers.Event.observe</code> method, given an element reference or a string identifier, the<code class="literal"> OpenLayers.Event.stopObservingElement</code> method allows us to stop observing some<code class="literal"> DOM</code> element.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl2sec16"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Creating features programmatically</em> recipe in<a class="link" href="ch03.html" title="Chapter 3. Working with Vector Layers"> Chapter 3</a>, <em>Working with Vector Layers</em></li><li class="listitem" style="list-style-type: disc">The<em> Styling features using symbolizers</em> recipe in<a class="link" href="ch07.html" title="Chapter 7. Styling Features"> Chapter 7</a>, <em> Styling Features</em></li><li class="listitem" style="list-style-type: disc">The<em> Creating a side-by-side map comparator</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Listening for vector layer features' events</em> recipe</li></ul></div></div></div></div></body></html>