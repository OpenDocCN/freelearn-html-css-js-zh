<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Unit Test, Stub, Spy, and Mock Your App"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Unit Test, Stub, Spy, and Mock Your App</h1></div></div></div><p>Majority of developers believe that testing is essential, but in reality only a few of them actually go for test-driven development. Testing falls under one of the best practices of the JavaScript development process. Hence, we decided to include a chapter on how to unit test Backbone-based applications.</p><p>A number of popular testing libraries, such as <code class="literal">QUnit</code>, <code class="literal">Jasmine</code>, <code class="literal">Mocha</code>, and <code class="literal">SinonJS</code>, are available to unit test JavaScript applications. In this chapter, we are going to show you how to test with <code class="literal">QUnit</code>, the simplest yet robust testing platform, which is pretty easy to learn as well. In the latter part, we will look into <code class="literal">SinonJS</code> to learn test spies, stubs, and mocks. Together, <code class="literal">QUnit</code> and <code class="literal">SinonJS</code> create a strong tool to test every part of your app. The main points to be discussed in this chapter are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Why unit testing is important</strong></span>: Testing is a habit. Continuing this along with development may take some extra time initially, but it is essential especially while working in a team or developing complex applications.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Testing with QUnit</strong></span>: We will look into the basic aspects of <code class="literal">QUnit</code>, and we will see how to use them for the <code class="literal">Backbone.js</code> components.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Using spies, stubs, and mocks with SinonJS</strong></span>: Spying on the behavior of JavaScript functions and controlling their behavior whenever needed from a test environment is absolutely necessary for unit testing. We will look into this concept briefly with the <code class="literal">SinonJS</code> test framework.</li></ul></div><div class="section" title="Understanding why unit testing is important"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Understanding why unit testing is important</h1></div></div></div><p>If you already<a id="id298" class="indexterm"/> know the benefits of testing and follow the best practices while developing your JavaScript apps, you can skip this section. If you still wonder why you should actually test your application while you are already writing clean and maintainable code, the following are a few reasons to consider:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Testing is never a waste of time. You do not need to run your code repeatedly to see whether it works or not. You can run all the test cases at once to see whether everything is functioning as expected. Testing gives you the confidence that your code is working fine.</li><li class="listitem" style="list-style-type: disc">Unit tests are really fast to create and fast to run too.</li><li class="listitem" style="list-style-type: disc">Update your code without worry. Your test will tell you whether the function is working as it is expected to or not. You will find this very helpful, especially when you work in a team.</li><li class="listitem" style="list-style-type: disc">Once you start writing unit tests for your code, you will soon find that you are writing more modular, flexible, and testable code than you used to.</li><li class="listitem" style="list-style-type: disc">In <span class="strong"><strong>Test Driven Development</strong></span> (<span class="strong"><strong>TDD</strong></span>)<a id="id299" class="indexterm"/>, you write failing test cases first and then develop the code. In that case, a passing test case ensures that your developed code works fine without any issues.</li></ul></div><p>Testing is fun. It's not<a id="id300" class="indexterm"/> very easy, sure, and not something that you can master in a day. It is not very difficult either—lots of developers are doing it and you can do it too.</p></div></div>
<div class="section" title="Testing with QUnit"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Testing with QUnit</h1></div></div></div><p>
<code class="literal">QUnit</code> (<a class="ulink" href="http://qunitjs.com">http://qunitjs.com</a>), a<a id="id301" class="indexterm"/> lightweight<a id="id302" class="indexterm"/> unit testing framework maintained by the jQuery team, which is quite easy to work with compared to other frameworks. Discussing <code class="literal">QUnit</code> in complete detail is beyond the scope of this book, but we will learn about the simple features of it and explore how we can use it with our Backbone components.</p><p>Assertions are the most essential elements of any unit test framework. You need to compare your actual implementation values to the results that the test produces. Assertions are the methods that serve this comparison functionality. <code class="literal">QUnit</code> has only eight assertions; we are going to use some of them in the next section. Let's discuss a few of them here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ok (state, message)</code>: This passes if the first argument is true</li><li class="listitem" style="list-style-type: disc"><code class="literal">equal (actual, expected, message)</code>: This returns true if <code class="literal">actual</code> and <code class="literal">expected</code> are equal</li><li class="listitem" style="list-style-type: disc"><code class="literal">deepEqual (actual, expected, message)</code>: This is a deep recursive-comparison assertion, working on primitive types, arrays, objects, regular expressions, dates, and functions</li><li class="listitem" style="list-style-type: disc"><code class="literal">strictEqual (actual, expected, message)</code>: This is a strict type and a value comparison assertion</li><li class="listitem" style="list-style-type: disc"><code class="literal">throws (block, actual, message)</code>: This is an assertion to test whether a callback throws an exception when run</li></ul></div><p>There are few <a id="id303" class="indexterm"/>more asserts: <code class="literal">notEqual()</code>, <code class="literal">notDeepEqual()</code>, and <code class="literal">notStrictEqual()</code>. The functionalities of these are clearly the opposite of their counterparts. In addition to these, <code class="literal">QUnit</code> has a number of test methods that are used to initiate the tests. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">asyncTest()</code>: This adds an asynchronous test to run</li><li class="listitem" style="list-style-type: disc"><code class="literal">expect()</code>: This specifies how many assertions are expected to run within a test</li><li class="listitem" style="list-style-type: disc"><code class="literal">module()</code>: This consists of group-related tests under a single label</li><li class="listitem" style="list-style-type: disc"><code class="literal">test()</code>: This adds a test to run</li></ul></div><p>Setting up <code class="literal">QUnit</code> is fairly straightforward. First we will create a <code class="literal">test</code> directory and put it inside our project directory. This <code class="literal">test</code> folder is going to hold all our test files of the project. Then, inside this folder, we will create an HTML file, which will show all the test results in our browser. In general, <code class="literal">QUnit</code> comes up with <code class="literal">qunit.js</code> and a <code class="literal">qunit.css</code> files. You need to just include the following code snippet as given in the QUnit website (<a class="ulink" href="http://qunitjs.com">http://qunitjs.com</a>) in your HTML file and you are done with the QUnit setup:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;QUnit Example&lt;/title&gt;
  &lt;link rel="stylesheet" href="/resources/qunit.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="qunit"&gt;&lt;/div&gt;
  &lt;div id="qunit-fixture"&gt;&lt;/div&gt;
  &lt;script src="/resources/qunit.js"&gt;&lt;/script&gt;
  &lt;script src="/resources/tests.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>The <code class="literal">tests.js</code> file will hold all your test cases. You can have multiple test files depending on your requirements. If you found that this section is a little complex and it is difficult to understand all the definitions of assertion methods, do not worry. In the next section, we will show you a simple <code class="literal">QUnit</code> test case with few of these assertions, and you will see how easy it is to get started with <code class="literal">QUnit</code>.</p><div class="section" title="Performing a basic test case"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec50"/>Performing a basic test case</h2></div></div></div><p>We <a id="id304" class="indexterm"/>learned the basic and important API methods of <code class="literal">QUnit</code>. Now, <a id="id305" class="indexterm"/>let's use few of them to create a simple test case. We will write a method that checks whether a number is prime or not. Then we will make a couple of calls to the <code class="literal">isPrime()</code> method<a id="id306" class="indexterm"/> from our test and analyze the results as follows:</p><div class="informalexample"><pre class="programlisting">// Function to check a prime number
function isPrime(number) {
  var start = 2;
  while (start &lt;= Math.sqrt(number)) {
    if (number % start++ &lt; 1) return false;
  }
  return number &gt; 1;
}

test('Test a prime number', function () {
  // tells you how many assertions are there in the test
  expect(2);

  // following two assertions check with two numbers 
  // whether they are prime number or not
  ok(isPrime(3), '3 is a prime number');
  equal(isPrime(8), false, '8 is not a prime number');
});</pre></div><p>A rather <a id="id307" class="indexterm"/>simple example is shared in the previous code snippet to show how easy it is to get started with <code class="literal">QUnit</code>. We use the <code class="literal">expect()</code> method at first to assure that we will be doing two assertions in this test case. If we do more than two assertions, then this test will fail. Now, those two asserts, namely <code class="literal">ok()</code> and <code class="literal">equal()</code>, call the <code class="literal">isPrime()</code> method<a id="id308" class="indexterm"/> with two <a id="id309" class="indexterm"/>different inputs and check whether those input values are prime numbers or not. When you run this test, you can see both the tests to pass through.</p></div><div class="section" title="Understanding the QUnit module (), setup (), and teardown () methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec51"/>Understanding the QUnit module (), setup (), and teardown () methods</h2></div></div></div><p>To organize multiple test cases, we need something that can provide a block structure and hold multiple tests together. The <a id="id310" class="indexterm"/>
<code class="literal">module()</code> method<a id="id311" class="indexterm"/> allows us to group the test cases together. Furthermore, it introduces the two methods, <a id="id312" class="indexterm"/>
<code class="literal">setup()</code><a id="id313" class="indexterm"/> and <a id="id314" class="indexterm"/>
<code class="literal">teardown()</code><a id="id315" class="indexterm"/>, that run before and after each test case, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">// First module
module('1st module', {
  setup: function () {
    // Runs before each test
  },
  teardown: function () {
    // Runs after each test
  }
});
test('Test 1', function () {});
test('Test 2', function () {});

// Second module
module('2nd module');
test('Test 1', function () {});</pre></div><p>The <code class="literal">setup()</code> method is quite useful when you need to instantiate an object (such as a view or a collection) that will be used in multiple tests. The <code class="literal">teardown()</code> method, on the other hand, is mostly used to clean up the resources that you added as global variables.</p></div><div class="section" title="Testing Backbone.js components with QUnit"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec52"/>Testing Backbone.js components with QUnit</h2></div></div></div><p>Now as we<a id="id316" class="indexterm"/> understand the basics of <code class="literal">QUnit</code>, let's try it with <a id="id317" class="indexterm"/>some Backbone components. We will first start with a Backbone model and we will create a simple <code class="literal">User</code> model, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var User = Backbone.Model.extend({
  defaults: {
    name: 'Swapan Guha',
    age: 56
  }
});

module('User model tests', {
  setup: function () {
    this.user = new User();
    this.user.set('age', 62);
  }
});

test('Can be instantiated with a default name and age to be set', function () {
  equal(this.user.get('name'), 'Swapan Guha');
  equal(this.user.get('age'), 64);
});</pre></div><p>Here, we tested the Backbone model with one of its default values and another attribute that we changed in the <code class="literal">setup()</code> method, but intentionally tested it with another value. So, this test should fail for one assert case. The following screenshot shows how it will look in a browser:</p><div class="mediaobject"><img src="graphics/3576_08_01.jpg" alt="Testing Backbone.js components with QUnit"/></div></div></div>
<div class="section" title="Using test spies, stubs, and mocks with SinonJS"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Using test spies, stubs, and mocks with SinonJS</h1></div></div></div><p>We use unit testing to test one component of an application. That component can be a function, an object, a variable, or any outcome which is not known yet, and your unit test wants to make sure whether that particular component is working fine or not. Often, besides testing separate components, you may find testing the behavior of your methods is of the same importance. For example, how many times a method is called, what it returns, whether it has thrown any exception, what arguments it is called with, and so on. To perform these types of behavioral testing, we use test spies, stubs, and mocks.</p><p>There are few testing libraries which support test spies, stubs, and mocks. However, we found <code class="literal">SinonJS</code> quite easy to work with and robust as well. <code class="literal">SinonJS</code> works seamlessly with <code class="literal">QUnit</code> and you can use it with or without <code class="literal">QUnit</code> too. The definition of <code class="literal">SinonJS</code>, as given on their website, is as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>Standalone test spies, stubs and mocks for JavaScript. No dependencies, works with any unit testing framework.</p></blockquote></div><div class="section" title="Testing with spies"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec53"/>Testing with spies</h2></div></div></div><p>We first <a id="id318" class="indexterm"/>need to know what a spy is. By definition, as given on the <code class="literal">SinonJS</code> website, a spy is as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>A test spy is a function that records arguments, return value, the value of this and exception thrown (if any) for all its calls. A test spy can be an anonymous function or it can wrap an existing function.</p></blockquote></div><p>So your next question should be why a spy should be used. We use test spies to test the behavior of callback and other methods, and to understand how they work. You will find out the answer in more detail once you look into some API methods associated with spies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">called()</code>: This returns true if the spy was called at least once</li><li class="listitem" style="list-style-type: disc"><code class="literal">calledOnce()</code>: This returns true if the spy was called exactly once</li><li class="listitem" style="list-style-type: disc"><code class="literal">returned()</code>: This returns true if the spy returned the provided value at least once</li></ul></div><p>These are <a id="id319" class="indexterm"/>few of the supported methods of the spy API. Hopefully, now you can understand why a spy is used—it allows you to test multiple characteristics of a function, to know whether it gets called only once, or to check what value it returns. A spy allows you every possibility to test the complete flow of a function. Now let's see how to use a spy from the following code snippet:</p><div class="informalexample"><pre class="programlisting">// A User model definition
var User = Backbone.Model.extend({
  defaults: {
    name: ''
  },

  // Split the name to provide an array of first and last name
  getNameAsArray: function () {
    return this.get('name').split(' ');
  }
});

test('should call getNameAsArray and return an array',function () {
  this.user = new User({
    name: 'Krishnendu Saha'
  });

  // Added a spy on the the "getNameAsArray" method
  sinon.spy(this.user, 'getNameAsArray'); // or this.spy()
  this.user.getNameAsArray();

  // We check whether the method is called only once
  ok(this.user.getNameAsArray.calledOnce);

  // We check whether the returned value of this 
  // method is an array
  equal(_.isArray(this.user.getNameAsArray.returnValues[0]),true);
});</pre></div><p>We used the <a id="id320" class="indexterm"/>same <code class="literal">User</code> model and added a <code class="literal">getNameAsArray()</code> method<a id="id321" class="indexterm"/> to it. We spied on this method to test whether it gets called only once and returns an array. The previous test case passes fine.</p><p>So, you can use spies for any or all of the following cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check for the invocation of a callback</li><li class="listitem" style="list-style-type: disc">Validate whether callbacks are executed with certain arguments</li><li class="listitem" style="list-style-type: disc">Validate if internal functions provide the correct return value</li><li class="listitem" style="list-style-type: disc">Validate a certain simple calling behavior</li></ul></div></div><div class="section" title="Testing with stubs"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec54"/>Testing with stubs</h2></div></div></div><p>A test stub, <a id="id322" class="indexterm"/>on the other hand, extends from a spy and adds some extra functionality to it. It is a function with preprogramed behavior and supports the complete spy API. It is used to replace (or fake) the behavior of an existing method with something. It is quite useful when you want to prevent a specific method from being called directly, or force a method to throw an error in order to test error handling. Like spies, stubs can either be anonymous, or they can wrap the existing functions. When wrapping an existing function with a stub, the original function is not called.</p><p>An anonymous stub can be defined as follows:</p><div class="informalexample"><pre class="programlisting">var stub = sinon.stub();</pre></div><p>As a wrapper to a method of an object, it can be defined as follows:</p><div class="informalexample"><pre class="programlisting">var stub = sinon.stub(object, "method");</pre></div><p>Here the function <code class="literal">object.method</code> is replaced with an anonymous stub function. You can also add one more function as the third parameter to the <code class="literal">stub()</code> function, which will work as a spy on <code class="literal">object.method</code> and will replace the original method as follows:</p><div class="informalexample"><pre class="programlisting">var stub = sinon.stub(object, "method", function(){});</pre></div><p>To understand how a spy works with a real example, we can use the same <code class="literal">User</code> model that we previously used. This is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">// We will use the same User model definition here

module("Should work when getNameAsArray method is called", {
  setup: function () {
    this.user = new User();

    // Use a stub to replace the getNameAsArray method
    this.userStub = sinon.stub(this.user, "getNameAsArray");
    this.userStub.returns([]);
  },

  // Restore the original method
  teardown: function () {
    this.userStub.restore();
  }
});

test('should call getNameAsArray and must return an empty array', function () {
  this.user.getNameAsArray();

  // Should return an empty array
  equal(_.isArray(this.user.getNameAsArray.returnValues[0]), true);
  equal(this.user.getNameAsArray.returnValues[0].length, 0);
});</pre></div><p>Here, we<a id="id323" class="indexterm"/> stub the <code class="literal">getNameAsArray()</code> method of the <code class="literal">User</code> model and return an empty array. So while you call the <code class="literal">getNameAsArray()</code> method, <span class="emphasis"><em>not the method but the stub will get called</em></span>. We made sure that the stub returns an empty array.</p><p>Now the test is as simple as the one we did earlier. We just call the <code class="literal">getNameAsArray()</code> method on the <code class="literal">User</code> instance and check the length of the returned value.</p></div><div class="section" title="Testing with mocks"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec55"/>Testing with mocks</h2></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>Mocks (and mock expectations) are fake methods (like spies) with pre-programmed behavior (like stubs) as well as pre-programmed expectations. A mock will fail your test if it is not used as expected.</p></blockquote></div><p>This is the definition of mock as given in the <code class="literal">SinonJS</code> website (<a class="ulink" href="http://sinonjs.org/docs/#mocks">http://sinonjs.org/docs/#mocks</a>). Mocks are<a id="id324" class="indexterm"/> quite similar to stubs, but they come with built-in expectations. They implement both the spy and stub APIs. With a mock, you define all the expectations that should happen in your test. When all those things are done, you assert whether those things happened exactly the way they were planned. So you define the expectations and if they aren't met, the test fails.</p><p>Now, how do we use a mock? We mock an object, set expectations on its methods, and apply modifiers on these expectations. Then we verify whether the test passes all the expectations or not. To understand it better, let's explore a simple example with mock, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">test('should call getNameAsArray once and check it is called on the user model', function () {
  this.user = new User({
    name: 'Subodh Guha'
  });

  var mock = sinon.mock(this.user);

  // We set the expectations here
  mock.expects('getNameAsArray').once().on(this.user);

  // Execution happens here
  this.user.getNameAsArray();

  // Now we verify whether the expectations are met or not
  mock.verify();
});</pre></div><p>We use the <a id="id325" class="indexterm"/>same <code class="literal">User</code> model here and create a mock with a <code class="literal">User</code> instance. Then we set the expectation on the mock to see whether the <code class="literal">getNameAsArray()</code> method is called only once on that <code class="literal">User</code> instance. All these expectations are set beforehand and we verify them all together at the end.</p><div class="section" title="Difference between mocks and stubs"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec13"/>Difference between mocks and stubs</h3></div></div></div><p>Now, because stubs and mocks are similar in functionality, you may wonder why and when you should use a<a id="id326" class="indexterm"/> mock instead of a stub. As given by the website, you would use a mock only when you want to provide both alternate functionality and an expectation in your test. The main difference you can see is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mock objects are used to define expectations, that is, in a particular scenario, we expect the <code class="literal">Foo()</code> method to be called with a set of parameters. Mock records and verifies such expectations that whether the <code class="literal">foo()</code> method actually got called with those parameters or not.</li><li class="listitem" style="list-style-type: disc">Stubs, on the other hand, have a different purpose—they do not record or verify expectations, but rather allow us to "replace" the behavior and the state of the "fake" object in order to utilize a test scenario.</li></ul></div><p>To test the life cycle with stubs, proceed with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Set up data: Prepare the object that is being tested and its stubs collaborators.</li><li class="listitem">Exercise: Test the functionality.</li><li class="listitem">Verify state: Use asserts to check the object's state.</li><li class="listitem">Teardown: Clean up the resources.</li></ol></div><p>To test the life cycle with mocks, proceed with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Set up data: Prepare object that is being tested.</li><li class="listitem">Set up expectations: Prepare expectations in a mock that is being used by the primary object.</li><li class="listitem">Exercise: Test the functionality.</li><li class="listitem">Verify expectations: Verify that correct methods have been invoked in the mock.</li><li class="listitem">Verify state: Use asserts to check the object's state.</li><li class="listitem">Teardown: Clean up the resources.</li></ol></div><p>As you can see, <a id="id327" class="indexterm"/>there are pre and post states for a mock. We set the expectation before the test and verify it afterwards. Anyway, the purpose of both stub and mock is to eliminate testing all the dependencies of a class or function so that your tests are more focused and simple in what they are trying to prove.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Summary</h1></div></div></div><p>We have included a number of books and tutorials related to <code class="literal">QUnit</code> and <code class="literal">SinonJS</code> in the <a class="link" href="apa.html" title="Appendix A. Books, Tutorials, and References">Appendix A</a>, <span class="emphasis"><em>Books, Tutorials, and References</em></span>. You can follow them to get a more detailed idea about these two technologies.</p><p>A few testing concepts were described in this chapter. You got an idea about the power of <code class="literal">QUnit</code> and <code class="literal">SinonJS</code>, and how to use them extensively to unit test your JavaScript application. Though that barely scratches the surface, we never intended to cover everything about testing in this book either. We just tried to make you aware of the fact that testing is an absolutely important part of the application development process, and you should make it a habit to write test cases whenever you develop. It will make your code more structured, flexible, and easier to use for your teammates.</p></div></body></html>