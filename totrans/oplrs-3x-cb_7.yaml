- en: Chapter 7. Styling Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Styling features using symbolizers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving style using StyleMap and the replacement of the feature's attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with StyleMap and the render intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with unique value rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining custom rules to style features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling clustered features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we know how to work with vector layers, such as adding new features or
    modifying the existing ones, the question we can have in mind is: how to style
    them?'
  prefs: []
  type: TYPE_NORMAL
- en: The visual representation of features, the **style**, is one of the most important
    concepts in GIS applications. It is not only important from the user's experience
    or designer's perspective but also as an information requirement, for example,
    to identify features that match certain rules.
  prefs: []
  type: TYPE_NORMAL
- en: The way we visualize features is not only important to make our application
    much more attractive, but also to improve the way we bring information to the
    user. For example, given a set of points that represent some temperatures, if
    we are interested on the hottest zones, we could represent them with different
    radius and color values. This way, a lesser radius and a color near to blue means
    a cold zone while a greater radius and a color near to red means a hot zone.
  prefs: []
  type: TYPE_NORMAL
- en: OpenLayers offers us a great degree of flexibility when styling features that
    can initially seem a bit complex. Concepts such as symbolizers, StyleMap, rules,
    or filters are all related with the process of styling.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see all this in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Styling features using symbolizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see the most basic form of styling a feature, we are going to create a little
    map editor that allows adding new features by specifying some few style properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling features using symbolizers](img/7843_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each `OpenLayers.Feature.Vector` instance can have a style associated with
    it. This style is called **symbolizer**, which is nothing more than a JavaScript
    object with some fields that specify the fill color, stroke, and so on. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the code, every time a feature is going to be added to the map, the code
    will get the fill and stroke properties from the controls on the left-hand side
    and will create a new symbolizer hash to be used by the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code has two main sections, one for HTML, where all the controls
    are placed, and a second one for the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML section has plenty of codes related with the controls used to select
    the fill and stroke properties. These controls come from the Dojo Toolkit project
    ([http://dojotoolkit.org](http://dojotoolkit.org)) and because they are not the
    goal of this recipe, we have not covered it here. We encourage the reader to take
    a look at it in the code bundle of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating the HTML file including OpenLayers dependencies (see the *Getting
    ready* section for the HTML code), create the `map` instance in the `div` element
    identified by `ch07_using_symbolizers` and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a vector layer where new features will be placed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `OpenLayers.Control.EditingToolbar` control that allows to add new
    features to the previous vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the code responsible, to get and apply the style to the new features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea is, each time a feature is added to the layer using the EditingToolbar
    control, create a symbolizer and apply it to the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to register a `beforefeatureadded` event listener in the
    vector layer so that we are notified each time a new feature is going to be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function `setFeatureStyle` is called every time a new feature is added.
    An `event` parameter is passed on each call, pointing to the feature to be added
    (`event.feature`) and a reference to the vector layer (`event.object`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `event.object` references the object passed as the `object` parameter in
    the `event.register(event_type, object, listener)` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once we obtain the property values from the Dojo widgets, we create a new symbolizer.
  prefs: []
  type: TYPE_NORMAL
- en: The `OpenLayers.Feature.Vector` class defines some style symbolizers in the
    `style` array property, so the quickest way is to create a copy of one of those
    styles (actually we have extended it) and then modify some of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The question that can arise here is: what takes precedence when styling, a
    rule applied to a vector layer or a symbolizer applied to a single feature?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is: styles goes from bottom to top, that is, if we have specified
    a symbolizer in a feature then it will be used to render it, otherwise, any rule
    or StyleMap assigned to the vector layer will be applied to its features.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Improving style using StyleMap and the replacement of feature's attributes*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Playing with StyleMap and the render intents* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving style using StyleMap and the replacement of feature's attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can summarize that there are two ways to style a feature. The first is applying
    a symbolizer hash directly to the feature (see the *Styling features using symbolizers*
    recipe). The second is applying the style to the layer so every feature contained
    in it becomes styled.
  prefs: []
  type: TYPE_NORMAL
- en: The second one is the preferred way in many situations. It is a generic way
    to style all the features in a layer by setting some styles and rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe shows how we can use the `StyleMap` instances and how easily we
    can style all the points of a layer without applying a style on each feature.
    The output of this recipe should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Improving style using StyleMap and the replacement of feature''s attributes](img/7843_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition, the technique we will use allows us to involve the feature's attributes
    to select a point radius and color, creating them all together more dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have created the HTML file with OpenLayers dependencies, start creating
    the `div` element that will hold the map instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create the map instance and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s start defining the style for the whole layer. First create a color
    palette for the points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a style instance from a previous symbolizer hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a vector layer applying the desired `StyleMap:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create some random points. Each feature will have two attributes `radius`
    and `temp` with random values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's go to describe first the random point features we have added to the vector
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to create some random points at random places. Because of this,
    we create some random x-y values, transform to map coordinates, create geometry,
    and finally create a feature with that geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we are setting in each feature, a couple of attributes `(radius`
    and `temp)` with random values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These attributes will be used later in the feature's style definition.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go to describe the creation of the style for the vector layer.
  prefs: []
  type: TYPE_NORMAL
- en: We want each feature to be represented as a point using the attribute `radius`
    for the point's radius and the `temp` attribute for the point's color.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a symbolizer by hash copying (actually extending)
    that is defined at `OpenLayers.Feature.Vector.style["default"])`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the source code you will find that `OpenLayers.Feature.Vector.style["default"])`
    is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once we have a fresh copy of the symbolizer, we change the `fillColor` and `pointRadius`
    properties. What is the challenge here? Well, we do not want fixed values for
    these properties, we want these properties to take their values from the feature's
    attributes they are styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, OpenLayers helps us with the **attribute replacement** syntax.
    In the same way, we can write a literal value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify that the radius value must come from the feature''s `featureRadius`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So in our sample, our features have the attribute `radius` defined as a random
    value that can be used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way as we can use an attribute to be replaced as the property value,
    we can also set a function which must return the value to be used as the property
    value. This is the case for the `fillColor` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we will see next, the function `colorFunction` returns a value depending
    on the feature's `temp` attribute, that is, we do not want to use the `temp` attribute
    directly but a value computed from it.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, attribute replacement cannot be used directly in a symbolizer
    hash applied to a feature or layer, it only works through an `OpenLayers.Style`
    instance. In addition, thanks to the `OpenLayers.Style` instance, we can define
    the functions, such as `colorFunction` to be used to compute a style property
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Attribute replacement can only be used through an `OpenLayers.Style` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe, once we define the symbolizer hash, we can create an instance
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the symbolizer hash that has been previously defined,
    which makes use of the attribute's replacement feature. The second parameter,
    the `context`, is an object passed in the process of rendering features. Here
    we define the required functions, such as the `colorFunction` that will be available
    in the rendering process, and will define the value for the `fillColor` depending
    on the `temp` attribute of each feature.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are almost done. The only remaining thing is to create a vector
    layer that uses the defined `OpenLayers.Style` instance to style the features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OpenLayers.Layer.Vector` class has a `styleMap` property used to specify
    the styles to apply to the features. The `OpenLayers.StyleMap` class can be instantiated
    with passing a different argument, but here we are creating it using the previously
    defined `OpenLayers.Style` style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, our recipe is complete. As we can see, there is no need to create a symbolizer
    and apply it to each feature. The only thing we need to do is to define a style
    and assign it to the vector layer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Playing with StyleMap and render intents* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Styling features using symbolizers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating features programmatically* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with StyleMap and the render intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some controls, such as `SelectFeature, ModifyFeature`, or `EditingToolbar`,
    which change the style of the feature depending on its current state, that is,
    if it is selected or is currently being edited. How does OpenLayers manage this?
    The answer is, through the **render intents:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with StyleMap and the render intents](img/7843_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This recipe shows how we can modify the styles used for each render intent to
    change the look of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: This way, features will be drawn on the map using blue instead of orange. Temporary
    features, those that are going to be created, will be drawn using green. Finally,
    those features that are selected, or are in the middle of the modification process,
    will be drawn using orange.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new HTML file and add the OpenLayers dependencies. The first step
    is to add the `div` element to hold the map instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the JavaScript section, initialize the map instance, add a base layer, and
    center the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are going to create three different styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, create a `StyleMap` instance that holds the three styles created
    as three different render intents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can create a vector layer using the previous `StyleMap` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we are going to add some controls to the map to allow the addition
    of new features and modification of the existing ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every vector layer can have an `OpenLayers.StyleMap` instance associated with
    it. On its own, a `StyleMap` instance stores one or more references to the `OpenLayers.Style`
    instances, each one of which acts as a render intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Every `Style` instance stores information about a style, and usually they are
    created from a symbolizer hash, as in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have defined a new style for the three render intents: `default, select`,
    and `temporary`, which are well known render intents used by most of the controls.'
  prefs: []
  type: TYPE_NORMAL
- en: A `StyleMap` can store as many render intents as we desire, we are not limited
    to these three commonly used render intents. For example, we can define render
    intents such as `red` or `hidden`, and associate a `Style` for them that renders
    features in red or not display them at all.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By setting the property `display` to`"none"` on the style's symbolizer hash,
    we can hide features. This is usually used in the `delete` render intent.
  prefs: []
  type: TYPE_NORMAL
- en: The render intents such as `default, select`, and `temporary`, are used extensively
    by many components within OpenLayers. This way, when a feature is rendered, the
    `default` style is used. When a feature is selected using the `OpenLayers.Control.SelectFeature`
    control, the `select` render intent is used to render the features. And when we
    are creating a new feature with `OpenLayers.Control.EditingToolbar` (which internally
    uses `OpenLayers.Control.DrawFeature)`, the control renders the feature using
    the style defined on the `temporary` render intent.
  prefs: []
  type: TYPE_NORMAL
- en: So, creating new render intents is no problem. In addition, we can create our
    custom controls and let them decide which render intent the layer must use to
    render the features.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's briefly describe the code used to create the panel with the controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have created an `OpenLayers.Control.EditingToolbar` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an `OpenLayers.Control.Panel` control containing buttons that activates/deactivates
    some `OpenLayers.Control.DrawFeature` controls. Next, we have created an `OpenLayers.ControlModifyFeature`
    instance, which is a single control and we have added it to the EditingToolbar
    control so that it becomes visible as a new button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/7843_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the screenshot, the `ModifyFeature` control is represented by the cross icon.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process to style and render a feature is complex. The following lines summarize
    the main steps involved in the feature styling process.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each feature, a vector layer must render the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `OpenLayers.Layer.Vector.drawFeature(feature, style)` is called.
    It accepts two parameters: the `feature` to be drawn and the `style` to be used.
    It can be a symbolizer or a render intent string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the feature has a `style` property, it is used to render the feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if the vector layer has a `style` property, it is used to render
    the feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if the `style` argument is provided and it is a style symbolizer,
    then it is used to render the feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `style` is a render intent string, then a symbolizer is created from
    the `Style` property associated to the render intent using the `createSymbolizer`
    method. This is where feature attributes are merged within the symbolizer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Styling features using symbolizers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Improving style using StyleMap and the replacement of feature's attributes*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with unique value rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, we do not only style features by what they represent, for example a
    city or a village, but we style depending on their attributes, such as the number
    of citizens, year of foundation, and number of squares.
  prefs: []
  type: TYPE_NORMAL
- en: To help on these cases, OpenLayers offers us the possibility to define rules
    to decide how to style features. For example, we can define a rule that for all
    features of a city with a population greater than 100,000 a point with radius
    20 and color brown can be rendered, while for cities with a population less than
    100,000, a point with radius 10, color orange, and semi transparent can be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning in the world of the rules, the concept of *unique value rules* are
    the simplest case we can find. The idea is simple, apply one style or another
    depending on the value of a feature's attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to load a GeoJSON file, with some cities of the
    world, and apply a rule that will set the radius of the points depending on the
    popularity rank attribute (the `POP_RANK` attribute), as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with unique value rules](img/7843_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start creating a new HTML file and add the OpenLayers dependencies. Add a `div`
    element to hold the map instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `script` element, add the required code to initialize the map and
    add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now define different styles to be used on the `POP_RANK` feature''s attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `StyleMap` instance and define a unique value rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add a vector layer with some cities of the world and make use of the
    previous `StyleMap` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Almost all the magic of this recipe resides in the `OpenLayers.StyleMap.addUniqueValueRules()`
    method. So, the sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: means, apply to the `default` render intent the specified `style` property,
    depending on the value of the `POP_RANK` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: It makes more sense once we look at the hash style. Depending on the value of
    the `POP_RANK`, the radius of the points representing cities will vary between
    `4` and `21:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have added to the map a vector layer that uses the previously created
    `StyleMap` instance where the unique value rules are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the vector layer uses an `OpenLayers.Protocol.HTTP` instance to
    load the GeoJSON file and an `OpenLayers.Strategy.Fixed` instance is used to just
    load the source data once.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of unique value rules through the `addUniqueValueRules()` method is
    easy, but as we can understand, it works only for a discrete value range.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the flexibility is poor because it is equivalent to an *is equal* rule,
    where we have no way to map a range of values to the same style.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Playing with StyleMap and the render intents* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Defining custom rules to style features* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using point features as markers* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with popups* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining custom rules to style features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will see a brief explanation before continuing with this recipe. The goal,
    as in the other recipes in the chapter, is to style the features of a vector layer
    depending on their attributes' values or their kind of feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, an `OpenLayers.Layer.Vector` layer class can have an `OpenLayers.StyleMap`
    instance associated with it, which determines the default style of the layers
    if it has only one `OpenLayers.Style`, or the set of styles that can be applied
    for each render intent if it contains more than one `OpenLayers.Style`. In its
    own way, each `OpenLayers.Style` instance can be used in two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Having a symbolizer hash acting as the default style to apply to the features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having some `OpenLayers.Rule` instances associated with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here we arrive to the main concept of this recipe, the **rules.**
  prefs: []
  type: TYPE_NORMAL
- en: A rule is nothing more than a join between a filter (concretely an `OpenLayers.Filter)`
    and a symbolizer, if the filter matches the feature then the symbolizer is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple thing gives us lot of flexibilities and power to style our features.
    In addition to the possibility to use symbolizers with attribute replacement,
    we can also use the set of filters OpenLayers offers us: comparison filters, spatial
    filters, or logical filters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this recipe is to load a GML file with European countries and style
    them depending on their `AREA` attribute, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining custom rules to style features](img/7843_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once created an HTML file with the OpenLayers dependencies, add the `div` element
    to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the JavaScript code section, initialize the map, add OpenStreetMap as the
    base layer, and center the map at the desired place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define five different rules to style elements based on the `AREA` attribute
    of the features. The following code has the rule to check if the value is less
    than 10,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code has the rule to check if the value is between 10,000 and
    25,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rule to check if the value is between 25,000 and 50,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rule to check if the value is between 50,000 and 100,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, the rule to check for values greater than 100,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the style with the customary rules defined previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a vector layer that loads the GML file and uses the previous
    style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we described at the beginning of the recipe, an `OpenLayers.Style` instance
    admits a set of `OpenLayers.Rule` instances to style the features.
  prefs: []
  type: TYPE_NORMAL
- en: Given a rule, all the features that match the specified `OpenLayers.Filter`
    are styled with the specified symbolizer hash, and thanks to the filters, we have
    enough flexibility to create the comparison or logical filters.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, we have created five filters. Let's describe two of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aRule` rule is formed by a comparison filter that matches all the features
    with an `AREA` attribute having a value less than 10,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bRule` uses a more complex rule. In this case, it is a logical `AND` filter
    composed of two comparison filters. It matches all the features to check whether
    their `AREA` attribute is greater than 10,000 and less than or equal to 25,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created all the desired rules, we can create an `OpenLayers.Style`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then apply it to the vector layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have created an `OpenLayers.StyleMap` instance passing only one style and
    not a style for each desired render intent. This means there will be no render
    intents in the layer, or expressed in other words, all the render intents will
    be rendered with the same style.
  prefs: []
  type: TYPE_NORMAL
- en: Because the vector layer must read data from a GML file in our server, we have
    made use of an `OpenLayers.Protocol.HTTP` instance that loads files from the specified
    URL and uses an instance in the `OpenLayers.Format.GML` format to read it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to center the map's viewport, we needed to transform the coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the base layer of the map is OpenStreetMap, this makes the map''s projection
    to become EPSG:900913, while we are specifying the center location as latitude/longitude
    using the EPSG:4326\. Because of this we need to make a transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our code, we have created the style with the sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'But the `OpenLayers.Style` constructor can accept two parameters: a symbolizer
    hash, to be used as the default style, and a set of options where we need to specify
    instance properties. With this in mind we can also instantiate the style as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Working with unique value rules* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Styling features using symbolizers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Improving style using StyleMap and the replacement of feature's attributes*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling clustered features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with lots of feature points, it is common to use the cluster strategy
    to avoid overlapping of points and improve the rendering performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe we are going to show how easy it is to style a vector layer
    using a cluster strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling clustered features](img/7843_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our layer vector will read a GeoJSON file with some cities of the world. The
    style will have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: For each cluster we will show the number of contained features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The point radius and border will depend on the number of contained features,
    the more features within it, the greater the radius will be
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start adding the `div` element for the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate an `OpenLayers.Map` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add OpenStreetMap as the base layer and center the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the data from a GeoJSON file and apply the desired style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After creating the map instance and adding the base layer, we have centered
    the viewport. Note how we have translated the coordinates from EPSG:4326 (latitude/longitude)
    to EPSG:900913 used by the map (implicitly used by OpenStreetMap layer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have added the vector layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To load the GeoJSON file from our server, we have used an `OpenLayers.Protocol.HTTP`
    instance with the `OpenLayers.Format.GeoJSON` format to read it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For layer strategies, we have specified the `OpenLayers.Strategy.Fixed` to
    load the content once and the `OpenLayers.Strategy.Cluster({distance: 25})` sentence
    to group features. The property `distance` sets the pixel distance that defines
    where two features must go into the same cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point and, before continuing with the recipe, we need to describe how
    the clustering process works.
  prefs: []
  type: TYPE_NORMAL
- en: When the layer is going to be rendered, the clustering algorithm checks for
    each feature if they are too close to other ones. For each set of features that
    are too close, a new point (cluster) is created and rendered. This way the number
    of points to draw on the map can be reduced drastically. In addition, each cluster
    point feature will contain references to the set of features it represents and
    also a `count` attribute with the number of features it contains.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our code, let's see the style applied to the layer, which is the
    most important thing in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have set the style for the `default` rendering intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This means if we use some control that changes the render intent of the layer
    to something different from the default, the style will probably be different.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we create the `OpenLayers.StyleMap` instance without passing directly the
    style instance, that is, without specifying a render intent, then the style will
    be the same for any render intent: `new OpenLayers.StyleMap(our_style_here)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `OpenLayers.Style` instance defined for the layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor receives two parameters: a symbolizer hash, which defines the
    style properties, and a set of options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the symbolizer hash, we have used the attribute replacement feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `count` attribute is taken from the cluster point feature attributes, as
    we explained previously.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `strokeFunction` and `radiusFunction` are not attributes,
    but functions which are defined in the `context` property of the `OpenLayers.Style`
    options. All the symbolizer properties are evaluated against the `context` object.
    So, each of the functions receives a feature reference every time the layer is
    going to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `radiusFunction`, it computes the radius for the point depending
    on the `count` attribute, returning the maximum value between the range of 60
    percent of `count` or `7:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the use of context is powerful enough to allow us to set style
    properties dynamically and dependence on other feature attributes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Improving style using StyleMap and the replacement of feature's attributes*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Defining custom rules to style features* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the cluster strategy* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
