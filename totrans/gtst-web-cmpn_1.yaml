- en: Web Components Essentials and Specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the world of Web Components.
  prefs: []
  type: TYPE_NORMAL
- en: Web Components, as the name indicates, are components that can be reused across
    different sections of a website by keeping encapsulation in check. They can even
    be published on the web, and be used by another site with the help of a simple
    import. This book covers all there is to know about Web Components. What they
    are made up of, how they can be used and in what scenarios. The book also covers
    wide variety of moderate and advanced level concepts such as good practices and
    integrating Web Components with other technologies.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about what Web Components are and how we can identify
    them while browsing various sites. We will also be talking about the specifications
    that make up Web Components along with detailed examples. You will be able to
    understand what custom elements are and how you can create one on your own. You
    will be able to encapsulate your Web Components with the help of a shadow DOM,
    and you will be able to use templates to achieve reusability.
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter talks only about the basics of Web Components, by the end
    of this chapter you will be able to create your own Web Components from scratch,
    and understand the specifications associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Web Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Component specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to run the code, you will need a simple server, say a Python `SimpleHTTPServer`.
    In order to see the code on the browser, first start the server. On Mac, use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, use the following command in the folder that you have the code :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and then you can simply go to `localhost:8080`. It will run `index.html` for
    you in that folder.
  prefs: []
  type: TYPE_NORMAL
- en: Web Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you have a phone with a touchscreen. This touchscreen is a component
    of the mobile phone, working in conjunction with various other components, such
    as the circuit board and battery. Very few of us know how a phone screen works
    individually, yet we're all able to operate a mobile phone with ease. The same
    can be said of Web Components, which are the complex building blocks of websites
    which become navigable to all.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, the millions of phone screens around the world today are largely
    based on only a handful of designs. Fundamentally, the technology behind the mobile
    component is reusable and adaptable, and the same principle applies to Web Components.
  prefs: []
  type: TYPE_NORMAL
- en: The above points show how component methodology can be useful in creating a
    better product. Now, you must be thinking, why do we even need to look into the
    concept of components on the web? Well, I would like you to recall the last five
    sites that you visited. All these five sites probably shared a few features in
    common. Some of these are a header, a footer, some sort of menu, and an advertisement
    section. All these features, in terms of functionality, are doing the same thing.
    The only thing that differs is the look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider another use case where the site domain is the same but there
    are multiple web apps running on that domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have all used Google or at least two or three Google services. If we observe,
    there is a section at the top-right corner on any of the Google services/sites.
    It''s your account information, the one with your profile picture. And it shows
    the list of accounts you have logged in with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22c29b2f-f549-42a8-9a40-c753c348e640.png)'
  prefs: []
  type: TYPE_IMG
- en: You will be able to see a similar account information card when you go from
    one service to another. Imagine being able to convert this functionality into
    an HTML tag `<account-info>` and being able to reuse it again and again on different
    services. This can be achieved with the help of Web Components.
  prefs: []
  type: TYPE_NORMAL
- en: A Web Component is a collection of specifications that lets a user create a
    functionality with a certain look and feel and which can be reused in such a way
    that all this functionality is encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the preceding example, `<account-info>`, a Web Component lets you
    put your functionality into its own custom name, which can be represented by an
    HTML tag, and then encapsulate its functionality. This encapsulation makes it
    easy to distribute and it can be reused again and again very easily.
  prefs: []
  type: TYPE_NORMAL
- en: In all, a Web Component lets you create a custom HTML tag that can be reused,
    and whose functionality is encapsulated from the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what Web Components are and what Web Components can do, let's
    talk about Web Component specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Web Component specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like any technology, Web Components also have a set of specifications that
    need to be followed in order to achieve the functionality associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Web Component specification has the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom element**: The ability to create custom HTML tags and make sure that
    the browser understands how to use this HTML tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shadow DOM**: The ability to encapsulate the contents of the component from
    other parts of the DOM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template**: Being able to create a reusable DOM structure that can be modified
    on the fly and output desired results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three specifications, when used together, provide a way to create a custom
    HTML tag that can output desired results (DOM structure) and let it encapsulate
    from the page, making it reusable again and again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know these specifications and what they do, let's dive into them
    individually and try to look at their JavaScript APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Custom elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A custom element specification lets you create a custom HTML tag that can be
    used as its own HTML tag on the page. In order to achieve this, we need to first
    write a class with the functionalities associated with that HTML element, and
    then we need to register it so that the browser understands what this HTML tag
    is, and how it can be used on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are someone who is new to the concept of classes in JavaScript, here
    is how you can create a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty simple, right? Let''s use the same class structure to create our custom
    element class, say `HelloWorld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, our custom element class is called `HelloWorld` and it
    is extending interface from the `HTMLElement` class, which represents how an HTML
    element should work on a page. So, `HelloWorld` now knows what click events are,
    what CSS is, and so on, simply by extending `HTMLElement`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this class, we have the `constructor()` method, which gets called as
    soon as a new instance of this class is created. The `super()` function needs
    to be called in order to correctly instantiate the properties of the extended
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code simply creates the element class definition. We still need
    to register this element. We can do so by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What it does is register the class `HelloWorld` by defining it using the `define()`
    interface in the `customElements` interface; `hello-world` is the name of the
    custom element that is going to be available on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is defined, you can used the custom element by simply writing the
    HTML tag as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When this code is run on a browser, it will render the text, **Hello World**.
  prefs: []
  type: TYPE_NORMAL
- en: Final code: [https://codepen.io/prateekjadhwani/pen/jJZmyy](https://codepen.io/prateekjadhwani/pen/jJZmyy).
  prefs: []
  type: TYPE_NORMAL
- en: Types of custom elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have understood how we can register custom elements, it is time
    we looked deeper into the type of custom elements. Based on the type of requirement,
    we can create two types of custom elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autonomous custom element**: Any element that can be used by itself, without
    depending on another HTML element can be considered an autonomous custom element.
    In technical terms, Any custom  hat extends `HTMLElement` is an autonomous custom
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have another example of an autonomous custom element. Let''s create
    a `SmileyEmoji` element that shows a smiley emoji. Here is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This registers the `smiley-emoji` custom element, which can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Customized built-in element**: This type of custom element can extend the
    functionality of an already existing HTML tag. Let''s create a custom element
    that extends `HTMLSpanElement` instead of `HTMLElement.` And its functionality
    is, say, it needs to add a smiley emoji at the end of the custom element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you have the following HTML, this will add the smiley to the end of
    the text `Hello World`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Final code: [https://codepen.io/prateekjadhwani/pen/RdQarm](https://codepen.io/prateekjadhwani/pen/RdQarm).
  prefs: []
  type: TYPE_NORMAL
- en: Try running the code for autonomous custom elements and customized built-in
    elements on a browser, or CodePen, or JSFiddle. The class and registration code
    will be in the JavaScript block and the rest will be in the HTML block.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the difference in registration code for `<smiley-emoji>` and `<add-smiley>`
    custom elements. The second one uses an extra parameter that specifies what it
    is extending.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether a custom element is already defined or not with the help
    of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It will either return undefined if it has not been registered, or will return
    the class definition, if it has been registered. This is a very helpful statement
    in large projects because registering an already registered custom element will
    break the code.
  prefs: []
  type: TYPE_NORMAL
- en: Final code: [https://codepen.io/prateekjadhwani/pen/moXPBd](https://codepen.io/prateekjadhwani/pen/moXPBd).
  prefs: []
  type: TYPE_NORMAL
- en: Shadow DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the second specification for Web Components and this one is responsible
    for encapsulation. Both the CSS and DOM can be encapsulated so that they are hidden
    from the rest of the page. What a shadow DOM does is let you create a new root
    node, called shadow root, that is hidden from the normal DOM of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even before we jump into the concept of a shadow DOM, let''s try to
    look at what a normal DOM looks like. Any page with a DOM follows a tree structure.
    Here I have the DOM structure of a very simple page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e67c5097-533a-4500-be7a-443cf7de1386.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, you can see that `#document` is the root node for this
    page.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out the root node of a page by typing `document.querySelector('html').getRootNode()`
    in the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to get the child nodes of an HTML tag using `document.querySelector(''html'').childNodes`
    in the browser console, then you can see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c74c9446-3506-4ab8-9535-8e66f8592d24.png)'
  prefs: []
  type: TYPE_IMG
- en: Final code: [https://codepen.io/prateekjadhwani/pen/aMqBLa](https://codepen.io/prateekjadhwani/pen/aMqBLa).
  prefs: []
  type: TYPE_NORMAL
- en: This shows that the DOM follows a tree structure. You can go deeper into these
    nodes by clicking on the arrow right next to the name of the node. And just like
    how I have shown in the screenshot, anyone can go into a particular node by expanding
    it and change these values. In order to achieve this encapsulation, the concept
    of a shadow DOM was invented.
  prefs: []
  type: TYPE_NORMAL
- en: What a shadow DOM does is let you create a new root node, called shadow root,
    that is hidden from the normal DOM of the page. This shadow root can have any
    HTML inside and can work as any normal HTML DOM structure with events and CSS.
    But this shadow root can only be accessed by a shadow host attached to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that instead of having text inside the `<p>` tag in
    the preceding example, we have a shadow host that is attached to a shadow root.
    This is what the page source would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d50f552b-ec38-4de8-bfe0-9d5cb1a74e7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, if you tried to get the child nodes of this `<p>` tag, you would
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e6719dc-3ccd-4f5e-8f66-49020c8a2c7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that there is a `<span>` tag in the shadow root. Even though this `<span>`
    tag is present inside the `<p>` tag, the shadow root does not let JavaScript APIs
    touch it. This is how the shadow DOM encapsulates code inside itself.
  prefs: []
  type: TYPE_NORMAL
- en: Final code: [https://codepen.io/prateekjadhwani/pen/LaQxEY](https://codepen.io/prateekjadhwani/pen/LaQxEY).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a shadow DOM does, let's jump on to some code and learn
    how to create our own shadow DOMs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a DOM with a class name entry. This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create a shadow DOM in this `div`, we will first need to get the
    reference to this `.entry` `div`, then we need to mark it as a shadow root, and
    then append the content to this shadow root. So, here is the JavaScript code for
    creating a `shadowRoot` inside a `div` and adding contents to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Final code: [https://codepen.io/prateekjadhwani/pen/JzpWYE](https://codepen.io/prateekjadhwani/pen/JzpWYE).
  prefs: []
  type: TYPE_NORMAL
- en: 'Pretty simple, right? Remember, we are still discussing the shadow DOM spec.
    We haven''t started implementing it inside a custom element yet. Let''s recall
    the definition of our `hello-world` custom element. This is what it looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the text `Hello World` is currently being added to normal DOM. We
    can use the same shadow DOM concepts discussed earlier in this custom element.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to get the reference to the node where we want to attach the
    shadow root. In this case, let''s make the custom element itself the shadow host
    by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can either add a text node or create a new element and append it to
    this `shadowRoot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Final code: [https://codepen.io/prateekjadhwani/pen/LaQyPB](https://codepen.io/prateekjadhwani/pen/LaQyPB).
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Till now, we have only created custom elements and shadow DOMs that require
    only one or, at the most, two lines of HTML code. If we move on to a real-life
    example, HTML code can be more than two lines. It can start from a few lines of
    nested `div` to images and paragraphs—you get the picture. The template specification
    provides a way to hold HTML on the browser without actually rendering it on the
    page. Let us look at a small example of a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write a template inside `<template>` tags and assign it an identifier,
    just as I have done with the help of an `id`. You can put it anywhere on the page;
    it does not matter. We can get its content with the help of JavaScript APIs and
    then clone it and put it inside any DOM, just as I have shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can have any number of templates on the page, which can be used
    by any JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Final code: [https://codepen.io/prateekjadhwani/pen/ZPxOeq](https://codepen.io/prateekjadhwani/pen/ZPxOeq).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the same template with a shadow DOM. We will keep the template
    as it is. The changes in the JavaScript code would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We are doing the same thing that we did in the previous example, but, instead
    of appending the code directly to the target `div`, we are first attaching a shadow
    root to the target `div`, and then appending the cloned template content.
  prefs: []
  type: TYPE_NORMAL
- en: Final code: [https://codepen.io/prateekjadhwani/pen/moxroz](https://codepen.io/prateekjadhwani/pen/moxroz).
  prefs: []
  type: TYPE_NORMAL
- en: We should be able to use the exact same concept inside the autonomous custom
    element that uses a shadow DOM. Let's give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the `id` of the template and call it `hello-world-template`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will follow the exact same approach that we followed in the preceding example.
    We will get the template content from the template reference, clone it, and append
    it in the custom element, making the code of the custom element look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can simply call the HTML tag inside our page using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we inspect the DOM structure inside developer tools, this is what we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/151c185e-055a-4b7b-803a-3f4a4dc84289.png)'
  prefs: []
  type: TYPE_IMG
- en: Final code: [https://codepen.io/prateekjadhwani/pen/ywKgBp](https://codepen.io/prateekjadhwani/pen/ywKgBp).
  prefs: []
  type: TYPE_NORMAL
- en: Module loader API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module loader API is not a part of Web Component spec sheet, but it is definitely
    something that is useful to know when it comes to creating and using multiple
    classes. As the name says, this specification lets a user load the modules. That
    is, if you have a bunch of classes, you can use module loaders to load these classes
    into the web page.
  prefs: []
  type: TYPE_NORMAL
- en: If your build process involves using WebPack or Gulp or anything else that lets
    you import modules directly or indirectly, please feel free to skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the basics. Let''s say we have our `index.html` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is a `<p>` tag in this HTML file. Now, let''s say we
    have a class called `AddNumber`, whose purpose is to add a random number between
    0 and 1 to this `<p>` tag. This would make the code look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? If you open the page on a browser, you will simply see a random
    number, and if you inspect the page, you will see that the random number replaced
    the text which was inside the `<p>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we choose to store it in a JavaScript file, we can try to import it using
    the following code, where `addNumber.js` is the name of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say you have a `randomNumberGenerator` function instead of the `Math.random()`
    method. The code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We also want the ability to let the user create a new object of the `AddNumber`
    class, rather than us creating it in the file. We do not want the user to know
    how `randomNumberGenerator` works, so we want the user to be only able to create
    the object of `AddNumber`. This way, we reach how modules work. We, the creators
    of modules, decide which functionalities the user can use and which they cannot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can choose what the user can use with the help of the `export` keyword.
    This would make the code look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When this file is imported (note that we haven't talked about imports yet),
    the user will only be able to use the `AddNumber` class. The `randomNumberGenerator` function won't
    be available to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you have another file with, say, two other functions, `add()`
    and `subtract()`, you can export both of them as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Importing a module can be easily done with the help of the import keyword. In
    this section, we will talk about the `type="module"` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the HTML file, `index.html`, instead of `type=text/javascript`, we can
    use `type=module` to tell the browser that the file that we are importing is a
    module. This is what it will look like when we are trying to import the file `addNumber.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it will look if we import functions from the `calc.js` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we can change the name of the module exported from `AddNumber`, which
    uses `export default`, and how we have to use the same name as the name of the
    function exported using `export`.
  prefs: []
  type: TYPE_NORMAL
- en: Named export versus default export
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous examples, that is, `addNumber.js` and `calc.js`, we saw that
    there are two ways to export something: `export` and `export default`. The simplest
    way to understand it is as follows: when a file exports multiple things with different
    names and when these names cannot be changed after import, it is a named export,
    whereas, when we export only one thing from a module file and this name can be
    changed to anything after the import, it is a default export.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom elements using imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we need to create a Web Component that does a very simple task of
    showing a heading and a paragraph inside it, and the name of the custom element
    should be `<revamped-paragraph>`. This is what the definition of this Web Component
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `index.html` file, the file that imports this module, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the template is a part of our HTML, and how it gets used when the
    module is imported. We will be learning about all the steps that take place from
    the actual registration of the Web Components to what happens when they are removed
    from the page in the next chapter, where we will learn about life cycle methods.
    But for now, we need to look at more examples to understand how to create Web
    Components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another example. In this example, we need to import multiple
    Web Components in the `index.html` file. The components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A student attendance table component**: A table that shows the index number,
    student name, and attendance in a checkbox. This data is obtained from a `student.json`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An information banner component**: The purpose of this component is to show
    a phone number and an address for the school where these students are studying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A time slot component**: A component that lets the user select a time slot
    for the class between three sets of timings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us start with the first one, the `<student-attendance-table>` component.
    We need to first identify what it needs. In my opinion, these are the things it
    needs:'
  prefs: []
  type: TYPE_NORMAL
- en: A `fetch` call to the `student.json` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A template for each row of the string. I will be using template strings here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default text that says loading... when it is making the call and another text
    that says unable to retrieve student list. when the fetch call fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what our `student.json` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the definition of the Web Component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice the functions `getLoadingText()` and `getErrorText()`. Their purpose
    is simply to return a text. Then the `render()` method first consumes the `getLoadingText()`
    method, and then makes the call using `getStudentList()` to fetch the student
    list from `student.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Once this student list is fetched, it gets passed onto `generateTable()` method,
    where every `name` and its `index` is passed into the `getTableRow()` method to
    generate rows and then gets returned back to be a part of the table. Once the
    table is formed, it is then passed into the `appendHTMLToShadowDOM()` method to
    be added to the shadow DOM for the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to look into the `<information-banner>` component. Since this component
    simply needs to display a phone number and an address of the school where they
    are studying, we can use `<template>` and make it work. This is what it looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, `information-banner-template` looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is not much different than the custom elements we have already
    talked about in previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the last custom element, the `<time-slot>` component. Since
    it also involves a preset number of time slots, we can use a `<template>` tag
    to do our work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `<time-slot>` component would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It is the same as the previous component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have written the Web Components, it''s time to take a look at the
    `index.html` file that includes all of these components together. This is what
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, one `<script>` tag of `type="module"` can import all three of
    them together, and can register the custom elements, which can be used in the
    `<body>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about Web Components and how we are able to identify
    them in our daily web visits. We also talked about the specifications associated
    with Web Components, making it easier to understand even further. We looked into
    custom elements and how we can create our own custom elements. We talked about
    the shadow DOM and how it provides a level of encapsulation for our Web Components.
    We then talked about templates and how they provide an element of reusability
    inside a Web Component. We also looked into modules and how they let you create
    and add Web Components dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: We dived deep into creating a Web Component with detailed code examples. With
    this, we should be able to create a simple Web Component from scratch without
    any issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into how we can make our Web Components do
    more with life cycle methods.
  prefs: []
  type: TYPE_NORMAL
