- en: Web Components Essentials and Specifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Components 基础与规范
- en: Welcome to the world of Web Components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 Web Components 的世界。
- en: Web Components, as the name indicates, are components that can be reused across
    different sections of a website by keeping encapsulation in check. They can even
    be published on the web, and be used by another site with the help of a simple
    import. This book covers all there is to know about Web Components. What they
    are made up of, how they can be used and in what scenarios. The book also covers
    wide variety of moderate and advanced level concepts such as good practices and
    integrating Web Components with other technologies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，Web Components 是可以在网站的不同部分重复使用的组件，同时保持封装性。它们甚至可以发布到网络上，并通过简单的导入在其他网站上使用。本书涵盖了关于
    Web Components 所有的知识。包括它们由什么组成，如何使用以及适用场景。本书还涵盖了广泛的中高级概念，例如最佳实践以及将 Web Components
    与其他技术集成。
- en: In this chapter, we will talk about what Web Components are and how we can identify
    them while browsing various sites. We will also be talking about the specifications
    that make up Web Components along with detailed examples. You will be able to
    understand what custom elements are and how you can create one on your own. You
    will be able to encapsulate your Web Components with the help of a shadow DOM,
    and you will be able to use templates to achieve reusability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Web Components 是什么，以及如何在浏览各种网站时识别它们。我们还将讨论构成 Web Components 的规范，以及详细的示例。你将能够理解自定义元素是什么，以及如何自己创建一个。你将能够借助阴影
    DOM 封装你的 Web Components，并且可以使用模板来实现可重用性。
- en: While this chapter talks only about the basics of Web Components, by the end
    of this chapter you will be able to create your own Web Components from scratch,
    and understand the specifications associated with them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章只讨论了 Web Components 的基础知识，但到本章结束时，你将能够从头开始创建自己的 Web Components，并理解与之相关的规范。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Web Components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Components
- en: Web Component specifications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Component 规范
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to run the code, you will need a simple server, say a Python `SimpleHTTPServer`.
    In order to see the code on the browser, first start the server. On Mac, use the
    following command:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行代码，你需要一个简单的服务器，比如 Python 的 `SimpleHTTPServer`。为了在浏览器中查看代码，首先启动服务器。在 Mac
    上，使用以下命令：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On Windows, use the following command in the folder that you have the code :'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，请在包含代码的文件夹中使用以下命令：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and then you can simply go to `localhost:8080`. It will run `index.html` for
    you in that folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你只需简单地访问 `localhost:8080`。它会在那个文件夹中为你运行 `index.html`。
- en: Web Components
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Components
- en: Let's say you have a phone with a touchscreen. This touchscreen is a component
    of the mobile phone, working in conjunction with various other components, such
    as the circuit board and battery. Very few of us know how a phone screen works
    individually, yet we're all able to operate a mobile phone with ease. The same
    can be said of Web Components, which are the complex building blocks of websites
    which become navigable to all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一部带触摸屏的手机。这个触摸屏是手机的一个组件，与电路板和电池等各个组件协同工作。我们中很少有人知道手机屏幕是如何单独工作的，但我们都能轻松地操作手机。同样，Web
    Components 也是网站复杂的构建块，它们使得网站对所有用户都变得可导航。
- en: More importantly, the millions of phone screens around the world today are largely
    based on only a handful of designs. Fundamentally, the technology behind the mobile
    component is reusable and adaptable, and the same principle applies to Web Components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，今天世界上数以百万计的手机屏幕在很大程度上基于只有少数几种设计。从根本上说，移动组件背后的技术是可重用和可适应的，同样的原则也适用于 Web
    Components。
- en: The above points show how component methodology can be useful in creating a
    better product. Now, you must be thinking, why do we even need to look into the
    concept of components on the web? Well, I would like you to recall the last five
    sites that you visited. All these five sites probably shared a few features in
    common. Some of these are a header, a footer, some sort of menu, and an advertisement
    section. All these features, in terms of functionality, are doing the same thing.
    The only thing that differs is the look and feel.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述点展示了组件方法在创建更好的产品中的有用性。现在，你可能正在想，为什么我们需要研究网页上的组件概念呢？好吧，我想让你回忆一下你最近访问的最后五个网站。这五个网站可能有一些共同点。其中一些是页眉、页脚、某种菜单以及广告部分。从功能的角度来看，所有这些功能都在做同样的事情。唯一不同的是外观和感觉。
- en: Let us consider another use case where the site domain is the same but there
    are multiple web apps running on that domain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个用例，其中网站域名相同，但在该域名上运行着多个Web应用。
- en: 'We have all used Google or at least two or three Google services. If we observe,
    there is a section at the top-right corner on any of the Google services/sites.
    It''s your account information, the one with your profile picture. And it shows
    the list of accounts you have logged in with:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都使用过Google，或者至少使用过两个或三个Google服务。如果我们观察，在任何Google服务/网站上，右上角都有一个部分。这是你的账户信息，带有你的个人头像。它显示了你的登录账户列表：
- en: '![](img/22c29b2f-f549-42a8-9a40-c753c348e640.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22c29b2f-f549-42a8-9a40-c753c348e640.png)'
- en: You will be able to see a similar account information card when you go from
    one service to another. Imagine being able to convert this functionality into
    an HTML tag `<account-info>` and being able to reuse it again and again on different
    services. This can be achieved with the help of Web Components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个服务切换到另一个服务时，你将能够看到一个类似的账户信息卡片。想象一下，能够将这个功能转换成一个HTML标签`<account-info>`，并且能够在不同的服务上重复使用它。这可以通过Web组件的帮助来实现。
- en: A Web Component is a collection of specifications that lets a user create a
    functionality with a certain look and feel and which can be reused in such a way
    that all this functionality is encapsulated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件是一组规范，允许用户创建具有特定外观和感觉的功能，并且可以以这种方式重复使用，使得所有这些功能都被封装起来。
- en: Just like the preceding example, `<account-info>`, a Web Component lets you
    put your functionality into its own custom name, which can be represented by an
    HTML tag, and then encapsulate its functionality. This encapsulation makes it
    easy to distribute and it can be reused again and again very easily.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的例子`<account-info>`一样，一个Web组件允许你将你的功能放入一个自定义的名称中，这个名称可以通过一个HTML标签来表示，然后封装其功能。这种封装使得其易于分发，并且可以非常容易地重复使用。
- en: In all, a Web Component lets you create a custom HTML tag that can be reused,
    and whose functionality is encapsulated from the user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，一个Web组件允许你创建一个可重复使用的自定义HTML标签，其功能被封装，从用户那里隔离出来。
- en: Now that we know what Web Components are and what Web Components can do, let's
    talk about Web Component specifications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了什么是Web组件以及它们能做什么，让我们来谈谈Web组件规范。
- en: Web Component specifications
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web组件规范
- en: Just like any technology, Web Components also have a set of specifications that
    need to be followed in order to achieve the functionality associated with them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何技术一样，Web组件也有需要遵循的一套规范，以实现与之相关的功能。
- en: 'A Web Component specification has the following parts:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件规范包含以下部分：
- en: '**Custom element**: The ability to create custom HTML tags and make sure that
    the browser understands how to use this HTML tag'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义元素**：能够创建自定义的HTML标签，并确保浏览器理解如何使用这个HTML标签'
- en: '**Shadow DOM**: The ability to encapsulate the contents of the component from
    other parts of the DOM'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影DOM**：能够封装组件内容，使其从DOM的其他部分隔离出来'
- en: '**Template**: Being able to create a reusable DOM structure that can be modified
    on the fly and output desired results'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：能够创建一个可重复使用的DOM结构，可以即时修改并输出所需的结果'
- en: These three specifications, when used together, provide a way to create a custom
    HTML tag that can output desired results (DOM structure) and let it encapsulate
    from the page, making it reusable again and again.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个规范，当一起使用时，提供了一种创建自定义HTML标签的方法，该标签可以输出所需的结果（DOM结构），并且可以将其封装，使其可以重复使用。
- en: Now that we know these specifications and what they do, let's dive into them
    individually and try to look at their JavaScript APIs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了这些规范以及它们的作用，让我们逐一深入探讨它们，并尝试查看它们的JavaScript API。
- en: Custom elements
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义元素
- en: A custom element specification lets you create a custom HTML tag that can be
    used as its own HTML tag on the page. In order to achieve this, we need to first
    write a class with the functionalities associated with that HTML element, and
    then we need to register it so that the browser understands what this HTML tag
    is, and how it can be used on the page.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素规范允许你创建一个自定义HTML标签，该标签可以作为其自身的HTML标签在页面上使用。为了实现这一点，我们首先需要编写一个与该HTML元素相关的功能类，然后我们需要注册它，以便浏览器理解这个HTML标签是什么，以及如何在页面上使用它。
- en: 'If you are someone who is new to the concept of classes in JavaScript, here
    is how you can create a class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个对JavaScript中的类概念新手，以下是如何创建一个类的方法：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Pretty simple, right? Let''s use the same class structure to create our custom
    element class, say `HelloWorld`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？让我们使用相同的类结构来创建我们的自定义元素类，比如说`HelloWorld`：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, our custom element class is called `HelloWorld` and it
    is extending interface from the `HTMLElement` class, which represents how an HTML
    element should work on a page. So, `HelloWorld` now knows what click events are,
    what CSS is, and so on, simply by extending `HTMLElement`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的自定义元素类被命名为`HelloWorld`，它从`HTMLElement`类扩展，这代表了HTML元素在页面上的工作方式。因此，`HelloWorld`现在知道点击事件是什么，CSS是什么，等等，仅仅通过扩展`HTMLElement`。
- en: Inside this class, we have the `constructor()` method, which gets called as
    soon as a new instance of this class is created. The `super()` function needs
    to be called in order to correctly instantiate the properties of the extended
    class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们有一个`constructor()`方法，它会在创建这个类的新实例时立即被调用。为了正确实例化扩展类的属性，需要调用`super()`函数。
- en: 'The preceding code simply creates the element class definition. We still need
    to register this element. We can do so by writing the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是创建了一个元素类定义。我们仍然需要注册这个元素。我们可以通过编写以下代码来完成：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What it does is register the class `HelloWorld` by defining it using the `define()`
    interface in the `customElements` interface; `hello-world` is the name of the
    custom element that is going to be available on the page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的就是通过在`customElements`接口中使用`define()`接口定义类`HelloWorld`来注册这个类；`hello-world`是将在页面上可用的自定义元素的名称。
- en: 'Once this is defined, you can used the custom element by simply writing the
    HTML tag as following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了它，你就可以通过简单地写下以下HTML标签来使用自定义元素：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When this code is run on a browser, it will render the text, **Hello World**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码在浏览器上运行时，它将渲染文本，**Hello World**。
- en: Final code: [https://codepen.io/prateekjadhwani/pen/jJZmyy](https://codepen.io/prateekjadhwani/pen/jJZmyy).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/jJZmyy](https://codepen.io/prateekjadhwani/pen/jJZmyy)。
- en: Types of custom elements
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义元素的类型
- en: 'Now that you have understood how we can register custom elements, it is time
    we looked deeper into the type of custom elements. Based on the type of requirement,
    we can create two types of custom elements:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何注册自定义元素，是时候更深入地了解自定义元素的类型了。根据需求类型，我们可以创建两种类型的自定义元素：
- en: '**Autonomous custom element**: Any element that can be used by itself, without
    depending on another HTML element can be considered an autonomous custom element.
    In technical terms, Any custom  hat extends `HTMLElement` is an autonomous custom
    element.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主自定义元素**：任何可以独立使用，而不依赖于其他HTML元素的元素都可以被认为是自主自定义元素。从技术角度讲，任何扩展`HTMLElement`的自定义元素都是自主自定义元素。'
- en: 'Let''s have another example of an autonomous custom element. Let''s create
    a `SmileyEmoji` element that shows a smiley emoji. Here is what it looks like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个自主自定义元素的例子。让我们创建一个`SmileyEmoji`元素，它显示一个笑脸表情符号。它看起来是这样的：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This registers the `smiley-emoji` custom element, which can be used as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将注册`smiley-emoji`自定义元素，可以使用如下方式：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Customized built-in element**: This type of custom element can extend the
    functionality of an already existing HTML tag. Let''s create a custom element
    that extends `HTMLSpanElement` instead of `HTMLElement.` And its functionality
    is, say, it needs to add a smiley emoji at the end of the custom element:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义内置元素**：这种类型的自定义元素可以扩展现有HTML标签的功能。让我们创建一个扩展`HTMLSpanElement`而不是`HTMLElement`的自定义元素。它的功能是，比如说，需要在自定义元素的末尾添加一个笑脸表情符号：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if you have the following HTML, this will add the smiley to the end of
    the text `Hello World`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你有以下的HTML，这将把笑脸添加到文本`Hello World`的末尾：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Final code: [https://codepen.io/prateekjadhwani/pen/RdQarm](https://codepen.io/prateekjadhwani/pen/RdQarm).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/RdQarm](https://codepen.io/prateekjadhwani/pen/RdQarm)。
- en: Try running the code for autonomous custom elements and customized built-in
    elements on a browser, or CodePen, or JSFiddle. The class and registration code
    will be in the JavaScript block and the rest will be in the HTML block.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在浏览器、CodePen 或 JSFiddle 上运行自主自定义元素和自定义内置元素的代码。类和注册代码将在 JavaScript 块中，其余的将在
    HTML 块中。
- en: Notice the difference in registration code for `<smiley-emoji>` and `<add-smiley>`
    custom elements. The second one uses an extra parameter that specifies what it
    is extending.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `<smiley-emoji>` 和 `<add-smiley>` 自定义元素注册代码的差异。第二个使用一个额外的参数来指定它扩展的内容。
- en: 'You can check whether a custom element is already defined or not with the help
    of the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码检查自定义元素是否已经定义：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It will either return undefined if it has not been registered, or will return
    the class definition, if it has been registered. This is a very helpful statement
    in large projects because registering an already registered custom element will
    break the code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它尚未注册，则它将返回 undefined，如果已注册，则返回类定义。这对于大型项目来说是一个非常有用的语句，因为注册已注册的自定义元素将破坏代码。
- en: Final code: [https://codepen.io/prateekjadhwani/pen/moXPBd](https://codepen.io/prateekjadhwani/pen/moXPBd).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/moXPBd](https://codepen.io/prateekjadhwani/pen/moXPBd)。
- en: Shadow DOM
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阴影 DOM
- en: This is the second specification for Web Components and this one is responsible
    for encapsulation. Both the CSS and DOM can be encapsulated so that they are hidden
    from the rest of the page. What a shadow DOM does is let you create a new root
    node, called shadow root, that is hidden from the normal DOM of the page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Web Components 的第二个规范，它负责封装。CSS 和 DOM 都可以被封装，从而隐藏在页面的其余部分。阴影 DOM 所做的是让您创建一个新的根节点，称为阴影根，它从页面的正常
    DOM 中隐藏。
- en: 'However, even before we jump into the concept of a shadow DOM, let''s try to
    look at what a normal DOM looks like. Any page with a DOM follows a tree structure.
    Here I have the DOM structure of a very simple page:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入阴影 DOM 的概念之前，让我们先看看一个正常的 DOM 是什么样子。任何带有 DOM 的页面都遵循树状结构。这里我有一个非常简单的页面的
    DOM 结构：
- en: '![](img/e67c5097-533a-4500-be7a-443cf7de1386.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e67c5097-533a-4500-be7a-443cf7de1386.png)'
- en: In the preceding image, you can see that `#document` is the root node for this
    page.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图片中，您可以看到`#document`是此页面的根节点。
- en: You can find out the root node of a page by typing `document.querySelector('html').getRootNode()`
    in the browser console.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在浏览器控制台中输入`document.querySelector('html').getRootNode()`来找到页面的根节点。
- en: 'If you try to get the child nodes of an HTML tag using `document.querySelector(''html'').childNodes`
    in the browser console, then you can see the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在浏览器控制台中使用`document.querySelector('html').childNodes`获取 HTML 标签的子节点，那么您可以看到以下截图：
- en: '![](img/c74c9446-3506-4ab8-9535-8e66f8592d24.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c74c9446-3506-4ab8-9535-8e66f8592d24.png)'
- en: Final code: [https://codepen.io/prateekjadhwani/pen/aMqBLa](https://codepen.io/prateekjadhwani/pen/aMqBLa).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/aMqBLa](https://codepen.io/prateekjadhwani/pen/aMqBLa)。
- en: This shows that the DOM follows a tree structure. You can go deeper into these
    nodes by clicking on the arrow right next to the name of the node. And just like
    how I have shown in the screenshot, anyone can go into a particular node by expanding
    it and change these values. In order to achieve this encapsulation, the concept
    of a shadow DOM was invented.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 DOM 遵循树状结构。您可以通过点击节点名称旁边的箭头进一步深入这些节点。就像我在截图中所展示的那样，任何人都可以通过展开节点进入特定的节点并更改这些值。为了实现这种封装，发明了阴影
    DOM 的概念。
- en: What a shadow DOM does is let you create a new root node, called shadow root,
    that is hidden from the normal DOM of the page. This shadow root can have any
    HTML inside and can work as any normal HTML DOM structure with events and CSS.
    But this shadow root can only be accessed by a shadow host attached to the DOM.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影 DOM 所做的是让您创建一个新的根节点，称为阴影根，它从页面的正常 DOM 中隐藏。这个阴影根可以包含任何 HTML 内容，并且可以像任何正常的
    HTML DOM 结构一样工作，具有事件和 CSS。但是，这个阴影根只能由连接到 DOM 的阴影宿主访问。
- en: 'For example, let''s say that instead of having text inside the `<p>` tag in
    the preceding example, we have a shadow host that is attached to a shadow root.
    This is what the page source would look like:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在前面示例中的 `<p>` 标签内不是文本，而是一个连接到阴影根的阴影宿主。页面源代码将如下所示：
- en: '![](img/d50f552b-ec38-4de8-bfe0-9d5cb1a74e7e.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d50f552b-ec38-4de8-bfe0-9d5cb1a74e7e.png)'
- en: 'Furthermore, if you tried to get the child nodes of this `<p>` tag, you would
    see something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你尝试获取这个 `<p>` 标签的子节点，你会看到如下内容：
- en: '![](img/9e6719dc-3ccd-4f5e-8f66-49020c8a2c7a.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e6719dc-3ccd-4f5e-8f66-49020c8a2c7a.png)'
- en: Notice that there is a `<span>` tag in the shadow root. Even though this `<span>`
    tag is present inside the `<p>` tag, the shadow root does not let JavaScript APIs
    touch it. This is how the shadow DOM encapsulates code inside itself.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在阴影根中有一个 `<span>` 标签。即使这个 `<span>` 标签位于 `<p>` 标签内部，阴影根也不允许 JavaScript API
    修改它。这就是阴影 DOM 如何封装其内部的代码。
- en: Final code: [https://codepen.io/prateekjadhwani/pen/LaQxEY](https://codepen.io/prateekjadhwani/pen/LaQxEY).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/LaQxEY](https://codepen.io/prateekjadhwani/pen/LaQxEY)。
- en: Now that we know what a shadow DOM does, let's jump on to some code and learn
    how to create our own shadow DOMs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了阴影 DOM 是做什么的，让我们来看看代码，学习如何创建我们自己的阴影 DOM。
- en: 'Let''s say we have a DOM with a class name entry. This is what it looks like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个具有类名 entry 的 DOM。它看起来是这样的：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to create a shadow DOM in this `div`, we will first need to get the
    reference to this `.entry` `div`, then we need to mark it as a shadow root, and
    then append the content to this shadow root. So, here is the JavaScript code for
    creating a `shadowRoot` inside a `div` and adding contents to it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这个 `div` 中创建一个阴影 DOM，我们首先需要获取这个 `.entry` `div` 的引用，然后我们需要将其标记为阴影根，然后将内容附加到这个阴影根上。所以，下面是创建
    `shadowRoot` 并向其中添加内容的 JavaScript 代码：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Final code: [https://codepen.io/prateekjadhwani/pen/JzpWYE](https://codepen.io/prateekjadhwani/pen/JzpWYE).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/JzpWYE](https://codepen.io/prateekjadhwani/pen/JzpWYE)。
- en: 'Pretty simple, right? Remember, we are still discussing the shadow DOM spec.
    We haven''t started implementing it inside a custom element yet. Let''s recall
    the definition of our `hello-world` custom element. This is what it looked like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？记住，我们仍在讨论阴影 DOM 规范。我们还没有开始在自定义元素中实现它。让我们回顾一下 `hello-world` 自定义元素的定义。它看起来是这样的：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the text `Hello World` is currently being added to normal DOM. We
    can use the same shadow DOM concepts discussed earlier in this custom element.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到文本 `Hello World` 目前正被添加到正常 DOM 中。我们可以使用之前在本自定义元素中讨论过的相同的阴影 DOM 概念。
- en: 'First, we need to get the reference to the node where we want to attach the
    shadow root. In this case, let''s make the custom element itself the shadow host
    by using the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取我们想要附加阴影根的节点的引用。在这种情况下，让我们通过以下代码将自定义元素本身作为阴影宿主：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can either add a text node or create a new element and append it to
    this `shadowRoot`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们既可以添加一个文本节点，也可以创建一个新的元素并将其附加到这个 `shadowRoot` 上：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Final code: [https://codepen.io/prateekjadhwani/pen/LaQyPB](https://codepen.io/prateekjadhwani/pen/LaQyPB).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/LaQyPB](https://codepen.io/prateekjadhwani/pen/LaQyPB)。
- en: Templates
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Till now, we have only created custom elements and shadow DOMs that require
    only one or, at the most, two lines of HTML code. If we move on to a real-life
    example, HTML code can be more than two lines. It can start from a few lines of
    nested `div` to images and paragraphs—you get the picture. The template specification
    provides a way to hold HTML on the browser without actually rendering it on the
    page. Let us look at a small example of a template:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只创建了需要一行或最多两行 HTML 代码的自定义元素和阴影 DOM。如果我们转向现实生活中的例子，HTML 代码可以超过两行。它可以是从几个嵌套的
    `div` 到图片和段落——你明白我的意思。模板规范提供了一种在浏览器中保留 HTML 而不实际在页面上渲染它的方法。让我们看看一个小型的模板示例：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can write a template inside `<template>` tags and assign it an identifier,
    just as I have done with the help of an `id`. You can put it anywhere on the page;
    it does not matter. We can get its content with the help of JavaScript APIs and
    then clone it and put it inside any DOM, just as I have shown in the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `<template>` 标签内编写一个模板，并给它一个标识符，就像我通过 `id` 做的那样。你可以把它放在页面的任何地方；这无关紧要。我们可以通过
    JavaScript API 获取其内容，然后克隆它并将其放入任何 DOM 中，就像我在下面的示例中展示的那样：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similarly, we can have any number of templates on the page, which can be used
    by any JavaScript code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，页面上可以有任意数量的模板，这些模板可以被任何 JavaScript 代码使用。
- en: 'Final code: [https://codepen.io/prateekjadhwani/pen/ZPxOeq](https://codepen.io/prateekjadhwani/pen/ZPxOeq).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/ZPxOeq](https://codepen.io/prateekjadhwani/pen/ZPxOeq)。
- en: 'Let''s now use the same template with a shadow DOM. We will keep the template
    as it is. The changes in the JavaScript code would be something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用带有阴影DOM的相同模板。我们将保持模板不变。JavaScript代码的更改将类似于以下内容：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are doing the same thing that we did in the previous example, but, instead
    of appending the code directly to the target `div`, we are first attaching a shadow
    root to the target `div`, and then appending the cloned template content.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做与上一个示例中相同的事情，但不是直接将代码附加到目标`div`，而是首先将一个阴影根附加到目标`div`，然后附加克隆的模板内容。
- en: Final code: [https://codepen.io/prateekjadhwani/pen/moxroz](https://codepen.io/prateekjadhwani/pen/moxroz).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/moxroz](https://codepen.io/prateekjadhwani/pen/moxroz)。
- en: We should be able to use the exact same concept inside the autonomous custom
    element that uses a shadow DOM. Let's give it a try.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够在使用阴影DOM的自定义元素中使用完全相同的概念。让我们试一试。
- en: 'Let''s edit the `id` of the template and call it `hello-world-template`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑模板的`id`并将其命名为`hello-world-template`：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will follow the exact same approach that we followed in the preceding example.
    We will get the template content from the template reference, clone it, and append
    it in the custom element, making the code of the custom element look like the
    following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循与上一个示例中相同的方法。我们将从模板引用中获取模板内容，克隆它，并将其附加到自定义元素中，使自定义元素的代码看起来如下所示：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can simply call the HTML tag inside our page using the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以简单地使用以下代码在我们的页面中调用HTML标签：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we inspect the DOM structure inside developer tools, this is what we see:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在开发者工具中检查DOM结构，我们会看到以下内容：
- en: '![](img/151c185e-055a-4b7b-803a-3f4a4dc84289.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/151c185e-055a-4b7b-803a-3f4a4dc84289.png)'
- en: Final code: [https://codepen.io/prateekjadhwani/pen/ywKgBp](https://codepen.io/prateekjadhwani/pen/ywKgBp).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码：[https://codepen.io/prateekjadhwani/pen/ywKgBp](https://codepen.io/prateekjadhwani/pen/ywKgBp)。
- en: Module loader API
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块加载器API
- en: Module loader API is not a part of Web Component spec sheet, but it is definitely
    something that is useful to know when it comes to creating and using multiple
    classes. As the name says, this specification lets a user load the modules. That
    is, if you have a bunch of classes, you can use module loaders to load these classes
    into the web page.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载器API不是Web组件规范的一部分，但它确实是创建和使用多个类时非常有用的知识。正如其名所示，这个规范允许用户加载模块。也就是说，如果您有一系列类，您可以使用模块加载器将这些类加载到网页中。
- en: If your build process involves using WebPack or Gulp or anything else that lets
    you import modules directly or indirectly, please feel free to skip this section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的构建过程涉及使用WebPack或Gulp或任何其他允许您直接或间接导入模块的工具，请随意跳过本节。
- en: 'Let''s start with the basics. Let''s say we have our `index.html` like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。假设我们的`index.html`如下所示：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see that there is a `<p>` tag in this HTML file. Now, let''s say we
    have a class called `AddNumber`, whose purpose is to add a random number between
    0 and 1 to this `<p>` tag. This would make the code look something like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在这个HTML文件中有一个`<p>`标签。现在，假设我们有一个名为`AddNumber`的类，其目的是向这个`<p>`标签添加一个介于0和1之间的随机数。这将使代码看起来如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Simple, right? If you open the page on a browser, you will simply see a random
    number, and if you inspect the page, you will see that the random number replaced
    the text which was inside the `<p>` tag.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吗？如果您在浏览器中打开页面，您将简单地看到一个随机数，如果您检查页面，您将看到随机数替换了`<p>`标签内的文本。
- en: 'If we choose to store it in a JavaScript file, we can try to import it using
    the following code, where `addNumber.js` is the name of the file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择将其存储在JavaScript文件中，我们可以尝试使用以下代码导入它，其中`addNumber.js`是文件的名称：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s say you have a `randomNumberGenerator` function instead of the `Math.random()`
    method. The code would look something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您有一个`randomNumberGenerator`函数而不是`Math.random()`方法。代码将如下所示：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We also want the ability to let the user create a new object of the `AddNumber`
    class, rather than us creating it in the file. We do not want the user to know
    how `randomNumberGenerator` works, so we want the user to be only able to create
    the object of `AddNumber`. This way, we reach how modules work. We, the creators
    of modules, decide which functionalities the user can use and which they cannot.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望用户能够创建一个新的`AddNumber`类对象，而不是我们在文件中创建它。我们不希望用户知道`randomNumberGenerator`是如何工作的，因此我们希望用户只能创建`AddNumber`的对象。这样，我们就了解了模块的工作方式。作为模块的创建者，我们决定用户可以使用哪些功能以及他们不能使用哪些功能。
- en: 'We can choose what the user can use with the help of the `export` keyword.
    This would make the code look something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`export`关键字来帮助用户选择他们可以使用的内容。这样代码看起来会像这样：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When this file is imported (note that we haven't talked about imports yet),
    the user will only be able to use the `AddNumber` class. The `randomNumberGenerator` function won't
    be available to the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个文件被导入时（注意我们还没有讨论导入），用户只能使用`AddNumber`类。`randomNumberGenerator`函数对用户不可用。
- en: 'Similarly, if you have another file with, say, two other functions, `add()`
    and `subtract()`, you can export both of them as shown in the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你有另一个包含两个其他函数的文件，比如`add()`和`subtract()`，你可以像下面这样导出它们：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Importing a module can be easily done with the help of the import keyword. In
    this section, we will talk about the `type="module"` attribute.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用导入关键字可以轻松地导入模块。在本节中，我们将讨论`type="module"`属性。
- en: 'Inside the HTML file, `index.html`, instead of `type=text/javascript`, we can
    use `type=module` to tell the browser that the file that we are importing is a
    module. This is what it will look like when we are trying to import the file `addNumber.js`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文件`index.html`内部，我们可以使用`type=module`而不是`type=text/javascript`来告诉浏览器我们正在导入的文件是一个模块。当我们尝试导入`addNumber.js`文件时，它将看起来像这样：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is how it will look if we import functions from the `calc.js` module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从`calc.js`模块导入函数，它看起来会是这样：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how we can change the name of the module exported from `AddNumber`, which
    uses `export default`, and how we have to use the same name as the name of the
    function exported using `export`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何可以更改使用`export default`导出的`AddNumber`模块的名称，以及我们如何必须使用与使用`export`导出的函数相同的名称。
- en: Named export versus default export
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名导出与默认导出
- en: 'In the previous examples, that is, `addNumber.js` and `calc.js`, we saw that
    there are two ways to export something: `export` and `export default`. The simplest
    way to understand it is as follows: when a file exports multiple things with different
    names and when these names cannot be changed after import, it is a named export,
    whereas, when we export only one thing from a module file and this name can be
    changed to anything after the import, it is a default export.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，即`addNumber.js`和`calc.js`，我们看到了有两种方式可以导出内容：`export`和`export default`。理解它的最简单方式如下：当一个文件使用不同的名称导出多个内容，并且这些名称在导入后不能更改时，它是一个命名导出，而当我们只从一个模块文件中导出一个内容，并且这个名称在导入后可以被更改成任何名称时，它是一个默认导出。
- en: Custom elements using imports
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导入的自定义元素
- en: 'Let''s say we need to create a Web Component that does a very simple task of
    showing a heading and a paragraph inside it, and the name of the custom element
    should be `<revamped-paragraph>`. This is what the definition of this Web Component
    would look like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要创建一个Web组件，它执行一个非常简单的任务，即在内部显示一个标题和一段段落，并且自定义元素的名称应该是`<revamped-paragraph>`。这个Web组件的定义看起来会是这样：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our `index.html` file, the file that imports this module, would look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`index.html`文件，导入此模块的文件，将看起来像这样：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how the template is a part of our HTML, and how it gets used when the
    module is imported. We will be learning about all the steps that take place from
    the actual registration of the Web Components to what happens when they are removed
    from the page in the next chapter, where we will learn about life cycle methods.
    But for now, we need to look at more examples to understand how to create Web
    Components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意模板是如何成为我们HTML的一部分，以及它在模块导入时是如何被使用的。我们将在下一章学习从Web组件的实际注册到它们从页面上移除时发生的一切步骤，其中我们将学习生命周期方法。但就目前而言，我们需要查看更多示例来了解如何创建Web组件。
- en: 'Let''s take a look at another example. In this example, we need to import multiple
    Web Components in the `index.html` file. The components are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。在这个例子中，我们需要在`index.html`文件中导入多个Web组件。组件如下：
- en: '**A student attendance table component**: A table that shows the index number,
    student name, and attendance in a checkbox. This data is obtained from a `student.json`
    file.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学生出勤表组件**：一个显示索引号、学生姓名和复选框中出勤情况的表格。这些数据是从`student.json`文件中获取的。'
- en: '**An information banner component**: The purpose of this component is to show
    a phone number and an address for the school where these students are studying.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息横幅组件**：此组件的目的是显示这些学生所在学校的电话号码和地址。'
- en: '**A time slot component**: A component that lets the user select a time slot
    for the class between three sets of timings.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间槽组件**：一个允许用户在三个时间组之间选择课程时间槽的组件。'
- en: 'Let us start with the first one, the `<student-attendance-table>` component.
    We need to first identify what it needs. In my opinion, these are the things it
    needs:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个开始，即`<student-attendance-table>`组件。我们首先需要确定它需要什么。在我看来，这些是它需要的：
- en: A `fetch` call to the `student.json` file
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`student.json`文件的`fetch`调用。
- en: A template for each row of the string. I will be using template strings here
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串每一行的模板。我将在这里使用模板字符串。
- en: A default text that says loading... when it is making the call and another text
    that says unable to retrieve student list. when the fetch call fails
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它正在打电话时，显示默认文本“正在加载...”，当获取学生列表失败时，显示文本“无法检索学生列表”。
- en: 'This is what our `student.json` file looks like:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`student.json`文件看起来像这样：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is what the definition of the Web Component looks like:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Web组件的定义看起来像这样：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice the functions `getLoadingText()` and `getErrorText()`. Their purpose
    is simply to return a text. Then the `render()` method first consumes the `getLoadingText()`
    method, and then makes the call using `getStudentList()` to fetch the student
    list from `student.json` file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数`getLoadingText()`和`getErrorText()`。它们的目的仅仅是返回一个文本。然后`render()`方法首先调用`getLoadingText()`方法，然后使用`getStudentList()`调用进行调用以从`student.json`文件中获取学生列表。
- en: Once this student list is fetched, it gets passed onto `generateTable()` method,
    where every `name` and its `index` is passed into the `getTableRow()` method to
    generate rows and then gets returned back to be a part of the table. Once the
    table is formed, it is then passed into the `appendHTMLToShadowDOM()` method to
    be added to the shadow DOM for the component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到学生列表，它就会被传递到`generateTable()`方法，其中每个`name`和其`index`都会传递到`getTableRow()`方法以生成行，然后返回以成为表格的一部分。一旦表格形成，它就会被传递到`appendHTMLToShadowDOM()`方法，以便添加到组件的shadow
    DOM中。
- en: 'It''s time to look into the `<information-banner>` component. Since this component
    simply needs to display a phone number and an address of the school where they
    are studying, we can use `<template>` and make it work. This is what it looks
    like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候查看`<information-banner>`组件了。由于这个组件只需要显示他们学习的学校的电话号码和地址，我们可以使用`<template>`并使其工作。这是它的样子：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Furthermore, `information-banner-template` looks something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`information-banner-template`看起来像这样：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, it is not much different than the custom elements we have already
    talked about in previous sections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它与我们在前几节中讨论的自定义元素没有太大区别。
- en: Let's move on to the last custom element, the `<time-slot>` component. Since
    it also involves a preset number of time slots, we can use a `<template>` tag
    to do our work.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到最后一个自定义元素，即`<time-slot>`组件。由于它也涉及预设的时间段数量，我们可以使用`<template>`标签来完成我们的工作。
- en: 'The template would look something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模板看起来可能像这样：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The definition of the `<time-slot>` component would look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`<time-slot>`组件的定义看起来像这样：'
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is the same as the previous component.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它与上一个组件相同。
- en: 'Now that we have written the Web Components, it''s time to take a look at the
    `index.html` file that includes all of these components together. This is what
    it looks like:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了Web组件，是时候看看包含所有这些组件的`index.html`文件了。这是它的样子：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, one `<script>` tag of `type="module"` can import all three of
    them together, and can register the custom elements, which can be used in the
    `<body>` tag.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个`type="module"`的`<script>`标签可以一起导入这三个组件，并注册自定义元素，这些元素可以在`<body>`标签中使用。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about Web Components and how we are able to identify
    them in our daily web visits. We also talked about the specifications associated
    with Web Components, making it easier to understand even further. We looked into
    custom elements and how we can create our own custom elements. We talked about
    the shadow DOM and how it provides a level of encapsulation for our Web Components.
    We then talked about templates and how they provide an element of reusability
    inside a Web Component. We also looked into modules and how they let you create
    and add Web Components dynamically.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Web 组件以及我们如何在日常的网页访问中识别它们。我们还讨论了与 Web 组件相关的规范，这使得进一步理解变得更加容易。我们探讨了自定义元素以及如何创建我们自己的自定义元素。我们还讨论了阴影
    DOM 以及它为我们的 Web 组件提供的一定程度的封装。然后我们讨论了模板以及它们如何在 Web 组件内部提供可重用性。此外，我们还探讨了模块以及它们如何让您动态创建和添加
    Web 组件。
- en: We dived deep into creating a Web Component with detailed code examples. With
    this, we should be able to create a simple Web Component from scratch without
    any issues.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了使用详细代码示例创建 Web 组件。通过这种方式，我们应该能够从头开始创建一个简单的 Web 组件而不会遇到任何问题。
- en: In the next chapter, we will look into how we can make our Web Components do
    more with life cycle methods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何利用生命周期方法让我们的 Web 组件做得更多。
