- en: Web Components Essentials and Specifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Components 基础与规范
- en: Welcome to the world of Web Components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 Web Components 的世界。
- en: Web Components, as the name indicates, are components that can be reused across
    different sections of a website by keeping encapsulation in check. They can even
    be published on the web, and be used by another site with the help of a simple
    import. This book covers all there is to know about Web Components. What they
    are made up of, how they can be used and in what scenarios. The book also covers
    wide variety of moderate and advanced level concepts such as good practices and
    integrating Web Components with other technologies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，Web Components 是可以在网站的不同部分重复使用的组件，同时保持封装性。它们甚至可以发布到网络上，并通过简单的导入在其他网站上使用。本书涵盖了关于
    Web Components 所有的知识。包括它们由什么组成，如何使用以及适用场景。本书还涵盖了广泛的中高级概念，例如最佳实践以及将 Web Components
    与其他技术集成。
- en: In this chapter, we will talk about what Web Components are and how we can identify
    them while browsing various sites. We will also be talking about the specifications
    that make up Web Components along with detailed examples. You will be able to
    understand what custom elements are and how you can create one on your own. You
    will be able to encapsulate your Web Components with the help of a shadow DOM,
    and you will be able to use templates to achieve reusability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Web Components 是什么，以及如何在浏览各种网站时识别它们。我们还将讨论构成 Web Components 的规范，以及详细的示例。你将能够理解自定义元素是什么，以及如何自己创建一个。你将能够借助阴影
    DOM 封装你的 Web Components，并且可以使用模板来实现可重用性。
- en: While this chapter talks only about the basics of Web Components, by the end
    of this chapter you will be able to create your own Web Components from scratch,
    and understand the specifications associated with them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章只讨论了 Web Components 的基础知识，但到本章结束时，你将能够从头开始创建自己的 Web Components，并理解与之相关的规范。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Web Components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Components
- en: Web Component specifications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Component 规范
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to run the code, you will need a simple server, say a Python `SimpleHTTPServer`.
    In order to see the code on the browser, first start the server. On Mac, use the
    following command:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行代码，你需要一个简单的服务器，比如 Python 的 `SimpleHTTPServer`。为了在浏览器中查看代码，首先启动服务器。在 Mac
    上，使用以下命令：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On Windows, use the following command in the folder that you have the code :'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，请在包含代码的文件夹中使用以下命令：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and then you can simply go to `localhost:8080`. It will run `index.html` for
    you in that folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你只需简单地访问 `localhost:8080`。它会在那个文件夹中为你运行 `index.html`。
- en: Web Components
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Components
- en: Let's say you have a phone with a touchscreen. This touchscreen is a component
    of the mobile phone, working in conjunction with various other components, such
    as the circuit board and battery. Very few of us know how a phone screen works
    individually, yet we're all able to operate a mobile phone with ease. The same
    can be said of Web Components, which are the complex building blocks of websites
    which become navigable to all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一部带触摸屏的手机。这个触摸屏是手机的一个组件，与电路板和电池等各个组件协同工作。我们中很少有人知道手机屏幕是如何单独工作的，但我们都能轻松地操作手机。同样，Web
    Components 也是网站复杂的构建块，它们使得网站对所有用户都变得可导航。
- en: More importantly, the millions of phone screens around the world today are largely
    based on only a handful of designs. Fundamentally, the technology behind the mobile
    component is reusable and adaptable, and the same principle applies to Web Components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，今天世界上数以百万计的手机屏幕在很大程度上基于只有少数几种设计。从根本上说，移动组件背后的技术是可重用和可适应的，同样的原则也适用于 Web
    Components。
- en: The above points show how component methodology can be useful in creating a
    better product. Now, you must be thinking, why do we even need to look into the
    concept of components on the web? Well, I would like you to recall the last five
    sites that you visited. All these five sites probably shared a few features in
    common. Some of these are a header, a footer, some sort of menu, and an advertisement
    section. All these features, in terms of functionality, are doing the same thing.
    The only thing that differs is the look and feel.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider another use case where the site domain is the same but there
    are multiple web apps running on that domain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'We have all used Google or at least two or three Google services. If we observe,
    there is a section at the top-right corner on any of the Google services/sites.
    It''s your account information, the one with your profile picture. And it shows
    the list of accounts you have logged in with:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22c29b2f-f549-42a8-9a40-c753c348e640.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: You will be able to see a similar account information card when you go from
    one service to another. Imagine being able to convert this functionality into
    an HTML tag `<account-info>` and being able to reuse it again and again on different
    services. This can be achieved with the help of Web Components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: A Web Component is a collection of specifications that lets a user create a
    functionality with a certain look and feel and which can be reused in such a way
    that all this functionality is encapsulated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Just like the preceding example, `<account-info>`, a Web Component lets you
    put your functionality into its own custom name, which can be represented by an
    HTML tag, and then encapsulate its functionality. This encapsulation makes it
    easy to distribute and it can be reused again and again very easily.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In all, a Web Component lets you create a custom HTML tag that can be reused,
    and whose functionality is encapsulated from the user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what Web Components are and what Web Components can do, let's
    talk about Web Component specifications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Web Component specifications
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like any technology, Web Components also have a set of specifications that
    need to be followed in order to achieve the functionality associated with them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'A Web Component specification has the following parts:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom element**: The ability to create custom HTML tags and make sure that
    the browser understands how to use this HTML tag'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shadow DOM**: The ability to encapsulate the contents of the component from
    other parts of the DOM'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template**: Being able to create a reusable DOM structure that can be modified
    on the fly and output desired results'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three specifications, when used together, provide a way to create a custom
    HTML tag that can output desired results (DOM structure) and let it encapsulate
    from the page, making it reusable again and again.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know these specifications and what they do, let's dive into them
    individually and try to look at their JavaScript APIs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Custom elements
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A custom element specification lets you create a custom HTML tag that can be
    used as its own HTML tag on the page. In order to achieve this, we need to first
    write a class with the functionalities associated with that HTML element, and
    then we need to register it so that the browser understands what this HTML tag
    is, and how it can be used on the page.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are someone who is new to the concept of classes in JavaScript, here
    is how you can create a class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Pretty simple, right? Let''s use the same class structure to create our custom
    element class, say `HelloWorld`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, our custom element class is called `HelloWorld` and it
    is extending interface from the `HTMLElement` class, which represents how an HTML
    element should work on a page. So, `HelloWorld` now knows what click events are,
    what CSS is, and so on, simply by extending `HTMLElement`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Inside this class, we have the `constructor()` method, which gets called as
    soon as a new instance of this class is created. The `super()` function needs
    to be called in order to correctly instantiate the properties of the extended
    class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code simply creates the element class definition. We still need
    to register this element. We can do so by writing the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What it does is register the class `HelloWorld` by defining it using the `define()`
    interface in the `customElements` interface; `hello-world` is the name of the
    custom element that is going to be available on the page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is defined, you can used the custom element by simply writing the
    HTML tag as following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When this code is run on a browser, it will render the text, **Hello World**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Final code: [https://codepen.io/prateekjadhwani/pen/jJZmyy](https://codepen.io/prateekjadhwani/pen/jJZmyy).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Types of custom elements
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have understood how we can register custom elements, it is time
    we looked deeper into the type of custom elements. Based on the type of requirement,
    we can create two types of custom elements:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**Autonomous custom element**: Any element that can be used by itself, without
    depending on another HTML element can be considered an autonomous custom element.
    In technical terms, Any custom  hat extends `HTMLElement` is an autonomous custom
    element.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have another example of an autonomous custom element. Let''s create
    a `SmileyEmoji` element that shows a smiley emoji. Here is what it looks like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This registers the `smiley-emoji` custom element, which can be used as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Customized built-in element**: This type of custom element can extend the
    functionality of an already existing HTML tag. Let''s create a custom element
    that extends `HTMLSpanElement` instead of `HTMLElement.` And its functionality
    is, say, it needs to add a smiley emoji at the end of the custom element:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if you have the following HTML, this will add the smiley to the end of
    the text `Hello World`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Final code: [https://codepen.io/prateekjadhwani/pen/RdQarm](https://codepen.io/prateekjadhwani/pen/RdQarm).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Try running the code for autonomous custom elements and customized built-in
    elements on a browser, or CodePen, or JSFiddle. The class and registration code
    will be in the JavaScript block and the rest will be in the HTML block.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Notice the difference in registration code for `<smiley-emoji>` and `<add-smiley>`
    custom elements. The second one uses an extra parameter that specifies what it
    is extending.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether a custom element is already defined or not with the help
    of the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It will either return undefined if it has not been registered, or will return
    the class definition, if it has been registered. This is a very helpful statement
    in large projects because registering an already registered custom element will
    break the code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Final code: [https://codepen.io/prateekjadhwani/pen/moXPBd](https://codepen.io/prateekjadhwani/pen/moXPBd).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Shadow DOM
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the second specification for Web Components and this one is responsible
    for encapsulation. Both the CSS and DOM can be encapsulated so that they are hidden
    from the rest of the page. What a shadow DOM does is let you create a new root
    node, called shadow root, that is hidden from the normal DOM of the page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even before we jump into the concept of a shadow DOM, let''s try to
    look at what a normal DOM looks like. Any page with a DOM follows a tree structure.
    Here I have the DOM structure of a very simple page:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e67c5097-533a-4500-be7a-443cf7de1386.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, you can see that `#document` is the root node for this
    page.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: You can find out the root node of a page by typing `document.querySelector('html').getRootNode()`
    in the browser console.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to get the child nodes of an HTML tag using `document.querySelector(''html'').childNodes`
    in the browser console, then you can see the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c74c9446-3506-4ab8-9535-8e66f8592d24.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Final code: [https://codepen.io/prateekjadhwani/pen/aMqBLa](https://codepen.io/prateekjadhwani/pen/aMqBLa).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: This shows that the DOM follows a tree structure. You can go deeper into these
    nodes by clicking on the arrow right next to the name of the node. And just like
    how I have shown in the screenshot, anyone can go into a particular node by expanding
    it and change these values. In order to achieve this encapsulation, the concept
    of a shadow DOM was invented.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: What a shadow DOM does is let you create a new root node, called shadow root,
    that is hidden from the normal DOM of the page. This shadow root can have any
    HTML inside and can work as any normal HTML DOM structure with events and CSS.
    But this shadow root can only be accessed by a shadow host attached to the DOM.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that instead of having text inside the `<p>` tag in
    the preceding example, we have a shadow host that is attached to a shadow root.
    This is what the page source would look like:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d50f552b-ec38-4de8-bfe0-9d5cb1a74e7e.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, if you tried to get the child nodes of this `<p>` tag, you would
    see something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e6719dc-3ccd-4f5e-8f66-49020c8a2c7a.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Notice that there is a `<span>` tag in the shadow root. Even though this `<span>`
    tag is present inside the `<p>` tag, the shadow root does not let JavaScript APIs
    touch it. This is how the shadow DOM encapsulates code inside itself.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Final code: [https://codepen.io/prateekjadhwani/pen/LaQxEY](https://codepen.io/prateekjadhwani/pen/LaQxEY).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a shadow DOM does, let's jump on to some code and learn
    how to create our own shadow DOMs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a DOM with a class name entry. This is what it looks like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to create a shadow DOM in this `div`, we will first need to get the
    reference to this `.entry` `div`, then we need to mark it as a shadow root, and
    then append the content to this shadow root. So, here is the JavaScript code for
    creating a `shadowRoot` inside a `div` and adding contents to it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Final code: [https://codepen.io/prateekjadhwani/pen/JzpWYE](https://codepen.io/prateekjadhwani/pen/JzpWYE).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Pretty simple, right? Remember, we are still discussing the shadow DOM spec.
    We haven''t started implementing it inside a custom element yet. Let''s recall
    the definition of our `hello-world` custom element. This is what it looked like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the text `Hello World` is currently being added to normal DOM. We
    can use the same shadow DOM concepts discussed earlier in this custom element.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to get the reference to the node where we want to attach the
    shadow root. In this case, let''s make the custom element itself the shadow host
    by using the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can either add a text node or create a new element and append it to
    this `shadowRoot`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Final code: [https://codepen.io/prateekjadhwani/pen/LaQyPB](https://codepen.io/prateekjadhwani/pen/LaQyPB).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Till now, we have only created custom elements and shadow DOMs that require
    only one or, at the most, two lines of HTML code. If we move on to a real-life
    example, HTML code can be more than two lines. It can start from a few lines of
    nested `div` to images and paragraphs—you get the picture. The template specification
    provides a way to hold HTML on the browser without actually rendering it on the
    page. Let us look at a small example of a template:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can write a template inside `<template>` tags and assign it an identifier,
    just as I have done with the help of an `id`. You can put it anywhere on the page;
    it does not matter. We can get its content with the help of JavaScript APIs and
    then clone it and put it inside any DOM, just as I have shown in the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similarly, we can have any number of templates on the page, which can be used
    by any JavaScript code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Final code: [https://codepen.io/prateekjadhwani/pen/ZPxOeq](https://codepen.io/prateekjadhwani/pen/ZPxOeq).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the same template with a shadow DOM. We will keep the template
    as it is. The changes in the JavaScript code would be something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are doing the same thing that we did in the previous example, but, instead
    of appending the code directly to the target `div`, we are first attaching a shadow
    root to the target `div`, and then appending the cloned template content.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Final code: [https://codepen.io/prateekjadhwani/pen/moxroz](https://codepen.io/prateekjadhwani/pen/moxroz).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We should be able to use the exact same concept inside the autonomous custom
    element that uses a shadow DOM. Let's give it a try.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the `id` of the template and call it `hello-world-template`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will follow the exact same approach that we followed in the preceding example.
    We will get the template content from the template reference, clone it, and append
    it in the custom element, making the code of the custom element look like the
    following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can simply call the HTML tag inside our page using the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we inspect the DOM structure inside developer tools, this is what we see:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/151c185e-055a-4b7b-803a-3f4a4dc84289.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Final code: [https://codepen.io/prateekjadhwani/pen/ywKgBp](https://codepen.io/prateekjadhwani/pen/ywKgBp).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Module loader API
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module loader API is not a part of Web Component spec sheet, but it is definitely
    something that is useful to know when it comes to creating and using multiple
    classes. As the name says, this specification lets a user load the modules. That
    is, if you have a bunch of classes, you can use module loaders to load these classes
    into the web page.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: If your build process involves using WebPack or Gulp or anything else that lets
    you import modules directly or indirectly, please feel free to skip this section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the basics. Let''s say we have our `index.html` like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see that there is a `<p>` tag in this HTML file. Now, let''s say we
    have a class called `AddNumber`, whose purpose is to add a random number between
    0 and 1 to this `<p>` tag. This would make the code look something like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Simple, right? If you open the page on a browser, you will simply see a random
    number, and if you inspect the page, you will see that the random number replaced
    the text which was inside the `<p>` tag.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'If we choose to store it in a JavaScript file, we can try to import it using
    the following code, where `addNumber.js` is the name of the file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s say you have a `randomNumberGenerator` function instead of the `Math.random()`
    method. The code would look something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We also want the ability to let the user create a new object of the `AddNumber`
    class, rather than us creating it in the file. We do not want the user to know
    how `randomNumberGenerator` works, so we want the user to be only able to create
    the object of `AddNumber`. This way, we reach how modules work. We, the creators
    of modules, decide which functionalities the user can use and which they cannot.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'We can choose what the user can use with the help of the `export` keyword.
    This would make the code look something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When this file is imported (note that we haven't talked about imports yet),
    the user will only be able to use the `AddNumber` class. The `randomNumberGenerator` function won't
    be available to the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you have another file with, say, two other functions, `add()`
    and `subtract()`, you can export both of them as shown in the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Importing a module can be easily done with the help of the import keyword. In
    this section, we will talk about the `type="module"` attribute.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the HTML file, `index.html`, instead of `type=text/javascript`, we can
    use `type=module` to tell the browser that the file that we are importing is a
    module. This is what it will look like when we are trying to import the file `addNumber.js`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is how it will look if we import functions from the `calc.js` module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how we can change the name of the module exported from `AddNumber`, which
    uses `export default`, and how we have to use the same name as the name of the
    function exported using `export`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Named export versus default export
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous examples, that is, `addNumber.js` and `calc.js`, we saw that
    there are two ways to export something: `export` and `export default`. The simplest
    way to understand it is as follows: when a file exports multiple things with different
    names and when these names cannot be changed after import, it is a named export,
    whereas, when we export only one thing from a module file and this name can be
    changed to anything after the import, it is a default export.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Custom elements using imports
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we need to create a Web Component that does a very simple task of
    showing a heading and a paragraph inside it, and the name of the custom element
    should be `<revamped-paragraph>`. This is what the definition of this Web Component
    would look like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our `index.html` file, the file that imports this module, would look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how the template is a part of our HTML, and how it gets used when the
    module is imported. We will be learning about all the steps that take place from
    the actual registration of the Web Components to what happens when they are removed
    from the page in the next chapter, where we will learn about life cycle methods.
    But for now, we need to look at more examples to understand how to create Web
    Components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another example. In this example, we need to import multiple
    Web Components in the `index.html` file. The components are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**A student attendance table component**: A table that shows the index number,
    student name, and attendance in a checkbox. This data is obtained from a `student.json`
    file.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An information banner component**: The purpose of this component is to show
    a phone number and an address for the school where these students are studying.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A time slot component**: A component that lets the user select a time slot
    for the class between three sets of timings.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us start with the first one, the `<student-attendance-table>` component.
    We need to first identify what it needs. In my opinion, these are the things it
    needs:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: A `fetch` call to the `student.json` file
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A template for each row of the string. I will be using template strings here
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default text that says loading... when it is making the call and another text
    that says unable to retrieve student list. when the fetch call fails
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what our `student.json` file looks like:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is what the definition of the Web Component looks like:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice the functions `getLoadingText()` and `getErrorText()`. Their purpose
    is simply to return a text. Then the `render()` method first consumes the `getLoadingText()`
    method, and then makes the call using `getStudentList()` to fetch the student
    list from `student.json` file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Once this student list is fetched, it gets passed onto `generateTable()` method,
    where every `name` and its `index` is passed into the `getTableRow()` method to
    generate rows and then gets returned back to be a part of the table. Once the
    table is formed, it is then passed into the `appendHTMLToShadowDOM()` method to
    be added to the shadow DOM for the component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to look into the `<information-banner>` component. Since this component
    simply needs to display a phone number and an address of the school where they
    are studying, we can use `<template>` and make it work. This is what it looks
    like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Furthermore, `information-banner-template` looks something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, it is not much different than the custom elements we have already
    talked about in previous sections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the last custom element, the `<time-slot>` component. Since
    it also involves a preset number of time slots, we can use a `<template>` tag
    to do our work.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The template would look something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The definition of the `<time-slot>` component would look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is the same as the previous component.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have written the Web Components, it''s time to take a look at the
    `index.html` file that includes all of these components together. This is what
    it looks like:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, one `<script>` tag of `type="module"` can import all three of
    them together, and can register the custom elements, which can be used in the
    `<body>` tag.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about Web Components and how we are able to identify
    them in our daily web visits. We also talked about the specifications associated
    with Web Components, making it easier to understand even further. We looked into
    custom elements and how we can create our own custom elements. We talked about
    the shadow DOM and how it provides a level of encapsulation for our Web Components.
    We then talked about templates and how they provide an element of reusability
    inside a Web Component. We also looked into modules and how they let you create
    and add Web Components dynamically.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Web 组件以及我们如何在日常的网页访问中识别它们。我们还讨论了与 Web 组件相关的规范，这使得进一步理解变得更加容易。我们探讨了自定义元素以及如何创建我们自己的自定义元素。我们还讨论了阴影
    DOM 以及它为我们的 Web 组件提供的一定程度的封装。然后我们讨论了模板以及它们如何在 Web 组件内部提供可重用性。此外，我们还探讨了模块以及它们如何让您动态创建和添加
    Web 组件。
- en: We dived deep into creating a Web Component with detailed code examples. With
    this, we should be able to create a simple Web Component from scratch without
    any issues.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了使用详细代码示例创建 Web 组件。通过这种方式，我们应该能够从头开始创建一个简单的 Web 组件而不会遇到任何问题。
- en: In the next chapter, we will look into how we can make our Web Components do
    more with life cycle methods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何利用生命周期方法让我们的 Web 组件做得更多。
