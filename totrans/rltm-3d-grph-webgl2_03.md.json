["```js\nuniform vec4 uLightColor;\n```", "```js\nuLightColor[3] = 1.0;\nuLightColor.w = 1.0;\nuLightColor.a = 1.0;\nuLightColor.q = 1.0;\n```", "```js\nvec4 v4;\n\nv4.rgba;  // is a vec4 and the same as just using v4\nv4.rgb;   // is a vec3\nv4.b;     // is a float\nv4.xy;    // is a vec2\nv4.xgba;  // is illegal - the component names do not come from the same set\n```", "```js\nin vec3 aVertexPosition;\nin vec3 aVertexNormal;\n```", "```js\nuniform vec3 uLightDirection;  // incoming light source direction\nuniform vec4 uLightDiffuse;    // light diffuse component\nuniform vec4 uMaterialDiffuse; // material diffuse color\n```", "```js\n#version 300 es\n\nout vec4 vVertexColor;\n\nvoid main(void) {\n  vVertexColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n```", "```js\nin vec4 vVertexColor;\n```", "```js\nattribute vec4 aVertexPosition;\nattribute vec3 aVertexNormal;\n```", "```js\nin vec4 aVertexPosition;\nin vec3 aVertexNormal;\n```", "```js\nvarying vec4 vVertexPosition;\nvarying vec3 vVertexNormal;\n```", "```js\nout vec4 vVertexPosition;\nout vec3 vVertexNormal;\n```", "```js\nin vec4 vVertexPosition;\nin vec3 vVertexNormal;\n```", "```js\n#version 300 es\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uNormalMatrix;\nuniform vec3 uLightDirection;\nuniform vec3 uLightDiffuse;\nuniform vec3 uMaterialDiffuse;\n\nin vec3 aVertexPosition;\nin vec3 aVertexNormal;\n\nout vec4 vVertexColor;\n\nvoid main(void) {\n  vec3 normal = normalize(vec3(uNormalMatrix * vec4(aVertexNormal, 1.0)));\n\n  vec3 lightDirection = normalize(uLightDirection);\n\n  float LambertianTerm = dot(normal, -lightDirection);\n\n  vVertexColor = vec4(uMaterialDiffuse * uLightDiffuse * LambertianTerm, \n   1.0);\n\n  gl_Position = uProjectionMatrix * uModelViewMatrix * \n   vec4(aVertexPosition, 1.0);\n}\n```", "```js\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uNormalMatrix;\n```", "```js\nvec3 normal = normalize(vec3(uNormalMatrix * vec4(aVertexNormal, 1.0)));\n\n```", "```js\ngl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n```", "```js\nvVertexColor = vec4(uMaterialDiffuse * uLightDiffuse * LambertianTerm, 1.0);\n```", "```js\n#version 300 es\n\n// Fragment shaders don't have a default precision so we need\n// to pick one. mediump is a good default. It means \"medium precision\"\nprecision mediump float;\n\nin vec4 vVertexColor;\n// we need to declare an output for the fragment shader\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vVertexColor;\n}\n```", "```js\naVertexColor = Id;\n```", "```js\nId = lightDiffuseProperty * materialDiffuseProperty * lambertCoefficient;\n```", "```js\n#version 300 es\nprecision mediump float;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uNormalMatrix;\nuniform vec3 uLightDirection;\nuniform vec3 uLightDiffuse;\nuniform vec3 uMaterialDiffuse;\n\nin vec3 aVertexPosition;\nin vec3 aVertexNormal;\n\nout vec4 vVertexColor;\n\nvoid main(void) {\n  // Calculate the normal vector\n  vec3 N = normalize(vec3(uNormalMatrix * vec4(aVertexNormal, 1.0)));\n  // Normalized light direction\n  vec3 L = normalize(uLightDirection);\n  // Dot product of the normal product and negative light direction vector\n  float lambertTerm = dot(N, -L);\n  // Calculating the diffuse color based on the Lambertian reflection model\n  vec3 Id = uMaterialDiffuse * uLightDiffuse * lambertTerm;\n  vVertexColor = vec4(Id, 1.0);\n  // Setting the vertex position\n  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\n// Expect the interpolated value fro, the vertex shader\nin vec4 vVertexColor;\n\n// Return the final color as fragColor\nout vec4 fragColor;\n\nvoid main(void)  {\n  // Simply set the value passed in from the vertex shader\n  fragColor = vVertexColor;\n}\n```", "```js\nvec3 light = vec3(uModelViewMatrix * vec4(uLightDirection, 0.0));\n```", "```js\nvec4(uLightDirection, 0.0);\n```", "```js\nmat4.rotate(modelViewMatrix, modelViewMatrix, angle * Math.PI / 180, [0, 1, 0]);\n```", "```js\ngl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);\n```", "```js\ngl.uniform3f(program.uLightDirection, 0, -1, -1);\n```", "```js\ngl.uniform3f(program.uLightDirection, 0, -1, -1);\n```", "```js\nmat4.rotate(modelViewMatrix, modelViewMatrix, angle * Math.PI / 180, [0, 1, 0]);\n```", "```js\nmat4.rotate(modelViewMatrix, modelViewMatrix, angle * Math.PI / 180, [1, 0, 0]);\n\n```", "```js\nfinalVertexColor = Ia + Id + Is;\n```", "```js\nIa = lightAmbient * materialAmbient;\nId = lightDiffuse * materialDiffuse * lambertCoefficient;\nIs = lightSpecular * materialSpecular * specularCoefficient;\n```", "```js\nfloat specular = pow(max(dot(lightReflection, eyeVector), 0.0), shininess);\n```", "```js\n#version 300 es\nprecision mediump float;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uNormalMatrix;\nuniform vec3 uLightDirection;\nuniform vec4 uLightAmbient;\nuniform vec4 uLightDiffuse;\nuniform vec4 uMaterialDiffuse;\n\nin vec3 aVertexPosition;\nin vec3 aVertexNormal;\n\nout vec4 vVertexColor;\n\nvoid main(void) {\n  vec3 N = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));\n  vec3 light = vec3(uModelViewMatrix * vec4(uLightDirection, 0.0));\n  vec3 L = normalize(light);\n  float lambertTerm = dot(N,-L);\n  vec4 Ia = uMaterialDiffuse * uLightAmbient;\n  vec4 Id =  uMaterialDiffuse * uLightDiffuse * lambertTerm;\n  vVertexColor = vec4(vec3(Ia + Id), 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nin vec4 vVertexColor;\n\nout vec4 fragColor;\n\nvoid main(void)  {\n  fragColor = vVertexColor;\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uNormalMatrix;\n\nin vec3 aVertexPosition;\nin vec3 aVertexNormal;\n\nout vec3 vNormal;\nout vec3 vEyeVector;\n\nvoid main(void) {\n  vec4 vertex = uModelViewMatrix * vec4(aVertexPosition, 1.0);\n  vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));\n  vEyeVector = -vec3(vertex.xyz);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nuniform float uShininess;\nuniform vec3 uLightDirection;\nuniform vec4 uLightAmbient;\nuniform vec4 uLightDiffuse;\nuniform vec4 uLightSpecular;\nuniform vec4 uMaterialAmbient;\nuniform vec4 uMaterialDiffuse;\nuniform vec4 uMaterialSpecular;\n\nin vec3 vNormal;\nin vec3 vEyeVector;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec3 L = normalize(uLightDirection);\n  vec3 N = normalize(vNormal);\n  float lambertTerm = dot(N, -L);\n  vec4 Ia = uLightAmbient * uMaterialAmbient;\n  vec4 Id = vec4(0.0, 0.0, 0.0, 1.0);\n  vec4 Is = vec4(0.0, 0.0, 0.0, 1.0);\n\n  if (lambertTerm > 0.0) {\n    Id = uLightDiffuse * uMaterialDiffuse * lambertTerm;\n    vec3 E = normalize(vEyeVector);\n    vec3 R = reflect(L, N);\n    float specular = pow( max(dot(R, E), 0.0), uShininess);\n    Is = uLightSpecular * uMaterialSpecular * specular;\n  }\n\n  fragColor = vec4(vec3(Ia + Id + Is), 1.0);\n}\n```", "```js\nfunction initProgram() {\n  const canvas = utils.getCanvas('webgl-canvas');\n  utils.autoResizeCanvas(canvas);\n\n  gl = utils.getGLContext(canvas);\n  gl.clearColor(0.9, 0.9, 0.9, 1);\n  gl.clearDepth(100);\n  gl.enable(gl.DEPTH_TEST);\n  gl.depthFunc(gl.LEQUAL);\n\n  const vertexShader = utils.getShader(gl, 'vertex-shader');\n  const fragmentShader = utils.getShader(gl, 'fragment-shader');\n\n  program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error('Could not initialize shaders');\n  }\n\n  gl.useProgram(program);\n\n  program.aVertexPosition = gl.getAttribLocation(program, \n   'aVertexPosition');\n  program.aVertexNormal = gl.getAttribLocation(program, 'aVertexNormal');\n\n  program.uProjectionMatrix = gl.getUniformLocation(program, \n   'uProjectionMatrix');\n  program.uModelViewMatrix = gl.getUniformLocation(program, \n   'uModelViewMatrix');\n  program.uNormalMatrix = gl.getUniformLocation(program, \n   'uNormalMatrix');\n  program.uLightDirection = gl.getUniformLocation(program, \n   'uLightDirection');\n  program.uLightAmbient = gl.getUniformLocation(program, 'uLightAmbient');\n  program.uLightDiffuse = gl.getUniformLocation(program, 'uLightDiffuse');\n  program.uMaterialDiffuse = gl.getUniformLocation(program, \n   'uMaterialDiffuse');\n}\n```", "```js\nconst canvas = utils.getCanvas('webgl-canvas');\nutils.autoResizeCanvas(canvas);\n\ngl = utils.getGLContext(canvas);\ngl.clearColor(0.9, 0.9, 0.9, 1);\ngl.clearDepth(100);\ngl.enable(gl.DEPTH_TEST);\ngl.depthFunc(gl.LEQUAL);\n\nconst vertexShader = utils.getShader(gl, 'vertex-shader');\n const fragmentShader = utils.getShader(gl, 'fragment-shader');\n```", "```js\nprogram = gl.createProgram();\ngl.attachShader(program, vertexShader);\ngl.attachShader(program, fragmentShader);\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n  alert('Could not initialize shaders');\n}\n\ngl.useProgram(program);\n```", "```js\nprogram.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\nprogram.aVertexNormal = gl.getAttribLocation(program, 'aVertexNormal');\n\nprogram.uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');\nprogram.uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');\nprogram.uNormalMatrix = gl.getUniformLocation(program, 'uNormalMatrix');\nprogram.uLightDirection = gl.getUniformLocation(program, 'uLightDirection');\nprogram.uLightAmbient = gl.getUniformLocation(program, 'uLightAmbient');\nprogram.uLightDiffuse = gl.getUniformLocation(program, 'uLightDiffuse');\nprogram.uMaterialDiffuse = gl.getUniformLocation(program, 'uMaterialDiffuse');\n```", "```js\nconst vertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\ngl.enableVertexAttribArray(vertexPosition);\n\nconst colorLocation = gl.getAttribLocation(program, 'aVertexColor');\ngl.enableVertexAttribArray(colorLocation);\n```", "```js\n#version 300 es\n\nin vec4 aVertexPosition;\nin vec3 aVertexColor;\n\nout vec3 vVertexColor;\n\nvoid main() {\n  vVertexColor = aVertexColor;\n  gl_Position = aVertexPosition;\n}\n```", "```js\nconst vertexPosition = 0;\ngl.enableVertexAttribArray(vertexPosition);\n\nconst colorLocation = 1;\ngl.enableVertexAttribArray(colorLocation);\n```", "```js\n#version 300 es\n\nlayout (location=0) in vec4 aVertexPosition;\nlayout (location=1) in vec3 aVertexColor;\n\nout vec3 vVertexColor;\n\nvoid main() {\n  vVertexColor = aVertexColor;\n  gl_Position = aVertexPosition;\n}\n```", "```js\nfunction initLights() {\n  gl.uniform3fv(program.uLightDirection, [0, 0, -1]);\n  gl.uniform4fv(program.uLightAmbient, [0.01, 0.01, 0.01, 1]);\n  gl.uniform4fv(program.uLightDiffuse, [0.5, 0.5, 0.5, 1]);\n  gl.uniform4f(program.uMaterialDiffuse, 0.1, 0.5, 0.8, 1);\n}\n```", "```js\ngl.vertexAttribPointer(index, size, type, normalize, stride, offset);\n```", "```js\ngl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);\ngl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n\ngl.bindBuffer(gl.ARRAY_BUFFER, normalsBuffer);\ngl.vertexAttribPointer(program.aVertexNormal, 3, gl.FLOAT, false, 0, 0);\n```", "```js\nprogram.aVertexNormal= gl.getAttribLocation(program, 'aVertexNormal');\n```", "```js\nfunction initBuffers() {\n  const vertices = [\n    -20, -8, 20, // 0\n    -10, -8, 0,  // 1\n    10, -8, 0,   // 2\n    20, -8, 20,  // 3\n    -20, 8, 20,  // 4\n    -10, 8, 0,   // 5\n    10, 8, 0,    // 6\n    20, 8, 20    // 7\n  ];\n\n  indices = [\n    0, 5, 4,\n    1, 5, 0,\n    1, 6, 5,\n    2, 6, 1,\n    2, 7, 6,\n    3, 7, 2\n  ];\n\n  // Create VAO\n  vao = gl.createVertexArray();\n\n  // Bind Vao\n  gl.bindVertexArray(vao);\n\n  const normals = utils.calculateNormals(vertices, indices);\n\n  const verticesBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), \n   gl.STATIC_DRAW);\n  // Configure instructions\n  gl.enableVertexAttribArray(program.aVertexPosition);\n  gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, \n   false, 0, 0);\n\n  const normalsBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalsBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), \n   gl.STATIC_DRAW);\n  // Configure instructions\n  gl.enableVertexAttribArray(program.aVertexNormal);\n  gl.vertexAttribPointer(program.aVertexNormal, 3, gl.FLOAT, false, \n   0, 0);\n\n  indicesBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), \n   gl.STATIC_DRAW);\n\n  // Clean\n  gl.bindVertexArray(null);\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n```", "```js\nfunction draw() {\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  mat4.perspective(projectionMatrix, 45, gl.canvas.width / \n   gl.canvas.height, 0.1, 10000);\n  mat4.identity(modelViewMatrix);\n  mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -40]);\n\n  gl.uniformMatrix4fv(program.uModelViewMatrix, false, \n   modelViewMatrix);\n  gl.uniformMatrix4fv(program.uProjectionMatrix, false, \n   projectionMatrix);\n\n  mat4.copy(normalMatrix, modelViewMatrix);\n  mat4.invert(normalMatrix, normalMatrix);\n  mat4.transpose(normalMatrix, normalMatrix);\n\n  gl.uniformMatrix4fv(program.uNormalMatrix, false, normalMatrix);\n\n  try {\n    // Bind VAO\n    gl.bindVertexArray(vao);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);\n    gl.drawElements(gl.TRIANGLES, indices.length, \n     gl.UNSIGNED_SHORT, 0);\n\n    // Clean\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n  catch (error) {\n    console.error(error);\n  }\n}\n```", "```js\nfunction initLights() {\n  gl.uniform3fv(program.uLightDirection, [0, 0, -1]);\n  gl.uniform4fv(program.uLightAmbient, [0.01, 0.01, 0.01, 1]);\n  gl.uniform4fv(program.uLightDiffuse, [0.5, 0.5, 0.5, 1]);\n  gl.uniform4f(program.uMaterialDiffuse, 0.1, 0.5, 0.8, 1);\n}\n```", "```js\nfunction processKey(ev) {\n  const lightDirection = gl.getUniform(program, program.uLightDirection);\n  const incrementValue = 10;\n\n  switch (ev.keyCode) {\n    // left arrow\n    case 37: {\n      azimuth -= incrementValue;\n      break;\n    }\n    // up arrow\n    case 38: {\n      elevation += incrementValue;\n      break;\n    }\n    // right arrow\n    case 39: {\n      azimuth += incrementValue;\n      break;\n    }\n    // down arrow\n    case 40: {\n      elevation -= incrementValue;\n      break;\n    }\n  }\n\n  azimuth %= 360;\n  elevation %= 360;\n\n  const theta = elevation * Math.PI / 180;\n  const phi = azimuth * Math.PI / 180;\n\n  // Spherical to cartesian coordinate transformation\n  lightDirection[0] = Math.cos(theta) * Math.sin(phi);\n  lightDirection[1] = Math.sin(theta);\n  lightDirection[2] = Math.cos(theta) * -Math.cos(phi);\n\n  gl.uniform3fv(program.uLightDirection, lightDirection);\n}\n```", "```js\nconst lightDirection = gl.getUniform(program, program.uLightDirection);\n```", "```js\ngl.uniform3fv(program.uLightDirection, lightDirection);\n```", "```js\nvec4 light = uModelViewMatrix * vec4(uLightPosition, 1.0);\nvLightRay = vertex.xyz - light.xyz;\n```", "```js\nvec4 light = vec4(uLightPosition, 1.0);\n```", "```js\n<script type=\"text/javascript\" src=\"img/Program.js\"></script> \n```", "```js\nfunction initProgram() {\n  const canvas = document.getElementById('webgl-canvas');\n  utils.autoResizeCanvas(canvas);\n\n  gl = utils.getGLContext(canvas);\n  gl.clearColor(...clearColor, 1);\n  gl.enable(gl.DEPTH_TEST);\n  gl.depthFunc(gl.LEQUAL);\n\n  program = new Program(gl, 'vertex-shader', 'fragment-shader');\n\n  const attributes = [\n    'aVertexPosition',\n    'aVertexNormal'\n  ];\n\n  const uniforms = [\n    'uProjectionMatrix',\n    'uModelViewMatrix',\n    'uNormalMatrix',\n    'uLightAmbient',\n    'uLightPosition',\n    'uMaterialSpecular',\n    'uMaterialDiffuse',\n    'uShininess'\n  ];\n\n  program.load(attributes, uniforms);\n}\n```", "```js\n'use strict';\n\n/*\n* Program constructor that takes a WebGL context and script tag IDs\n* to extract vertex and fragment shader source code from the page\n*/\nclass Program {\n\n  constructor(gl, vertexShaderId, fragmentShaderId) {\n    this.gl = gl;\n    this.program = gl.createProgram();\n\n    if (!(vertexShaderId && fragmentShaderId)) {\n      return console.error('No shader IDs were provided');\n    }\n\n    gl.attachShader(this.program, utils.getShader(gl, \n     vertexShaderId));\n    gl.attachShader(this.program, utils.getShader(gl, \n     fragmentShaderId));\n    gl.linkProgram(this.program);\n\n    if (!this.gl.getProgramParameter(this.program, \n     this.gl.LINK_STATUS)) {\n      return console.error('Could not initialize shaders.');\n    }\n\n    this.useProgram();\n  }\n\n  // Sets the WebGL context to use current program\n  useProgram() {\n    this.gl.useProgram(this.program);\n  }\n\n  // Load up the given attributes and uniforms from the given values\n  load(attributes, uniforms) {\n    this.useProgram();\n    this.setAttributeLocations(attributes);\n    this.setUniformLocations(uniforms);\n  }\n\n  // Set references to attributes onto the program instance\n  setAttributeLocations(attributes) {\n    attributes.forEach(attribute => {\n      this[attribute] = this.gl.getAttribLocation(this.program, \n       attribute);\n    });\n  }\n\n  // Set references to uniforms onto the program instance\n  setUniformLocations(uniforms) {\n    uniforms.forEach(uniform => {\n      this[uniform] = this.gl.getUniformLocation(this.program, \n       uniform);\n    });\n  }\n\n  // Get the uniform location from the program\n  getUniform(uniformLocation) {\n    return this.gl.getUniform(this.program, uniformLocation);\n  }\n\n}\n```", "```js\nconst utils = {\n\n  // Normalize colors from 0-255 to 0-1\n  normalizeColor(color) {\n    return color.map(c => c / 255);\n  },\n\n  // De-normalize colors from 0-1 to 0-255\n  denormalizeColor(color) {\n    return color.map(c => c * 255);\n  },\n\n  // ...  \n};\n```"]