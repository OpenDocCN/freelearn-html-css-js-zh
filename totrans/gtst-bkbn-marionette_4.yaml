- en: Chapter 4. Managing Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。管理视图
- en: As we learned in [Chapter 3](ch03.html "Chapter 3. Marionette View Types and
    Their Use"), *Marionette View Types and Their Use*, `Marionette.js` views provide
    us with a lot of functionality to render data with the benefit of having to write
    very little code in exchange. In this chapter, we are going to discover what a
    `Region` in Marionette is and what `RegionManager` and `BabySitter` objects are.
    All of them are intended to help us manage views in an easier way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第3章](ch03.html "第3章。Marionette 视图类型及其使用")中学习的那样，*Marionette 视图类型及其使用*，`Marionette.js`
    视图为我们提供了许多功能，以极少的代码编写量渲染数据。在本章中，我们将探讨 Marionette 中的 `Region` 是什么，以及 `RegionManager`
    和 `BabySitter` 对象是什么。所有这些都是为了帮助我们以更简单的方式管理视图。
- en: 'We will also get to know a handy object while rendering templates in your application:
    the `Renderer` object. After that, we will have a short summary of what we have
    learned through the first four chapters.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将了解在应用程序中渲染模板时的一个实用对象：`Renderer` 对象。之后，我们将简要总结前四章所学的内容。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: '`Marionette.Region`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette.Region`'
- en: '`Marionette.RegionManager`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette.RegionManager`'
- en: '`Marionette.BabySitter`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette.BabySitter`'
- en: '`Marionette.Renderer`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette.Renderer`'
- en: Improving the application's performance with `Marionette.TemplateCache`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Marionette.TemplateCache` 提高应用程序的性能
- en: All of these are very helpful objects that will help us to manage our Marionette
    views with ease, keeping in mind performance and reuse.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都非常有用的对象，将帮助我们轻松管理 Marionette 视图，同时考虑到性能和重用。
- en: Understanding the Marionette.Region object
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Marionette.Region 对象
- en: While building an application, we need to separate the screen into small, logical
    pieces such as header, footer, navigation, and content area. These are common
    parts that are present in most applications. Usually your navigation options can
    change depending on the user. The header may also be different based on your user
    profile, and of course, your content area is going to be busy showing different
    views—views that need to be rendered to perform an action and closed in order
    to show a new view with perhaps some results or the next logical steps in your
    application. That's why we should think of the footer or content parts of your
    application as regions within your application, where we will be swapping different
    views.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，我们需要将屏幕划分为小的、逻辑的部分，如页眉、页脚、导航和内容区域。这些是大多数应用程序中常见的部分。通常，您的导航选项可能会根据用户而变化。页眉也可能根据您的用户配置文件而不同，当然，您的内容区域将忙于显示不同的视图——需要渲染以执行操作并关闭以显示新视图的视图，可能还有一些结果或应用程序中的下一个逻辑步骤。这就是为什么我们应该将应用程序的页脚或内容部分视为应用程序内的区域，在那里我们将交换不同的视图。
- en: 'The following code exemplifies one of the ways to create a `Marionette.Region`
    object:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了创建 `Marionette.Region` 对象的一种方法：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To define a region, we just need to specify an element in DOM that will serve
    as a container of the views on your logical section of the application. In this
    case, the `#footer` is a DIV element, but it can be any HTML element as long as
    appending a view inside of it generates a valid HTML.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个区域，我们只需指定一个 DOM 元素，该元素将作为应用程序逻辑部分中视图的容器。在这种情况下，`#footer` 是一个 DIV 元素，但可以是任何
    HTML 元素，只要在其中添加视图可以生成有效的 HTML。
- en: The idea behind a region is to use it as a container of views in your application
    one at a time. It will be in charge of calling the `render` function of the specified
    view when we call the method `.show` of the region. It will call the close method
    of the current view and remove it from the DOM when we call the method `.close`
    of the region.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 区域背后的想法是将其用作应用程序中视图的容器，一次一个。当我们调用区域的 `.show` 方法时，它将负责调用指定视图的 `render` 函数。当我们调用区域的
    `.close` 方法时，它将调用当前视图的关闭方法并将其从 DOM 中移除。
- en: 'The following is the code needed to use a region in order to render a view:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要使用区域来渲染视图的代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see in the preceding code snippet, the `show` method of the region
    will take the instance of the view to be rendered as a parameter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，区域的 `show` 方法将接受要渲染的视图实例作为参数。
- en: 'Rendering the views and then swapping them for new ones seems trivial at the
    beginning. We can just call `close` and `render`, right? Then why do we need a
    region object to do it for us? This is because the region does these things for
    us and much more, without us having to worry about which view is the current view
    displayed inside of it. Think of it in this way: you have the content region and
    you will display a view inside of it. We can replace this view with a new one
    just by calling the `.show` method and the region will take care of the removal
    of the first view. So we don''t have to call its `close` method, as this is part
    of the functionality of the `show` method of the region. This means that if there
    is a view already being displayed in the region, the `close` method of the exiting
    view will be called by calling `show` and passing a new view, thereby ensuring
    there is proper removal of its `.el` event bindings.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，渲染视图然后交换为新视图似乎很简单。我们只需调用`close`和`render`，对吧？那么为什么我们需要一个区域对象来为我们做这件事呢？这是因为区域为我们做这些事情，而且更多，我们不需要担心当前显示在其中的视图是哪一个。可以这样想：你有内容区域，你将在其中显示一个视图。我们只需通过调用`.show`方法来替换这个视图，区域将负责移除第一个视图。所以我们不需要调用它的`close`方法，因为这是区域`.show`方法功能的一部分。这意味着如果区域中已经显示了一个视图，通过调用`show`并传递一个新的视图来调用，将调用现有视图的`close`方法，从而确保其`.el`事件绑定被正确移除。
- en: Let's use a wizard as an example. We have four steps and on each step, we show
    a view where we will fill some data. On each one of these views, we have links
    that will guide us to the next step or to the previous step in case we want to
    modify the data. The links will modify the URL, and it will be the router's responsibility
    to call the proper step.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个巫师为例。我们分为四个步骤，在每一步中，我们展示一个视图，我们将在这里填写一些数据。在这些视图中的每一个，我们都有链接，这些链接将引导我们进入下一步或回到前一步，以防我们想要修改数据。这些链接将修改URL，这将由路由器负责调用适当的步骤。
- en: 'For this example, the code that is inside the controller is given as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，控制器内部的代码如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the preceding code, we can see the benefits of using a region to render
    views. If the user clicks on the second step and decides to go back, we don't
    need to check whether the instance of the `stepTwoView` method is in memory and
    close it in order to render the `stepOneView` method, as this will be handled
    by the region.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到使用区域渲染视图的好处。如果用户点击第二个步骤并决定返回，我们不需要检查`stepTwoView`方法的实例是否在内存中，并关闭它以渲染`stepOneView`方法，因为这将由区域处理。
- en: There will be occasions where it will be impossible to track which view is present
    in a region, and in most of those cases, we don't care. We just need to render
    a new view on this area without having to worry about whether the previous view
    is being removed in a proper way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有一些情况，我们无法跟踪区域中存在哪个视图，在大多数这些情况下，我们并不关心。我们只需要在这个区域上渲染一个新的视图，而无需担心之前的视图是否被正确移除。
- en: 'Another way to declare a region is by attaching it directly to a Marionette
    application, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种声明区域的方法是将它直接附加到Marionette应用程序上，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, we used the `.addRegions` method of the application object that
    is expecting an object literal with the names of the regions and the DOM element
    to be used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了应用程序对象的`.addRegions`方法，它期望一个包含区域名称和要使用的DOM元素的字面量对象。
- en: 'To use these new regions, we just need to call them by the name given in the
    object literal, which is used for this configuration as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些新的区域，我们只需通过在对象字面量中给出的名称来调用它们，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In [Chapter 3](ch03.html "Chapter 3. Marionette View Types and Their Use"),
    *Marionette View Types and Their Use*, we defined a layout. The layout view of
    Marionette serves as a container of regions or as a container of containers. The
    layout will render a template with the skeleton of your HTML. Inside this skeleton,
    we will put the DIV element or elements that will serve as regions, and once this
    layout is rendered, we can use its region to display views.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。Marionette视图类型及其使用")中，我们定义了一个布局。"Marionette视图类型及其使用"，Marionette的布局视图充当区域或容器。布局将渲染一个包含HTML骨架的模板。在这个骨架内部，我们将放置作为区域的DIV元素或元素，一旦这个布局被渲染，我们就可以使用它的区域来显示视图。
- en: 'So lets review the code as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们按照以下方式回顾代码：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the layout declaration, we defined a template and the regions object literal,
    giving names to the regions and matching those with the DOM elements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局声明中，我们定义了一个模板和区域对象字面量，为区域命名，并将它们与DOM元素匹配。
- en: 'For this `BookStoreApp`, we will create `mainRegion`. The responsibility of
    this region is to render the layout view of the application. The layout view will
    contain the initial HTML file and the logical regions of the application, regions
    that will show the proper views. The following code exemplifies the creation of
    the application object, the layout view, and the rendering of views inside the
    regions of the layout:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个`BookStoreApp`，我们将创建`mainRegion`。这个区域的责任是渲染应用程序的布局视图。布局视图将包含初始HTML文件和应用程序的逻辑区域，这些区域将显示适当的视图。以下代码示例说明了创建应用程序对象、布局视图以及在布局区域中渲染视图：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the help of the layout and the regions, we can create a logical segmentation
    of the screen that will allow us to render views on each region. Using meaningful
    names for these regions will definitely help, as we just need to pass the right
    view to the region and stop worrying about the glue code needed for rendering
    and cleanup.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局和区域的帮助下，我们可以创建屏幕的逻辑分割，这将允许我们在每个区域上渲染视图。为这些区域使用有意义的名称将肯定有所帮助，因为我们只需要将正确的视图传递给区域，并停止担心渲染和清理所需的粘合代码。
- en: 'A region will raise the following two events while rendering a view that will
    help us to perform an extra manipulation to the DOM:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染视图时，区域将引发以下两个事件，这将帮助我们执行对DOM的额外操作：
- en: '`"show"/onShow`: This event is called on the view instance when the view has
    been rendered and displayed'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"show"/onShow`: 当视图渲染并显示时，此事件在视图实例上被调用'
- en: '`"show"/onShow`: This event is called on the region instance when the view
    has been rendered and displayed'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"show"/onShow`: 当视图渲染并显示时，此事件在区域实例上被调用'
- en: 'Finally, while closing a view, the following method will be raised that can
    be used to perform one of the final tasks such as notifying the user with a friendly
    message:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在关闭视图时，以下方法将被触发，可以用来执行一些最终任务，例如用友好的消息通知用户：
- en: '`"close"/onClose`: This method is called when the view has been closed'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"close"/onClose`: 当视图被关闭时，此方法被调用'
- en: 'You can subscribe to these events as usual with the `.on` method declaration
    as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`.on`方法声明像往常一样订阅这些事件，如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code exemplifies how to subscribe to the `close` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何订阅`close`方法：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the Marionette.RegionManager object
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Marionette.RegionManager对象
- en: Using regions helps to manage views in a very elegant way. But that may not
    be enough for some applications, which can have dozens of regions that need to
    be added and removed during the lifetime of the application. To accomplish this
    management, we can take advantage of the `RegionManager` object of Marionette,
    which will serve as a container for regions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用区域可以帮助以非常优雅的方式管理视图。但对于某些应用程序来说，这可能还不够，这些应用程序在其生命周期中可能需要添加和删除数十个区域。为了完成这项管理，我们可以利用Marionette的`RegionManager`对象，它将作为区域的容器。
- en: Having your regions in this container can help us to accomplish almost the same
    actions, which we could accomplish with a `Backbone.Collection` object, with the
    help of underscore methods such as `each`, `map`, `invoke`, `contains`, and `toArray`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将区域放在这个容器中可以帮助我们完成几乎与使用`Backbone.Collection`对象相同的行为，借助underscore方法如`each`、`map`、`invoke`、`contains`和`toArray`。
- en: 'The following syntax can help us to declare `Marionette.RegionManager`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法可以帮助我们声明`Marionette.RegionManager`：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following syntax demonstrates how to add a region to `regionManager`. The
    `addRegion` method takes two parameters. The first one will be the ID or alias
    of the region, and the second one will be the DOM element to be used.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法演示了如何将区域添加到`regionManager`。`addRegion`方法接受两个参数。第一个将是区域的ID或别名，第二个将是用于的DOM元素。
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we want to add multiple regions, we need to use the `addRegions` method and
    pass an object literal to this method with names and IDs as parameters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加多个区域，我们需要使用`addRegions`方法，并将带有名称和ID的对象字面量作为参数传递给此方法。
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can make use of the `removeRegion` method to remove the region from `regionManager`
    and also to close the region, which will call `close` on the contained view, thereby
    removing this view from the application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`removeRegion`方法从`regionManager`中删除区域，并关闭区域，这将调用包含视图的`close`，从而从应用程序中删除此视图。
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To remove all the regions, we can use the `removeRegions` method as shown in
    the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除所有区域，我们可以使用以下代码中所示的 `removeRegions` 方法：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can continue adding more regions to this container. But let's now create
    a `RegionManager` object for a category that will contain regions for subcategories;
    each region will show a `CollectionView` object with books of the same subcategory.
    So we display a `CollectionView` object inside a region with the same name.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续向这个容器添加更多区域。但现在让我们创建一个 `RegionManager` 对象，用于一个包含子类别区域的类别；每个区域将显示一个具有相同子类别书籍的
    `CollectionView` 对象。因此，我们在具有相同名称的区域中显示一个 `CollectionView` 对象。
- en: The idea is that the user wants to view books of his favorite category and also
    wants to add more subcategories to the screen to be rendered. For instance, in
    the History category, we can have an option to view books from modern history,
    Rome, universal history, World War II, and many more subcategories.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是用户希望查看他最喜欢的类别的书籍，并且还希望向屏幕上添加更多要渲染的子类别。例如，在历史类别中，我们可以有一个选项来查看现代历史、罗马、世界历史、第二次世界大战等更多子类别的书籍。
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then just render the proper view on each region as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在每个区域上渲染适当的视图，如下所示：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If at some point, the user switches to another category and no longer wants
    to see the History category, calling `removeRegions` will cascade to the view
    level, thereby removing all the views in a safe way for us.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个时刻，用户切换到另一个类别并且不再想看到历史类别，调用 `removeRegions` 将级联到视图级别，从而以安全的方式移除所有视图。
- en: Using the Backbone.BabySitter object
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Backbone.BabySitter 对象
- en: With the value that they provide, two objects made its way out of the Marionette
    library and can be used individually by including them in your scripts or using
    the blended version of Marionette. One is the `Backbone.Wreqr.EventAggregator`
    object and the other is the `Backbone.BabySitter` object, which is the one that
    we are about to discuss.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 他们提供的值使得两个对象从 Marionette 库中脱颖而出，并且可以通过将它们包含在您的脚本中或使用 Marionette 的混合版本来单独使用。一个是
    `Backbone.Wreqr.EventAggregator` 对象，另一个是 `Backbone.BabySitter` 对象，这是我们即将讨论的对象。
- en: This object helps us to keep track of views and to manage them. These views
    can be contained within another view or another object that needs to keep track
    of these views.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象帮助我们跟踪视图并管理它们。这些视图可以包含在另一个视图或另一个需要跟踪这些视图的对象中。
- en: The `BabySitter` object can be used to contain views instead of regions. The
    responsibility of `RegionManager` is to contain and perform actions on regions
    within your application. The `BabySitter` object has the same responsibility,
    but in this case, it helps us to manage related views.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`BabySitter` 对象可以用来包含视图而不是区域。`RegionManager` 的责任是在您的应用程序中包含和执行区域内的操作。`BabySitter`
    对象有相同的责任，但在这个情况下，它帮助我们管理相关的视图。'
- en: 'The following code is an example of an instantiation of a BabySitter object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个 BabySitter 对象实例化的示例：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can start adding and removing views to this container as it is a regular
    `Backbone.Collection` object; you can do this by using the add and remove functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以开始向这个容器添加和移除视图，因为它是一个常规的 `Backbone.Collection` 对象；您可以通过使用添加和移除函数来完成此操作。
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The container offers a lot of useful methods such as length, which will return
    the number of views that the container is keeping track of.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了许多有用的方法，例如长度，它将返回容器跟踪的视图数量。
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we have mentioned earlier, the container exposes several functions of the
    underscore collection functions, such as `each`, `map`, `find`, `select`, `filter`,
    `all`, `some`, and `toArray`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，容器公开了几个 underscore 集合函数的功能，例如 `each`、`map`、`find`、`select`、`filter`、`all`、`some`
    和 `toArray`。
- en: 'To demonstrate that we can call a method of each one of the views inside the
    container, we just need to write the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们可以在容器内部调用每个视图的方法，我们只需要编写以下代码：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The responsibility of the preceding function is to iterate all the views in
    the container and call a function inside this view,in this case, the `changeColor`
    function of each view.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面函数的责任是迭代容器中的所有视图，并在该视图中调用一个函数，在这种情况下，是每个视图的 `changeColor` 函数。
- en: We have created a JSFiddle that demonstrates the use of the `BabySitter` object.
    You can find it at [http://jsfiddle.net/rayweb_on/fxzAs/](http://jsfiddle.net/rayweb_on/fxzAs/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 JSFiddle 来演示 `BabySitter` 对象的使用。您可以在 [http://jsfiddle.net/rayweb_on/fxzAs/](http://jsfiddle.net/rayweb_on/fxzAs/)
    找到它。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[jsfiddle.net](http://jsfiddle.net) is a very useful website for sharing small
    snippets of code, facilitating collaboration between developers.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[jsfiddle.net](http://jsfiddle.net)是一个非常有用的网站，用于共享代码片段，促进开发者之间的协作。'
- en: Taking advantage of the Marionette.Renderer object
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Marionette.Renderer对象
- en: As we saw in [Chapter 3](ch03.html "Chapter 3. Marionette View Types and Their
    Use"), *Marionette View Types and Their Use*, Marionette does the great job of
    removing the repetitive code needed in order to render views. But behind the scenes,
    what Marionette does is it delegates this task to the `Renderer` object. Its responsibility
    is to load and compile the template into the `.template` function and to pass
    the data to be used in order to properly render the model of the view. This means
    that every view object in Marionette uses the `Renderer` object. This object can
    also help to render HTML into DOM by just passing a template with the data to
    be used for this purpose.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](ch03.html "第3章。Marionette视图类型及其用途")中看到的，“Marionette视图类型及其用途”，Marionette出色地完成了删除渲染视图所需重复代码的工作。但在幕后，Marionette所做的是将此任务委托给`Renderer`对象。其责任是加载和编译模板到`.template`函数，并传递用于正确渲染视图模型的数据。这意味着Marionette中的每个视图对象都使用`Renderer`对象。此对象还可以通过仅传递一个带有用于此目的的数据的模板来帮助将HTML渲染到DOM中。
- en: Let's say that for some reason we need to append HTML into our view, but we
    don't want to call the render of the view that we are working with. In such a
    case, we can use the `Marionette.Renderer` object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设由于某种原因我们需要将HTML附加到我们的视图中，但我们不想调用我们正在处理的视图的渲染。在这种情况下，我们可以使用`Marionette.Renderer`对象。
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding function, we declared a template that is in DOM, then we created
    an object literal with dummy data, and then we passed these two to the `Renderer`
    object, which returned an HTML, that we finally appended to the `$el` of our view.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们声明了一个在DOM中的模板，然后创建了一个包含虚拟数据的对象字面量，然后将这两个传递给`Renderer`对象，它返回一个HTML，我们最终将其附加到视图的`$el`上。
- en: To see this example working, you can go to the [http://jsfiddle.net/rayweb_on/BeMfz/](http://jsfiddle.net/rayweb_on/BeMfz/)
    JSFiddle link.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此示例的运行效果，您可以访问[http://jsfiddle.net/rayweb_on/BeMfz/](http://jsfiddle.net/rayweb_on/BeMfz/)
    JSFiddle链接。
- en: But perhaps a better use could be to render DOM elements that will serve as
    containers for the regions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许更好的用途是渲染将作为区域容器的DOM元素。
- en: If we need to render the subcategories, we need the DIVs `(<div id="rome"><div>`)
    to be available in order to attach the regions and then call `show` to render
    the views inside these containers (DIV elements).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要渲染子类别，我们需要确保DIVs（`<div id="rome"><div>`）可用，以便附加区域，然后调用`show`来渲染这些容器（DIV元素）内的视图。
- en: Improving the performance of the application with TemplateCache
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TemplateCache提高应用程序的性能
- en: In every application, performance matters. That's why having our templates available
    in the cache will definitely improve the speed of the rendering process in future
    calls.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个应用程序中，性能都很重要。这就是为什么我们的模板在缓存中可用将肯定提高未来调用中渲染过程的速度。
- en: 'Marionette has an object called `TemplateCache` that is used by the `Renderer`
    object. This means that all of our templates are stored in this `TemplateCache`
    object and to start making use of it, we just need to call the `get` method. Internally,
    this method will confirm whether it already has the template and then return it;
    alternatively, it will load the template from DOM and will return the template
    so that we can use it, but it will also keep a reference of it. Hence in the subsequent
    call, we will get the cached version of our template by using the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette有一个名为`TemplateCache`的对象，该对象由`Renderer`对象使用。这意味着所有模板都存储在这个`TemplateCache`对象中，要开始使用它，我们只需调用`get`方法。内部，此方法将确认是否已有模板，然后返回它；否则，它将从DOM中加载模板，并返回模板以便我们可以使用，同时也会保留其引用。因此，在后续调用中，我们将通过以下代码获取模板的缓存版本：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To remove one or more templates from our cache, we need to call the `clear`
    function as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的缓存中删除一个或多个模板，我们需要调用`clear`函数，如下所示：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we need to delete more than one template, we can pass a list of templates
    to be deleted or simply call the `clear()` function without parameters to delete
    all the cached templates as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要删除多个模板，我们可以传递要删除的模板列表，或者简单地调用不带参数的`clear()`函数来删除所有缓存的模板，如下所示：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, we can use the following code to do this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下代码来完成此操作：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By default, the Marionette `TemplateCache` works with underscore templates,
    but to override this, we need to provide our own definition of the `compileTemplate`
    function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Marionette的`TemplateCache`与underscore模板一起工作，但为了覆盖这一点，我们需要提供我们自己的`compileTemplate`函数定义。
- en: To be consistent, we will override this function to return handlebars templates.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，我们将覆盖这个函数以返回handlebars模板。
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Handlebars is a very popular template engine and is commonly used as an alternative
    to underscore templates. You can find out more about it on its website, [http://handlebarsjs.com/](http://handlebarsjs.com/).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 处理Handlebars是一个非常流行的模板引擎，通常用作underscore模板的替代品。你可以在其网站上了解更多信息，[http://handlebarsjs.com/](http://handlebarsjs.com/)。
- en: As we saw, making use of `TemplateCache` is very easy and the benefits that
    it provides are definitely its biggest selling point.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，利用`TemplateCache`非常简单，它提供的优势无疑是其最大的卖点。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about different objects that Marionette provides
    to manage views, such as the `Region` and `BabySitter` objects. This management
    is definitely needed, but it takes a lot of glue code to achieve it. So having
    it out of the way at the time of building an application is a very good reason
    to start using these objects.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Marionette提供的一些不同对象来管理视图，例如`Region`和`BabySitter`对象。这种管理确实是必要的，但实现它需要大量的粘合代码。因此，在构建应用程序时将其排除在外是一个很好的理由来开始使用这些对象。
- en: In the next chapter, we will learn how to modularize our applications into small
    modules of subapplications in order to keep different functionalities of our website
    separated from each other, but still working together.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将我们的应用程序模块化成小的子应用程序模块，以便将网站的不同功能隔离开来，但仍然可以协同工作。
