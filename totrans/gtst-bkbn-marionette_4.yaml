- en: Chapter 4. Managing Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in [Chapter 3](ch03.html "Chapter 3. Marionette View Types and
    Their Use"), *Marionette View Types and Their Use*, `Marionette.js` views provide
    us with a lot of functionality to render data with the benefit of having to write
    very little code in exchange. In this chapter, we are going to discover what a
    `Region` in Marionette is and what `RegionManager` and `BabySitter` objects are.
    All of them are intended to help us manage views in an easier way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also get to know a handy object while rendering templates in your application:
    the `Renderer` object. After that, we will have a short summary of what we have
    learned through the first four chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Marionette.Region`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Marionette.RegionManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Marionette.BabySitter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Marionette.Renderer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the application's performance with `Marionette.TemplateCache`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these are very helpful objects that will help us to manage our Marionette
    views with ease, keeping in mind performance and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Marionette.Region object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building an application, we need to separate the screen into small, logical
    pieces such as header, footer, navigation, and content area. These are common
    parts that are present in most applications. Usually your navigation options can
    change depending on the user. The header may also be different based on your user
    profile, and of course, your content area is going to be busy showing different
    views—views that need to be rendered to perform an action and closed in order
    to show a new view with perhaps some results or the next logical steps in your
    application. That's why we should think of the footer or content parts of your
    application as regions within your application, where we will be swapping different
    views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code exemplifies one of the ways to create a `Marionette.Region`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To define a region, we just need to specify an element in DOM that will serve
    as a container of the views on your logical section of the application. In this
    case, the `#footer` is a DIV element, but it can be any HTML element as long as
    appending a view inside of it generates a valid HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind a region is to use it as a container of views in your application
    one at a time. It will be in charge of calling the `render` function of the specified
    view when we call the method `.show` of the region. It will call the close method
    of the current view and remove it from the DOM when we call the method `.close`
    of the region.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code needed to use a region in order to render a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, the `show` method of the region
    will take the instance of the view to be rendered as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rendering the views and then swapping them for new ones seems trivial at the
    beginning. We can just call `close` and `render`, right? Then why do we need a
    region object to do it for us? This is because the region does these things for
    us and much more, without us having to worry about which view is the current view
    displayed inside of it. Think of it in this way: you have the content region and
    you will display a view inside of it. We can replace this view with a new one
    just by calling the `.show` method and the region will take care of the removal
    of the first view. So we don''t have to call its `close` method, as this is part
    of the functionality of the `show` method of the region. This means that if there
    is a view already being displayed in the region, the `close` method of the exiting
    view will be called by calling `show` and passing a new view, thereby ensuring
    there is proper removal of its `.el` event bindings.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's use a wizard as an example. We have four steps and on each step, we show
    a view where we will fill some data. On each one of these views, we have links
    that will guide us to the next step or to the previous step in case we want to
    modify the data. The links will modify the URL, and it will be the router's responsibility
    to call the proper step.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, the code that is inside the controller is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see the benefits of using a region to render
    views. If the user clicks on the second step and decides to go back, we don't
    need to check whether the instance of the `stepTwoView` method is in memory and
    close it in order to render the `stepOneView` method, as this will be handled
    by the region.
  prefs: []
  type: TYPE_NORMAL
- en: There will be occasions where it will be impossible to track which view is present
    in a region, and in most of those cases, we don't care. We just need to render
    a new view on this area without having to worry about whether the previous view
    is being removed in a proper way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to declare a region is by attaching it directly to a Marionette
    application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we used the `.addRegions` method of the application object that
    is expecting an object literal with the names of the regions and the DOM element
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these new regions, we just need to call them by the name given in the
    object literal, which is used for this configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 3](ch03.html "Chapter 3. Marionette View Types and Their Use"),
    *Marionette View Types and Their Use*, we defined a layout. The layout view of
    Marionette serves as a container of regions or as a container of containers. The
    layout will render a template with the skeleton of your HTML. Inside this skeleton,
    we will put the DIV element or elements that will serve as regions, and once this
    layout is rendered, we can use its region to display views.
  prefs: []
  type: TYPE_NORMAL
- en: 'So lets review the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the layout declaration, we defined a template and the regions object literal,
    giving names to the regions and matching those with the DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this `BookStoreApp`, we will create `mainRegion`. The responsibility of
    this region is to render the layout view of the application. The layout view will
    contain the initial HTML file and the logical regions of the application, regions
    that will show the proper views. The following code exemplifies the creation of
    the application object, the layout view, and the rendering of views inside the
    regions of the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the help of the layout and the regions, we can create a logical segmentation
    of the screen that will allow us to render views on each region. Using meaningful
    names for these regions will definitely help, as we just need to pass the right
    view to the region and stop worrying about the glue code needed for rendering
    and cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: 'A region will raise the following two events while rendering a view that will
    help us to perform an extra manipulation to the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"show"/onShow`: This event is called on the view instance when the view has
    been rendered and displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"show"/onShow`: This event is called on the region instance when the view
    has been rendered and displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, while closing a view, the following method will be raised that can
    be used to perform one of the final tasks such as notifying the user with a friendly
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"close"/onClose`: This method is called when the view has been closed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can subscribe to these events as usual with the `.on` method declaration
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code exemplifies how to subscribe to the `close` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the Marionette.RegionManager object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using regions helps to manage views in a very elegant way. But that may not
    be enough for some applications, which can have dozens of regions that need to
    be added and removed during the lifetime of the application. To accomplish this
    management, we can take advantage of the `RegionManager` object of Marionette,
    which will serve as a container for regions.
  prefs: []
  type: TYPE_NORMAL
- en: Having your regions in this container can help us to accomplish almost the same
    actions, which we could accomplish with a `Backbone.Collection` object, with the
    help of underscore methods such as `each`, `map`, `invoke`, `contains`, and `toArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following syntax can help us to declare `Marionette.RegionManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The following syntax demonstrates how to add a region to `regionManager`. The
    `addRegion` method takes two parameters. The first one will be the ID or alias
    of the region, and the second one will be the DOM element to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we want to add multiple regions, we need to use the `addRegions` method and
    pass an object literal to this method with names and IDs as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can make use of the `removeRegion` method to remove the region from `regionManager`
    and also to close the region, which will call `close` on the contained view, thereby
    removing this view from the application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove all the regions, we can use the `removeRegions` method as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can continue adding more regions to this container. But let's now create
    a `RegionManager` object for a category that will contain regions for subcategories;
    each region will show a `CollectionView` object with books of the same subcategory.
    So we display a `CollectionView` object inside a region with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that the user wants to view books of his favorite category and also
    wants to add more subcategories to the screen to be rendered. For instance, in
    the History category, we can have an option to view books from modern history,
    Rome, universal history, World War II, and many more subcategories.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And then just render the proper view on each region as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If at some point, the user switches to another category and no longer wants
    to see the History category, calling `removeRegions` will cascade to the view
    level, thereby removing all the views in a safe way for us.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Backbone.BabySitter object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the value that they provide, two objects made its way out of the Marionette
    library and can be used individually by including them in your scripts or using
    the blended version of Marionette. One is the `Backbone.Wreqr.EventAggregator`
    object and the other is the `Backbone.BabySitter` object, which is the one that
    we are about to discuss.
  prefs: []
  type: TYPE_NORMAL
- en: This object helps us to keep track of views and to manage them. These views
    can be contained within another view or another object that needs to keep track
    of these views.
  prefs: []
  type: TYPE_NORMAL
- en: The `BabySitter` object can be used to contain views instead of regions. The
    responsibility of `RegionManager` is to contain and perform actions on regions
    within your application. The `BabySitter` object has the same responsibility,
    but in this case, it helps us to manage related views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of an instantiation of a BabySitter object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can start adding and removing views to this container as it is a regular
    `Backbone.Collection` object; you can do this by using the add and remove functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The container offers a lot of useful methods such as length, which will return
    the number of views that the container is keeping track of.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we have mentioned earlier, the container exposes several functions of the
    underscore collection functions, such as `each`, `map`, `find`, `select`, `filter`,
    `all`, `some`, and `toArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate that we can call a method of each one of the views inside the
    container, we just need to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The responsibility of the preceding function is to iterate all the views in
    the container and call a function inside this view,in this case, the `changeColor`
    function of each view.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a JSFiddle that demonstrates the use of the `BabySitter` object.
    You can find it at [http://jsfiddle.net/rayweb_on/fxzAs/](http://jsfiddle.net/rayweb_on/fxzAs/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[jsfiddle.net](http://jsfiddle.net) is a very useful website for sharing small
    snippets of code, facilitating collaboration between developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of the Marionette.Renderer object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [Chapter 3](ch03.html "Chapter 3. Marionette View Types and Their
    Use"), *Marionette View Types and Their Use*, Marionette does the great job of
    removing the repetitive code needed in order to render views. But behind the scenes,
    what Marionette does is it delegates this task to the `Renderer` object. Its responsibility
    is to load and compile the template into the `.template` function and to pass
    the data to be used in order to properly render the model of the view. This means
    that every view object in Marionette uses the `Renderer` object. This object can
    also help to render HTML into DOM by just passing a template with the data to
    be used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that for some reason we need to append HTML into our view, but we
    don't want to call the render of the view that we are working with. In such a
    case, we can use the `Marionette.Renderer` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we declared a template that is in DOM, then we created
    an object literal with dummy data, and then we passed these two to the `Renderer`
    object, which returned an HTML, that we finally appended to the `$el` of our view.
  prefs: []
  type: TYPE_NORMAL
- en: To see this example working, you can go to the [http://jsfiddle.net/rayweb_on/BeMfz/](http://jsfiddle.net/rayweb_on/BeMfz/)
    JSFiddle link.
  prefs: []
  type: TYPE_NORMAL
- en: But perhaps a better use could be to render DOM elements that will serve as
    containers for the regions.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to render the subcategories, we need the DIVs `(<div id="rome"><div>`)
    to be available in order to attach the regions and then call `show` to render
    the views inside these containers (DIV elements).
  prefs: []
  type: TYPE_NORMAL
- en: Improving the performance of the application with TemplateCache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every application, performance matters. That's why having our templates available
    in the cache will definitely improve the speed of the rendering process in future
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Marionette has an object called `TemplateCache` that is used by the `Renderer`
    object. This means that all of our templates are stored in this `TemplateCache`
    object and to start making use of it, we just need to call the `get` method. Internally,
    this method will confirm whether it already has the template and then return it;
    alternatively, it will load the template from DOM and will return the template
    so that we can use it, but it will also keep a reference of it. Hence in the subsequent
    call, we will get the cached version of our template by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove one or more templates from our cache, we need to call the `clear`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to delete more than one template, we can pass a list of templates
    to be deleted or simply call the `clear()` function without parameters to delete
    all the cached templates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the following code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By default, the Marionette `TemplateCache` works with underscore templates,
    but to override this, we need to provide our own definition of the `compileTemplate`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: To be consistent, we will override this function to return handlebars templates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Handlebars is a very popular template engine and is commonly used as an alternative
    to underscore templates. You can find out more about it on its website, [http://handlebarsjs.com/](http://handlebarsjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, making use of `TemplateCache` is very easy and the benefits that
    it provides are definitely its biggest selling point.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about different objects that Marionette provides
    to manage views, such as the `Region` and `BabySitter` objects. This management
    is definitely needed, but it takes a lot of glue code to achieve it. So having
    it out of the way at the time of building an application is a very good reason
    to start using these objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to modularize our applications into small
    modules of subapplications in order to keep different functionalities of our website
    separated from each other, but still working together.
  prefs: []
  type: TYPE_NORMAL
