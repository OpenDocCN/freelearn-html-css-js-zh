- en: Chapter 8. Playing Around
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。玩玩
- en: Smartphones have been no strangers to fun little games that helped pass the
    time. From the seemingly eternally-existing Solitaire to Snake!, Tetris, or Pop-the-Bubble
    variants, we've found ways to pass the time with our mobile devices. Even if you
    nearly always write productive applications, sooner or later, the *bug* to write
    a game is likely to bite.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 智能手机并不陌生于那些帮助消磨时间的有趣小游戏。从看似永恒存在的纸牌游戏到蛇、俄罗斯方块或泡泡龙变体，我们找到了用我们的移动设备消磨时间的方法。即使你几乎总是编写生产性应用程序，迟早，编写游戏的“虫子”很可能会咬你。
- en: What do we build?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建什么？
- en: In this project, we're going to put together a game called *Cave Runner*. Okay,
    it won't win any prizes based on the originality of the game (or the title), nor
    will it win *Best Game of the Year*. But it's amusing, and has a lot of potential
    to expand in various ways, and so serves as a good base, especially for the quick
    and diverting category that many games try to fit into.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将组合一个名为 *Cave Runner* 的游戏。好吧，它不会因为游戏（或标题）的原创性而赢得任何奖项，也不会赢得 *年度最佳游戏*。但它很有趣，有很多扩展的潜力，因此是一个很好的基础，特别是对于许多游戏试图适应的快速娱乐类别。
- en: What does it do?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它能做什么？
- en: To accomplish this, we're going to be relying heavily upon the HTML5 Canvas,
    which is quite literally the only way we're going to achieve anything even approaching
    60 fps (the target for most games). Even so, only recent and powerful devices
    are going to meet this target, and so we also will need to sludge around in the
    mathematics around how to create a game that isn't reliant upon its frame rate.
    If the game's timing relied solely on the frame rate, 30 fps would feel as if
    we're sludging through mud, that is, the game would feel like it was progressing
    in slow motion. Instead, we have to act like we're running at 60 fps, even if
    we can't display that many frames, so that we avoid this effect.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将严重依赖HTML5 Canvas，这是我们实现接近60 fps（大多数游戏的目标）的唯一方式。即便如此，只有最近且功能强大的设备才能达到这个目标，因此我们还需要在如何创建不依赖于帧率的游戏方面进行数学上的研究。如果游戏的计时完全依赖于帧率，30
    fps会感觉像是在泥潭中挣扎，也就是说，游戏会感觉像是在慢动作中前进。相反，我们必须表现得像是在以60 fps的速度奔跑，即使我们无法显示那么多帧，这样我们就可以避免这种效果。
- en: 'While controlling a game character on a console, portable game machine, or
    PC is pretty obvious (keyboard, mouse, D-pad, Joystick, and so on), how does one
    control a game character on a mobile device which probably has none of those features?
    There are two answers: use the multi-touch screen, which can be used to simulate
    a Joystick or D-pad, or use the device''s built-in accelerometer. We''ll talk
    about using both in this task.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制控制台、便携式游戏机或PC上的游戏角色时，控制游戏角色在可能没有这些功能的移动设备上可能很明显（键盘、鼠标、D-pad、摇杆等），那么如何在移动设备上控制游戏角色呢？有两种答案：使用多触控屏幕，可以用来模拟摇杆或D-pad，或者使用设备的内置加速度计。我们将在本任务中讨论使用这两种方法。
- en: Which brings us to the last big thing; it's not so hard to implement, but it
    is absolutely critical to have in place—**persistent** **settings**. If we're
    going to provide two methods of control, we need a way to save which method the
    user prefers. While we have used the `File` API in previous projects to store
    persistent content, we're going to use `localStorage` this time. After all, we're
    only storing a simple flag, not a lot of user-generated content.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了最后一项重要的事情；实现起来并不难，但绝对有必要——**持久** **设置**。如果我们打算提供两种控制方法，我们需要一种方法来保存用户偏好的方法。虽然我们在以前的项目中使用了
    `File` API 来存储持久内容，但这次我们将使用 `localStorage`。毕竟，我们只存储一个简单的标志，而不是大量的用户生成内容。
- en: Why is it great?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它很棒？
- en: Hopefully, you'll have a bit of fun with the game as it stands now, but even
    as a simple game, it introduces you to the concepts you'll need to create complex
    games further down the road. We'll work on keeping the game going at the same
    speed, regardless of frame rate. We'll talk about persistent settings using `localStorage`.
    We'll also work out how to control the game using the touch screen and the accelerometer.
    All of these things combine to create a good game, and you should have a good
    base from which to build on for any future endeavors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能从目前这个游戏中获得一些乐趣，但即使作为一个简单的游戏，它也介绍了你将来创建复杂游戏所需的概念。我们将努力保持游戏以相同的速度进行，无论帧率如何。我们将讨论使用
    `localStorage` 的持久化设置。我们还将研究如何使用触摸屏和加速度计来控制游戏。所有这些因素结合起来，创造了一个好游戏，你应该有一个很好的基础，可以在此基础上进行任何未来的努力。
- en: How are we going to do it?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何做到这一点？
- en: 'We''re going to approach this much like we have the prior projects:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像以前的项目一样处理这个问题：
- en: Designing the game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计游戏
- en: Implementing the options view
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现选项视图
- en: Generating levels
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成水平
- en: Drawing to the canvas
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布上绘制
- en: Keeping up
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持进度
- en: Performing updates
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行更新
- en: Handling touch-based input
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理基于触摸的输入
- en: Handling the accelerometer
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理加速度计
- en: What do I need to get started?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要什么来开始？
- en: Go ahead and create your project, or use the project in the code package for
    this book as a start. You'll want to use the images in `www/images`. If you want
    some insight on how we designed the graphic assets, feel free to look in the `/resources`
    directory in the code package for this project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建你的项目，或者使用本书代码包中的项目作为起点。你将需要使用`www/images`中的图片。如果你想了解我们如何设计图形资产，请随意查看本项目代码包中的`/resources`目录。
- en: In general, we'll be talking more about the code that is already written than
    spelling the code out verbatim. As such, it would be a good idea to have the project
    downloaded so that you have the code as a reference. Go ahead and compile it for
    your device, too, and play with it, to get a better feel for what we'll be talking
    about.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，我们将更多地讨论已经编写的代码，而不是逐字拼写代码。因此，最好下载项目，以便你有一个代码作为参考。然后，为你的设备编译它，并与之互动，以更好地了解我们将要讨论的内容。
- en: Designing the game
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计游戏
- en: Where in previous projects we'd be developing the user interface and the interactions
    between the various widgets and views, we'll be designing how our game looks and
    acts instead. While similar, there's often a lot more that has to go into designing
    games (graphic assets, level design, character design, animation, and so on).
    Unfortunately, we can't go over everything given the length of the project, but
    we can give you a good start.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的项目中，我们会开发用户界面以及各种小部件和视图之间的交互，而我们将设计游戏的外观和动作。虽然相似，但设计游戏（图形资产、水平设计、角色设计、动画等等）需要投入更多的工作。不幸的是，鉴于项目的长度，我们无法涵盖所有内容，但我们可以给你一个好的开始。
- en: Getting on with it
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: The primary theme of the game may already be evident from the title, Cave Runner.
    These kinds of games have been around since the first computers, even if the graphical
    quality was a tad bit coarse. In short, we're going to develop a game that has
    a series of levels through which the player (who controls a ship) has to navigate
    safely in order to advance. Each level will be more difficult than the previous,
    and in our particular version, as long as the player can keep up, there's no end
    to the levels. In all practicality, there will be a point where the player can't
    navigate safely through a given level, and so the game always ends with a crash.
    Think of it as an endurance run where we already know the outcome – it's the journey
    that's the point.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的主要主题可能已经从标题“洞穴跑者”中显而易见。这类游戏自第一台计算机问世以来就存在了，即使图形质量有点粗糙。简而言之，我们将开发一个游戏，玩家（控制一艘飞船）必须安全地通过一系列水平才能前进。每个水平都比前一个更难，在我们的特定版本中，只要玩家能够跟上，水平就没有尽头。实际上，总会有一个点，玩家无法安全地通过给定的水平，因此游戏总是以崩溃结束。把它想象成一场我们已经知道结果的耐力赛跑——重点是旅程。
- en: The level consists of a cave-like structure with walls on both sides of the
    screen. These walls are irregular and random and together form a safe path for
    the ship. If the ship touches the edges, the game is over.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 水平由一个类似洞穴的结构组成，屏幕两侧都有墙壁。这些墙壁是不规则和随机的，共同形成一条安全的路径供飞船通过。如果飞船触碰到边缘，游戏就结束了。
- en: '![Getting on with it](img/9403_08_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_08_01.jpg)'
- en: To make things a little more difficult, there are obstacles that get in the
    ship's way. In the first levels, they don't appear very often, but as the levels
    get harder, the obstacles appear more often. The obstacle looks like a *wall*
    with an opening cut out, and the ship must pass within the opening in order to
    be safe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情变得稍微困难一些，有一些障碍物会阻碍飞船的行进。在最初的水平中，它们并不经常出现，但随着水平的难度增加，障碍物出现的频率也会增加。障碍物看起来像有一个开口的*墙*，飞船必须通过开口才能安全通过。
- en: Our levels will be randomly generated according to certain parameters in order
    to create an ever-changing landscape. Even though our levels are random, you could
    just easily create static levels and load them in wherever necessary, something
    which we suggest at the end of the project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的水平将根据某些参数随机生成，以创建一个不断变化的景观。尽管我们的水平是随机的，但你完全可以轻松创建静态水平并在需要的地方加载它们，这是我们建议在项目结束时做的事情。
- en: 'Our ship will be very simple: a triangle. Yes, one can get a lot more complicated
    with animation and such, but for the simple visual style of our game, it works
    well for our needs.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的飞船将非常简单：一个三角形。是的，可以通过动画等方式使其更加复杂，但考虑到我们游戏的简单视觉风格，它很好地满足了我们的需求。
- en: 'In order to move the ship, the player has two options: touch or swipe the screen
    in order to control the ship, or tilt the device. The ship will move according
    to the direction of the swipe or the tilt, that is, tilting or swiping left will
    move the ship left, and vice versa. Since we''re calling our character a *ship*,
    we''re intentionally introducing some fuzzy mechanics to the movement. In other
    words, the ship doesn''t respond instantly, nor does it stop instantly. Think
    of the ship as if it has thrusters on it.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动飞船，玩家有两个选择：触摸或滑动屏幕以控制飞船，或者倾斜设备。飞船将根据滑动或倾斜的方向移动，也就是说，向左倾斜或滑动将使飞船向左移动，反之亦然。由于我们称我们的角色为
    *飞船*，我们故意在移动中引入了一些模糊的机制。换句话说，飞船不会立即响应，也不会立即停止。想象一下，飞船上好像有推进器。
- en: Of course, we could have decided that the position of the ship was directly
    related to the position of the finger on the screen or the degree of the tilt,
    and for some games this would be appropriate. It is always important to recognize
    that you should tailor your control mechanism to your game and use what makes
    sense.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们本可以决定飞船的位置直接与屏幕上手指的位置或倾斜度相关，对于某些游戏来说这可能很合适。始终重要的是要认识到你应该根据你的游戏调整你的控制机制，并使用合理的方法。
- en: Our game itself will be contained within one view—the game view. Outside of
    the game will live the start view and an options view. The start view contains
    two buttons, namely, **Play** and **Options**. Tapping on **Play** will switch
    to the game view, while the **Options** button will switch to the options view.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏本身将包含在一个视图中——游戏视图。游戏之外将存在起始视图和选项视图。起始视图包含两个按钮，即 **玩** 和 **选项**。点击 **玩**
    将切换到游戏视图，而 **选项** 按钮将切换到选项视图。
- en: 'The options view gives two iconic representations of controlling movement:
    one for tilting the device and one for sliding a finger across the screen. Tapping
    either of these elements will select that method as the control method. An additional
    **Back** button lets the user get back to the start view.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 选项视图提供了两种控制移动的标志性表示：一种用于倾斜设备，另一种用于在屏幕上滑动手指。点击这两个元素中的任何一个将选择该方法作为控制方法。一个额外的 **返回**
    按钮让用户返回到起始视图。
- en: 'Inside the game view we have several items that need to be displayed. Of course,
    the level and the ship are required, but games often display other information
    as well. In our case, we''ll display the current level and the distance travelled
    through the level. Should we need to display a message (such as ***Crash!*** or
    **Level Complete**) we''ll show it in the middle of the screen along with two
    buttons: one to restart or continue, depending on the situation, and one to go
    back to the game view.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏视图中，我们有几个需要显示的项目。当然，级别和飞船是必需的，但游戏通常会显示其他信息。在我们的案例中，我们将显示当前级别和通过级别的距离。如果我们需要显示一条消息（例如
    ***碰撞！*** 或 **关卡完成**），我们将在屏幕中间显示它，并附带两个按钮：一个用于重新开始或继续，具体取决于情况，另一个用于返回游戏视图。
- en: And that's it, really; it's not a complicated game, and yet it can provide a
    base for more complicated endeavors in the future.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上就是这样，这并不是一个复杂的游戏，但它可以为未来更复杂的尝试提供一个基础。
- en: 'Let''s have a quick look at our graphical assets before we wrap this task up.
    Our splash screen looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这个任务之前，让我们快速看一下我们的图形资源。我们的启动画面看起来是这样的：
- en: '![Getting on with it](img/9403_08_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_08_02.jpg)'
- en: 'Our control icons will look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制图标将看起来像这样：
- en: '![Getting on with it](img/9403_08_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_08_03.jpg)'
- en: Our buttons that we use throughout the game won't require any graphical assets.
    We'll just use a rounded rectangle with a border and shadow, which we can accomplish
    with CSS.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整个游戏中使用的按钮不需要任何图形资源。我们只需使用带有边框和阴影的圆角矩形，这可以通过CSS实现。
- en: What did we do?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task we designed our game mechanics and assets. We've figured out the
    views we need as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们设计了游戏机制和资源。我们也确定了所需的视图。
- en: What else do I need to know?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: By no means is game design this simple. We can quickly go through this particular
    game partly because it is both simple and the mechanism is also well known. Even
    slightly more complex games will require a good deal of time to design, and it
    is best to do so before even writing a single line of code. Figure out your visual
    style, your sound style, the mechanics of the game, control mechanisms, levels,
    and animations. All of this will take time and lots of paper.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计绝不是这么简单。我们可以快速浏览这个特定的游戏，部分原因是因为它既简单，机制也众所周知。即使是稍微复杂一些的游戏，也需要花费大量的时间去设计，最好在写任何代码之前就完成。确定你的视觉风格、声音风格、游戏机制、控制机制、关卡和动画。所有这些都需要时间，并且需要大量的纸张。
- en: Implementing the options view
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现选项视图
- en: The start view is a simple view that we're not going to dwell on; feel free
    to look at the code in `www/views/startView.html`. In this task we'll focus on
    the options view located in `www/views/optionsView.html`. It's only moderately
    more complex than the start view, so some of the code is very similar.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开始视图是一个简单的视图，我们不会过多地讨论；您可以自由地查看`www/views/startView.html`中的代码。在这个任务中，我们将关注位于`www/views/optionsView.html`的选项视图。它比开始视图稍微复杂一些，所以一些代码非常相似。
- en: 'When done, we''ll have something that looks like the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将得到以下截图所示的内容：
- en: '![Implementing the options view](img/9403_08_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![实现选项视图](img/9403_08_05.jpg)'
- en: Getting on with it
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始实施
- en: 'Let''s take a look at the HTML for the view first:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看视图的HTML代码：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first portion is very simple; the actual content is in a template that
    we''ll process for localization:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分非常简单；实际内容在一个模板中，我们将对其进行本地化处理：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this part of the code, we've defined two methods of control. Touching either
    the `optionsView_tilt` or `optionsView_slide` icon will call the method to select
    that control method. The **Back** button will pop the view and return to the start
    view.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们定义了两种控制方法。触摸`optionsView_tilt`或`optionsView_slide`图标将调用选择该控制方法的方法。**返回**按钮将弹出视图并返回到开始视图。
- en: 'Note that we''ve not defined any styles here; the styling lives in `www/styles/style.css`.
    Here''s the styling we''re using for our view:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里没有定义任何样式；样式位于`www/styles/style.css`。以下是我们的视图使用的样式：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We're using a background image for our start and options view (but not the game
    view), which we define in the preceding code. This puts a nice image behind our
    controls, so we need to be careful where we place the buttons so as to not overwrite
    any critical text or graphical elements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为开始视图和选项视图（但不是游戏视图）使用背景图像，我们在前面的代码中定义了它。这将在我们的控件后面放置一个漂亮的图像，因此我们需要小心地放置按钮，以免覆盖任何关键文本或图形元素。
- en: 'Each button is styled as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮的样式如下：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This gives us a nice rounded button with bright colors as seen in the screenshot
    heading this section. It's also slightly rotated off-kilter, something games can
    usually get away with. Doing this in a productivity application wouldn't be all
    that good an idea.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个漂亮的圆角按钮，颜色鲜艳，如本节标题截图所示。它也稍微倾斜，这在游戏中通常是可以接受的。在生产力应用程序中这样做并不是一个好主意。
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For each button, we have to specify the location of the button, and if we want,
    we also override the rotation to have buttons in different rotations on the screen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个按钮，我们必须指定按钮的位置，如果我们想的话，我们还可以覆盖旋转，使屏幕上的按钮以不同的角度旋转。
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For our control selection, we first indicate where the icons will live, in
    the preceding code snippet, and then specify each one''s properties as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的控制选择，我们首先指示图标将位于哪里，在前面的代码片段中，然后指定每个图标的属性如下：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The font, in this case, gives us a handwritten feel. Note that we provide a
    fallback in case the device doesn't support this font, which is likely on Android
    devices. All recent iOS devices provide this font automatically.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字体给我们一种手写的感受。请注意，我们提供了一个回退方案，以防设备不支持这种字体，这在Android设备上很可能是这种情况。所有最新的iOS设备都会自动提供这种字体。
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When selected, we change the color of the text and make the selected item appear
    to be highlighted.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当选中时，我们改变文本的颜色，并使选中的项看起来被突出显示。
- en: 'Let''s take a look at the code; it''s really pretty simple:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码；它实际上非常简单：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As always, our `initializeView` method is used to set the view up and perform
    the necessary localization. It also calls `displayControlSetting`, which will
    highlight the appropriate control method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们的`initializeView`方法用于设置视图并执行必要的本地化。它还会调用`displayControlSetting`，这将突出显示适当的方法：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we're using `localStorage` here; it's almost so subtle you could
    miss it. First we check for the existence of our desired property (`controlSetting`).
    If it doesn't exist, we default to the *slide* control method. If it does exist,
    we'll use whichever value is stored in the property.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用的是`localStorage`；它几乎微妙到你可以错过它。首先，我们检查我们想要的属性（`controlSetting`）是否存在。如果不存在，我们将默认使用*滑动*控制方法。如果存在，我们将使用属性中存储的任何值。
- en: While `localStorage` isn't guaranteed to be 100 percent persistent (iOS has
    the option to delete it should the device's space get low), it's good enough for
    these kinds of settings.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`localStorage`并不保证100%持久（iOS设备空间不足时可以选择删除），但对于这类设置来说已经足够好了。
- en: 'When the user taps one of the control methods, we set `localStorage.controlSetting`
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击其中一个控制方法时，我们将`localStorage.controlSetting`设置为以下内容：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From this point on, the code is like we've used before, so we won't reprint
    it here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，代码就像我们之前使用的那样，所以这里不会重新打印它。
- en: What did we do?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we created our options view. We created the ability for the user
    to select either a *tilt* or *swipe* control method for their character, and we
    have used `localStorage` to both save and read back the user's preference.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们创建了我们的选项视图。我们为用户提供了选择他们的角色是使用*倾斜*还是*滑动*控制方式的能力，并且我们使用了`localStorage`来保存和读取用户的偏好。
- en: What else do I need to know?
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: What if the user sees this screen and decides that *swipe* is the control method
    they want? This means we never set a property within `localStorage`. This means
    that when the game starts, how will it know which control method to use?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户看到这个屏幕并决定*滑动*是他们想要的控制方法呢？这意味着我们从未在`localStorage`中设置任何属性。这意味着当游戏开始时，它将如何知道使用哪种控制方法？
- en: Simple, we'll do a check there too. If there's nothing in `localStorage`, we'll
    assume the user wants to use the swipe method. The key here is to be consistent;
    if the game decided to use the tilt method instead, but displayed the swipe as
    the default in our options view, the player would obviously be confused as to
    which option means what.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，我们也会在那里进行检查。如果`localStorage`中没有内容，我们将假设用户想要使用滑动方法。这里的关键是要保持一致性；如果游戏决定使用倾斜方法，但在我们的选项视图中显示滑动作为默认选项，玩家显然会困惑于哪个选项代表什么。
- en: Generating levels
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成关卡
- en: It's hard to imagine a game without at least one level, and that level needs
    to have some sort of content in it. In this task, we'll examine how to generate
    content for the levels in our game.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个没有至少一个关卡的游戏是很难的，而且这个关卡需要包含一些内容。在这个任务中，我们将探讨如何为游戏中的关卡生成内容。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Open the `gameView.html` file in `www/views`. We'll be using this file quite
    a bit, so it would be a good idea to have it open for reference.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`www/views`中打开`gameView.html`文件。我们将相当频繁地使用这个文件，所以最好将其打开以供参考。
- en: Getting on with it
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'There are a few ways one can generate a level. One can use random content,
    pseudo-random content, or static content. The first is pretty easy: just use random
    numbers for everything. Unfortunately, this doesn''t usually result in terribly
    nice levels, and there''s little guarantee of winnability or difficulty.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以生成关卡。可以使用随机内容、伪随机内容或静态内容。第一种很简单：只需为所有内容使用随机数字。不幸的是，这通常不会产生非常好的关卡，而且很难保证可赢性和难度。
- en: 'The third method is also pretty easy: use static content. This means that you''ve
    determined the entire level ahead of time, and stored it in a file. When the game
    requests the level, it can be read back. This means it is the same every time,
    which can be good (or bad), depending on the game, but it also means that you
    have a clear way to ensure both winnability and difficulty. For puzzle games,
    this is nearly always the method one uses.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法也很简单：使用静态内容。这意味着你在游戏开始之前就已经确定了整个关卡，并将其存储在文件中。当游戏请求关卡时，可以读取它。这意味着每次都是相同的，这可以是好事（或坏事），取决于游戏，但它也意味着你有明确的方式来确保可赢性和难度。对于解谜游戏，这种方法几乎总是首选。
- en: Our method is to be pseudo-random. We'll be using plenty of random numbers;
    we don't want perfectly straight cave walls or easily-guessed paths. But we also
    want to build in some level of increase in difficulty over time, as well as restrict
    the levels to a few parameters to help ensure (though not guarantee) winnability.
    It is possible to guarantee a level can be winnable with enough code, but we won't
    go quite that far in this game.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法是伪随机。我们将使用大量的随机数；我们不希望洞穴墙壁是完美的直线或容易被猜到的路径。但我们还希望随着时间的推移在难度上增加一些层次，以及将级别限制在几个参数内，以帮助确保（尽管不能保证）可玩性。通过足够的代码可以保证级别可玩，但在这个游戏中我们不会走那么远。
- en: 'Let''s go through the code used to generate a level using the following code
    snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码片段来查看用于生成级别的代码：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First we initialize our `points[]` array, and then four arrays within it. The
    first two arrays contain the left and right points that make up the cave wall.
    The last two contain the edges of any obstacle opening, or `-1` if there is no
    obstacle in place.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的`points[]`数组，然后在其中定义四个数组。前两个数组包含构成洞穴墙壁的左右点。最后两个数组包含任何障碍物开口的边缘，如果没有障碍物，则为`-1`。
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we start to define some variables that we'll be using to control our level.
    These two variables store the last points generated for the cave, but we need
    to have something to start from as well. `cWidth` is defined earlier in the file
    as being the width of the screen, so you can see how this would generate an open
    area in the middle of the screen at the beginning of our level. This is important,
    since we don't want to surprise the player with an immediate obstacle they can't
    avoid.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始定义一些我们将使用来控制我们级别的变量。这两个变量存储洞穴生成的最后几个点，但我们需要有一个起点。`cWidth`在文件中之前被定义为屏幕宽度，所以你可以看到这将在我们级别的开始时在屏幕中间生成一个开放区域。这很重要，因为我们不希望玩家遇到他们无法避免的即时障碍。
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`bias` controls the direction our cave walls will tend towards. They''ll still
    be randomly generated, but we introduce `bias` whenever the walls hit the edge
    of the screen so that there is always some movement.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`bias`控制着我们的洞穴墙壁倾向于哪个方向。它们仍然会被随机生成，但每当墙壁碰到屏幕边缘时，我们就引入`bias`，以确保始终有一些移动。'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`rndWidth` controls how much our cave wall can vary over a particular distance.
    In this case, it is controlled by the width of the screen and our current level.
    This means the cave gets harder to navigate as we progress through our levels.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`rndWidth`控制我们的洞穴墙壁在特定距离内可以变化的程度。在这种情况下，它由屏幕宽度和我们当前的级别控制。这意味着随着我们通过级别，洞穴的导航会变得更加困难。'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`channelWidth`, on the other hand, limits just how close the cave walls can
    get. It''s also based on the width of the screen and the level. You''ll notice
    that at some high level, the channel will be too small to permit passage of the
    ship. At this point, the game can be considered over, or one could also build
    in a way to prevent this value from ever getting too small.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`channelWidth`限制了洞穴墙壁可以靠近的程度。它也基于屏幕宽度和级别。你会在某些高级别时注意到通道太小，无法让飞船通过。在这种情况下，游戏可以被认为是结束了，或者也可以设计一种方法来防止这个值变得太小。
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An obstacle, or wall, is only generated every so often; we don't want an obstacle
    to appear at every point. So we generate some sort of chance that is also based
    on the level. Easier levels will have fewer obstacles, while harder levels will
    have several.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 障碍物或墙壁只会在某些时候生成；我们不希望障碍物在每个点都出现。因此，我们生成一种基于级别的机会。较简单的级别将有较少的障碍物，而较难的级别将有几个障碍物。
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`wallEvery` also factors in how often obstacles appear, but in a different
    way. It controls how many points must be between an obstacle before it can have
    a chance to be generated. In this case, we''ll start off at 29 points, but will
    steadily lower it as the levels increase. This means obstacles will not only appear
    more often, but closer together.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`wallEvery`也考虑了障碍物出现的频率，但以不同的方式。它控制着在障碍物有机会生成之前必须有多少点。在这种情况下，我们将从29个点开始，但随着级别的增加，我们将稳步降低它。这意味着障碍物不仅会出现的更频繁，而且会更靠近。'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we want to create a cave several hundred points long. The first level
    will start out with 366 points, and will only increase from there.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建一个长度为几百点的洞穴。第一个级别将从366个点开始，并且只会从那里增加。
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For each point, we determine the left and right side of the cave. We base this
    on the previous point, add in `bias` (increased with the level), and then add
    a random number within our allowed width, and we have a cavern wall that will
    vary by a random amount, but not by so much (at least in the first levels) that
    the level will be impossible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个点，我们确定洞穴的左右两侧。我们基于前一个点，加入`偏差`（随着关卡的增加而增加），然后在我们允许的宽度内添加一个随机数，我们就有了会随机变化但不会变化太大的洞穴墙壁（至少在最初关卡中是这样）。
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, without a few restrictions on the sides, it would be possible for
    the cave to wander off the screen, which does the player no good if they can't
    see it. So, we keep the cave on the screen. For the first two restrictions, we
    also affect the `bias`; this will tend to give the cave a zig-zag pattern overall.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有对两侧的一些限制，洞穴就有可能偏离屏幕，如果玩家看不到它，这对玩家没有任何好处。所以，我们保持洞穴在屏幕上。对于前两个限制，我们也影响了`偏差`；这通常会使得洞穴呈现出锯齿状的图案。
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, we add the points to the array and store them for future reference
    (the next iteration in the loop).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将点添加到数组中，并存储起来以供将来参考（循环的下一个迭代）。
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we determine if it is time to put an obstacle in the way. First, we only
    check every so often (`wallEvery`), and we also restrict any obstacle from appearing
    within the first 30 points of the cave.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确定是否需要放置障碍物。首先，我们只是偶尔检查一下（`wallEvery`），并且我们还限制任何障碍物出现在洞穴前30个点内。
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next we decide if a wall will appear at this point; this makes obstacles pretty
    rare early on, but they add up in later levels.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们决定在这个点是否会出现墙壁；这使障碍物在早期阶段相当罕见，但在后面的关卡中会逐渐增加。
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For the obstacle, we create an opening that is a smaller opening than the width
    of the cave; this means the wall juts out from the cave by some degree. We then
    determine some random value within the range of the cave's opening and that's
    where the opening will go.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于障碍物，我们创建一个比洞穴宽度小的开口；这意味着墙壁会从洞穴中突出一定角度。然后我们确定洞穴开口范围内的一个随机值，这就是开口将出现的位置。
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If there is no obstacle, we push `-1`; this way we can know if there's an obstacle
    (or not) at any given point.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有障碍物，我们推送`-1`；这样我们就可以知道在任意给定点是否有障碍物（或者没有）。
- en: And that's it! This will create a long, winding cave that's more treacherous
    the higher the level.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这将创建一个又长又弯的洞穴，随着关卡级别的提高，它将变得更加危险。
- en: What did we do?
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we generated the levels for our game, based on pseudo-random generation
    with some specific rules in place to create levels increasing in difficulty over
    the course of the game.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们根据伪随机生成和一些特定的规则为我们的游戏生成了关卡，这些规则使得关卡在游戏过程中难度逐渐增加。
- en: What else do I need to know?
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: This isn't the only way to generate a pseudo-random level, of course. There's
    all sorts of ways that are beyond the scope of this book, and there are things
    you can do to ensure that a level always stays winnable too. Level generation
    is a subject all on its own (with many, many smart people working in the field),
    so it won't take long to get your mind blown with some of the level-generation
    techniques out there. See [http://en.wikipedia.org/wiki/Procedural_generation](http://en.wikipedia.org/wiki/Procedural_generation)
    for examples of games that generate their levels procedurally as well as some
    links to articles describing various ways to generate levels procedurally. Keep
    in mind that this is highly specific to the kind of game you're developing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，生成伪随机关卡的方法不止一种。还有很多方法超出了这本书的范围，而且你还可以做一些事情来确保关卡始终可赢。关卡生成是一个独立的主题（在这个领域有许多许多聪明的人在工作），所以很快你就能被一些关卡生成技术所震撼。参见[http://en.wikipedia.org/wiki/Procedural_generation](http://en.wikipedia.org/wiki/Procedural_generation)了解一些游戏如何通过程序生成关卡以及一些描述如何通过程序生成关卡的链接。请记住，这非常具体地取决于你正在开发的游戏类型。
- en: Drawing to the canvas
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将绘图绘制到画布上
- en: Of course, it does no good to generate a level if we don't display it to the
    player. That's what we'll be doing in this task.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们不向玩家展示生成的关卡，那么生成关卡就没有任何意义。这正是我们将在这个任务中做的。
- en: Getting on with it
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续进行
- en: First, we set the canvas up, also taking care to deal with retina screens in
    the process.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置了画布，在这个过程中也注意到了处理视网膜屏幕。
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We store these as global variables, because it is important not to have to do
    DOM walking for every frame of content—that only slows us down—something that
    is a bad thing when we're trying to render a frame within 16 milliseconds (the
    maximum amount of time we can take if we're targeting 60 fps).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些存储为全局变量，因为对于每一帧的内容，我们都不需要做DOM遍历——这只会减慢我们的速度——当我们试图在16毫秒内渲染一帧时（如果我们目标是60
    fps，我们能够承受的最大时间），这是一件坏事。
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we set up a few properties and then clear the canvas. It is critical to
    clear the canvas for every frame; otherwise you'll end up leaving ghosts behind
    of the previous frame.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一些属性，然后清除画布。对于每一帧清除画布是至关重要的；否则，你会在后面留下前帧的幽灵。
- en: 'Then we draw both sides of the cave using a loop:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用循环绘制洞穴的两侧：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Based on which part of the cave we're drawing, we assign either the `0` or `1`
    index of `points[]` to another variable, `pts`. This lets us avoid having to double
    index the points array such as `points[i][x]` and use `pts[x]` instead. We also
    define the left (or right) side of the wall that is off screen; this comes in
    handy for drawing the cave, since we need to fill the cave walls to make them
    solid. This means we are essentially drawing a big rectangle with one portion
    of it very rough; the rough side being the cave wall.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们正在绘制的洞穴部分，我们将`points[]`的`0`或`1`索引分配给另一个变量`pts`。这让我们避免了需要双重索引点数组，如`points[i][x]`，而是使用`pts[x]`。我们还定义了屏幕外的墙壁的左侧（或右侧）；这对于绘制洞穴很有用，因为我们需要填充洞穴墙壁以使其成为实心。这意味着我们实际上是在绘制一个大矩形，其中一部分非常粗糙；粗糙的一侧是洞穴墙壁。
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We begin the path and then move to the leftmost, topmost portion of the canvas;
    in fact, quite a way off of it. This ensures the player never sees the edge of
    the big rectangle we're drawing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始路径，然后移动到画布的最左上角；实际上，离它相当远。这确保玩家永远不会看到我们正在绘制的矩形大框的边缘。
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, we loop through each point in the array, but only over the ones necessary.
    If the player is halfway through the level, there's no point in drawing the previous
    points, nor is there any point in drawing parts of the cave that are beyond the
    screen's height.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历数组中的每个点，但只遍历必要的点。如果玩家已经完成了关卡的一半，就没有必要绘制前面的点，也没有必要绘制屏幕高度之外的洞穴部分。
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In order to keep the motion of the cave smooth, we multiply the current piece
    by the piece width and subtract our current position in the level. Technically,
    this would result in a jumpy view at the first and last drawn index, but we're
    drawing a couple of points beyond both sides, so any jumpiness is kept off screen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持洞穴运动的平滑，我们将当前块乘以块宽度，并从关卡中的当前位置减去。技术上，这会在第一个和最后一个绘制的索引处产生跳跃视图，但我们在两边都绘制了一些点，所以任何跳跃都会保持在屏幕之外。
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we draw a line to the given point. If we're working on the right side,
    the point is to the left of the screen's right edge, which is the right side of
    the cave.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们画一条线到给定的点。如果我们正在处理右侧，那么这个点位于屏幕右侧边缘的左侧，也就是洞穴的右侧。
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we have an obstacle to display, we also draw a line to the point and then
    a vertical line one `pieceWidth` high. This will cause the obstacle to appear
    like a wall with an opening in it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有障碍物要显示，我们也会画一条线到那个点，然后画一条`pieceWidth`高的垂直线。这将使障碍物看起来像有一个开口的墙壁。
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, we draw a line off screen again, and then proceed to fill and stroke
    the path. The player will only see the rough edges of the cave wall.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次在屏幕外画一条线，然后继续填充和描边路径。玩家只会看到洞穴墙壁的粗糙边缘。
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After we draw the cave walls, we need to draw the ship. In this case, we draw
    a simple triangle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制洞穴墙壁之后，我们需要绘制飞船。在这种情况下，我们绘制一个简单的三角形。
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Generally most games need to display some text (such as a score), and so we
    do something similar too. We show the current level and the distance travelled
    through the level.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数游戏需要显示一些文本（例如得分），所以我们也做了类似的事情。我们显示当前关卡和通过关卡的距离。
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, if the user's control method is swiping, we display a translucent circle
    where the user is touching (assuming it is at the bottom of the screen) so that
    the user knows that the touch has been registered.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果用户的控制方法是滑动，我们会在用户触摸的地方显示一个半透明的圆圈（假设它在屏幕底部），这样用户就知道触摸已经被记录了。
- en: Keep in mind that when drawing a frame, we need to be quick, and thankfully
    the operations that we just saw depend on the hardware; we can achieve a frame
    within a few milliseconds. If we stay under 17 milliseconds, we can achieve nearly
    60 fps, though on older hardware, this is more like 20-30 milliseconds. So we
    need to do something else, which we'll cover next, that is, drop frames so that
    the game doesn't feel too sluggish.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在绘制帧时，我们需要快速，幸运的是，我们刚才看到的操作依赖于硬件；我们可以在几毫秒内完成一帧。如果我们保持在17毫秒以下，我们几乎可以达到60
    fps，尽管在较旧的硬件上，这可能是20-30毫秒。所以我们需要做其他事情，我们将在下一节中讨论，那就是丢弃帧，以便游戏不会感觉太迟缓。
- en: What did we do?
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we drew the level on the canvas, displayed the ship, and put various
    text on the canvas as well. We also kept it quick, something we could only do
    by using the `canvas` tag.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们在画布上绘制了关卡，显示了飞船，并在画布上放置了各种文本。我们还保持了快速，这是通过使用`canvas`标签实现的。
- en: What else do I need to know?
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: 'Of course, the preceding code only draws one frame; we need to call it multiple
    times in order to achieve fluid scrolling. There are two ways to do this: we can
    use `setTimeout` or use `requestAnimationFrame`. The latter is preferred, as it
    has better resolution than `setTimeout`, but it isn''t yet supported in all mobile
    browsers. For our purposes, we use `setTimeout`. It calls in `doUpdate`, which
    we''ll go over later, rather than `doAnim`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的代码只绘制了一帧；我们需要多次调用它才能实现流畅的滚动。有两种方法可以实现这一点：我们可以使用`setTimeout`或者使用`requestAnimationFrame`。后者更受欢迎，因为它比`setTimeout`具有更好的分辨率，但还不是所有移动浏览器都支持。就我们的目的而言，我们使用`setTimeout`。它在`doUpdate`中调用，我们稍后会讨论，而不是`doAnim`。
- en: Keeping up
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持同步
- en: Even if we can't hit 60 fps, we need to act like we are hitting 60 fps anyway.
    If we don't, any slowdowns will cause the game to feel as if it was in slow-mo.
    Instead, we need to *drop frames* and move things along as if we were getting
    60 fps. The display will not be as smooth, but the gameplay won't get that slow-mo
    feeling until we drop down to a really low frame rate.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不能达到60 fps，我们也需要表现得像是达到了60 fps。如果我们不这样做，任何减速都会使游戏感觉像是在慢动作中。相反，我们需要*丢弃帧*，并像达到60
    fps一样继续前进。显示可能不会那么平滑，但直到帧率真的降得很低，游戏体验才不会变得那么慢。
- en: Getting on with it
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'If you were paying close attention to our code in the last task, you''ll notice
    that we skipped a few lines. These were the lines crucial to keeping the game
    progressing as if it were hitting 60 fps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在上一个任务中仔细观察我们的代码，你会注意到我们跳过了一些行。这些行对于使游戏以60 fps的速度进行至关重要：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: All we're doing is measuring the time between frames and then applying some
    math to it. We then pass this in to `doUpdate`, which we'll discuss later. This
    number equates to the number of frames that should have passed in a given period
    of time. If we're at 60 fps, we'll always end up with this number being 1; but
    if we're at 30 fps, the number will be 2; and at 15 fps it will be 4, and so on.
    Since the number can be fractional, we can be very fine-grained when updating
    our game.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的一切只是测量帧之间的时间，然后对它应用一些数学运算。然后我们将其传递给`doUpdate`，我们稍后会讨论。这个数字等同于在给定时间段内应该通过的帧数。如果我们是60
    fps，我们总是会得到这个数字为1；但如果我们是30 fps，这个数字将是2；在15 fps时将是4，以此类推。由于这个数字可以是分数，我们可以在更新游戏时非常细致。
- en: What did we do?
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: So, that was short, but it's not a terribly complicated concept. But it is very
    important; without it, if the device slowed down for any reason, the game would
    slow down too, making it feel as if it was in slow-motion. Instead, we'll drop
    the frames in order to keep the speed up. It won't be as smooth, but gameplay
    should always trump getting every frame in.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这很简单，但并不是一个特别复杂的概念。但它非常重要；如果没有它，如果设备因为任何原因变慢，游戏也会变慢，给人一种慢动作的感觉。相反，我们将丢弃帧以保持速度。它可能不会那么平滑，但游戏体验应该始终优于每帧都显示。
- en: Performing updates
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行更新
- en: Of course, drawing the same frame over and over won't do any good. We need to
    update the game too. This includes responding to user input, checking for collisions,
    and moving us along the cave.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，反复绘制相同的帧是没有用的。我们还需要更新游戏。这包括响应用户输入、检查碰撞以及沿着洞穴移动。
- en: Getting on with it
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'We''ll be doing all our updating in… guess what! `doUpdate`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在...猜猜看！`doUpdate`中进行所有更新：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you recall from the last task, `f` is the incoming frame multiplier. We want
    this to be 1, but it might be 2 if we're getting 30 fps, or 4 if we're getting
    15\. We'll use this at various points to multiply any updates so that everything
    moves as if we were getting 60 fps, even when we aren't.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得上一个任务，`f`是输入帧乘数。我们希望它是1，但如果我们的帧率是30，它可能是2，如果是15，它可能是4。我们将在多个地方使用这个值来乘以任何更新，以便让一切看起来像是在60帧下运行，即使我们实际上不是。
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There are the various methods of doing collision detection. We could determine
    it mathematically, but that gets more than a bit painful. Instead, we'll use the
    canvas' own data and do pixel-based collision detection instead.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种进行碰撞检测的方法。我们可以通过数学方法来确定，但这会变得相当痛苦。相反，我们将使用画布自己的数据，并执行基于像素的碰撞检测。
- en: The preceding line requests very little data from the canvas. In fact, we're
    only checking the center point of the ship for a collision. Part of this is so
    that we can be lenient on the user, part of it is laziness, but the other part
    is that pixel-based collision detection using the canvas is horribly slow. In
    fact, just checking for one pixel cuts our fps nearly in half.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行从画布请求的数据非常少。实际上，我们只是在检查飞船的中心点是否有碰撞。这样做的一部分原因是为了对用户宽容一些，另一部分原因是懒惰，但还有一部分原因是基于画布的像素碰撞检测非常慢。实际上，仅仅检查一个像素就能将我们的帧率几乎减半。
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the pixel data in the data returned from the canvas is not zero (black),
    then we know we've impacted on something; what we've hit doesn't matter. We mark
    the game as over, and tell the user about it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从画布返回的数据中的像素数据不是零（黑色），那么我们知道我们已经撞击了某个东西；我们撞击的物体不重要。我们标记游戏结束，并通知用户。
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Sometimes `f` comes in as `0` or `Infinity`. This is most often at the start
    of a game, when we have to pass in a time difference, but there's not really been
    any. In this case, the division in `doAnim` will return `infinity`. We don't want
    to do anything in either case, so we make sure that we only operate if `f` is
    a reasonable value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时`f`会是`0`或`Infinity`。这通常发生在游戏开始时，我们必须传递一个时间差，但实际上并没有。在这种情况下，`doAnim`中的除法将返回`infinity`。我们不想在两种情况下做任何事情，所以我们确保只有在`f`是合理值时才进行操作。
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`buttonDown` reflects the user''s input if they are using touch controls. If
    they are sliding left, `buttonDown` will be negative. If they are going to the
    right, `buttonDown` will be positive. If they aren''t doing anything, it will
    be zero. If they are using tilt controls, we''ll calculate this value differently,
    but we''ll show that in the next section.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`buttonDown`反映了用户使用触摸控制时的输入。如果他们向左滑动，`buttonDown`将是负数。如果他们向右移动，`buttonDown`将是正数。如果他们什么都没做，它将是零。如果他们使用倾斜控制，我们将以不同的方式计算这个值，但将在下一节中展示。'
- en: If we're non-zero, we build up some acceleration, as if a thruster was on the
    ship. Since thrusters can't react instantly, the ship takes a little bit to react.
    This has the effect of making the game a little harder; one has to take into account
    the reaction time of the ship.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们非零，我们会积累一些加速度，就像飞船上有推进器一样。由于推进器不能立即反应，飞船需要一点时间来反应。这会使游戏变得更难；玩家必须考虑到飞船的反应时间。
- en: If we're zero, we reduce the acceleration, as if the ship was coasting to a
    stop. Once we reach a certain threshold, we stop the ship entirely, but until
    that point, there is some movement. Again, this adds some difficulty, as it must
    be considered when moving the ship.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为零，我们会减少加速度，就像飞船在减速一样。一旦我们达到某个阈值，我们就完全停止飞船，但在那之前，仍然有一些移动。再次强调，这增加了难度，因为移动飞船时必须考虑这一点。
- en: One important variable in the preceding code snippet is `deviceFactor`. This
    is subjective; when the ship's movement felt right on an Android device, it felt
    too slow on an iOS device, and so this variable compensates a bit for that difference.
    Never be afraid to tweak the movement mechanics on different devices so that it
    feels the same, even if it isn't technically the same.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，一个重要的变量是`deviceFactor`。这是主观的；当飞船在Android设备上移动感觉合适时，在iOS设备上感觉太慢，因此这个变量对此差异进行了一些补偿。永远不要害怕在不同的设备上调整移动机制，以便感觉相同，即使技术上并不相同。
- en: Note that we multiply the acceleration by `f`; this keeps the ship's movement
    working as if it were happening in a game with 60 fps.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过`f`乘以加速度；这样可以使飞船的运动看起来就像是在一个每秒60帧的游戏中发生。
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, we calculate the vertical distance through the cave, which is done by
    adding a number to `currentTop`. We adjust it slowly based on the current level
    as well, so higher levels will get faster and faster. Again, we multiply by `f`
    to keep things feeling smooth.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算通过洞穴的垂直距离，这是通过向`currentTop`添加一个数字来完成的。我们还根据当前级别缓慢调整它，因此级别越高，速度越快。再次，我们乘以`f`以保持事物感觉平滑。
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the player has managed to navigate the entire level, we need to stop the
    game and tell the user that they made it. When they continue, they'll pick up
    at the next higher level.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家设法完成了整个关卡，我们需要停止游戏并告诉用户他们成功了。当他们继续时，他们将开始下一个更高级别的游戏。
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here's our `setTimeout` that keeps everything going. Note that we do this unless
    the game is over or the level is over. If one wanted to add a pause feature, one
    would also avoid setting a timer at this point.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`setTimeout`，它使一切继续进行。注意，除非游戏结束或关卡结束，否则我们会这样做。如果有人想添加暂停功能，也会避免在这个时候设置定时器。
- en: The `17` here is intended to get us as close to 60 fps as possible. It doesn't
    work out to that in reality, as browsers don't have good resolution, so the next
    frame could arrive in 12 milliseconds or in 30\. WebKit, thankfully, has something
    on the order of 4 milliseconds resolution, so it isn't likely to be far off of
    `17`, and so we can get up to 56 fps, assuming a modern device.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`17`是为了尽可能接近60 fps。在现实中，这并不总是能达到，因为浏览器的分辨率并不好，所以下一帧可能需要12毫秒或30毫秒。幸运的是，WebKit大约有4毫秒的分辨率，所以它不太可能偏离`17`太多，因此我们可以达到56
    fps，假设设备是现代的。
- en: What did we do?
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we handled the updating of the ship's position, the position in
    the cave, and whether or not we crashed, or completed the level.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们处理了船只位置的更新，洞穴中的位置，以及我们是否发生碰撞或完成关卡。
- en: What else do I need to know?
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: Yeah, pixel-based collision detection is a pretty lazy way out. In nearly every
    circumstance, math-based collision detection is the better (and faster) way to
    do it. There's lots of good stuff out there about how to do good collision detection,
    and it falls out of the scope of this project. You might start with [http://en.wikipedia.org/wiki/Collision_detection](http://en.wikipedia.org/wiki/Collision_detection)
    for more information.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，基于像素的碰撞检测是一种相当懒惰的方法。在几乎所有情况下，基于数学的碰撞检测都是更好的（并且更快的）方法。关于如何进行良好的碰撞检测有很多好的资料，但这超出了这个项目的范围。你可以从[http://en.wikipedia.org/wiki/Collision_detection](http://en.wikipedia.org/wiki/Collision_detection)开始了解更多信息。
- en: It wouldn't be quite so bad in our game if it wasn't for the fact that even
    requesting a single pixel from the canvas data drops our frame rate by nearly
    half. I suspect this has to do with having to transfer the data off of the GPU
    and back to the CPU for processing, but that's just a guess. Even so, it's a bit
    painful, and if I'd had more caffeine when writing the collision detection routines,
    I'd have gone the math route.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是因为请求画布数据中的一个像素几乎会减半我们的帧率，我们的游戏不会这么糟糕。我怀疑这与必须将数据从GPU传输到CPU进行处理的操作有关，但这只是猜测。即使如此，这也有些痛苦，如果我在编写碰撞检测例程时喝更多的咖啡，我可能会选择数学方法。
- en: Handling touch-based input
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理基于触摸的输入
- en: 'Since we don''t have a physical keyboard or joystick or D-pad, we have to emulate
    one on the screen. We could do this with two buttons on the screen for our game:
    one to go left, and one to go right. In fact, the game has it built in, just hidden.
    Another way is to allow for the differences in how a swipe might occur: a slow
    movement when our ship is not in danger, or a sudden movement when we need to
    avoid an obstacle in a hurry. Another method would be to simply link up the touch
    position on the screen to the ship; essentially our finger would have to trace
    the path through the cave. For smaller devices this might be fine, but for larger
    devices, it is better to go with some other method.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有物理键盘、摇杆或D-pad，我们不得不在屏幕上模拟一个。我们可以用屏幕上的两个按钮来为我们的游戏做这件事：一个向左移动，一个向右移动。事实上，游戏已经内置了这个功能，只是隐藏了。另一种方法是允许滑动可能发生的差异：当我们的船不在危险中时，进行缓慢移动；当我们需要紧急避开障碍物时，进行突然移动。另一种方法是将屏幕上的触摸位置与船只连接起来；本质上，我们的手指必须沿着洞穴的路径移动。对于较小的设备，这可能是可以的，但对于较大的设备，最好采用其他方法。
- en: Getting on with it
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续进行
- en: In our game, our touch input can handle swipes (where the finger isn't always
    on the screen) to move the ship in short bursts, or it can handle long drags where
    the finger is always on the screen and slight movements generate movement.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们的触摸输入可以处理滑动（手指不总是在屏幕上）来使飞船进行短时间的移动，或者它可以处理长拖动，手指始终在屏幕上，轻微的移动就会产生移动。
- en: 'To put it simply: if we move left, the ship should move left, and vice versa.
    However, if we need to get out of an obstacle''s way in a hurry, we shouldn''t
    have to move a long distance. We should be able to move a short distance in a
    quick burst, and so we also measure the distance between movements so we can tune
    the ship''s movement to how fast our finger is moving. If the finger is moving
    slowly, the ship moves slowly. If it moves quickly, the ship moves really quickly.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说：如果我们向左移动，飞船应该向左移动，反之亦然。然而，如果我们需要紧急避开障碍物，我们不需要移动很长的距离。我们应该能够快速移动一小段距离，因此我们也测量移动之间的距离，以便我们可以调整飞船的移动速度以匹配手指的移动速度。如果手指移动缓慢，飞船移动缓慢。如果手指移动得快，飞船就移动得非常快。
- en: None of this is hard; in fact, the hardest part isn't making it work, it's making
    it work well. It's hard to make a control method feel totally natural, and I won't
    claim to have mastered it here. It takes lots of testing to get a control mechanism
    just right.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都不难；事实上，最难的部分不是让它工作，而是让它工作得很好。很难让控制方法感觉完全自然，我不会在这里声称我已经掌握了它。这需要大量的测试才能得到一个恰到好处的控制机制。
- en: 'Let''s look at our code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的代码：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Before the game starts, we check the control method the user has selected –
    remember the options view. If the control method is `slide`, we''ll attach events
    to an overlay `DIV`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始之前，我们检查用户选择的控制方法——记得选项视图。如果控制方法是`slide`，我们将事件附加到覆盖`DIV`上：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This overlay literally covers the entire canvas. You may wonder why we have
    to use an overlay—it turns out that the canvas itself isn't always so hot at handling
    touch events!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个覆盖层实际上覆盖了整个画布。您可能会想知道为什么我们必须使用覆盖层——结果是画布本身并不总是擅长处理触摸事件！
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When a finger touches the screen, we record the initial touch, and tell the
    game that a finger is touching the screen. If you remember `doUpdate`, this last
    part tells the game to draw a translucent circle at the x position of the touch
    to give the user feedback.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当手指触摸屏幕时，我们记录初始触摸，并告诉游戏有手指触摸屏幕。如果您还记得`doUpdate`，这最后一部分告诉游戏在触摸的x位置绘制一个半透明的圆圈，以给用户反馈。
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If a movement is received, we need to calculate the distance between the last
    x position and the new x position. We then give `buttonDown` a negative or positive
    value based on the direction of the movement. We also divide it if the movement
    was slow; if it was a fast movement (over five pixels), we'd have values of `-1`
    for left and `+1` for right, but a slow movement might return `-0.2` and `+0.2`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到移动，我们需要计算最后x位置和新的x位置之间的距离。然后根据移动的方向给`buttonDown`赋予负值或正值。如果移动缓慢，我们还会将其除以；如果是一个快速的移动（超过五个像素），我们会有`-1`的左值和`+1`的右值，但缓慢的移动可能返回`-0.2`和`+0.2`。
- en: If the finger hasn't moved by much (it needs to have moved by more than one
    pixel to register movement to the ship), then we indicate that `buttonDown` is
    `0`, so that the ship will coast to a stop. We also set up a timer to fire in
    a few short ms to turn `buttonDown` to zero as well. This is because we won't
    receive a `touchMove` event if the finger stays absolutely still, so we need a
    way to catch this. If a movement is received before the timer expires, we cancel
    the timer so that the value never becomes zero as long as there is adequate movement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果手指移动的距离不大（需要移动超过一个像素才能将移动注册到飞船上），那么我们将`buttonDown`设置为`0`，这样飞船就会滑行到停止。我们还设置了一个计时器，在几毫秒后触发，将`buttonDown`设置为零。这是因为如果手指完全静止不动，我们不会收到`touchMove`事件，所以我们需要一种方法来捕捉这种情况。如果在计时器到期之前收到移动，我们将取消计时器，这样只要存在足够的移动，值就不会变成零。
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When the finger is lifted, we will instantly allow the ship to coast to a stop,
    and stop displaying the translucent circle.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当手指抬起时，我们将立即允许飞船滑行到停止，并停止显示半透明的圆圈。
- en: This isn't the only way to do movement, and I urge you to experiment with different
    ways of processing touch-based input.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是处理移动的唯一方法，我强烈建议您尝试不同的处理基于触摸输入的方法。
- en: What did we do?
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we dealt with touch-based input in order to allow the user to
    move our game's ship.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们处理了基于触摸的输入，以便允许用户移动我们游戏中的飞船。
- en: Handling the accelerometer
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理加速度计
- en: In order to respond to the tilt of the device, we need to use the device's accelerometer.
    These aren't the easiest things to deal with, and our implementation is a bit
    naïve. Unfortunately, it doesn't take long until you start getting into the math
    that's more than a bit complicated, and so lies outside the scope of this project.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应设备的倾斜，我们需要使用设备的加速度计。这些并不是最容易处理的事情，我们的实现有点天真。不幸的是，不久你就会开始接触到相当复杂的数学，而这超出了这个项目的范围。
- en: Getting on with it
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续进行
- en: Accelerometer-based input is hard – really hard. So hard, in fact, that the
    game doesn't have a particularly good implementation of it. You are encouraged
    to experiment with a lot of devices and algorithms to come up with a good control
    scheme.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 基于加速度计的输入很困难——真的很困难。实际上，游戏对此并没有一个特别好的实现。你被鼓励尝试很多设备和算法，以找到一种好的控制方案。
- en: 'To turn on the accelerometer check, we first have to set up a watch for it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用加速度计检查，我们首先必须为它设置一个监视器：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This sets up a 40 milliseconds watch–not really quite as fast as I'd like, but
    workable. Every 40 milliseconds, the `updateAccelerometer` method will be called.
    If an error occurs, then `accelerometerError` will be called.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了40毫秒的监视器——并不完全像我期望的那样快，但可以工作。每40毫秒，`updateAccelerometer` 方法将被调用。如果发生错误，则调用
    `accelerometerError`。
- en: 'Watching the accelerometer takes some effort, so when done with it, it is always
    a good idea to clear it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 监视加速度计需要一些努力，所以当完成它时，总是清除它是一个好主意：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'So what do we get with the accelerometer? We get an object containing four
    values: a timestamp, an x value, a y value, and a z value. These values indicate
    the acceleration in a given direction. If the device is lying flat on a table,
    the x and y values will be zero, while the z value will be equal to the force
    of gravity. Generally we can assume that the x value corresponds to left/right
    tilt (assuming the device is upright), which is all we need for our game.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，加速度计能给我们带来什么呢？我们得到一个包含四个值的对象：一个时间戳，一个x值，一个y值和一个z值。这些值表示给定方向上的加速度。如果设备平放在桌子上，x和y值将是零，而z值将等于重力。一般来说，我们可以假设x值对应于左右倾斜（假设设备是直立的），这是我们游戏所需要的。
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When we receive an update, we apply a weighted average of the new input and
    the previous input, giving more weight to the previous input. It turns out that
    accelerometer-based input is really, really noisy, and so we only give the new
    input small importance. This has the side-effect, unfortunately, of making movement
    feel a little sluggish. The fractional values make a big difference in how well
    the ship responds, but at the trade-off of a ship that feels jittery. Feel free
    to experiment with these numbers, but they need to add up to one.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到更新时，我们将新的输入和之前的输入应用加权平均值，给之前的输入更多的权重。结果证明，基于加速度计的输入真的很嘈杂，所以我们只给新的输入很小的权重。不幸的是，这有一个副作用，就是让移动感觉有点迟缓。分数值在船的响应能力上有很大的影响，但以船感觉抖动为代价。请随意尝试这些数字，但它们需要加起来等于一。
- en: 'Note the `amCalibrated` variable; you could also compare the data to a calibrated
    value instead. The calibrated value is often obtained just before the level begins,
    when `amCalibrated` would be set to `false`. The next accelerometer update would
    calibrate the device:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `amCalibrated` 变量；你也可以将数据与校准值进行比较。校准值通常在关卡开始前不久获得，当时 `amCalibrated` 会被设置为
    `false`。下一个加速度计更新将校准设备：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A better way to calibrate the accelerometer would be to take a series of inputs
    and average them out. For that matter, that is the same way to smooth out the
    accelerometer itself; but those algorithms are beyond the scope of this book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 校准加速度计的一个更好的方法是从一系列输入中取平均值。就这个话题而言，这也是平滑加速度计本身的方法；但那些算法超出了这本书的范围。
- en: 'Now, let''s go back to `doUpdate` and look at the code specific for the tilt-based
    input:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `doUpdate` 并查看针对基于倾斜输入的特定代码：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here we make the assumption that with no tilt, the ship should be in the middle
    of the screen (which is `window.innerWidth / 2`). We then subtract the value of
    the x value from the last accelerometer sample and multiply it by `32`. This number
    is really quite arbitrary, feel free to experiment here. Personally, `32` felt
    about right–not requiring the device to tilt all the way over, but also requiring
    sufficient tilt to make movement feel substantial.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设在没有倾斜的情况下，飞船应该在屏幕中间（即`window.innerWidth / 2`）。然后我们从最后一个加速度计样本的x值中减去该值，并将其乘以`32`。这个数字实际上相当随意，你可以在这里自由实验。我个人觉得`32`感觉恰到好处——不需要将设备倾斜到极限，但同时也需要足够的倾斜来使移动感觉足够明显。
- en: The remainder of the lines ensure that the ship can't go off the edges of the
    screen.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的行确保飞船不能离开屏幕的边缘。
- en: What did we do?
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we dealt with handling accelerometer-based input.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们处理了基于加速度计的输入。
- en: What else do I need to know?
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要知道什么？
- en: Working with the accelerometer is no simple task. While our code is pretty simple,
    there are a lot of complicated algorithms out there to both reduce the noise but
    at the same time keep the movement from feeling sluggish–something I can't say
    we've really accomplished here.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与加速度计一起工作并不简单。虽然我们的代码相当简单，但有很多复杂的算法旨在减少噪声，同时保持移动感觉不迟钝——这并不是我们真正实现的地方。
- en: Another alternative is to use the device's gyroscope. These values aren't based
    on acceleration, but on the position of the device itself, and though noisy, they
    aren't as noisy as the accelerometer values. As such, they can be easier to work
    with. The problem is that only iOS exposes these to a browser. On Android, one
    would need to write a plugin to work with this type of sensor. Furthermore, not
    every device has a gyroscope, so you would need to provide a fallback to the accelerometer
    just in case.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用设备的陀螺仪。这些值不是基于加速度，而是基于设备本身的位置，尽管它们很嘈杂，但它们并不像加速度计值那么嘈杂。因此，它们可以更容易地处理。问题是只有iOS将这些暴露给浏览器。在Android上，需要编写一个插件来处理这种类型的传感器。此外，并非每个设备都有陀螺仪，因此你需要提供一个回退到加速度计的方案，以防万一。
- en: Game Over..... Wrapping it up
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束..... 结束
- en: Whew! That was a lot of work, but the result is pretty fun. See how far you
    can get before it gets too hard. Let me tell you, it doesn't take me very long
    to crash and burn.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这是一项很大的工作，但结果相当有趣。看看你在它变得太难之前能走多远。让我告诉你，我崩溃和失败得并不快。
- en: The final results are displayed in the following pages. I've not included Android
    screenshots since they appear virtually identical.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将在以下页面显示。我没有包括Android截图，因为它们几乎完全相同。
- en: 'The starting screen will be as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 启动屏幕将如下所示：
- en: '![Game Over..... Wrapping it up](img/9403_08_04.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束..... 结束](img/9403_08_04.jpg)'
- en: 'The options view will be as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 选项视图将如下所示：
- en: '![Game Over..... Wrapping it up](img/9403_08_05.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束..... 结束](img/9403_08_05.jpg)'
- en: 'And an unfortunate crash is seen in the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中可以看到一个不幸的崩溃：
- en: '![Game Over..... Wrapping it up](img/9403_08_06.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束..... 结束](img/9403_08_06.jpg)'
- en: Can you take the HEAT? The Hotshot Challenge
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能承受高温吗？热手挑战
- en: There are a lot of ways this game could be enhanced. Why don't you try a few?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方法可以增强这款游戏。你为什么不尝试几种呢？
- en: The game currently lacks a pause option; why don't you add one?
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏目前缺少暂停选项；你为什么不添加一个呢？
- en: Our game is naïve with regards to multitasking. Upon resumption, it will happily
    extrapolate where we should be in the cave after what might be a very long time.
    A better method would be to pause the game when it is in the background.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的游戏在多任务处理方面比较简单。在恢复时，它会愉快地外推我们可能在洞穴中的位置，这可能已经过去很长时间了。更好的方法是在游戏处于后台时暂停游戏。
- en: We're using pixel-based collision detection. Why don't you try to use math-based
    detection instead?
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用基于像素的碰撞检测。你为什么不尝试使用基于数学的检测呢？
- en: Try various control schemes until you find some you like.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试各种控制方案，直到找到你喜欢的。
- en: Use gyroscope values if available.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可用，请使用陀螺仪值。
- en: Add powerups or other objects in the map that could affect the player for good
    or bad.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图中添加可以影响玩家的增强道具或其他物体。
- en: Make static levels for the game that could be loaded on demand.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏制作静态关卡，这些关卡可以按需加载。
- en: Add logic to make sure any level is winnable.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加逻辑以确保任何关卡都是可赢的。
