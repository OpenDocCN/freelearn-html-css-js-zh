- en: Chapter 8. Playing Around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smartphones have been no strangers to fun little games that helped pass the
    time. From the seemingly eternally-existing Solitaire to Snake!, Tetris, or Pop-the-Bubble
    variants, we've found ways to pass the time with our mobile devices. Even if you
    nearly always write productive applications, sooner or later, the *bug* to write
    a game is likely to bite.
  prefs: []
  type: TYPE_NORMAL
- en: What do we build?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we're going to put together a game called *Cave Runner*. Okay,
    it won't win any prizes based on the originality of the game (or the title), nor
    will it win *Best Game of the Year*. But it's amusing, and has a lot of potential
    to expand in various ways, and so serves as a good base, especially for the quick
    and diverting category that many games try to fit into.
  prefs: []
  type: TYPE_NORMAL
- en: What does it do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To accomplish this, we're going to be relying heavily upon the HTML5 Canvas,
    which is quite literally the only way we're going to achieve anything even approaching
    60 fps (the target for most games). Even so, only recent and powerful devices
    are going to meet this target, and so we also will need to sludge around in the
    mathematics around how to create a game that isn't reliant upon its frame rate.
    If the game's timing relied solely on the frame rate, 30 fps would feel as if
    we're sludging through mud, that is, the game would feel like it was progressing
    in slow motion. Instead, we have to act like we're running at 60 fps, even if
    we can't display that many frames, so that we avoid this effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'While controlling a game character on a console, portable game machine, or
    PC is pretty obvious (keyboard, mouse, D-pad, Joystick, and so on), how does one
    control a game character on a mobile device which probably has none of those features?
    There are two answers: use the multi-touch screen, which can be used to simulate
    a Joystick or D-pad, or use the device''s built-in accelerometer. We''ll talk
    about using both in this task.'
  prefs: []
  type: TYPE_NORMAL
- en: Which brings us to the last big thing; it's not so hard to implement, but it
    is absolutely critical to have in place—**persistent** **settings**. If we're
    going to provide two methods of control, we need a way to save which method the
    user prefers. While we have used the `File` API in previous projects to store
    persistent content, we're going to use `localStorage` this time. After all, we're
    only storing a simple flag, not a lot of user-generated content.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it great?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully, you'll have a bit of fun with the game as it stands now, but even
    as a simple game, it introduces you to the concepts you'll need to create complex
    games further down the road. We'll work on keeping the game going at the same
    speed, regardless of frame rate. We'll talk about persistent settings using `localStorage`.
    We'll also work out how to control the game using the touch screen and the accelerometer.
    All of these things combine to create a good game, and you should have a good
    base from which to build on for any future endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to do it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to approach this much like we have the prior projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the options view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing to the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling touch-based input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do I need to get started?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and create your project, or use the project in the code package for
    this book as a start. You'll want to use the images in `www/images`. If you want
    some insight on how we designed the graphic assets, feel free to look in the `/resources`
    directory in the code package for this project.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we'll be talking more about the code that is already written than
    spelling the code out verbatim. As such, it would be a good idea to have the project
    downloaded so that you have the code as a reference. Go ahead and compile it for
    your device, too, and play with it, to get a better feel for what we'll be talking
    about.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where in previous projects we'd be developing the user interface and the interactions
    between the various widgets and views, we'll be designing how our game looks and
    acts instead. While similar, there's often a lot more that has to go into designing
    games (graphic assets, level design, character design, animation, and so on).
    Unfortunately, we can't go over everything given the length of the project, but
    we can give you a good start.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary theme of the game may already be evident from the title, Cave Runner.
    These kinds of games have been around since the first computers, even if the graphical
    quality was a tad bit coarse. In short, we're going to develop a game that has
    a series of levels through which the player (who controls a ship) has to navigate
    safely in order to advance. Each level will be more difficult than the previous,
    and in our particular version, as long as the player can keep up, there's no end
    to the levels. In all practicality, there will be a point where the player can't
    navigate safely through a given level, and so the game always ends with a crash.
    Think of it as an endurance run where we already know the outcome – it's the journey
    that's the point.
  prefs: []
  type: TYPE_NORMAL
- en: The level consists of a cave-like structure with walls on both sides of the
    screen. These walls are irregular and random and together form a safe path for
    the ship. If the ship touches the edges, the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To make things a little more difficult, there are obstacles that get in the
    ship's way. In the first levels, they don't appear very often, but as the levels
    get harder, the obstacles appear more often. The obstacle looks like a *wall*
    with an opening cut out, and the ship must pass within the opening in order to
    be safe.
  prefs: []
  type: TYPE_NORMAL
- en: Our levels will be randomly generated according to certain parameters in order
    to create an ever-changing landscape. Even though our levels are random, you could
    just easily create static levels and load them in wherever necessary, something
    which we suggest at the end of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our ship will be very simple: a triangle. Yes, one can get a lot more complicated
    with animation and such, but for the simple visual style of our game, it works
    well for our needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to move the ship, the player has two options: touch or swipe the screen
    in order to control the ship, or tilt the device. The ship will move according
    to the direction of the swipe or the tilt, that is, tilting or swiping left will
    move the ship left, and vice versa. Since we''re calling our character a *ship*,
    we''re intentionally introducing some fuzzy mechanics to the movement. In other
    words, the ship doesn''t respond instantly, nor does it stop instantly. Think
    of the ship as if it has thrusters on it.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could have decided that the position of the ship was directly
    related to the position of the finger on the screen or the degree of the tilt,
    and for some games this would be appropriate. It is always important to recognize
    that you should tailor your control mechanism to your game and use what makes
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: Our game itself will be contained within one view—the game view. Outside of
    the game will live the start view and an options view. The start view contains
    two buttons, namely, **Play** and **Options**. Tapping on **Play** will switch
    to the game view, while the **Options** button will switch to the options view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options view gives two iconic representations of controlling movement:
    one for tilting the device and one for sliding a finger across the screen. Tapping
    either of these elements will select that method as the control method. An additional
    **Back** button lets the user get back to the start view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the game view we have several items that need to be displayed. Of course,
    the level and the ship are required, but games often display other information
    as well. In our case, we''ll display the current level and the distance travelled
    through the level. Should we need to display a message (such as ***Crash!*** or
    **Level Complete**) we''ll show it in the middle of the screen along with two
    buttons: one to restart or continue, depending on the situation, and one to go
    back to the game view.'
  prefs: []
  type: TYPE_NORMAL
- en: And that's it, really; it's not a complicated game, and yet it can provide a
    base for more complicated endeavors in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a quick look at our graphical assets before we wrap this task up.
    Our splash screen looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our control icons will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our buttons that we use throughout the game won't require any graphical assets.
    We'll just use a rounded rectangle with a border and shadow, which we can accomplish
    with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task we designed our game mechanics and assets. We've figured out the
    views we need as well.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By no means is game design this simple. We can quickly go through this particular
    game partly because it is both simple and the mechanism is also well known. Even
    slightly more complex games will require a good deal of time to design, and it
    is best to do so before even writing a single line of code. Figure out your visual
    style, your sound style, the mechanics of the game, control mechanisms, levels,
    and animations. All of this will take time and lots of paper.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the options view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The start view is a simple view that we're not going to dwell on; feel free
    to look at the code in `www/views/startView.html`. In this task we'll focus on
    the options view located in `www/views/optionsView.html`. It's only moderately
    more complex than the start view, so some of the code is very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'When done, we''ll have something that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the options view](img/9403_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the HTML for the view first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first portion is very simple; the actual content is in a template that
    we''ll process for localization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this part of the code, we've defined two methods of control. Touching either
    the `optionsView_tilt` or `optionsView_slide` icon will call the method to select
    that control method. The **Back** button will pop the view and return to the start
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we''ve not defined any styles here; the styling lives in `www/styles/style.css`.
    Here''s the styling we''re using for our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We're using a background image for our start and options view (but not the game
    view), which we define in the preceding code. This puts a nice image behind our
    controls, so we need to be careful where we place the buttons so as to not overwrite
    any critical text or graphical elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each button is styled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a nice rounded button with bright colors as seen in the screenshot
    heading this section. It's also slightly rotated off-kilter, something games can
    usually get away with. Doing this in a productivity application wouldn't be all
    that good an idea.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For each button, we have to specify the location of the button, and if we want,
    we also override the rotation to have buttons in different rotations on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For our control selection, we first indicate where the icons will live, in
    the preceding code snippet, and then specify each one''s properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The font, in this case, gives us a handwritten feel. Note that we provide a
    fallback in case the device doesn't support this font, which is likely on Android
    devices. All recent iOS devices provide this font automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When selected, we change the color of the text and make the selected item appear
    to be highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code; it''s really pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, our `initializeView` method is used to set the view up and perform
    the necessary localization. It also calls `displayControlSetting`, which will
    highlight the appropriate control method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we're using `localStorage` here; it's almost so subtle you could
    miss it. First we check for the existence of our desired property (`controlSetting`).
    If it doesn't exist, we default to the *slide* control method. If it does exist,
    we'll use whichever value is stored in the property.
  prefs: []
  type: TYPE_NORMAL
- en: While `localStorage` isn't guaranteed to be 100 percent persistent (iOS has
    the option to delete it should the device's space get low), it's good enough for
    these kinds of settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user taps one of the control methods, we set `localStorage.controlSetting`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From this point on, the code is like we've used before, so we won't reprint
    it here.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we created our options view. We created the ability for the user
    to select either a *tilt* or *swipe* control method for their character, and we
    have used `localStorage` to both save and read back the user's preference.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if the user sees this screen and decides that *swipe* is the control method
    they want? This means we never set a property within `localStorage`. This means
    that when the game starts, how will it know which control method to use?
  prefs: []
  type: TYPE_NORMAL
- en: Simple, we'll do a check there too. If there's nothing in `localStorage`, we'll
    assume the user wants to use the swipe method. The key here is to be consistent;
    if the game decided to use the tilt method instead, but displayed the swipe as
    the default in our options view, the player would obviously be confused as to
    which option means what.
  prefs: []
  type: TYPE_NORMAL
- en: Generating levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's hard to imagine a game without at least one level, and that level needs
    to have some sort of content in it. In this task, we'll examine how to generate
    content for the levels in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `gameView.html` file in `www/views`. We'll be using this file quite
    a bit, so it would be a good idea to have it open for reference.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few ways one can generate a level. One can use random content,
    pseudo-random content, or static content. The first is pretty easy: just use random
    numbers for everything. Unfortunately, this doesn''t usually result in terribly
    nice levels, and there''s little guarantee of winnability or difficulty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third method is also pretty easy: use static content. This means that you''ve
    determined the entire level ahead of time, and stored it in a file. When the game
    requests the level, it can be read back. This means it is the same every time,
    which can be good (or bad), depending on the game, but it also means that you
    have a clear way to ensure both winnability and difficulty. For puzzle games,
    this is nearly always the method one uses.'
  prefs: []
  type: TYPE_NORMAL
- en: Our method is to be pseudo-random. We'll be using plenty of random numbers;
    we don't want perfectly straight cave walls or easily-guessed paths. But we also
    want to build in some level of increase in difficulty over time, as well as restrict
    the levels to a few parameters to help ensure (though not guarantee) winnability.
    It is possible to guarantee a level can be winnable with enough code, but we won't
    go quite that far in this game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the code used to generate a level using the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First we initialize our `points[]` array, and then four arrays within it. The
    first two arrays contain the left and right points that make up the cave wall.
    The last two contain the edges of any obstacle opening, or `-1` if there is no
    obstacle in place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, we start to define some variables that we'll be using to control our level.
    These two variables store the last points generated for the cave, but we need
    to have something to start from as well. `cWidth` is defined earlier in the file
    as being the width of the screen, so you can see how this would generate an open
    area in the middle of the screen at the beginning of our level. This is important,
    since we don't want to surprise the player with an immediate obstacle they can't
    avoid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`bias` controls the direction our cave walls will tend towards. They''ll still
    be randomly generated, but we introduce `bias` whenever the walls hit the edge
    of the screen so that there is always some movement.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`rndWidth` controls how much our cave wall can vary over a particular distance.
    In this case, it is controlled by the width of the screen and our current level.
    This means the cave gets harder to navigate as we progress through our levels.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`channelWidth`, on the other hand, limits just how close the cave walls can
    get. It''s also based on the width of the screen and the level. You''ll notice
    that at some high level, the channel will be too small to permit passage of the
    ship. At this point, the game can be considered over, or one could also build
    in a way to prevent this value from ever getting too small.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: An obstacle, or wall, is only generated every so often; we don't want an obstacle
    to appear at every point. So we generate some sort of chance that is also based
    on the level. Easier levels will have fewer obstacles, while harder levels will
    have several.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`wallEvery` also factors in how often obstacles appear, but in a different
    way. It controls how many points must be between an obstacle before it can have
    a chance to be generated. In this case, we''ll start off at 29 points, but will
    steadily lower it as the levels increase. This means obstacles will not only appear
    more often, but closer together.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next, we want to create a cave several hundred points long. The first level
    will start out with 366 points, and will only increase from there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For each point, we determine the left and right side of the cave. We base this
    on the previous point, add in `bias` (increased with the level), and then add
    a random number within our allowed width, and we have a cavern wall that will
    vary by a random amount, but not by so much (at least in the first levels) that
    the level will be impossible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Of course, without a few restrictions on the sides, it would be possible for
    the cave to wander off the screen, which does the player no good if they can't
    see it. So, we keep the cave on the screen. For the first two restrictions, we
    also affect the `bias`; this will tend to give the cave a zig-zag pattern overall.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we add the points to the array and store them for future reference
    (the next iteration in the loop).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we determine if it is time to put an obstacle in the way. First, we only
    check every so often (`wallEvery`), and we also restrict any obstacle from appearing
    within the first 30 points of the cave.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next we decide if a wall will appear at this point; this makes obstacles pretty
    rare early on, but they add up in later levels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For the obstacle, we create an opening that is a smaller opening than the width
    of the cave; this means the wall juts out from the cave by some degree. We then
    determine some random value within the range of the cave's opening and that's
    where the opening will go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If there is no obstacle, we push `-1`; this way we can know if there's an obstacle
    (or not) at any given point.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! This will create a long, winding cave that's more treacherous
    the higher the level.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we generated the levels for our game, based on pseudo-random generation
    with some specific rules in place to create levels increasing in difficulty over
    the course of the game.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This isn't the only way to generate a pseudo-random level, of course. There's
    all sorts of ways that are beyond the scope of this book, and there are things
    you can do to ensure that a level always stays winnable too. Level generation
    is a subject all on its own (with many, many smart people working in the field),
    so it won't take long to get your mind blown with some of the level-generation
    techniques out there. See [http://en.wikipedia.org/wiki/Procedural_generation](http://en.wikipedia.org/wiki/Procedural_generation)
    for examples of games that generate their levels procedurally as well as some
    links to articles describing various ways to generate levels procedurally. Keep
    in mind that this is highly specific to the kind of game you're developing.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing to the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, it does no good to generate a level if we don't display it to the
    player. That's what we'll be doing in this task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we set the canvas up, also taking care to deal with retina screens in
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We store these as global variables, because it is important not to have to do
    DOM walking for every frame of content—that only slows us down—something that
    is a bad thing when we're trying to render a frame within 16 milliseconds (the
    maximum amount of time we can take if we're targeting 60 fps).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Next, we set up a few properties and then clear the canvas. It is critical to
    clear the canvas for every frame; otherwise you'll end up leaving ghosts behind
    of the previous frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we draw both sides of the cave using a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Based on which part of the cave we're drawing, we assign either the `0` or `1`
    index of `points[]` to another variable, `pts`. This lets us avoid having to double
    index the points array such as `points[i][x]` and use `pts[x]` instead. We also
    define the left (or right) side of the wall that is off screen; this comes in
    handy for drawing the cave, since we need to fill the cave walls to make them
    solid. This means we are essentially drawing a big rectangle with one portion
    of it very rough; the rough side being the cave wall.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We begin the path and then move to the leftmost, topmost portion of the canvas;
    in fact, quite a way off of it. This ensures the player never sees the edge of
    the big rectangle we're drawing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next, we loop through each point in the array, but only over the ones necessary.
    If the player is halfway through the level, there's no point in drawing the previous
    points, nor is there any point in drawing parts of the cave that are beyond the
    screen's height.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In order to keep the motion of the cave smooth, we multiply the current piece
    by the piece width and subtract our current position in the level. Technically,
    this would result in a jumpy view at the first and last drawn index, but we're
    drawing a couple of points beyond both sides, so any jumpiness is kept off screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Next, we draw a line to the given point. If we're working on the right side,
    the point is to the left of the screen's right edge, which is the right side of
    the cave.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If we have an obstacle to display, we also draw a line to the point and then
    a vertical line one `pieceWidth` high. This will cause the obstacle to appear
    like a wall with an opening in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we draw a line off screen again, and then proceed to fill and stroke
    the path. The player will only see the rough edges of the cave wall.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After we draw the cave walls, we need to draw the ship. In this case, we draw
    a simple triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Generally most games need to display some text (such as a score), and so we
    do something similar too. We show the current level and the distance travelled
    through the level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if the user's control method is swiping, we display a translucent circle
    where the user is touching (assuming it is at the bottom of the screen) so that
    the user knows that the touch has been registered.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when drawing a frame, we need to be quick, and thankfully
    the operations that we just saw depend on the hardware; we can achieve a frame
    within a few milliseconds. If we stay under 17 milliseconds, we can achieve nearly
    60 fps, though on older hardware, this is more like 20-30 milliseconds. So we
    need to do something else, which we'll cover next, that is, drop frames so that
    the game doesn't feel too sluggish.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we drew the level on the canvas, displayed the ship, and put various
    text on the canvas as well. We also kept it quick, something we could only do
    by using the `canvas` tag.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, the preceding code only draws one frame; we need to call it multiple
    times in order to achieve fluid scrolling. There are two ways to do this: we can
    use `setTimeout` or use `requestAnimationFrame`. The latter is preferred, as it
    has better resolution than `setTimeout`, but it isn''t yet supported in all mobile
    browsers. For our purposes, we use `setTimeout`. It calls in `doUpdate`, which
    we''ll go over later, rather than `doAnim`.'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if we can't hit 60 fps, we need to act like we are hitting 60 fps anyway.
    If we don't, any slowdowns will cause the game to feel as if it was in slow-mo.
    Instead, we need to *drop frames* and move things along as if we were getting
    60 fps. The display will not be as smooth, but the gameplay won't get that slow-mo
    feeling until we drop down to a really low frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you were paying close attention to our code in the last task, you''ll notice
    that we skipped a few lines. These were the lines crucial to keeping the game
    progressing as if it were hitting 60 fps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: All we're doing is measuring the time between frames and then applying some
    math to it. We then pass this in to `doUpdate`, which we'll discuss later. This
    number equates to the number of frames that should have passed in a given period
    of time. If we're at 60 fps, we'll always end up with this number being 1; but
    if we're at 30 fps, the number will be 2; and at 15 fps it will be 4, and so on.
    Since the number can be fractional, we can be very fine-grained when updating
    our game.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, that was short, but it's not a terribly complicated concept. But it is very
    important; without it, if the device slowed down for any reason, the game would
    slow down too, making it feel as if it was in slow-motion. Instead, we'll drop
    the frames in order to keep the speed up. It won't be as smooth, but gameplay
    should always trump getting every frame in.
  prefs: []
  type: TYPE_NORMAL
- en: Performing updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, drawing the same frame over and over won't do any good. We need to
    update the game too. This includes responding to user input, checking for collisions,
    and moving us along the cave.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll be doing all our updating in… guess what! `doUpdate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you recall from the last task, `f` is the incoming frame multiplier. We want
    this to be 1, but it might be 2 if we're getting 30 fps, or 4 if we're getting
    15\. We'll use this at various points to multiply any updates so that everything
    moves as if we were getting 60 fps, even when we aren't.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There are the various methods of doing collision detection. We could determine
    it mathematically, but that gets more than a bit painful. Instead, we'll use the
    canvas' own data and do pixel-based collision detection instead.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding line requests very little data from the canvas. In fact, we're
    only checking the center point of the ship for a collision. Part of this is so
    that we can be lenient on the user, part of it is laziness, but the other part
    is that pixel-based collision detection using the canvas is horribly slow. In
    fact, just checking for one pixel cuts our fps nearly in half.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If the pixel data in the data returned from the canvas is not zero (black),
    then we know we've impacted on something; what we've hit doesn't matter. We mark
    the game as over, and tell the user about it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes `f` comes in as `0` or `Infinity`. This is most often at the start
    of a game, when we have to pass in a time difference, but there's not really been
    any. In this case, the division in `doAnim` will return `infinity`. We don't want
    to do anything in either case, so we make sure that we only operate if `f` is
    a reasonable value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`buttonDown` reflects the user''s input if they are using touch controls. If
    they are sliding left, `buttonDown` will be negative. If they are going to the
    right, `buttonDown` will be positive. If they aren''t doing anything, it will
    be zero. If they are using tilt controls, we''ll calculate this value differently,
    but we''ll show that in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: If we're non-zero, we build up some acceleration, as if a thruster was on the
    ship. Since thrusters can't react instantly, the ship takes a little bit to react.
    This has the effect of making the game a little harder; one has to take into account
    the reaction time of the ship.
  prefs: []
  type: TYPE_NORMAL
- en: If we're zero, we reduce the acceleration, as if the ship was coasting to a
    stop. Once we reach a certain threshold, we stop the ship entirely, but until
    that point, there is some movement. Again, this adds some difficulty, as it must
    be considered when moving the ship.
  prefs: []
  type: TYPE_NORMAL
- en: One important variable in the preceding code snippet is `deviceFactor`. This
    is subjective; when the ship's movement felt right on an Android device, it felt
    too slow on an iOS device, and so this variable compensates a bit for that difference.
    Never be afraid to tweak the movement mechanics on different devices so that it
    feels the same, even if it isn't technically the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we multiply the acceleration by `f`; this keeps the ship's movement
    working as if it were happening in a game with 60 fps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next, we calculate the vertical distance through the cave, which is done by
    adding a number to `currentTop`. We adjust it slowly based on the current level
    as well, so higher levels will get faster and faster. Again, we multiply by `f`
    to keep things feeling smooth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If the player has managed to navigate the entire level, we need to stop the
    game and tell the user that they made it. When they continue, they'll pick up
    at the next higher level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here's our `setTimeout` that keeps everything going. Note that we do this unless
    the game is over or the level is over. If one wanted to add a pause feature, one
    would also avoid setting a timer at this point.
  prefs: []
  type: TYPE_NORMAL
- en: The `17` here is intended to get us as close to 60 fps as possible. It doesn't
    work out to that in reality, as browsers don't have good resolution, so the next
    frame could arrive in 12 milliseconds or in 30\. WebKit, thankfully, has something
    on the order of 4 milliseconds resolution, so it isn't likely to be far off of
    `17`, and so we can get up to 56 fps, assuming a modern device.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we handled the updating of the ship's position, the position in
    the cave, and whether or not we crashed, or completed the level.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yeah, pixel-based collision detection is a pretty lazy way out. In nearly every
    circumstance, math-based collision detection is the better (and faster) way to
    do it. There's lots of good stuff out there about how to do good collision detection,
    and it falls out of the scope of this project. You might start with [http://en.wikipedia.org/wiki/Collision_detection](http://en.wikipedia.org/wiki/Collision_detection)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: It wouldn't be quite so bad in our game if it wasn't for the fact that even
    requesting a single pixel from the canvas data drops our frame rate by nearly
    half. I suspect this has to do with having to transfer the data off of the GPU
    and back to the CPU for processing, but that's just a guess. Even so, it's a bit
    painful, and if I'd had more caffeine when writing the collision detection routines,
    I'd have gone the math route.
  prefs: []
  type: TYPE_NORMAL
- en: Handling touch-based input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we don''t have a physical keyboard or joystick or D-pad, we have to emulate
    one on the screen. We could do this with two buttons on the screen for our game:
    one to go left, and one to go right. In fact, the game has it built in, just hidden.
    Another way is to allow for the differences in how a swipe might occur: a slow
    movement when our ship is not in danger, or a sudden movement when we need to
    avoid an obstacle in a hurry. Another method would be to simply link up the touch
    position on the screen to the ship; essentially our finger would have to trace
    the path through the cave. For smaller devices this might be fine, but for larger
    devices, it is better to go with some other method.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our game, our touch input can handle swipes (where the finger isn't always
    on the screen) to move the ship in short bursts, or it can handle long drags where
    the finger is always on the screen and slight movements generate movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put it simply: if we move left, the ship should move left, and vice versa.
    However, if we need to get out of an obstacle''s way in a hurry, we shouldn''t
    have to move a long distance. We should be able to move a short distance in a
    quick burst, and so we also measure the distance between movements so we can tune
    the ship''s movement to how fast our finger is moving. If the finger is moving
    slowly, the ship moves slowly. If it moves quickly, the ship moves really quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: None of this is hard; in fact, the hardest part isn't making it work, it's making
    it work well. It's hard to make a control method feel totally natural, and I won't
    claim to have mastered it here. It takes lots of testing to get a control mechanism
    just right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the game starts, we check the control method the user has selected –
    remember the options view. If the control method is `slide`, we''ll attach events
    to an overlay `DIV`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This overlay literally covers the entire canvas. You may wonder why we have
    to use an overlay—it turns out that the canvas itself isn't always so hot at handling
    touch events!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When a finger touches the screen, we record the initial touch, and tell the
    game that a finger is touching the screen. If you remember `doUpdate`, this last
    part tells the game to draw a translucent circle at the x position of the touch
    to give the user feedback.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If a movement is received, we need to calculate the distance between the last
    x position and the new x position. We then give `buttonDown` a negative or positive
    value based on the direction of the movement. We also divide it if the movement
    was slow; if it was a fast movement (over five pixels), we'd have values of `-1`
    for left and `+1` for right, but a slow movement might return `-0.2` and `+0.2`.
  prefs: []
  type: TYPE_NORMAL
- en: If the finger hasn't moved by much (it needs to have moved by more than one
    pixel to register movement to the ship), then we indicate that `buttonDown` is
    `0`, so that the ship will coast to a stop. We also set up a timer to fire in
    a few short ms to turn `buttonDown` to zero as well. This is because we won't
    receive a `touchMove` event if the finger stays absolutely still, so we need a
    way to catch this. If a movement is received before the timer expires, we cancel
    the timer so that the value never becomes zero as long as there is adequate movement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When the finger is lifted, we will instantly allow the ship to coast to a stop,
    and stop displaying the translucent circle.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't the only way to do movement, and I urge you to experiment with different
    ways of processing touch-based input.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we dealt with touch-based input in order to allow the user to
    move our game's ship.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to respond to the tilt of the device, we need to use the device's accelerometer.
    These aren't the easiest things to deal with, and our implementation is a bit
    naïve. Unfortunately, it doesn't take long until you start getting into the math
    that's more than a bit complicated, and so lies outside the scope of this project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accelerometer-based input is hard – really hard. So hard, in fact, that the
    game doesn't have a particularly good implementation of it. You are encouraged
    to experiment with a lot of devices and algorithms to come up with a good control
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn on the accelerometer check, we first have to set up a watch for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This sets up a 40 milliseconds watch–not really quite as fast as I'd like, but
    workable. Every 40 milliseconds, the `updateAccelerometer` method will be called.
    If an error occurs, then `accelerometerError` will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Watching the accelerometer takes some effort, so when done with it, it is always
    a good idea to clear it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'So what do we get with the accelerometer? We get an object containing four
    values: a timestamp, an x value, a y value, and a z value. These values indicate
    the acceleration in a given direction. If the device is lying flat on a table,
    the x and y values will be zero, while the z value will be equal to the force
    of gravity. Generally we can assume that the x value corresponds to left/right
    tilt (assuming the device is upright), which is all we need for our game.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When we receive an update, we apply a weighted average of the new input and
    the previous input, giving more weight to the previous input. It turns out that
    accelerometer-based input is really, really noisy, and so we only give the new
    input small importance. This has the side-effect, unfortunately, of making movement
    feel a little sluggish. The fractional values make a big difference in how well
    the ship responds, but at the trade-off of a ship that feels jittery. Feel free
    to experiment with these numbers, but they need to add up to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the `amCalibrated` variable; you could also compare the data to a calibrated
    value instead. The calibrated value is often obtained just before the level begins,
    when `amCalibrated` would be set to `false`. The next accelerometer update would
    calibrate the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A better way to calibrate the accelerometer would be to take a series of inputs
    and average them out. For that matter, that is the same way to smooth out the
    accelerometer itself; but those algorithms are beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to `doUpdate` and look at the code specific for the tilt-based
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here we make the assumption that with no tilt, the ship should be in the middle
    of the screen (which is `window.innerWidth / 2`). We then subtract the value of
    the x value from the last accelerometer sample and multiply it by `32`. This number
    is really quite arbitrary, feel free to experiment here. Personally, `32` felt
    about right–not requiring the device to tilt all the way over, but also requiring
    sufficient tilt to make movement feel substantial.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the lines ensure that the ship can't go off the edges of the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we dealt with handling accelerometer-based input.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with the accelerometer is no simple task. While our code is pretty simple,
    there are a lot of complicated algorithms out there to both reduce the noise but
    at the same time keep the movement from feeling sluggish–something I can't say
    we've really accomplished here.
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative is to use the device's gyroscope. These values aren't based
    on acceleration, but on the position of the device itself, and though noisy, they
    aren't as noisy as the accelerometer values. As such, they can be easier to work
    with. The problem is that only iOS exposes these to a browser. On Android, one
    would need to write a plugin to work with this type of sensor. Furthermore, not
    every device has a gyroscope, so you would need to provide a fallback to the accelerometer
    just in case.
  prefs: []
  type: TYPE_NORMAL
- en: Game Over..... Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whew! That was a lot of work, but the result is pretty fun. See how far you
    can get before it gets too hard. Let me tell you, it doesn't take me very long
    to crash and burn.
  prefs: []
  type: TYPE_NORMAL
- en: The final results are displayed in the following pages. I've not included Android
    screenshots since they appear virtually identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting screen will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game Over..... Wrapping it up](img/9403_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The options view will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game Over..... Wrapping it up](img/9403_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And an unfortunate crash is seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game Over..... Wrapping it up](img/9403_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Can you take the HEAT? The Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of ways this game could be enhanced. Why don't you try a few?
  prefs: []
  type: TYPE_NORMAL
- en: The game currently lacks a pause option; why don't you add one?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our game is naïve with regards to multitasking. Upon resumption, it will happily
    extrapolate where we should be in the cave after what might be a very long time.
    A better method would be to pause the game when it is in the background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're using pixel-based collision detection. Why don't you try to use math-based
    detection instead?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try various control schemes until you find some you like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use gyroscope values if available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add powerups or other objects in the map that could affect the player for good
    or bad.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make static levels for the game that could be loaded on demand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add logic to make sure any level is winnable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
