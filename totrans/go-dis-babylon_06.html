<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer069">
<h1 class="chapter-number" id="_idParaDest-119"><a id="_idTextAnchor120"/>6</h1>
<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Implementing the Game Mechanics</h1>
<p>The focus of the previous chapters was solidly on building an application foundation for <strong class="bold">Space-Truckers</strong>. Now, it’s time to shift gears (as it were) and look at the way we want to implement the game for its first phase: <strong class="bold">Route Planning</strong>. As we usually want to do when faced with a single, daunting, complex problem, we break down this part of the game into two principal facets: simulation and game elements. Throughout this chapter, we’ll start by looking at the simulation part of the game before layering the game mechanics on top of the simulation in a way that gives us the freedom to iterate.</p>
<p>It’s a common tactic of reality shows and gameshows where the host will give a wind-up speech that seems to indicate that they’re about to get to the big reveal, but then instead the show cuts to a commercial. This is relevant because we’re going to perform a similar <em class="italic">headfake</em> – instead of diving directly into the exciting simulation and game mechanics, we’re going to first take a short detour so that we can learn about how to manage music and sounds in Space-Truckers. Though a short one, it will be a handy addition as we continue integrating more and more functionality into the application.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>A Detour into Sound Management</li>
<li>Designing the Game Elements of the Route Simulation</li>
<li>Creating the Orbital Mechanics Simulation</li>
<li>Defining the Rules – Game Mechanics</li>
</ul>
<h1 id="_idParaDest-121"><a id="_idTextAnchor122"/>Technical Requirements</h1>
<p>The first section of this chapter deals with audio files and playing them, so it’s helpful but not necessary to have speakers or some other way of hearing sound output. As always, the source code is available on GitHub at <a href="https://github.com/jelster/space-truckers/tree/ch6">https://github.com/jelster/space-truckers/tree/ch6</a>.</p>
<p>As you might expect, most of the technical requirements from previous chapters apply to this one since we’re continuing the work that started there. </p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>Helpful Things to Know</h2>
<p>The following are helpful things to know:</p>
<ul>
<li>Outside of the technical realm of software, there are some concepts and skills that are helpful to have previous knowledge of coming into this section. Don’t worry if you don’t recognize or aren’t familiar with this stuff – that’s the whole reason you’re reading this book in the first place – to learn! This includes vector operations in 3D space, addition, subtraction, multiplication, and so on, as well as the difference between normalized (1- unit) and non- normalized vectors.</li>
<li>Basic kinematic physics – calculate the velocity or position of something based on time, with and without including acceleration.</li>
<li>Familiarity with force and momentum relationships.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Computers are supposed to be the ones who are good at crunching numbers, not you. Don’t freak out if you don't consider yourself a math person – we’ve got you covered!</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>Useful Links from the Babylon.js Docs</h2>
<p>The following <a id="_idIndexMarker376"/>are some useful links:</p>
<ul>
<li>Physics Engine and Forces: <a href="https://doc.babylonjs.com/divingDeeper/physics/forces">https://doc.babylonjs.com/divingDeeper/physics/forces</a></li>
<li>Mesh Copies, Clones, and Instances – look at the <strong class="bold">Solid Particle System</strong> (<strong class="bold">SPS</strong>), Instances, and Thin Instances: <a href="https://doc.babylonjs.com/divingDeeper/mesh/copies">https://doc.babylonjs.com/divingDeeper/mesh/copies</a></li>
<li>Environment Skyboxes (which we will get more into in <a href="B17266_10_Final_AM.xhtml#_idTextAnchor207"><em class="italic">Chapter 10</em></a><em class="italic">, Improving the Environment with Lighting and Materials</em>): <a href="https://doc.babylonjs.com/divingDeeper/environment/skybox">https://doc.babylonjs.com/divingDeeper/environment/skybox</a></li>
<li>Events<a id="_idIndexMarker377"/> and Actions: <a href="https://doc.babylonjs.com/divingDeeper/events/actions">https://doc.babylonjs.com/divingDeeper/events/actions</a></li>
</ul>
<h1 id="_idParaDest-124"><a id="_idTextAnchor125"/>A Detour into Sound Management</h1>
<p>The topic of <a id="_idIndexMarker378"/>playing music and sound FX has come up previously in our journey – the theme song sound is played as part of the Splash Screen that we built in <a href="B17266_05_Final_AM.xhtml#_idTextAnchor103"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding a Cut Scene and Handling Input</em>, after all. The sound plays just fine, and everything seems to work, so what need is there to <em class="italic">make things more complicated</em> for no apparent reason? This is an excellent point to raise because, in software, the best approaches tend to also be the simplest, and simple is good because it means fewer things can go wrong (by definition). When fewer things can go wrong in software, it’s easy and cheap to make changes, additions, and enhancements and that is good for both Engineering and Accounting – a two-for-one special!</p>
<p>What all of that is getting to is that even though it works fine in isolation to load and directly play the <strong class="source-inline">BABYLON.Sound</strong> instance directly in the Screen itself, things break down when more than one Scene and Screen become involved. The main reason for this has to do with the fact that <strong class="source-inline">AudioEngine</strong> is independent of the Scene, but the Sound is not. This causes issues when we want to coordinate the starting, stopping, and volume levels of multiple Sounds across multiple different Scenes.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/>Sounds, SoundTracks, and the AudioEngine</h2>
<p>Analogous <a id="_idIndexMarker379"/>to how<a id="_idIndexMarker380"/> the <strong class="bold">WebGL2</strong>/<strong class="bold">WebGPU</strong> canvas is used to perform rendering, the underlying audio engine used in Babylon.js is based on the <strong class="bold">Web Audio</strong> specification. If you’re<a id="_idIndexMarker381"/> interested in diving into that, and/or if you have insomnia, check it out at <a href="https://webaudio.github.io/web-audio-api/">https://webaudio.github.io/web-audio-api/</a>. To read more details on the abstractions built on top of that specification, the relevant Babylon.js API docs can be found at <a href="https://doc.babylonjs.com/typedoc/classes/babylon.sound">https://doc.babylonjs.com/typedoc/classes/babylon.sound</a>.</p>
<p>To boil down our requirements when it comes to audio, we need the application to be able to do the <a id="_idIndexMarker382"/>following things or have the following qualities:</p>
<ul>
<li>We need to be able to control the collective volume (gain) level for groups of related types of sounds, such as background music, UI feedback sounds, and game sound effects</li>
<li>It should be easy to change out the underlying sound assets without needing to change any of the consuming components’ code</li>
<li>Consumers of the audio component should be able to easily access the underlying <strong class="source-inline">BABYLON.Sound</strong></li>
<li>The asynchronous loading of audio assets should be coordinated to ensure all of a Scene’s assets have completed their tasks before signaling readiness</li>
</ul>
<p>To accomplish the first item, we’ll leverage the functionality of <strong class="source-inline">BABYLON.SoundTrack</strong>. This type is well named because it tells you what it does in the name! Instances of a Sound are associated with a <strong class="source-inline">SoundTrack</strong> via the <strong class="source-inline">SoundTrack.addSound</strong> function. The collective volume of any Sounds belonging to a given <strong class="source-inline">SoundTrack</strong> is controlled with the <strong class="source-inline">setVolume</strong> function. There are other methods in <strong class="source-inline">SoundTrack</strong> of course, but the two mentioned functions are the ones that we’re interested in now. </p>
<p>Looking back at the list of<a id="_idIndexMarker383"/> requirements, the third can be provided by a property accessor, while the second requirement is fulfilled by creating a mapping between a <em class="italic">friendly</em> string identifier and an object map (see <a href="B17266_05_Final_AM.xhtml#_idTextAnchor103"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding a Cut Scene and Handling Input</em>, the <em class="italic">Designing the Input System</em> section for more examples of this). The last requirement can be satisfied easily with the use of the functionality of the JS-standard <strong class="source-inline">Promise</strong> object. We’ll see how these all work together shortly, but it’s worth taking a moment to step back from the detailed requirements discussed previously to understand how this fits into the bigger picture.</p>
<p>A helpful way of identifying missing requirements and potential opportunities to solve problems relating to those requirements is to mentally picture a concrete scenario involving the matter at hand. In this case, picture the gameplay screen. Things are happening in it – the player inputs commands, the application responds to acknowledge entry, and events happen in-game. At the same time, music is playing in the background underneath the mechanical whines and screeching put out by the player’s cargo pod as it is launched or<a id="_idIndexMarker384"/> as it crashes. There is a multitude of <a id="_idIndexMarker385"/>audio samples being played at any given time, but they all have different volumes appropriate to their category or type of sound. Keep that goal in mind because as we dive into the details, this overall <em class="italic">big picture</em> will help guide and keep us on track.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/>SpaceTruckerSoundManager</h2>
<p>The<a id="_idIndexMarker386"/> first two steps – design and build – concern the specifics of how we will use the audio features of Babylon.js to create our <a id="_idIndexMarker387"/>audio component, while the third concerns how we will make use of that component. The full code for the following snippets can be found in this chapter’s branch of the Space-Truckers GitHub repository at <a href="https://github.com/jelster/space-truckers/blob/ch6/src/spaceTruckerSoundManager.js">https://github.com/jelster/space-truckers/blob/ch6/src/spaceTruckerSoundManager.js</a>.</p>
<h3>Design</h3>
<p>We need <a id="_idIndexMarker388"/>a bit of helper logic that will wrap the Babylon.js objects and help us manage their lifetimes and behavior. Because we’re so very imaginative, we’ll call it <strong class="source-inline">SpaceTruckerSoundManager</strong> – catchy, right? There are probably a lot of different ways that this can be constructed, but we want <em class="italic">The Simplest Thing That Could Possibly Work</em>, and that is <strong class="source-inline">spaceTruckerSoundMap.js</strong> and its <strong class="source-inline">soundFileMap</strong>:</p>
<pre class="source-code">&#13;
const soundFileMap = {&#13;
    "title": { url: titleSongUrl, channel: 'music', &#13;
      loop: true },&#13;
    "overworld": { url: backgroundMusicUrl, &#13;
      channel: 'music', loop: true },&#13;
    "whoosh": { url: uiWhooshSoundUrl, &#13;
      channel: 'ui', loop: false }&#13;
};</pre>
<p>The URL for each sound file is supplied by an associated <strong class="source-inline">import</strong> statement, with the object key being an arbitrary (but unique) string name. <strong class="source-inline">SoundTrack</strong> that the sound will be added to, as <a id="_idIndexMarker389"/>well as the <strong class="source-inline">loop</strong> flag to control auto-looping, are the two other data pieces rounding out <strong class="source-inline">soundFileMap</strong>, so let’s move on to how <strong class="source-inline">SpaceTruckerSoundManager</strong> uses it.</p>
<h3>Build</h3>
<p>Each<a id="_idIndexMarker390"/> instance of <strong class="source-inline">SpaceTruckerSoundManager</strong> is initialized with the associated scene, along with a list of one or more <strong class="source-inline">soundId</strong>. These are stored in the <strong class="source-inline">registeredSounds</strong> object map, which can be used to retrieve a given <strong class="source-inline">Sound</strong> by calling the <strong class="source-inline">sound(id)</strong> accessor function:</p>
<pre class="source-code">&#13;
registeredSounds = {};&#13;
sound(id) {&#13;
    return this.registeredSounds[id];&#13;
}</pre>
<p>The three different <strong class="source-inline">SoundTracks</strong> are stored in the <strong class="source-inline">channels</strong> property and initialized in the constructor:</p>
<pre class="source-code">&#13;
constructor(scene, ...soundIds) {&#13;
    this.channels.music = new SoundTrack(scene, &#13;
      { mainTrack: false, volume: 0.89 });&#13;
    this.channels.sfx = new SoundTrack(scene, &#13;
      { mainTrack: true, volume: 1 });&#13;
    this.channels.ui = new SoundTrack(scene, &#13;
      { mainTrack: false, volume: 0.94 });</pre>
<p>As mentioned previously, <strong class="source-inline">constructor</strong> takes <strong class="source-inline">scene</strong> and a list of <strong class="source-inline">soundIds</strong>; what was not mentioned previously was that after the constructor finishes, the component will not be ready for use yet – the <strong class="source-inline">onReadyObservable</strong> property of the component will notify subscribers when <strong class="source-inline">SpaceTruckerSoundManager</strong> has finished loading and preparing all its child <strong class="source-inline">Sound</strong> instances:</p>
<pre class="source-code">&#13;
Promise.all(onReadyPromises).then(readyIds =&gt;&#13;
  this.onReadyObservable.notifyObservers(readyIds));</pre>
<p>The bulk of the<a id="_idIndexMarker391"/> constructor’s logic is taken up by a loop over the list of <strong class="source-inline">soundIds</strong>. Inside the loop is logic charged with the business of instantiating and managing how that Sound is loaded, the state of which is represented by <strong class="source-inline">prom</strong>. When the Sound’s <strong class="source-inline">onLoaded</strong> callback fires, the newly loaded <strong class="source-inline">Sound</strong> is added to the appropriate channel, <strong class="source-inline">SoundTrack</strong>, and the promise is resolved successfully:</p>
<pre class="source-code">&#13;
const onReadyPromises = [];&#13;
soundIds.forEach(soundId =&gt; {&#13;
    const mapped = soundFileMap[soundId];&#13;
    const chan = this.channels[soundId] ?? &#13;
        scene.mainSoundTrack;&#13;
    // guard logic omitted for length&#13;
    const prom = new Promise((resolve, reject) =&gt; {&#13;
        const sound = new Sound(soundId, mapped.url, scene, &#13;
           () =&gt; {&#13;
            chan.addSound(this.registeredSounds[soundId]);&#13;
            resolve(soundId);&#13;
        }, {&#13;
            autoplay: false,&#13;
            loop: mapped.loop,&#13;
            spatialSound: mapped.channel === 'sfx'&#13;
        });&#13;
        sound.onEndedObservable.add((endedSound, state) &#13;
          =&gt; {&#13;
                this.onSoundPlaybackEnded&#13;
                    .notifyObservers(endedSound.name);&#13;
            });&#13;
        this.registeredSounds[soundId] = sound;&#13;
        });&#13;
        onReadyPromises.push(prom);&#13;
    });    &#13;
}</pre>
<p>The individual <a id="_idIndexMarker392"/>asynchronous <strong class="source-inline">Promises</strong> are coordinated in two ways: first, an array of promises is constructed containing all of the different asynchronous calls that need to be resolved before continuing. Second, the <strong class="source-inline">Promise.all</strong> method takes that array of Promises and returns another <strong class="source-inline">Promise</strong> that, when resolved, will contain the results of each <strong class="source-inline">Promise</strong> contained in the array. In other words, it waits until everything has finished and then announces its completion.</p>
<p>Because we can’t mark the constructor as <strong class="source-inline">async</strong>, we can’t await the Promise results. Instead, we attach a function to the <strong class="source-inline">Promise.then</strong> chain, which, in turn, signals readiness via <strong class="source-inline">onReadyObservable</strong>. What’s notable is the absence is any sort of error or exception handling or catching – something that we will want to include in a more production-hardened application!</p>
<h3>Integrate</h3>
<p>The <a id="_idIndexMarker393"/>Splash Screen (see <a href="B17266_05_Final_AM.xhtml#_idTextAnchor103"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding a Cut Scene and Handling Input</em>) already plays a Sound, so we’ll want to replace that with a <strong class="source-inline">SpaceTruckerSoundManager</strong> instance that is initialized in the constructor:</p>
<pre class="source-code">&#13;
this.audioManager = new SpaceTruckerSoundManager&#13;
  (scene, 'title');&#13;
this.audioManager.onReadyObservable.addOnce(_ =&gt;&#13;
  this.onReadyObservable.notifyObservers());</pre>
<p>The Scene will have completed loading and initialization long before <strong class="source-inline">audioManager.onReadyObservable</strong> fires, so we will use that event to signal the Screen’s overall readiness. To make the refactor seamless and easy, the music field of <strong class="source-inline">SplashScene</strong> is changed into the <strong class="source-inline">get music()</strong> accessor, which retrieves the <em class="italic">title</em> Sound from the underlying <strong class="source-inline">audioManager</strong>:</p>
<pre class="source-code">&#13;
get music() {&#13;
    return this.audioManager.sound("title");&#13;
}</pre>
<p>As a result, no <a id="_idIndexMarker394"/>other code changes are necessary to retrofit <strong class="source-inline">SpaceTruckerSoundManager</strong> into <strong class="source-inline">SplashScreen</strong> – it’s good to go! This brings our little detour to its end, but this won’t be the last time we see this since we’re going to be making direct use of it later in this chapter. For now, however, we’re going to be shifting topics to look at the route simulation and how it is constructed.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor128"/>Designing the Game Elements of the Route Simulation</h1>
<p>The <a id="_idIndexMarker395"/>Helios star system is the setting for Space-Truckers, but up until now, we haven’t gotten into what that entails. A topic covered in exhaustive detail in other books both fiction and non- is the well-known fact that Space Is Big. Like, Really Big. At the scale of a solar system, distances involved are so large compared to relative sizes of things that trying to represent this huge scale accurately in our game will neither be fun nor performant.  </p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>An Overview of the Helios System</h2>
<p>The <a id="_idIndexMarker396"/>following diagram is a<a id="_idIndexMarker397"/> rather stylized view of the Helios system – the home setting for Space-Truckers – from a bird’s-eye view. Bracketed planetary bodies show the two different start and end route possibilities –outward going in toward the sun and vice versa. In the following diagram, the different shaded regions correspond to different potential encounters for players during the driving phase:</p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="Figure 6.1 – Depiction of the route planning gameplay map&#13;&#10;" height="1420" src="image/Figure_6.01_B17266.jpg" width="1396"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Depiction of the route planning gameplay map</p>
<p>The <a id="_idIndexMarker398"/>closest planet is Hermes, so-called <a id="_idIndexMarker399"/>because it speeds around in its tight orbit of Helios. In the game world, it’s the primary starting position for route planning. Routes originating from Hermes will end at the busy hive of construction at Zeus. The alternative, the <em class="italic">B</em> route, starts a bit further out from the star around the planet Tellus and has as its destination as the distant ice factories of Janus.</p>
<p>In between either set of origins and destinations are a whole solar system’s worth of potential hazards and obstacles. Close to the turbulent star, solar storms are common. They can ruin a Space-Trucker’s Day by twisting and curling the Space-Road and forcing operators to steer their vehicle and cargo through them to maintain accurate navigation. A bit past the orbit of the blue-and-green jewel Tellus is another navigation hazard in the form of a dense asteroid belt.</p>
<p>In the real world, there’s no such thing as an asteroid belt thick enough to be a meaningful navigation hazard, but in the world of Space-Truckers, decades of asteroid mining operations have littered and set loose enough debris to make it a real problem for vessels aiming to pass through the rocky hazards. Past the asteroid belt lies the gas giant Zeus, the titan of planets in the Helios system, where a hive of industrial activity sparkles and glimmers around the clock. The busy factories require a constant supply of raw materials, spare parts, and supplies, and that’s where Space-Truckers come in. Getting straight to Zeus isn’t always as easy as it may seem, though.</p>
<p>Not <a id="_idIndexMarker400"/>content to confine their industries <a id="_idIndexMarker401"/>to merely the orbit of the giant planet, recent engineering projects at the leading and trailing LaGrange points take advantage of the rich resources present in the so-called <em class="italic">Trojan</em> and <em class="italic">Greek</em> families of asteroids. Anyone familiar with road construction knows the delays, detours, and occasional flag-waver directing traffic that has been diverted, and those construction zones are no different in space!</p>
<p>Past the glowing forges and factories of the Zeus system, things start to get dark and cold. The ice giant Janus sits at the gateway between the warm buzzing of activity of the inner system with the quiet darkness of the outer. Space-Truckers arrive and depart from the area on journeys to deliver stored energy gathered in the brightness sunward, departing with full loads of icy volatiles vital to sustaining life in the inner system. However, they are not alone out there – large herds of simple space-life roam these cold and distant plains. Not used to seeing visitors, they present a navigational hazard for the unwary Space-Trucker on the tail-end of a long haul. </p>
<p>Putting everything together, the following screenshot shows what the system looks like when the route planning begins:</p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="Figure 6.2 – The ReadyToLaunch phase of the route planning screen. This shows most of the actors involved, including the Star, destinationMesh, planets, launchArrow, and cargo&#13;&#10;" height="980" src="image/Figure_6.02_B17266.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The ReadyToLaunch phase of the route planning screen. This shows most of the actors involved, including the Star, destinationMesh, planets, launchArrow, and cargo</p>
<p>Now that<a id="_idIndexMarker402"/> we’ve looked at the system<a id="_idIndexMarker403"/> from the big picture perspective, it’s time to break out the individual actors and look for commonalities between them. This allows us to start creating game components that will help service the game concepts that in a way is kind of like putting together a list of job requirements.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>Actors and Their Behavior</h2>
<p>Before <a id="_idIndexMarker404"/>we get into the specifics of the different objects and components that will comprise the route planning screen, let’s take a look at what our object hierarchies look like concerning our game objects. The basic idea is that there are several pieces of data and behaviors that we know our game objects will need, but at the same time, we want to avoid writing repetitive code. We need to be able to update or advance the simulation, sometimes at a very fine-grained level, so we will generally avoid having components register their own <strong class="source-inline">onBeforeRender</strong> handlers and instead provide an <strong class="source-inline">update(deltaTime)</strong> method that will serve the same purpose. Here is one way of depicting how our various components interact with each other, with data, and with the application: </p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 6.3 – A class diagram of the Game Components involved in RoutePlanningScreen&#13;&#10;" height="634" src="image/Figure_6.03_B17266.jpg" width="1306"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A class diagram of the Game Components involved in RoutePlanningScreen</p>
<p>In the preceding <a id="_idIndexMarker405"/>diagram, the abstract hierarchy of classes is in the center. <strong class="source-inline">BaseGameObject</strong> is the least derived (for example, it doesn’t extend any other type), while the various classes for the game concepts are the most derived. <strong class="source-inline">RoutePlanningScreen</strong> hosts the various instances of those game component classes, managing their behavior in a fashion that is like the overall rendering pipeline:</p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<img alt="Figure 6.4 – The SpaceTruckerApplication update and render cycle, simplified&#13;&#10;" height="438" src="image/Figure_6.04_B17266.jpg" width="535"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The SpaceTruckerApplication update and render cycle, simplified</p>
<p>Each frame<a id="_idIndexMarker406"/> that the <strong class="source-inline">RoutePlanningScreen.update</strong> method is invoked by <strong class="source-inline">SpaceTruckerApplication</strong>, <strong class="source-inline">RoutePlanningScreen</strong> goes through its own child components and (optionally) calls their update methods. When all of those have been completed and <strong class="source-inline">RoutePlanningScreen</strong> has finished its update cycle, the screen is finally rendered. There are a few steps that are missing in this diagram, such as the before and after physics steps, but that is the mechanism for how our game’s underlying state can change and evolve. That’s how we describe the most primitive behavior needed by our game objects, so let’s use that knowledge to code it up!</p>
<h3>Abstracting the BaseGameObject Class</h3>
<p>The <strong class="source-inline">BaseGameObject</strong> class (see <a href="https://github.com/jelster/space-truckers/blob/ch6/src/baseGameObject.js">https://github.com/jelster/space-truckers/blob/ch6/src/baseGameObject.js</a> for its source) is what provides that shared, low-level <a id="_idIndexMarker407"/>functionality <a id="_idIndexMarker408"/>that we don’t want to have to duplicate across game objects. It is the least common denominator for any object that we may want to render in a <strong class="source-inline">Scene</strong>. Many of the properties of <strong class="source-inline">BaseGameObject</strong> are simple proxies that allow access to the underlying properties of the different Babylon.js components comprising the game object, such as the <strong class="source-inline">Vector3</strong> rotation property accessors:</p>
<pre class="source-code">&#13;
get rotation() { return this.mesh?.rotation; }&#13;
set rotation(value) { this.mesh.rotation = value; }</pre>
<p>In <a id="_idIndexMarker409"/>addition to <a id="_idIndexMarker410"/>consolidating access to the various component and data properties, <strong class="source-inline">BaseGameObject</strong> provides two crucial behaviors: <strong class="source-inline">update</strong> and <strong class="source-inline">dispose</strong>.</p>
<p><strong class="source-inline">update</strong> doesn’t seem to do much in this base class, since all it does is update the <strong class="source-inline">lastSceneTime</strong> property, but it’s an important role; many types of behaviors require tracking not just the amount of time since the last frame was rendered but also the previous value to properly integrate things such as velocity and acceleration.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If an extending class depends on the <strong class="source-inline">deltaTime</strong> and/or <strong class="source-inline">lastSceneTime</strong> value, make sure to call <strong class="source-inline">super.update(deltaTime)</strong> as the <em class="italic">first</em> thing it does in its <strong class="source-inline">update</strong> method.</p>
<p>For folks with<a id="_idIndexMarker411"/> experience in traditional <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) languages, the usage pattern might be familiar: an abstract base class provides common functionality to its more derived classes. An example of how this works is in the orbital mechanics simulation that we’ve implemented.</p>
<h3>Defining the Orbital Mechanics Simulation Elements</h3>
<p>The <strong class="source-inline">Planet</strong> class (covered shortly) builds<a id="_idIndexMarker412"/> off the <strong class="source-inline">OrbitingGameObject</strong> class (<a href="https://github.com/jelster/space-truckers/blob/ch6/src/orbitingGameObject.js">https://github.com/jelster/space-truckers/blob/ch6/src/orbitingGameObject.js</a>), which, in turn, is<a id="_idIndexMarker413"/> derived from the <strong class="source-inline">BaseGameObject</strong> prototype. <strong class="source-inline">OrbitingGameObject</strong> provides a base suite of data and behavior about the various calculations involved in both orbital motion and gravitational acceleration – the nerdy but interesting physics and math stuff we’d otherwise end up repeating across multiple places in the code base. Though it isn’t intended for objects of this type to be rendered directly, it would still be possible to do so by simply setting the <strong class="source-inline">mesh</strong> and <strong class="source-inline">material</strong> properties<a id="_idIndexMarker414"/> appropriately. The following table <a id="_idIndexMarker415"/>summarizes the data and behavior of <strong class="source-inline">OrbitingGameObject</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 6.5 – Summary of the behavior and data of the OrbitingGameObject component&#13;&#10;" height="1235" src="image/Figure_6.05_B17266.jpg" width="1646"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Summary of the behavior and data of the OrbitingGameObject component</p>
<p>By abstracting <a id="_idIndexMarker416"/>away<a id="_idIndexMarker417"/> the details of the orbital and gravitational calculations, more derived classes are much easier to understand, build, and maintain. A great example of how this can be leveraged is the <strong class="source-inline">Planet</strong> class.</p>
<h3>Implementing the Star and Planets</h3>
<p>The bulk<a id="_idIndexMarker418"/> of the constructor logic for the <strong class="source-inline">Planet</strong> class (<a href="https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/planet.js">https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/planet.js</a>) is devoted to the pertinent needs of reading the input <strong class="source-inline">planData</strong> and then instantiating and configuring the render-specific aspects of the component – tasks such as creating materials and loading and applying textures. Notice that there is no mention in<a id="_idIndexMarker419"/> the <strong class="source-inline">Planet</strong> class file of anything relating to our orbital simulation – only the specifics that make a given <strong class="source-inline">Planet</strong> instance different from another.</p>
<p>To aid in this effort, the class is data-driven: <strong class="source-inline">planData</strong> passed into the constructor function contains all the data needed. That’s the beauty of the mixed inheritance/composition patterns that we’ve been applying; each of our components only needs to concern itself with the specific tasks that it has been designed to accomplish and nothing more! As a result, this is what a typical <strong class="source-inline">planData</strong> looks like:</p>
<pre class="source-code">&#13;
{&#13;
        name: "tellus",&#13;
        posRadians: Scalar.RandomRange(0, 2 * Math.PI),&#13;
        posRadius: 750,&#13;
        scale: 30,&#13;
        color: new Color3(0.91, 0.89, 0.72),&#13;
        diffuseTexture: earthDiffuseUrl,&#13;
        normalTexture: earthNormalUrl,&#13;
        specularTexture: earthSpecularUrl,&#13;
        lightMapUrl: earthCloudsUrl,&#13;
        mass: 1e14&#13;
    } </pre>
<p>Perhaps <a id="_idIndexMarker420"/>this looks familiar? Back in <a href="B17266_02_Final_AM.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Ramping Up on Babylon.js</em>, we saw a very similar structure that was used to generate the orbiting planets of the Loading Screen – with a few new members (such as <strong class="source-inline">mass</strong>). Similarly, the <strong class="source-inline">Star</strong> class (https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/star.js) can be very short and sweet since although it does not orbit like other game objects, it does participate in gravitational calculations. </p>
<p>By setting <strong class="source-inline">autoUpdatePosition = false</strong>, the star will not move in its central position in the world space. This makes the constructor and subsequent class quite simple:</p>
<pre class="source-code">&#13;
constructor(scene, options) {&#13;
    super(scene, options);&#13;
    this.autoUpdatePosition = false;&#13;
    const starData = options;&#13;
    &#13;
    this.mesh = MeshBuilder.CreateSphere("star", &#13;
      { diameter: starData.scale }, this.scene);&#13;
    this.material = new StandardMaterial("starMat",&#13;
      this.scene);&#13;
    this.material.emissiveTexture = new&#13;
      Texture(starData.diffuseTexture, this.scene);&#13;
}</pre>
<p>The last <a id="_idIndexMarker421"/>two actors of our dramatis personae are the player’s avatar, also known as <strong class="bold">the cargo</strong>, and the hazardous collection of boulders that form the asteroid belt. We’ll cover the cargo later because we have a major new concept to cover first in the Asteroid Belt – <strong class="bold">Thin Instances</strong>. If you <a id="_idIndexMarker422"/>have a phobia of numbers and math (and it’s OK if you do!), fair warning – there be matrices and quaternions ahead, but there’s no need to worry – you won’t have to sweat any of the hard <em class="italic">maths</em>. All of the hard work and heavy thinking is done by functions in Babylon.js, so all we need to do is understand when and how to use them!</p>
<h3>Procedurally Generating the Asteroid Belt</h3>
<p>Before we talk <a id="_idIndexMarker423"/>about the particulars of the <strong class="source-inline">AsteroidBelt</strong> class (<a href="https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/asteroidBelt.js">https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/asteroidBelt.js</a>), we should review some definitions<a id="_idIndexMarker424"/> and concepts in the context of rendering meshes. Firstly, it’s important to understand <a id="_idIndexMarker425"/>what a <strong class="bold">mesh</strong> is at its simplest level. Starting with the simplest explanation, a mesh is a bunch of points set up in a particular order in 3D space. More in-depth, a mesh is a collection of points in 3D space that can be positioned, rotated, and scaled together. To describe it in extremely precise terms, a mesh is an array of vectors grouped as a set of matrices that represent the position, translation, and rotation of each part of the 3D model, respectively. While a mesh’s geometry is sent to the GPU once, that same geometry can be linked (reused) by the GPU to render as many additional instances as are required.</p>
<p>In the case of regular instances, it is important to understand that although the mesh geometry is not duplicated in the GPU, there is still a CPU (JavaScript) overhead stemming from the need to iterate over each instance every frame for processing. That’s the price of being able to retain control over individual instances, but some situations may not require that much control. That’s where Thin Instances come into play.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you’ve used 3D Modeling tools such as Blender, Thin Instances in Babylon.js are referred to as linked objects in Blender.</p>
<p>The <a id="_idIndexMarker426"/>essential concept that we’re <a id="_idIndexMarker427"/>focusing on here is the idea that there are circumstances where we might need hundreds, thousands, or even tens of thousands of individual copies of a given mesh to be rendered in a particular Scene, but we don’t want to incur the memory or CPU overhead of having to process and maintain multiple copies of that mesh’s geometry. Think trees in a forest (for example, <a href="https://playground.babylonjs.com/%23YB006J%2375">https://playground.babylonjs.com/#YB006J#75</a>), or an ocean comprised of LEGO® (for example, <a href="https://playground.babylonjs.com/%23TWQZAU%233">https://playground.babylonjs.com/#TWQZAU#3</a>), or, as is relevant to our case, a large number of asteroids – giant, floating space rocks (for example, <a href="https://playground.babylonjs.com/%235BS9JG%2359">https://playground.babylonjs.com/#5BS9JG#59</a> – with a tip of the hat to Babylon.js community member <em class="italic">Evgeni_Popov</em>).</p>
<p>The key limitations<a id="_idIndexMarker428"/> to keep in mind when thinking about (Thin) Instances are as follows:</p>
<ul>
<li>All instances, Thin or not, must share the same Material</li>
<li>Although much more efficient than cloning a mesh, Instances are still both CPU- and GPU-bound</li>
<li>For Thin Instances, you must manipulate an individual Instance’s properties (for example, position, scaling, rotation, and so on) by manually manipulating the specific Instance’s matrix values</li>
<li>All Thin Instances are always drawn (or not) – there is no way to hide or skip the rendering of an individual Thin Instance</li>
<li>Thin Instances check collisions as a single, giant mesh; there is no way to register collision detection for individual Instances</li>
</ul>
<p>Even with those limitations in mind, it makes sense to use Thin Instances to render the Asteroid Belt – we want at least a thousand (or so...) of them, so we don’t need to exercise much control over them, and since we want them to look relatively homogenous, it’s OK for them to share the<a id="_idIndexMarker429"/> same Material. We’ll get more into the Material we’ll use for the asteroids later, so for now, let’s look at how we are creating each asteroid’s Thin Instance through the power of Analogy.</p>
<p class="callout-heading">Important note</p>
<p class="callout">We are operating under the assumption that an instance has the same sign for its scaling, position, and rotation components (this is known in matrix jargon as having the same sign <em class="italic">determinant</em>). You should not directly mix elements with opposite signs. For example, the following statement results in a mixed determinant sign:</p>
<p class="callout"><strong class="source-inline">Matrix.Compose(new Vector3(-1, 1, 1),Quaternion.Identity(), newVector3(2, 1, 0))</strong></p>
<p class="callout">This is because the negative sign in the first argument conflicts with the positive <strong class="source-inline">1</strong> that an Identity Quaternion represents.</p>
<p>Astrophysicists<a id="_idIndexMarker430"/> who study black holes have an interesting way of describing the properties of their scientific studies.</p>
<p>The idea is that, any given black hole only has three observable properties – electric charge, mass, and spine that uniquely defines it, whereas things like people, stars and plants, have quite a few additional attributes making them – and you – uniquely special. Like<a id="_idIndexMarker431"/> this <strong class="bold">no-hair theorem</strong>, as it’s called, each Thin Instance of our asteroid will be distinguished apart from its brethren by just their properties of <strong class="bold">position</strong>, <strong class="bold">rotation</strong>, and <strong class="bold">scale</strong>. We will define values for each of these properties, for each instance individually, storing the arrays as class members. Thus, the algorithm for generating the asteroids can be relatively quite simple: declare the matrices, quaternions, rotations, scalings, and position arrays. Then, allocate a <strong class="source-inline">Float32Array</strong> to use as the matrix buffer. The size should be nine times the count of asteroids to create to hold the resulting data.</p>
<p>For every asteroid that we want to create, we must do the following:</p>
<ol>
<li>Generate a set of three vectors, one each for the position, rotation, and scale.</li>
<li>Randomly set the component values of each vector to a number in limits.</li>
<li>Add the new vectors to their respective arrays.</li>
<li>Create and add a new, empty Quaternion, Matrix to arrays. </li>
<li>Convert the rotation vector into a Quaternion.</li>
<li>Use vectors and quaternions to compose the Matrix.</li>
<li>Copy the matrix elements to the matrix buffer.</li>
<li>Set the <strong class="source-inline">thinInstance</strong> buffer on the target mesh to the instance from the matrix buffer.</li>
</ol>
<p>When we <a id="_idIndexMarker432"/>randomly generate the <a id="_idIndexMarker433"/>values, we need to ensure that the values are all within valid parameters, and we can do this in several different ways. The first is used for the scaling and rotational vector values and helps to create the rough, rock-shaped surface of what started as a smooth <strong class="source-inline">IcoSphere</strong> mesh. Because <strong class="source-inline">Math.random()</strong> returns a floating-point number between zero and one, we scale that number out by a factor representing the maximum in the range of values we want to see generated – in other words, when the random value is equal to one.</p>
<p>Since it’s also possible to get zero as a value, the scale has an additional additive constant to ensure at least a minimum value. A similar, though more simple expression, generates rotations for each axis. The scaling <strong class="source-inline">Vector3</strong> works well for defining the scale and rotation of the asteroid instance, but specifying the position requires another approach.</p>
<p>Once again, we must shift from thinking in linear terms to that of angular. Using the Babylon.js <strong class="source-inline">Scalar.RandomRange()</strong> utility function, we can generate a random point somewhere in the torus (donut shape) by defining <strong class="source-inline">innerBeltRadius</strong> and <strong class="source-inline">outerBeltRadius</strong> – that is, we generate a random number (<strong class="source-inline">rTheta</strong>) that is then combined with another random number between 0 and 2 * π.</p>
<p class="callout-heading">Note</p>
<p class="callout">Recall that the sine and cosine functions take their inputs in radians, and a full circle is described by 2 * π or approximately 6.28319 radians.</p>
<p>The <em class="italic">X</em> and <em class="italic">Z</em>-axis values<a id="_idIndexMarker434"/> for the world position of the asteroid are computed by converting the radial (angular) value into world coordinates – for example, <strong class="source-inline">Math.sin(theta)</strong> or <strong class="source-inline">Math.cos(theta)</strong> – which yields a normalized value, then multiplying that by our randomized scale constant to properly place the object in the world. Because we are using a very simplified mathematical model to distribute the asteroids in space, we can treat the vertical <em class="italic">Y</em>-axis by multiplying half of a random number by the density configuration constant:</p>
<pre class="source-code">&#13;
this.positions.push(new Vector3(&#13;
    Math.sin(theta) * rTheta,&#13;
    (Math.random() - 0.5) * density,&#13;
    Math.cos(theta) * rTheta&#13;
));</pre>
<p>Updating <a id="_idIndexMarker435"/>an asteroid’s rotation, position, or scale is a two-step process. The first step is for the <strong class="source-inline">AsteroidBelt</strong> class to modify values in the desired array at the index corresponding to the desired asteroid instance. In the update loop, each asteroid’s rotation values are tweaked by a small random amount by modifying <strong class="source-inline">this.rotations[i]</strong>.</p>
<p>Once that has been completed, the second step is the same as the original generation algorithm, conveniently factored out into the <strong class="source-inline">updateMatrices</strong> function of the class. The only difference between creating and updating the thin instance data is that when we update, we use <strong class="source-inline">mesh.thinInstanceBufferUpdated</strong> instead of <strong class="source-inline">mesh.thinInstanceSetBuffer</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more on the technical aspects of using Babylon.js with meshes, Instances, and the GPU, see the official docs at <a href="https://doc.babylonjs.com/divingDeeper/mesh/copies/instances">https://doc.babylonjs.com/divingDeeper/mesh/copies/instances</a> and <a href="https://doc.babylonjs.com/divingDeeper/mesh/copies/thinInstances">https://doc.babylonjs.com/divingDeeper/mesh/copies/thinInstances</a>.</p>
<p>It is finally time to put everything we’ve been looking at together into one and begin our examination of the<a id="_idIndexMarker436"/> actual <strong class="bold">Route Planning Screen</strong>. Although it may seem a bit confusing <a id="_idIndexMarker437"/>due to an apparent lack of <em class="italic">big-picture focus</em>, we didn’t have the proper context established yet <a id="_idIndexMarker438"/>to take that picture in. Still, it can be difficult to follow along with this type of overview, so here’s yet another occasion where the PG comes in handy. As shown previously, this snippet (<a href="https://playground.babylonjs.com/%235BS9JG%2359">https://playground.babylonjs.com/#5BS9JG#59</a>) is a preliminary, basic implementation of the planet simulation, and although not 100% identical to the game’s code, it’s illustrative of all the concepts described previously, as well as some we have yet to cover!</p>
<h3>Adding the CargoUnit Class</h3>
<p>The <strong class="source-inline">CargoUnit</strong> class<a id="_idIndexMarker439"/> is this <a id="_idIndexMarker440"/>part of the game’s projection of the player into the game world. It derives from <strong class="source-inline">OrbitingGameObject</strong>, but it does not automatically have its position updated – just like the <strong class="source-inline">Star</strong> class we just finished looking at. Unlike the <strong class="source-inline">Star</strong> class, there’s a little bit more happening.</p>
<p>Starting with the data, the <strong class="source-inline">CargoUnit</strong> class tracks several pieces of game-specific in-flight information, such as <strong class="source-inline">timeInTransit</strong> and <strong class="source-inline">distanceTraveled</strong>. The <strong class="source-inline">isInFlight</strong> Boolean flag is implicitly correlated with <strong class="source-inline">PLANNING_STATE.InFlight</strong>, if that wasn’t apparent already. These and other pieces of data are consumed by both <strong class="source-inline">RoutePlanningScreen</strong> and <strong class="source-inline">PlanningScreenGui</strong> (more on that later) and get updated as part of the hopefully now-familiar update method pattern shown in the following code.</p>
<p>During the update, there is some logic to point the cargo unit’s rotation in the direction of flight, which involves a tiny bit of vector math, but more importantly, there is logic to apply the current frame’s accumulated gravitational forces to the box. Since force is calculated in terms of effect per second, it must be scaled to the amount of time that has passed since the last frame, using <strong class="source-inline">deltaTime</strong>. After the force is applied, we clear the <strong class="source-inline">currentGravity</strong> field to prevent forces from infiltrating across rendered frames:</p>
<pre class="source-code">&#13;
update(deltaTime) {&#13;
        super.update(deltaTime);&#13;
        if (this.isInFlight) {&#13;
            this.lastGravity = this.currentGravity.clone();&#13;
            const linVel =&#13;
              this.physicsImpostor.getLinearVelocity();&#13;
            this.lastVelocity = linVel.clone();&#13;
            linVel.normalize();&#13;
            this.timeInTransit += deltaTime;&#13;
            this.distanceTraveled +=&#13;
              this.lastVelocity.length() * deltaTime;    &#13;
            &#13;
            this.rotation = Vector3.Cross(this.mesh.up,&#13;
              linVel);&#13;
            this.physicsImpostor.applyImpulse(this.&#13;
              currentGravity.scale(deltaTime),&#13;
              this.mesh.getAbsolutePosition());&#13;
            this.currentGravity = Vector3.Zero();&#13;
        }&#13;
    }</pre>
<p>A vector cross-product<a id="_idIndexMarker441"/> is a mathematical operation that takes two orthogonal vectors (that is, two vectors perpendicular <a id="_idIndexMarker442"/>to each other) and yields a third, new vector that points in a direction perpendicular to <em class="italic">both</em> of the inputs. By inputting the (normalized) physical velocity of <strong class="source-inline">cargoUnit</strong> along with the local <em class="italic">Up</em> axis, we are given the resulting rotational coordinates that <strong class="source-inline">cargoUnit</strong> must adopt to point itself in the direction of travel.</p>
<p class="callout-heading">Note</p>
<p class="callout">A force applied to an asymmetrically massed body such as <strong class="source-inline">cargoUnit</strong> will cause angular rotation, or torque, causing the unit to spin wildly around its center of mass. This is not as bad as the game crashing, but not great, especially when paired with <strong class="source-inline">TrailMesh</strong>! By setting the rotation to point in the direction of travel, we are ensuring that gravitational forces transfer to the unit’s linear – not angular – velocity. Also, we prevent <strong class="source-inline">TrailMesh</strong> from twisting itself up into knots – a factor that is critical when generating the next phase’s route.</p>
<p>Defining the<a id="_idIndexMarker443"/> CargoUnit’s behaviors is the last thing to cover before we shift focus. In addition to the update behavior, only three other actions are implemented by the class.</p>
<p>The <strong class="source-inline">reset</strong>, <strong class="source-inline">launch</strong>, and <strong class="source-inline">destroy</strong> actions are fairly self-explanatory from their names. The <strong class="source-inline">reset</strong> method is called any time the simulation is being restarted, such as when the player presses the <em class="italic">Delete</em> key on their keyboard. It clears all of the stored state data from <strong class="source-inline">CargoUnit</strong> before moving itself back to its initial start location and setting the <strong class="source-inline">isInFlight</strong> flag to <strong class="source-inline">false</strong>. The <strong class="source-inline">launch</strong> function is where <strong class="source-inline">TrailMesh</strong> is instantiated, along with the initial <em class="italic">kick</em> from the launcher; it is responsible for setting the <strong class="source-inline">isInFlight</strong> flag appropriately. Lastly, the <strong class="source-inline">destroyed</strong> function is called whenever <strong class="source-inline">SpaceTruckerApplication</strong> has determined that <strong class="source-inline">CargoUnit</strong> has been officially <em class="italic">destroyed</em>, for example, when encountering an obstacle that is not amused by the impact. It is responsible for making sure that <strong class="source-inline">CargoUnit</strong> doesn’t fly off at infinite velocity after a collision and instead stays put where it is.</p>
<p>That was <a id="_idIndexMarker444"/>certainly a large number of different concepts and classes to go over in such a short space, but there is so much more to see we can’t possibly stay on this topic any longer. We have mentioned several times that we would eventually go into some detail regarding how the flight mechanics are implemented with the physics engine, and we’ve almost got to the point where we can create a critical mass of contextual knowledge. This knowledge will propel us toward a greater understanding and progress – hang in there!</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/>Establishing the Basic Route Planning Screen</h2>
<p>Of all the<a id="_idIndexMarker445"/> different things we’ve <a id="_idIndexMarker446"/>worked on to date in Space-Truckers, <strong class="source-inline">SpaceTruckerPlanningScreen</strong> (<a href="https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/spaceTruckerPlanningScreen.js">https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/spaceTruckerPlanningScreen.js</a>) is by far the most complex. We’ve come prepared to manage that complexity by looking at the individual components first; with fewer things to have to try and keep track of, it’s much easier to stay focused on the topic at hand. Let’s break down the different aspects of the screen to make it a bit more manageable. There<a id="_idIndexMarker447"/> are three basic categories or facets that we’ll focus on – this should start to be getting familiar by now – data, behavior, and state transitions. Each has a distinct role to play, and by understanding each, in turn, we will be prepared to take the next steps toward creating the simulation.</p>
<h3>Developing the Data</h3>
<p>A lot of different <a id="_idIndexMarker448"/>pieces of data are needed to both run the simulation and embody the game mechanics. Some of them, such as <strong class="source-inline">launchForce</strong>, <strong class="source-inline">origin</strong>, and <strong class="source-inline">cargo</strong>, deal with the game mechanics, while others, such as the <strong class="source-inline">planets</strong> array and the <strong class="source-inline">asteroidBelt</strong> and <strong class="source-inline">star</strong> objects, store information needed for the gravitational simulation. <strong class="source-inline">onStateChangeObservable</strong> is used by other components (for example, the <strong class="source-inline">PlanningScreenGui</strong> class at <a href="https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/route-plan-gui.js">https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/route-plan-gui.js</a>) to respond to changes in the <strong class="source-inline">gameState</strong> property, an enumeration value of one of the <strong class="source-inline">PLANNING_STATE</strong> keys:</p>
<pre class="source-code">&#13;
static PLANNING_STATE = Object.freeze({&#13;
        Created: 0,&#13;
        Initialized: 1,&#13;
        ReadyToLaunch: 2,&#13;
        InFlight: 3,&#13;
        CargoArrived: 4,&#13;
        GeneratingCourse: 6,&#13;
        CargoDestroyed: 7,&#13;
        Paused: 8&#13;
    });</pre>
<p>Rounding out the defined data for this Screen is <strong class="source-inline">preFlightActionList</strong> (see <a href="B17266_05_Final_AM.xhtml#_idTextAnchor103"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding a Cut Scene and Handling Input</em>), which specifies the names of the input actions this class should handle, as well as whether the input should be <em class="italic">bounced</em>, or prevented from repeating for a brief time:</p>
<pre class="source-code">&#13;
const preFlightActionList = [&#13;
    { action: 'ACTIVATE', shouldBounce: () =&gt; true },&#13;
    { action: 'MOVE_OUT', shouldBounce: () =&gt; false },&#13;
    { action: 'MOVE_IN', shouldBounce: () =&gt; false },&#13;
    { action: 'GO_BACK', shouldBounce: () =&gt; true },&#13;
    { action: 'MOVE_LEFT', shouldBounce: () =&gt; false },&#13;
    { action: 'MOVE_RIGHT', shouldBounce: () =&gt; false },&#13;
]; </pre>
<p>In this <a id="_idIndexMarker449"/>particular instance, our actions will be linked to the previously mentioned factors such as <strong class="source-inline">launchForce</strong>, allowing players to choose their launch direction, timing, and speed using whatever input method has been configured – except for touch and visual controls (those must be created and hosted in the GUI).</p>
<p>As you may expect, the constructor is where the majority of the Screen’s objects are initialized. Game Components such as <strong class="source-inline">soundManager</strong>, <strong class="source-inline">actionProcessor</strong>, <strong class="source-inline">camera</strong>, <strong class="source-inline">lights</strong>, <strong class="source-inline">skybox</strong>, and so on are all created and configured there. For lighting, we use a <strong class="source-inline">PointLight</strong> with the intensity cranked up to a cool ten million – the vastness of space is dark – and we want to make sure the light of <strong class="source-inline">star</strong> can light up the scene in the way we want. That covers many of the familiar happenings occurring in the constructor, but there’s a lot more going on that falls outside of the familiar.</p>
<h3>Driving Behavior with Data</h3>
<p>An important factor<a id="_idIndexMarker450"/> driving the code design is the need to drive the behavior of the simulation via data as much as possible (without going overboard). This means that instead of hardcoding values directly into <strong class="source-inline">SpaceTruckerPlanningScreen</strong>, we define the <strong class="source-inline">gameData</strong> file to hold our configuration values. By reading through the configuration data passed into the constructor, it is easy to run the simulation using arbitrary, easily changed values (more on refactoring to accommodate iteration will be covered shortly). Factors such as the origin planet and the destination planet are stored in <strong class="source-inline">gameData</strong>, along with physical information about the system (for example, <strong class="source-inline">PrimaryReferenceMass</strong>, or how much the central star weighs).</p>
<p>Some <a id="_idIndexMarker451"/>components of <strong class="source-inline">SpaceTruckerPlanningScreen</strong> are defined internally to the class. An example of this is the <strong class="source-inline">launchArrow</strong> mesh, which was created using a combination of the <strong class="source-inline">arrowLines</strong> <strong class="source-inline">Vector3 array</strong>, and <strong class="source-inline">MeshBuilder.CreateDashedLines</strong> functions, which returns a mesh from a passed-in array of points. Other meshes are much simpler, such as <strong class="source-inline">destinationMesh</strong> – a sphere parented to a <strong class="source-inline">Planet</strong> that’s used for visual and collision purposes.</p>
<p>Preparing for the implementation of the game mechanics is part of our task here, so we will create and set up <strong class="source-inline">destinationMesh</strong> with an <strong class="source-inline">ActionManager</strong> that will look out for intersections with <strong class="source-inline">cargo.mesh</strong> (the player’s cargo unit), invoking the <strong class="source-inline">cargoArrived</strong> function if that does happen:</p>
<pre class="source-code">&#13;
this.destinationMesh.actionManager = new ActionManager(this.scene);&#13;
this.destinationMesh.actionManager.registerAction(&#13;
   new ExecuteCodeAction(&#13;
       {&#13;
           trigger:&#13;
             ActionManager.OnIntersectionEnterTrigger,&#13;
           parameter: this.cargo.mesh&#13;
       },&#13;
       (ev) =&gt; {&#13;
           console.log('mesh intersection triggered!', ev);&#13;
           this.cargoArrived();&#13;
       }&#13;
   ));</pre>
<p>The purpose of <strong class="source-inline">cargoArrived</strong> is to set the current state for <strong class="source-inline">Screen</strong>, along with any other needed state-change-related actions to stop the simulation. For now, this is enough, but later, we will be adding additional behavior to this function. </p>
<p>Similar<a id="_idIndexMarker452"/> to how <strong class="source-inline">SpaceTruckerApplication</strong> takes different sets of actions in its per-frame <strong class="source-inline">update</strong> method, (see <a href="B17266_03_Final_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, <em class="italic">Establishing the Development Workflow</em>), switching on <strong class="source-inline">currentState</strong> to control its behavior, <strong class="source-inline">SpaceTruckerPlanningScreen</strong> does so as well. The first thing to do is calculate the number of milliseconds since the last time the frame was rendered, which we can do using the <strong class="source-inline">deltaTime</strong> parameter (for testing) or retrieve using <strong class="source-inline">scene.getEngine().getDeltaTime()</strong> if missing. After that, <strong class="source-inline">actionProcessor</strong> updates its list of inputs and mappings to actions. Now, it’s time to <strong class="source-inline">switch</strong> on <strong class="source-inline">gameState</strong>:</p>
<pre class="source-code">&#13;
switch (this.gameState) {&#13;
    case SpaceTruckerPlanningScreen.PLANNING_STATE.Created:&#13;
        break;&#13;
    case SpaceTruckerPlanningScreen.&#13;
        PLANNING_STATE.ReadyToLaunch:&#13;
        this.star.update(dT);&#13;
        this.planets.forEach(p =&gt; p.update(dT));&#13;
        this.asteroidBelt.update(dT);&#13;
        this.cargo.update(dT);&#13;
        this.cargo.position = this.origin.position.clone().&#13;
          scaleInPlace(1.1, 1, 1);&#13;
        break;&#13;
    case SpaceTruckerPlanningScreen.&#13;
        PLANNING_STATE.InFlight:&#13;
        this.star.update(dT);&#13;
        this.planets.forEach(p =&gt; p.update(dT));&#13;
        this.asteroidBelt.update(dT);&#13;
        this.cargo.update(dT);&#13;
        let grav =&#13;
          this.updateGravitationalForcesForBox(dT);&#13;
        this.cargo.physicsImpostor.applyImpulse(grav,&#13;
          this.cargo.mesh.getAbsolutePosition());&#13;
        break;&#13;
    // ...and so on&#13;
}</pre>
<p>Looking at the<a id="_idIndexMarker453"/> statement, it’s easy to see that when <strong class="source-inline">gameState</strong> is in the <strong class="source-inline">ReadyToLaunch</strong> or <strong class="source-inline">InFlight</strong> stages, the various celestial bodies get their <strong class="source-inline">update</strong> methods called. In other words, the simulation is only advanced when the game state is either <strong class="source-inline">ReadyToLaunch</strong> or <strong class="source-inline">InFlight</strong>. This brings up the overall question of how we will implement the signature feature of this Screen: <strong class="bold">the orbital mechanics simulation</strong>.</p>
<h3>Transitioning States</h3>
<p>As implied<a id="_idIndexMarker454"/> in the previous discussion about the <strong class="source-inline">cargoArrived</strong> function, changes in the Screen’s <strong class="source-inline">gameState</strong> are triggered by <strong class="source-inline">cargoArrived</strong> and similar functions. Here is a summary of the different state changes, the functions initiating the change, and their usage:</p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<img alt="" height="974" src="image/Table_6.01_B17266.jpg" width="1650"/>
</div>
</div>
<p>Except<a id="_idIndexMarker455"/> for the <strong class="source-inline">setReadyToLaunchState</strong> function, all of the state changes in this Screen arise from either events happening in the game or via direct user input. The reason that <strong class="source-inline">setReadyToLaunchState</strong> is the exception is that while the Screen is created as part of the overall application initialization process, certain things can’t happen until the Scene is being rendered. In addition, we need to be able to arbitrarily reset the screen to its initial state so that players don’t have to restart the entire application when they want to try a new route. Here’s what a very basic success route looks like with the <strong class="source-inline">CargoArrived</strong> state:</p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<img alt="Figure 6.6 – The Route planning screen after a successful cargo arrival at the Destination planet. The trail mesh shows the path of the cargo from start to finish" height="1007" src="image/Figure_6.06_B17266.jpg" width="1519"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The Route planning screen after a successful cargo arrival at the Destination planet. The trail mesh shows the path of the cargo from start to finish</p>
<p>On the topic of <a id="_idIndexMarker456"/>routes, it can be difficult at first to figure out how to get a successful cargo launch, so here is a quick tip – aim in the opposite (retrograde) direction to the direction of the orbital motion to get a more direct flight path. As depicted in the preceding screenshot, you can see the trail of the cargo unit going in a counterclockwise direction to the camera while the planets all orbit clockwise. </p>
<p>Understanding the three facets we examined for the Route Planning Screen helps make the connection between the inputs and how the application should behave as a result (its outputs). Behaviors are defined to be dependent upon data to drive the specifics of that behavior. Game data specifies how far planets might orbit from their star, their mass, and more, but the application state is what ultimately controls and decides whether and how much to move them in their celestial dance.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor132"/>Creating the Orbital Mechanics Simulation</h1>
<p>When <a id="_idIndexMarker457"/>thinking about the various components involved in <strong class="source-inline">SpaceTruckerPlanningScreen</strong>, it’s important to consider how the simulation runs. Every frame (actually, it could be potentially more than once per frame, but for simplicity’s sake, we’ll go with once per frame), the physics simulation updates its own internal state. That state is largely opaque to us – though if needed we can always access it – but is manifested through the post-physics step changes that are made to an object’s position and/or rotation. To make our <strong class="source-inline">CargoUnit</strong> perform the necessary gravitational boogie, we need to tell the physics simulation the force it should impart, calculated from the accumulated gravitational forces of the system.</p>
<p>Though very similar in appearance, the <strong class="source-inline">InFlight</strong> game state has two major differences from <strong class="source-inline">ReadyToLaunch</strong>: when we are <strong class="source-inline">InFlight</strong>, we want the cargo to be affected by the gravity of all the different massive bodies in the system. To keep things tidy, we wrap up the task of summing together all these forces into the <strong class="source-inline">updateGravitationalForcesForBox</strong> function:</p>
<pre class="source-code">&#13;
updateGravitationalForcesForBox(timeStep) {&#13;
    const cargoPosition = this.cargo.position;&#13;
    let summedForces =&#13;
      this.star.calculateGravitationalForce(cargoPosition);&#13;
    this.planets.forEach(p =&gt; summedForces.addInPlace(p.&#13;
      calculateGravitationalForce(cargoPosition)));&#13;
    return summedForces.scaleInPlace(timeStep);&#13;
}</pre>
<p>What’s nice about this function is that it can leverage the base functionality provided by <strong class="source-inline">OrbitingGameObject</strong> to obtain each component’s contribution to the overall forces experienced by the cargo unit, even though we are mixing different types of objects such as <em class="italic">stars</em> and <em class="italic">planets</em>. The returned <strong class="source-inline">Vector3</strong> is passed to <strong class="source-inline">physicsImpostor</strong> (see the <em class="italic">Understanding the Physics</em> section) as an impulsive <em class="italic">shove</em> imparted to the cargo object. From there, we let the physics engine take over the task of updating the CargoUnit’s position and velocity.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>Understanding the Physics</h2>
<p>Most people <a id="_idIndexMarker458"/>are familiar with the apocryphal story of how Isaac Newton came up with his Theory of Gravity after getting hit on the head by a falling apple, and of how he changed how we think about the world we live in and the universe we inhabit. We don’t need to have memorized the equations to experience the effects of gravity – being a law of nature and all, it doesn’t care one way or another how someone feels about it. Stars wheel and twinkle around the night sky as planets spin in a celestial dance, and all of it – at least from the viewpoint of a 17th-century scientist – can be described with just a few equations.</p>
<p class="callout-heading">Important note</p>
<p class="callout">We will be diving a bit into some physics and algebra here, but greatly simplified from what a more realistic simulation would require. For example, by assuming that our planets all have perfectly circular orbits, we obviate the need to implement the more complicated equations needed to support elliptical ones. Another example of how we’re simplifying this is that the force calculations are only being performed on <strong class="source-inline">cargoUnit</strong> and not between each massive body, as would be the case in the real world.</p>
<p>The first and most fundamental is known as Newton’s First Law of Motion. It describes the relationship between an object, a force applied to that object, and the object’s resistance to being accelerated – its inertia: </p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<img alt="Figure 6.7 – Newton’s First Law of Motion. The force (a vector) on an object is equal to the object’s mass times its current acceleration. This is commonly re-arranged to solve for either m or a unknowns&#13;&#10;" height="19" src="image/Figure_6.07_B17266.jpg" width="50"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Newton’s First Law of Motion. The force (a vector) on an object is equal to the object’s mass times its current acceleration. This is commonly re-arranged to solve for either m or a unknowns</p>
<p>Since force is what we ultimately want to calculate when we are running the simulation, we can replace the left-hand side of the preceding equation with the following equation. The two values for the object’s mass cancel each other out, leading to a rather curious conclusion – the only mass that matters for our calculations is the mass of the larger body. The mass of <strong class="source-inline">cargoUnit</strong> does not factor in at all:</p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<img alt="Figure 6.8 – Newton’s Law of Universal Gravitation. Implemented in OrbitingGameObject. The value of the Gravitational Constant (G) has been experimentally verified to many decimal places&#13;&#10;" height="31" src="image/Figure_6.08_B17266.jpg" width="235"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Newton’s Law of Universal Gravitation. Implemented in OrbitingGameObject. The value of the Gravitational Constant (G) has been experimentally verified to many decimal places</p>
<p>In<a id="_idIndexMarker459"/> conversational language, the equation can be phrased thus: the force (<em class="italic">F</em>) experienced by an object of a given mass (<em class="italic">m1</em>) at a distance of <em class="italic">r</em> from another mass (<em class="italic">m2</em>) is equal to a constant value (<em class="italic">G</em>), times the product of the two masses divided by the square of the distance between them. In computational terms, we separately compute the direction of the force (via a vector subtraction of the two object’s positions) and its magnitude (via the preceding equation), or scale, before combining and returning a final result vector.</p>
<p>The choice of units can be arbitrary but must be consistent; the metric system is assumed throughout this text because sanity is a prized possession and should be treasured. Therefore, masses are in kilograms, and the radius is in meters. This makes the resulting Force a value with units of <img alt="" height="17" src="image/Formula_6.01_B17266.png" width="65"/>. Put alternatively, this is the measure of how fast a 1 kg mass is accelerated in 1 second by the applied force and is known as the N, or Newton, for obvious reasons. What is much less obvious are some of the implications of the equation.</p>
<p>First, the force, <em class="italic">F</em>, is a vector value, not a scalar. This means that there are both direction and magnitude components to the force.</p>
<p>Second, unlike electrical and magnetic forces, which have positive or negative <em class="italic">charges</em>, gravity is always positive. Because mathematicians are constantly trying to prove their theory that they have a sense of humor, this fact is denoted in the equation by the negative sign, indicating that objects are always pulled toward the gravitational mass, never pushed away.</p>
<p>Third, the force experienced by the object is dictated by the sum of all the forces from each mass capable of influencing the object. This means that the overall force may be lessened to a degree or even canceled out altogether from equal or stronger resulting forces at opposing positions from the object under scrutiny.</p>
<p>A final note on this topic aimed at those who might have some knowledge of calculus and numerical integration: though our time step between physics calculations may be around 1/60th of a second, the straightforward integration via summation is inherently inaccurate. It is accurate enough, however, to allow the simulation to exhibit the type of emergent behavior that we’re looking to see using our simplified orbital physics model. The full implementation of the gravitational force calculation for a single pair of bodies is contained in <strong class="source-inline">OrbitingGameObject.calculateGravitationalForce(position)</strong>. The code can also be viewed at <a href="https://github.com/jelster/space-truckers/blob/8a8022b4cac08f1df9e4c7cfc8ff7c6275c71558/src/orbitingGameObject.js#L72">https://github.com/jelster/space-truckers/blob/8a8022b4cac08f1df9e4c7cfc8ff7c6275c71558/src/orbitingGameObject.js#L72</a>.</p>
<p>Hopefully, that <a id="_idIndexMarker460"/>little digression into abstract equations wasn’t too intimidating, because that was the worst of it (for now…) and understanding how those equations are structured helps to clarify the simulation’s <strong class="source-inline">InFlight</strong> behavior. But before the simulation can perform any <strong class="source-inline">InFlight</strong> calculations, the physics engine and the data it depends upon must be initialized and configured.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/>Driving the Simulation’s Physics</h2>
<p>The <a id="_idIndexMarker461"/>Babylon.js distribution contains built-in support for four separate physics engines: <strong class="bold">Cannon</strong>, <strong class="bold">Oimo</strong>, <strong class="bold">Energy</strong>, and <strong class="bold">Ammo</strong>. Each of <a id="_idIndexMarker462"/>them has <a id="_idIndexMarker463"/>pros and cons, and <a id="_idIndexMarker464"/>though not perfect, the <strong class="bold">Ammo</strong> physics library<a id="_idIndexMarker465"/> is what is being used in Space-Truckers. The choice comes down to an individual project’s needs and the developer’s preferences, but there are some practical matters relating to the developer’s experience that are worth understanding.</p>
<p>The team behind Babylon.js is fiercely dedicated to maintaining backward-compatibility support for users. As we discussed in <a href="B17266_03_Final_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, <em class="italic">Establishing the Development Workflow</em>, the Babylon.js ES6 libraries retain some of the prior versions’ patterns in use at the time, such as the use of side-effect only <strong class="source-inline">import</strong> statements. Further complicating matters is the fact that the Babylon.js team doesn’t own or maintain any of the physics engines themselves – only the Babylon.js plugin wrapper for the library – yet the CDN and <em class="italic">full</em> Babylon.js distributions come bundled with all supported engines.</p>
<p>Because the point of tree-shaking with ES6 modules is to only package and load the source files needed, it is necessary to add a <strong class="source-inline">package.json</strong> reference to one or more physics engines. Unfortunately, none of the libraries with available Babylon.js plugins currently have a trusted, verified, and up-to-date package published to the NPM, but the GitHub repository for Ammo shows the most consistent activity over the last few years, indicating that it is likely to continue active development on updates, bug fixes, and feature enhancements, which is where Node’s support for referencing a package directly from a GitHub repository is very handy.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The initialization of the Ammo.js physics library is <strong class="bold">asynchronous</strong> (this is a breaking change from the previous 4.X version of the library), meaning that it is necessary to resolve or somehow <strong class="source-inline">await</strong> the Ammo promise. To ensure that the library has been properly initialized and loaded, a wrapper is needed. The <strong class="source-inline">/src/externals/ammoWrapper.js</strong> module first imports the <strong class="source-inline">ammo.js</strong> library, and exports two variables: <strong class="source-inline">ammoModule</strong> itself along with an <strong class="source-inline">ammoReadyPromise</strong> that populates <strong class="source-inline">ammoModule</strong> before resolving.</p>
<p class="callout">In <strong class="source-inline">SpaceTruckerPlanningScreen</strong>, <strong class="source-inline">ammoReadyPromise</strong> is imported and resolved as part of the constructor logic, ensuring that by the time <strong class="source-inline">initializePhysics</strong> is called, <strong class="source-inline">AmmoJsPlugin</strong> has everything it needs to do its job (see the next section for more on <strong class="source-inline">initializePhysics</strong>).</p>
<p>The great <a id="_idIndexMarker466"/>thing about using a physics engine that has already been built and proven is that there isn’t much to do other than set up the desired parameters for the physics simulation. This is done in the <strong class="source-inline">SpaceTruckerPlanningScreen.initializePhysics</strong> method.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/>Configuring the InFlight Physics Simulation</h2>
<p>The <strong class="source-inline">initializePhysics</strong> method<a id="_idIndexMarker467"/> is not invoked during object construction because we know the screen won’t initially be shown to players, and we want to make sure that the scene has been completely set up with all the meshes involved before doing anything with the physics engine. It is invoked by <strong class="source-inline">setReadyToLaunchState</strong>, and since that method can be called several different ways, the <strong class="source-inline">initializePhysics</strong> function can’t make assumptions about the current state of the engine. That is why the physics engine is reset and cleared before every flight – keeping the interface between the engine and game opaque makes for simpler code.</p>
<p>The first thing we want to make sure and do is set <strong class="source-inline">scene.gravity</strong> to <strong class="source-inline">Vector3.Zero</strong> – otherwise, it would default to the Earth-normal value of (<strong class="source-inline">0, -9.8, 0</strong>). This is a space simulation, and it wouldn’t pass muster to have players falling at the wrong speed and direction! Next, we must dispose of any existing physics impostors before disabling the engine entirely. That paves the way for the newly-created <strong class="source-inline">AmmoJSPlugin</strong> to get passed into the <strong class="source-inline">scene.enablePhysics</strong> method. Let’s slow down for a moment – what is a <strong class="source-inline">PhysicsImpostor</strong>?</p>
<p>Most <a id="_idIndexMarker468"/>meshes (or at least most interesting meshes) are going to have complicated geometries. The overall shape of the mesh may not be symmetric on all axes, and there may be convex or concave surfaces that can obscure or hide other parts of the geometry, depending on the angle in question. Some meshes may also have dense geometries, with vertice counts in the hundreds of thousands or more. Performing physics – and when we mention physics in this context, what we are referring to are collision calculations for the most part – against such complicated geometries is complicated, inaccurate, and untenably slow.</p>
<p>To make these calculations work in the short amount of time available between frames, we must substitute a much simpler geometric shape that can approximate the actual mesh’s shape in place of the original. This approximation is generally a simple shape, such as a <strong class="source-inline">Box</strong>, <strong class="source-inline">Sphere</strong>, or <strong class="source-inline">Cylinder</strong>. The challenge for the developer is to select the most appropriate impostor type for the mesh getting physics applied.</p>
<p>The physics Impostor sounds pretty cool as a name, but in terms of its functionality, it might also be thought of as being a proxy object to act on behalf of the Mesh when dealing with the Physics engine. It holds information such as mass, linear and angular velocities, and friction values, as you might expect, but there’s also logic for controlling how the Impostor syncs data between engine and mesh.</p>
<p>After enabling the physics engine with <strong class="source-inline">AmmoJSPlugin</strong>, every <strong class="source-inline">planet</strong>, as well as <strong class="source-inline">star</strong> and <strong class="source-inline">cargoUnit</strong> have their <strong class="source-inline">physicsImpostor</strong> properties populated with appropriate values read from the <strong class="source-inline">gameData</strong> configuration, similar to the one shown here:</p>
<pre class="source-code">&#13;
this.star.physicsImpostor = new&#13;
  PhysicsImpostor(this.star.mesh,&#13;
  PhysicsImpostor.SphereImpostor, {&#13;
    mass: this.config.starData.mass,&#13;
    restitution: 0,&#13;
    disableBidirectionalTransformation: false,&#13;
}, this.scene);</pre>
<p>Once the impostors have been created, <strong class="source-inline">cargoUnit.physicsImpostor</strong> is subscribed to the <strong class="source-inline">onCargoDestroyed</strong> method handler, which is responsible for transitioning the game state from <strong class="source-inline">InFlight</strong> to <strong class="source-inline">CargoDestroyed</strong>.</p>
<p>This<a id="_idIndexMarker469"/> was a big lead-up to what is a bit of an anti-climax – shouldn’t complex stuff like physics and gravity be a lot more complicated? Perhaps it should be, but thanks to the hard work of a LOT of people over a very long time, it isn’t anymore! That’s a fortunate thing indeed because that allows us to pay more attention to the game mechanics and how they fit on top of the orbital simulation.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/>Defining the Rules – Game Mechanics</h1>
<p>Typical business <a id="_idIndexMarker470"/>application development focuses on dividing the responsibilities of the application into logical segments that layer on top of one another, with the user on one side and the application’s foundational infrastructure on the other. Data and commands pass sequentially from one layer to another as user-initiated events propagate in concert with system and application events. Ideally, the code has the qualities of both being loosely coupled and tightly cohesive.</p>
<p>This may sound like a paradox or contradiction – how can something be both loose and tight at the same time? The answer is that it can be both because the two qualities tend to be inversely correlated with each other. Loose coupling between components means that making changes to one has little to no effect on the other. A tightly cohesive system is one where functionality is confined to a small number of code or application components; everything needed to accomplish a particular task is close at hand.</p>
<p>When developing a game, we strive to factor it in a similarly well-structured fashion – not because it looks nice in a class diagram but because it makes it easy to change, extend, fix, and enhance. Now, let’s provide a summary of the basic game mechanics (also known as <strong class="bold">Business Rules</strong>) that <a id="_idIndexMarker471"/>are applied to <strong class="source-inline">RoutePlanningScreen</strong>.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/>Controllable Launch Parameters</h2>
<p>A key part<a id="_idIndexMarker472"/> of the principal game loop in route planning is that the player should be able to control the timing, angle, and velocity of their launch. This only applies in the <strong class="source-inline">ReadyToLaunch</strong> phase. A minimum and a maximum launch velocity should be enforced, with the specific values for the minimum and maximum determined by empirical iteration (for example, trial and error).</p>
<p>The player should be able to visually gauge the launch factors, with or without the help of seeing the underlying data. If the player isn’t satisfied with their alignments or they want to start over, they should be able to reset to starting parameters. In the <em class="italic">Supporting Input Controls</em> section, we’ll look at the input mapping to see how players should interact from their end of things. Next, we’ll talk about how a player might succeed or fail at the game along with what defines a particular scenario.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/>Going Places and Crashing EVERYWHERE</h2>
<p>A given game<a id="_idIndexMarker473"/> playthrough should have an <strong class="source-inline">origin</strong> and a <strong class="source-inline">destination</strong> Planet designated in the scenario’s <strong class="source-inline">gameData</strong>. These should be visible to the player so that they know where they are and where they need to be. Potential hazards <a id="_idIndexMarker474"/>and obstacles should be made visible to players. After the player has elected to launch their cargo into its ballistic trajectory, the game ends in a losing state (<strong class="source-inline">CargoDestroyed</strong>) if <strong class="source-inline">CargoUnit</strong> contacts our <strong class="source-inline">Star</strong> or any <strong class="source-inline">Planet</strong>.</p>
<p>If the player can align their launch so that it intersects the destination within a certain radius, they will be considered to have successfully planned their flight route. If the player chooses to reject the given flight plan, the simulation is reset in the same way as it is elsewhere. Should the player accept the flight plan, gameplay moves to the next phase.</p>
<p>Future game phases, along with the game mechanics of scoring, will be covered later in this book. To read more about the basic game design, the original game design docs for Space-Truckers can be found at <a href="https://github.com/jelster/space-truckers/blob/develop/design/game-design-specs.md">https://github.com/jelster/space-truckers/blob/develop/design/game-design-specs.md</a>. While mostly out of date, it can provide further insights into how the game’s elements have evolved and grown over time, in addition to potentially deriving some degree of amusement by looking at the various concept sketches.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/>Supporting Input Controls</h2>
<p>In the<a id="_idIndexMarker475"/> previous chapter, we looked at the input processing and control system. That system defines an <strong class="source-inline">inputActionMap</strong>, with every potential input getting mapped to the name of an Action (Command). The specific meaning and effect of a given action is determined by whatever code implements that action and is specific to the Screen.</p>
<p>Let’s look at the Route Planning’s control scheme in its entirety. Some entries are new since the preceding chapter; the pointer (touch/mouse) operations are assumed to be centered around GUI elements (see the <em class="italic">Showing Game Information with the GUI</em> section) and the camera controls are using native keymaps unless otherwise noted:</p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="" height="488" src="image/Table_6.02_B17266.jpg" width="1650"/>
</div>
</div>
<p>The <strong class="source-inline">GamePad</strong> control scheme is oriented toward an Xbox® controller, but other types of controllers can still be supported with little effort – see <a href="B17266_05_Final_AM.xhtml#_idTextAnchor103"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding a Cut Scene and Handling Input</em>, along with the <strong class="source-inline">gamePadControlMap</strong> constant in the <strong class="source-inline">inputActionMap.js</strong> file at <a href="https://github.com/jelster/space-truckers/blob/ch6/src/inputActionMaps.js">https://github.com/jelster/space-truckers/blob/ch6/src/inputActionMaps.js</a>.</p>
<p>For the most part, we’ve already covered the function implementations for each of these actions separately in earlier sections of this chapter, so we aren’t going to spend time on how that operates because we’ve only looked at half of the feedback loop by looking at user input. We need to close that loop by examining the sorts of information that the game presents back to the user.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/>Showing Game Information with the GUI</h2>
<p>When <a id="_idIndexMarker476"/>folks think about <strong class="bold">UIs</strong>, the first thing that comes to mind are those of a graphical nature – web pages, start menus, and the like. While the visual medium is one of the dominant means of communication between person and computer, audio and other channels of output are definitely on the docket for us to look through – just not at this time. We’ll be beefing up the environmental effects both visually and audibly in the next chapter. For now, let’s look at how the GUI is structured.</p>
<p>Unlike the <strong class="bold">Splash</strong> and <strong class="bold">Main Menu</strong> Screens, the <strong class="bold">Planning Screen</strong> screen doesn’t directly create or manage its UI. As you may recall, we’ve been using the Babylon.js GUI’s <strong class="source-inline">AdvancedDynamicTexture</strong> to render our GUI elements, and that isn’t going to change. What is different, however, is that <strong class="source-inline">SpaceTruckerPlanningScreen</strong> hosts an instance of <strong class="source-inline">PlanningScreenGui</strong> (see <a href="https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/route-plan-gui.js">https://github.com/jelster/space-truckers/blob/ch6/src/route-planning/route-plan-gui.js</a>). In turn, <strong class="source-inline">PlanningScreenGui</strong> takes the <strong class="source-inline">SpaceTruckerPlanningScreen</strong> instance in its constructor, allowing it to access all of the data it needs to dynamically update the GUI. We need to perform our UI initialization and configuration after the Scene has finished loading and the Screen is completely constructed; otherwise, our GUI will need to contain an eventual spaghetti-flavored mess of conditional and null checks.</p>
<p>Avoiding that is straightforward: listen for <strong class="source-inline">scene.onReadyObservable</strong> and then use that to instantiate the GUI. To provide additional flexibility in separating construction from configuration time, the <strong class="source-inline">bindToScreen</strong> function creates the actual UI components, links display objects with meshes from the Screen, and performs other boilerplate-type creation tasks. This completes the static configuration of the GUI, but we want – no, demand – that the GUI should update in more-or-less real time with the latest data from the simulation and game. That’s where our double-fisted combination comes in handy!</p>
<p>The first punch is given by the event subscription to <strong class="source-inline">SpaceTruckerPlanningScreen.onStateChangeObservable</strong> with the <strong class="source-inline">onScreenStateChange</strong> function:</p>
<pre class="source-code">&#13;
this.planningScreen.onStateChangeObservable.add(state =&gt; {&#13;
    const currentState = state.currentState;&#13;
    this.onScreenStateChange(currentState);&#13;
}); </pre>
<p>This <a id="_idIndexMarker477"/>ensures that the GUI is informed whenever the game state changes, such as from <strong class="source-inline">ReadyToLaunch</strong> to <strong class="source-inline">InFlight</strong>. The logic in that method looks at <strong class="source-inline">newState</strong> to determine which controls should be visible, and what color the text should be. That handles the problem of needing to coordinate UI changes with state changes, while the other side of this pugilistic analogy is the knock-out blow of per-frame updates to controls done as part of the <strong class="source-inline">update</strong> method.</p>
<p>In the <strong class="source-inline">update</strong> method, numbers are formatted for display, controls update their text properties, and the Launch Arrow gets scaled according to the current launch Force. Essentially, anything that doesn’t directly affect the game gets updated in this method. The problem of needing to display dynamically updated data has been solved as well – we can cease our unyielding demands and claim victory!</p>
<p>It’s a great thing that we’ve knocked out the rest of this chapter, not only because of the great amount of information we’ve covered in quite a small amount of text but because the boxing analogy is very off-brand for Space-Truckers and it was wearing quite thin. Let’s review what we’ve just gone over and look at some ideas for what you can do to practice working with the concepts.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor141"/>Summary</h1>
<p>We started this chapter having freshly completed the <strong class="bold">Main Menu</strong> Screen, and we’ve finished it having implemented the <strong class="bold">Route Planning</strong> Screen and the bulk of its core game loop – that’s quite the trip for how short a time we’ve been traveling! <strong class="source-inline">SpaceTruckerSoundManager</strong> maintains an internal catalog of all sound assets and makes those assets available to hosting Screens that want to play sounds. Although it seems like it does a lot, when it comes to actual Babylon.js Sounds, it likes to delegate responsibility to the Sound.</p>
<p>The ability to mix different sounds and sources is provided by the different SoundTracks defined by <strong class="source-inline">SpaceTruckerSoundManager</strong>, and they make it very easy to have background music playing at the same time as a game sound effect without having to code logic around volume levels. This is because each soundtrack has a volume (gain) control.</p>
<p>After reviewing the <strong class="source-inline">GameObject</strong> class hierarchy, we dove – or more appropriately, fell – into the specifics of how the rendered actors are constructed. Toolbox ready, we created <strong class="source-inline">SpaceTruckerPlanningScreen</strong> and set up a set of states and transitions between them. From there, we danced over basic gravitational physics – doesn’t that sound cool? Find a way to work into your next conversation that you know gravitational physics and stroke your chin thoughtfully.</p>
<p>Then, we learned a bit about how the <strong class="source-inline">Ammo.js</strong> physics engine is set up and configured with our project. Having set the planets in motion, we shifted our focus to layering on some of the gameplay elements. Player-controlled launch parameters, collision detection, and showing players their stats all went quickly to our enlightened senses, leaving us facing the path forward.</p>
<p>In the next chapter, solar flares and prominences will erupt from the particle systems we’ll put in place.Later, we will explore encounter zones and focus on capturing route data as we flesh out route planning and prepare for the next phase of gameplay.</p>
<p>Extended Topics</p>
<p>Are you not feeling quite ready to move on to the next chapter? Are you having trouble figuring out how all of what you’ve just read works? Jump over to the Space-Truckers discussion board (<a href="https://github.com/jelster/space-truckers/discussions">https://github.com/jelster/space-truckers/discussions</a>) to search for answers or post your questions so that others may be able to help answer them. Not ready to move on but feel like you’ve got a good grasp of things? Why not try enhancing the Screen with some of these ideas:</p>
<ul>
<li>When the game begins, have the camera start somewhere far out before pulling in toward the star, giving a tour of the system as it does so, before ending in the starting camera position. There are lots of ways to accomplish this, but one potential approach would be to create an animation and set of keyframes that dictate the camera’s position. Another might be to use <strong class="source-inline">autoFramingBehavior</strong>, along with tweaking the camera’s inertia and other related values.</li>
<li>Make the gamepad’s triggers usable for adjusting the launch force; pulling on the left could decrease the force while pulling on the right could increase the force. Essentially, this would work the same way as the current button presses do, except that the constant value being incremented is scaled or replaced by the trigger value instead (the trigger is the positive axis, while the other is negative).</li>
<li>Think the physics calculations are too inaccurate? Do you sneer at the idea of matrix math being <em class="italic">complex</em>? Do you begin to question your existence when someone says that you’re <em class="italic">irrational</em>? OK, here’s a challenge: add a basic numerical integrator to the part of the simulation where the forces are scaled according to <strong class="source-inline">deltaTime</strong>.</li>
</ul>
<p>(Easier) Use Euler’s method to calculate the cargo unit’s new/future position using the current velocity and the frame’s <strong class="source-inline">deltaTime</strong> combined with the previous frame’s velocity and position (<a href="https://en.wikipedia.org/wiki/Euler_method">https://en.wikipedia.org/wiki/Euler_method</a>).</p>
<p>(Harder) Use Verlet integration to do the same (<a href="https://en.wikipedia.org/wiki/Verlet_integration">https://en.wikipedia.org/wiki/Verlet_integration</a>).</p>
<ul>
<li>OK, so maybe the last one was a bit too hardcore, but there’s still the urge to do something to make the code suck a little bit less… here’s a challenge that doesn’t specifically require knowledge of any of the aforementioned topics but does require engineering savvy and great source code literacy: integrate the core gravitational simulation into the Babylon.js physics plugin/engine.</li>
<li>If you accomplish any of these things, be sure to share your work with the world by posting links on the Space-Truckers discussion, the Babylon.js Forums, and/or by opening a Pull Request!</li>
</ul>
</div>
<div>
<div id="_idContainer070">
</div>
</div>
</div></body></html>