- en: Chapter 11. Using Force
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using gravity and charge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing velocity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the link constraint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using force to assist visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating force
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a force-directed graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Use the force, Luke!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A master''s words of wisdom to his apprentice*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover one of the most fascinating aspects of D3: force.
    Force simulation is one of the most awe-inspiring techniques that you can add
    to your visualization. Through a number of highly interactive and fully functional
    examples, we will help you explore not only the typical application of D3 force
    (for example, the force-directed graph), but also other essential aspects of force
    manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: D3 force simulation support was created not as a separate capability, but rather
    as a kind of additional D3 layout. As we mentioned in [Chapter 9](ch09.html "Chapter 9. Lay
    Them Out"), *Lay Them Out*, D3 layouts are nonvisual data-oriented layout management
    programs designed to be used with different visualization. Force simulation was
    originally created for the purpose of implementing a specific type of visualization
    called **force-directed graph**. Its implementation uses standard **velocity**
    **verlet integration** simulating physical forces on particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, D3 implements a numeric method that is capable of loosely simulating
    the motion of particles using its velocity with stepped temporal functions. This
    kind of simulation, of course, was ideal in implementing particular visualization,
    such as a force-directed graph; however, you will also discover through recipes
    in this chapter that force simulation is capable of generating many other interesting
    visualization effects, thanks to its flexibility in custom force manipulation.
    The application of such techniques introduced in this chapter goes even beyond
    the data visualization realm and has practical applications in many other domains,
    for example, user interface design. Of course, in this chapter, we will also cover
    the classical application of force: the force-directed graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Using gravity and charge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will introduce you to the first two fundamental forces:
    gravity and charge. As we have mentioned before, one objective of force layout''s
    design is to loosely simulate the motion of particles, and one major feature of
    this simulation is the force of charge. Additionally, force simulation also implements
    pseudo gravity, or more accurately, a weak geometric constraint typically centered
    on the canvas that can be leveraged to keep your visualization from escaping the
    canvas. In the following example, you will learn how these two fundamental, sometimes
    opposing, forces can be leveraged to generate various effects with a particle
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/gravity-and-charge.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/gravity-and-charge.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following example, we will experiment with the force simulating gravity
    and charge settings so you can better understand different opposing forces involved
    and their interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates a force-enabled particle system that is capable of operating
    in the modes shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Force simulation modes
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get our hands dirty with the preceding code example, let's first dig
    a little bit deeper into the fundamental concepts of alpha decay, velocity decay,
    charge, positioning, and collision so we can have an easier time understanding
    all the magic number settings we will use in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Alpha decay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alpha determines how hot a simulation is. A simulation starts with alpha of
    1 and decay toward 0 by default over 300 iterations. Therefore, if you set the
    alpha decay to 0 meaning there is no decay therefore simulation will never stop.
    This is the setting we will use in this chapter in order to better demonstrate
    the effects. In real-life visualization, you will typically use some level of
    decay so that the simulation will cool down after a while, similar to how particles
    work in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Velocity decay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At each tick of the simulation particle, velocity is scaled down by a specified
    decay. Thus, a value of 1 corresponds to a frictionless environment, whereas a
    value of 0 freezes all particles in place since they lose their velocity immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Charge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Charge is specified to simulate mutual n-body forces among the particles. A
    negative value will result in mutual node repulsion, whereas a positive value
    will result in a mutual node attraction.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If X or Y positioning forces are specified, the simulation will push particles
    toward a desired position along a given dimension with configured strength. This
    is typically used as a global force that applies to all particles in the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Collision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The collision force treats particles as circles with a certain radius instead
    of size-less points. This will prevent particles from overlapping in a simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, now with the dry definition behind us, let's take a look at how these
    forces can be leveraged to generate interesting visual effects.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up zero force layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set up zero force layout, we simply set up force layout with neither gravity
    nor charge. The force layout can be created using the `d3.forceSimulation` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we disable `alphaDecay` so that simulation will continue to run
    without cooling down while setting the `velocityDecay` to `0.8` to simulate the
    effect of friction. Next, we set the `collision` to slightly larger than the radius
    of the `svg:circle` element we will create later. With this setting in place,
    we then create additional nodes represented as `svg:circle` on SVG whenever the
    user moves the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Node object was created initially on line `A` with its coordinates set to the
    current mouse location. Like all other D3 layouts, force simulation is not aware
    and has no visual elements. Therefore, every node we create needs to be added
    to the layout''s nodes array on line `C` and removed when the visual representation
    of these nodes was removed on line `B`. By default, force simulation starts automatically
    as soon as the simulation was created. With zero gravity and charge, this setting
    essentially lets us place a string of nodes with our mouse movement, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up zero force layout](img/image_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: No Gravity or Charge
  prefs: []
  type: TYPE_NORMAL
- en: Setting up mutual repulsion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the next mode, we will set the charge to a negative value without any global
    positioning force in order to generate a mutual repulsive force field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines tell force layout to apply `-10` charge on each node and update
    the node''s `{x, y}` coordinate accordingly, based on the simulation result on
    each tick. However, only doing this is still not enough to move the particles
    on SVG since the layout has no knowledge of the visual elements. Next, we need
    to write some code to connect the data that is being manipulated by force layout
    to our graphical elements. Following is the code to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we register a `tick` event listener function that updates all circle elements
    to its new position based on the force layout's calculation. Tick listener is
    triggered on each tick of the simulation. At each tick, we set the `cx` and `cy`
    attributes to be the `x` and `y` values on `d`. This is because we have already
    bound the node object as datum to these circle elements. Therefore, they already
    contain the new coordinates calculated by force layout. This effectively establishes
    force layout's control over all the particles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Force simulation also sets values other than x and y on the node object, which
    we will cover and leverage in later recipes to implement force drag and custom
    forces. In this recipe, let's just focus on the simple force-based positioning
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than `tick`, force layout also supports some other events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tick`: Triggered on each tick of the simulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: Triggered when a simulation ends'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This force setting generates the following visual effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up mutual repulsion](img/image_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mutual Repulsion
  prefs: []
  type: TYPE_NORMAL
- en: Setting up gravity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we change the charge to a positive value, it generates mutual attraction
    or gravity among the particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following visual effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up gravity](img/image_11_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Gravity
  prefs: []
  type: TYPE_NORMAL
- en: Setting up positioning with gravity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we turn on gravity with central positioning force, then it generates a
    somewhat similar effect as the mutual attraction; however, you can notice the
    strong gravitational pull as the mouse cursor moves away from the center:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up positioning with gravity](img/image_11_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Positioning with gravity
  prefs: []
  type: TYPE_NORMAL
- en: Setting up positioning with repulsion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we can turn on both positioning and mutual repulsion. The result is
    an equilibrium of forces that keeps all particles somewhat stable, neither escaping
    nor colliding with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what this force equilibrium looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up positioning with repulsion](img/image_11_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Positioning with repulsion
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to Velocity Verlet integration at [https://en.wikipedia.org/wiki/Verlet_integration](https://en.wikipedia.org/wiki/Verlet_integration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to scalable, versatile, and simple constrained graph layout at [http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf](http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to physical simulation at [http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm](http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content of this chapter is inspired by Mike Bostock's brilliant talk on
    D3 Force that can be found at [http://mbostock.github.io/d3/talk/20110921/](http://mbostock.github.io/d3/talk/20110921/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [Chapter 10](ch10.html "Chapter 10. Interacting with Your Visualization"),
    *Interacting with Your Visualization*, for more details on how to interact with
    the mouse in D3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to D3 Force Simulation API document for more details on force at [https://github.com/d3/d3-force](https://github.com/d3/d3-force)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing velocity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous recipe, we touched upon force simulation node object and its
    {`x, y`} attributes, which determine the location of a node on the layout. In
    this recipe, we will discuss another interesting aspect of physical motion simulation:
    velocity. The D3 force layout has a built-in support for velocity simulation,
    which relies on the {`vx, vy`} attributes on the node object. Let''s see how this
    can be done in the example described in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/velocity.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/velocity.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will modify the previous recipe by first disabling both
    positioning and charge and then giving newly added node some initial velocity.
    As a result, now, the faster you move the mouse higher the initial velocity and
    momentum will be for each node. Here is the code to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates a particle system with initial directional velocity proportional
    to the user''s mouse movement, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Velocity
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The overall structure of this recipe is pretty similar to the previous one.
    It also generates particles as the user moves the mouse around. Moreover, once
    the force simulation starts, the particle position is fully controlled by the
    force layout in its `tick` event listener function. However, in this recipe, we
    have turned off both positioning and charge so that we can focus more clearly
    on momentum alone. We left some friction so that the velocity decay, making simulation
    look more realistic. Here is our force layout configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The major difference in this recipe is that we keep track of not only the current
    mouse position, but also the previous mouse position. Additionally, whenever the
    user moves the mouse, we generate a node object containing the current location
    (`point[0], point[1]`) and the previous location (`previousPoint.x, previousPoint.y`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since user's mouse location is sampled on fixed interval, the faster the user
    moves the mouse the further apart these two positions will be. This property and
    the directional information gained from these two positions are nicely translated
    automatically by force simulation into initial velocity for each particle we create
    as we have demonstrated in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the {`x, y, vx, vy`} attributes we have discussed so far, the force
    layout node object also supports some other useful attributes that we will list
    here for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`: Zero-based index of the node within the node''s array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: The x-coordinate of the current node position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: The y-coordinate of the current node position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vx`: The node''s current x-velocity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vy`: The node''s current y-velocity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fx`: The node''s fixed x-position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fy`: The node''s fixed y-position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will cover `fx` and `fy` and their usage in later recipe that involves dragging,
    which is one of the most common way to leverage fixed positioning of a node.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Interacting with mouse events* recipe in [Chapter 10](ch10.html
    "Chapter 10. Interacting with Your Visualization"), *Interacting with Your Visualization*,
    for more details on how to interact with the mouse in D3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the D3 Force Simulation Nodes API for more details on node attributes
    at [https://github.com/d3/d3-force#simulation_nodes](https://github.com/d3/d3-force#simulation_nodes)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the link constraint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered some important aspects of the force layout, such as
    gravity, charge, friction, and velocity. In this recipe, we will discuss another
    critical functionality: links. As we have mentioned in the introduction section,
    D3 force simulation supports a scalable simple graph constraint, and in this recipe,
    we will demonstrate how link constraint can be leveraged in conjunction with other
    forces.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/link-constraint.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/link-constraint.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, whenever the user clicks on the mouse, we will generate a force-directed
    ring of particles constrained by links between nodes. Here is how it is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates force-directed particle rings on a mouse click, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Force-directed particle rings
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Link constraint adds another useful dimension to force-assisted visualization.
    In this recipe, we set up our force layout with the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides collision, charge, and friction, this time we also bound charge-force
    interaction to 25% of the maximum height to simulate a more localized force interaction.
    When the user clicks on their mouse, a random number of nodes are being created
    and put under force simulation''s control similar to what we have done in the
    previous recipes. The major addition in this recipe is the link creation, and
    its control logic is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `createLinks` function, the `n-1` link objects were created connecting
    a set of nodes into a ring (for loop on line `A`). Each link object must have
    two attributes specified as `source` and `target`, telling force layout which
    pair of nodes are connected by this link object. Once this is created, we decided
    to visualize the links in this recipe using a `svg:line` element (refer to line
    `B`). However, we will see in the next recipe that this does not have to always
    be the case. As a matter of fact, you can use pretty much anything; you can imagine
    to visualize (including hiding them, but retain the links for layout computation)
    the links as long as it makes sense for the audience of your visualization. After
    that, we also need to add link objects to force layout''s links array (on line
    `C`) so that they can be put under force layout''s control. The `d3.forceLink`
    function has two important parameters: link distance and link strength; both parameters
    are exclusively link related:'
  prefs: []
  type: TYPE_NORMAL
- en: '`linkDistance`: This could be a constant or a function, which defaults to `20`
    pixels. Link distances are evaluated when the simulation is initialized, and it
    is implemented as weak geometric constraints. For each tick of the layout, the
    distance between each pair of linked nodes is computed and compared to the target
    distance. The links are then moved toward each other or away from each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linkStength`: This could be a constant or a function, which defaults to `1`.
    Link strength sets the strength (rigidity) of links with a value in the range
    of `[0, 1]`. Link strength is also evaluated on initialization or reset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we will need to translate the positioning data generated by force
    layout to SVG implementation in the `tick` function for each link similar to what
    we did for the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see here, the D3 force simulation has again done most of the heavy
    lifting, therefore, all we need to do is simply set `{x1, y1}` and `{x2, y2}`
    on the `svg:line` elements in the `tick` function. Additionally, we have also
    used two bounded X and Y function to make sure that the particles and rings will
    not escape our SVG canvas area. For reference, the following screenshot is what
    a link object looks like after it is manipulated by force layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_11_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Link object
  prefs: []
  type: TYPE_NORMAL
- en: 'One last additional technique worth mentioning in this recipe is the force-enabled
    dragging. All nodes generated by this recipe are "drag gable," and force simulation
    automatically re-computes all forces and constraints, as the user drags the rings
    around, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_11_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dragging, with force simulation
  prefs: []
  type: TYPE_NORMAL
- en: 'This is accomplished by registering the `d3.drag` event handler as shown on
    line `D` in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of each of the drag event handler is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When dragging happens on a particular node, we use `fx` and `fy` to fix that
    particular node to its initial position as shown on line `E`. While the dragging
    is happening, we continue to update the node's position with the user's mouse
    position, thus, moving the node while being dragged (refer to line `F`). Finally,
    when drag ends, we unfix the node position, thus, allowing force simulation to
    take control once again, as shown on line `G`. This is a very general drag support
    pattern you will see quite often with force-assisted visualization, including
    some later recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scalable, versatile, and simple constrained graph layout: [http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf](http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information about force.links() function please refer to: [https://github.com/d3/d3-force#links](https://github.com/d3/d3-force#links)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using force to assist visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we learned to use force simulation visualizing particles and links similar
    to how you would use force in its classic application, the forced-directed graph.
    This kind of visualization is what force simulation was designed for in the first
    place. However, this is by no means the only way to utilize force in your visualization.
    In this recipe, we will explore techniques that I call force-assisted visualization.
    With this technique, you can add some randomness and arbitrariness into your visualization
    by leveraging force.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/arbitrary-visualization.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/arbitrary-visualization.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will generate bubbles on the user''s mouse click. The bubbles
    are made of `svg:path` elements filled with gradient color. The `svg:path` elements
    are not strictly controlled by force layout though they are influenced by force,
    therefore, giving them the randomness required to simulate a bubble in real life:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates force-assisted bubbles on the user''s mouse click as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Force assisted bubbles
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is built on top of what we have done in the previous recipe, therefore,
    its overall approach is quite similar to the last recipe in which we created force-controlled
    particle rings on the user''s mouse click. The major difference between this recipe
    and the last one is in this one we decided to use the `d3.line` generator to create
    the `svg:path` element that outlines our bubbles instead of using `svg:circle`
    and `svg:line`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On line `A`, we created a line generator with a `d3.curveBasisClosed` curve
    mode since this gives us the smoothest outline for our bubble. Whenever a user
    clicks on the mouse, a `svg:path` element was created connecting all nodes (line
    `C`). Additionally, we also fill the bubble with our predefined gradient to give
    it a nice glow (line `B`). Finally, we also need to implement the force-based
    positioning in the `tick` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the `tick` function, we simply re-invoke the line generator function to update
    the `d` attribute for each path, thus, animating the bubbles using force layout
    computation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to SVG Gradients and Patterns at [https://www.w3.org/TR/SVG/pservers.html](https://www.w3.org/TR/SVG/pservers.html)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Using line generator* recipe in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*, for more information on D3 line generator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating force
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explored many interesting aspects and applications of D3 force;
    however, in all of these prior recipes, we simply applied force layout's computation
    (gravity, charge, friction, collision, and velocity) directly to our visualization.
    In this recipe, we will go one step further to implement custom force manipulation,
    hence creating our own type of force.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will first generate five sets of colored particles then
    assign corresponding colors and categorical force pull to user''s touch, hence
    pulling only the particles that match the color. Since this recipe is a bit complex,
    I will give an example here: if I touch the visualization with my first finger,
    it will generate a blue circle and pull all blue particles to that circle, whereas
    my second touch will generate an orange circle and will only pull the orange particles.
    This type of force manipulation is commonly referred to as categorical multi-foci.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/multi-foci.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/multi-foci.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is how you can achieve this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates multi-categorical foci on touch, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multi-categorical foci on touch
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step of this recipe is to create colored particles and standard force
    equilibrium between positioning and repulsion. All node objects contain separate
    color and type ID attributes (line `A` and `B`), so they can be easily identified
    later. On line `C`, we let force simulation manage all the positioning of these
    particles as we have done in previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to create a large `svg:circle` element on user touch to
    represent the touch point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the pretty standard multi-touch drawing that we saw in *Interacting
    with a multi-touch device* recipe in [Chapter 10](ch10.html "Chapter 10. Interacting
    with Your Visualization"), *Interacting with Your Visualization*. Once the touch
    point is identified, all the custom force magic are implemented in the `tick`
    function. Now, let''s take a look at the `tick` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this tick function, we have the familiar part, on line `F`, where we let
    force simulation to control the position of all particles on the canvas; however,
    we have also introduced a custom force. On line `C`, we looped through all nodes
    to identify the nodes associated with a given center that represents user's touch.
    Once we detect the touch center, we started to move the particle closer to the
    center one tick at a time (line `D` and `E`) using the `k` coefficient. The larger
    the `k` the faster the particles will converge around a touch point.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Interacting with a multi-touch device* recipe in [Chapter 10](ch10.html
    "Chapter 10. Interacting with Your Visualization"), *Interacting with your Visualization*,
    for more information on D3 multi-touch support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a force-directed graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we will show how to implement a force-directed graph, the classic application
    of D3 force. However, we believe with all the techniques and knowledge you have
    gained so far from this chapter, implementing force-directed graph should feel
    quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/force-directed-graph.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/force-directed-graph.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will visualize the flare dataset as a force-directed tree
    (tree is a special type of graph):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe visualizes the hierarchical flare dataset as a force-directed tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Force-directed graph (tree)
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we can already see, this recipe is pretty short, and a quarter of the code
    was actually devoted to drag support. This is due to the fact that force-directed
    graph is what force simulation was designed for in the first place. Thus, there
    is really not much to do other than simply applying the force with correct data
    structure. First, we process the hierarchical dataset using the standard `d3.hierarchy`
    (line `A`) since this is how we can retrieve the nodes and links data structure
    `d3.force` expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'On line `B`, we leverage the `d3.hierarchy.descendants` function to retrieve
    all nodes contained in the tree and the links among nodes on line `C` using the
    `d3.hierachy.links` function. These are the data structure `d3.force` expects;
    once we have them, they can be directly passed to simulation on line `D` and `E`.
    The rest of the recipe is very similar to the *Setting the link constraint* recipe
    in this chapter. We created the `svg:link` element to represent links and `svg:circle`
    elements to represent the nodes in the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The only parts worth mentioning here is that we colored the node using its
    parent''s name on line `F`, so all siblings will be colored consistently, and
    on line `G`, we used the common drag support pattern mentioned in the *Setting
    the link constraint* recipe to allow dragging with this graph. Finally, we let
    force simulation to control both nodes and links positioning completely in the
    tick function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Building a tree* recipe in [Chapter 9](ch09.html "Chapter 9. Lay
    Them Out"), *Lay Them Out*, for more information on D3 tree layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on force-directed graphs, visit [https://en.wikipedia.org/wiki/Force-directed_graph_drawing](https://en.wikipedia.org/wiki/Force-directed_graph_drawing)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
