<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Model-View-Whatever</h1></div></div></div><p>If you are a frontend developer, you may not be familiar with the traditional software architectural pattern referred to as <strong>Model-View-Controller</strong> (<strong>MVC</strong>). Variations of this pattern have found their way into frontend software architectural patterns in recent years through such frameworks as <em>Backbone.js</em>, <em>Ember.js</em>, and AngularJS. Regardless of your experience in these areas, this chapter will discuss the evolution of the so-called <strong>Model-View-Whatever</strong> (<strong>MVW</strong>) pattern and its relevance to SPA development through the following topic areas:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The original MVC pattern</li><li class="listitem" style="list-style-type: disc"><strong>Model-View-Presentation</strong> (<strong>MVP</strong>)/<strong>Model-View-ViewModel</strong> (<strong>MVVM</strong>) explained</li><li class="listitem" style="list-style-type: disc"><strong>View-Interactor-Presenter-Entity-Router</strong> (<strong>VIPER</strong>) and other variations of MVW</li><li class="listitem" style="list-style-type: disc">AngularJS and MVW</li><li class="listitem" style="list-style-type: disc">Using the MVW pattern in a SPA</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec11"/>The original MVC pattern</h1></div></div></div><p>The MVC software architectural pattern has existed in one form or another since the 1970s, but it became more popular and generally accepted with its use in web application frameworks such as Ruby on Rails, CakePHP, and Django. MVC frameworks like these brought a higher level of organization and sophistication to web application development than had been previously conceived, and in doing so, paved the way for modern SPA development.</p><p>To understand the relevance of MVC to modern SPA development, let's first break down the components and ideology of MVC.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>The Model</h2></div></div></div><p>The <em>Model</em> component of MVC deals with an application's data. This includes data that is displayed to the user, received from the user, and stored in the database. Additionally, the Model handles all <strong>Create, Read, Update, Delete</strong> (<strong>CRUD</strong>) operations with the database. Many frameworks also use the Model to handle an application's <em>business logic</em>, or how the data should be manipulated before being saved or viewed, but this is not necessarily a standard.</p><p>In the simplest terms, the Model in an MVC web application is a representation of the application's data. That data may include anything relevant to the application, such as the current user's information. Traditional web application frameworks use relational databases, such as MySQL, to store data. Modern SPA architectures, however, are now gravitating more and more toward document-oriented databases, or what is commonly referred to as <em>NoSQL</em>. MongoDB and many other NoSQL databases use JSON documents to store records. This is great for frontend architectures because JavaScript can directly parse JSON, and in the case of the MEAN stack, JSON data is native to every tier of the architecture.</p><p>Let's take a current web application's user information as an example. We will refer to this as the <em>User Model</em>
<strong>:</strong>
</p><pre class="programlisting">{ &#13;
    "id": 1, &#13;
    "name": { &#13;
        "first": "Philip", &#13;
        "last": "Klauzinski" &#13;
    }, &#13;
    "title": "Sr. UI Engineer", &#13;
    "website": "http://webtopian.com" &#13;
} &#13;
</pre><p>A simple JSON document like this will be returned from the database to your app for direct parsing by JavaScript. There is no need for any <strong>Structured Query Language</strong> (<strong>SQL</strong>) with a document-oriented database, hence the term <em>NoSQL</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>The View</h2></div></div></div><p>The core component of MVC is the <em>View</em>, and it is likely the one you are most familiar with if you are a frontend developer. The View embodies everything that the user interacts with, and in the case of a web application, what the browser consumes. Traditional MVC frameworks serve Views from the server, but in the case of a JavaScript SPA and using an architecture like the MEAN stack, the View is contained entirely in the frontend. From a development and asset management standpoint, this makes things a lot easier to maintain because the dual aspect of dealing with Views both on the server side and the frontend does not exist.</p><p>The templates for Views in a JavaScript SPA are written using HTML mixed with some type of web template system such as Underscore, Handlebars, or Jade, as only a few examples. A web template system allows your HTML markup to be parsed by JavaScript and evaluated for expressions that place dynamic data and content within your Views. For example, let's look at a simple Handlebars template using the User Model from earlier:</p><pre class="programlisting">&lt;h1&gt;User Information&lt;/h1&gt; &#13;
&lt;dl&gt; &#13;
    &lt;dt&gt;Name&lt;/dt&gt; &#13;
    &lt;dd&gt;{{name.first}} {{name.last}}&lt;/dd&gt; &#13;
    &lt;dt&gt;Title&lt;/dt&gt; &#13;
    &lt;dd&gt;{{title}}&lt;/dd&gt; &#13;
    &lt;dt&gt;Website&lt;/dt&gt; &#13;
    &lt;dd&gt;{{website}}&lt;/dd&gt; &#13;
&lt;/dl&gt; &#13;
</pre><p>Imagine an AJAX request is made for the currently logged-in user's data, and the SPA returns the User Model JSON document from a <code class="literal">GET</code> request. The properties from that JSON document can be directly inserted into the View for that request. In the case of Handlebars, a set of two opening and closing curly braces (<code class="literal">{{ ... }}</code>), or double curly brace notation, is used to identify expressions to be parsed within the template. In this case, those expressions are simply the user's first name, last name, and title. For more information on Handlebars templates, see <a class="ulink" href="http://handlebarsjs.com">handlebarsjs.com</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>The Controller</h2></div></div></div><p>The <em>Controller</em> component in the MVC pattern is the most variable between different frameworks, and thus the most difficult to define with true clarity as a general concept. In a traditional web application MVC framework such as Ruby on Rails or CakePHP, the Controller takes input from the user in the form of web requests, or <em>actions</em>, and makes changes to the Model before rendering a new response in the View. The following diagram shows the flow of the Controller within the MVC paradigm:</p><p>
</p><div><img src="img/image_02_001.jpg" alt="The Controller"/></div><p>
</p><p>(Diagram from Wikipedia - <a class="ulink" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#Components">https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#Components</a>)</p><p>With this representation of the Controller, it is easy to see how it could encapsulate a great deal of application code, and in fact when working with some MVC web frameworks, it is often difficult to know where to draw the line between Controller logic, business rules for the Model, validation rules for the View, and many other common components of a web application. This nebulous nature of the Controller has led to the decision of the authors of many modern web frameworks to move away from the term <em>Controller</em> entirely and adapt a new concept in its place.</p><p>The Model and the View components of MVC are easy to understand and to differentiate  their purposes within a web application, but the Controller is not so clear-cut. Let's now explore some of the concepts that have replaced the Controller in more recent web application architectural patterns.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>MVP and MVVM</h1></div></div></div><p>The term <em>Model-View-Whatever</em> came about amid the rise of many architectural patterns that included a Model and a View, but replaced the Controller with a different concept for a core component, or even with a number of them.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>MVP</h2></div></div></div><p>MVP is a variation on the MVC architectural pattern in which the <em>Presenter</em> component replaces the Controller. The Presenter also acts as the Controller in this pattern, but it takes on additional responsibility in that it serves to handle presentation logic for the View. The reasoning behind this paradigm is to enhance the testability of an application by having the View itself contain little to no presentation logic.</p><p>Another key difference between MVP and MVC is that a Presenter in MVP has a one-to-one relationship with a View, meaning there is a unique Presenter defined for every View, whereas MVC allows the Controller to have a one-to-many relationship with the View. In other words, MVC allows there to be any number of Views defined for a Controller and each View is mapped to an <em>action</em> of that Controller. MVP maps only one View to a Presenter. Additionally, MVP prohibits a direct relationship between the View and the Model, which is again for enhancing testability by keeping business logic out of the View:</p><p>
</p><div><img src="img/image_02_002.jpg" alt="MVP"/></div><p>
</p><p>(Diagram from Wikipedia - <a class="ulink" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter</a>)</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>MVVM</h2></div></div></div><p>MVVM is yet another variation on the MVC architectural pattern. The <em>ViewModel</em> in this paradigm is a representation of the Model data for the current user's session. Changes to the ViewModel are always made before any changes are made to the Model.</p><p>MVVM is like MVP in that the View has no knowledge of the Model, but in contrast, the View has a many-to-one relationship with the ViewModel. This means that multiple Views can be mapped to one ViewModel. The ViewModel component also contrasts with the Presenter in MVP in that it has no knowledge of the View. Instead, the View has a reference to the ViewModel, which allows it to be updated based on changes to the ViewModel.</p><p>The primary distinction of MVVM from the other architectural patterns in regard to SPA development, however, is the support of <em>two-way data binding</em>. This means that changes to the ViewModel are automatically reflected in the View, and changes to data in the View by the user are automatically updated in the ViewModel. This makes MVVM a more viable pattern for modern SPA development because the View can be updated and stays in sync with the ViewModel without the need for a new page request, which is what would be required in a traditional MVC or MVP architecture:</p><p>
</p><div><img src="img/image_02_003.jpg" alt="MVVM"/></div><p>
</p><p>(Diagram from <a class="ulink" href="http://social.technet.microsoft.com/wiki/contents/articles/13347.mvvm-model-view-viewmodel-part-1.aspx">http://social.technet.microsoft.com/wiki/contents/articles/13347.mvvm-model-view-viewmodel-part-1.aspx</a>)</p><p>Data binding will be discussed further in <em>
<a class="link" href="ch06.html" title="Chapter 6. Data Binding, and Why You Should Embrace It">Chapter 6</a>, Data Binding, and Why You Should Embrace It</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Summarizing the differences between MVC, MVP, and MVVM</h2></div></div></div><p>Now you should have a basic understanding of the MVC architectural pattern and the MVP and MVVM variations of it. A full understanding of these concepts is not necessary to move forward with learning JavaScript SPA development, but it is important to have some knowledge of the types of components that can comprise a multitier stack. Shown here is a diagram highlighting the key differences between the three architectural patterns discussed in this section:</p><p>
</p><div><img src="img/image_02_004.jpg" alt="Summarizing the differences between MVC, MVP, and MVVM"/></div><p>
</p><p>(Diagram from <a class="ulink" href="http://geekswithblogs.net/dlussier/archive/2009/11/21/136454.aspx">http://geekswithblogs.net/dlussier/archive/2009/11/21/136454.aspx</a>)</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>VIPER and other variations of MVW</h1></div></div></div><p>The primary reason that modern architectural patterns have moved away from MVC is that the Controller in MVC generally embodies too much application code and becomes unwieldy, thereby being difficult to test. This has led to patterns that not only replace the Controller with something else, but that add multiple layers in its place to further establish a separation of concerns within an application.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>VIPER</h2></div></div></div><p>In the world of <em>iOS</em>, Apple's mobile operating system, MVC was long encouraged as the pattern to follow. More recently, however, many iOS developers have moved away from pure MVC and have adopted patterns that establish more than just three layers within an application's architecture. One of these patterns is <em>VIPER,</em> which stands for <strong>View, Interactor, Presenter, Entity, and Routing</strong> (or Router).</p><p>Let's briefly cover what each of these components is:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>View</strong>: Just as with MVC, the View represents the user interface.</li><li class="listitem" style="list-style-type: disc"><strong>Interactor</strong>: Contains the business logic for a particular behavior and corresponding View within the app. An Interactor is similar to a Controller in MVC, but it may interact with multiple Models and is not constrained to only one Model.</li><li class="listitem" style="list-style-type: disc"><strong>Presenter</strong>: Contains logic for the View, just as with MVP.</li><li class="listitem" style="list-style-type: disc"><strong>Entity</strong>: Another word for <em>Model</em>, simply used to achieve the <em>E</em> in the <strong>VIPER</strong> acronym.</li><li class="listitem" style="list-style-type: disc"><strong>Routing</strong>: Each request in an app is made using a unique call, and in the case of a web application, a URL or <em>route</em> from the browser is used to make an application request. This layer may also be called the Router.</li></ul></div><p>It is evident from the description of the components in VIPER that they do not actually flow in the order of the acronym itself, but rather are ordered as such for aesthetic purposes. The diagram below shows the true flow of the VIPER pattern, along with representations of the browser and the database to supplement the understanding of this flow:</p><p>
</p><div><img src="img/image_02_005.jpg" alt="VIPER"/></div><p>
</p><p>(Diagram from <a class="ulink" href="http://khanlou.com/2014/03/model-view-whatever/">http://khanlou.com/2014/03/model-view-whatever/</a>)</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Other variations of MVW</h2></div></div></div><p>So far, we have covered the traditional MVC architectural pattern, MVP, MVVM, and the more recently contrived VIPER pattern. What should be clear is the patterns that have followed MVC do not represent a full paradigm shift, but rather a restructuring of the traditional Controller component to embody more clarity, and in the case of VIPER, to be divided into a further separation of concerns. The general paradigm is not lost in these other patterns because the concept of the Model and the View remain intact. This trend is what has led to the generalized paradigmatic term <em>Model-View-Whatever</em> or MVW.</p><p>What we are left with is a multitude of architectural patterns that have been conceived as abstractions of MVC. So, what pattern should you choose for a JavaScript SPA? This is a highly subjective topic, so the best answer is that you should choose a pattern based on the type of app you are building, and also based on what makes the most sense to you and what you are most comfortable with.</p><p>The software libraries and frameworks you choose to work with should also factor into what pattern you use. In that regard, let's take a look at how AngularJS has adapted MVC for its own version of MVW.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>AngularJS and MVW</h1></div></div></div><p>AngularJS is a frontend JavaScript framework for building web applications, and it is a core component of the MEAN stack. It provides developers with the ability to use custom HTML attributes and elements to drive behavior within an app. It also provides some handy features such as two-way data binding and dependency injection.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>A brief history of AngularJS</h2></div></div></div><p>AngularJS began as a side project of two Google developers, but eventually became an official Google open source project. Since its inception, it has undergone many changes in its methodology, including a transition away from touting MVC as its pattern of choice. Instead, the AngularJS team now labels it as <em>a JavaScript MVW framework</em> (at the time of writing).</p><p>The reason for the declaration of AngularJS to be MVW was in response to extensive debate and confusion from the developer community over what pattern AngularJS follows. The label itself may not be important to some developers, but it is important in highlighting the fact that the architectural pattern AngularJS uses is more complex than traditional MVC. AngularJS does, however, include a Controller component, among others. Let's take a closer look at what those components are.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>AngularJS components</h2></div></div></div><p>AngularJS is designed for creating web applications, and as such, it includes conceptual components that do not exist in traditional MVC. Also keep in mind that AngularJS is a frontend framework only, so it is agnostic of what server-side framework and database solution is used.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec5"/>Template</h3></div></div></div><p>A <strong>Template</strong> in AngularJS is an HTML document that contains special markup allowing it to be parsed to handle dynamic data, as with any web template system. AngularJS uses its own proprietary web template system as opposed to a third-party one, such as <strong>Handlebars</strong>. Just like Handlebars, however, AngularJS uses double curly brace notation to identify expressions within the HTML markup:</p><pre class="programlisting">&lt;html ng-app="myApp"&gt; &#13;
&lt;head&gt; &#13;
    &lt;script src="img/angular.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="img/app.js"&gt;&lt;/script&gt; &#13;
&lt;/head&gt; &#13;
&lt;body ng-controller="UsersController"&gt; &#13;
 &#13;
    &lt;ul&gt; &#13;
        &lt;li ng-repeat="user in users"&gt; &#13;
            {{user.first_name}} {{user.last_name}} &#13;
        &lt;/li&gt; &#13;
    &lt;/ul&gt; &#13;
 &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>This is an example of a simple AngularJS template. You can see that it is constructed like a normal HTML document, but it also includes AngularJS expressions. You will also notice that there are special HTML attributes prefixed by <code class="literal">ng-</code>, which convey different types of application information to the AngularJS framework.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec6"/>Directives</h3></div></div></div><p>Directives are special HTML markup that AngularJS uses to drive behaviors within the DOM. A directive can be driven by a custom HTML attribute prefixed with <code class="literal">ng</code>, a custom HTML element name such as <code class="literal">&lt;my-element&gt;&lt;/my-element&gt;</code>, a comment, or a CSS class.</p><p>You can define your own directives for your application, but AngularJS also includes some predefined directives for common use cases. For example, the <code class="literal">ng-repeat</code> attribute shown in the previous example uses the built-in <code class="literal">ngRepeat</code> directive, which is used to render template markup once per item while iterating over a collection:</p><pre class="programlisting">    &lt;ul&gt; &#13;
        &lt;li ng-repeat="user in users"&gt; &#13;
            {{user.first_name}} {{user.last_name}} &#13;
        &lt;/li&gt; &#13;
    &lt;/ul&gt; &#13;
</pre><p>In the example, the <code class="literal">users</code> object is iterated over and properties of each <code class="literal">user</code> are rendered from the template.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec7"/>Model</h3></div></div></div><p>The <em>Model</em> is a representation of the variable data available for use within expressions in the current View. The Model available to a View is confined to a particular <strong>Scope</strong>, or context:</p><pre class="programlisting">$scope.users = [ &#13;
    { &#13;
        id: 1, &#13;
        first_name: 'Peebo', &#13;
        last_name: 'Sanderson' &#13;
    }, &#13;
    { &#13;
        id: 2, &#13;
        first_name: 'Udis', &#13;
        last_name: 'Petroyka' &#13;
    } &#13;
]; &#13;
</pre><p>In this example, an array of <code class="literal">users</code> is registered on the <code class="literal">$scope</code> object. This exposes the <code class="literal">users</code> variable to a template that has access to this particular scope.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec8"/>Scope</h3></div></div></div><p>The Scope is a JavaScript object that defines the Model context for variables within the View. As shown in the previous example, <code class="literal">$scope.users</code> would be accessed in the View for that Scope as <code class="literal">{{users}}</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec9"/>Expressions</h3></div></div></div><p>An <strong>Expression</strong> in AngularJS is just like an expression in any web template system, as explained earlier. Double curly brace notation is used to identify expressions in AngularJS:</p><pre class="programlisting">    &lt;ul&gt; &#13;
        &lt;li ng-repeat="user in users"&gt; &#13;
            {{user.first_name}} {{user.last_name}} &#13;
        &lt;/li&gt; &#13;
    &lt;/ul&gt; &#13;
</pre><p>In this example, <code class="literal">{{user.first_name}}</code> and <code class="literal">{{user.last_name}}</code> are AngularJS expressions.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Compiler</h3></div></div></div><p>The <strong>Compiler</strong> parses Template markup and evaluates it for Directives and Expressions to drive the behavior and data within the View. The AngularJS compiler is internal to the framework and not something that you will often access or interact with directly.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec11"/>Filter</h3></div></div></div><p>A <strong>Filter</strong> is used to format an Expression in the View to be presented in a particular way. For example, the View may be passed a currency amount from the Model in the form of a number. A Filter can be added to the Expression in order to format what the user sees as a monetary value with a currency symbol. The pipe <code class="literal">|</code> symbol is used within the double curly brace notation to append a filter:</p><pre class="programlisting">&lt;p&gt;&lt;strong&gt;Cost:&lt;/strong&gt; {{ total | currency }} &#13;
</pre><p>In this example, <code class="literal">total</code> represents the Expression and <code class="literal">currency</code> represents the Filter.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec12"/>View</h3></div></div></div><p>Just as with traditional MVC, the View in AngularJS is the user interface. Views are composed of Templates, and the terms are largely interchangeable in the context of an AngularJS application.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Data binding</h3></div></div></div><p>Data binding in AngularJS is <em>bidirectional</em>, or two-way, so data changed in the View is updated in the Model, and data changed in the Model is updated in the View. This is done automatically, without the need for any additional business logic to handle the changes.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Controller</h3></div></div></div><p>A Controller is really a <em>View Controller</em> in AngularJS, since it is a purely frontend framework. Like traditional MVC, the Controller contains business logic, but that business logic only pertains to the View:</p><pre class="programlisting">var myApp = angular.module('myApp', []); &#13;
myApp.controller('UsersController', function($scope) { &#13;
    $scope.users = [ &#13;
        { &#13;
            id: 1, &#13;
            first_name: 'Peebo', &#13;
            last_name: 'Sanderson' &#13;
        }, &#13;
        { &#13;
            id: 2, &#13;
            first_name: 'Udis', &#13;
            last_name: 'Petroyka' &#13;
        } &#13;
    ]; &#13;
}); &#13;
</pre><p>A <code class="literal">UsersController</code> could be created, for example, that contains the <code class="literal">users</code> Model shown previously and exposes it in the View through its <code class="literal">$scope</code> object.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec15"/>Dependency injection</h3></div></div></div><p>The term <em>dependency injection</em> is commonly used with respect to JavaScript as the ability to asynchronously add resources to the current web page. In AngularJS, the concept is similar, but only with regard to other AngularJS components. For example, Directives, Filters, and Controllers are all injectable.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec16"/>Injector</h3></div></div></div><p>The <strong>Injector</strong> is the container for dependencies and is responsible for finding them and adding them when needed. It is decoupled from the application code using declarative syntax within the View and is typically not accessed directly.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec17"/>Module</h3></div></div></div><p>The <strong>Module</strong> is a container for all the main components of an app. It gives the app a main namespace reference to all associated Directives, Services, Controllers, Filters, and any additional configuration information:</p><pre class="programlisting">Var myAppModule = angular.module('myApp', []); &#13;
</pre><p>If your Module depends on any other Modules, you can add them to the empty array parameter shown in the previous example.</p><p>To apply a Module to an SPA using AngularJS, you can simply declare the name of the module within your main page's HTML using the custom <code class="literal">ng-app</code> attribute on your app container element:</p><pre class="programlisting">&lt;body ng-app="myApp"&gt; &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec18"/>Service</h3></div></div></div><p>The <strong>Service</strong> is a component that differentiates AngularJS from traditional MVC in that it is used to contain reusable business logic that you may want to share across different Controllers within your app. This helps to keep Controllers from becoming too large and complicated, and also allows different parts of the app to share some commonly used business logic. Currency conversion, for example, is something that could be written as a Service because you may want to use it in multiple Controllers.</p><p>The following diagram illustrates how the components of AngularJS interact with each other:</p><p>
</p><div><img src="img/image_02_006.jpg" alt="Service"/></div><p>
</p><p>(Diagram from <a class="ulink" href="https://dzone.com/refcardz/angularjs-essentials">https://dzone.com/refcardz/angularjs-essentials</a>)</p><p>AngularJS 2.x (in beta at the time of writing) differs in its architectural pattern from v1.x, which is the version represented here.</p><p>Now that you have a better understanding of the components that comprise the AngularJS MVW architectural pattern and how those components pertain to a frontend SPA architecture, let's apply some of these MVW principles to a simple JavaScript SPA example.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Using the MVW pattern in an SPA</h1></div></div></div><p>It should now be clear to you that MVW is not a precise architectural pattern, but rather a paradigm in which you have a Model, a View, and a nebulous third component, or more components, depending on how fine-grained you decide to break down your separation of concerns. Everything falling within that gray area is based on what type of application you are building, what architectural components you are comfortable with as a developer, and what frameworks and libraries you are working with.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Building a simple JavaScript SPA</h2></div></div></div><p>The complexity of your SPA should always be a factor in what technologies you use to build it. More to the point, you should not go into every project assuming you will always use a certain technology stack or framework. This rule goes for the MEAN stack as well.</p><p>Let's take the User Model example from earlier, and the accompanying Handlebars template View, and actually build it out as an SPA, complete with the AJAX request to retrieve the User Model data. For something simple like this, using AngularJS and the MEAN stack would definitely be overkill. Let's begin by using the NPM, Bower, and Grunt environment you set up in <a class="link" href="ch01.html" title="Chapter 1. Getting Organized with NPM, Bower, and Grunt"><em>Chapter 1</em></a><em>Getting Organized NPM, Bower, and Grunt</em>. So how do we proceed?</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec19"/>Creating the Model</h3></div></div></div><p>The Model is the simple JSON object of user data we defined earlier. Rather than setting up a database for this, let's simply place it in a text file and name it <code class="literal">user.json</code>:</p><pre class="programlisting">{ &#13;
    "id": 1, &#13;
    "name": { &#13;
        "first": "Philip", &#13;
        "last": "Klauzinski" &#13;
    }, &#13;
    "title": "Sr. UI Engineer", &#13;
    "website": "http://webtopian.com" &#13;
} &#13;
</pre><p>Save the file to the same directory as your <code class="literal">package.json</code>, <code class="literal">bower.json</code>, and <code class="literal">Gruntfile.js</code>. Feel free to replace the user information with your own for this example.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec20"/>Creating the View</h3></div></div></div><p>The View for this example will be the web template document we defined earlier with a definition list containing user information:</p><pre class="programlisting">&lt;h1&gt;User Information&lt;/h1&gt; &#13;
&lt;dl&gt; &#13;
    &lt;dt&gt;Name&lt;/dt&gt; &#13;
    &lt;dd&gt;{{name.first}} {{name.last}}&lt;/dd&gt; &#13;
    &lt;dt&gt;Title&lt;/dt&gt; &#13;
    &lt;dd&gt;{{title}}&lt;/dd&gt; &#13;
    &lt;dt&gt;Website&lt;/dt&gt; &#13;
    &lt;dd&gt;{{website}}&lt;/dd&gt; &#13;
&lt;/dl&gt; &#13;
</pre><p>Save this file to the root directory of your project as well and name it <code class="literal">user.handlebars</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec21"/>Setting up frontend assets</h3></div></div></div><p>We are not creating a complex SPA in this case, so we will not use any frontend frameworks, but we do want to install a few libraries to make development easier.</p><p>If you followed the examples in <a class="link" href="ch01.html" title="Chapter 1. Getting Organized with NPM, Bower, and Grunt"><em>Chapter 1</em></a>,<em> Getting Organized with NPM, Bower</em>, and Grunt you should already have jQuery installed via Bower. If you have not yet installed it, go ahead and do so now:</p><pre class="programlisting">
<strong>$ bower install jquery --save</strong>
</pre><p>We will use jQuery for handling AJAX requests and DOM manipulation within the SPA.</p><p>Now let's install the Handlebars library for parsing our web template View:</p><pre class="programlisting">
<strong>$ bower install handlebars --save</strong>
</pre><div><div><div><div><h4 class="title"><a id="ch02lvl4sec7"/>Compiling web templates</h4></div></div></div><p>A web template has to be compiled to JavaScript before it can be parsed for expressions. This can be done in the browser using the Handlebars frontend library, but it means longer execution times when loading templates, and it also means loading a larger library asset file on the initial page load. The initial page load is critical for a SPA because you do not want the user waiting a long time for your app to download assets and prepare the page for the initial View. Additionally, if you want to separate your Views into separate files, as we did with <code class="literal">user.handlebars</code>, then those View files have to be loaded asynchronously at some point to hand over to the compiler.</p></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec8"/>Precompiling web templates</h4></div></div></div><p>To circumvent large asset payloads and extraneous round trips to the server to fetch Views, Handlebars allows you to <em>precompile</em> web templates to JavaScript so that they can be used immediately within your app. This gives you the ability to separate your Views into different files and keep things organized and still maintain a lower initial page load.</p><p>For this example, let's install the Handlebars Node.js package globally so that it can be used from the command line in any directory:</p><pre class="programlisting">
<strong>$ npm install handlebars -g</strong>
</pre><p>This will now allow you to compile your templates on the command line to create a precompiled JavaScript template file you can use in your SPA. From the root of your project directory, enter the following:</p><pre class="programlisting">
<strong>$ handlebars *.handlebars -f templates.js</strong>
</pre><p>This command is telling the Handlebars compiler to take all files with the extension .<code class="literal">handlebars</code> (in this case only <code class="literal">user.handlebars</code>) and compile them to a single file named <code class="literal">templates.js</code>. This could allow to you have 100 separate web template View files and precompile them to one JavaScript file, for example. This is a good practice because it allows you to map each View file to a REST API endpoint on your server side. In the case of our SPA example, our endpoint will be requesting the <code class="literal">user.json</code> file through AJAX.</p></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec9"/>Handling server HTTP requests</h4></div></div></div><p>Now we will install the <em>PayloadJS</em> library for handling REST requests within the SPA:</p><pre class="programlisting">
<strong>$ bower install payloadjs --save</strong>
</pre><p>PayloadJS will allow us to easily make AJAX requests triggered from our SPA markup by using custom <code class="literal">data-</code> HTML attributes to define behaviors and parameters in the DOM.</p></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec22"/>Creating the SPA layout</h3></div></div></div><p>One of the most important pieces of a SPA is the <em>single page</em> itself, or the <em>layout</em> for your app. This is the one and only server-side HTML page that you will load in order to initialize and display your app.</p><p>Create a file in the root of your directory named <code class="literal">index.html</code>, and enter the following code into it:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;head&gt; &#13;
        &lt;title&gt;My Application&lt;/title&gt; &#13;
    &lt;/head&gt; &#13;
    &lt;body&gt; &#13;
        &lt;p&gt;&lt;a href="#" data-url="/user.json" data-template="user" data-selector=".results"&gt;Load user data&lt;/a&gt;&lt;/p&gt; &#13;
        &lt;div class="results"&gt;&lt;/div&gt; &#13;
        &lt;script src="img/jquery.min.js"&gt;&lt;/script&gt; &#13;
        &lt;script src="img/handlebars.runtime.min.js"&gt;&lt;/script&gt; &#13;
        &lt;script src="img/payload.js"&gt;&lt;/script&gt; &#13;
        &lt;script src="img/templates.js"&gt;&lt;/script&gt; &#13;
        &lt;script&gt; &#13;
            Payload.deliver({ &#13;
                templates: Handlebars.templates             &#13;
            }); &#13;
        &lt;/script&gt; &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>This will be the main layout page for your SPA. You will notice that <code class="literal">script</code> tag references have been added that point to jQuery, Handlebars, PayloadJS, and the <code class="literal">templates.js</code> file we created. These are all of the assets you will need loaded in order to run this SPA. Additionally, the <code class="literal">Payload.deliver()</code> command is run at the bottom of the page and passed an object to overwrite any of its default initialization options. This method simply initializes PayloadJS to drive the behavior within the DOM indicated in the <code class="literal">data-</code> attributes on the link with the text <strong>Load user data</strong>. In this case, we are setting the <code class="literal">templates</code> property that is passed in to <code class="literal">Handlebars.templates</code>, since that is the namespace containing our Handlebars template.</p><p>For more information on using PayloadJS, please see payloadjs.com.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec23"/>Serving the SPA</h3></div></div></div><p>Now you have all of the necessary files in place to run this simple SPA. The only thing left is a local server to run and load the <code class="literal">index.html</code> file for testing. Let's install a simple HTTP server with NPM for this purpose:</p><pre class="programlisting">
<strong>$ npm install http-server -g</strong>
</pre><p>Install this package globally so that it can be run from the command line. This simple Node.js HTTP server can be run specifying any local directory as your server. In this case, we want to run the server for the current project directory:</p><pre class="programlisting">
<strong>$ http-server ./ </strong>
</pre><p>After running this command, you should see something similar to the following output in your console:</p><pre class="programlisting">
<strong>Starting up http-server, serving ./</strong>
<strong>Available on:</strong>
<strong>  http:127.0.0.1:8080</strong>
<strong>  http:192.168.0.2:8080</strong>
<strong>Hit CTRL-C to stop the server</strong>
</pre><p>This indicates that the HTTP server is running and available locally.</p><p>Now you should be able to go to a browser and load the URL <code class="literal">localhost:8080</code> and you will see the contents of the <code class="literal">index.html</code> page you created. The only visible content of the page is the link with the text <strong>Load user data</strong>. If everything is set up properly and you click on that link, you should notice a <strong>Loading...</strong> indicator below it for a brief moment, followed by the contents of the <code class="literal">user.handlebars</code> template file populated with the data from the <code class="literal">user.json</code> file loaded into the page:</p><p>
</p><div><img src="img/image_02_007.jpg" alt="Serving the SPA"/></div><p>
</p><p>The full page with the response after clicking on the link should look similar to the preceding screenshot.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec24"/>Overview of a simple JavaScript SPA</h3></div></div></div><p>So we have created a simple JavaScript SPA using a general MVW pattern with the following components:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Model: <code class="literal">user.json</code></li><li class="listitem" style="list-style-type: disc">View: <code class="literal">user.handlebars</code></li><li class="listitem" style="list-style-type: disc">Precompiled templates file: <code class="literal">templates.js</code></li><li class="listitem" style="list-style-type: disc">SPA layout page: <code class="literal">index.html</code></li><li class="listitem" style="list-style-type: disc">HTTP server: Node.js <em>http-server</em> package</li></ul></div><p>This is about as simple as it gets, but you have created an SPA nonetheless. This example should give you an idea of how powerful JavaScript can be for creating a single page application. Feel free to extend this simple SPA with more Model data files, additional web template Views, some CSS, and a bit of your own creativity.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>You should now have an understanding of the traditional MVC pattern, MVP, MVVM, VIPER, and the reasons for the transition away from traditional MVC and conventions leading to the more generalized MVW pattern. The should also understand that the term <em>Model-View-Whatever</em>, or <em>MVW</em>, was largely popularized by the AngularJS team, and that this was done in regard to the modern SPA requiring a new and more complex set of components that were non-existent when the original MVC pattern was conceived of.</p><p>You also should now have the ability to build a simple JavaScript SPA with just a few Node.js and Bower packages. Now it's on to bigger and better things. In the next chapter, we will discuss how to create the ideal application development environment for a SPA by expanding on the Node.js environment we have been working with so far.</p></div></body></html>