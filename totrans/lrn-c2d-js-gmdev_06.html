<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Controlling the Game with Virtual Pads"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Controlling the Game with Virtual Pads</h1></div></div></div><p>One of the most important things to consider when making a cross-platform game is the way the player will control the main character. Most of the devices your game will be running on won't have a keyboard or a mouse, and although more and more portable devices now support pads, your game must also be playable without pads.</p><p>In this chapter, I will show you three of the most popular ways to create virtual pads on any device. Among other things, you will learn how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scroll big images to give an idea of an endless background</li><li class="listitem" style="list-style-type: disc">Schedule events</li><li class="listitem" style="list-style-type: disc">Control the frame rate</li><li class="listitem" style="list-style-type: disc">Check collision between sprites</li><li class="listitem" style="list-style-type: disc">Create a simple particle system</li><li class="listitem" style="list-style-type: disc">Move sprites manually or using actions</li></ul></div><p>So, the first thing to do is take a look at how successful games allow players to interact with them using virtual pads.</p><div class="section" title="Overview of virtual pads"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Overview of virtual pads</h1></div></div></div><p>The oldest, simplest, and highly discouraged way to create virtual pads is placing directional <a id="id214" class="indexterm"/>buttons on the screen and controlling the character according to the button pressed by the player.</p><p>I also used this kind of virtual pad in the first version of my <span class="emphasis"><em>Sokoban</em></span> game before I made the game playable with swipes, as I showed you during the creation of <span class="emphasis"><em>Cocosban</em></span> game.</p><div class="mediaobject"><img src="graphics/0075SOS_06_01.jpg" alt="Overview of virtual pads"/><div class="caption"><p>The Sokoban game</p></div></div><p>In this game, you move the character by clicking or tapping exactly on an arrow button. It can fit in a slow-paced puzzle game, but becomes unplayable in a fast-paced arcade.</p><p>That's why famous <a id="id215" class="indexterm"/>platform games such as <span class="emphasis"><em>Mikey Shorts</em></span> use ghost buttons. Ghost buttons act like normal buttons, but the sensible area is way bigger than the icon itself.</p><div class="mediaobject"><img src="graphics/0075SOS_06_02.jpg" alt="Overview of virtual pads"/></div><p>Although the buttons aren't bigger than the ones used in my <span class="emphasis"><em>Sokoban</em></span> game, the sensible area covers the entire screen: the actual red button sensible area is the whole column of the screen covering the red button icon, the blue button sensible area is the whole column of the screen covering the blue button icon, and so on.</p><p>Another way to handle <a id="id216" class="indexterm"/>virtual pads is by using the virtual analogic pad. Although, the way to control <span class="emphasis"><em>Mikey Shorts</em></span> is digital, which means one button can only be pressed or released; sometimes, games require more precision in movements like the following screenshot of the <span class="emphasis"><em>Grand Theft Auto</em></span> series:</p><div class="mediaobject"><img src="graphics/0075SOS_06_03.jpg" alt="Overview of virtual pads"/></div><p>On the bottom left-hand side of the screen, you can see a virtual analogic pad. The pad is initially activated by <a id="id217" class="indexterm"/>touching the screen, then the further you drag the pad from its original position, the faster the character will walk or run.</p><p>Another way to create virtual pads that I would like to mention is the one used in the <span class="emphasis"><em>VVVVVV</em></span> game, which does not show any icon. A screenshot of the <span class="emphasis"><em>VVVVVV</em></span> game is shown as follows:</p><div class="mediaobject"><img src="graphics/0075SOS_06_04.jpg" alt="Overview of virtual pads"/></div><p>You simply move the character left and right by continuously dragging, or dragging and holding your finger on the device, and I have to say it works way better than the old virtual pad because you can virtually use any spot on the device to move. Above all, there isn't any <span class="emphasis"><em>origin</em></span> you have to cross to change direction: no matter how far you move your finger from the point <a id="id218" class="indexterm"/>you start touching, once you move the finger in the opposite direction, the character will walk in the other direction.</p><p>Now, apart from the first example, which I said is obsolete, you will see how to create all these ways to control your character with virtual pads.</p></div></div>
<div class="section" title="First things first &#x2013; the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>First things first – the game</h1></div></div></div><p>We are <a id="id219" class="indexterm"/>making a little game just to test our virtual pads: a <a id="id220" class="indexterm"/>landscape game with a shopping cart surrounded by falling bombs and strawberries trying to catch strawberries while avoiding bombs? Does it sound crazy? It is.</p><p>This is the content of our <code class="literal">assets</code> folder:</p><div class="mediaobject"><img src="graphics/0075SOS_06_05.jpg" alt="First things first – the game"/></div><p>The making of the entire game is very similar to the making of the endless space runner, so there's no need to talk about code you should already know.</p><p>This is the content of <code class="literal">main.js</code>:</p><div class="informalexample"><pre class="programlisting">cc.game.onStart = function(){
  var screenSize = cc.view.getFrameSize();
  cc.view.setDesignResolutionSize(480, 320, cc.ResolutionPolicy.SHOW_ALL);
  cc.LoaderScene.preload(gameResources, function () {
    cc.director.runScene(new gameScene());
  }, this);
};
cc.game.run();</pre></div><p>Just look at the resolution policy to make the game work in landscape mode.</p><p>This is the content of <code class="literal">loadassets.js</code>:</p><div class="informalexample"><pre class="programlisting">var gameResources = [
  "assets/bomb.png",
  "assets/cart.png",
  "assets/strawberry.png",
  "assets/leftbutton.png",
  "assets/rightbutton.png"
];</pre></div><p>The content of <code class="literal">gamescript.js</code>, as said, is very similar to the content of the endless space runner.</p><p>First, let's <a id="id221" class="indexterm"/>take a look at the final result:</p><div class="mediaobject"><img src="graphics/0075SOS_06_06.jpg" alt="First things first – the game"/></div><p>We have a <a id="id222" class="indexterm"/>cart in the bottom center of the stage, and fruit and bombs falling every second with a random trajectory.</p><p>As I already told you, there's nothing new! You should know everything you need to build this game. This is <code class="literal">gamescript.js</code>: first, you need two global variables to handle the cart itself and the layer that will be filled with fruit and bombs:</p><div class="informalexample"><pre class="programlisting">var itemsLayer;
var cart;</pre></div><p>The <code class="literal">gameScene</code> is then defined as usual:</p><div class="informalexample"><pre class="programlisting">var gameScene = cc.Scene.extend({
  onEnter:function () {
    this._super();
    gameLayer = new game();
    gameLayer.init();
    this.addChild(gameLayer);
  }
});</pre></div><p>The <code class="literal">game</code> class <a id="id223" class="indexterm"/>declaration contains the core of the <a id="id224" class="indexterm"/>game itself:</p><div class="informalexample"><pre class="programlisting">var game = cc.Layer.extend({
  init:function () {
    this._super();
    var backgroundLayer = cc.LayerGradient.create(cc.color(0,0,0,255), cc.color(0x46,0x82,0xB4,255));
    this.addChild(backgroundLayer);
    itemsLayer = cc.Layer.create()
    this.addChild(itemsLayer)
    topLayer = cc.Layer.create()
    this.addChild(topLayer)
    cart = cc.Sprite.create("assets/cart.png");
    topLayer.addChild(cart,0);
    cart.setPosition(240,24);
    this.schedule(this.addItem,1);
  },
  addItem:function(){
    var item = new Item();
    itemsLayer.addChild(item,1);
  },
  removeItem:function(item){
    itemsLayer.removeChild(item);
  }
});</pre></div><p>This looks like it's a lot of code, but there's nothing new: we simply add a background gradient, then two layers: one for fruit and bombs and one for the cart, and finally, we add the cart itself. To create fruit and bombs, we use the <code class="literal">schedule</code> method, which calls the <code class="literal">addItem</code> function every second to create a new <code class="literal">Item</code> class instance, while the <code class="literal">removeItem</code> function will remove fruit and bombs once they fly off the screen.</p><p>This is really <a id="id225" class="indexterm"/>similar to the creation of the space endless <a id="id226" class="indexterm"/>runner, and the same goes for the creation of fruit and bombs in the <code class="literal">Item</code> declaration:</p><div class="informalexample"><pre class="programlisting">var Item = cc.Sprite.extend({
  ctor:function() {
    this._super();
    if(Math.random()&lt;0.5){
      this.initWithFile("assets/bomb.png");
      this.isBomb=true;
    }
    else{
      this.initWithFile("assets/strawberry.png");
      this.isBomb=false;
    }
  },
  onEnter:function() {
    this._super();
    this.setPosition(Math.random()*400+40,350);
    var moveAction = cc.MoveTo.create(8, new cc.Point(Math.random()*400+40,-50));
    this.runAction(moveAction);
    this.scheduleUpdate();
  },
  update:function(dt){
    if(this.getPosition().y&lt;35 &amp;&amp; this.getPosition().y&gt;30 &amp;&amp; Math.abs(this.getPosition().x-cart.getPosition().x)&lt;10 &amp;&amp; !this.isBomb){
      gameLayer.removeItem(this);
      console.log("FRUIT");
    }
    if(this.getPosition().y&lt;35 &amp;&amp; Math.abs(this.getPosition().x-cart.getPosition().x)&lt;25 &amp;&amp; this.isBomb){
      gameLayer.removeItem(this);
      console.log("BOMB");
    }
    if(this.getPosition().y&lt;-30){
      gameLayer.removeItem(this)
    }
  }
});</pre></div><p>Again, there's a lot of code, but most of it is pure JavaScript and has nothing to do with Cocos2d-JS. Let's take a look at it anyway:</p><div class="informalexample"><pre class="programlisting">ctor:function() {
  this._super();
  if(Math.random()&lt;0.5){
    this.initWithFile("assets/bomb.png");
    this.isBomb=true;
  }
  else{
    this.initWithFile("assets/strawberry.png");
    this.isBomb=false;
  }
}</pre></div><p>How can you decide whether the current item will be a fruit or a bomb? By simply drawing a random number, then <a id="id227" class="indexterm"/>according to its value, use the <a id="id228" class="indexterm"/>bomb or fruit image. The <code class="literal">isBomb</code> custom attribute will tell us whether it's a bomb (<code class="literal">true</code>) or a fruit (<code class="literal">false</code>):</p><div class="informalexample"><pre class="programlisting">onEnter:function() {
  this._super();
  this.setPosition(Math.random()*400+40,350);
  var moveAction = cc.MoveTo.create(8, new cc.Point(Math.random()*400+40,-50));
  this.runAction(moveAction);
  this.scheduleUpdate();
}</pre></div><p>When it's time to place it on the stage, we put it in a random horizontal position outside the top of the screen and create a tween to move it outside the bottom of the screen in a different random horizontal position. Pretty similar to the endless runner's asteroid movement.</p><div class="informalexample"><pre class="programlisting">update:function(dt){
  if(this.getPosition().y&lt;35 &amp;&amp; this.getPosition().y&gt;30 &amp;&amp; Math.abs(this.getPosition().x-cart.getPosition().x)&lt;10 &amp;&amp; !this.isBomb){
    gameLayer.removeItem(this);
    console.log("FRUIT");
  }
  if(this.getPosition().y&lt;35 &amp;&amp; Math.abs(this.getPosition().x-cart.getPosition().x)&lt;25 &amp;&amp; this.isBomb){
    gameLayer.removeItem(this);
    console.log("BOMB");
  }
  if(this.getPosition().y&lt;-30){
    gameLayer.removeItem(this)
  }
}</pre></div><p>The <code class="literal">update</code> function ,which is called at every frame, checks for three conditions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If the <a id="id229" class="indexterm"/>item is a fruit and it's very close to the cart, then we remove the item and output some text to the console to have a debug message, which displays the player hit a fruit.</li><li class="listitem">If the item is a bomb and it's close (not as close as required by the fruit), but close to the cart, then we remove the item and output some text to the console to get a debug message, which displays the player hit a bomb. This is a difficult game, because being hit by a bomb is easier than collecting a fruit.</li><li class="listitem">If the item (no matter which kind of item) is outside the bottom of the stage, we need to remove it.</li></ol></div><p>That's all for the <a id="id230" class="indexterm"/>game. Now, you need to let the player <a id="id231" class="indexterm"/>control the cart in the three ways mentioned before.</p><div class="section" title="Controlling the cart with ghost buttons"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec11"/>Controlling the cart with ghost buttons</h2></div></div></div><p>To control <a id="id232" class="indexterm"/>the cart with ghost buttons, first, you have to place the button on the screen, which, as said, will only act as a fake button <a id="id233" class="indexterm"/>because the entire left and right area of the stage will represent the actual button.</p><p>You need to <a id="id234" class="indexterm"/>add some global variables to the script to handle left and right buttons as well as the horizontal speed:</p><div class="informalexample"><pre class="programlisting">var itemsLayer;
var cart;
<span class="strong"><strong>var xSpeed = 0;</strong></span>
<span class="strong"><strong>var left;</strong></span>
<span class="strong"><strong>var right;</strong></span>
</pre></div><p>The <code class="literal">xSpeed</code> variable represents the horizontal speed of the cart, while the <code class="literal">left</code> and <code class="literal">right</code> variables will be assigned to left and right arrow buttons.</p><p>Now, the <code class="literal">init</code> function needs to place the buttons, set the <code class="literal">touch</code> listener, and schedule the update at each frame:</p><div class="informalexample"><pre class="programlisting">init:function () {
  this._super();
  var backgroundLayer = cc.LayerGradient.create(cc.color(0,0,0,255), cc.color(0x46,0x82,0xB4,255));
  this.addChild(backgroundLayer);
  itemsLayer = cc.Layer.create()
  this.addChild(itemsLayer)
  topLayer = cc.Layer.create()
  this.addChild(topLayer)
  cart = cc.Sprite.create("assets/cart.png");
  topLayer.addChild(cart,0);
  cart.setPosition(240,24);
  <span class="strong"><strong>left = cc.Sprite.create("assets/leftbutton.png");</strong></span>
<span class="strong"><strong>  topLayer.addChild(left,0);</strong></span>
<span class="strong"><strong>  left.setPosition(40,160)</strong></span>
<span class="strong"><strong>  left.setOpacity(128)</strong></span>
<span class="strong"><strong>  right = cc.Sprite.create("assets/rightbutton.png");</strong></span>
<span class="strong"><strong>  topLayer.addChild(right,0);</strong></span>
<span class="strong"><strong>  right.setPosition(440,160);</strong></span>
<span class="strong"><strong>  right.setOpacity(128)</strong></span>
<span class="strong"><strong>  this.schedule(this.addItem,1);</strong></span>
<span class="strong"><strong>  cc.eventManager.addListener(touchListener, this);</strong></span>
<span class="strong"><strong>  this.scheduleUpdate();</strong></span>
}</pre></div><p>I would like <a id="id235" class="indexterm"/>you to check whether both <a id="id236" class="indexterm"/>left and right arrow buttons are placed on the <code class="literal">topLayer</code> and their opacity is set to half transparent. Also, look at the name of the <a id="id237" class="indexterm"/>listener variable we are going to create: <code class="literal">touchListener</code>.</p><p>Also, this is the <code class="literal">touchListener</code> declaration:</p><div class="informalexample"><pre class="programlisting">var touchListener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  swallowTouches: true,
  onTouchBegan: function (touch, event) {
    if(touch.getLocation().x &lt; 240){
      xSpeed = -2;
      left.setOpacity(255);
      right.setOpacity(128);
    }
    else{
      xSpeed = 2;
      right.setOpacity(255);
      left.setOpacity(128);
    }
    return true;
  },
  onTouchEnded:function (touch, event) {
    xSpeed = 0;
    left.setOpacity(128);
    right.setOpacity(128);
  }
})</pre></div><p>It's a touch <a id="id238" class="indexterm"/>event like the ones we've met before. Let's <a id="id239" class="indexterm"/>take a closer look at the triggered events:</p><div class="informalexample"><pre class="programlisting">onTouchBegan: function (touch, event) {
  if(touch.getLocation().x &lt; 240){
    xSpeed = -2;
    left.setOpacity(255);
    right.setOpacity(128);
  }
  else{
    xSpeed = 2;
    right.setOpacity(255);
    left.setOpacity(128);
  }
  return true;
}</pre></div><p>When the player touches <a id="id240" class="indexterm"/>the screen that deals with ghost buttons, we only need to check whether the left or right portion of the screen has been touched, set <code class="literal">xSpeed</code> accordingly as well as turn the speed to on or off, and set it at full or half opacity to the respective arrow buttons.</p><p>It's very important that the function returns <code class="literal">true</code> if you want Cocos2d-JS to be able to check when the player stops touching the screen. To acheive this, add the following code snippet:</p><div class="informalexample"><pre class="programlisting">onTouchEnded:function (touch, event) {
  xSpeed = 0;
  left.setOpacity(128);
  right.setOpacity(128);
}</pre></div><p>When the player stops <a id="id241" class="indexterm"/>touching the screen, <code class="literal">xSpeed</code> is set back to zero and both buttons are turned off.</p><p>Now, you only <a id="id242" class="indexterm"/>have to move the cart in the <code class="literal">update</code> function of the <code class="literal">game</code> class:</p><div class="informalexample"><pre class="programlisting">update:function(dt){
  if(xSpeed&gt;0){
    cart.setFlippedX(true);
  }
  if(xSpeed&lt;0){
    cart.setFlippedX(false);
  }
  cart.setPosition(cart.getPosition().x+xSpeed,cart.getPosition().y);
}</pre></div><p>There's really <a id="id243" class="indexterm"/>no need to explain anything as you are only moving the cart by <code class="literal">xSpeed</code> pixels; just take a look at the <code class="literal">setFlippedX</code> method to flip the cart horizontally when it's going right.</p><p>Run the game and you will see what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0075SOS_06_08.jpg" alt="Controlling the cart with ghost buttons"/></div><p>Touch the <a id="id244" class="indexterm"/>screen anywhere to move the cart to the left or to the right according to the position of the screen you are touching. That's all <a id="id245" class="indexterm"/>about ghost buttons. Now, let's see <a id="id246" class="indexterm"/>how to control the game using the virtual pad.</p></div><div class="section" title="Controlling the cart with a virtual pad"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec12"/>Controlling the cart with a virtual pad</h2></div></div></div><p>The first <a id="id247" class="indexterm"/>thing to do in order to control a game with a <a id="id248" class="indexterm"/>virtual pad is to have a virtual pad. So we need to change some images in our <code class="literal">assets</code> folder:</p><div class="mediaobject"><img src="graphics/0075SOS_06_09.jpg" alt="Controlling the cart with a virtual pad"/></div><p>The left and right buttons have been removed to be replaced by virtual pad images, so <code class="literal">loadassets.js</code> changes this way:</p><div class="informalexample"><pre class="programlisting">var gameResources = [
  "assets/bomb.png",
  "assets/cart.png",
  "assets/strawberry.png",
  <span class="strong"><strong>"assets/touchorigin.png",</strong></span>
  <span class="strong"><strong>"assets/touchend.png"</strong></span>
];</pre></div><p>Obviously, most of the game remains the same because you are only changing the way you control <a id="id249" class="indexterm"/>the cart. You need to change the global <a id="id250" class="indexterm"/>variables a bit:</p><div class="informalexample"><pre class="programlisting">var itemsLayer;
var cart;
var xSpeed = 0;
<span class="strong"><strong>var touchOrigin;</strong></span>
<span class="strong"><strong>var touching = false;</strong></span>
<span class="strong"><strong>var touchEnd;</strong></span>
</pre></div><p>While game-related variables remain the same, I added two new variables called <code class="literal">touchOrigin</code> and <code class="literal">touchEnd</code>, which will handle virtual pad touches. Also, the variables used before to handle buttons have been removed. A Boolean variable called <code class="literal">touching</code> will tell us whether the player is touching the screen.</p><p>Now, the <code class="literal">init</code> function of the <code class="literal">game</code> class needs some changes too:</p><div class="informalexample"><pre class="programlisting">init:function () {
  this._super();
  var backgroundLayer = cc.LayerGradient.create(cc.color(0,0,0,255), cc.color(0x46,0x82,0xB4,255));
  this.addChild(backgroundLayer);
  itemsLayer = cc.Layer.create()
  this.addChild(itemsLayer)
  topLayer = cc.Layer.create()
  this.addChild(topLayer)
  cart = cc.Sprite.create("assets/cart.png");
  topLayer.addChild(cart,0);
  cart.setPosition(240,24);
  this.schedule(this.addItem,1);
  cc.eventManager.addListener(touchListener, this);
  this.scheduleUpdate();
}</pre></div><p>Basically, all <a id="id251" class="indexterm"/>lines about the left and right button have been <a id="id252" class="indexterm"/>removed, but the core of the script is in the <code class="literal">touchListener</code> declaration:</p><div class="informalexample"><pre class="programlisting">var touchListener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  swallowTouches: true,
  onTouchBegan: function (touch, event) {
    touchOrigin = cc.Sprite.create("assets/touchorigin.png");
    topLayer.addChild(touchOrigin,0);
    touchOrigin.setPosition(touch.getLocation().x,touch.getLocation().y);
    touchEnd = cc.Sprite.create("assets/touchend.png");
    topLayer.addChild(touchEnd,0);
    touchEnd.setPosition(touch.getLocation().x,touch.getLocation().y);
    touching = true;
    return true;
  },
  onTouchMoved: function (touch, event) {
    touchEnd.setPosition(touch.getLocation().x,touchEnd.getPosition().y);
  },
  onTouchEnded:function (touch, event) {
    touching = false;
    topLayer.removeChild(touchOrigin);
    topLayer.removeChild(touchEnd);
  }
})</pre></div><p>The first thing I would like you to see is the three events:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">onTouchBegan</code>: This <a id="id253" class="indexterm"/>event places both virtual pad <a id="id254" class="indexterm"/>sprites in the touch location and sets the <code class="literal">touching</code> Boolean variable to <code class="literal">true</code>.</li><li class="listitem"><code class="literal">onTouchMoved</code>: This <a id="id255" class="indexterm"/>event updates the <a id="id256" class="indexterm"/><code class="literal">touchEnd</code> sprite to the current touch position. As the name suggests, this event is triggered when the player moves their finger around the screen.</li><li class="listitem"><code class="literal">onTouchEnded</code>: This <a id="id257" class="indexterm"/>event removes both virtual pad <a id="id258" class="indexterm"/>sprites and sets the <code class="literal">touching</code> Boolean variable to <code class="literal">false</code>.</li></ol></div><p>It's easy to <a id="id259" class="indexterm"/>guess how I am moving the cart in the <code class="literal">update</code> function of the <code class="literal">game</code> class. If the <code class="literal">touching</code> variable is <code class="literal">true</code>, the cart speed is the difference <a id="id260" class="indexterm"/>between the <code class="literal">touchEnd</code> and <code class="literal">touchOrigin</code> functions' <span class="emphasis"><em>x</em></span> coordinates:</p><div class="informalexample"><pre class="programlisting">update:function(dt){
  if(touching){
    xSpeed = (touchEnd.getPosition().x-touchOrigin.getPosition().x)/50;
    if(xSpeed&gt;0){
      cart.setFlippedX(true);
    }
    if(xSpeed&lt;0){
      cart.setFlippedX(false);
    }
    cart.setPosition(cart.getPosition().x+xSpeed,cart.getPosition().y);
  }
}</pre></div><p>Being an analogic pad, the greater the difference between the <code class="literal">touchEnd</code> and <code class="literal">touchOrigin</code> functions' <span class="emphasis"><em>x</em></span> coordinates, the faster the cart movement. I divided the difference by <code class="literal">50</code> to keep the game playable; otherwise, the game would move too fast.</p><p>Test the game and play.</p><div class="mediaobject"><img src="graphics/0075SOS_06_10.jpg" alt="Controlling the cart with a virtual pad"/></div><p>Touch and drag <a id="id261" class="indexterm"/>the screen to move the cart at the proper <a id="id262" class="indexterm"/>speed. Also, that's all for the analogic virtual pad too.</p></div><div class="section" title="Controlling the cart just with your finger"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec13"/>Controlling the cart just with your finger</h2></div></div></div><p>Although you have been controlling the cart with your finger throughout the entire chapter, you have <a id="id263" class="indexterm"/>always had visual feedback of your movements. The last way to move the cart that I am going to show in this chapter does not <a id="id264" class="indexterm"/>provide any visual feedback, but it works great in games where movements are limited to one axis, such as the one you are making now.</p><p>First, you don't need any graphic assets except the ones directly related to the game, so our <code class="literal">loadassets.js</code> file is smaller than ever:</p><div class="informalexample"><pre class="programlisting">var gameResources = [
"assets/bomb.png",
"assets/cart.png",
"assets/strawberry.png"
];</pre></div><p>Now, the changes are even smaller than the ones you made when you created the virtual pad from the ghost button: you just need to change the global variables a bit:</p><div class="informalexample"><pre class="programlisting">var itemsLayer;
var xSpeed = 0;
var cart;
<span class="strong"><strong>var detectedX;</strong></span>
<span class="strong"><strong>var savedX;</strong></span>
var touching=false;</pre></div><p>The <code class="literal">detectedX</code> and <code class="literal">savedX</code> variables will store the current and last saved finger or mouse in a horizontal position.</p><p>The <code class="literal">touchListener</code> content is way simpler than before because you don't have to manage <a id="id265" class="indexterm"/>images:</p><div class="informalexample"><pre class="programlisting">var touchListener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  swallowTouches: true,
  onTouchBegan: function (touch, event) {
    touching = true;
    detectedX = touch.getLocation().x;
    savedX = detectedX
    return true;
  },
  onTouchMoved: function (touch, event) {
    detectedX = touch.getLocation().x;
  },
  onTouchEnded:function (touch, event) {
    touching = false;
  }
})</pre></div><p>Apart from <a id="id266" class="indexterm"/>setting the <code class="literal">touching</code> Boolean variable to <code class="literal">true</code> or <code class="literal">false</code>, as seen before, you play with <code class="literal">detectedX</code> and <code class="literal">savedX</code> to store the initial and current touch horizontal coordinate.</p><p>The <code class="literal">update</code> function of the <code class="literal">game</code> class takes care of the rest:</p><div class="informalexample"><pre class="programlisting">update:function(dt){
  if(touching){
    var deltaX = savedX - detectedX
    if(deltaX&gt;0){
      xSpeed = -2;
    }
    if(deltaX&lt;0){
      xSpeed = 2;
    }
    savedX = detectedX;
    if(xSpeed&gt;0){
      cart.setFlippedX(true);
    }
    if(xSpeed&lt;0){
      cart.setFlippedX(false);
    }
    cart.setPosition(cart.getPosition().x+xSpeed,cart.getPosition().y);
  }
}</pre></div><p>When the player is touching the screen, the difference between current and last saved horizontal touch coordinate is made to see whether the cart has to move to the left or to the right. Then, the last saved horizontal touch coordinate is updated to the current horizontal touch <a id="id267" class="indexterm"/>coordinate, which is ready to change again if an <code class="literal">onTouchMoved</code> event is triggered.</p><p>Test the game <a id="id268" class="indexterm"/>and move your finger back and forth, you will see the cart change direction as soon as your finger changes direction.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Summary</h1></div></div></div><p>Congratulations! This was a hard and long chapter because it explained three different ways to control your games. Now, it's up to you to use the way you think it fits better for each of your games, so why don't you write down a list of your favourite mobile games and think about what kind of way would you use to control the player?</p><p>Now, let's move on to the next chapter where you will meet realistic physics.</p></div></body></html>