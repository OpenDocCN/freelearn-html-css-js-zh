- en: Chapter 5. Adding Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding some visual controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the NavigationHistory control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with geolocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing controls outside the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing features on multiple vector layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring distances and areas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting feature information from a data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting information from a WMS server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explores from the basics, the most important and common controls
    that OpenLayers offers us as developers. Controls allow us to navigate through
    the map, play with layers, zoom in or out, perform actions such as editing features,
    measuring distances, and the like. In essence, controls allow us to interact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OpenLayers.Control` class is the base class for all the controls and contains
    the common properties and methods that a control can have. We can summarize this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A control is attached to a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A control can trigger events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A control can be activated or deactivated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A control can have a visual representation (such as a button) or have no visual
    representation (such as the drag action)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controls are closely related to the **handlers**. While controls are designed
    to contain the logic of the action, they delegate to the handlers *the low-level
    tasks*, such as to know about the mouse or keyboard events. For example, the `OpenLayers.Control.DragPan`
    control is responsible for dragging the map by reacting to the mouse events. While
    the task, to listen to the mouse events, is delegated to an internal instance
    of the `OpenLayers.Handler.DragPan` class, the task to move the map is made by
    the control itself.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way as with the controls, the class `OpenLayers.Handler` is the
    base class for all the existing handlers used by the controls.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some recipes that will help us to understand the controls better.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenLayers offers a great number of controls, commonly used on mapping applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe shows how to use the most common controls that have a visual representation.
    The list includes the OverviewMap control, the Scale and ScaleLine controls, the
    Graticule control, the LayerSwitcher control, the PanZoomBar control, the MousePosition
    control, and the Permalink control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and removing controls](img/7843_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First add the code for the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using the **Dojo Toolkit** ([http://dojotoolkit.org/](http://dojotoolkit.org/))
    to create the richest user interface, thanks to the beautiful components it offers.
    The goal of the recipe is not to teach Dojo, but to teach OpenLayers, so we are
    free to change the code related to HTML, to use checkbox elements for input, instead
    of the Dojo toggle buttons, and work with the `onclick` event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The importance of the recipe is that the reader learns about creating different
    controls, attaching them to the map, and activating or deactivating them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add the `div` element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the map instance and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the set of controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the code to add or remove the controls depending on the state
    of its corresponding buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each function receives a `checked` parameter that indicates if the button is
    pressed or not. Depending on its value, we simply add or remove the control from
    the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we have done is to create the map instance, forcing it to have
    no controls attached to it. This is done by setting the `controls` property to
    an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we create an `OpenLayers.Map` instance without specifying the `controls`
    property, OpenLayers automatically adds the next set of default controls to it:
    Navigation, PanZoom, ArgParser, and Attribution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have created the controls and added all of them to the map using the
    `addControls` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Before continuing, let's take a look at the properties used in some of the controls'
    instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the layer switcher, we have set the property `ascending` to `false`. This
    means the layers will be sorted in descending order, that is they will be added
    to the map in the reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the OverviewMap control, the `maximized` property allows us to expand the
    control created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for the Graticule control, the `displayInLayerSwitcher` property allows
    to switch it on or off in the LayerSwitcher control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the Dojo Toolkit, the buttons we have created have the behavior of
    a toggle button. Each button has a function associated with it that is executed
    every time the button state changes from checked to unchecked. In the case of
    the overview map button, the associated function is `overviewMapChanged` that
    is specified in the `onChange` event within the `data-dojo-props` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The function that acts as the listener for the `onChange` event receives a boolean
    parameter, indicating if the button is checked or unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the listener functions are similar. Depending on the value of the checked
    parameter, it removes (and destroys) the control from the map or creates a new
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the same way as layers, removing a control from the map instance with the
    `removeControl()` method does not free the possible resources used by the control.
    We need to explicitly do it with the `destroy()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Placing controls outside the map* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Understanding how themes work using img folder* recipe (theming the PanZoomBar
    control) in [Chapter 6](ch06.html "Chapter 6. Theming"), *Theming*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a navigation history control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the most commonly used control in our mapping applications will be
    the Navigation control. `OpenLayers.Control.Navigation` control integrates (makes
    use of) some other controls, such as `OpenLayers.Control.DragPan, OpenLayers.Control.ZoomBox`,
    or a wheel handler, which allows us to pan and zoom the map.
  prefs: []
  type: TYPE_NORMAL
- en: While navigating, moving, or zooming, it can be interesting to store a history
    of the navigation actions made by the user, so he/she can go back or forward to
    previous places. Fortunately, we don't need to reinvent the wheel. OpenLayers
    offers us the `OpenLayers.Control.NavigationHistory` control.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how easy it is to add it to our applications and benefit from
    its features.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a navigation history control](img/7843_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the screenshot, we are going to add a button above the map
    that will enable or disable the Navigation component.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file with the required OpenLayers dependencies. Add the code
    for the toggle button that will enable/disable the navigation control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a `div` element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create the map instance and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Navigation and NavigationHistory controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the function responsible to enable/disable the navigation control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First let''s talk about the navigation control. Using it is not a mystery.
    Simply create a control instance and add it to the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The button created at the beginning makes use of the Dojo Toolkit, which allows
    us to easily convert it to a toggle button. In addition, we have added a listener
    function to check when the button''s state changes between checked and unchecked.
    The `navigationChanged` function activates or deactivates the control depending
    on the `checked` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Each control has an `activate()` and `deactivate()` method. They are defined
    in the base class, `OpenLayers.Control`, and all concrete controls inherit or
    override these methods.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `activate` and `deactivate` is preferred over removing and adding
    the control from/to the map. This way, there is no need to either create or attach
    instances of the control. The control is simply in standby until we activate it
    again.
  prefs: []
  type: TYPE_NORMAL
- en: That is all related to the navigation control, let's take a look at how to add
    the navigation history control, because this is just a two-step process.
  prefs: []
  type: TYPE_NORMAL
- en: The `OpenLayers.Control.NavigationHistory` control is a bit more special. It
    contains stacks to store the previous and next visited places and, among others,
    also contains references to two buttons (instances of the `OpenLayers.Control.Button`
    control class), which allows us to go back and forward in the navigation history.
    The references to these buttons can be found in the `previous` and `next` properties.
  prefs: []
  type: TYPE_NORMAL
- en: By default, after adding a NavigationHistory control to the map, no button appears.
    It is our responsibility to show the previous and next buttons on the map. For
    this, and other similar purposes, OpenLayers offers us the `OpenLayers.Control.Panel`
    control class. It is a special kind of control that can contain or group together
    other controls. So, with all this in mind, we can now explain the way the Navigation
    History control is added to the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to create the `OpenLayers.Control.NavigationHistory` instance
    and add it to the map. Second, we need to add a panel to show the two buttons
    and add the two buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the panel itself must be added to the map as a new control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added the navigation, the navigation history, and the
    panel with the buttons as map controls, simply because all three are controls.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Theming"), *Theming*, we will see how we
    can change the icons used by this control.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Adding and removing controls* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Placing controls outside the map* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Understanding how themes work using the theme folder* recipe in [Chapter
    6](ch06.html "Chapter 6. Theming"), *Theming*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with geolocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the arrival of **HTML5**, one of the many new APIs and concepts introduced
    in the specification is the possibility to identify the location of the client
    that is loading the web page, through the **Geolocation API** ([http://dev.w3.org/geo/api/spec-source.html](http://dev.w3.org/geo/api/spec-source.html)).
    Of course, in the world of web mapping applications, this opens new and great
    possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to show how easily we can identify the current
    location of the user and center the map''s viewport to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with geolocation](img/7843_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every time the user clicks on the **Geolocation** button, the map's viewport
    will be moved to the current user's location and a marker will be placed on it.
    Also, when the mouse goes over the marker, a popup with the current location will
    be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of the recipe, Geolocation is a feature that
    the browser must implement, so we need an HTML5 compliant browser to make this
    control work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First create the HTML file with OpenLayers dependencies, then add the HTML
    code for the button and map element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, initialize the map instance and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the `OpenLayers.Control.Geolocate` control to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and add to the map, the marker layer, where the marker will be placed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set an initial place for the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the listener function associated to the **Geolocation** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, implement the function that is executed each time the location of
    the client is detected. The purpose of this function is to add a marker to the
    map at the current client''s location, and show a popup with the coordinates when
    the mouse goes over the marker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by removing any previous markers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the icon to be used by the marker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, register a listener for the mouseover event that will show the popup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to create the `OpenLayers.Control.Geolocate` control instance
    and add it to the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The control can trigger three events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`locationupdated:` This event is fired when the browser returns a new position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locationfailed:` This event is fired if the geolocation fails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locationuncapable:` This event is fired if you activate the control in a browser
    that does not support geolocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we attached an event listener function for the events `locationupdated`
    and `locationfailed`.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Geolocate control, we need to invoke its `activate()` method. Then,
    OpenLayers will request the browser to get the current user's location and the
    browser will ask if we want to share our location. If we accept, then a `locationupdated`
    event will be triggered with the current location as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe, the `geolocationClick` function is called when the button is
    clicked and forces the activation of the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when the `locationupdated` event is triggered, the `locateMarker` function
    is executed, passing an `event` parameter with all the related event information,
    including the client coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The coordinates stored at `event.point` are transformed by the **Geolocate**
    control, to be in the same coordinate system as the map.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this function is to add a marker to the map at the current client's
    location and show a popup with the coordinates when the mouse goes over the marker.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `OpenLayers.Control.Geolocate` control has a couple of interesting properties.
  prefs: []
  type: TYPE_NORMAL
- en: First the `bind` property, by default set to `true`, allows us to specify if
    the map's center must be updated to the location detected by the control.
  prefs: []
  type: TYPE_NORMAL
- en: The `watch` property, by default set to `false`, allows updating the position
    regularly.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can pass to the control a `geolocationOptions` object, defined
    in the specification (see [http://dev.w3.org/geo/api/spec-source.html#position_options_interface)](http://dev.w3.org/geo/api/spec-source.html#position_options_interface))
    for better configuration of the control.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Adding and removing controls* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Modifying features* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing controls outside the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, all the controls are placed on the map. This way, controls such
    as the PanPanel, EditingToolbar, or MousePosition are rendered on top of the map
    and over any layer. This is the default behavior, but OpenLayers is flexible enough
    to allow us to put controls outside the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Placing controls outside the map](img/7843_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe we are going to create a map where the navigation toolbar and
    the mouse position controls are placed outside and above the map.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file and add the OpenLayers dependencies. Add the following
    CSS code required to redefine some aspects of the controls we are going to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the HTML code to place the two controls above the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the map instance and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the mouse position and navigation toolbar controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous code seems pretty simple. We have added two controls to our map:
    an `OpenLayers.Control.MousePosition` control, which shows the current coordinates
    of the mouse on the map, and `OpenLayers.Control.NavToolbar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OpenLayers.Control.NavToolbar` control is nothing more than a panel control
    that contains other controls: an `OpenLayers.Control.Navigation` control, the
    hand icon (to move the map), and an `OpenLayers.Control.ZoomBox` control, the
    magnifying glass icon (to zoom on a given box).'
  prefs: []
  type: TYPE_NORMAL
- en: So, where is the secret in the recipe for placing the controls outside the map?
    The answer is in the construction of each control.
  prefs: []
  type: TYPE_NORMAL
- en: The base class `OpenLayers.Control` has a `div` property that points to the
    `div` element that will be used to hold the control. By default, no `div` element
    is specified in the constructor, so the control creates a new one to be used.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify a `div` element in the control instantiation, then it is used
    as the place where the control will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the MousePosition control, we have used the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This means we are placing the control on the previously created `div` element,
    identified by the `mouseposition` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the navigation toolbar, it differs a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this case we have set the CSS class `olControlNavToolbar`, defined by OpenLayers.
    Why?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we do not specify the `div` property, the control creates one and applies
    some default CSS classes that set the control icon, borders, background color,
    and so on. Remove the `div` property from the navigation toolbar and see the results.
    A `div` element will be created and placed on the map with some classes, such
    as `olControlNavToolbar`, attached to it and will contain some other elements
    representing the buttons for the pan and zoom actions.
  prefs: []
  type: TYPE_NORMAL
- en: When we specify the `div` property to be used, no style is automatically created
    and, because of this, controls can disappear or not be rendered nicely if we do
    not specify some CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is clear, we can say we have not used the CSS class with the mouse
    position control because it only contains some text. Well, we have only set the
    font size.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation control is a more complex control, it contains two other controls
    and we need to tune up its style a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we will see in [Chapter 6](ch06.html "Chapter 6. Theming"), *Theming*, most
    of the OpenLayers flexibility when working with controls is due to the use of
    the CSS classes. All the controls have, by default, a CSS class associated that
    defines its position, icons, color, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the CSS code that we have set at the beginning of the recipe, we are redefining
    the place of the navigation toolbar within the `div` and indicating that we want
    the contained elements, buttons, and flows in the `left` direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Theming"), *Theming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing features on multiple vector layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with vector information, most probably, one of the most common
    things we can do in a GIS application is: add new features.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenLayers has plenty of controls, so there is no need to reinvent the wheel.
    We have a set of tools and the only thing we need to do is learn how to use each
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this concrete purpose, add new features. OpenLayers has the `OpenLayers.Control.EditingToolbar`
    control that shows a toolbar with some buttons to add polygons, polylines, and
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing features on multiple vector layers](img/7843_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we can have many vector layers in the map, the control needs us to specify
    the layer it must work on.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to showing how easy is to use the control, the goal of this recipe
    is to show how we can use the same control to add features to more than one layer.
  prefs: []
  type: TYPE_NORMAL
- en: This way, this little application will consist of a map with two vector layers.
    Thanks to the radio buttons, we will be able to chose the layer on which we want
    to create the new features.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, add the HTML code to create a couple of radio buttons that will allow
    us to select the vector layer on which we want to draw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a map instance and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the two vector layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the editing toolbar control, initially associated to the first vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, implement the code to handle the radio button changes. It will change
    the layer associated to the editing toolbar control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of the `OpenLayers.Control.EditingToolbar` control has not much mystery.
    In the constructor, we need to indicate the vector layer we want to add the new
    features to.
  prefs: []
  type: TYPE_NORMAL
- en: The control will show some buttons on top of the map, allowing us to create
    new polygons, polylines, or points. Those new features will be added to the specified
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: So, the secret to add features to other vector layers is about how to change
    the layer referenced by the control.
  prefs: []
  type: TYPE_NORMAL
- en: The `OpenLayers.Control.EditingToolbar` control is nothing more than a panel
    that contains four controls. We encourage the reader to take a look at its `initialize`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The editor toolbar contains a navigation control, which is represented by the
    hand icon, and three instances of the `OpenLayers.Control.DrawFeature` control.
  prefs: []
  type: TYPE_NORMAL
- en: The DrawFeature control is the essence of the editor toolbar control. Given
    a vector layer and a handler, the control allows drawing features on the layer.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, controls are closely related
    to handlers. Here, we can see how handlers are responsible for detecting the mouse
    events and translate it to the point, path, or polygon creation events. On the
    other side, the draw feature control listens for these events and creates the
    appropriate map features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize the key points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The editor toolbar, as a panel, contains a list of controls: one Navigation
    control and three DrawFeature controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the EditingToolbar control needs a reference to the vector layer
    to be edited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vector layer reference is passed to the three DrawFeature controls, so they
    can add new features on the layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can see that by changing the layer reference in the draw feature controls,
    we change the layer where features are added. And this is exactly what the functions
    that listen for radio buttons'' events do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the code, from the editing toolbar we get all the draw feature
    controls with the call to the `getControlsByClass` method, and then for each one
    we change the reference to the layer by changing the `layer` property.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we look at the code of the `initialize()` method of the `OpenLayers.Control.EditingToolbar`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can see it is passing a `displayClass` property to the `OpenLayers.Control.DrawFeature`
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: This property is also common to all controls inherited from the `OpenLayers.Control`
    class, and specifies the CSS class that must be applied to the `div` element that
    will be used to draw the control.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Placing controls outside the map* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Modifying features* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on the web mapping application, most probably, the capability to
    allow the users to add new features would be a desired requirement, but what about
    modifying features such as move vertex, rotate features, scale, and so on?
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, OpenLayers simplifies our lives as developers, giving us the powerful
    `OpenLayers.Control.ModifyFeature` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying features](img/7843_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This time we are going to create a little application that will provide us
    with two important controls: first, to add new features and second, to modify
    them. For this purpose, we will use the `OpenLayers.Control.EditingToolbar` and
    `OpenLayers.Control.ModifyFeature` controls.'
  prefs: []
  type: TYPE_NORMAL
- en: In concrete, we will see how we can reshape, resize, rotate, and drag features.
    In addition, we will see how to filter what kind of features can be affected by
    the modifications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with creating the controls required for managing the control to
    modify a feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the JavaScript coding by initializing the map and adding a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a vector layer to add and modify its features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach an editing toolbar control to the previous layer and add it to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, attach a ModifyFeature control to the vector layer and add it to
    the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the listener functions that modify the behavior of the modify feature control.
    First add the function that activates or deactivates the control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the function that changes the way the modifications are made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally add the function to filter the type of geometries the control affects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The editing toolbar allows us to draw points, paths, and polygons. Once some
    features are added to the layer, we can click on the **Modify** toggle button
    to activate or deactivate the modify feature control. This action is handled by
    the `modifyChanged` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: By default, the modify feature control allows to reshape any kind of feature,
    no matter whether it is a point, path, or polygon, that is we can move or add
    a new vertex to the feature.
  prefs: []
  type: TYPE_NORMAL
- en: With the checkboxes, we can modify the behavior of the control, for example,
    allowing resizing or dragging of the selected feature.
  prefs: []
  type: TYPE_NORMAL
- en: The function `changeMode` listens for changes on any of the checkboxes and is
    responsible to modify the action that the control handles.
  prefs: []
  type: TYPE_NORMAL
- en: The action in question is specified through the `mode` property of the control.
    We can set it at the time of instantiation, or later by modifying the property,
    as we are doing in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the control allows to handle many actions at a time. We can specify
    all of them using the logical OR operator. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we force the deactivation and later the activation of the control
    so that the new `mode` value takes effect.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can control one more thing of the control's behavior and that is,
    the kind of features we can modify. Using the select box, we can choose the kind
    of geometries that can be modified by the control. The function `changeFilter`
    is listening for changes on the select box and changes the configuration of the
    modify feature control.
  prefs: []
  type: TYPE_NORMAL
- en: This geometry filter is done by using the `geometryType` property of the control.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this property can only be set at instantiation time, changes
    made later have no effect. So, we need to remove the control from the map and
    create a new one with the desired geometries to be filtered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Removing a control from the map does not free the possible resources used by
    the control. We need to destroy it to free the resources.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After reading this recipe, we know how to modify the features. But, what if
    we want to listen for events while features are being modified? How to know when
    a modification is going to be made?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is simple, we need to listen for events in the vector layer we are
    modifying.
  prefs: []
  type: TYPE_NORMAL
- en: Registering for events, such as `beforefeaturemodified, featureselected`, or
    `vertexremoved` allows us to know what exactly is happening and react according
    to our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Editing features on multiple vector layers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding and removing controls* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Listening for vector layer features' event* recipe in [Chapter 4](ch04.html
    "Chapter 4. Working with Events"), *Controls*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring distances and areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The capability to measure distances or areas is an important thing on many GIS
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to see in action what the Measure control in OpenLayers
    offers to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will show a simple map with some buttons on top, as shown in
    the following screenshot. The **Measure** toggle button activates or deactivates
    the control, while the radio buttons bring us the possibility to select what to
    measure: a path or an area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Measuring distances and areas](img/7843_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition, we can set two control options. The **Geodesic** control indicates
    if the distance of the area computation must be in geodesic metrics instead of
    planar. The **Immediate** option is useful to update the measure every time we
    move the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we are going to write not the whole source code but only those pieces
    of code that are important for the recipe. So, we are avoiding putting here the
    HTML code required to build the measure button, checkboxes, options radio buttons,
    and the `div` element that holds the map instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the JavaScript code. First, instantiate the map, add
    a base layer, and center the map display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, add the Measure control. Note that we are registering two listener functions
    for the events `measure` and `measurepartial:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, place the code for the **Measure** toggle button that activates or deactivates
    the control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the listener functions for the `measure` and `measurepartial` control
    events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, place the code for the functions that change the **Geodesic** and
    **Immediate** options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start analyzing how we initialized the measure control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The only parameter we need to pass to the control is a handler to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like many other controls, the `OpenLayers.Control.Measure` class makes use
    of handlers to interact with the map. In this case, the measure control can make
    use of any handler that allows to draw geometries. To summarize, the flow is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The control is activated and it delegates to a handler the task of drawing some
    geometry in the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the handler has drawn the desired geometry, (such as a path or a polygon)
    the feature is returned to the control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The control computes the distance or area of the geometry and triggers an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, we have a limitation to use handlers that return geometries that implement
    the `getArea()` or `getLength()` methods. For example, if you try to use the `OpenLayers.Handler.Box`
    handler with the measure control, once you activate the control and draw a box,
    you will get an error in the browser console. This is because the box handler
    returns an `OpenLayers.Bounds` instance that neither has a `getLength` nor `getArea`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code we have initialized the measure control setting as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `persist` property to `true`. This property indicates that the geometry
    created by the handler must remain on the map until a new measure starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two event listeners, for the events `measure` and `measurepartial`. The `measure`
    event is triggered once the measure action has been finished. The `measurepartial`
    is triggered on any measure update (only if the `immediate` property is true).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **Measure** toggle button is pressed, the `measureClick` function is
    executed. This function checks what kind of handler must be used for the measurement
    and sets it on the control.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by the `updateHandler` method on the Measure control. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the `measureClick` function adds the control to the map and activates
    when the button is toggled on, or deactivates and removes the control from the
    map when the button is toggled off.
  prefs: []
  type: TYPE_NORMAL
- en: For the control options buttons, we have set two listening functions associated
    to the checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the **Immediate** checkbox changes, the `changeImmediate` function is
    executed. This, using the `setImmediate` method, changes the `immediate` property
    of the control, which allows triggering events every time the measure updates
    with a mouse movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Geodesic** checkbox sets the value of the `geodesic` property. This time
    we can modify the property directly without the need of a setter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: With the `geodesic` property set to `true`, the control will use a geodesic
    metric instead of a planar metric to compute the measures.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important part of the measurement is done with the geometric instances.
  prefs: []
  type: TYPE_NORMAL
- en: All the geometry classes, such as `OpenLayers.Geometry.Polygon` or `OpenLayers.Geometry.LineString`,
    contain methods to compute their area or length.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the measure control source code, we can see how once its associated
    handler returns a geometry, it simply calls the geometry methods to get the area
    or length and triggers an event.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Working with geolocation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Editing features on multiple vector layers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Modifying features* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting feature information from data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We work on web mapping applications almost every day. We know how to create
    a map and add raster and vector layers. More than that, we know how to get vector
    data from different data sources: GeoJSON file, KML file, or from a WFS server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, and related to vector layers, one of the possible questions
    we could have is: how can we retrieve the feature''s information? Fortunately,
    OpenLayers offers us some controls that can answer this question.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to see in action the `OpenLayers.Control.GetFeature`
    control class that has the ability to query the feature's data source.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a map with a base layer and two vector layers. One from
    a WFS server, with the USA, and the other from a GML file with Europe's countries.
  prefs: []
  type: TYPE_NORMAL
- en: On top of the map, a button allows us to activate/deactivate the `GetFeature`
    control and two radio buttons allow us to select between the USA or Europe layers
    to be queried.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start creating the HTML file with the OpenLayers dependencies. Then
    add the HTML code for the map and buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the JavaScript section, set the proxy script to be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the map and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the two vector layers, the first from a WFS server and the second from
    a GML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a third layer that will serve to show the selected features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the `GetFeature` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the code to activate/deactivate the control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, add the code that will change which layer to be queried by the
    control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we are working with the WFS layer, and also the later queries made by
    the `GetFeature` control are using AJAX, we need to configure a proxy script to
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'After initializing the map, we have added a base WMS layer simply using the
    `OpenLayers.Layer.WMS` class and specifying a URL to the server and the WMS layer
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The two vector layers have not much secret. Thanks to the `OpenLayers.Protocol`
    subclasses, we can easily create vector layers from different data sources by
    simply specifying the right protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we have created a third vector layer called `selected`. Why? Let''s
    explain first how the `OpenLayers.Control.GetFeature` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: By default, `OpenLayers.Control.GetFeature` starts working when a click event
    is made. Then, using the specified `protocol` instance, it queries the data source
    for the features under the click location.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, by using the `box` property, we can allow selecting features using
    a selection binding box. A third selection is done with the hover action but we
    have disabled it setting the `hover` property to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: As the name implies, the properties `multipleKey` and `toggleKey` are used to
    define the control keys that are used to select multiple features and toggle their
    selection state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `eventListeners` property allows us to register at the time the
    constructor is called and the events we want to listen for. In this case we will
    be notified when a feature will be selected or unselected.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the third vector layer, the `selected` layer.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the other controls, such as the `OpenLayers.Control.SelectFeature,
    OpenLayers.Control.GetFeature` didn't modify the visual style of the feature.
    That is, if you use the `SelectFeature` control, you will see that each time you
    select a feature, its color and border will change to indicate it is selected.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, with `OpenLayers.Control.GetFeature`, nothing happens when
    a feature is selected. The control makes a query to the data source and an event
    is triggered. You are responsible to perform something with that event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we are retrieving the feature from the event and adding it
    to the selected layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the instantiation code of the selected layer, it looks something
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We have supplied a different style for the layer. In this case, we are getting
    the`"temporary"` style defined at `OpenLayers.Feature.Vector` and applying it
    to the layer so the features have a different look.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More on styling is discussed in [Chapter 7](ch07.html "Chapter 7. Styling Features"),
    *Styling Features.*
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that the `OpenLayers.Control.SelectFeature` control
    is similar to the `OpenLayers.control.GetFeature` control, but they have important
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: First, the `OpenLayers.control.GetFeature` control makes a query to the data
    source that returns the features involved by the selection. The `openLayers.Control.SelectFeature`
    control makes no request, it works on the client-side and retrieves the selected
    feature from the specified vector layer.
  prefs: []
  type: TYPE_NORMAL
- en: Second, every time a feature is selected with the `OpenLayers.Control.SelectFeature`
    control, a `featureselected` event is triggered by the vector layer. So we can
    register listeners in the vector layer to be notified for the selection events.
  prefs: []
  type: TYPE_NORMAL
- en: With the `OpenLayers.control.GetFeature` control, no event is triggered by the
    vector layer. The events are triggered by the control and because of this we need
    to register listeners in the control.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with the `OpenLayers.control.GetFeature` control, we can use any protocol
    that supports spatial filters. Because of this, we can use the `GetFeature` control
    against a WFS server or a GML file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Selecting and transforming features* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Getting information from the WMS server* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding GML layer* recipe in [Chapter 3](ch03.html "Chapter 3. Working with
    Vector Layers"), *Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Filtering features in WFS requests* in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Listening for vector layer features' event* in [Chapter 4](ch04.html "Chapter 4. Working
    with Events"), *Controls*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting information from the WMS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, the **Web Map Service (WMS)** has an important role in the GIS world,
    mainly because rendering tons of vector data at the client-side, no matter if
    its browser on a desktop consumes many resources.
  prefs: []
  type: TYPE_NORMAL
- en: If we think, in the OpenStreetMap project, where we have tons of vector data
    about streets, places, and so on, we can see that the main way to render data
    is in a raster way.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, WMS servers allow us to get vector or raster data, from a
    shapefile, from a `.geotiff` file, from a spatial database, and so on, and render
    all together as a single image. Not only that, if properly configured, a WMS server
    allows us to query information of a feature at a given point.
  prefs: []
  type: TYPE_NORMAL
- en: With OpenLayers, this can be easily done using the `OpenLayers.Control.WMSGetFeatureInfo`
    control.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, we can see what our current recipe looks like.
    Given some vector information about USA states, the server returns a raster image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting information from the WMS server](img/7843_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the control is activated, any click event on the map will trigger a request
    to the WMS server to get the feature information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file with the OpenLayers library dependencies and add the code
    for the button and the map''s `div` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the proxy script, and initialize the map instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add two WMS layers. The first will act as the base layer while the second
    will be an overlay layer with the USA states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the layer switcher control and center the map''s viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add the code for the `WMSGetFeatureInfo` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the code to activate/deactivate the control when the button is
    clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A WMS server implements different request types. The most important is the `GetMap`
    request, which allows us to get an image given some parameters, such as a bounding
    box, the name of the layers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All this explanation is more close to understanding the WMS standard than working
    with OpenLayers. So, invest your time and learn what the WMS standard offers and
    how it works. You can find a very brief description at wikipedia: [http://en.wikipedia.org/wiki/Web_Map_Service](http://en.wikipedia.org/wiki/Web_Map_Service),
    and the whole specification at OGC: [http://www.opengeospatial.org/standards/wms](http://www.opengeospatial.org/standards/wms).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the WMS server can implement the `GetFeatureInfo` request. This
    type of request allows us to, given a point and some layer names configured at
    the WMS server, retrieve information from a feature, that is, we can get a feature
    attribute from a layer which is rendered as a raster image.
  prefs: []
  type: TYPE_NORMAL
- en: Let's describe the code of this recipe, which is the goal of this book and not
    to explain how a WMS server works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because, the control will make an AJAX request, we need to set a proxy script
    to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The WMS layer comes from a public server from the awesome **OpenGeo** project
    ([http://opengeo.org](http://opengeo.org)). The first layer acts as a base layer.
    The second one must be an overlay layer, because we have set the `isBaseLayer`
    property to `false`. In addition, to avoid the layer hiding the base layer, we
    have set the `transparent` property, which is used in the WMS request, to `true:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the `WMSGetFeatureInfo` control is easy, we need to set the WMS server
    URL, some desired properties and register some event listeners to make something
    with the returned information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we want to show a popup with the data, we have registered a function
    on the `getfeatureinfo` event, which is triggered when the control obtains the
    server data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To query information of a layer in a WMS server, it must be configured as a
    queryable layer. If we request for a layer which is not queryable, then a `nogetfeatureinfo`
    event will be triggered by the control.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the control requests data for all WMS layers in the map. With the
    `queryVisible` property, we can limit the query to those layers which are currently
    visible and forget those hidden layers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `WMSGetFeatureInfo` control has other interesting properties.
  prefs: []
  type: TYPE_NORMAL
- en: With the `hover` property set to `true` we can force the control to query the
    server, not only when the mouse clicks on the map, but also on the mouse hover
    event.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `layers` property, which accepts an array of `OpenLayers.Layer.WMS`
    layers, we can control which layers must be queried on the server. If not specified,
    the layers are obtained from the map.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if a layer has been configured to work with more than one server,
    only the first one is used for the queries.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is important to note that a WMS server can return the data in different
    formats, for example, a plain text, an HTML response, or also in GML format.
  prefs: []
  type: TYPE_NORMAL
- en: With the `infoFormat` property, we can indicate to the server the kind of response
    we desire. By default it is HTML.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Getting feature information from data source* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Selecting and transforming features* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding WMS layer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
