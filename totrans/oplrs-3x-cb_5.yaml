- en: Chapter 5. Adding Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 添加控件
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Adding some visual controls
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些视觉控件
- en: Adding the NavigationHistory control
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加NavigationHistory控件
- en: Working with geolocation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理地理位置
- en: Placing controls outside the map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将控件放置在地图外部
- en: Editing features on multiple vector layers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个矢量图层上编辑要素
- en: Modifying features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改要素
- en: Measuring distances and areas
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量距离和面积
- en: Getting feature information from a data source
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据源获取要素信息
- en: Getting information from a WMS server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从WMS服务器获取信息
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter explores from the basics, the most important and common controls
    that OpenLayers offers us as developers. Controls allow us to navigate through
    the map, play with layers, zoom in or out, perform actions such as editing features,
    measuring distances, and the like. In essence, controls allow us to interact.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从基础知识出发，探讨了OpenLayers为我们开发者提供的最重要和最常用的控件。控件使我们能够导航地图、操作图层、放大或缩小，执行编辑要素、测量距离等操作。本质上，控件允许我们进行交互。
- en: 'The `OpenLayers.Control` class is the base class for all the controls and contains
    the common properties and methods that a control can have. We can summarize this
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Control`类是所有控件的基类，包含控件可能具有的常见属性和方法。我们可以总结如下：'
- en: A control is attached to a map
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件附加到地图上
- en: A control can trigger events
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件可以触发事件
- en: A control can be activated or deactivated
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件可以被激活或禁用
- en: A control can have a visual representation (such as a button) or have no visual
    representation (such as the drag action)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件可以有视觉表示（如按钮）或没有视觉表示（如拖动操作）
- en: Controls are closely related to the **handlers**. While controls are designed
    to contain the logic of the action, they delegate to the handlers *the low-level
    tasks*, such as to know about the mouse or keyboard events. For example, the `OpenLayers.Control.DragPan`
    control is responsible for dragging the map by reacting to the mouse events. While
    the task, to listen to the mouse events, is delegated to an internal instance
    of the `OpenLayers.Handler.DragPan` class, the task to move the map is made by
    the control itself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 控件与**处理器**密切相关。虽然控件旨在包含动作的逻辑，但它们将**低级任务**委托给处理器，例如了解鼠标或键盘事件。例如，`OpenLayers.Control.DragPan`控件负责通过响应鼠标事件来拖动地图。虽然监听鼠标事件的任务委托给`OpenLayers.Handler.DragPan`类的内部实例，但移动地图的任务由控件本身完成。
- en: In a similar way as with the controls, the class `OpenLayers.Handler` is the
    base class for all the existing handlers used by the controls.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与控件类似，`OpenLayers.Handler`类是所有控件使用的现有处理器的基础类。
- en: Let's see some recipes that will help us to understand the controls better.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些菜谱，这将帮助我们更好地理解控件。
- en: Adding and removing controls
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和删除控件
- en: OpenLayers offers a great number of controls, commonly used on mapping applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers提供了大量的控件，这些控件在地图应用中常用。
- en: 'This recipe shows how to use the most common controls that have a visual representation.
    The list includes the OverviewMap control, the Scale and ScaleLine controls, the
    Graticule control, the LayerSwitcher control, the PanZoomBar control, the MousePosition
    control, and the Permalink control:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱展示了如何使用具有视觉表示的最常用控件。列表包括OverviewMap控件、Scale和ScaleLine控件、Graticule控件、LayerSwitcher控件、PanZoomBar控件、MousePosition控件和Permalink控件：
- en: '![Adding and removing controls](img/7843_05_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![添加和删除控件](img/7843_05_01.jpg)'
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First add the code for the buttons:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加按钮的代码：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the **Dojo Toolkit** ([http://dojotoolkit.org/](http://dojotoolkit.org/))
    to create the richest user interface, thanks to the beautiful components it offers.
    The goal of the recipe is not to teach Dojo, but to teach OpenLayers, so we are
    free to change the code related to HTML, to use checkbox elements for input, instead
    of the Dojo toggle buttons, and work with the `onclick` event.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在使用**Dojo Toolkit**([http://dojotoolkit.org/](http://dojotoolkit.org/))来创建最丰富的用户界面，多亏了它提供的精美组件。本菜谱的目标不是教授Dojo，而是教授OpenLayers，因此我们可以自由地更改与HTML相关的代码，使用复选框元素作为输入，而不是Dojo切换按钮，并处理`onclick`事件。
- en: The importance of the recipe is that the reader learns about creating different
    controls, attaching them to the map, and activating or deactivating them.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本菜谱的重要性在于读者学习了创建不同控件、将它们附加到地图上以及激活或禁用它们。
- en: 'Next, add the `div` element to hold the map:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`div`元素以容纳地图：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the map instance and add a base layer:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建地图实例并添加基本图层：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the set of controls:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加控件集：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, add the code to add or remove the controls depending on the state
    of its corresponding buttons:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，根据相应按钮的状态添加或删除控件的代码：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each function receives a `checked` parameter that indicates if the button is
    pressed or not. Depending on its value, we simply add or remove the control from
    the map:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个函数都接收一个 `checked` 参数，表示按钮是否被按下。根据其值，我们简单地从地图中添加或删除控件：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing we have done is to create the map instance, forcing it to have
    no controls attached to it. This is done by setting the `controls` property to
    an empty array:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是创建地图实例，强制它没有任何控件附加到它。这是通过将 `controls` 属性设置为空数组来完成的：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When we create an `OpenLayers.Map` instance without specifying the `controls`
    property, OpenLayers automatically adds the next set of default controls to it:
    Navigation, PanZoom, ArgParser, and Attribution.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个没有指定 `controls` 属性的 `OpenLayers.Map` 实例时，OpenLayers 会自动向其中添加下一组默认控件：导航、平移缩放、ArgParser
    和版权信息。
- en: 'Next, we have created the controls and added all of them to the map using the
    `addControls` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了控件，并使用 `addControls` 方法将所有控件添加到地图中：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before continuing, let's take a look at the properties used in some of the controls'
    instantiation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看看在控件实例化中使用的属性。
- en: 'On the layer switcher, we have set the property `ascending` to `false`. This
    means the layers will be sorted in descending order, that is they will be added
    to the map in the reverse order:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在图层切换器上，我们已经将属性 `ascending` 设置为 `false`。这意味着图层将按降序排序，即它们将以相反的顺序添加到地图中：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the OverviewMap control, the `maximized` property allows us to expand the
    control created:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OverviewMap 控件上，`maximized` 属性允许我们扩展创建的控件：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, for the Graticule control, the `displayInLayerSwitcher` property allows
    to switch it on or off in the LayerSwitcher control:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 Graticule 控件，`displayInLayerSwitcher` 属性允许在 LayerSwitcher 控件中打开或关闭它：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Thanks to the Dojo Toolkit, the buttons we have created have the behavior of
    a toggle button. Each button has a function associated with it that is executed
    every time the button state changes from checked to unchecked. In the case of
    the overview map button, the associated function is `overviewMapChanged` that
    is specified in the `onChange` event within the `data-dojo-props` attribute:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Dojo Toolkit，我们创建的按钮具有切换按钮的行为。每个按钮都有一个与之关联的函数，该函数在按钮状态从选中变为未选中时执行。在概述地图按钮的情况下，关联的函数是
    `overviewMapChanged`，它在 `data-dojo-props` 属性中的 `onChange` 事件内指定：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function that acts as the listener for the `onChange` event receives a boolean
    parameter, indicating if the button is checked or unchecked.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `onChange` 事件监听器的函数接收一个布尔参数，指示按钮是否被选中或取消选中。
- en: 'All the listener functions are similar. Depending on the value of the checked
    parameter, it removes (and destroys) the control from the map or creates a new
    one:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有监听函数都很相似。根据检查参数的值，它从地图中删除（并销毁）控件或创建一个新的控件：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the same way as layers, removing a control from the map instance with the
    `removeControl()` method does not free the possible resources used by the control.
    We need to explicitly do it with the `destroy()` method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与图层一样，使用 `removeControl()` 方法从地图实例中删除控件不会释放控件可能使用的资源。我们需要使用 `destroy()` 方法显式地这样做。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Placing controls outside the map* recipe
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将控件放置在地图外部* 的配方'
- en: The *Understanding how themes work using img folder* recipe (theming the PanZoomBar
    control) in [Chapter 6](ch06.html "Chapter 6. Theming"), *Theming*
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。主题") 的 *使用 img 文件夹理解主题如何工作* 配方（为主题化 PanZoomBar 控件）中，*主题化*
- en: Adding a navigation history control
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加导航历史记录控件
- en: Probably the most commonly used control in our mapping applications will be
    the Navigation control. `OpenLayers.Control.Navigation` control integrates (makes
    use of) some other controls, such as `OpenLayers.Control.DragPan, OpenLayers.Control.ZoomBox`,
    or a wheel handler, which allows us to pan and zoom the map.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的地图应用程序中，最常用的控件可能是导航控件。`OpenLayers.Control.Navigation` 控件集成了（使用了）一些其他控件，例如
    `OpenLayers.Control.DragPan`、`OpenLayers.Control.ZoomBox` 或滚轮处理程序，这允许我们平移和缩放地图。
- en: While navigating, moving, or zooming, it can be interesting to store a history
    of the navigation actions made by the user, so he/she can go back or forward to
    previous places. Fortunately, we don't need to reinvent the wheel. OpenLayers
    offers us the `OpenLayers.Control.NavigationHistory` control.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航、移动或缩放时，存储用户执行的导航操作的历史可能很有趣，这样他/她就可以回到或前进到先前的地方。幸运的是，我们不需要重新发明轮子。OpenLayers为我们提供了`OpenLayers.Control.NavigationHistory`控件。
- en: This recipe shows how easy it is to add it to our applications and benefit from
    its features.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了将其添加到我们的应用程序中并从中受益是多么容易。
- en: '![Adding a navigation history control](img/7843_05_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![添加导航历史控件](img/7843_05_02.jpg)'
- en: As you can see in the screenshot, we are going to add a button above the map
    that will enable or disable the Navigation component.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，我们将在地图上方添加一个按钮，该按钮将启用或禁用导航组件。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create an HTML file with the required OpenLayers dependencies. Add the code
    for the toggle button that will enable/disable the navigation control:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所需OpenLayers依赖项的HTML文件。添加用于启用/禁用导航控件的切换按钮代码：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, add a `div` element to hold the map:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个`div`元素来包含地图：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, create the map instance and add a base layer:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建地图实例并添加一个基础图层：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the Navigation and NavigationHistory controls:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加导航和导航历史控件：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement the function responsible to enable/disable the navigation control:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现负责启用/禁用导航控件的函数：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First let''s talk about the navigation control. Using it is not a mystery.
    Simply create a control instance and add it to the map:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈导航控件。使用它并不神秘。只需创建一个控件实例并将其添加到地图中：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The button created at the beginning makes use of the Dojo Toolkit, which allows
    us to easily convert it to a toggle button. In addition, we have added a listener
    function to check when the button''s state changes between checked and unchecked.
    The `navigationChanged` function activates or deactivates the control depending
    on the `checked` value:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建的按钮使用了Dojo Toolkit，这使得我们能够轻松地将其转换为切换按钮。此外，我们还添加了一个监听函数来检查按钮的状态是否在选中和不选中之间改变。`navigationChanged`函数根据`checked`值激活或禁用控件：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each control has an `activate()` and `deactivate()` method. They are defined
    in the base class, `OpenLayers.Control`, and all concrete controls inherit or
    override these methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控件都有一个`activate()`和`deactivate()`方法。它们在基类`OpenLayers.Control`中定义，并且所有具体的控件都继承或覆盖了这些方法。
- en: The use of `activate` and `deactivate` is preferred over removing and adding
    the control from/to the map. This way, there is no need to either create or attach
    instances of the control. The control is simply in standby until we activate it
    again.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于从地图中移除和添加控件，使用`activate`和`deactivate`更受欢迎。这样，就不需要创建或附加控件的实例。控件只是处于待机状态，直到我们再次激活它。
- en: That is all related to the navigation control, let's take a look at how to add
    the navigation history control, because this is just a two-step process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都与导航控件相关，让我们看看如何添加导航历史控件，因为这只是一个两步的过程。
- en: The `OpenLayers.Control.NavigationHistory` control is a bit more special. It
    contains stacks to store the previous and next visited places and, among others,
    also contains references to two buttons (instances of the `OpenLayers.Control.Button`
    control class), which allows us to go back and forward in the navigation history.
    The references to these buttons can be found in the `previous` and `next` properties.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Control.NavigationHistory`控件有点特别。它包含用于存储先前和后续访问位置的栈，以及其他内容，还包含对两个按钮（`OpenLayers.Control.Button`控件类的实例）的引用，这允许我们在导航历史中前进和后退。这些按钮的引用可以在`previous`和`next`属性中找到。'
- en: By default, after adding a NavigationHistory control to the map, no button appears.
    It is our responsibility to show the previous and next buttons on the map. For
    this, and other similar purposes, OpenLayers offers us the `OpenLayers.Control.Panel`
    control class. It is a special kind of control that can contain or group together
    other controls. So, with all this in mind, we can now explain the way the Navigation
    History control is added to the map.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在地图中添加NavigationHistory控件后，不会出现任何按钮。显示上一个和下一个按钮的责任在我们。为此，以及其他类似的目的，OpenLayers为我们提供了`OpenLayers.Control.Panel`控件类。这是一种特殊的控件，可以包含或组合其他控件。所以，考虑到所有这些，我们现在可以解释如何将导航历史控件添加到地图中。
- en: 'First we need to create the `OpenLayers.Control.NavigationHistory` instance
    and add it to the map. Second, we need to add a panel to show the two buttons
    and add the two buttons:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建 `OpenLayers.Control.NavigationHistory` 实例并将其添加到地图中。其次，我们需要添加一个面板来显示两个按钮，并添加这两个按钮：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the panel itself must be added to the map as a new control:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须将面板本身作为新的控件添加到地图中：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we have added the navigation, the navigation history, and the
    panel with the buttons as map controls, simply because all three are controls.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经添加了导航、导航历史和带有按钮的面板作为地图控件，仅仅是因为这三者都是控件。
- en: In [Chapter 6](ch06.html "Chapter 6. Theming"), *Theming*, we will see how we
    can change the icons used by this control.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。主题") 的 *主题* 中，我们将看到如何更改此控件使用的图标。
- en: See also
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Adding and removing controls* recipe
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和删除控件* 的配方'
- en: The *Placing controls outside the map* recipe
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将控件放置在地图外部* 的配方'
- en: The *Understanding how themes work using the theme folder* recipe in [Chapter
    6](ch06.html "Chapter 6. Theming"), *Theming*
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。主题") 的 *主题* 中的 *使用主题文件夹理解主题工作方式* 配方
- en: Working with geolocation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理地理位置
- en: With the arrival of **HTML5**, one of the many new APIs and concepts introduced
    in the specification is the possibility to identify the location of the client
    that is loading the web page, through the **Geolocation API** ([http://dev.w3.org/geo/api/spec-source.html](http://dev.w3.org/geo/api/spec-source.html)).
    Of course, in the world of web mapping applications, this opens new and great
    possibilities.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 **HTML5** 的到来，规范中引入了许多新的 API 和概念之一是识别加载网页的客户端位置的可能性，通过 **地理位置 API** ([http://dev.w3.org/geo/api/spec-source.html](http://dev.w3.org/geo/api/spec-source.html))。当然，在网络地图应用的世界中，这开辟了新的巨大可能性。
- en: 'In this recipe, we are going to show how easily we can identify the current
    location of the user and center the map''s viewport to it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示如何轻松地识别用户的当前位置并将地图的视口中心对准它：
- en: '![Working with geolocation](img/7843_05_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![处理地理位置](img/7843_05_03.jpg)'
- en: Every time the user clicks on the **Geolocation** button, the map's viewport
    will be moved to the current user's location and a marker will be placed on it.
    Also, when the mouse goes over the marker, a popup with the current location will
    be shown.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户点击 **地理位置** 按钮，地图的视口将移动到当前用户的当前位置，并在其上放置一个标记。此外，当鼠标悬停在标记上时，将显示一个包含当前位置的弹出窗口。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we mentioned at the beginning of the recipe, Geolocation is a feature that
    the browser must implement, so we need an HTML5 compliant browser to make this
    control work.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在配方开头所述，地理位置是浏览器必须实现的功能，因此我们需要一个符合 HTML5 的浏览器才能使此控件工作。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First create the HTML file with OpenLayers dependencies, then add the HTML
    code for the button and map element:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建包含 OpenLayers 依赖项的 HTML 文件，然后添加按钮和地图元素的 HTML 代码：
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, initialize the map instance and add a base layer:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，初始化地图实例并添加一个基本图层：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, add the `OpenLayers.Control.Geolocate` control to the map:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `OpenLayers.Control.Geolocate` 控制器添加到地图中：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create and add to the map, the marker layer, where the marker will be placed:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并添加到地图中，放置标记的标记层：
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set an initial place for the view:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为视图设置初始位置：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the listener function associated to the **Geolocation** button:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现与 **地理位置** 按钮关联的监听器函数：
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, implement the function that is executed each time the location of
    the client is detected. The purpose of this function is to add a marker to the
    map at the current client''s location, and show a popup with the coordinates when
    the mouse goes over the marker:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现每次检测到客户端位置时执行的功能。此函数的目的是在当前客户端的位置上向地图添加一个标记，并在鼠标悬停在标记上时显示一个带有坐标的弹出窗口：
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Start by removing any previous markers:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先删除任何之前的标记：
- en: '[PRE29]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, create the icon to be used by the marker:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建用于标记的图标：
- en: '[PRE30]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, register a listener for the mouseover event that will show the popup:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，注册一个鼠标悬停事件的监听器，该监听器将显示弹出窗口：
- en: '[PRE31]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first step is to create the `OpenLayers.Control.Geolocate` control instance
    and add it to the map:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建 `OpenLayers.Control.Geolocate` 控制器实例并将其添加到地图中：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The control can trigger three events:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 控件可以触发三个事件：
- en: '`locationupdated:` This event is fired when the browser returns a new position'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locationupdated:` 当浏览器返回新位置时触发此事件'
- en: '`locationfailed:` This event is fired if the geolocation fails'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locationfailed:` 如果地理位置失败，则触发此事件'
- en: '`locationuncapable:` This event is fired if you activate the control in a browser
    that does not support geolocation.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locationuncapable:` 如果你在不支持地理位置的浏览器中激活控件，则会触发此事件。'
- en: In this recipe, we attached an event listener function for the events `locationupdated`
    and `locationfailed`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们为`locationupdated`和`locationfailed`事件附加了一个事件监听器函数。
- en: To use the Geolocate control, we need to invoke its `activate()` method. Then,
    OpenLayers will request the browser to get the current user's location and the
    browser will ask if we want to share our location. If we accept, then a `locationupdated`
    event will be triggered with the current location as an argument.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Geolocate控件，我们需要调用其`activate()`方法。然后，OpenLayers将请求浏览器获取当前用户的位置，浏览器会询问我们是否想要分享我们的位置。如果我们接受，则将触发一个带有当前位置作为参数的`locationupdated`事件。
- en: 'In the recipe, the `geolocationClick` function is called when the button is
    clicked and forces the activation of the control:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱中，当按钮被点击时，会调用`geolocationClick`函数，并强制激活控件：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, when the `locationupdated` event is triggered, the `locateMarker` function
    is executed, passing an `event` parameter with all the related event information,
    including the client coordinates:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当`locationupdated`事件被触发时，`locateMarker`函数被执行，传递一个带有所有相关事件信息的`event`参数，包括客户端坐标：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The coordinates stored at `event.point` are transformed by the **Geolocate**
    control, to be in the same coordinate system as the map.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`event.point`中的坐标由**Geolocate**控件转换，以与地图相同的坐标系一致。
- en: The purpose of this function is to add a marker to the map at the current client's
    location and show a popup with the coordinates when the mouse goes over the marker.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的目的是在地图上添加一个标记到当前客户端的位置，并在鼠标悬停在标记上时显示一个带有坐标的弹出窗口。
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `OpenLayers.Control.Geolocate` control has a couple of interesting properties.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Control.Geolocate`控件有几个有趣的属性。'
- en: First the `bind` property, by default set to `true`, allows us to specify if
    the map's center must be updated to the location detected by the control.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`bind`属性默认设置为`true`，允许我们指定地图的中心是否必须更新为控件检测到的位置。
- en: The `watch` property, by default set to `false`, allows updating the position
    regularly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`属性默认设置为`false`，允许定期更新位置。'
- en: In addition, we can pass to the control a `geolocationOptions` object, defined
    in the specification (see [http://dev.w3.org/geo/api/spec-source.html#position_options_interface)](http://dev.w3.org/geo/api/spec-source.html#position_options_interface))
    for better configuration of the control.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以向控件传递一个`geolocationOptions`对象，该对象在规范中定义（见[http://dev.w3.org/geo/api/spec-source.html#position_options_interface)](http://dev.w3.org/geo/api/spec-source.html#position_options_interface))，以更好地配置控件。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding and removing controls* recipe
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和删除控件*菜谱'
- en: The *Modifying features* recipe
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改特征*菜谱'
- en: Placing controls outside the map
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将控件放置在地图外部
- en: 'By default, all the controls are placed on the map. This way, controls such
    as the PanPanel, EditingToolbar, or MousePosition are rendered on top of the map
    and over any layer. This is the default behavior, but OpenLayers is flexible enough
    to allow us to put controls outside the map:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有控件都放置在地图上。这样，像PanPanel、EditingToolbar或MousePosition这样的控件就会渲染在地图上方，覆盖任何图层。这是默认行为，但OpenLayers足够灵活，允许我们将控件放置在地图之外：
- en: '![Placing controls outside the map](img/7843_05_04.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![将控件放置在地图外部](img/7843_05_04.jpg)'
- en: In this recipe we are going to create a map where the navigation toolbar and
    the mouse position controls are placed outside and above the map.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个地图，其中导航工具栏和鼠标位置控件放置在地图外部和上方。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create an HTML file and add the OpenLayers dependencies. Add the following
    CSS code required to redefine some aspects of the controls we are going to use:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTML文件并添加OpenLayers依赖项。添加以下CSS代码，用于重新定义我们将要使用的控件的一些方面：
- en: '[PRE35]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, add the HTML code to place the two controls above the map:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加HTML代码以将两个控件放置在地图上方：
- en: '[PRE36]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create the map instance and add a base layer:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建地图实例并添加基本图层：
- en: '[PRE37]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, add the mouse position and navigation toolbar controls:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加鼠标位置和导航工具栏控件：
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The previous code seems pretty simple. We have added two controls to our map:
    an `OpenLayers.Control.MousePosition` control, which shows the current coordinates
    of the mouse on the map, and `OpenLayers.Control.NavToolbar`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码看起来相当简单。我们向地图添加了两个控件：一个`OpenLayers.Control.MousePosition`控件，它显示鼠标在地图上的当前坐标，以及`OpenLayers.Control.NavToolbar`。
- en: 'The `OpenLayers.Control.NavToolbar` control is nothing more than a panel control
    that contains other controls: an `OpenLayers.Control.Navigation` control, the
    hand icon (to move the map), and an `OpenLayers.Control.ZoomBox` control, the
    magnifying glass icon (to zoom on a given box).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Control.NavToolbar` 控件只不过是一个包含其他控件的面板控件：一个 `OpenLayers.Control.Navigation`
    控件（用于移动地图的手形图标），以及一个 `OpenLayers.Control.ZoomBox` 控件（用于在给定框上缩放的放大镜图标）。'
- en: So, where is the secret in the recipe for placing the controls outside the map?
    The answer is in the construction of each control.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，将控件放置在地图外的秘诀在哪里？答案是每个控件的构建中。
- en: The base class `OpenLayers.Control` has a `div` property that points to the
    `div` element that will be used to hold the control. By default, no `div` element
    is specified in the constructor, so the control creates a new one to be used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 基类 `OpenLayers.Control` 有一个指向用于存放控件的 `div` 元素的 `div` 属性。默认情况下，构造函数中没有指定 `div`
    元素，因此控件会创建一个新的用于此目的。
- en: If you specify a `div` element in the control instantiation, then it is used
    as the place where the control will be rendered.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了一个 `div` 元素用于控件实例化，那么它将用作控件将被渲染的位置。
- en: 'For the MousePosition control, we have used the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于鼠标位置控件，我们使用了以下代码：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This means we are placing the control on the previously created `div` element,
    identified by the `mouseposition` string.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将控件放置在之前创建的 `div` 元素上，该元素由 `mouseposition` 字符串标识。
- en: 'For the navigation toolbar, it differs a bit:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于导航工具栏，它略有不同：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this case we have set the CSS class `olControlNavToolbar`, defined by OpenLayers.
    Why?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们设置了 OpenLayers 定义的 CSS 类 `olControlNavToolbar`。为什么？
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we do not specify the `div` property, the control creates one and applies
    some default CSS classes that set the control icon, borders, background color,
    and so on. Remove the `div` property from the navigation toolbar and see the results.
    A `div` element will be created and placed on the map with some classes, such
    as `olControlNavToolbar`, attached to it and will contain some other elements
    representing the buttons for the pan and zoom actions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有指定 `div` 属性时，控件会创建一个并应用一些默认的 CSS 类，这些类设置了控件图标、边框、背景颜色等。从导航工具栏中移除 `div`
    属性并查看结果。将创建一个 `div` 元素并将其放置在地图上，并附加一些类，例如 `olControlNavToolbar`，它将包含表示平移和缩放操作的按钮等元素。
- en: When we specify the `div` property to be used, no style is automatically created
    and, because of this, controls can disappear or not be rendered nicely if we do
    not specify some CSS.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指定要使用的 `div` 属性时，不会自动创建样式，因此如果未指定一些 CSS，控件可能会消失或无法很好地渲染。
- en: Once this is clear, we can say we have not used the CSS class with the mouse
    position control because it only contains some text. Well, we have only set the
    font size.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这一点明确，我们可以说我们没有使用鼠标位置控件的 CSS 类，因为它只包含一些文本。好吧，我们只设置了字体大小。
- en: The navigation control is a more complex control, it contains two other controls
    and we need to tune up its style a bit.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 导航控件是一个更复杂的控件，它包含两个其他控件，我们需要对其样式进行一点调整。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we will see in [Chapter 6](ch06.html "Chapter 6. Theming"), *Theming*, most
    of the OpenLayers flexibility when working with controls is due to the use of
    the CSS classes. All the controls have, by default, a CSS class associated that
    defines its position, icons, color, and so on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在 [第 6 章](ch06.html "第 6 章。主题") 中看到的，*主题*，OpenLayers 在处理控件时的大部分灵活性都归因于
    CSS 类的使用。所有控件默认都有一个与之关联的 CSS 类，它定义了其位置、图标、颜色等。
- en: 'In the CSS code that we have set at the beginning of the recipe, we are redefining
    the place of the navigation toolbar within the `div` and indicating that we want
    the contained elements, buttons, and flows in the `left` direction:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱开头设置的 CSS 代码中，我们重新定义了导航工具栏在 `div` 中的位置，并指出我们希望包含的元素、按钮和流向在 `left` 方向上：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 6](ch06.html "Chapter 6. Theming"), *Theming*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 6 章](ch06.html "第 6 章。主题")，*主题*'
- en: Editing features on multiple vector layers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个矢量图层上编辑要素
- en: 'When working with vector information, most probably, one of the most common
    things we can do in a GIS application is: add new features.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理矢量信息时，在 GIS 应用程序中，我们最可能做的最常见的事情之一是：添加新要素。
- en: OpenLayers has plenty of controls, so there is no need to reinvent the wheel.
    We have a set of tools and the only thing we need to do is learn how to use each
    one.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers 有很多控件，因此没有必要重新发明轮子。我们有一套工具，我们唯一需要做的就是学习如何使用每一个。
- en: 'For this concrete purpose, add new features. OpenLayers has the `OpenLayers.Control.EditingToolbar`
    control that shows a toolbar with some buttons to add polygons, polylines, and
    points:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个具体目的，添加新要素。OpenLayers 有 `OpenLayers.Control.EditingToolbar` 控件，它显示一个带有一些按钮的工具栏，用于添加多边形、折线和点：
- en: '![Editing features on multiple vector layers](img/7843_05_05.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![在多个矢量图层上编辑要素](img/7843_05_05.jpg)'
- en: Because we can have many vector layers in the map, the control needs us to specify
    the layer it must work on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地图中可以包含多个矢量图层，控制需要我们指定它必须工作的图层。
- en: In addition to showing how easy is to use the control, the goal of this recipe
    is to show how we can use the same control to add features to more than one layer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了展示如何轻松使用控件外，本菜谱的目标是展示我们如何使用相同的控件向多个图层添加要素。
- en: This way, this little application will consist of a map with two vector layers.
    Thanks to the radio buttons, we will be able to chose the layer on which we want
    to create the new features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，这个小应用程序将包含一个具有两个矢量图层的地图。多亏了单选按钮，我们将能够选择我们想要创建新要素的图层。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, add the HTML code to create a couple of radio buttons that will allow
    us to select the vector layer on which we want to draw:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加 HTML 代码以创建几个单选按钮，这将允许我们选择我们想要在哪个矢量图层上绘制：
- en: '[PRE42]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, create a map instance and add a base layer:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个地图实例并添加一个基本图层：
- en: '[PRE43]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the two vector layers:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个矢量图层：
- en: '[PRE44]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the editing toolbar control, initially associated to the first vector layer:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加编辑工具栏控件，最初与第一个矢量图层相关联：
- en: '[PRE45]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, implement the code to handle the radio button changes. It will change
    the layer associated to the editing toolbar control:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现处理单选按钮更改的代码。它将更改与编辑工具栏控件关联的图层：
- en: '[PRE46]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The use of the `OpenLayers.Control.EditingToolbar` control has not much mystery.
    In the constructor, we need to indicate the vector layer we want to add the new
    features to.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `OpenLayers.Control.EditingToolbar` 控件并没有多少神秘之处。在构造函数中，我们需要指定我们想要添加新要素的矢量图层。
- en: The control will show some buttons on top of the map, allowing us to create
    new polygons, polylines, or points. Those new features will be added to the specified
    layer.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 控件将在地图上方显示一些按钮，允许我们创建新的多边形、折线或点。这些新要素将被添加到指定的图层。
- en: So, the secret to add features to other vector layers is about how to change
    the layer referenced by the control.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将要素添加到其他矢量图层的秘密在于如何更改控件引用的图层。
- en: The `OpenLayers.Control.EditingToolbar` control is nothing more than a panel
    that contains four controls. We encourage the reader to take a look at its `initialize`
    method.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Control.EditingToolbar` 控制不过是一个包含四个控件的面板。我们鼓励读者查看其 `initialize`
    方法。'
- en: The editor toolbar contains a navigation control, which is represented by the
    hand icon, and three instances of the `OpenLayers.Control.DrawFeature` control.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑工具栏包含一个导航控件，由手形图标表示，以及三个 `OpenLayers.Control.DrawFeature` 控件的实例。
- en: The DrawFeature control is the essence of the editor toolbar control. Given
    a vector layer and a handler, the control allows drawing features on the layer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: DrawFeature 控制是编辑工具栏控制的精髓。给定一个矢量图层和一个处理器，该控制允许在图层上绘制要素。
- en: As we mentioned at the beginning of this chapter, controls are closely related
    to handlers. Here, we can see how handlers are responsible for detecting the mouse
    events and translate it to the point, path, or polygon creation events. On the
    other side, the draw feature control listens for these events and creates the
    appropriate map features.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章开头所述，控件与处理器密切相关。在这里，我们可以看到处理器负责检测鼠标事件并将其转换为点、路径或多边形创建事件。另一方面，draw feature
    控制监听这些事件并创建相应的地图要素。
- en: 'Let''s summarize the key points:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下关键点：
- en: 'The editor toolbar, as a panel, contains a list of controls: one Navigation
    control and three DrawFeature controls'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑工具栏，作为一个面板，包含了一系列控件：一个导航控件和三个 DrawFeature 控件
- en: In addition, the EditingToolbar control needs a reference to the vector layer
    to be edited
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，EditingToolbar 控件需要一个要编辑的矢量图层的引用
- en: The vector layer reference is passed to the three DrawFeature controls, so they
    can add new features on the layer
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矢量图层引用被传递给三个 DrawFeature 控件，因此它们可以在图层上添加新要素
- en: 'Now, we can see that by changing the layer reference in the draw feature controls,
    we change the layer where features are added. And this is exactly what the functions
    that listen for radio buttons'' events do:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到通过更改绘制要素控件中的图层引用，我们改变了添加要素的图层。这正是监听单选按钮事件的功能所做的事情：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we can see in the code, from the editing toolbar we get all the draw feature
    controls with the call to the `getControlsByClass` method, and then for each one
    we change the reference to the layer by changing the `layer` property.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，我们从编辑工具栏中通过调用 `getControlsByClass` 方法获取所有绘制要素控件，然后对每个控件通过更改 `layer` 属性来更改图层引用。
- en: There's more...
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we look at the code of the `initialize()` method of the `OpenLayers.Control.EditingToolbar`
    class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `OpenLayers.Control.EditingToolbar` 类的 `initialize()` 方法的代码：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can see it is passing a `displayClass` property to the `OpenLayers.Control.DrawFeature`
    controls.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它正在将 `displayClass` 属性传递给 `OpenLayers.Control.DrawFeature` 控件。
- en: This property is also common to all controls inherited from the `OpenLayers.Control`
    class, and specifies the CSS class that must be applied to the `div` element that
    will be used to draw the control.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性也适用于从 `OpenLayers.Control` 类继承的所有控件，并指定必须应用于将要用于绘制控件的 `div` 元素的 CSS 类。
- en: See also
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Placing controls outside the map* recipe
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将控件放置在地图外部* 菜谱'
- en: The *Modifying features* recipe
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改要素* 菜谱'
- en: Modifying features
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改要素
- en: When working on the web mapping application, most probably, the capability to
    allow the users to add new features would be a desired requirement, but what about
    modifying features such as move vertex, rotate features, scale, and so on?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当在网页地图应用上工作时，很可能允许用户添加新功能的能力是一个期望的要求，但修改诸如移动顶点、旋转要素、缩放等功能又如何呢？
- en: 'Again, OpenLayers simplifies our lives as developers, giving us the powerful
    `OpenLayers.Control.ModifyFeature` control:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，OpenLayers 简化了我们的开发生活，为我们提供了强大的 `OpenLayers.Control.ModifyFeature` 控件：
- en: '![Modifying features](img/7843_05_06.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![修改要素](img/7843_05_06.jpg)'
- en: 'This time we are going to create a little application that will provide us
    with two important controls: first, to add new features and second, to modify
    them. For this purpose, we will use the `OpenLayers.Control.EditingToolbar` and
    `OpenLayers.Control.ModifyFeature` controls.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将创建一个小应用程序，它将为我们提供两个重要的控件：首先，添加新功能；其次，修改它们。为此，我们将使用 `OpenLayers.Control.EditingToolbar`
    和 `OpenLayers.Control.ModifyFeature` 控件。
- en: In concrete, we will see how we can reshape, resize, rotate, and drag features.
    In addition, we will see how to filter what kind of features can be affected by
    the modifications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将看到如何重塑、调整大小、旋转和拖动要素。此外，我们还将看到如何过滤哪些类型的要素可以被修改所影响。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s start with creating the controls required for managing the control to
    modify a feature:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建管理修改要素控件的控件开始：
- en: '[PRE49]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the element to hold the map:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用于承载地图的元素：
- en: '[PRE50]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Start the JavaScript coding by initializing the map and adding a base layer:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过初始化地图并添加基本图层开始 JavaScript 编码：
- en: '[PRE51]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, add a vector layer to add and modify its features:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个矢量图层来添加和修改其要素：
- en: '[PRE52]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Attach an editing toolbar control to the previous layer and add it to the map:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编辑工具栏控件附加到之前的图层，并将其添加到地图中：
- en: '[PRE53]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Similarly, attach a ModifyFeature control to the vector layer and add it to
    the map:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，将 ModifyFeature 控件附加到矢量图层，并将其添加到地图中：
- en: '[PRE54]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the listener functions that modify the behavior of the modify feature control.
    First add the function that activates or deactivates the control:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加修改修改要素控件行为的监听器函数。首先添加一个激活或停用控件的功能：
- en: '[PRE55]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, add the function that changes the way the modifications are made:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个改变修改方式的功能：
- en: '[PRE56]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally add the function to filter the type of geometries the control affects:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后添加一个函数来过滤受控制影响的几何类型：
- en: '[PRE57]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The editing toolbar allows us to draw points, paths, and polygons. Once some
    features are added to the layer, we can click on the **Modify** toggle button
    to activate or deactivate the modify feature control. This action is handled by
    the `modifyChanged` function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑工具栏允许我们绘制点、路径和多边形。一旦将一些要素添加到图层中，我们可以点击 **修改** 切换按钮来激活或停用修改要素控件。这个动作由 `modifyChanged`
    函数处理：
- en: '[PRE58]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: By default, the modify feature control allows to reshape any kind of feature,
    no matter whether it is a point, path, or polygon, that is we can move or add
    a new vertex to the feature.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，修改功能控制器允许重塑任何类型的功能，无论它是点、路径还是多边形，也就是说我们可以移动或向功能添加一个新顶点。
- en: With the checkboxes, we can modify the behavior of the control, for example,
    allowing resizing or dragging of the selected feature.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复选框，我们可以修改控制器的行为，例如，允许调整大小或拖动选定的功能。
- en: The function `changeMode` listens for changes on any of the checkboxes and is
    responsible to modify the action that the control handles.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`changeMode`正在监听任何复选框的变化，并负责修改控制器处理的操作。
- en: The action in question is specified through the `mode` property of the control.
    We can set it at the time of instantiation, or later by modifying the property,
    as we are doing in this recipe.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有关动作的指定是通过控制器的`mode`属性来完成的。我们可以在实例化时设置它，或者稍后通过修改属性来设置，就像我们在本食谱中所做的那样。
- en: 'In addition, the control allows to handle many actions at a time. We can specify
    all of them using the logical OR operator. For example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，控制器允许同时处理许多动作。我们可以使用逻辑或运算符指定所有这些动作。例如：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, we force the deactivation and later the activation of the control
    so that the new `mode` value takes effect.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们强制停用控制器，然后激活它，以便新的`mode`值生效。
- en: Finally, we can control one more thing of the control's behavior and that is,
    the kind of features we can modify. Using the select box, we can choose the kind
    of geometries that can be modified by the control. The function `changeFilter`
    is listening for changes on the select box and changes the configuration of the
    modify feature control.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以控制控制器行为的另一个方面，那就是我们可以修改的功能类型。使用选择框，我们可以选择可以被控制器修改的几何类型。函数`changeFilter`正在监听选择框的变化，并更改修改功能控制的配置。
- en: This geometry filter is done by using the `geometryType` property of the control.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此几何过滤器是通过使用控制器的`geometryType`属性来完成的。
- en: Unfortunately, this property can only be set at instantiation time, changes
    made later have no effect. So, we need to remove the control from the map and
    create a new one with the desired geometries to be filtered.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，此属性只能在实例化时设置，稍后做出的更改没有效果。因此，我们需要从地图中删除控制器，并创建一个新的控制器，带有要过滤的期望几何形状。
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Removing a control from the map does not free the possible resources used by
    the control. We need to destroy it to free the resources.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从地图中删除控制器不会释放控制器可能使用的资源。我们需要销毁它以释放资源。
- en: There's more...
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: After reading this recipe, we know how to modify the features. But, what if
    we want to listen for events while features are being modified? How to know when
    a modification is going to be made?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本食谱后，我们知道如何修改功能。但是，如果我们想在功能被修改时监听事件怎么办？如何知道何时将进行修改？
- en: The answer is simple, we need to listen for events in the vector layer we are
    modifying.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单，我们需要监听我们正在修改的矢量层中的事件。
- en: Registering for events, such as `beforefeaturemodified, featureselected`, or
    `vertexremoved` allows us to know what exactly is happening and react according
    to our requirements.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注册事件，如`beforefeaturemodified`、`featureselected`或`vertexremoved`，使我们能够确切地知道正在发生什么，并根据我们的要求做出反应。
- en: See also
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考内容
- en: The *Editing features on multiple vector layers* recipe
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多矢量层编辑功能*食谱'
- en: The *Adding and removing controls* recipe
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和删除控制器*食谱'
- en: The *Listening for vector layer features' event* recipe in [Chapter 4](ch04.html
    "Chapter 4. Working with Events"), *Controls*
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。处理事件") *控制*中的*监听矢量层功能事件*食谱
- en: Measuring distances and areas
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量距离和面积
- en: The capability to measure distances or areas is an important thing on many GIS
    applications.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多GIS应用中，测量距离或面积的能力是非常重要的。
- en: In this recipe, we are going to see in action what the Measure control in OpenLayers
    offers to the developer.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将看到OpenLayers中的测量控制器为开发者提供了哪些功能。
- en: 'The application will show a simple map with some buttons on top, as shown in
    the following screenshot. The **Measure** toggle button activates or deactivates
    the control, while the radio buttons bring us the possibility to select what to
    measure: a path or an area:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将显示一个简单的地图，上面有一些按钮，如下面的截图所示。**测量**切换按钮激活或停用控制器，而单选按钮则为我们提供了选择要测量的内容：路径或区域：
- en: '![Measuring distances and areas](img/7843_05_07.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![测量距离和面积](img/7843_05_07.jpg)'
- en: In addition, we can set two control options. The **Geodesic** control indicates
    if the distance of the area computation must be in geodesic metrics instead of
    planar. The **Immediate** option is useful to update the measure every time we
    move the mouse.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以设置两个控件选项。**测地线**控件表示面积计算的距离是否必须使用测地线度量而不是平面度量。**立即**选项在每次移动鼠标时更新测量很有用。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Here, we are going to write not the whole source code but only those pieces
    of code that are important for the recipe. So, we are avoiding putting here the
    HTML code required to build the measure button, checkboxes, options radio buttons,
    and the `div` element that holds the map instance.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将只编写重要的代码片段，而不是整个源代码。因此，我们避免在这里放置构建测量按钮、复选框、选项单选按钮以及包含地图实例的`div`元素的HTML代码。
- en: 'Let''s take a look at the JavaScript code. First, instantiate the map, add
    a base layer, and center the map display:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看JavaScript代码。首先，实例化地图，添加一个基本图层，并居中地图显示：
- en: '[PRE60]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, add the Measure control. Note that we are registering two listener functions
    for the events `measure` and `measurepartial:`
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加测量控制。请注意，我们为事件`measure`和`measurepartial:`注册了两个监听函数：
- en: '[PRE61]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, place the code for the **Measure** toggle button that activates or deactivates
    the control:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，放置用于激活或禁用控制的**测量**切换按钮的代码：
- en: '[PRE62]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Implement the listener functions for the `measure` and `measurepartial` control
    events:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现对`measure`和`measurepartial`控件事件的监听函数：
- en: '[PRE63]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, place the code for the functions that change the **Geodesic** and
    **Immediate** options:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，放置用于更改**测地线**和**立即**选项的函数的代码：
- en: '[PRE64]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start analyzing how we initialized the measure control:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下我们是如何初始化测量控制的：
- en: '[PRE65]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The only parameter we need to pass to the control is a handler to be used.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要传递给控件的一个参数是用于处理程序。
- en: 'Like many other controls, the `OpenLayers.Control.Measure` class makes use
    of handlers to interact with the map. In this case, the measure control can make
    use of any handler that allows to draw geometries. To summarize, the flow is as
    follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多其他控件一样，`OpenLayers.Control.Measure`类利用处理程序与地图进行交互。在这种情况下，测量控件可以利用任何允许绘制几何形状的处理程序。总结一下，流程如下：
- en: The control is activated and it delegates to a handler the task of drawing some
    geometry in the map
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件被激活，并将绘制地图上某些几何形状的任务委托给处理程序
- en: Once the handler has drawn the desired geometry, (such as a path or a polygon)
    the feature is returned to the control
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦处理程序绘制了所需的几何形状（例如路径或多边形），该要素就被返回到控件
- en: The control computes the distance or area of the geometry and triggers an event
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件计算几何形状的距离或面积，并触发一个事件
- en: Note
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually, we have a limitation to use handlers that return geometries that implement
    the `getArea()` or `getLength()` methods. For example, if you try to use the `OpenLayers.Handler.Box`
    handler with the measure control, once you activate the control and draw a box,
    you will get an error in the browser console. This is because the box handler
    returns an `OpenLayers.Bounds` instance that neither has a `getLength` nor `getArea`
    method.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们使用返回实现`getArea()`或`getLength()`方法的几何形状处理程序有限制。例如，如果您尝试使用`OpenLayers.Handler.Box`处理程序与测量控件一起使用，一旦激活控件并绘制一个矩形，您将在浏览器控制台中收到一个错误。这是因为矩形处理程序返回一个没有`getLength`或`getArea`方法的`OpenLayers.Bounds`实例。
- en: 'In our code we have initialized the measure control setting as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们初始化测量控制设置如下：
- en: The `persist` property to `true`. This property indicates that the geometry
    created by the handler must remain on the map until a new measure starts.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`persist`属性设置为`true`。此属性表示由处理程序创建的几何形状必须保留在地图上，直到新的测量开始。
- en: Two event listeners, for the events `measure` and `measurepartial`. The `measure`
    event is triggered once the measure action has been finished. The `measurepartial`
    is triggered on any measure update (only if the `immediate` property is true).
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个事件监听器，针对`measure`和`measurepartial`事件。`measure`事件在测量动作完成后触发。`measurepartial`在每次测量更新时触发（仅当`immediate`属性为`true`时）。
- en: When the **Measure** toggle button is pressed, the `measureClick` function is
    executed. This function checks what kind of handler must be used for the measurement
    and sets it on the control.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下**测量**切换按钮时，执行`measureClick`函数。此函数检查必须用于测量的处理程序类型，并将其设置在控件上。
- en: 'This can be done by the `updateHandler` method on the Measure control. For
    example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过测量控制上的`updateHandler`方法来完成。例如：
- en: '[PRE66]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In addition, the `measureClick` function adds the control to the map and activates
    when the button is toggled on, or deactivates and removes the control from the
    map when the button is toggled off.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`measureClick`函数将控制添加到地图上，并在按钮开启时激活，或者在按钮关闭时停用并从地图中移除控制。
- en: For the control options buttons, we have set two listening functions associated
    to the checkboxes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控制选项按钮，我们设置了两个与复选框关联的监听函数。
- en: 'When the **Immediate** checkbox changes, the `changeImmediate` function is
    executed. This, using the `setImmediate` method, changes the `immediate` property
    of the control, which allows triggering events every time the measure updates
    with a mouse movement:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当**立即**复选框改变时，`changeImmediate`函数将被执行。这通过使用`setImmediate`方法，改变控制的`immediate`属性，允许在每次测量更新时通过鼠标移动触发事件：
- en: '[PRE67]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The **Geodesic** checkbox sets the value of the `geodesic` property. This time
    we can modify the property directly without the need of a setter function:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**大地测量**复选框设置`geodesic`属性的值。这次我们可以直接修改属性，而不需要setter函数：'
- en: '[PRE68]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: With the `geodesic` property set to `true`, the control will use a geodesic
    metric instead of a planar metric to compute the measures.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当`geodesic`属性设置为`true`时，控制将使用大地测量度量而不是平面度量来计算测量值。
- en: There's more...
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: An important part of the measurement is done with the geometric instances.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 测量的一个重要部分是用几何实例完成的。
- en: All the geometry classes, such as `OpenLayers.Geometry.Polygon` or `OpenLayers.Geometry.LineString`,
    contain methods to compute their area or length.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的几何类，如`OpenLayers.Geometry.Polygon`或`OpenLayers.Geometry.LineString`，都包含计算它们的面积或长度的方法。
- en: Looking at the measure control source code, we can see how once its associated
    handler returns a geometry, it simply calls the geometry methods to get the area
    or length and triggers an event.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看测量控制源代码，我们可以看到一旦其关联的处理程序返回一个几何体，它就简单地调用几何方法来获取面积或长度并触发一个事件。
- en: See also
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考内容
- en: The *Working with geolocation* recipe
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用地理位置*菜谱'
- en: The *Editing features on multiple vector layers* recipe
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在多个矢量层上编辑要素*菜谱'
- en: The *Modifying features* recipe
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改要素*菜谱'
- en: Getting feature information from data source
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据源获取要素信息
- en: 'We work on web mapping applications almost every day. We know how to create
    a map and add raster and vector layers. More than that, we know how to get vector
    data from different data sources: GeoJSON file, KML file, or from a WFS server.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎每天都在处理网络地图应用。我们知道如何创建地图并添加栅格和矢量层。不仅如此，我们还知道如何从不同的数据源获取矢量数据：GeoJSON文件、KML文件或从WFS服务器。
- en: 'At this point, and related to vector layers, one of the possible questions
    we could have is: how can we retrieve the feature''s information? Fortunately,
    OpenLayers offers us some controls that can answer this question.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，与矢量层相关，我们可能有一个问题：我们如何检索要素的信息？幸运的是，OpenLayers为我们提供了一些可以回答这个问题的控制。
- en: In this recipe, we are going to see in action the `OpenLayers.Control.GetFeature`
    control class that has the ability to query the feature's data source.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到`OpenLayers.Control.GetFeature`控制类在查询要素数据源方面的实际应用。
- en: We are going to create a map with a base layer and two vector layers. One from
    a WFS server, with the USA, and the other from a GML file with Europe's countries.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含一个底图层和两个矢量层的地图。一个来自WFS服务器，包含美国，另一个来自GML文件，包含欧洲国家。
- en: On top of the map, a button allows us to activate/deactivate the `GetFeature`
    control and two radio buttons allow us to select between the USA or Europe layers
    to be queried.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图上方，一个按钮允许我们激活/停用`GetFeature`控制，两个单选按钮允许我们在要查询的美国或欧洲层之间进行选择。
- en: How to do it...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start creating the HTML file with the OpenLayers dependencies. Then
    add the HTML code for the map and buttons:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始创建带有OpenLayers依赖项的HTML文件。然后添加地图和按钮的HTML代码：
- en: '[PRE69]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the JavaScript section, set the proxy script to be used:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript部分，设置要使用的代理脚本：
- en: '[PRE70]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Initialize the map and add a base layer:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化地图并添加一个底图层：
- en: '[PRE71]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Add the two vector layers, the first from a WFS server and the second from
    a GML file:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个矢量层，第一个来自WFS服务器，第二个来自GML文件：
- en: '[PRE72]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Add a third layer that will serve to show the selected features:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个第三层，用于显示选定的要素：
- en: '[PRE73]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now add the `GetFeature` control:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加`GetFeature`控制：
- en: '[PRE74]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Insert the code to activate/deactivate the control:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入激活/停用控制的代码：
- en: '[PRE75]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And finally, add the code that will change which layer to be queried by the
    control:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加将改变由控制查询的层的代码：
- en: '[PRE76]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we are working with the WFS layer, and also the later queries made by
    the `GetFeature` control are using AJAX, we need to configure a proxy script to
    be used.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用WFS层，并且后续的`GetFeature`控制查询也使用AJAX，因此我们需要配置一个要使用的代理脚本。
- en: 'After initializing the map, we have added a base WMS layer simply using the
    `OpenLayers.Layer.WMS` class and specifying a URL to the server and the WMS layer
    name:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化地图后，我们仅使用`OpenLayers.Layer.WMS`类添加了一个基本WMS层，并指定了服务器的URL和WMS层名称：
- en: '[PRE77]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The two vector layers have not much secret. Thanks to the `OpenLayers.Protocol`
    subclasses, we can easily create vector layers from different data sources by
    simply specifying the right protocol:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个矢量层没有太多秘密。多亏了`OpenLayers.Protocol`子类，我们可以通过简单地指定正确的协议轻松地从不同的数据源创建矢量层：
- en: '[PRE78]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In addition, we have created a third vector layer called `selected`. Why? Let''s
    explain first how the `OpenLayers.Control.GetFeature` works:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们创建了一个名为`selected`的第三个矢量层。为什么？让我们首先解释一下`OpenLayers.Control.GetFeature`是如何工作的：
- en: '[PRE79]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: By default, `OpenLayers.Control.GetFeature` starts working when a click event
    is made. Then, using the specified `protocol` instance, it queries the data source
    for the features under the click location.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`OpenLayers.Control.GetFeature`在发生点击事件时开始工作。然后，使用指定的`protocol`实例，它查询点击位置下的数据源特征。
- en: In addition, by using the `box` property, we can allow selecting features using
    a selection binding box. A third selection is done with the hover action but we
    have disabled it setting the `hover` property to `false`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过使用`box`属性，我们可以允许使用选择绑定框选择特征。第三次选择是通过悬停动作完成的，但我们已将其设置为`false`来禁用它。
- en: As the name implies, the properties `multipleKey` and `toggleKey` are used to
    define the control keys that are used to select multiple features and toggle their
    selection state.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`multipleKey`和`toggleKey`属性用于定义用于选择多个特征和切换其选择状态的控件键。
- en: Finally, the `eventListeners` property allows us to register at the time the
    constructor is called and the events we want to listen for. In this case we will
    be notified when a feature will be selected or unselected.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`eventListeners`属性允许我们在构造函数调用时注册我们想要监听的事件。在这种情况下，我们将被通知当特征被选中或取消选中时。
- en: Let's go back to the third vector layer, the `selected` layer.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到第三个矢量层，即`selected`层。
- en: In contrast to the other controls, such as the `OpenLayers.Control.SelectFeature,
    OpenLayers.Control.GetFeature` didn't modify the visual style of the feature.
    That is, if you use the `SelectFeature` control, you will see that each time you
    select a feature, its color and border will change to indicate it is selected.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他控制（如`OpenLayers.Control.SelectFeature`和`OpenLayers.Control.GetFeature`）不同，`OpenLayers.Control.GetFeature`没有修改特征的可视样式。也就是说，如果你使用`SelectFeature`控制，你会看到每次选择一个特征时，其颜色和边框都会改变以指示它已被选中。
- en: On the other hand, with `OpenLayers.Control.GetFeature`, nothing happens when
    a feature is selected. The control makes a query to the data source and an event
    is triggered. You are responsible to perform something with that event.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用`OpenLayers.Control.GetFeature`，当选择一个特征时不会发生任何事情。控制会对数据源进行查询并触发一个事件。你负责对那个事件进行操作。
- en: 'In this recipe, we are retrieving the feature from the event and adding it
    to the selected layer:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们从事件中检索特征并将其添加到所选层：
- en: '[PRE80]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If we look at the instantiation code of the selected layer, it looks something
    like the following code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看所选层的实例化代码，它看起来像以下代码：
- en: '[PRE81]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We have supplied a different style for the layer. In this case, we are getting
    the`"temporary"` style defined at `OpenLayers.Feature.Vector` and applying it
    to the layer so the features have a different look.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为该层提供了不同的样式。在这种情况下，我们正在获取在`OpenLayers.Feature.Vector`中定义的`"temporary"`样式并将其应用于层，以便特征具有不同的外观。
- en: Note
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More on styling is discussed in [Chapter 7](ch07.html "Chapter 7. Styling Features"),
    *Styling Features.*
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 关于样式的更多讨论请参阅[第7章](ch07.html "第7章。样式化特征")，*样式化特征*。
- en: There's more...
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is important to note that the `OpenLayers.Control.SelectFeature` control
    is similar to the `OpenLayers.control.GetFeature` control, but they have important
    differences.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`OpenLayers.Control.SelectFeature`控制与`OpenLayers.control.GetFeature`控制类似，但它们有重要的区别。
- en: First, the `OpenLayers.control.GetFeature` control makes a query to the data
    source that returns the features involved by the selection. The `openLayers.Control.SelectFeature`
    control makes no request, it works on the client-side and retrieves the selected
    feature from the specified vector layer.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`OpenLayers.control.GetFeature`控件会对数据源进行查询，返回由选择涉及的特征。`openLayers.Control.SelectFeature`控件不进行请求，它在客户端工作，并从指定的矢量图层检索选定的特征。
- en: Second, every time a feature is selected with the `OpenLayers.Control.SelectFeature`
    control, a `featureselected` event is triggered by the vector layer. So we can
    register listeners in the vector layer to be notified for the selection events.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，每次使用`OpenLayers.Control.SelectFeature`控件选择特征时，矢量层都会触发一个`featureselected`事件。因此，我们可以在矢量层中注册监听器以通知选择事件。
- en: With the `OpenLayers.control.GetFeature` control, no event is triggered by the
    vector layer. The events are triggered by the control and because of this we need
    to register listeners in the control.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`OpenLayers.control.GetFeature`控件，矢量层不会触发任何事件。事件是由控件触发的，因此我们需要在控件中注册监听器。
- en: Finally, with the `OpenLayers.control.GetFeature` control, we can use any protocol
    that supports spatial filters. Because of this, we can use the `GetFeature` control
    against a WFS server or a GML file.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`OpenLayers.control.GetFeature`控件，我们可以使用任何支持空间过滤的协议。正因为如此，我们可以将`GetFeature`控件用于WFS服务器或GML文件。
- en: See also
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Selecting and transforming features* recipe
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择和转换特征*配方'
- en: The *Getting information from the WMS server* recipe
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从WMS服务器获取信息*配方'
- en: The *Adding GML layer* recipe in [Chapter 3](ch03.html "Chapter 3. Working with
    Vector Layers"), *Vector Layers*
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。处理矢量图层")中的*添加GML图层*配方，*矢量图层*'
- en: The *Filtering features in WFS requests* in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。处理矢量图层")中的*在WFS请求中过滤特征*，*矢量图层*'
- en: The *Listening for vector layer features' event* in [Chapter 4](ch04.html "Chapter 4. Working
    with Events"), *Controls*
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章。处理事件")中的*监听矢量图层特征事件*，*控件*'
- en: Getting information from the WMS server
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从WMS服务器获取信息
- en: Nowadays, the **Web Map Service (WMS)** has an important role in the GIS world,
    mainly because rendering tons of vector data at the client-side, no matter if
    its browser on a desktop consumes many resources.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**Web地图服务（WMS）**在GIS世界中扮演着重要的角色，主要是因为在客户端渲染大量的矢量数据，无论其是在桌面上的浏览器，都会消耗很多资源。
- en: If we think, in the OpenStreetMap project, where we have tons of vector data
    about streets, places, and so on, we can see that the main way to render data
    is in a raster way.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑OpenStreetMap项目，其中我们拥有大量关于街道、地点等的矢量数据，我们可以看到渲染数据的主要方式是栅格方式。
- en: In this scenario, WMS servers allow us to get vector or raster data, from a
    shapefile, from a `.geotiff` file, from a spatial database, and so on, and render
    all together as a single image. Not only that, if properly configured, a WMS server
    allows us to query information of a feature at a given point.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，WMS服务器允许我们从shapefile、从`.geotiff`文件、从空间数据库等获取矢量或栅格数据，并将它们全部渲染成一张单独的图像。不仅如此，如果配置得当，WMS服务器还允许我们查询给定点的特征信息。
- en: With OpenLayers, this can be easily done using the `OpenLayers.Control.WMSGetFeatureInfo`
    control.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenLayers，可以通过`OpenLayers.Control.WMSGetFeatureInfo`控件轻松实现。
- en: In the following screenshot, we can see what our current recipe looks like.
    Given some vector information about USA states, the server returns a raster image.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到我们当前的配方看起来是什么样子。给定一些关于美国各州的矢量信息，服务器返回一个栅格图像。
- en: '![Getting information from the WMS server](img/7843_05_09.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![从WMS服务器获取信息](img/7843_05_09.jpg)'
- en: Once the control is activated, any click event on the map will trigger a request
    to the WMS server to get the feature information.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦激活了控件，地图上的任何点击事件都会触发对WMS服务器的请求以获取特征信息。
- en: How to do it...
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create an HTML file with the OpenLayers library dependencies and add the code
    for the button and the map''s `div` element:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含OpenLayers库依赖项的HTML文件，并添加按钮和地图`div`元素的代码：
- en: '[PRE82]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Set the proxy script, and initialize the map instance:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置代理脚本，并初始化地图实例：
- en: '[PRE83]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, add two WMS layers. The first will act as the base layer while the second
    will be an overlay layer with the USA states:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加两个WMS图层。第一个将作为基础图层，而第二个将是一个带有美国各州的叠加图层：
- en: '[PRE84]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Add the layer switcher control and center the map''s viewport:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加图层切换控件并居中地图的视口：
- en: '[PRE85]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then add the code for the `WMSGetFeatureInfo` control:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加 `WMSGetFeatureInfo` 控件的代码：
- en: '[PRE86]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, add the code to activate/deactivate the control when the button is
    clicked:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加代码以在按钮点击时激活/停用控件：
- en: '[PRE87]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works...
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A WMS server implements different request types. The most important is the `GetMap`
    request, which allows us to get an image given some parameters, such as a bounding
    box, the name of the layers, and so on.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: WMS 服务器实现了不同的请求类型。最重要的是 `GetMap` 请求，它允许我们根据一些参数（如边界框、图层名称等）获取图像。
- en: Note
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'All this explanation is more close to understanding the WMS standard than working
    with OpenLayers. So, invest your time and learn what the WMS standard offers and
    how it works. You can find a very brief description at wikipedia: [http://en.wikipedia.org/wiki/Web_Map_Service](http://en.wikipedia.org/wiki/Web_Map_Service),
    and the whole specification at OGC: [http://www.opengeospatial.org/standards/wms](http://www.opengeospatial.org/standards/wms).'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些解释更接近于理解 WMS 标准，而不是使用 OpenLayers。因此，花时间学习 WMS 标准提供了什么以及它是如何工作的。你可以在维基百科上找到一个非常简短的描述：[http://en.wikipedia.org/wiki/Web_Map_Service](http://en.wikipedia.org/wiki/Web_Map_Service)，以及完整的规范在
    OGC：[http://www.opengeospatial.org/standards/wms](http://www.opengeospatial.org/standards/wms)。
- en: In addition, the WMS server can implement the `GetFeatureInfo` request. This
    type of request allows us to, given a point and some layer names configured at
    the WMS server, retrieve information from a feature, that is, we can get a feature
    attribute from a layer which is rendered as a raster image.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，WMS 服务器可以实现 `GetFeatureInfo` 请求。这种类型的请求允许我们，给定一个点和在 WMS 服务器上配置的一些图层名称，从特征中检索信息，即我们可以从作为栅格图像渲染的图层中获取特征属性。
- en: Let's describe the code of this recipe, which is the goal of this book and not
    to explain how a WMS server works.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述这个菜谱的代码，这是本书的目标，而不是解释 WMS 服务器是如何工作的。
- en: 'Because, the control will make an AJAX request, we need to set a proxy script
    to be used:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，控件将执行 AJAX 请求，我们需要设置一个代理脚本来使用：
- en: '[PRE88]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The WMS layer comes from a public server from the awesome **OpenGeo** project
    ([http://opengeo.org](http://opengeo.org)). The first layer acts as a base layer.
    The second one must be an overlay layer, because we have set the `isBaseLayer`
    property to `false`. In addition, to avoid the layer hiding the base layer, we
    have set the `transparent` property, which is used in the WMS request, to `true:`
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: WMS 图层来自令人惊叹的 **OpenGeo** 项目（[http://opengeo.org](http://opengeo.org)）的公共服务器。第一个图层充当基础图层。第二个图层必须是一个叠加图层，因为我们已将
    `isBaseLayer` 属性设置为 `false`。此外，为了避免图层隐藏基础图层，我们已将用于 WMS 请求的 `transparent` 属性设置为
    `true`：
- en: '[PRE89]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Adding the `WMSGetFeatureInfo` control is easy, we need to set the WMS server
    URL, some desired properties and register some event listeners to make something
    with the returned information:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `WMSGetFeatureInfo` 控件很简单，我们需要设置 WMS 服务器 URL、一些期望的属性，并注册一些事件监听器来处理返回的信息：
- en: '[PRE90]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Because we want to show a popup with the data, we have registered a function
    on the `getfeatureinfo` event, which is triggered when the control obtains the
    server data:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想显示包含数据的弹出窗口，我们在 `getfeatureinfo` 事件上注册了一个函数，该事件在控件获取服务器数据时触发：
- en: '[PRE91]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To query information of a layer in a WMS server, it must be configured as a
    queryable layer. If we request for a layer which is not queryable, then a `nogetfeatureinfo`
    event will be triggered by the control.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询 WMS 服务器中图层的详细信息，它必须配置为可查询图层。如果我们请求一个不可查询的图层，则控件将触发 `nogetfeatureinfo` 事件。
- en: By default, the control requests data for all WMS layers in the map. With the
    `queryVisible` property, we can limit the query to those layers which are currently
    visible and forget those hidden layers.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，控件请求地图中所有 WMS 图层的数据。使用 `queryVisible` 属性，我们可以限制查询仅限于当前可见的图层，并忽略那些隐藏的图层。
- en: There's more...
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `WMSGetFeatureInfo` control has other interesting properties.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`WMSGetFeatureInfo` 控件还有其他有趣的属性。'
- en: With the `hover` property set to `true` we can force the control to query the
    server, not only when the mouse clicks on the map, but also on the mouse hover
    event.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `hover` 属性设置为 `true`，我们可以强制控件在鼠标点击地图时查询服务器，同时也在鼠标悬停事件上查询。
- en: Using the `layers` property, which accepts an array of `OpenLayers.Layer.WMS`
    layers, we can control which layers must be queried on the server. If not specified,
    the layers are obtained from the map.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `layers` 属性，它接受一个 `OpenLayers.Layer.WMS` 图层数组的对象，我们可以控制哪些图层必须在服务器上查询。如果没有指定，图层将从地图中获取。
- en: In addition, if a layer has been configured to work with more than one server,
    only the first one is used for the queries.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果图层被配置为与多个服务器一起工作，则仅使用第一个服务器进行查询。
- en: Also, it is important to note that a WMS server can return the data in different
    formats, for example, a plain text, an HTML response, or also in GML format.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，需要注意的是，WMS服务器可以以不同的格式返回数据，例如，纯文本、HTML响应，或者GML格式。
- en: With the `infoFormat` property, we can indicate to the server the kind of response
    we desire. By default it is HTML.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`infoFormat`属性，我们可以向服务器指示我们期望的响应类型。默认情况下是HTML。
- en: See also
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Getting feature information from data source* recipe
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从数据源获取要素信息* 菜单'
- en: The *Selecting and transforming features* recipe
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择和转换特征* 菜单'
- en: The *Adding WMS layer* recipe
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加WMS图层* 菜单'
