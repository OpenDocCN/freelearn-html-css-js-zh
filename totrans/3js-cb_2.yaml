- en: Chapter 2. Geometries and Meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating an object around its own axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating an object around a point in space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Informing Three.js about updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a large number of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating geometries from height maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointing an object to another object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing text in 3D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering 3D formulas as 3D geometries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Three.js with a custom geometry object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a spline curve between two points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and exporting a model from Blender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OBJMTLLoader with multiple materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying matrix transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js comes with a large number of geometries that you can use out of the
    box. In this chapter, we'll show you some recipes that explain how you can transform
    these standard geometries. Besides that, we'll also show you how to create your
    own custom geometries and load geometries from external sources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can access all of the example code within all recipes in this cookbook from
    the GitHub repository created at [https://github.com/josdirksen/threejs-cookbook](https://github.com/josdirksen/threejs-cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: Rotating an object around its own axis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways in which you can change the appearance of a mesh. For example,
    you can change its position, scale, or material. Often, you'll also need to change
    the rotation of `THREE.Mesh`. In this first recipe on rotation, we'll show you
    the simplest way to rotate an arbitrary mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To rotate a mesh, we first need to create a scene that contains an object you
    can rotate. For this recipe, we provide an example, `02.01-rotate-around-axis.html`,
    that you can open in your browser. When you open this recipe, you''ll see something
    similar to the following screenshot in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this demo, you can see a 3D cube slowly rotating around its axis. Using the
    control GUI in the upper-right corner, you can change the speed at which the object
    rotates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To rotate the cube from this example around its axis like we showed you in
    the previous screenshot, you have to take a couple of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first step in this recipe, we''ll set up the control GUI, as we''ve
    shown in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*,
    in the *Controlling the variables used in the scene* recipe, which you can see
    in the top-right corner. This time, we''ll use the following as the control object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this `control` object, we''ll control the rotation around any of the three
    axes. We pass this control object to the `addControls` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now when we call the `addControls` function, we'll get the nice GUI that you
    saw in the screenshot at the beginning of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we can control the rotation through the GUI, we can use these values
    to directly set the rotation of our object. In this example, we continuously update
    the `rotation` property of the mesh, so you get the nice animation you can see
    in the example. For this, we define the `render` function like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, you can see that we increase the `rotation` property of the
    `THREE.Mesh` object with the value set in the control GUI. This results in the
    animation you can see in the screenshot in the *Getting ready* section. Note that
    the rotation property is of the `THREE.Vector3` type. This means that you can
    also set the property in one statement using `cube.rotation.set(x, y, z)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you set the rotation property on `THREE.Mesh`, as we do in this example,
    Three.js doesn't directly calculate the new positions of the vertices of the geometry.
    If you print out these vertices to the console, you'll see that regardless of
    the `rotation` property, they will stay exactly the same. What happens is that
    when Three.js actually renders `THREE.Mesh` in the `renderer.render` function,
    it is at that exact point that its exact position and rotation is calculated.
    So when you translate, rotate, or scale `THREE.Mesh`, the underlying `THREE.Geometry`
    object stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different ways to rotate an object besides the one we showed here:'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming *Rotating an object around a point in space* recipe, we'll show
    you how you can rotate an object around an arbitrary point in space instead of
    its own axis, as we showed in this recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating an object around a point in space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you rotate an object using its rotate property, the object is rotated around
    its own center. In some scenarios, though, you might want to rotate an object
    around a different object. For instance, when modeling the solar system, you want
    to rotate the moon around the earth. In this recipe, we'll explain how you can
    set up Three.js objects in such a way that you can rotate them around one another
    or any point in space.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we''ve also provided an example you can experiment with. To
    load this example, just open `02.02-rotate-around-point-in-space.html` in a browser.
    When you open this file, you''ll see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the controls on the right-hand side, you can rotate various objects around.
    By changing the **rotationSpeedX**, **rotationSpeedY**, and **rotationSpeedZ**
    properties, you can rotate the red box around the center of the sphere.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To best demonstrate the rotation of an object around another one, you should
    rotate around that object's *y* axis. To do this, change the **rotationSpeedY**
    property.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rotating an object around another object takes a couple of additional steps
    compared to the rotation we showed in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create the central blue sphere you can see in the screenshot.
    This is the object that we''ll rotate the little red box around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So far, there's nothing special in this code snippet. You can see a standard
    `THREE.Sphere` object from which we create `THREE.Mesh` and add it to the scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to define a separate object, which we''ll use as the pivot
    point for our box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `pivotPoint` object is a `THREE.Object3D` object. This is the parent object
    of `THREE.Mesh` and can be added to a scene without a geometry or a material.
    In this recipe, however, we don't add it to the scene but add it to the sphere
    we created in step 1\. So, if the sphere rotates or changes position, this `pivotPoint`
    object will also change its position and rotation since we added it as a child
    to the sphere.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can create the red box, and instead of adding it to the scene, we add
    it to the `pivotPoint` object we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can rotate `pivotPoint` and the cube will follow the rotation of `pivotPoint`.
    For this recipe, we do this by updating the `rotation` property of `pivotPoint`
    in the `render` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create `THREE.Mesh` in Three.js, you normally just add it to `THREE.Scene`
    and position it individually. In this recipe, however, we've made use of the `THREE.Mesh`
    feature, which extends from `THREE.Object3D` itself and can also contain children.
    So when the parent object is rotated, this will also affect the children.
  prefs: []
  type: TYPE_NORMAL
- en: 'A really interesting aspect of using the approach explained in this recipe
    is that we can now do a couple of interesting things:'
  prefs: []
  type: TYPE_NORMAL
- en: We can rotate the box itself by updating the `cube.rotation` property like we
    did in the *Rotating an object around its own axis* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also rotate the box around the sphere by changing the rotation property
    of the sphere, as we added `pivotPoint` as a child of the sphere mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can even combine everything, we can rotate `pivotPoint`, `sphereMesh`, and
    `cube`—all separately—and create very interesting effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ve used the fact that we can add children to meshes as
    a way to rotate an object around another object. However, after reading the following
    recipes, you will learn more about this:'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Rotating an object around its own axis* recipe, we showed you how you
    can rotate an object around its own axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Informing Three.js about updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve worked a bit longer with Three.js, you''ll probably have noticed
    that sometimes, it seems that changes you make to a certain geometry doesn''t
    always result in a change onscreen. This is because for performance reasons, Three.js
    caches some objects (such as the vertices and faces of a geometry) and doesn''t
    automatically detect updates. For these kinds of changes, you''ll have to explicitly
    inform Three.js that something has changed. In this recipe, we''ll show you what
    properties of a geometry are cached and require explicit notification to Three.js
    to be updated. These properties are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`geometry.vertices`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geometry.faces`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geometry.morphTargets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geometry.faceVertexUvs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geometry.faces[i].normal` and `geometry.vertices[i].normal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geometry.faces[i].color` and `geometry.vertices[i].color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geometry.vertices[i].tangent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geometry.lineDistances`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An example is available that allows you to change two properties that require
    an explicit update: face colors and vertex positions. If you open up the `02.04-update-stuff.html`
    example in your browser, you''ll see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the menu in the top-right section, you can change two properties of this
    geometry. With the **changeColors** button, you can set the colors of each individual
    face to a random color, and with **changeVertices**, you change the position of
    each vertex of this cube. To apply these changes, you have to push the **setUpdateColors**
    button or the **setUpdateVertices** button, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of properties where you have to explicitly tell Three.js
    about the update. This recipe will show you how to inform Three.js about all possible
    changes. Depending on the change you''re making, you can jump in at any step of
    the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, if you want to add vertices or change the values of an individual vertex
    of a geometry, you can use the `geometry.vertices` property. Once you've added
    or changed an element, you need to set the `geometry.verticesNeedUpdate` property
    to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following this, you might want the face definition within a geometry to be cached
    as well, which will require you to use the `geometry.faces` property. This means
    that when you add `THREE.Face` or update one of the existing properties, you need
    to set `geometry.elementsNeedUpdate` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might then want to morph targets that can be used to create animations,
    where one set of vertices morph into another set of vertices. This will require
    the `geometry.morphTargets` property. To do this, when you add a new morph target
    or update an existing one, you need to set `geometry.morphTargetsNeedUpdate` to
    `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the next step would be to add `geometry.faceVertexUvs`. With this property,
    you define how textures are mapped onto the geometry. If you add or change elements
    in this array, you need to set the `geometry.uvsNeedUpdate` property to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might also want to change the vertices or faces' normals by changing the
    `geometry.faces[i].normal` and `geometry.vertices[i].normal` properties. When
    you do this, you have to set `geometry.normalsNeedUpdate` to `true` to inform
    Three.js about this. Besides the normal, there is also a `geometry.vertices[i].tangent`
    property. This property is used to calculate shadows and also calculate when textures
    are rendered. If you make manual changes, you have to set `geometry.tangentsNeedUpdate`
    to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you can define individual colors on the vertices or the faces. You do
    this by setting these color properties: `geometry.faces[i].color` and `geometry.vertices[i].color`.
    Once you''ve made changes to these properties, you have to set `geometry.colorsNeedUpdate`
    to `true`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a final step, you can choose to change textures and materials during runtime.
    When you want to change one of these properties of a material, you need to set
    `material.needsUpdate` to `true`: texture, fog, vertex colors, skinning, morphing,
    shadow map, alpha test, uniforms, and lights. If you want to update the data behind
    a texture, you need to set the `texture.needsUpdate` flag to `true`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a summary, steps 1 to 7 apply to geometries and any resulting Three.js objects
    that are based on geometries.
  prefs: []
  type: TYPE_NORMAL
- en: To get the most performance out of your 3D scene, Three.js caches certain properties
    and values that usually don't change. Especially when working with the WebGL renderer,
    a lot of performance is gained by caching all these values. When you set one of
    these flags to true, Three.js knows, very specifically, which part it needs to
    update.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are recipes within this book that are similar to this. If you look at
    the source code for the *Applying matrix transformations* recipe, you can see
    that we've used the `verticesNeedUpdate` property after we applied some matrix
    transformations to the geometry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a large number of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have scenes with large numbers of objects, you will start noticing some
    performance issues. Each of the meshes you create and add to the scene will need
    to be managed by Three.js, which will cause slowdowns when you're working with
    thousands of objects. In this recipe, we'll show you how to merge objects together
    to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are no additional libraries or resources required to merge objects together.
    We've prepared an example that shows you the difference in performance when using
    separate objects compared to a merged object. When you open up the `02.05-handle-large-number-of-object.html`
    example, you can experiment with the different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see that with a merged object approach,
    we still get 60 fps when working with 120,000 objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Merging objects in Three.js is very easy. The following code snippet shows
    you how to merge the objects from the previous example together. The important
    step here is to create a new `THREE.Geometry()` object named `mergedGeometry`
    and then create a large number of `BoxGeometry` objects, as shown in the highlighted
    code sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We merge each `cubeGeometry` object into the `mergedGeometry` object by calling
    the `merge` function. The result is a single geometry that we use to create `THREE.Mesh`,
    which we add to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you call the `merge` function on a geometry (let''s call it `merged`)
    and pass in the geometry to be merged (let''s call this one `toBeMerged`), Three.js
    takes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, Three.js clones all the vertices from the `toBeMerged` geometry and adds
    them to the vertices array of the `merged` geometry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it walks through the faces from the `toBeMerged` geometry and creates
    new faces in the `merged` geometry, copying the original normal and colors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a final step, it copies the `uv` mapping from `toBeMerged` into the `uv`
    mapping of the `merged` geometry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result is a single geometry that, when added to the scene, looks like multiple
    geometries.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main issue with this approach is that it gets harder to color, style, animate,
    and transform the objects that are merged together independently. For Three.js,
    after the merge, it counts as a single object. It is, however, possible to apply
    specific materials to each face. We show you how to do this in the *Using separate
    materials for faces* recipe in [Chapter 4](ch04.html "Chapter 4. Materials and
    Textures"), *Materials and Textures*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating geometries from height maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Three.js, it is easy to create your own geometries. For this recipe, we're
    going to show you how to create your own geometry based on a terrain height map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To convert a height map into a 3D geometry, we first need to have a height
    map. In the source files provided with this book, you can find a height map for
    a portion of the Grand Canyon. The following image shows you what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you''re familiar with the Grand Canyon, you''ll probably recognize the distinct
    shape. The final result we''ll have at the end of this recipe can be viewed by
    opening up the `02.06-create-terrain-from-heightmap.html` file in your browser.
    You''ll see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a heightmap-based geometry, you need to perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the required Three.js code, we first need to load the image
    and set some properties that determine the final size and height of the geometry.
    This can be done by adding the following code snippet and loading the image by
    setting the `img.src` property to the location of our height map. Once the image
    is loaded, the `img.onload` function will be called, where we convert the image
    data to `THREE.Geometry`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the image is loaded in the `onload` function, we need the value of each
    pixel and convert it to `THREE.Vector3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in this code snippet, we process each of the image pixels, and
    based on the pixel value, we create `THREE.Vector3`, which we add to the vertices
    array of our custom geometry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve defined the vertices, the next step is to use these vertices
    to create faces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, each set of four vertices is converted into two `THREE.Face3`
    elements and added to the `faces` array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now all we need to do is to let Three.js calculate the vertex and face normals,
    and we can create `THREE.Mesh` from this geometry and add it to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you render this scene, you might need to play around with the camera position
    and the scale of the final mesh to get the correct size.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Height maps are a way to embed the height information into an image. Each pixel
    value of the image represents the relative height measured at that point. In this
    recipe, we've processed this value, together with its *x* and *y* values, and
    converted it into a vertex. If we do this for each point, we get an exact 3D representation
    of the 2D height map. In this case, it results in a geometry that contains 512
    * 512 vertices.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we create a geometry from scratch, there are a few interesting things
    we can add. We can, for instance, color each individual face. This can be done
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, add the `chroma` library (you can download the source from [https://github.com/gka/chroma.js](https://github.com/gka/chroma.js)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then create a color scale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the face colors based on the height of the face:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, set `vertexColors` of the material to `THREE.FaceColors`. The result
    looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![There''s more…](img/1182OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also apply different kinds of materials to really create a terrain-like
    effect. For more information on this, see [Chapter 4](ch04.html "Chapter 4. Materials
    and Textures"), *Materials and Textures*, on materials.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this sample, we've used a height map to create a geometry. You can also use
    a heightmap as a bump map to add depth detail to a model. We show you how to do
    this in [Chapter 4](ch04.html "Chapter 4. Materials and Textures"), *Materials
    and Textures*, in the *Adding depth to a mesh with bump map* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointing an object to another object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common requirement for many games is that cameras and other objects follow
    each other or be aligned to one another. Three.js has standard support for this
    using the `lookAt` function. In this recipe, you'll learn how you can use the
    `lookAt` function to point an object to look at another object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example for this recipe can be found in the sources for this book. If you
    open `02.07-point-object-to-another.html` in your browser, you see something similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the menu, you can point the large blue rectangle to look at any of the
    other meshes in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating the `lookAt` functionality is actually very simple. When you add `THREE.Mesh`
    to the scene, you can just call its `lookAt` function and point it to the position
    it should turn to. For the example provided for this recipe, this is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So when you push the `lookAtSphere` button, the rectangle's `lookAt` function
    will be called with the sphere's position.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using this code, it is very easy to line up one object with another. With the
    `lookAt` function, Three.js hides the complexity that is needed to accomplish
    this. Internally, Three.js uses matrix calculations to determine the rotation
    it needs to apply to the object to align it correctly with the object you're looking
    at. The required rotations are then set on the object (to the `rotation` property)
    and shown in the next render loop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we showed you how to align one object to another. With Three.js,
    you can use the same approach for other types of objects. You can point the camera
    to center on a specific object using `camera.lookAt(object.position)`, and you
    can also direct a light to point to a specific object using `light.lookAt(object.position)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `lookAt` to follow a moving object. Just add the `lookAt` code
    in the render loop, and the object will follow the moving object around.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lookAt` function uses matrix calculations internally. In the last recipe
    of this chapter, *Applying matrix transformations*, we show you how you can use
    matrix calculations to accomplish other effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing text in 3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cool feature of Three.js is that it allows you to write text in 3D. With a
    couple of simple steps, you can use any text, even with font support, as a 3D
    object in your scene. This recipe shows you how to create 3D text and explains
    the different configuration options available to style the result.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To work with 3D text, we need to include some additional JavaScript in our
    pages. Three.js provides a number of fonts you can use, and they are provided
    as individual JavaScript files. To add all the available fonts, include the following
    scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already done this in the `02.09-write-text-in-3D.html` example. If you
    open this in your browser, you can play around with the various fonts and properties
    available when creating text in Three.js. When you open the specified example
    you will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating 3D text in Three.js is very easy. All you have to do is create `THREE.TextGeometry`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `text` property is the text we want to write, and `params` define how the
    text is rendered. The `params` object can have many different parameters, which
    you can look at in more detail in the *How it works…* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, however, we''ve used the following set of parameters (which
    point to the GUI in the top-right section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This geometry can then be added to the scene like any other geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one thing you need to take into account when working with `THREE.TextGeometry`
    and materials. As you can see from the code snippet, we add two material objects
    instead of one. The first material is applied to the front of rendered text, and
    the second one is applied to the side of the rendered text. If you just pass in
    one material, it is applied to both the front and the side.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, there is a variety of different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `height` | The height property defines the depth of the text, in other words,
    how far the text is extruded to make it 3D. |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | With this property, you set the size of the final text. |'
  prefs: []
  type: TYPE_TB
- en: '| `curveSegments` | If a character has curves (for example, the letter *a*),
    this property defines how smooth the curves will be. |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelEnabled` | A bevel provides a smooth transition from the front of the
    text to the side. If you set this value to true, a bevel will be added to the
    rendered text. |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelThickness` | If you''ve set `bevelEnabled` to `true`, it defines how
    deep the bevel is. |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelSize` | If you''ve set `bevelEnabled` to `true`, it defines how high
    the bevel is. |'
  prefs: []
  type: TYPE_TB
- en: '| `weight` | This is the weight of the font (normal or bold). |'
  prefs: []
  type: TYPE_TB
- en: '| `font` | This is the name of the font to be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `material` | When an array of materials is provided, this should contain
    the index of the material to be used for the front. |'
  prefs: []
  type: TYPE_TB
- en: '| `extrudeMaterial` | When an array of materials is provided, this should contain
    the index of the materials to be used for the side. |'
  prefs: []
  type: TYPE_TB
- en: When you create `THREE.TextGeometry`, Three.js internally uses `THREE.ExtrudeGeometry`
    to create the 3D shapes. `THREE.ExtrudeGeometry` works by taking a 2D shape and
    extrudes it along the *Z* axis to make it 3D. To create a 2D shape from a text
    string, Three.js uses the JavaScript files that we included in the *Getting ready*
    section of this recipe. These JavaScript files, based on [http://typeface.neocracy.org/fonts.html](http://typeface.neocracy.org/fonts.html),
    allow you to render text as 2D paths, which we then can convert to 3D.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to use a different font, you can convert your own fonts at [http://typeface.neocracy.org/fonts.html](http://typeface.neocracy.org/fonts.html).
    All you need to do to use these fonts is include them on your page and pass in
    the correct `name` and `style` values as parameters to `THREE.TextGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering 3D formulas as 3D geometries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js offers many different ways to create geometries. You can use the standard
    Three.js objects, such as `THREE.BoxGeometry` and `THREE.SphereGeometry`, create
    geometries completely from scratch, or just load models created by external 3D
    modeling programs. In this recipe, we will show you another way to create geometries.
    This recipe shows you how to create geometries based on math formulas.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll be using the `THREE.ParametricGeometry` object. As this
    is available from the standard Three.js distribution, there is no need to include
    additional JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the end result of this recipe, you can look at `02.10-create-parametric-geometries.html`,
    you''ll see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This figure shows you a *Gray's Kleinbottle*, which is rendered based on a couple
    of simple math formulas.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generating geometries using math formulas with Three.js is very easy and only
    takes two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create the function that will create the geometry
    for us. This function will take two arguments: `u` and `v`. When Three.js uses
    this function to generate a geometry, it will call this function with `u` and
    `v` values, starting at `0` and ending at `1`. For each of these `u` and `v` combinations,
    this function should return a `THREE.Vector3` object, which represents a single
    vertex in the final geometry. The function that creates the figure you saw in
    the previous section is shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can provide functions of your own as long as you return a new `THREE.Vector3`
    object for each value of `u` and `v`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got the function that creates our geometry, we can use this
    function to create `THREE.ParametricGeometry`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can clearly see that three arguments have been applied to the constructor
    of `THREE.ParametricObject`. This is discussed in more detail in the *How it works…*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: All you have to do after creating the geometry is create `THREE.Mesh` and add
    it to the scene just like any other Three.js object.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From step 2 in the preceding code snippet, you can see that we provide three
    arguments to the constructor of `THREE.ParametricObject`. The first one is the
    function we showed you in step 1, the second determines in how many steps we divide
    the `u` parameter, and the third one determines in how many steps we divide the
    `v` parameter. The higher the number, the more vertices will be created, and the
    smoother the final geometry will look. Note, though, that a very high amount of
    vertices has an adverse effect on performance.
  prefs: []
  type: TYPE_NORMAL
- en: When you create `THREE.ParametricGeometry`, Three.js will call the provided
    function a number of times. The amount of times the function is called is based
    on the second and third parameters. This results in a set of `THREE.Vector3` objects,
    which are then automatically combined into faces. This results in a geometry that
    you can use just like any other geometry.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many different things you can do with these kinds of geometries than
    what is shown in this recipe. In the `02.10-create-parametric-geometries.html`
    source file, you can find a couple of other functions that create interesting-looking
    geometries such as the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/1182OS_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extending Three.js with a custom geometry object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipes you've seen so far, we create Three.js objects from scratch.
    We either build a new geometry from scratch with vertices and faces, or we reuse
    an existing one and configure it for our purpose. While this is good enough for
    most scenarios, it isn't the best solution when you need to maintain a large code
    base with lots of different geometries. In Three.js, you create geometries by
    just instantiating a `THREE.GeometryName` object. In this recipe, we'll show you
    how you can create a custom geometry object and instantiate it just like the other
    Three.js objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example that you can use to experiment with this recipe can be found in
    the provided sources. Open up `02.11-extend-threejs-with-custom-geometry.html`
    in your browser to see the final result, which will be similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, you see a single rotating cube. This cube is created as
    a custom geometry and can be instantiated by using new `THREE.FixedBoxGeometry()`.
    In the upcoming section, we'll explain how to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extending Three.js with a custom geometry is fairly easy and only takes a couple
    of simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a new JavaScript object that contains
    the logic and properties of our new Three.js geometry. For this recipe, we''ll
    create `FixedBoxGeometry`, which acts exactly like `THREE.BoxGeometry` but uses
    the same values for its height, width, and depth. For this recipe, we create this
    new object in the `setupCustomObject` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, we define a new JavaScript object using `THREE.FixedBoxGeometry
    = function ( width, segments) {..}`. In this function, we first call the constructor
    of the parent object (`THREE.Geometry.call( this )`). This makes sure that all
    properties are correctly initialized. Next, we wrap an existing `THREE.BoxGeometry`
    object and use information from that object to set `vertices`, `faces`, and `faceVertexUvs`
    for our own custom object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we need to tell JavaScript that our `THREE.BoxGeometry` object extends
    from `THREE.Geometry`. This is done by setting a prototype property of `THREE.FixedBoxGeometry`
    to `Object.create(THREE.Geometry.prototype)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After `setupCustomObject()` is called, we can now use the same approach to
    create this object like we do for the other Three.js-provided geometries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we've created a custom Three.js geometry that you can instantiate
    just like the standard geometries provided by Three.js.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we use one of the standard ways JavaScript provides to create
    objects that inherit from other objects. We defined the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code fragment tells JavaScript that `THREE.FixedBoxGeometry` is created,
    it inherits all the properties and functions from `THREE.Geometry`, which has
    its own constructor. This is the reason we also add the following call to our
    new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This calls the constructor of the `THREE.Geometry` object whenever our own custom
    object is created.
  prefs: []
  type: TYPE_NORMAL
- en: There is more to prototype-based inheritance than what's explained in this short
    recipe. If you want to know more about prototype-based inheritance, the Mozilla
    guys have a great explanation on how inheritance using the prototype property
    works at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we've wrapped an existing Three.js object to create our custom
    object. You can also apply this same approach for objects that are created completely
    from scratch. For instance, you can create `THREE.TerrainGeometry` from the JavaScript
    code we used in the *Creating geometries from heightmaps* recipe to create a 3D
    terrain.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a spline curve between two points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create visualizations and, for instance, want to visualize the flight
    path of an airplane, drawing a curve between the start and end point is a good
    approach. In this recipe, we'll show you how you can do this using the standard
    `THREE.TubeGeometry` object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you open the example for this recipe, `02.12-create-spline-curve.html`,
    you can see a tube geometry that curves from start to end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the upcoming section, we'll explain step by step how to create this curve.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a curved spline, like what is shown in the preceding example, we
    need to take a couple of simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is define some constants for this curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `numPoints` object defines how many vertices we'll use to define the curve
    and the number of segments we use when rendering the tube. The `start` vector
    defines the position where we want to start the curve, the `end` vector determines
    the end point of our curve, and finally, the `middle` vector defines the height
    and center point of our curve. If we, for instance, set `numPoints` to `5`, we
    get a different kind of curve.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1182OS_02_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now that we''ve got the `start`, `end`, and `middle` vectors, we can use them
    to create a nice curve. For this, we can use an object provided by Three.js, called
    `THREE.QuadraticBezierCurve3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Based on this `curveQuad`, we can now create a simple tube geometry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a tube, we use `THREE.TubeGeometry` and pass in `curveQuad`, which
    we created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `QuadraticBezierCurve3` object we created in this recipe has a number of
    different functions (`getTangentAt` and `getPointAt`) that determine the location
    somewhere along the path. These functions return information based on the `start`,
    `middle`, and `end` vectors passed in to the constructor. When we pass `QuadraticBezierCurve3`
    into `THREE.TubeGeometry`, `THREE.TubeGeometry` uses the `getTangentAt` function
    to determine where to position its vertices.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used `THREE.QuadraticBezierCurve3` to create our spline.
    Three.js also provides a `THREE.CubicBezierCurve3` and `THREE.SplineCurve3` curve,
    which you can use to define these kinds of splines. You can find more information
    on the differences between a quadratic Bezier curve and a cubic Bezier curve at
    [http://stackoverflow.com/questions/18814022/what-is-the-difference-between-cubic-bezier-and-quadratic-bezier-and-their-use-c](http://stackoverflow.com/questions/18814022/what-is-the-difference-between-cubic-bezier-and-quadratic-bezier-and-their-use-c).
  prefs: []
  type: TYPE_NORMAL
- en: Creating and exporting a model from Blender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blender, which you can download from [http://www.blender.org/download/](http://www.blender.org/download/),
    is a great tool to create 3D models and has excellent support for Three.js. With
    the right plugin, Blender can export models directly into Three.js' own JSON format,
    which can then easily be added to your scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can use the JSON exporter in Blender, we first need to install the
    plugin in Blender. To install the plugin, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to do is get the latest version of the plugin. We've
    added this to the source code of this book. You can find this plugin in the `assets/plugin`
    folder. In that directory, you'll find a single directory with the `io_mesh_threejs`
    name. To install the plugin, just copy this complete directory to the plugin location
    of Blender. As Blender is multiplatform, depending on your OS, this plugin directory
    might be stored in a different location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Windows, copy the `io_mesh_threejs` directory to `C:\Users\USERNAME\AppData\Roaming\Blender
    Foundation\Blender\2.70a\scripts\addons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For OS X users, it depends on where you installed Blender (extracted the ZIP
    file). You should copy the `io_mesh_threejs` directory to `/location/of/extracted/zip/blender.app/Contents/MacOS/2.6X/scripts/addons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, for Linux users, copy the `io_mesh_threejs` directory to `/home/USERNAME/.config/blender/2.70a/scripts/addons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you've installed Blender through apt-get, you should copy the `io_mesh_threejs`
    directory to `/usr/lib/blender/scripts/addons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to enable the Three.js plugin. If Blender is already running,
    restart it and open **User Preferences**. You can find this by navigating to **File**
    | **User Preferences**. In the screen that opens, select the **Addons** tab, which
    lists all the plugins that are available.![Getting ready](img/1182OS_02_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the Three.js plugin is enabled. To make sure it stays enabled
    when you restart Blender, click on the **Save User Settings** button. Now, close
    this window and if you navigate to **File** | **Export**, you should see a Three.js
    export function as shown in the following screenshot:![Getting ready](img/1182OS_02_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's look at the rest of this recipe and see how we can export a model
    from Blender and load it in Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To export a model from Blender, we first have to create one. Instead of loading
    an existing one, in this recipe, we''ll create one from scratch, export it, and
    load it in Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: To start off, when you open Blender, you'll see a cube. First, we delete this
    cube. You do this by pressing *x* and clicking on delete in the pop up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we'll create a simple geometry that we can export with the Three.js plugin
    we installed. For this, click on **Add** in the bottom menu and select **Monkey**,
    as shown in the following screenshot:![How to do it...](img/1182OS_02_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you should have an empty scene in Blender with monkey geometry in the
    middle:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1182OS_02_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can export this monkey to Three.js using the plugin we installed in the *Getting
    ready* section of this recipe. To do this, navigate to **Export** | **Three.js**
    in the **File** menu. This opens up the export dialog where you can determine
    the directory to export the model to. In this **Export** dialog, you can also
    set some additional Three.js-specific export properties, but the default properties
    usually are okay. For this recipe, we exported the model as `monkey.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we''ve exported the model and can now load it with Three.js.
    To load the model, we only have to add the following JavaScript to the *Getting
    started with the WebGL renderer* recipe we showed in [Chapter 1](ch01.html "Chapter 1. Getting
    Started"), *Getting Started*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is a rotating monkey, which we created in Blender, rendered by Three.js
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1182OS_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few recipes that you will benefit from reading:'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Using OBJMTLLoader with multiple materials* recipe, we use a different
    format, which we load into Three.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Animation and Physics"), *Animation and
    Physics*, where we look at animations, we'll revisit the Three.js exporter plugin
    when we're working with skeleton-based animations in the *Animating with skeletons*
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OBJMTLLoader with multiple materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three.js provides a number of standard geometries that you can use to create
    your 3D scenes. Complex models, however, are more easily created in dedicated
    3D modeling applications such as Blender or 3ds Max. Luckily, though, Three.js
    has great support for a large number of export formats, so you can easily load
    models created in these kinds of packages. A standard that is widely supported
    is the `OBJ` format. With this format, the model is described with two different
    files: an `.obj` file that defines the geometries and an `.mtl` file that defines
    the material. In this recipe, we''ll show you the steps you need to take to successfully
    load a model using `OBJMTLLoader`, which is provided by Three.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To load models described in the `.obj` and `.mtl` format, we need to first
    include the correct JavaScript file, as these JavaScript objects aren''t included
    in the standard Three.js JavaScript file. So, within the head section, you need
    to add the following script tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The model we use in this example is a Lego mini figure. In Blender, the original
    model looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the final model by opening up `02.14-use-objmtlloader-with-multiple-materials.html`
    in your browser. The following screenshot shows you what the renderer model looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's walk you through the steps you need to take to load such a model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we load the model in Three.js, we first need to check whether the correct
    paths are defined in the `.mtl` file. So, the first thing we need to do is open
    the `.mtl` file in a text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open the `.mtl` file for this example, you''ll see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `.mtl` file defines two materials: one for the body of the mini figure
    and one for its cap. What we need to check is the `map_Kd` property. This property
    needs to contain the relative path, from where the `.obj` file is loaded to where
    Three.js can find the textures. In our example, this path is: `.../textures/Mini-tex.png`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve made sure the `.mtl` file contains the correct references,
    we can load the model using `THREE.OBJMTLLoader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we pass both `.obj` and `.mtl` files into the `load` function.
    The final argument of this `load` function is a `callback` function. This `callback`
    function will be called when the model is done loading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, you can do everything you want with the loaded model. In this
    example, we add the scaling and rotation functionality through the menu in the
    top-right section and apply these properties to the `render` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.obj` and `.mtl` file formats are well-documented formats. `OBJMTLLoader`
    parses the information from these two files and creates geometries and materials
    based on that information. It uses the `.obj` file to determine an object's geometry
    and uses information from the `.mtl` file to determine the material, which is
    `THREE.MeshLambertMaterial` in this case, to be used for each geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js then combines these together into `THREE.Mesh` objects and returns
    a single `THREE.Object3D` object that contains all the parts of the `Lego` figure,
    which you can then add to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we showed you how to load objects defined in the `.obj` and
    `.mtl` format. Besides this format, Three.js also supports a wide range of other
    formats. For a good overview of the file formats supported by Three.js, refer
    to this directory on Three.js'' GitHub repository: [https://github.com/mrdoob/three.js/tree/master/examples/js/loaders](https://github.com/mrdoob/three.js/tree/master/examples/js/loaders).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we assume we have a complete model in the correct format. If
    you want to create a model from scratch, a good open source 3D modeling tool is
    Blender. The the *Creating and Exporting a model from a Blender* recipe, explains
    how to create a new model in Blender and export it so that Three.js can load it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying matrix transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first couple of recipes in this chapter, we used the `rotation` property
    and applied translations to get the desired rotational effect. Behind the scenes,
    Three.js uses matrix transformations to modify the shape and position of the mesh
    or the geometry. Three.js also provides the functionality to apply custom matrix
    transformations directly to a geometry or a mesh. In this recipe, we'll show you
    how you can apply your own custom matrix transformations directly to a Three.js
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To view this recipe in action and experiment with the various transformations,
    open the `02.15-apply-matrix-transformations.html` example in your browser. You''ll
    be presented with the following simple Three.js scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this scene, you can use the menu on the right-hand side to apply various
    transformations directly to the spinning cube. In the next section, we'll show
    you the steps you need to take to create this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating your own matrix transformation is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s look at the code that gets called when you click on the **doTranslation**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in the code, creating a custom matrix transformation is very
    easy and requires only the following steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, you instantiate a new `THREE.Matrix4` object and pass in the values of
    the matrix as arguments to the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you use the `applyMatrix` function of either `THREE.Mesh` or `THREE.Geometry`
    to apply the transformation to that specific object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you apply this on `THREE.Geometry` you have to set the `verticesNeedUpdate`
    property to `true`, as vertex changes aren't automatically propagated to the renderer
    (see the *Informing Three.js about updates* recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The transformations used in this recipe are based on matrix calculations. Matrix
    calculations by themselves are a rather complex subject. If you're interested
    in more information on how matrix calculations work and how they can be used for
    all different kinds of transformations, a good explanation can be found at [http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices](http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the example for this chapter, you can apply a couple of transformations
    to the rotating cube. The following code snippet shows you the matrices used for
    these transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we created the matrix transformations from scratch. Three.js,
    however, also provides some helper functions in the `Three.Matrix4` class that
    you can use to more easily create these kinds of matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '`makeTranslation(x, y, z)`: This function returns a matrix, which when applied
    to a geometry or a mesh, translates the object by the specified x, y, and z values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`makeRotationX(theta)`: This returns a matrix that can be used to rotate a
    mesh or geometry by a certain amount of radians along the *x* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`makeRotationY(theta)`: This is the same as the previous one—this time around
    the *y* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`makeRotationZ(theta)`: This is the same as the previous one—this time around
    the *z* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`makeRotationAxis(axis, angle)`: This returns a rotation matrix based on the
    provided axis and angle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`makeScale(x, y, z)`: This function returns a matrix that can be used to scale
    an object along any of the three axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve also used matrix transformations in other recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first two recipes, *Rotating an object around its own axis* and *Rotating
    an object around a point in space*, the actual rotation is applied using a matrix
    transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Rotating an object around its own axis* recipe, we used the helper functions
    from the `THREE.Matrix4` object to rotate an object around its axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
