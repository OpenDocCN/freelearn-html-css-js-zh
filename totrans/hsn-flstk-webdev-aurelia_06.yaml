- en: Storing Our Data in MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the applications that you use on a daily basis store their information in
    databases. Databases allow you to provide the best experience to your users. Just
    imagine how hard it might be for your users without a database. For example, imagine
    you have bought a new iPhone and need to have all your contacts from your Instagram
    account added to your new phone. If databases did not exist, you would need to
    copy all of your contact information and add it locally to your new device. This
    may sound ridiculous, but this is how a world without databases might be.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to learn how to create applications that are able to connect
    and store information into a database. So, now you will learn how to use MongoDB
    as your NoSQL database and how to integrate our backend with it using one of the
    most popular libraries called Mongoose.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongooseJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating our API with MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Big companies around the globe are using NoSQL Databases to provide the velocity
    that the users expect when using their applications; companies such as Facebook,
    Amazon, and Google all use them. However, why are these databases so special?
    To answer this question, let''s see what is the difference between SQL and NoSQL
    databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SQL databases** | **NoSQL databases** |'
  prefs: []
  type: TYPE_TB
- en: '| Table-based and hard structured | Not table-based |'
  prefs: []
  type: TYPE_TB
- en: '| Encourage normalization | Encourage denormalization |'
  prefs: []
  type: TYPE_TB
- en: '| Require a schema | Are schema-less |'
  prefs: []
  type: TYPE_TB
- en: '| Fast | Superfast |'
  prefs: []
  type: TYPE_TB
- en: '| Scalability is difficult to achieve | Scalability is extremely easy to achieve
    |'
  prefs: []
  type: TYPE_TB
- en: Of course, there are more differences and benefits, but talking about all the
    advantages and the science behind them is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that there are different types of NoSQL databases to
    solve different types of challenges. Let's learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: Document databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is one of the most popular databases, thanks to MongoDB and CouchDB. This
    type of database stores the information in a JSON-based document. As this is a
    key-value store, you can save complex objects that contain arrays, nested documents,
    and other different data types. For example, you can save the following *person*
    in the JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you don't need to store the addresses in a different document
    (or a table in SQL databases); you can perfectly store them in the same document
    (or a table in SQL databases).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated on its official website, MongoDB is an open source document database
    with the scalability and flexibility that you want and the querying and indexing
    that you need.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB uses collections to persist a set of JSON documents, and the schema
    for the documents can change over time without affecting the other documents stored
    in the collection. The schema-less feature is great when you are working on applications
    that have different kind of roles and users. A user might utilize some fields,
    while other users might require some other fields but without the need to fill
    the unused fields with null values. Instead, fields that are not required are
    not persisted in the JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can learn how to install MongoDB on its official site at [https://www.mongodb.com](https://www.mongodb.com).
    We strongly recommend you to use Docker for your development environment instead
    of installing MongoDB on your local machine. So, let's see how you can install
    MongoDB using Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need to download Docker from its official site, [https://www.docker.com](https://www.docker.com).
    Once the download is completed, go ahead and install it. If you are working on
    MacOS or Windows, Docker will also install another tool called **Kitematic**.
    When the installation is done, look for mongo in the Containers section. Then,
    hit CREATE. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c999c7a-6285-41ed-866a-d4a4a7b593cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The tool will download the image and once it is done, it will run the MongoDB
    container and provide us the host and port where MongoDB is running, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3aa4e49-68c3-415c-bdf9-f67934799bc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For users who are using Linux, execute the following command to create a MongoDB
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will start a new container and exposes its internal port
    `27017` and will share a directory called `data` from your host to the container.
    By doing this, we can persist the container information into our host file system.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our MongoDB database running on top of Docker, we need to practice
    a little bit with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we integrate our API with MongoDB, it is important to learn how to interact
    with MongoDB directly. So, let's learn how to perform the basic CRUD operations
    using the MongoDB command-line tool. To do this, we will need to access the MongoDB
    container Terminal, but it is extremely easy using Kitematic. In the container's
    toolbar, click on the exec options. This will launch a Terminal window connected
    to the MongoDB container Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it is launched, type `mongo` to get into the MongoDB CLI. Take a look
    at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a79c1485-e01e-4ef5-a775-46e001de3ee1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For users who are using Linux. You can get into the container by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Cool! Now we are ready to play with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To insert a document, first we specify the `collection` name and pass the JSON
    document by calling the `insert` method as the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s insert the first team to our `teams` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The three dots at the beginning of the lines refer to new lines or the *Enter*
    key.
  prefs: []
  type: TYPE_NORMAL
- en: If the insertion was executed correctly, you should receive the `writeResult`
    response that contains the number of documents inserted into its `nInserted` property.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To retrieve the list of documents, we use the `find` method. For example, run
    the following query to retrieve the full list of teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a new `_id` property has been added automatically. This property
    is known as the primary key of the JSON document. This is an autogenerated value,
    so you will have a different value when you run the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The teams'' collection over time will have more than just a single team. So,
    how could we retrieve a single team from the collection? Do you remember the `{}`
    JSON object we passed to the `find` method? This JSON object is used to query
    the collection. So, if we want to retrieve the `Peru` team, we have to execute
    the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can pass any field used in the JSON document. For example, you
    can use `name`, `ranking`, `captain`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Updating documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update a document, we use the `updateOne` or `updateMany` methods. For example,
    let''s update the `ranking` property of the `Peru` team. Execute the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax looks a little weird, but it is not. The first question you might
    have is why do we need `$set`? We need `$set` to specify the fields that we are
    interested to update. Otherwise, you will replace the document. Consider this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s list our teams'' collection to see the first update reflected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, yes, the `ranking` field has been updated to `1`. Now let''s try to update
    this document without the `$set` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that an error is thrown and no changes have been made. That is helpful
    for us because we are using the `updateOne` method, but there is another method
    called `update`, which will give us headaches if we don''t use it properly. For
    example, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, when you note that you forgot the `$set` operator, you have
    lost your team''s data. Try to find the `Peru` team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: No results are shown. Now a tear might be rolling down your cheek. Funny, right?
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when you are updating or deleting documents. A production error of
    this type can cost you the post.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, to delete a document, we use the `deleteOne` or `deleteMany` methods.
    For example, again insert the `Peru` team and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Cool! Now we are in a good shape to learn about Mongoose and how to integrate
    our API with MongoDB. Keep reading!!
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you use a GUI tool to explore your MongoDB data. We use **Robo
    3T** or Robomongo. You can download it from its official page at [https://robomongo.org](https://robomongo.org).
  prefs: []
  type: TYPE_NORMAL
- en: MongooseJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mongoose.js is one of the most popular NPM modules to integrate a Node.js application
    with a MongoDB database. It provides an easy way to model our application data
    and comes along with different built-in features to validate, cast, and query
    our database, avoiding boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use our MongoDB container that we installed in the previous section.
    The two pieces of information that we need are the host and port where MongoDB
    is running. That information is shown in the Kitematic tool in the `Home/IP &
    Ports/Access URL` section. For example, in my case, these are `localhost` and
    `32768`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edf8840c-9f0a-4ac1-974c-77ed971705ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install Mongoose, we will use NPM. So, in your Terminal, navigate to the
    `wc-backend` project and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation is done, we need to get into the `src` folder and create
    a new folder called `config`*.* In the `config` folder, now create a new file
    called `mongoose-connection.js`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have Mongoose installed and we have created our configuration file,
    it is time to write some code to establish the connection to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is where the best part starts. So, we will need to create a connection
    to the *database*; to do this, open the `mongoose-connection.js` file and apply
    the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the Mongoose module and host it into the `mongoose` constant.
    Then, we call the `connect` function and pass the connection URL using the *host*
    and *port* that points to our MongoDB docker container. Lastly, we tell mongoose
    that our database name will be `wcDb`. If the connection was successful, the `connected`
    event will be called and the `connection is ready` message should be printed.
    Let''s test things out; execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Cool! Our Node.js module is able to establish a successful connection with MongoDB
    using Mongoose. Now we will need to define schemas, models, and collections. Keep
    reading!
  prefs: []
  type: TYPE_NORMAL
- en: Defining schemas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To store information in our database we need to create a model, this model
    is created based on a initial schema definition. This schema definition contains
    the attributes and datatypes of the information we want to store. Let''s define
    the schema for our collections of teams. In the same `mongoose-connection.js`
    file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, defining schemas is straightforward. We use the `mongoose.Schema`
    object and define the fields we want for our schema as a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in other database engines, the fields should be defined with a data type.
    The following are all valid types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Buffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mixed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps, you are familiar will almost all the data types listed. The `Mixed`
    data type basically allows you to define a field whose value can be of any data
    type. Personally, we don't recommend the use of this data type because maintaining
    a `Mixed` field can become hard, and you may want to write boilerplate code to
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mongoose comes with several built-in validators. Some validators are present
    in all data types and some are exclusive for a data type. For example, a `String`
    field will have the `min` and `max` validators but a `Boolean` type will not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some validations to our `Team` schema. Open the `mongoose-connection.js`
    file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, our schema looks more professional and will help us validate the data before
    it is persisted in MongoDB. Most of the validators are self-explanatory. As you
    might have noticed, when you want to apply validators, the syntax to declare a
    field changes a little bit; in this case, a JavaScript object should be passed
    to define the data type and validators. To find more information about validators,
    visit [http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our schema, it is time to tell Mongoose that we want to use
    that Schema to create new objects in order to send them to MongoDB. To do this,
    we need to create a model by passing the schema already defined. Open the `mongoose-connection.js`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Believe it or not, we just need this line to interface our schema to MongoDB.
    In this line, we tell Mongoose that we want to call our collection as `team`.
    The result of calling `mongoose.model` will be an object that is the model; we
    will use this object to create new instances. The `Team` object also contains
    built-in CRUD methods, so we will use them to create CRUD operations to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test things out, let''s create the `Peru` team and save it in our database.
    In the same file, add the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create the `peruTeam` object using the `Team` model instance we created
    earlier. Each new instance contains built-in functions. The `save` built-in function
    is called to save the `peruTeam` in the database. A callback is defined to process
    the result of the operation. If everything goes right, a message showing the new
    generated ID will be shown. So, execute the following command to test things out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Cool! Now we are ready to start the integration between our database module
    and our RESTful API. Keep reading!!
  prefs: []
  type: TYPE_NORMAL
- en: Integrating our API with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we are! It''s time to implement our Teams Rest controller. To do this,
    we will start decoupling the Team model that has all the logic to communicate
    with the MongoDB database. Once the Team model is refactored, we will start implementing
    the code in the Team Rest Controller to implement the CRUD operations to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: List all the teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the existing teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get our hands dirty!
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling the Team Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created a `models` folder in the root project directory. In this folder,
    we will create all the models for our application. Start creating the `team.js`
    file in the `src`/`models` folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we use the `touch` command to create a new file. Then, open this
    file, and from the `src/config/mongoose-connection.js` file, cut the following
    lines and copy them into the `src/models/team.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to isolate the `TeamSchema` definition, and we are exporting the
    model created by mongoose to be accessed later by the Rest Controller. Be sure
    that your `src/config/mongoose-connection` file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Cool! So far, so good. Now it is time to implement our Rest Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Rest Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Isolating the business logic is always a good practice; for that reason, we
    won't be calling the model directly from the Rest Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by calling the `mongoose-connection` module to open a connection
    to MongoDB. Open the `server.js` file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That's all we need to establish a new connection. The `mongoose-connection`
    file contains the logic to open a connection to MongoDB, so we don't need to type
    more code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new team, we need to call the model''s built-in methods provided
    by Mongoose. The `save` function is used to create and update the fields for any
    model. So, first we will start importing the `Team` model into the `src/routes/teams-api.js`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have imported the module with the `require` function and stored
    it into the `Team` constant, we can use it to create a new team. Let''s modify
    the `POST HTTP` method of the Rest Controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first change to note is the `next` param into the function. This param is
    used to throw an error to express in case Mongoose is not able to create a new
    team. Then, we create a new team, passing the `body` param from the `req` object
    and calling the `save` function. The `save` function returns a `Promise` that
    is just an asynchronous call, which, when finished successfully, will return the
    information of the new team saved into the `then` method. Once we have the data,
    we send the information as a `JSON` type to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test things out. First, we need to get the server up by executing `node
    server.js` and then we will use cURL to test this endpoint. Open your Terminal
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went right, you should see the JSON object responding with the
    autogenerated `_id` attribute. Let''s see what happens if we run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we receive an ugly error that says we are falling in a duplication key
    error. Why is this happening? Let''s get answers from the model schema that we
    defined earlier. Open the `src/models/team.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Hot dog! You have the answer. The error we are facing, is because we defined
    the `name` property as `unique:true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to fix something in the message. We expect a JSON response from
    the REST API, so let''s configure a global exception handler in our backend to
    send the error as a JSON object instead of an ugly and incomprehensible HTML page.
    Open the `server.js` file and apply the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a global middleware, which is a function that expects four params:'
  prefs: []
  type: TYPE_NORMAL
- en: '`err`: Contains null if no error is thrown; otherwise, it''s an instance of
    error or another value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req`: The source request sent by the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res`: The response property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: The reference to the next action that Express.js will call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As is expected, all the errors return an HTTP status different than `200`.
    Until we define the correct status of the other CRUD operations, let''s leave
    it with `status(500)` by default. Now, let''s run it again and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we receive a JSON object with a single `error` attribute. Cool!
    Let's continue and learn how to retrieve the full list of teams.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To retrieve the full list of teams, we will make use of the GET HTTP method.
    Let''s start by cleaning up our code a little bit. Until now, we have been using
    an array of teams; we won''t need it anymore, so let''s remove it. In `src/routes/teams-api.js`,
    apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our code cleaned, add the following change to implement the
    logic to retrieve the full list of teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we call the `find` method to return a `Promise` as the `save` function
    used to create new teams. As it is a `Promise`, we will receive the data returned
    from the database into the **`then`** function and if something goes wrong, it
    will return an error in the `catch` function. Let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! Now we are able to retrieve the list of teams using the `api` we just
    implemented. Let's continue!
  prefs: []
  type: TYPE_NORMAL
- en: Finding a single team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find a single team, we will make use of the `findById` built-in method,
    and we will pass a valid ID to it. So, apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we extract the ID from the `req.params` object. Note that we are not
    using the `/teams` route. Instead, we are using the `/teams/:id` route. It means
    that Express.js will inject the `id` attribute as an element of the `params` object.
    Then, we call the `findById` method and send the response to the client. Let''s
    test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Cool! It is working. Note that we are using an existing ID—`5a662fbf728726072c6298fc`.
    This value will be different for you. To get a valid value, just call the `/teams`
    endpoint to list all your teams, and copy and replace it with the value in the
    `_id` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what would happen if we pass an invalid ID? Let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A `null` value is retrieved now. According to our API Documentation, we have
    to return the `HTTP 404` status to represent a Not found response. So, to do this,
    we need to validate the result from the `findById` method and raise an error if
    we receive a null as a response. Go ahead and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now with this implementation, if we receive a `null`, we will raise an error
    that will be handled by our global error handler, which will send a JSON object
    with the error message. Let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to modify our error handler to change the HTTP status code
    to `404`. In the `server.js` file, apply the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we declare the `STATUS` variable and assign `500` as its default value.
    Then, we apply a regular expression validation to check whether the message contains
    the `not found` string. If so, `STATUS` is changed to `404`. So, let''s test it
    again, adding the `-v` flag in the `curl` command to see the HTTP status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now with this, we are ready to learn how to update a `team`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update our `teams`, first we will need to look for an existing team in our
    database using the `ID` provided in the path. If a team is found, we apply the
    changes to the `team` object. So, let''s start adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: First, we extract the `id` passed in the endpoint. Then, we call the `findById`
    method to look for an existing team. If a valid team is found, we will have a
    `team` object as a parameter. Otherwise, an error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are more lines of code to add to our logic. Now it''s
    time to extract the values from the `req.body` object and modify the `team` found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We have created a `teamBody` variable to host the `req.body` data. Then, we
    change the values into the `team` object. We are using the `||` operator; this
    operator will assign `teamBody.code` if this value is sent in the body object.
    Otherwise, it will assign the same value to the `team` object. With this, we are
    able to change the values only if they are sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to save it to the database, we will call the save method as we did when
    we coded the logic to create a new `Team`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! Now we have implemented the logic to update our `Team` entities. Let''s
    test things out. Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Now we are able to update `Team` entities. However, have you noticed
    that our code is a little difficult to organize? We are using multiple `Promise`
    entities to find and save a product. What will happen if we need to perform more
    asynchronous operations? Sooner or later, we will end up having code that contains
    a lot of `then` instructions that might be difficult to maintain and understand.
    However, don't worry! The async/await comes to save the day! Keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: The async/await instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The async and await are two instructions that come to save our life from the
    `Promise` chaos. This will allows us to write asynchronous code using asynchronous
    syntax. Let's organize our code to see how this works!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to create a new function for the update process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note in the preceding code is the `async` keyword. This keyword
    will wrap the returning result into a `Promise` and will allow us to use the `await`
    keyword. You cannot use `await` keyword in a non-async function. The `await` keyword
    will wait for the asynchronous call `Team.findById(id)` to end and will return
    the result. The same happens when we call the `team.save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using async-await helps us avoid the `Promise` chaos. It provides us with an
    execution flow that might look like an asynchronous execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined the `updateTeam` async function, we need to modify our
    `PUT` endpoint to call this new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We said that `async` will wrap the result into a `Promise`, so to use the result,
    we will need to use the `then` and `catch` methods to process the returning `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! Now we are ready to learn how to delete an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting a team is extremely easy. To do this, we will call the remove built-in
    method of the `Team` model. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s test things out. Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a bit different now; we received a JSON object with two params:'
  prefs: []
  type: TYPE_NORMAL
- en: '`n`: The number of documents removed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ok`: `1` if the operations were successful or `0` if not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awesome! Now we have our Rest API to manage our teams ready, but there is a
    key missing piece in our API that we did not take care of, and that is security.
    We will make our API secure by adding an authentication and authorization layer
    in subsequent chapters. Keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what a database is and the difference between SQL
    and NoSQL databases. Also, we implemented the API to manage teams that is able
    to persist the information into a MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about async/await, and we were able to code a more easy-to-read
    and maintainable asynchronous logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore advanced features of Aurelia to integrate
    our REST API with our Aurelia web application.
  prefs: []
  type: TYPE_NORMAL
