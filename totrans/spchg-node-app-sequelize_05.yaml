- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Adding Hooks and Lifecycle Events to Your Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将钩子和生命周期事件添加到您的模型中
- en: ORM typically provides a way for us to be able to transform states, or objects,
    throughout events that occur when executing certain operations. These methods
    are often referred to as hooks, lifecycle events, object lifecycles, or even callbacks
    (the latter is *not* often used within the Node.js community due to a nomenclature
    conflict against Node.js’ native environment). Usually, these methods have a temporal
    prefix (for example, `before` and `after`) preceding an event’s name.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 通常提供一种方法，使我们能够在执行某些操作时发生的事件中转换状态或对象。这些方法通常被称为钩子、生命周期事件、对象生命周期，甚至回调（后者在 Node.js
    社区中不常用，因为与 Node.js 的原生环境存在命名冲突）。通常，这些方法有一个时间前缀（例如，`before` 和 `after`）在事件名称之前。
- en: 'There are no strict rules as to what an ORM requires as an event throughout
    its entire lifecycle. The events typically included within an ORM are called:
    validation, save, create, update, and destroy. Other ORM frameworks offer a wider
    scope of events or more granular control, such as before/after connecting to your
    database, defining your models, and calling a finder query.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 在其整个生命周期中对事件的要求没有严格的规则。ORM 中通常包括的事件被称为：验证、保存、创建、更新和销毁。其他 ORM 框架提供更广泛的事件范围或更细粒度的控制，例如在连接到数据库之前/之后、定义您的模型以及调用查找查询时。
- en: Sequelize categorizes hooks into global and local hooks. Global hooks are for
    defining default lifecycle events for every model, enforce events (referred to
    as permanent hooks in Sequelize), and connection-related events. The local hooks
    entail lifecycle events defined on models for instances/records.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 将钩子分为全局钩子和局部钩子。全局钩子用于为每个模型定义默认的生命周期事件，强制事件（在 Sequelize 中称为永久钩子），以及与连接相关的事件。局部钩子包括在模型上定义的实例/记录的生命周期事件。
- en: 'In this chapter, we will go over the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: The order of operations for lifecycle events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期事件的执行顺序
- en: Defining, removing, and executing lifecycle events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义、删除和执行生命周期事件
- en: Using lifecycle events with associations and transactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关联和事务中使用生命周期事件
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can always reference Sequelize’s code base to maintain an up-to-date list
    of available lifecycle events here: [https://sequelize.org/docs/v6/other-topics/hooks/](https://sequelize.org/docs/v6/other-topics/hooks/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以始终参考 Sequelize 的代码库来维护一个可用的生命周期事件列表：[https://sequelize.org/docs/v6/other-topics/hooks/](https://sequelize.org/docs/v6/other-topics/hooks/)。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter at [https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch5](https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch5).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch5](https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch5)找到本章的代码文件。
- en: Order of operations for lifecycle events
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期事件的执行顺序
- en: Lifecycle events are an important feature when we want to introduce project-specific
    behaviors/constraints that extend beyond a database engine’s scope. Knowing the
    lifecycle events is only half of the equation, and the other half consists of
    knowing when those lifecycle events are triggered.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要引入超出数据库引擎范围的项目特定行为/约束时，生命周期事件是一个重要的特性。了解生命周期事件只是方程的一半，另一半是了解这些生命周期事件何时被触发。
- en: Suppose we were given the task to offer all of our products for free to employees.
    The first action could be adding a `beforeValidate` hook that would set the transaction’s
    subtotal to `0` if the user was an employee. That’s easy for us, but unfortunately
    a nightmare for the accounting department. A better approach would be to add an
    additional item that represents the employee discount, using the `beforeValidate`
    or `beforeCreate` hook.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被分配了一个任务，即向所有员工免费提供我们的产品。第一个动作可能是添加一个 `beforeValidate` 钩子，如果用户是员工，则将事务的小计设置为
    `0`。这对我们来说很简单，但不幸的是，这对会计部门来说是一个噩梦。更好的方法是在 `beforeValidate` 或 `beforeCreate` 钩子中添加一个表示员工折扣的额外项目。
- en: The real answer in knowing which lifecycle events to use depends on the project’s
    requirements. From our previous example, some transactions require moving legal
    tender, which involves charging the employee and then providing a refund/credit
    as a separate transaction. In this case, we would not be able to use `beforeValidate`
    nor `beforeCreate`, but `afterCreate` could be applicable. Under the context of
    Sequelize, knowing where to place your code’s logic is knowing the order of operations
    for lifecycle events.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 知道使用哪些生命周期事件的真实答案取决于项目的需求。从我们之前的例子中，一些交易需要移动法定货币，这涉及到先向员工收费，然后作为单独的交易提供退款/信用。在这种情况下，我们无法使用`beforeValidate`或`beforeCreate`，但`afterCreate`可能适用。在Sequelize的上下文中，知道在哪里放置你的代码逻辑就是知道生命周期事件的操作顺序。
- en: 'In Sequelize, lifecycle events follow the `before`/`after` preface style for
    hook names, like other ORM frameworks. All of Sequelize’s *connection* lifecycle
    events are defined on the `sequelize` object itself, and all of the *instance*
    event types are defined on models. The *model* event types can be defined in both
    areas. The exception to these rules is when we want to define an instance event
    for all of the models globally (examples will be provided in the following section).
    Here is a table listing lifecycle events in the order that they are executed along
    with a signature for the callback function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '在Sequelize中，生命周期事件遵循`before`/`after`前缀风格命名钩子，就像其他ORM框架一样。Sequelize的所有*连接*生命周期事件都定义在`sequelize`对象本身上，所有*实例*事件类型都定义在模型上。*模型*事件类型可以在两个地方定义。这些规则的例外情况是我们想要为所有模型全局定义实例事件（以下章节将提供示例）。以下是按执行顺序列出生命周期事件及其回调函数签名的表格： '
- en: '**Hook definitions sorted by lifecycle execution**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**钩子定义按生命周期执行顺序排序**'
- en: '| **Event name** | **Event type** | **Requires sync*** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **事件名称** | **事件类型** | **需要同步** |'
- en: '| --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `beforeConnect(config)``beforeDisconnect(connection)` | Connection | No |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `beforeConnect(config)``beforeDisconnect(connection)` | 连接 | 否 |'
- en: '| `beforeSync(options)``afterSync(options)` | Connection | No |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `beforeSync(options)``afterSync(options)` | 连接 | 否 |'
- en: '| `beforeBulkSync(options)``afterBulkSync(options)` | Connection | No |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `beforeBulkSync(options)``afterBulkSync(options)` | 连接 | 否 |'
- en: '| `beforeQuery(options, query)` | Connection | No |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `beforeQuery(options, query)` | 连接 | 否 |'
- en: '| `beforeDefine(attributes, options)``afterDefine(factory)` | Connection (Model)
    | Yes |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `beforeDefine(attributes, options)``afterDefine(factory)` | 连接（模型） | 是 |'
- en: '| `beforeInit(config, options)``afterInit(sequelize)` | Connection (Model)
    | Yes |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `beforeInit(config, options)``afterInit(sequelize)` | 连接（模型） | 是 |'
- en: '| `beforeAssociate({ source, target, type }, options)``afterAssociate({ source,
    target, type, association }, options)` | Connection (Model) | Yes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `beforeAssociate({ source, target, type }, options)``afterAssociate({ source,
    target, type, association }, options)` | 连接（模型） | 是 |'
- en: '| `beforeBulkCreate(instances, options)``beforeBulkDestroy(options)``beforeBulkRestore(options)``beforeBulkUpdate(options)`
    | Model | No |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `beforeBulkCreate(instances, options)``beforeBulkDestroy(options)``beforeBulkRestore(options)``beforeBulkUpdate(options)`
    | 模型 | 否 |'
- en: '| `beforeValidate(instance, options)` | Instance | No |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `beforeValidate(instance, options)` | 实例 | 否 |'
- en: '| `afterValidate(instance, options)``validationFailed(instance, options, error)`
    | Instance | No |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `afterValidate(instance, options)``validationFailed(instance, options, error)`
    | 实例 | 否 |'
- en: '| `beforeCreate(instance, options)``beforeDestroy(instance, options)``beforeRestore(instance,
    options)``beforeUpdate(instance, options)``beforeSave(instance, options)``beforeUpsert(values,
    options)` | Instance | No |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `beforeCreate(instance, options)``beforeDestroy(instance, options)``beforeRestore(instance,
    options)``beforeUpdate(instance, options)``beforeSave(instance, options)``beforeUpsert(values,
    options)` | 实例 | 否 |'
- en: '| `afterCreate(instance, options)``afterDestroy(instance, options)``afterRestore(instance,
    options)``afterUpdate(instance, options)``afterSave(instance, options)``afterUpsert(created,
    options)` | Instance | No |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `afterCreate(instance, options)``afterDestroy(instance, options)``afterRestore(instance,
    options)``afterUpdate(instance, options)``afterSave(instance, options)``afterUpsert(created,
    options)` | 实例 | 否 |'
- en: '| `afterBulkCreate(instances, options)``afterBulkDestroy(options)``afterBulkRestore(options)``afterBulkUpdate(options)`
    | Instance | No |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `afterBulkCreate(instances, options)``afterBulkDestroy(options)``afterBulkRestore(options)``afterBulkUpdate(options)`
    | 实例 | 否 |'
- en: '| `afterQuery(options, query)` | Connection | No |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `afterQuery(options, query)` | 连接 | 否 |'
- en: '| `beforeDisconnect(connection)``afterDisconnect(connection)` | Connection
    | No |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `beforeDisconnect(connection)``afterDisconnect(connection)` | 连接 | 否 |'
- en: '*These lifecycle events will be triggered only if `sequelize.sync()` is invoked.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些生命周期事件只有在调用`sequelize.sync()`时才会触发。'
- en: The majority of these lifecycle events are explicative in corresponding with
    their Sequelize function (for example, `beforeSave` for `Model.save()`). However,
    there are two types of events that are implicative and may not be clear initially.
    The first one is the `restore` events related to paranoid models (where records
    are considered `delete` with a column flag as opposed to being physically deleted).
    The second one is the `Upsert` events that are invoked for `create`, `update`,
    and `save`-related methods, indicating to us whether a record was newly created
    or updated from a pre-existing record.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生命周期事件中的大多数都与它们的 Sequelize 函数（例如，`beforeSave` 对应于 `Model.save()`）相对应。然而，有两种类型的事件是隐含的，并且可能一开始并不明显。第一种是与偏执模型（记录被视为通过列标志标记为`delete`而不是物理删除）相关的`restore`事件。第二种是`Upsert`事件，这些事件在`create`、`update`和`save`相关方法中被调用，向我们指示记录是新建的还是从现有记录更新而来。
- en: 'Where Sequelize differentiates from other ORM lifecycle events is, in addition
    to *instance* and *connection*-related events, Sequelize will also provide hooks
    surrounding *finder* methods (for example, `findAll` and `findOne`). The following
    is a list with a brief explanation of each finder event:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 与其他 ORM 生命周期事件的不同之处在于，除了与*实例*和*连接*相关的事件外，Sequelize 还将提供围绕*查询*方法的钩子（例如，`findAll`和`findOne`）。以下是一个包含每个查询事件简要说明的列表：
- en: '`beforeFind(options)`: Occurs before any transformation that occurs to options
    from Sequelize internally'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeFind(options)`: 在 Sequelize 内部对选项进行任何转换之前发生'
- en: '`beforeFindAfterExpandIncludeAll(options)`: An event that is triggered after
    Sequelize expands the *include* attributes (for example, setting proper defaults
    for specific associations)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeFindAfterExpandIncludeAll(options)`: 在 Sequelize 扩展*include*属性（例如，为特定关联设置适当的默认值）后触发的事件'
- en: '`beforeFindAfterOptions(options)`: Before the finder method invokes the query
    and after Sequelize is finished hydrating/transforming options'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeFindAfterOptions(options)`: 在查询方法调用查询之前以及 Sequelize 完成填充/转换选项之后发生'
- en: '`afterFind(instances, options)`: Returns a single instance or an array of instances
    after a finder method is finished querying'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterFind(instances, options)`: 在查询方法完成后返回单个实例或实例数组'
- en: '`beforeCount(options)`: This event will trigger before the `count()` instance
    method queries the database'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeCount(options)`: 在`count()`实例方法查询数据库之前触发此事件'
- en: Now that we have a better understanding of which hooks are available to use
    and the order of execution through the lifecycle, we can begin building our models
    with lifecycle events attached to them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对可以使用哪些钩子和生命周期执行的顺序有了更好的理解，我们可以开始构建带有附加生命周期事件的模型。
- en: Defining, removing, and executing lifecycle events
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义、删除和执行生命周期事件
- en: There are several ways to attach lifecycle events to models and Sequelize’s
    behavior. Each of these methods allows us to change the attribute values that
    are derived from the hook’s arguments as pass-by-reference. For example, you can
    add additional properties to the instances returned in `afterFind` by simply updating
    the attributes on the objects from within the lifecycle method. By default, Sequelize
    will treat lifecycle events as synchronous operations, but if you need asynchronous
    capabilities, you can return a `Promise` object or an `async` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将生命周期事件附加到模型和 Sequelize 的行为上。这些方法中的每一种都允许我们通过引用传递来更改从钩子参数派生的属性值。例如，您可以通过在生命周期方法内部更新对象上的属性来简单地向`afterFind`返回的实例添加额外的属性。默认情况下，Sequelize
    将生命周期事件视为同步操作，但如果您需要异步功能，则可以返回一个`Promise`对象或一个`async`函数。
- en: Defining instance and model lifecycle events
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义实例和模型生命周期事件
- en: 'Instance and model lifecycle events can be defined in several ways, including
    defining these events as a local hook (defined directly from the model itself).
    There are several ways to define a local hook; we will start with the basic example
    of declaring hooks during the initialization of a model:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实例和模型生命周期事件可以通过多种方式定义，包括将这些事件定义为本地钩子（直接从模型本身定义）。定义本地钩子有几种方法；我们将从在模型初始化期间声明钩子的基本示例开始：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To define the same exact hook outside of initialization, we can either use
    the `addHook()` method or invoke the corresponding lifecycle method directly.
    This method provides an easy way for plugins and adapters to integrate with your
    models after defining them. The following is a simple example of how to use this
    method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在初始化之外定义完全相同的钩子，我们可以使用 `addHook()` 方法或直接调用相应的生命周期方法。此方法为插件和适配器在定义模型后轻松集成提供了方便。以下是如何使用此方法的简单示例：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous examples provided illustrations for synchronous events. An example
    of asynchronous hooks involves returning a Promise (as previously stated), like
    so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子提供了同步事件的说明。异步钩子的一个例子是返回一个 Promise（如前所述），如下所示：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To throw an error from a synchronous lifecycle event, you can return a rejected
    `Promise` object:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要从同步生命周期事件中抛出错误，你可以返回一个被拒绝的 `Promise` 对象：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For organizational purposes, you can declare names for your lifecycle events
    using the `addHook()` or direct methods:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织目的，你可以使用 `addHook()` 或直接方法为你的生命周期事件声明名称：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These examples provide us with methods for assigning lifecycle events on the
    local scope of the model itself. If we wanted to define lifecycle events on a
    global scope (applicable to all models), we would use the Sequelize constructor
    to do so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子为我们提供了在模型本身的局部作用域上分配生命周期事件的方法。如果我们想在全局作用域（适用于所有模型）上定义生命周期事件，我们将使用 Sequelize
    构造函数来完成：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will generate a default `beforeValidate` hook for models that do not define
    their own `beforeValidate` hooks. If you wish to run a global hook, regardless
    of whether the model has its own definition, we can define **permanent hooks**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为未定义自己的 `beforeValidate` 钩子的模型生成默认的 `beforeValidate` 钩子。如果你希望无论模型是否有自己的定义都运行全局钩子，我们可以定义**永久钩子**：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Even if a model has its own `beforeValidate` hook definition, Sequelize will
    still execute the global hook. If we have a global and local hook associated with
    the same lifecycle event, then Sequelize will execute the local hook(s) first
    followed by the global hook(s).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 即使模型有自己的 `beforeValidate` 钩子定义，Sequelize 仍然会执行全局钩子。如果我们有一个与同一生命周期事件关联的全局和局部钩子，那么
    Sequelize 会首先执行局部钩子（们），然后是全局钩子（们）。
- en: 'For model-specific event types (such as `bulkDestroy` and `bulkUpdate`), Sequelize
    will not execute individual delete and update hooks per row by default. To modify
    this behavior, we can add a `{ individualHooks: true }` option for when we call
    these methods, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '对于特定的模型事件类型（如 `bulkDestroy` 和 `bulkUpdate`），Sequelize 默认不会按行执行单个删除和更新钩子。要修改这种行为，我们可以在调用这些方法时添加
    `{ individualHooks: true }` 选项，如下所示：'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Using the `{ indvidualHooks: true }` option could cause a decrease in performance,
    depending on whether Sequelize will need to retrieve rows, store the rows/additional
    information in memory (for example, `bulkDestroy` and `bulkUpdate` but not `bulkCreate`),
    and execute individual hooks per record.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `{ indvidualHooks: true }` 选项可能会降低性能，这取决于 Sequelize 是否需要检索行、在内存中存储行/附加信息（例如，`bulkDestroy`
    和 `bulkUpdate` 但不是 `bulkCreate`），以及为每条记录执行单个钩子。'
- en: Removing lifecycle events
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除生命周期事件
- en: Some projects will require conditionally invoking lifecycle events. For instance,
    we may have some sort of validation to check whether a user is still eligible
    for replying to a comment on a forum. This validation is appropriate for a production
    environment but not necessary for a development environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目可能需要条件性地调用生命周期事件。例如，我们可能需要进行某种验证来检查用户是否仍然有资格回复论坛上的评论。这种验证对于生产环境是合适的，但对于开发环境则不是必需的。
- en: 'One method would be to create a conditional logic surrounding the hook definition
    – for example, the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在钩子定义周围创建条件逻辑——例如，以下内容：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would technically work, but what if we had several stipulations, such as
    sending an order email in the `afterCreate` hook or refunding an order in production
    only? We would have a lot of “`if` statements” throughout the code base. Sequelize
    offers a method to remove lifecycle events to help organize this type of workflow
    called `removeHook`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这在技术上是可以工作的，但如果我们有多个规定，比如在 `afterCreate` 钩子中发送订单邮件或在生产环境中仅退款？我们将在代码库中有很多“`if`”语句。Sequelize
    提供了一种移除生命周期事件的方法来帮助组织这种类型的工作流程，称为 `removeHook`。
- en: 'We could load all of the lifecycle events as we normally would, but if our
    environment is at the development stage, then we can run through all of our models
    and remove the applicable hooks. All of these granular tunings can be organized
    in one function given the `removeHook` method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像平时一样加载所有生命周期事件，但如果我们的环境处于开发阶段，那么我们可以遍历所有模型并移除适用的钩子。所有这些细粒度的调整都可以通过`removeHook`方法组织在一个函数中：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Removing lifecycle events is useful for timed behavior in an application or
    for removing explicit debugging hooks. The next section will help us understand
    the order of operation when executing lifecycle events and when a specific lifecycle
    event will be executed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 移除生命周期事件对于应用程序中的定时行为或移除显式调试钩子很有用。下一节将帮助我们了解执行生命周期事件时的操作顺序以及特定生命周期事件将在何时执行。
- en: Executing lifecycle events
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行生命周期事件
- en: 'Sequelize will run the corresponding/applicable lifecycle events based on the
    method that you are invoking. Using our previous `Transactions` model example,
    if we were to run `Transactions.create({ … })`, then Sequelize would automatically
    run the following lifecycle events (in sequential order):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize将根据你调用的方法运行相应的/适用的生命周期事件。使用我们之前的`Transactions`模型示例，如果我们运行`Transactions.create({
    … })`，那么Sequelize将自动运行以下生命周期事件（按顺序）：
- en: '`beforeValidate`'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeValidate`'
- en: '`afterValidate`/`validationFailed`'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`afterValidate`/`validationFailed`'
- en: '`beforeCreate`'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeCreate`'
- en: '`beforeSave`'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeSave`'
- en: '`afterSave`'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`afterSave`'
- en: '`afterCreate`'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`afterCreate`'
- en: One caveat to keep in mind for executing lifecycle events is that when you are
    using the `update()` method, it is important to keep in mind that Sequelize will
    not execute the lifecycle events unless an attribute’s value has changed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个问题是，在执行生命周期事件时，当你使用`update()`方法时，重要的是要记住，除非某个属性的值已更改，否则Sequelize不会执行生命周期事件。
- en: 'For instance, this will not call the corresponding lifecycle events:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这不会调用相应的生命周期事件：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since the values did not change, Sequelize will ignore the lifecycle events.
    If we wanted to enforce this behavior, we could add a `hooks: true` parameter
    to the update’s configuration:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '由于值没有改变，Sequelize将忽略生命周期事件。如果我们想强制这种行为，我们可以在更新的配置中添加一个`hooks: true`参数：'
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have the basics of how to define, remove, and execute lifetime events,
    we can move on to the nuances of utilizing hooks with associations and transactions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何定义、移除和执行生命周期事件的基础知识，我们可以继续探讨如何利用关联和事务的钩子。
- en: Using lifecycle events with associations and transactions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关联和事务的生命周期事件
- en: As the default behavior, Sequelize will execute lifecycle events without associating
    a transaction with any database queries that are invoked within the lifecycle’s
    scope. However, sometimes our project requires transactions to be used within
    lifecycle events, such as an accountant’s ledger or creating log entries. Sequelize
    offers a `transaction` parameter when calling certain methods, such as `update`,
    `create`, `destroy`, and `findAll`, that will allow us to use a transaction that
    was defined outside of the lifecycle’s scope to be used within the lifecycle itself.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为默认行为，Sequelize将在不将事务与生命周期范围内的任何数据库查询相关联的情况下执行生命周期事件。然而，有时我们的项目需要在生命周期事件中使用事务，例如会计的账簿或创建日志条目。当调用某些方法，如`update`、`create`、`destroy`和`findAll`时，Sequelize提供了一个`transaction`参数，这将允许我们使用在生命周期范围外定义的事务在生命周期内部使用。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When calling `beforeDestroy` and `afterDestroy` on a model, Sequelize will intentionally
    skip destroying any associations with that model unless the `onDelete` parameter
    is set to `CASCADE` and the `hooks` parameter is set to `true`. This is due to
    Sequelize needing to explicitly delete each association row by row, which could
    cause congestion if we are not careful.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当在模型上调用`beforeDestroy`和`afterDestroy`时，Sequelize会故意跳过与该模型关联的任何销毁操作，除非`onDelete`参数设置为`CASCADE`且`hooks`参数设置为`true`。这是由于Sequelize需要逐行显式删除每个关联行，如果不小心可能会导致拥堵。
- en: 'If we were to write a naive accounting system and wanted to create logging
    entries as a separate ledger, we would first define our models like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要编写一个简单的会计系统，并希望作为单独的账簿创建日志条目，我们首先定义我们的模型如下：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can add our `Ledger` model, which is a copy of the `Book` model with
    a naive reference column (for brevity) and a signature column, to indicate that
    the transaction was approved by an external source:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加我们的`Ledger`模型，这是一个`Book`模型的副本，包含一个简单的引用列（为了简洁）和一个签名列，以指示交易已被外部来源批准：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To automate the `Ledger` workflow, we can add an `afterCreate` hook to our
    Book model to record the account balance changes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化`Ledger`工作流程，我们可以在Book模型中添加一个`afterCreate`钩子来记录账户余额的变化：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, when we create a new booking entry, we can pass a `transaction` reference
    so that Sequelize can execute queries within the lifecycle scopes under the same
    transaction. We will be covering transactions more in depth in [*Chapter 6*](B17841_06.xhtml#_idTextAnchor147),
    *Implementing Transactions with Sequelize*, but for now, we will give a simple
    illustrative example of what a transaction would look like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建一个新的预订条目时，我们可以传递一个`transaction`引用，这样Sequelize就可以在同一个事务范围内执行生命周期范围内的查询。我们将在[*第6章*](B17841_06.xhtml#_idTextAnchor147)中更深入地介绍事务，*使用Sequelize实现事务*，但到目前为止，我们将给出一个简单的示例，说明事务将是什么样子：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The benefit of using a transaction within the lifecycle event is that if any
    part of the transaction workflow fails to execute, we can halt the rest of the
    workflow without diluting the quality of our database’s records. Without the `transaction`
    parameter being set within the previous example, Sequelize would still have created
    a Ledger entry, even if the `checkBalances` method returned an error and did not
    commit the transaction.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在生命周期事件中使用事务的好处是，如果事务工作流程的任何部分执行失败，我们可以停止其余的工作流程，而不会稀释我们数据库记录的质量。在没有设置`transaction`参数的前一个示例中，即使`checkBalances`方法返回错误且未提交事务，Sequelize仍然会创建一个账簿条目。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sequelize will sometimes use its own internal transaction for methods such as
    `findOrCreate`. You may always overwrite this parameter with your own transaction.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize有时会为`findOrCreate`等方法使用其自身的内部事务。您始终可以用您自己的事务覆盖此参数。
- en: Now that we have the fundamentals of adding lifecycle events to our models,
    we can begin updating our Avalon Airlines project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了向我们的模型添加生命周期事件的基础，我们可以开始更新我们的Avalon Airlines项目。
- en: Putting it all together
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: 'For this section, we will only need to update the `BoardingTicket` model (located
    in `models/boardingticket.js`) by adding two attributes, `cost` and `isEmployee`,
    and some lifecycle events for our boarding seat workflow. Let’s look at the steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们只需要更新`BoardingTicket`模型（位于`models/boardingticket.js`），添加两个属性`cost`和`isEmployee`，以及我们登机座位工作流程的一些生命周期事件。让我们看看步骤：
- en: 'First, we will need to add our attributes within the `init` method, which should
    end up looking like this:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`init`方法中添加我们的属性，最终应该看起来像这样：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Below the `init` function, we will want to add our lifecycle events. The first
    one will check whether the ticket is considered to be an employee ticket and,
    if so, then mark the subtotal as zero:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`函数下方，我们希望添加我们的生命周期事件。第一个将检查票是否被认为是员工票，如果是，则将小计标记为零：
- en: '[PRE17]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we will want to ensure our subtotal is never less than zero (the `beforeValidate`
    event would also be applicable here):'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望确保小计永远不会小于零（`beforeValidate`事件也适用于此处）：
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the last lifecycle event for our model, we will want to check whether the
    customer had selected a seat that was considered available:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们模型的最后一个生命周期事件，我们希望检查客户是否选择了被认为是可用的座位：
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After these changes, whenever we create a new boarding ticket, our application
    will now perform three lifecycle events prior to saving the record. For reference
    only, the following is an example of how we would pass the transaction to our
    `BoardingTicket` model:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些更改之后，每次我们创建一个新的登机牌，我们的应用程序现在在保存记录之前将执行三个生命周期事件。仅作参考，以下是我们如何将事务传递给`BoardingTicket`模型的示例：
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That wraps up our required changes in this chapter for the Avalon Airlines project.
    We added a lifecycle event that checks for subtotals and seat availability. We
    also went through an example of passing a transaction to a specific query, which
    we will expand upon in the next chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了本章对Avalon Airlines项目的必要更改。我们添加了一个检查小计和座位可用性的生命周期事件。我们还通过一个示例展示了如何将事务传递给特定的查询，我们将在下一章中进一步展开。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through what a lifecycle event is and how it can be
    used in day-to-day applications, which lifecycle events are available to Sequelize
    and in which order they are initiated, and how to add lifecycle events to or remove
    them from a Sequelize model.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了生命周期事件是什么，以及如何在日常应用中使用它，Sequelize提供了哪些生命周期事件以及它们的启动顺序，以及如何向Sequelize模型添加或删除生命周期事件。
- en: In the next chapter, we will be covering how transactions work, how they are
    used, and how they can be configured within Sequelize. In addition, the following
    chapter will also cover different types of locks for transactions and the differences
    between managed and unmanaged transactions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍事务的工作原理，它们的使用方式以及如何在 Sequelize 中进行配置。此外，下一章还将涵盖事务的不同锁定类型以及受管理和非受管理事务之间的区别。
- en: References
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'If you run into issues with lifecycle events, a quick reference can be found
    here: [https://sequelize.org/master/manual/hooks.xhtml](https://sequelize.org/master/manual/hooks.xhtml).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在生命周期事件方面遇到问题，可以在此处找到快速参考：[https://sequelize.org/master/manual/hooks.xhtml](https://sequelize.org/master/manual/hooks.xhtml)。
