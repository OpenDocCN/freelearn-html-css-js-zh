<html><head></head><body>
        

                            
                    <h1 class="header-title">Making a Weather App in Elm</h1>
                
            
            
                
<p>Welcome to <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>. In this chapter, we will make our Elm-powered weather app. The purpose of this app is to learn how to fetch information from JSON and use it in our app.</p>
<p>The topics we will cover include:</p>
<ul>
<li>Taking care of errors with <kbd>Result</kbd></li>
<li>Dealing with optional values and nothingness using <kbd>Maybe</kbd></li>
<li>Decoding JSON strings using decoders</li>
<li>Fetching remote data with the help of the HTTP package</li>
<li>Working with a third-party API</li>
</ul>
<p>After completing this chapter, you will be able to:</p>
<ul>
<li>Fetch information from the internet in JSON format</li>
<li>Have your Elm apps consume JSON data using decoders</li>
<li>Understand how all the moving parts fit together to build a functioning app</li>
</ul>
<p>To begin, we will look at obtaining weather data from a third-party API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Obtaining the weather data from a third-party API</h1>
                
            
            
                
<p>In order for our weather app to even be possible, we will need to obtain weather data from somewhere. Luckily, there are plenty of weather-related APIs online, which makes this task a lot easier to accomplish.</p>
<p class="mce-root">In order to have a working app, we need to connect to a third-party data provider. In our case, the data provider we will use is Open Weather Map.</p>
<p>The information about the Open Weather Map's API is available at <a href="https://openweathermap.org/api">https://openweathermap.org/api</a>.</p>
<p>To gain access to the API you need to obtain the APPID. The instructions on how to do that are available here, <a href="http://openweathermap.org/appid">http://openweathermap.org/appid</a>. Basically, all that is needed to obtain it is to create a new account.</p>
<p>As soon as you have created your account, you will find your API key generated under the API keys tab. To access the data for a city, for example, Chicago, it's enough to visit the following URL: <kbd>http://api.openweathermap.org/data/2.5/weather?q=chicago&amp;APPID=abcdef1234567890</kbd></p>
<p>Obviously, the preceding URL is using the wrong APPID. Replace it with your own, and you should be good to go. Using the correct APPID in the preceding URL, your browser will show a JSON string like this:</p>
<pre>{"coord":{"lon":-87.62,"lat":41.88},"weather":[{"id":802,"main":"Clouds","description":"scattered clouds","icon":"03n"}],"base":"stations","main":{"temp":268.9,"pressure":1025,"humidity":86,"temp_min":267.15,"temp_max":270.15},"visibility":16093,"wind":{"speed":2.1,"deg":260},"clouds":{"all":40},"dt":1518941700,"sys":{"type":1,"id":1030,"message":0.0033,"country":"US","sunrise":1518957687,"sunset":1518996470},"id":4887398,"name":"Chicago","cod":200}</pre>
<p>Just what we do with this string will be discussed later in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What are we going to build?</h1>
                
            
            
                
<p class="mce-root">We are going to build a very simple weather app, which will communicate with the outside world to fetch JSON-formatted weather data.</p>
<p class="mce-root">Once we receive that weather data, we will then decode the JSON string into values that our app's model will be able to understand and work with, using decoders. Let's jump right in.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building our weather app</h1>
                
            
            
                
<p class="mce-root">We will start by replacing the code in <kbd>Main.elm</kbd> with the bare-bones Elm code we have already been using in the previous chapters:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)<br/>import Html.Events exposing (..)<br/><br/>-- Model<br/>init =<br/>    {}<br/><br/>-- Update<br/>type Msg<br/>    = Nothing<br/><br/>update msg model =<br/>    model<br/><br/>-- View<br/>view model =<br/>    div [] [ text "Everything will go here" ]<br/><br/>-- Main<br/>main =<br/>    beginnerProgram<br/>        { model = init<br/>        , view = view<br/>        , update = update<br/>        }</pre>
<p>Let's immediately improve our app by replacing <kbd>beginnerProgram</kbd> with <kbd>Html.Program</kbd>, since <kbd>beginnerProgram,</kbd> as explained in the previous chapter, has no means of working with side effects:</p>
<pre>module Main exposing (..)<br/>import Html exposing (..)<br/><br/><br/>-- Model<br/>type alias Model =<br/>    {}<br/><br/>init : ( Model, Cmd Msg )<br/>init =<br/>    ( Model, Cmd.none )<br/><br/>-- Update<br/>type Msg<br/>    = Noop<br/><br/>update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        Noop -&gt;<br/>            ( model, Cmd.none )<br/><br/>-- View<br/>view : Model -&gt; Html Msg<br/>view model =<br/>    div [] [ text "Everything will go here, this time using Html.program" ]<br/><br/>-- Subscriptions<br/>subscriptions : Model -&gt; Sub Msg<br/>subscriptions model =<br/>    Sub.none<br/><br/>-- Main<br/>main : Program Never Model Msg<br/>main =<br/>    Html.program<br/>        { init = init<br/>        , view = view<br/>        , update = update<br/>        , subscriptions = subscriptions<br/>        }</pre>
<p>Let's walk through the preceding code.</p>
<p>We start off by describing the application model as a type alias called <kbd>Model</kbd>, and we set it to an empty record. Following the type alias, we introduce the <kbd>init</kbd> function, which holds the initial state of our app, and the initial command to run. With <kbd>Cmd.none</kbd>, we are basically saying to Elm runtime not to run any commands at this point. So, although we are not going to be requesting any commands to be run at this moment in our code, we cannot just omit them, we have to be explicit, and clearly state that we will not run any commands just yet.</p>
<p>Note the change in the <kbd>init</kbd> function: the <kbd>init</kbd> function now takes the following two-tuple: <kbd>( Model, Cmd.none )</kbd>.</p>
<p>Next, in the <kbd>update</kbd> function, we are using a union type <kbd>Msg</kbd>, which can be only of <kbd>NoOp</kbd> value. Basically, whenever we want to assert that our app should not do anything with a message it receives, we can use <kbd>NoOp</kbd> as the value.</p>
<p>The update function uses a <kbd>case of</kbd> expression. We pass two arguments to the <kbd>update</kbd> function: the <kbd>msg</kbd> and the <kbd>model</kbd>, and these arguments are used to update the <kbd>model</kbd> and return a command. Here, since we are receiving the <kbd>NoOp</kbd> message, the only thing that happens is: we just return the <kbd>model</kbd> as is. By using <kbd>Cmd.none</kbd> in the returned two-tuple, we are saying to the Elm runtime that it should not run any commands.</p>
<p>In the <kbd>subscriptions</kbd> function, all that we are doing is: we are saying to the Elm runtime that we do not want to subscribe to any events. Hence, we assign it the value of <kbd>Sub.none</kbd>. Finally, the <kbd>main</kbd> function gets assigned the <kbd>Html.program</kbd> where all of the above comes together. </p>
<p>In the next section, we'll install the HTTP package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing the HTTP package</h1>
                
            
            
                
<p>To install the HTTP package, we need to point our console to the location of our <kbd>weather app</kbd> folder. Next, run the following command in the console:</p>
<pre><strong>elm package install elm-lang/http 1.0.0</strong></pre>
<p>This is what the console will return:</p>
<pre><strong>To install elm-lang/http I would like to add the following</strong><br/><strong>dependency to elm-package.json:</strong><br/><br/><strong>    "elm-lang/http": "1.0.0 &lt;= v &lt; 2.0.0"</strong><br/><br/><strong>May I add that to elm-package.json for you? [Y/n]</strong></pre>
<p>After confirming with <kbd>y</kbd>, the console will output the following:</p>
<pre><strong>Some new packages are needed. Here is the upgrade plan.</strong><br/><br/><strong>  Install:</strong><br/><strong>    elm-lang/http 1.0.0</strong><br/><br/><strong>Do you approve of this plan? [Y/n]</strong></pre>
<p>Approving the plan by typing <kbd>y</kbd> will produce the following messages in the console:</p>
<pre><strong>Starting downloads...</strong><br/><br/><strong>  ● elm-lang/http 1.0.0</strong><br/><br/><strong>Packages configured successfully!</strong></pre>
<p>Next, let's open the <kbd>elm-package.json</kbd> and verify that it looks as follows:</p>
<pre>{<br/>    "version": "1.0.0",<br/>    "summary": "helpful summary of your project, less than 80 characters",<br/>    "repository": "https://github.com/user/project.git",<br/>    "license": "BSD3",<br/>    "source-directories": [<br/>        "src"<br/>    ],<br/>    "exposed-modules": [],<br/>    "dependencies": {<br/>        "elm-lang/core": "5.1.1 &lt;= v &lt; 6.0.0",<br/>        "elm-lang/html": "2.0.0 &lt;= v &lt; 3.0.0",<br/>        "elm-lang/http": "1.0.0 &lt;= v &lt; 2.0.0"<br/>    },<br/>    "elm-version": "0.18.0 &lt;= v &lt; 0.19.0"<br/>}</pre>
<p>With this, we have successfully added the HTTP package to our project.</p>
<p>The official documentation for the HTTP package is available at <a href="http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http">http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http</a>. </p>
<p>Now that we have added all the necessary packages, we can continue building our app.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding all the imports</h1>
                
            
            
                
<p>Let's begin by adding all the imports that we need at the top of <kbd>Main.elm</kbd>:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)
import Html.Events exposing (..)<br/>import Http<br/>import Json.Decode as Decode</pre>
<p>The linter will throw four identical warnings after you save your code with the preceding update. The only difference, in each of the warnings, is the module that is referenced. For example:</p>
<pre>Module `Html.Attributes` is unused.<br/>Best to remove it. Don't save code quality for later!</pre>
<p>It is wonderful that the compiler encourages us to improve our code quality at the first possible opportunity, but for now, it is safe to ignore those warnings. We will soon add the code to our app that will resolve them. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conceptualizing the model</h1>
                
            
            
                
<p>Since we will be changing up quite a lot of things in our app, at this point we can prevent several nagging errors by simply temporarily removing type annotations. To do that, simply remove type annotations from the following functions: <kbd>init</kbd>, <kbd>update</kbd>, <kbd>view</kbd>, <kbd>subscriptions</kbd>, and <kbd>main</kbd>.</p>
<p>Let's look at our updated model now:</p>
<pre>type alias Model =<br/>    { temperatureInfo : TemperatureInfo<br/>    , city : String<br/>    }<br/><br/><br/>type alias TemperatureInfo =<br/>    { name : String<br/>    , windSpeed : Float<br/>    , temperature : Float<br/>    , pressure : Float<br/>    , humidity : Float<br/>    }</pre>
<p>The building blocks of our model should be self-explanatory. Let's then add the preceding code to <kbd>Main.elm</kbd>, and save the file. Our app compiles just fine, and everything works as it has. Let's now update the <kbd>init</kbd> function: </p>
<pre>init =<br/>    ( Model (TemperatureInfo "Did not load" 0 0 0 0) ""<br/>    , Cmd.none<br/>    )</pre>
<p>What we did here is, we simply reflected the newly introduced changes to our model, in our <kbd>init</kbd> function. In the next section, we'll set up the <kbd>Msg</kbd> and the <kbd>update</kbd> functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up Msg union type</h1>
                
            
            
                
<p>Our <kbd>Msg</kbd> union type is pretty simple:</p>
<pre>type Msg<br/>    = GetTemp<br/>    | CityInput String<br/>    | NewTemp (Result Http.Error String)</pre>
<p>There are three possible messages that the <kbd>update</kbd> function can receive: <kbd>GetTemp</kbd>, <kbd>CityInput</kbd>, and <kbd>NewTemp</kbd>. The most peculiar of them is the third one:</p>
<pre>NewTemp (Result Http.Error String)</pre>
<p>There is some code there that we haven't seen before.  The <kbd>NewTemp</kbd> value holds a <kbd>Result</kbd>.  That result can be an <kbd>Http.Error</kbd>, which means that something caused our HTTP request to fail. There can be a number of reasons: the URL does not exist, or the server did not respond, and so on. Another thing that can happen is: the request can succeed.</p>
<p>In that case, we'll get back the <kbd>String</kbd> as the result of making a successful HTTP request. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Result and Maybe</h1>
                
            
            
                
<p>This is a good time to make a little digression and talk about <kbd>Result</kbd> and <kbd>Maybe</kbd> in some more detail. To deal with errors, Elm also has <kbd>Tasks</kbd>, but we will not discuss them at this time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with Result</h1>
                
            
            
                
<p>The official documentation for <kbd>Result</kbd> is available at: <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/Result">http://package.elm-lang.org/packages/elm-lang/core/latest/Result</a>. We use <kbd>Result</kbd> whenever there are things that our code does that can potentially fail. Using <kbd>Result</kbd> allows us to deal better with errors in Elm. The <kbd>Result</kbd> definition says that it's a union type that has two <kbd>type</kbd> constructors: <kbd>Ok</kbd> and <kbd>Err</kbd>.  Take a look at the following code snippet:</p>
<pre>type Result error value<br/>    = Ok value<br/>    | Err error</pre>
<p>If an operation succeeds, the <kbd>Result</kbd> is <kbd>Ok</kbd>. Otherwise, the <kbd>Result</kbd> is <kbd>Err</kbd>. </p>
<p>To test drive <kbd>Result</kbd>, all that we need to do is run an operation that might fail. REPL is the perfect place for such a test. Thus, let's point our browser to <a href="http://elmrepl.cuberoot.in/">http://elmrepl.cuberoot.in/</a> and run the following:</p>
<pre><strong>import Date</strong><br/><strong>Date.fromString "2018-02-18"</strong></pre>
<p>Running the preceding in the REPL, will return the following:</p>
<pre><strong>Ok &lt;Sun Feb 18 2018 00:00:00 GMT+0000 (UTC)&gt; : Result.Result String Date.Date</strong></pre>
<p>Wonderful, we got back an <kbd>Ok</kbd> result from an operation that could have failed. Let's do it again, for good measure:</p>
<pre><strong>Date.fromString "0"</strong></pre>
<p>You might think that the preceding would fail, but it is actually completely valid:</p>
<pre><strong>Ok &lt;Sat Jan 01 2000 00:00:00 GMT+0000 (UTC)&gt; : Result.Result String Date.Date</strong></pre>
<p>Great, we still got back an <kbd>Ok</kbd>.  This time, let's use a string of letters, to make sure that the REPL can't handle it:</p>
<pre><strong>Date.fromString "abc"</strong></pre>
<p>And indeed, the REPL doesn't know how to deal with this input. However, instead of throwing an ugly exception, we get an elegant one:</p>
<pre><strong>Err "Unable to parse 'abc' as a date. Dates must be in the ISO 8601 format."</strong><br/><strong>    : Result.Result String Date.Date</strong></pre>
<p>To drive the point home, in the preceding example, we ran an expression that could potentially fail, that is, we ran the  <kbd>Date.fromString</kbd> function. The <kbd>Date.fromString</kbd> function takes a parameter of type <kbd>String</kbd>, and returns a <kbd>Date</kbd>. In the preceding code snippet, we gave it the String with the value of <kbd>abc</kbd>, and it returned an <kbd>Err</kbd> as the <kbd>Result</kbd>.</p>
<div><kbd>Result</kbd> has its own module, and that is why the type definition reads <kbd>Result.Result</kbd>.</div>
<p>Next, we'll look at working with <kbd>Maybe</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with Maybe</h1>
                
            
            
                
<p>Also a union type, <kbd>Maybe</kbd> is a way to deal with nothingness in Elm, or, put differently, with values that are optional, that is, which might, or might not exist. The official documentation, available at <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe">http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe</a>, gives the definition for the <kbd>Maybe</kbd> union type as follows:</p>
<pre>type Maybe a<br/>  = Just a<br/>  | Nothing</pre>
<p>As we discussed earlier in the book, using the letter  <kbd>a</kbd> in Elm is a convention, and it's a way to describe that the value used at that position can be anything. So the <kbd>a</kbd> in the preceding definition can be a <kbd>String</kbd>, an <kbd>Int</kbd>, or any other value.</p>
<p>So, in Elm, <kbd>Maybe</kbd> can be only one of two things— <kbd>Just</kbd> anything, or <kbd>Nothing</kbd>. More specifically, <kbd>Maybe</kbd> can be either one of these:</p>
<ul>
<li><kbd>Just</kbd> a <kbd>String</kbd>, or <kbd>Just</kbd> an <kbd>Int</kbd>, or <kbd>Just</kbd> a <kbd>Float</kbd>..., or</li>
<li><kbd>Nothing</kbd></li>
</ul>
<p> </p>
<p>Let's now turn to Elm REPL at <a href="http://elmrepl.cuberoot.in/">http://elmrepl.cuberoot.in/</a> and see the <kbd>Maybe</kbd> type in practice:</p>
<pre><strong>testingMaybe = Just 1</strong></pre>
<p>The REPL will return the following:</p>
<pre><strong>Just 1 : Maybe.Maybe number</strong></pre>
<p>As we can see, <kbd>Just 1</kbd> is a <kbd>Maybe number</kbd>. Let's do another one:</p>
<pre><strong>testingMaybe = Just 1.1</strong></pre>
<p>Running the preceding line will result in this:</p>
<pre><strong>Just 1.1 : Maybe.Maybe Float</strong></pre>
<p>Finally, let's see a <kbd>Nothing</kbd> in action:</p>
<pre><strong>testingMaybe = Nothing</strong></pre>
<p>REPL replies with the following:</p>
<pre><strong>Nothing : Maybe.Maybe a</strong></pre>
<p>Since <kbd>Nothing</kbd> has no value, we are back to <kbd>Maybe a</kbd>. Elm guarantees require us to have an <kbd>a</kbd> here, even though <kbd>Nothing</kbd> is <kbd>Nothing</kbd>, and since it represents the absence of value it does not need a type for its value.</p>
<p>To destructure a <kbd>Maybe</kbd>, we can use the <kbd>case-of</kbd> expression. Let's see an example of that using Ellie:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (Html, text)<br/><br/><br/>-- A person, but maybe we do not know their age.<br/>type alias Person =<br/>    { name : String<br/>    , age : Maybe String<br/>    }<br/>tom = { name = "Tom", age = Just "42" }<br/>sue = { name = "Sue", age = Nothing }<br/><br/><br/>main =<br/>    text &lt;| <br/>    case tom.age of <br/>        Nothing -&gt;<br/>            "No age for this person"<br/>        Just val -&gt;<br/>            val</pre>
<p>In the preceding example, we are using a slightly altered version of the person example available at the official documentation for <kbd>Maybe</kbd>. The difference in the preceding code is that instead of an <kbd>Int</kbd>, we are using a <kbd>String</kbd> for the <kbd>age</kbd> entry in our record. That way, we can avoid making our code any more complex than it needs to be, and we still return a <kbd>String</kbd> from all the branches in our <kbd>case-of</kbd> expression.</p>
<p>The app will print out <kbd>42</kbd> upon compilation. Now, let's change the app so that we are attempting to print Sue's age. The only difference to be made is listed as follows:</p>
<pre>case sue.age of</pre>
<p>This time, upon compilation, the app will pattern-match the <kbd>Nothing</kbd> branch of the <kbd>case-of</kbd> expression in <kbd>main</kbd>, and that will result in the <kbd>"No age for this person"</kbd> message printed on the screen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Result and Maybe with Defaults</h1>
                
            
            
                
<p><kbd>Result</kbd> and <kbd>Maybe</kbd> are quite similar. If our operation succeeds, we get an <kbd>Ok a</kbd> with <kbd>Result</kbd>. When dealing with <kbd>Maybe</kbd>, we get <kbd>Just a</kbd> if a value is present.</p>
<p>In case there was an error, for <kbd>Result</kbd> we get <kbd>Err error</kbd>. In case of no value in <kbd>Maybe</kbd>, we get <kbd>Nothing</kbd>. We have already looked at using <kbd>Result.withDefault</kbd> earlier in the book (in <a href="5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml">Chapter 4</a>, <em>Preparing a Unit Conversion Website in Elm</em>). Let's do a quick recap by running the following in Elm REPL:</p>
<pre><strong>Result.withDefault 0 (Ok 1)</strong></pre>
<p>The REPL responds with the following:</p>
<pre><strong>1 : number</strong></pre>
<p>Now let's try using <kbd>Strings</kbd>:</p>
<pre><strong>Result.withDefault "This is default." (Ok "This is OK")</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>"This is OK" : String</strong></pre>
<p>Similar to <kbd>Result</kbd>, we can also use <kbd>withDefault</kbd> on <kbd>Maybe</kbd>. Run the following in the REPL:</p>
<pre><strong>Maybe.withDefault 0 Nothing</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>0 : number</strong></pre>
<p>Let's do a couple more. First, let's give it a default <kbd>String</kbd>:</p>
<pre><strong>Maybe.withDefault "abc" Nothing</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>"abc" : String</strong></pre>
<p>How about a default <kbd>Record</kbd>?</p>
<pre><strong>Maybe.withDefault {} Nothing</strong></pre>
<p>Running the preceding code in the REPL will produce the following:</p>
<pre><strong>{} : {}</strong></pre>
<p>In the next section, we will work on our <kbd>update</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the update function</h1>
                
            
            
                
<p>Our <kbd>update</kbd> function will be a lot more complex. First, we need to cover all the preceding messages in our <kbd>update</kbd> function. We'll do that by adding a <kbd>case-of</kbd> expression:</p>
<pre>update msg model =<br/>    case msg of<br/>        GetTemp -&gt;<br/>            ( model, getTemperature model.city )<br/><br/>        NewTemp (Ok json) -&gt;<br/>            let<br/>                newTemperatureInfo =<br/>                    decodeTemperatureInfo json<br/>            in<br/>            ( { model | temperatureInfo = newTemperatureInfo }, Cmd.none )<br/><br/>        NewTemp (Err _) -&gt;<br/>            ( model, Cmd.none )<br/><br/>        CityInput city -&gt;<br/>            ( { model | city = city }, Cmd.none )</pre>
<p>In the preceding code snippet, we can see four possible cases for our <kbd>update</kbd> function. In case our <kbd>update</kbd> function receives the <kbd>GetTemp</kbd> message, it will return the two-tuple that has the <kbd>model</kbd> and the <kbd>getTemperature</kbd> value. </p>
<p>If the <kbd>update</kbd> function receives the <kbd>NewTemp (Ok json)</kbd> message, that is, if we successfully receive a JSON string from a remote server, then we use a <kbd>let-in</kbd> expression to return the same <kbd>model</kbd>, updated with the <kbd>newTemperatureInfo</kbd>.</p>
<p>The third pattern to match is the <kbd>NewTemp (Err _)</kbd>. This pattern will be matched in case we receive an error from the remote server, in which case we will just return the existing model - that is, <kbd>(model, Cmd.none)</kbd>.</p>
<p>The last possible message that we can pattern-match for in the <kbd>update</kbd> function, is the <kbd>CityInput</kbd> message. If we get a <kbd>CityInput</kbd> message, we will take the <kbd>city</kbd> String that gets passed to it, and return the existing model, plus the new <kbd>city</kbd> String.</p>
<p>However, if we ran our app now, the compiler would throw two errors:</p>
<ul>
<li>Cannot find variable <kbd>getTemperature</kbd></li>
<li>Cannot find variable <kbd>decodeTemperatureInfo</kbd></li>
</ul>
<p>Obviously, abstracting away complexity into separate variables is great to make it easier to reason about our app, but now we need to get into the actual implementation of <kbd>getTemperature</kbd> and <kbd>decodeTemperatureInfo</kbd>, in order to make our <kbd>update</kbd> function work. But before we can do that, we will need to look at decoders and encoders in greater detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Decoders and encoders</h1>
                
            
            
                
<p>To parse data from JSON, Elm uses decoders. To do the opposite, Elm uses encoders. Using decoders and encoders, we can translate data from dynamically typed JSON, to statically typed Elm data structures, and vice versa.</p>
<p>To begin, let's look at the <kbd>Json.Decode</kbd> package, available as part of the Elm language core. The official documentation for <kbd>Json.Decode</kbd> is available at: <a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode">http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode</a>. The official documentation defines a decoder as:</p>
<p>A value that knows how to decode JSON values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Decoding primitive values</h1>
                
            
            
                
<p>Let's look at a few examples of decoding primitive values, with the help of Elm REPL. To begin, let's decode a simple <kbd>Int</kbd>:</p>
<pre><strong>import Json.Decode exposing (..)</strong><br/><strong>decodeString int "100"</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>Ok 100 : Result.Result String Int</strong></pre>
<p>So, we get back a <kbd>Result</kbd>, which is a sign of an action that can potentially fail. Let's see how it fails, by providing a <kbd>Bool</kbd> to the preceding expression, instead of an <kbd>Int</kbd>:</p>
<pre><strong>decodeString int "true"</strong></pre>
<p>Running the preceding code results in the REPL returning the following:</p>
<pre><strong>Err "Expecting an Int but instead got: true" : Result.Result String Int</strong></pre>
<p>Next, let's decode a JSON <kbd>float</kbd> into an Elm <kbd>Float</kbd>:</p>
<pre><strong>decodeString float "1.234"</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>Ok 1.234 : Result.Result String Float</strong></pre>
<p>How about decoding a JSON <kbd>string</kbd> into an Elm <kbd>String</kbd>?</p>
<pre><strong>decodeString string "abcd"</strong></pre>
<p>This time, the REPL responds with the following:</p>
<pre><strong>Err "Given an invalid JSON: Unexpected token a" : Result.Result String String</strong></pre>
<p>Why is that error occuring? Because we need to provide escaped quotes as well, so as to make it work:</p>
<pre><strong>decodeString string "\"abcd\""</strong></pre>
<p>Now the REPL is not complaining:</p>
<pre><strong>Ok "abcd" : Result.Result String String</strong></pre>
<p>Finally, let's look at decoding a JSON boolean into an Elm <kbd>Bool</kbd>:</p>
<pre><strong>decodeString bool "false"</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>Ok False : Result.Result String Bool</strong></pre>
<p>Let's examine each of the decoders' signatures:</p>
<pre><strong>import Json.Decode exposing (..)</strong><br/><strong>int</strong><br/><strong>&lt;decoder&gt; : Json.Decode.Decoder Int</strong><br/><strong>float</strong><br/><strong>&lt;decoder&gt; : Json.Decode.Decoder Float</strong><br/><strong>string</strong><br/><strong>&lt;decoder&gt; : Json.Decode.Decoder String</strong><br/><strong>bool</strong><br/><strong>&lt;decoder&gt; : Json.Decode.Decoder Bool</strong></pre>
<p>As we can see in the preceding code snippet, <kbd>int</kbd> is a decoder for <kbd>Int</kbd>, <kbd>float</kbd> is a decoder for <kbd>Float</kbd>, <kbd>string</kbd> is a decoder for <kbd>String</kbd>, and <kbd>bool</kbd> is a decoder for <kbd>Bool</kbd>. Now that we understand how primitives are decoded from JSON into Elm, let's look at decoding a more complex JSON string, namely, the one that we got back from the API at the beginning of this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Decoding a JSON string returned from the API</h1>
                
            
            
                
<p>To begin, let's look at the JSON string that we got back from the API:</p>
<pre>{  <br/>   "coord":{  <br/>      "lon":-87.62,<br/>      "lat":41.88<br/>   },<br/>   "weather":[  <br/>      {  <br/>         "id":802,<br/>         "main":"Clouds",<br/>         "description":"scattered clouds",<br/>         "icon":"03n"<br/>      }<br/>   ],<br/>   "base":"stations",<br/>   "main":{  <br/>      "temp":268.9,<br/>      "pressure":1025,<br/>      "humidity":86,<br/>      "temp_min":267.15,<br/>      "temp_max":270.15<br/>   },<br/>   "visibility":16093,<br/>   "wind":{  <br/>      "speed":2.1,<br/>      "deg":260<br/>   },<br/>   "clouds":{  <br/>      "all":40<br/>   },<br/>   "dt":1518941700,<br/>   "sys":{  <br/>      "type":1,<br/>      "id":1030,<br/>      "message":0.0033,<br/>      "country":"US",<br/>      "sunrise":1518957687,<br/>      "sunset":1518996470<br/>   },<br/>   "id":4887398,<br/>   "name":"Chicago",<br/>   "cod":200<br/>}</pre>
<p>Obviously, we have formatted the JSON string so as to make it easier to read. The first thing to note is; we do not have to decode all of the preceding code. We can choose to decode only as much data as we need. So let's assume that the only piece of data that we are interested in is the second-to-last key-value pair, namely: <kbd>''name'':''Chicago''</kbd>.</p>
<p>How do we decode it out of the preceding chunk of JSON? We'll make a small Ellie app to see how this can be done:</p>
<pre>import Html exposing (..)<br/>import Json.Decode exposing (..)<br/><br/>main = text (toString (decodeString weatherDataDecoder (json)))<br/><br/>type alias WeatherData =<br/> { name : String }<br/><br/>json = """<br/>{ <br/> "coord":{ <br/> "lon":-87.62,<br/> "lat":41.88<br/> },<br/> "weather":[ <br/> { <br/> "id":802,<br/> "main":"Clouds",<br/> "description":"scattered clouds",<br/> "icon":"03n"<br/> }<br/> ],<br/> "base":"stations",<br/> "main":{ <br/> "temp":268.9,<br/> "pressure":1025,<br/> "humidity":86,<br/> "temp_min":267.15,<br/> "temp_max":270.15<br/> },<br/> "visibility":16093,<br/> "wind":{ <br/> "speed":2.1,<br/> "deg":260<br/> },<br/> "clouds":{ <br/> "all":40<br/> },<br/> "dt":1518941700,<br/> "sys":{ <br/> "type":1,<br/> "id":1030,<br/> "message":0.0033,<br/> "country":"US",<br/> "sunrise":1518957687,<br/> "sunset":1518996470<br/> },<br/> "id":4887398,<br/> "name":"Chicago",<br/> "cod":200<br/>}<br/>"""<br/><br/>weatherDataDecoder =<br/> Json.Decode.map<br/> WeatherData<br/> (field "name" string)</pre>
<p>The preceding little app successfully decodes the JSON string provided. As we can see, we are decoding only the <kbd>name</kbd> key from our JSON object, whose value, based on the JSON object provided previously, is <kbd>Chicago</kbd>. The result of compiling the app in the Ellie editor is displayed on the screen:</p>
<pre>Ok { name = "Chicago" }</pre>
<p>Let's see how we can improve on the preceding app. This time, we want to return not only the <kbd>name</kbd> key from our JSON object, but also the <kbd>id</kbd> key:</p>
<pre>import Html exposing (..)<br/>import Json.Decode exposing (..)<br/><br/><br/>main = text (toString (decodeString weatherDataDecoder (json)))<br/><br/><br/>type alias WeatherData =<br/>  { id : Int <br/>  , name : String <br/>  }<br/><br/>json = """<br/>{ <br/>   "coord":{ <br/>      "lon":-87.62,<br/>      "lat":41.88<br/>   },<br/>   "weather":[ <br/>      { <br/>         "id":802,<br/>         "main":"Clouds",<br/>         "description":"scattered clouds",<br/>         "icon":"03n"<br/>      }<br/>   ],<br/>   "base":"stations",<br/>   "main":{ <br/>      "temp":268.9,<br/>      "pressure":1025,<br/>      "humidity":86,<br/>      "temp_min":267.15,<br/>      "temp_max":270.15<br/>   },<br/>   "visibility":16093,<br/>   "wind":{ <br/>      "speed":2.1,<br/>      "deg":260<br/>   },<br/>   "clouds":{ <br/>      "all":40<br/>   },<br/>   "dt":1518941700,<br/>   "sys":{ <br/>      "type":1,<br/>      "id":1030,<br/>      "message":0.0033,<br/>      "country":"US",<br/>      "sunrise":1518957687,<br/>      "sunset":1518996470<br/>   },<br/>   "id":4887398,<br/>   "name":"Chicago",<br/>   "cod":200<br/>}<br/>"""<br/><br/>weatherDataDecoder =<br/>  Json.Decode.map2<br/>    WeatherData<br/>    (field "id" int)<br/>    (field "name" string)</pre>
<p>If we compiled the app now, we'd get a slightly different result from what we had last time:</p>
<pre>Ok { id = 4887398, name = "Chicago" }</pre>
<p>There are slight changes in the preceding app, which make it possible to extract two values, rather than just one, which we had in the previous version of our little JSON-decoding app. Let's look at the changes:</p>
<pre>type alias WeatherData =<br/>  { id : Int <br/>  , name : String <br/>  }</pre>
<p>In the <kbd>WeatherData</kbd> type alias, we added an <kbd>id</kbd> of type <kbd>Int</kbd> to our <kbd>Record</kbd>:</p>
<pre>weatherDataDecoder =<br/>  Json.Decode.map2<br/>    WeatherData<br/>    (field "id" int)<br/>    (field "name" string)</pre>
<p>In the decoders, we are using the <kbd>map2</kbd> function instead of the <kbd>map</kbd> function, and we are adding another JSON field, with the key of <kbd>id</kbd>, and the expected value of the JSON integer. Analog to what we have seen, in case we wanted to map over another value from our JSON object, we would need to use the <kbd>map3</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Decoding nested objects</h1>
                
            
            
                
<p>Let's say that we want to get the country information from the returned JSON. The change that we need to make to our decoder is simple: instead of <kbd>field</kbd>, we will use <kbd>at</kbd>. While <kbd>field</kbd> uses a string, <kbd>at</kbd> uses a list of strings, which allows us to go into the structure of a nested object. Let's update our Ellie app's <kbd>weatherDataDecoder</kbd> so that it looks as follows:</p>
<pre>weatherDataDecoder =<br/>  Json.Decode.map3<br/>    WeatherData<br/>    (field "id" int)<br/>    (field "name" string)<br/>    (at ["sys", "country"] string)</pre>
<p>Let's also update the <kbd>WeatherData</kbd> type alias:</p>
<pre>type alias WeatherData =<br/>  { id : Int <br/>  , name : String <br/>  , country: String<br/>  }</pre>
<p>Note that in the preceding code snippet, we are keeping our flat <kbd>Record</kbd> structure, and it does not reflect the JSON object that we get the data from. That is perfectly fine. Upon compilation, the app will print the following result to the screen:</p>
<pre>Ok { id = 4887398, name = "Chicago", country = "US" }</pre>
<p>Now that we understand how decoders work, and after a bit of practice with decoders, it should be a lot easier to understand the code that we will see in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding getTemperature and decodeTemperatureInfo</h1>
                
            
            
                
<p> Our <kbd>getTemperature</kbd> is a simple <kbd>let-in</kbd> expression, which will send a new request using <kbd>Http.send</kbd> and <kbd>Http.getString</kbd>, so as to obtain the weather data from a custom URL. The string of the custom URL to fetch the data from, depends on the <kbd>city</kbd> variable, that is, the value of the user input we get from the text input field of our app:</p>
<pre>getTemperature city =<br/>    let<br/>        url =<br/>            "http://api.openweathermap.org/data/2.5/weather?q=" ++ city ++ "&amp;APPID=b30c7031a64e301cb64ceaa346e24a83"<br/>    in<br/>    Http.send NewTemp (Http.getString url)</pre>
<p>The <kbd>decodeTemperatureInfo</kbd> is also a <kbd>let-in</kbd> expression, which, although possibly a bit scary-looking at first glance, is actually just a number of repetitions in trying to decode JSON data:</p>
<pre>decodeTemperatureInfo : String -&gt; TemperatureInfo<br/>decodeTemperatureInfo json =<br/>    let<br/>        name =<br/>            Result.withDefault "Error decoding data!" (Decode.decodeString (Decode.field "name" Decode.string) json)<br/><br/>        windSpeed =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "wind", "speed" ] Decode.float) json)<br/><br/>        temperature =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "temp" ] Decode.float) json)<br/><br/>        pressure =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "pressure" ] Decode.float) json)<br/><br/>        humidity =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "humidity" ] Decode.float) json)<br/>    in<br/>    TemperatureInfo name windSpeed temperature pressure humidity</pre>
<p>Basically, what's happening in the preceding code is—we are decoding the JSON string we received from the remote server, step by step. At this point, saving and running our app, we would see exactly the same window as before: Everything will go here, this time using Html.program.</p>
<p>That is a good sign. It means our app compiles successfully. It also means that there is more work to be done in the <kbd>view</kbd> and <kbd>main</kbd> functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the view</h1>
                
            
            
                
<p>Our <kbd>view</kbd> function is there to give us the visual representation of our model. For our app to work, the <kbd>view</kbd> function needs to have an input field, the submit button, and several values to be populated upon contacting the remote server and decoding the JSON string:</p>
<pre>view model =<br/>    div []<br/>        [ input [ placeholder "City", onInput CityInput ] []<br/>        , br [] []<br/>        , button [ onClick GetTemp ] [ text "Get temperature" ]<br/>        , br [] []<br/>        , div [] [ text "Name: ", text model.temperatureInfo.name ]<br/>        , div [] [ text "Temp: ", text (toString model.temperatureInfo.temperature) ]<br/>        , div [] [ text "Wind: ", text (toString model.temperatureInfo.windSpeed) ]<br/>        , div [] [ text "Pressure: ", text (toString model.temperatureInfo.pressure) ]<br/>        , div [] [ text "Humidity: ", text (toString model.temperatureInfo.humidity) ]<br/>        ]</pre>
<p>Let's look at how the preceding code works. We start off with the wrapping <kbd>div</kbd>. Next, we have the <kbd>input</kbd> function, which will have the placeholder word <kbd>City</kbd> in the text input field. We also have a message that this <kbd>input</kbd> function will emit, and the message is of <kbd>CityInput</kbd> type.</p>
<p>Next, we have the <kbd>br</kbd> function, and then the <kbd>button</kbd> function, which will emit the <kbd>GetTemp</kbd> message <kbd>onClick</kbd>. The next significant function is the <kbd>div</kbd> function, which will have the string of <kbd>''Name: ''</kbd> plus the value of <kbd>model.temperatureInfo.name</kbd>. Similarly, we follow it up with other <kbd>div</kbd> functions that concatenate strings together based on the values contained inside the current <kbd>model</kbd>.</p>
<p>Save everything and run your app. The result will be a fully working weather app that fetches a JSON string from a remote server and properly displays the result. To make the app fetch the data, it's enough to type a major city name into the input field, and click the button.</p>
<p>Before wrapping up this section, let's look at the complete weather app code:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)<br/>import Html.Events exposing (..)<br/>import Http<br/>import Json.Decode as Decode<br/><br/><br/>main =<br/>    Html.program<br/>        { init = init<br/>        , view = view<br/>        , update = update<br/>        , subscriptions = subscriptions<br/>        }<br/><br/><br/>type alias Model =<br/>    { temperatureInfo : TemperatureInfo<br/>    , city : String<br/>    }<br/><br/><br/>type alias TemperatureInfo =<br/>    { name : String<br/>    , windSpeed : Float<br/>    , temperature : Float<br/>    , pressure : Float<br/>    , humidity : Float<br/>    }<br/><br/><br/>init : ( Model, Cmd Msg )<br/>init =<br/>    ( Model (TemperatureInfo "Did not load" 0 0 0 0) ""<br/>    , Cmd.none<br/>    )<br/><br/><br/>type Msg<br/>    = GetTemp<br/>    | CityInput String<br/>    | NewTemp (Result Http.Error String)<br/><br/><br/>update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        GetTemp -&gt;<br/>            ( model, getTemperature model.city )<br/><br/>        NewTemp (Ok json) -&gt;<br/>            let<br/>                newTemperatureInfo =<br/>                    decodeTemperatureInfo json<br/>            in<br/>                ( { model | temperatureInfo = newTemperatureInfo }, Cmd.none )<br/><br/>        NewTemp (Err _) -&gt;<br/>            ( model, Cmd.none )<br/><br/>        CityInput city -&gt;<br/>            ( { model | city = city }, Cmd.none )<br/><br/><br/>view : Model -&gt; Html Msg<br/>view model =<br/>    div []<br/>        [ input [ placeholder "City", onInput CityInput ] []<br/>        , br [] []<br/>        , button [ onClick GetTemp ] [ text "Get temperature" ]<br/>        , br [] []<br/>        , div [] [ text "Name: ", text (model.temperatureInfo.name) ]<br/>        , div [] [ text "Temp: ", text (toString model.temperatureInfo.temperature) ]<br/>        , div [] [ text "Wind: ", text (toString model.temperatureInfo.windSpeed) ]<br/>        , div [] [ text "Pressure: ", text (toString model.temperatureInfo.pressure) ]<br/>        , div [] [ text "Humidity: ", text (toString model.temperatureInfo.humidity) ]<br/>        ]<br/><br/><br/>subscriptions : Model -&gt; Sub Msg<br/>subscriptions model =<br/>    Sub.none<br/><br/><br/>getTemperature : String -&gt; Cmd Msg<br/>getTemperature city =<br/>    let<br/>        url =<br/>            "http://api.openweathermap.org/data/2.5/weather?q=" ++ city ++ "&amp;APPID=b30c7031a64e301cb64ceaa346e24a83"<br/>    in<br/>        Http.send NewTemp (Http.getString url)<br/><br/><br/>decodeTemperatureInfo : String -&gt; TemperatureInfo<br/>decodeTemperatureInfo json =<br/>    let<br/>        name =<br/>            Result.withDefault "Error decoding data!" (Decode.decodeString (Decode.field "name" Decode.string) json)<br/><br/>        windSpeed =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "wind", "speed" ] Decode.float) json)<br/><br/>        temperature =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "temp" ] Decode.float) json)<br/><br/>        pressure =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "pressure" ] Decode.float) json)<br/><br/>        humidity =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "humidity" ] Decode.float) json)<br/>    in<br/>        TemperatureInfo name windSpeed temperature pressure humidity</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have covered a lot of new concepts, and reinforced some that we have learned about in the previous chapters. We have looked at using <kbd>Result</kbd> and <kbd>Maybe</kbd> to deal with operations that might fail and to deal with possibly missing data. We looked at using decoders and mapping over them. </p>
<p>We also looked at using the <kbd>Http</kbd> package to get remote JSON data. Now that we have set up the basics of our weather app, we will discuss ways of improving it in the next chapter.</p>


            

            
        
    </body></html>