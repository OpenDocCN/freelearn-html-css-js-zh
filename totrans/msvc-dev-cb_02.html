<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Edge Services</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Controlling access to your service with an edge proxy server</li>
<li>Extending your services with sidecars</li>
<li>Using API Gateway to route requests to services</li>
<li>Rate limiting with an edge proxy server</li>
<li>Stopping cascading failure with Hystrix</li>
<li>Using a service mesh to factor out shared concerns</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Now that you've had some experience breaking a monolith into microservices, you've seen that many of the challenges exist outside the monolith or service code bases themselves. Exposing your service to the internet, controlling routing, and building in resiliency are all concerns that can be addressed by what are commonly called <strong>edge services</strong>. These are services that exist at the edge of our architecture, generally handling requests from the public internet. Luckily, because many of these challenges are so common, open source projects exist to handle most of them for us. We'll use a lot of great open source software in this chapter.</p>
<p>With the recipes in this chapter, you'll learn how to use open source software to expose your services to the public internet, control routing, extend your service's functionality, and handle a number of common challenges when deploying and scaling microservices. You'll also learn about techniques for making client development against services easier and how to standardize the monitoring and observability of your microservice architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling access to your service with an edge proxy server</h1>
                </header>
            
            <article>
                
<p><span class="author-d-4z65zz66zl57z75zyiz66zfr2fz87zwz89znujgz72zva2qurwfz69zz78zz74zp0mz88zdz68z0hz89zmz65zz78zz86zlsz84z">In <a href="d5b36f18-79eb-4c0a-bbde-3e94733ef97c.xhtml" target="_blank">Chapter 1</a>, <em>Breaking the Monolith</em>, we modified a monolith code base to provide easy routing to our microservices. This approach works and requires little effort, making it an ideal intermediary step. Eventually, your monolith will become a bottleneck in the development and resiliency of your architecture. As you try to scale your service and build more microservices, your monolith will need to be updated and deployed every time you make an API change to your service. Additionally, your monolith will have to handle connections to your services and is probably not well-configured to handle edge concerns such as load shedding or circuit breaking. In the <em>Routing requests to services</em> recipe of <a href="d5b36f18-79eb-4c0a-bbde-3e94733ef97c.xhtml" target="_blank">Chapter 1</a>, <em>Breaking the Monolith</em>, we introduced the concept of edge proxies. Using an edge proxy server to expose your service to the public internet allows you to factor out most of the shared concerns a publicly exposed service must address. Requirements such as request routing, load shedding, back pressure, and authentication can all be handled in a single edge proxy layer instead of being duplicated by every service you need to have exposed to the internet.</span></p>
<p><span class=" author-d-4z65zz66zl57z75zyiz66zfr2fz87zwz89znujgz72zva2qurwfz69zz78zz74zp0mz88zdz68z0hz89zmz65zz78zz86zlsz84z">An edge proxy is a proxy server that sits on the edge of your infrastructure, providing access to internal services. You can think of an edge proxy as the</span> <span class=" author-d-4z65zz66zl57z75zyiz66zfr2fz87zwz89znujgz72zva2qurwfz69zz78zz74zp0mz88zdz68z0hz89zmz65zz78zz86zlsz84z h-ldquo">“</span><span class=" author-d-4z65zz66zl57z75zyiz66zfr2fz87zwz89znujgz72zva2qurwfz69zz78zz74zp0mz88zdz68z0hz89zmz65zz78zz86zlsz84z">front door” to your internal service architecture—</span><span class=" author-d-4z65zz66zl57z75zyiz66zfr2fz87zwz89znujgz72zva2qurwfz69zz78zz74zp0mz88zdz68z0hz89zmz65zz78zz86zlsz84z">it allows clients on the internet to make requests to internal services you deploy. There are multiple open source edge proxies that have a robust feature set and community, so we don't have to write and maintain our own edge proxy server. One of the most popular open source edge proxy servers is called <strong>Zuul</strong> and is built by Netflix. Zuul is an edge service that provides dynamic routing, monitoring, resiliency, security, and more. Zuul is packaged as a Java library. Services written in the Java framework Spring Boot can use an embedded Zuul service to provide edge-proxy functionality. In this recipe, we'll walk through building a small Zuul edge proxy and configuring it to route requests to our services.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operational notes</h1>
                </header>
            
            <article>
                
<p><span class="author-d-4z65zz66zl57z75zyiz66zfr2fz87zwz89znujgz72zva2qurwfz69zz78zz74zp0mz88zdz68z0hz89zmz65zz78zz86zlsz84z">Continuing with our example application from the previous chapter, imagine that our photo-messaging application (we'll call it <kbd>pichat</kbd> from now on) was originally implemented as a Ruby on Rails monolithic code base. When the product first launched, we deployed the application to Amazon Web Services behind a single <strong>Elastic Load Balancer</strong> (<strong>ELB</strong>). We created a single <strong>Auto Scale Group</strong> (<strong>ASG</strong>) for the monolith, called <kbd>pichat-asg</kbd>.</span></p>
<p><span class=" author-d-4z65zz66zl57z75zyiz66zfr2fz87zwz89znujgz72zva2qurwfz69zz78zz74zp0mz88zdz68z0hz89zmz65zz78zz86zlsz84z">Each EC2 instance in our ASG is running NGINX, which handles requests for static files (images, JavaScript, CSS) and proxies requests to unicorns running on the same host that is serving our Rails application. SSL is terminated at the ELB, and HTTP requests are forwarded to NGINX. The ELB is accessed through the DNS <kbd>monolith.pichat-int.me</kbd> name from within the <strong>Virtual Private Cloud</strong> (<strong>VPC</strong>).</span></p>
<p>We've now created a single <kbd>attachment-service</kbd>, which handles videos and images attached to messages being sent through the platform. The <kbd>attachment-service</kbd> is written in Java, using the Spring Boot platform and is deployed in its own ASG, called <kbd>attachment-service-asg</kbd>, that has its own ELB. We've created a private DNS record, called <kbd>attachment-service.pichat-int.me</kbd>, that points to this ELB.</p>
<p>With this architecture and topology in mind, we now want to route requests from the public internet to our Rails application or our newly created attachment service, depending on the path.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li><span>To demonstrate using Zuul to route requests to services, we'll first create a basic Java application that will serve as our edge proxy service. The Java project Spring Cloud provides an embedded Zuul service, making it pretty simple to create a service that uses the <kbd>zuul</kbd> library. We'll start by creating a basic Java application. Create the <kbd>build.gradle</kbd> file with the following content:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath "org.springframework.boot:spring-boot-gradle-plugin:1.4.4.RELEASE"<br/>        classpath "io.spring.gradle:dependency-management-plugin:0.5.6.RELEASE"<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/>apply plugin: 'io.spring.dependency-management'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencyManagement {<br/>    imports {<br/>        mavenBom 'org.springframework.cloud:spring-cloud-netflix:1.4.4.RELEASE'<br/>    }<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.4.4.RELEASE'<br/>    compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-zuul'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<ol start="2">
<li>Create a single class called <kbd>EdgeProxyApplication</kbd>. This will serve as the entry point to our application:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch02.edgeproxy;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.cloud.netflix.zuul.EnableZuulProxy;<br/><br/>@EnableZuulProxy<br/>@SpringBootApplication<br/>public class EdgeProxyApplication {<br/>    public static void main(String[] args) {<br/>        SpringApplication.run(EdgeProxyApplication.class, args);<br/>    }<br/>}</pre>
<ol start="3">
<li><span>Create a file called <kbd>application.yml</kbd> in the <kbd>src/main/resources</kbd> directory of your application. This file will specify your route configurations. In this example, we'll imagine that our monolith application can be accessed on the <kbd>monolith.pichat-int.me</kbd> internal host and we want to expose the <kbd>/signup</kbd> and <kbd>/auth/login</kbd> paths to the public internet:</span></li>
</ol>
<pre style="padding-left: 60px"><span>zuul:<br/> routes:<br/>  signup:<br/>   path: /signup<br/>   url: http://monolith.pichat-int.me<br/>  auth:<br/>   path: /auth/login<br/>   url: http://monolith.pichat-int.me</span></pre>
<ol start="4">
<li>Start the project with <kbd>./gradlew bootRun</kbd> and you should be able to access the <kbd>/signup</kbd> and <kbd>/auth/login</kbd> URLs, which will be proxied to our monolith application. </li>
<li>We want to expose the <kbd>attachment-service</kbd> URLs to the internet. The attachment service exposes the following endpoints:</li>
</ol>
<pre style="padding-left: 60px">POST / # Creates an attachment<br/>GET / # Fetch attachments, can filter by message_id<br/>DELETE /:attachment_id # Deletes the specified attachment<br/>GET /:id # Get the specific attachment</pre>
<ol start="6">
<li>We'll need to decide which paths we want to use in our public API. Modify <kbd>application.properties</kbd> to add the following entries:</li>
</ol>
<pre style="padding-left: 60px"><span>zuul:<br/> routes:<br/>  signup:<br/>   path: /signup<br/>   url: http://monolith.pichat-int.me<br/>  auth:<br/>   path: /auth/login<br/>   url: http://monolith.pichat-int.me</span><br/>  attachments:<br/>   path: /attachments/**<br/>   url: http://attachment-service.pichat-int.me</pre>
<ol start="7">
<li>Now all requests to <kbd>/attachments/*</kbd> will be forwarded to the attachment service and signup, and <kbd>auth/login</kbd> will continue to be served by our monolith application.</li>
</ol>
<p> </p>
<ol start="8">
<li>We can test this by running our service locally and sending requests to <kbd>localhost:8080/signup, localhost:8080/auth/login</kbd>, and <kbd>localhost:8080/attachments/foo</kbd>. You should be able to see that requests are routed to the respected services. Of course, the service will respond with an error because <kbd>attachment-service.pichat-int.me</kbd> cannot be resolved, but this shows that the routing is working as expected:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ curl -D - http://localhost:8080/attachments/foo</strong><br/><strong>HTTP/1.1 500</strong><br/><strong>X-Application-Context: application</strong><br/><strong>Content-Type: application/json;charset=UTF-8</strong><br/><strong>Transfer-Encoding: chunked</strong><br/><strong>Date: Tue, 27 Mar 2018 12:52:21 GMT</strong><br/><strong>Connection: close</strong><br/><br/><strong>{"timestamp":1522155141889,"status":500,"error":"Internal Server Error","exception":"com.netflix.zuul.exception.ZuulException","message":"attachment-service.pichat-int.me"}%</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending your services with sidecars</h1>
                </header>
            
            <article>
                
<p>When you start developing microservices, it's common to embed a certain amount of boilerplate into each service. Logging, metrics, and configuration are all functionalities that are commonly copied from service to service, resulting in a large amount of boilerplate and copied and pasted code. As your architecture grows and you develop more services, this kind of setup becomes harder and harder to maintain. The usual result is that you end up with a bunch of different ways of doing logging, metrics, service discovery, and so on, which results in systems that are hard to debug and maintain. Changing something as simple as a metrics namespace or adding a feature to your service discovery clients can require the coordination of multiple teams and code bases. More realistically, your microservices architecture will continue to grow with inconsistent logging, metrics, and service discovery conventions, making it harder for developers to operate, contributing to overall operational pain.</p>
<p>The sidecar pattern describes a pattern whereby you extend the functionality of a service with a separate process or container running on the same machine. Common functionalities, such as metrics, logging, service discovery, configuration, or even network RPC, can be factored out of your application and handled by a sidecar service running alongside it. This pattern makes it easy to standardize shared concerns within your architecture by implementing them in a separate process that can be used by all of your services.</p>
<p>A common method for implementing a sidecar is to build a small, separate process that exposes some functionality over a commonly used protocol, such as HTTP. Imagine, for instance, that you want all of your services to use a centralized service-discovery service instead of relying on DNS hosts and ports to be set in each application's configuration. To accomplish this, you'd need to have up-to-date client libraries for your service-discovery service available in all of the languages that your services and monolith are written in. A better way would be to run a sidecar parallel to each service that runs a service-discovery client. Your services could then proxy requests to the sidecar and have it determine where to send them. As an added benefit, you could configure the sidecar to emit consistent metrics around network RPC requests made between services. </p>
<p>This is such a common pattern that there are multiple open source solutions available for it. In this recipe, we'll use <kbd>spring-cloud-netflix-sidecar</kbd>, a project that includes a simple HTTP API that allows non-JVM applications to use JVM client libraries. The Netflix sidecar assumes you are using Eureka, a service registry designed to support the service-discovery needs of clients. We'll discuss service discovery in more detail in later chapters. The sidecar also assumes your non-JVM application is serving a health-check endpoint and will use this to advertise its health to Eureka. Our Rails application exposes such an endpoint, /health, which, when running normally, will return a small JSON payload with a key status and the <kbd>UP</kbd> value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Start by creating a basic Spring Boot service. Include the Spring Boot Gradle plugin and add dependencies for Spring Boot and the Spring Cloud Netflix sidecar project:</li>
</ol>
<pre style="padding-left: 60px">group <span>'com.packtpub.microservices'<br/></span>version <span>'1.0-SNAPSHOT'<br/></span><span><br/></span>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath <span>"org.springframework.boot:spring-boot-gradle-plugin:1.4.4.RELEASE"<br/></span><span>        </span>classpath <span>"io.spring.gradle:dependency-management-plugin:0.5.6.RELEASE"<br/></span><span>    </span>}<br/>}<br/><br/>apply <span>plugin</span>: <span>'java'<br/></span>apply <span>plugin</span>: <span>'org.springframework.boot'<br/></span>apply <span>plugin</span>: <span>'io.spring.dependency-management'<br/></span><span><br/></span><span>sourceCompatibility </span>= <span>1.8<br/></span><span><br/></span>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencyManagement {<br/>    imports {<br/>        <span>mavenBom </span><span>'org.springframework.cloud:spring-cloud-netflix:1.4.4.RELEASE'<br/></span><span>    </span>}<br/>}<br/><br/>dependencies {<br/>    compile <span>group</span>: <span>'org.springframework.boot'</span>, <span>name</span>: <span>'spring-boot-starter-web'</span>, <span>version</span>: <span>'1.4.4.RELEASE'<br/></span><span>    </span>compile <span>group</span>: <span>'org.springframework.cloud'</span>, <span>name</span>: <span>'spring-cloud-netflix-sidecar'</span>, <span>version</span>: <span>'1.4.4.RELEASE'<br/></span><span>    </span>testCompile <span>group</span>: <span>'junit'</span>, <span>name</span>: <span>'junit'</span>, <span>version</span>: <span>'4.12'<br/></span>}</pre>
<ol start="2">
<li>We're ready to create a simple Spring Boot application. We'll use the <kbd>@EnableSidecar</kbd> annotation, which also includes the <kbd>@EnableZuulProxy</kbd>, <kbd>@EnableCircuitBreaker</kbd>, and <kbd>@EnableDiscoveryClient</kbd> annotations:</li>
</ol>
<pre style="padding-left: 60px"><span>package </span>com.packtpub.microservices<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>EnableAutoConfiguration</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.sidecar.<span>EnableSidecar</span><span>;<br/></span><span>import </span>org.springframework.stereotype.<span>Controller</span><span>;<br/></span><span><br/></span><span>@EnableSidecar<br/></span><span>@Controller<br/></span><span>@EnableAutoConfiguration<br/></span><span>public class </span>SidecarController {<br/>    <span>public static void </span><span>main</span>(String[] args) {<br/>        SpringApplication.<span>run</span>(SidecarController.<span>class, </span>args)<span>;<br/></span><span>    </span>}<br/>}</pre>
<ol start="3">
<li>The Netflix sidecar application requires a few configuration settings to be present. Create a new file called <kbd>application.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px">server:<br/> port: 5678<br/><br/>sidecar:<br/> port: 3000<br/> health-uri: http://localhost:3000/health</pre>
<ol start="4">
<li>The sidecar will now expose an API that allows non-JVM applications to locate services registered with Eureka. If our <kbd>attachment-service</kbd> is registered with Eureka, the sidecar will proxy requests to <kbd>http://localhost:5678/attachment/1234</kbd> to <kbd>http://attachment-service.pichat-int.me/1234</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using API Gateways for routing requests to services</h1>
                </header>
            
            <article>
                
<p>As we've seen in other recipes, microservices should provide a specific business capability and should be designed around one or more domain concepts, surrounded by a bounded context. This approach to designing service boundaries works well to guide you toward simple, independently-scalable services that can be managed and deployed by a single team dedicated to a certain area of your application or business. </p>
<p>When designing user interfaces, clients often aggregate related but distinct entities from various backend microservices. In our fictional messaging application, for instance, the screen that shows an actual message might have information from a message service, a media service, a likes service, a comments service, and so on. All of this information can be cumbersome to collect and can result in a large number of round-trip requests to the backend.</p>
<p>Porting a web application from a monolith with server-side-rendered HTML to a single-page JavaScript application, for example, can easily result in hundreds of <kbd>XMLHttpRequests</kbd> for a single page load:</p>
<div class="CDPAlignCenter CDPAlign"><span class="packt_screen"><img src="assets/cfb729cb-f3d8-473f-affc-652421565438.png" style="width:26.58em;height:49.25em;"/><br/></span></div>
<p class="mce-root CDPAlignCenter CDPAlign CDPAlignLeft">To reduce the amount of round-trip requests to the backend services, consider creating one or more API Gateways that provide an API that is catered to the client's needs. API Gateways can be used to present a single view of backend entities in a way that makes it easier for clients who use the API. In the preceding example, a request to a single message endpoint could return information about the message itself, media included in the message, likes and comments, and other information.</p>
<p class="mce-root CDPAlignCenter CDPAlign CDPAlignLeft">These entities can be concurrently collected from various backend services using a fan-out request pattern:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/58af6302-bb02-46c3-860f-7385c987080a.png" style="width:39.42em;height:13.75em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design considerations</h1>
                </header>
            
            <article>
                
<p>One of the benefits of using an API Gateway to provide access to microservices is that you can create a single, cohesive API for a specific client. In most cases, you'll want to create a specific API for mobile clients, perhaps even one API for iOS and one for Android. This implementation of API Gateways is commonly referred to as the <strong>Backend for Frontend</strong> (<strong>BFF</strong>) because it provides a single logical backend for each frontend application. A web application has very different needs than a mobile device. </p>
<p>In our situation, we'll focus on creating one endpoint that provides all the data needed by the message-view screen. This includes the message itself as well as the attachment(s), the user details of the sender, and any additional recipients of the message. If the message is public, it can also have likes and comments, which we'll imagine are served by a separate service. Our endpoint could look something like this:</p>
<pre>GET /message_details/:message_id</pre>
<p>The endpoint will return a response similar to the following:</p>
<pre>{<br/>  "message_details": {<br/>    "message": {<br/>      "id": 1234,<br/>      "body": "Hi There!",<br/>      "from_user_id": "user:4321"<br/>    },<br/>    "attachments": [{<br/>      "id": 4543,<br/>      "media_type": 1,<br/>      "url": "http://..."<br/>    }],<br/>    "from_user": {<br/>      "username": "paulosman",<br/>      "profile_pic": "http://...",<br/>      "display_name": "Paul Osman"<br/>    },<br/>    "recipients": [<br/>      ...<br/>    ],<br/>    "likes": 200,<br/>    "comments": [{<br/>      "id": 943,<br/>      "body": "cool pic",<br/>      "user": {<br/>        "username": "somebody",<br/>        "profile_pic": "http://..."<br/>      }<br/>    }]<br/>  }<br/>}</pre>
<p>This response should have everything a client needs to show our message-view screen. The data itself comes from a variety of services, but, as we'll see, our API Gateway does the hard work of making those requests and aggregating the responses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>An API Gateway is responsible for exposing an API, making multiple service calls, aggregating the results, and returning them to the client. The <strong>Finagle Scala</strong> framework makes this natural by representing service calls as futures, which can be composed to represent dependencies. To stay consistent with other examples in this book, we'll build a small example gateway service in Java using the Spring Boot framework:</p>
<p class="mce-root"/>
<ol>
<li>Create the project skeleton. Create a new Java project and add the following dependencies and plugins to the Gradle build file. We'll be using Spring Boot and Hystrix in this recipe:</li>
</ol>
<pre style="padding-left: 60px">plugins {<br/>    id <span>'org.springframework.boot' </span>version <span>'1.5.9.RELEASE'<br/></span>}<br/><br/>group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>apply plugin: 'java'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.5.9.RELEASE'<br/>    compile group: 'com.netflix.hystrix', name: 'hystrix-core', version: '1.0.2'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<p style="padding-left: 60px">Looking at the JSON <span>example </span>in the previous section, it's clear that we are collecting and aggregating some distinct domain concepts. For the purposes of this example, we'll imagine that we have a message service that retrieves information about messages, including likes, comments, and attachments, and a user service. Our gateway service will be making a call to the message service to retrieve the message itself, then calls to the other services to get the associated data, which we'll stitch together in a single response. For the purposes of this recipe, imagine the message service is running on port <kbd>4567</kbd> and the user service on port <kbd>4568</kbd>. We'll create some stub services to mock out the data for these hypothetical microservices.</p>
<ol start="2">
<li>Create a model to represent our <kbd>Message</kbd> data:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.gateway.models;<br/><br/>import com.fasterxml.jackson.annotation.JsonIgnoreProperties;<br/>import com.fasterxml.jackson.annotation.JsonProperty;<br/><br/>@JsonIgnoreProperties(ignoreUnknown = false)<br/>public class Message {<br/><br/>    private String id;<br/>    private String body;<br/><br/>    @JsonProperty("from_user_id")<br/>    private String fromUserId;<br/><br/>    public String getId() {<br/>        return id;<br/>    }<br/><br/>    public void setId(String id) {<br/>        this.id = id;<br/>    }<br/><br/>    public String getBody() {<br/>        return body;<br/>    }<br/><br/>    public void setBody(String body) {<br/>        this.body = body;<br/>    }<br/><br/>    public String getFromUserId() {<br/>        return fromUserId;<br/>    }<br/><br/>    public void setFromUserId(String fromUserId) {<br/>        this.fromUserId = fromUserId;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">It's important that non-dependent service calls be done in a non-blocking, asynchronous manner. Luckily, Hystrix has an option to execute commands asynchronously, returning <kbd>Future&lt;T&gt;</kbd>.</p>
<ol start="3">
<li>Create a new package, say, <kbd>com.packtpub.microservices.gateway.commands</kbd> with the following classes:</li>
</ol>
<ul>
<li style="padding-left: 30px">Create the <kbd>AttachmentCommand</kbd> class with the following content:</li>
</ul>
<pre style="padding-left: 60px">package com.packtpub.microservices.gateway.commands;<br/><br/>import com.netflix.hystrix.HystrixCommand;<br/>import com.netflix.hystrix.HystrixCommandGroupKey;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>public class AttachmentCommand extends HystrixCommand&lt;String&gt; {<br/>    private String messageId;<br/><br/>    public AttachmentCommand(String messageId) {<br/>        super(HystrixCommandGroupKey.Factory.asKey("AttachmentCommand"));<br/>        this.messageId = messageId;<br/>    }<br/><br/>    @Override<br/>    public String run() {<br/>        RestTemplate template = new RestTemplate();<br/>        String attachmentsUrl = "http://localhost:4567/message/" + messageId + "/attachments";<br/>        ResponseEntity&lt;String&gt; response = template.getForEntity(attachmentsUrl, String.class);<br/>        return response.getBody();<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><span>Create the </span><kbd>CommentCommand</kbd> <span>class with the following content:</span></li>
</ul>
<pre style="padding-left: 60px">package com.packtpub.microservices.commands;<br/><br/>import com.netflix.hystrix.HystrixCommand;<br/>import com.netflix.hystrix.HystrixCommandGroupKey;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>public class CommentCommand extends HystrixCommand&lt;String&gt; {<br/><br/>    private String messageId;<br/><br/>    public CommentCommand(String messageId) {<br/>        super(HystrixCommandGroupKey.Factory.asKey("CommentGroup"));<br/>        this.messageId = messageId;<br/>    }<br/><br/>    @Override<br/>    public String run() {<br/>        RestTemplate template = new RestTemplate();<br/>        String commentsUrl = "http://localhost:4567/message/" + messageId + "/comments";<br/>        ResponseEntity&lt;String&gt; response = template.getForEntity(commentsUrl, String.class);<br/>        return response.getBody();<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><span>Create the </span><kbd>LikeCommand</kbd> <span>class with the following content</span>:</li>
</ul>
<pre style="padding-left: 60px">package com.packtpub.microservices.commands;<br/><br/>import com.netflix.hystrix.HystrixCommand;<br/>import com.netflix.hystrix.HystrixCommandGroupKey;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>public class LikeCommand extends HystrixCommand&lt;String&gt; {<br/><br/>    private String messageId;<br/><br/>    public LikeCommand(String messageId) {<br/>        super(HystrixCommandGroupKey.Factory.asKey("Likegroup"));<br/>        this.messageId = messageId;<br/>    }<br/><br/>    @Override<br/>    public String run() {<br/>        RestTemplate template = new RestTemplate();<br/>        String likesUrl = "http://localhost:4567/message/" + messageId + "/likes";<br/>        ResponseEntity&lt;String&gt; response = template.getForEntity(likesUrl, String.class);<br/>        return response.getBody();<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px">Our <kbd>MessageClient</kbd> class is a bit different than the previous examples—instead of returning the JSON string from the service response, it'll return an object representation, in this case, an instance of our <kbd>Message</kbd> class:</li>
</ul>
<pre style="padding-left: 60px">package com.packtpub.microservices.commands;<br/><br/>import com.netflix.hystrix.HystrixCommand;<br/>import com.netflix.hystrix.HystrixCommandGroupKey;<br/>import com.packtpub.microservices.models.Message;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>public class MessageClient extends HystrixCommand&lt;Message&gt; {<br/><br/>    private final String id;<br/><br/>    public MessageClient(String id) {<br/>        super(HystrixCommandGroupKey.Factory.asKey("MessageGroup"));<br/>        this.id = id;<br/>    }<br/><br/>    @Override<br/>    public Message run() {<br/>        RestTemplate template = new RestTemplate();<br/>        String messageServiceUrl = "http://localhost:4567/message/" + id;<br/>        Message message = template.getForObject(messageServiceUrl, Message.class);<br/>        return message;<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px">Create the <kbd>UserCommand</kbd> class with the following content:</li>
</ul>
<pre style="padding-left: 60px">package com.packtpub.microservices.commands;<br/><br/>import com.netflix.hystrix.HystrixCommand;<br/>import com.netflix.hystrix.HystrixCommandGroupKey;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>public class UserCommand extends HystrixCommand&lt;String&gt; {<br/><br/>    private String id;<br/><br/>    public UserCommand(String id) {<br/>        super(HystrixCommandGroupKey.Factory.asKey("UserGroup"));<br/>        this.id = id;<br/>    }<br/><br/>    @Override<br/>    public String run() {<br/>        RestTemplate template = new RestTemplate();<br/>        String userServiceUrl = "http://localhost:4568/user/" + id;<br/>        ResponseEntity&lt;String&gt; response = template.getForEntity(userServiceUrl, String.class);<br/>        return response.getBody();<br/>    }<br/>}</pre>
<ol start="4">
<li>Stitch together the execution of these Hystrix commands in a single controller that exposes our API as the <kbd>/message_details/:message_id</kbd> endpoint:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices;<br/><br/>import com.fasterxml.jackson.databind.ObjectMapper;<br/>import com.packtpub.microservices.commands.*;<br/>import com.packtpub.microservices.models.Message;<br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.http.MediaType;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.web.bind.annotation.PathVariable;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>import java.io.IOException;<br/>import java.io.StringWriter;<br/>import java.util.HashMap;<br/>import java.util.Map;<br/>import java.util.concurrent.ExecutionException;<br/>import java.util.concurrent.Future;<br/><br/>@SpringBootApplication<br/>@RestController<br/>public class MainController {<br/><br/>    @RequestMapping(value = "/message_details/{id}", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)<br/>    public Map&lt;String, HashMap&lt;String, String&gt;&gt; messageDetails(@PathVariable String id)<br/>            throws ExecutionException, InterruptedException, IOException {<br/><br/>        Map&lt;String, HashMap&lt;String, String&gt;&gt; result = new HashMap&lt;&gt;();<br/>        HashMap&lt;String, String&gt; innerResult = new HashMap&lt;&gt;();<br/><br/>        Message message = new MessageClient(id).run();<br/>        String messageId = message.getId();<br/><br/>        Future&lt;String&gt; user = new UserClient(message.getFromUserId()).queue();<br/>        Future&lt;String&gt; attachments = new AttachmentClient(messageId).queue();<br/>        Future&lt;String&gt; likes = new LikeClient(messageId).queue();<br/>        Future&lt;String&gt; comments = new CommentClient(messageId).queue();<br/><br/>        ObjectMapper mapper = new ObjectMapper();<br/>        StringWriter writer = new StringWriter();<br/>        mapper.writeValue(writer, message);<br/><br/>        innerResult.put("message", writer.toString());<br/>        innerResult.put("from_user", user.get());<br/>        innerResult.put("attachments", attachments.get());<br/>        innerResult.put("comments", comments.get());<br/>        innerResult.put("likes", likes.get());<br/><br/>        result.put("message_details", innerResult);<br/><br/>        return result;<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        SpringApplication.run(MainController.class, args);<br/>    }<br/>}</pre>
<ol start="5">
<li>There you have it. Run the service with <kbd>./gradlew bootRun</kbd> and test it by making a request to:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ curl -H "Content-Type: application/json" http://localhost:8080/message_details/1234 </strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stopping cascading failures with Hystrix</h1>
                </header>
            
            <article>
                
<p>Failures in a complex system can be hard to diagnose. Often, the symptom can appear far away from the cause. Users might start experiencing higher-than-normal error rates during login because of some downstream service that manages profile pictures or something else tangentially related to user profiles. An error in one service can often propagate needlessly to a user request and adversely impact user experience and therefore trust in your application. Additionally, a failing service can have cascading effects, turning a small system outage into a high-severity, customer-impacting incident. It's important when designing microservices to consider failure isolation and decide how you want to handle different failure scenarios.</p>
<p>A number of patterns can be used to improve the resiliency of distributed systems. Circuit breakers are a common pattern used to back off from making requests to a temporarily overwhelmed service. Circuit breakers were first described in Michael Nygard's book <em>Release It!</em>. A calling service defaults to a closed state, meaning requests are sent to the downstream service.</p>
<p>If the calling service receives too many failures too quickly, it can change the state of its circuit breaker to open, and start failing fast. Instead of waiting for the downstream service to fail again and adding to the load of the failing service, it just sends an error to upstream services, giving the overwhelmed service time to recover. After a certain amount of time has passed, the circuit is closed again and requests start flowing to the downstream service. </p>
<p>There are many available frameworks and libraries that implement circuit breakers. Some frameworks, such as Twitter's Finagle, automatically wrap every RPC call in a circuit breaker. In our example, we'll use the popular Netflix library, <kbd>hystrix</kbd>. Hystrix is a general-purpose, fault-tolerance library that structures isolated code as commands. When a command is executed, it checks the state of a circuit breaker to decide whether to issue or short circuit the request.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Hystrix is made available as a Java library, so we'll demonstrate its use by building a small Java Spring Boot application:</p>
<ol>
<li>Create a new Java application and add the dependencies to your <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><span>plugins {<br/>    id 'org.springframework.boot' version '1.5.9.RELEASE'<br/>}<br/><br/>group </span><span>'com.packetpub.microservices'<br/></span><span>version </span><span>'1.0-SNAPSHOT'<br/></span><span><br/></span>apply <span>plugin</span>: <span>'java'<br/></span><span><br/></span><span>sourceCompatibility </span>= <span>1.8<br/></span><span><br/></span>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.5.9.RELEASE'<br/>    compile <span>group</span>: <span>'com.netflix.hystrix'</span>, <span>name</span>: <span>'hystrix-core'</span>, <span>version</span>: <span>'1.0.2'<br/></span><span>    </span>testCompile <span>group</span>: <span>'junit'</span>, <span>name</span>: <span>'junit'</span>, <span>version</span>: <span>'4.12'<br/></span>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>We'll create a simple <kbd>MainController</kbd> that returns a simple message. This is a contrived example, but it demonstrates an upstream service making downstream calls. At first, our application will just return a hardcoded <kbd>Hello, World!</kbd> message. Next, we'll move the string out to a Hystrix command. Finally, we'll move the message to a service call wrapped in a Hystrix command:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.EnableAutoConfiguration;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>@SpringBootApplication<br/>@EnableAutoConfiguration<br/>@RestController<br/>public class MainController {<br/>    @RequestMapping("/message")<br/>    public String message() {<br/>        return "Hello, World!";<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        SpringApplication.run(MainController.class, args);<br/>    }<br/>}</pre>
<ol start="3">
<li>Move the message out to <kbd>HystrixCommand</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices;<br/><br/>import com.netflix.hystrix.HystrixCommand;<br/>import com.netflix.hystrix.HystrixCommandGroupKey;<br/><br/>public class CommandHelloWorld extends HystrixCommand&lt;String&gt; {<br/><br/>    private String name;<br/><br/>    CommandHelloWorld(String name) {<br/>        super(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"));<br/>        this.name = name;<br/>    }<br/><br/>    @Override<br/>    public String run() {<br/>        return "Hello, " + name + "!";<br/>    }<br/>}</pre>
<ol start="4">
<li>Replace the method in <kbd>MainController</kbd> to use <kbd>HystrixCommand</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><span>@RequestMapping</span>(<span>"/message"</span>)<br/><span>public </span>String <span>message</span>() {<br/>    <span>return new </span>CommandHelloWorld(<span>"Paul"</span>).execute()<span>;<br/></span>}</pre>
<ol start="5">
<li>Move the message generation to another service. We're hardcoding the hypothetical message service URL here, which is not a good practice but will do for demonstration purposes:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices;<br/><br/>import com.netflix.hystrix.HystrixCommand;<br/>import com.netflix.hystrix.HystrixCommandGroupKey;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>public class CommandHelloWorld extends HystrixCommand&lt;String&gt; {<br/><br/>    CommandHelloWorld() {<br/>        super(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"));<br/>    }<br/><br/>    @Override<br/>    public String run() {<br/>        RestTemplate restTemplate = new RestTemplate();<br/>        String messageResourceUrl = "http://localhost:4567/";<br/>        ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(messageResourceUrl, String.class);<br/>        return response.getBody();<br/>    }<br/><br/>    @Override<br/>    public String getFallback() {<br/>        return "Hello, Fallback Message";<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="6">
<li>Update the <kbd>MainController</kbd> class to contain the following:</li>
</ol>
<pre style="padding-left: 60px">package com.packetpub.microservices;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.EnableAutoConfiguration;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>@SpringBootApplication<br/>@EnableAutoConfiguration<br/>@RestController<br/>public class MainController {<br/><br/>    @RequestMapping("/message")<br/>    public String message() {<br/>        return new CommandHelloWorld().execute();<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        SpringApplication.run(MainController.class, args);<br/>    }<br/>}</pre>
<ol start="7">
<li>Our <kbd>MainController</kbd> class now makes a service call, wrapped in a Hystrix command, to generate a message to send back to the client. You can test this by creating a very simple service that generates a message string. <kbd>sinatra</kbd> is a simple-to-use Ruby library ideal for creating test services. Create a new file called <kbd>message-service.rb</kbd>:</li>
</ol>
<pre style="padding-left: 60px">require 'sinatra'<br/><br/>get '/' do<br/>  "Hello from Sinatra"<br/>end</pre>
<ol start="8">
<li>Run the service by running <kbd>ruby message-service.rb</kbd> and then make a few sample requests to your Hystrix-enabled service. You can simulate a failure by modifying the service to return a <kbd>503</kbd>, indicating that it is temporarily overwhelmed:</li>
</ol>
<pre style="padding-left: 60px">require 'sinatra'<br/><br/>get '/' do<br/>  halt 503, 'Busy'<br/>end</pre>
<p style="padding-left: 60px">Your Spring service should now attempt to reach the service but use the value in the fallback when it encounters a <kbd>503</kbd>. Furthermore, after a number of attempts, the command's circuit breaker will be tripped and the service will start defaulting to the fallback for a period of time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rate limiting</h1>
                </header>
            
            <article>
                
<p>In addition to techniques such as circuit breaking, rate limiting can be an effective way to prevent cascading failures in a distributed system. Rate limiting can be effective at preventing spam, protecting against <strong>Denial of Service</strong> (<strong>DoS</strong>) attacks, and protecting parts of a system from becoming overloaded by too many simultaneous requests. Typically implemented as either a global or per-client limit, rate limiting is usually part of a proxy or load balancer. In this recipe, we'll use NGINX, a popular open source load balancer, web server, and reverse proxy.</p>
<p>Most rate-limiting implementations use the <em>leaky-bucket algorithm</em>—an algorithm that originated in computer network switches and telecommunications networks. As the name suggests, the leaky-bucket algorithm is based on the metaphor of a bucket with a small leak in it that controls a constant rate. Water is poured into the bucket in bursts, but the leak guarantees that water exists in the bucket at a steady, fixed rate. If the water is poured in faster than the water exits the bucket, eventually the bucket will overflow. In this case, the overflow represents requests that are dropped.</p>
<p>It's certainly possible to implement your own rate-limiting solution; there are even implementations of the algorithms out there that are open source and available to use. It's a lot easier, however, to use a product such as NGINX to do rate limiting for you. In this recipe, we'll configure NGINX to proxy requests to our microservice. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li><span>I</span>nstall NGINX by running the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>apt-get install nginx</strong></pre>
<ol start="2">
<li><kbd>nginx</kbd> has a <kbd>config</kbd> file, <kbd>nginx.conf</kbd>. On an Ubuntu-based Linux system, this will probably be in the <kbd>/etc/nginx/nginx.conf</kbd> directory. Open the file and look for the <kbd>http</kbd> block and add the following content:</li>
</ol>
<pre style="padding-left: 60px">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;<br/>server {<br/>    location /auth/signin {<br/>        limit_req zone=mylimit;<br/>        proxy_pass http://my_upstream;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As you can see from the preceding code, rate limiting is implemented with two configuration directives. The <kbd>limit_req_zone</kbd> directive defines the parameters for rate limiting. In this example, we're implementing a rate limit, based on the client's IP address, of 10 requests per second. The <kbd>limit_req</kbd> directive applies our rate limiting to a specific path or location. In this case, we're applying it to all requests to <kbd>/auth/signin</kbd>, presumably because we don't want bots scripting the creation of accounts! </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using service mesh for shared concerns</h1>
                </header>
            
            <article>
                
<p>As web services' frameworks and standards evolve, the amount of boilerplate or shared application concerns is reduced. This is because, collectively, we figure out what parts of our applications are universal and therefore shouldn't need to be re-implemented by every programmer or team. When people first started networking computers, programmers writing network-aware applications had to worry about a lot of low-level details that are now abstracted out by the operating system's networking stack. Similarly, there are certain universal concerns that all microservices share. Frameworks such as Twitter's Finagle wrap all network calls in a circuit breaker, increasing fault tolerance and isolating failures in systems. Finagle and Spring Boot, the Java framework we've been using for most of these recipes, both support exposing a standard metrics endpoint that standardizes basic network, JVM, and application metrics collected for microservices.</p>
<p class="mce-root"/>
<p>Every microservice should consider a number of shared application concerns. From an observability perspective, services should strive to emit consistent metrics and structured logs. To improve the reliability of our systems, services should wrap network calls in circuit breakers and implement consistent retry and back-off logic. To support changes in network and service topology, services should consider implementing client-side load balancing and use centralized service discovery.</p>
<p>Instead of implementing all of these features in each of our services, it would be ideal to abstract them out to something outside our application code that could be maintained and operated separately. Like the features of our operating systems network stack, if each of these features is implemented by something our application could rely on being present, we would not have to worry about them being available. This is the idea behind a service mesh.</p>
<p>Running a service mesh configuration involves running each microservice in your system behind a network proxy. Instead of services speaking directly to one another, they communicate via their respective proxies, which are installed as sidecars. Practically speaking, your service would communicate with its own proxy running on localhost. As network requests are sent through a services proxy, the proxy can control what metrics are emitted and what log messages are output. The proxy can also integrate directly with your service registry and distribute requests evenly among active nodes, keeping track of failures and opting to fail fast when a certain threshold has been reached. Running your system in this kind of configuration can ease the operational complexity of your system while improving the reliability and observability of your architecture.</p>
<p>Like most of the recipes discussed in this chapter, there are numerous open source solutions for running a service mesh. We'll focus on <strong>Linkerd</strong>, an open source proxy server built and maintained by buoyant. The original authors of Linkerd worked at Twitter before forming buoyant and as such, Linkerd incorporates many of the lessons learned by teams at Twitter. It shares many features with the Finagle Scala framework, but can be used with services written in any language. In this recipe, we'll walk through installing and configuring Linkerd and discuss how we can use it to control communication between our Ruby on Rails monolith API and our newly developed media service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To demonstrate running a service behind a proxy, we'll install and run an instance of Linkerd and configure it to handle requests to and from your service. There are instructions on the Linkerd website for running it in Docker, Kubernetes, and other options. To keep things simple, we'll focus on running Linkerd and our service locally:</p>
<ol>
<li>Download the latest Linkerd release at <a href="https://github.com/linkerd/linkerd/releases">https://github.com/linkerd/linkerd/releases</a>. </li>
<li>Extract the tarball by executing the following command:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>$ tar xvfz linkerd-1.3.4.tgz</strong><br/><strong>$ cd linkerd-1.3.4</strong></pre>
<ol start="3">
<li>By default, <kbd>linkerd</kbd> ships with a configuration that uses file-based service discovery. We'll discuss alternatives to this approach next, but, for now, create a new file called <kbd>disco/media-service</kbd> with the following contents:</li>
</ol>
<pre style="padding-left: 60px">localhost 8080</pre>
<ol start="4">
<li>This maps the hostname and port to a service called <kbd>media-service</kbd>. Linkerd uses this file to look up services by name and determines the hostname and port mappings.</li>
<li>Run Linkerd as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ./linkerd-1.3.4-exec config/linkerd.yaml</strong></pre>
<ol start="6">
<li>Start the service on port <kbd>8080</kbd>. Change into the <kbd>media-service</kbd> directory and run the service:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>$ ./gradlew bootRun</span></strong></pre>
<ol start="7">
<li>Linkerd is running on port <kbd>4140</kbd>. Test that proxying is working with the following request:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ curl -H "Host: attachment-service" http://localhost:4140/</strong></pre>


            </article>

            
        </section>
    </body></html>