- en: Chapter 7. Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until this chapter, we learned the basic Ember.js concepts that equipped
    us with the necessary tools that enabled us to create full-fledged applications.
    From this chapter onwards, we will be guided through creating all sorts of sophisticated
    applications as we explore more advanced Ember.js features. This chapter will
    introduce us to Ember.js components, which enable us to create custom reusable
    elements, and will cover the following topics in this regard:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using components as template layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining actions inside a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing a component with the rest of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A web component is a reusable custom HTML tag. The World Wide Web Consortium
    is already working on custom web element (web components) specifications ([http://www.w3.org/TR/components-intro/](http://www.w3.org/TR/components-intro/))
    that will allow developers to create these custom HTML elements with custom behaviors
    as opposed to always relying on the provided standard HTML elements. This specification
    is still being worked on, but there are a number of JavaScript open source projects
    (shims) that can get you started before this specification is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Polymer**, available at [http://www.polymer-project.org/](http://www.polymer-project.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facebook React**, available at [http://facebook.github.io/react/docs/component-api.html](http://facebook.github.io/react/docs/component-api.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ember.js components**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ember.js provides mechanisms that will allow developers to create and complete
    these components in the near future of web technology. Once web components are
    standardized, Ember.js will continue enabling the easy creation of these custom
    elements. It's therefore an added advantage to start utilizing the Ember.js component
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components are a higher-level construct of Ember.js views, and therefore, to
    define one, we''ll need to define either or both of the following two Ember.js
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: The component's class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component's template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class is usually extended from the `Ember.Component` class in the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `component` template is then defined and named using Ember.js conventions.
    For example, the template for the preceding component will be named as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The bundled sample of this chapter includes a simple application that utilizes
    several components. This application allows users to upload and rate photos as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a component](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The application defines the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Post input component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post date component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post rating component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User post component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post photo component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We already noticed that some of these components were defined by either a class
    or a template. For example, the `user-post` component did not define a class.
    Also, the template names were namespaced using a hyphen, while the class names
    were camelized. Therefore, it would have been incorrect to register the `user-post`
    component template as `userpost`. This rule corresponds to one of the following
    component attributes described by W3C:'
  prefs: []
  type: TYPE_NORMAL
- en: Component custom elements must be namespaced by a hyphen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components are sandboxed but can communicate through events. Therefore, the
    component and the host DOM JavaScript cannot manipulate each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hence, the `post-input` component class and template, for example, were defined
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once defined, a component can be included into any application template using
    the Handlebars expressions. For example, the first component is a button that
    is used to prompt the user to select an image from the disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our router defines the `photos` route that handled requests at the home
    path as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, all we need to do is include the component in the corresponding
    `photos` template as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the `components` template being swapped, resulting in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Do not worry about how the resulting element is a button. The important thing
    to note is that we just defined and used a custom HTML element without worrying
    about its underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating components from views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed, you might be wondering why components and views are different
    since both wrap templates. Well, components are indeed a subclass of views, but
    their controller context is isolated from the rest of the application. While application
    controllers can be assigned to any view, the defined component classes cannot
    be assigned to other components or views. Components define an interface the desired
    context must implement, and they are therefore more reusable and modular, as we
    will see in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Passing properties to components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we just mentioned that components are isolated from the rest of the application,
    there is room for them to communicate with the host application in several ways.
    First, they''re able to bind to proprieties in the host template context. For
    example, we just mentioned that the preceding button component is used to prompt
    the user to upload images. The component requires that an enumerable property,
    which will act as the photo store, be bound to its `posts` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the component will be able to store the provided photos, as we will
    discuss in a later section. These selected photos will then be displayed to the
    user in the same template as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used yet another component, `user-post`, which rendered a given photo
    into the included page portion. Again, we did not need to worry about the underlying
    implementation of the component. We only needed to satisfy its interface's requirement
    of binding a photo to its `post` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how these components used the bound properties, let''s consider
    the `post-date` component that was used by the just discussed `user-post` component
    to display a humanized format of the post''s date. This component contains a single
    expression that displays the formatted date as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression is a computed property that uses the Moment.js library ([http://momentjs.com](http://momentjs.com))
    to format the date and is defined in the corresponding class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependent date property is then bound in the `user-post` component as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Customizing a component's element tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the W3C component specification is still being worked on, Ember.js components
    utilize the existing standard HTML elements. In [Chapter 3](part0029_split_000.html#page
    "Chapter 3. Routing and State Management"), *Routing and State Management*, we
    learned that a view's template is wrapped around an element, which by default
    is `div`. This element can then be customized using the view's `tagName` property.
    A component's template is also wrapped in the same way in a customizable element.
    For example, we promised to discuss how the `post-input` component mentioned previously
    was rendered into DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is define the property in the corresponding class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Customizing a component's element class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since components are views, their element''s class can be specified statically
    or dynamically using the `classNames` and `classNameBindings` array properties
    on the component''s class. For example, the `post-input` component defines a static
    class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the component being rendered as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the sample application, we mentioned that users are able to rate uploaded
    photos. The `user-post` component uses the `post-rating` component that serves
    as the rating widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the stars in the latter part is also a component (`post-rating-item`)
    and is listed horizontally to compose the widget as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the colored stars represent the range of the rating, and so, we
    use the `active` class in this case to style them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of a dynamic class where the component will only acquire
    the class if the defined computed `active` class evaluates to `True`. We will
    discuss how this rating works in a later section, but one last thing to note is
    that in the case of dynamic classes, we can specify the class name to use. For
    example, we can implement the preceding case as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also implement it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Customizing a component's element attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A component''s element attribute values can also be bound to properties using
    the `attributeBindings` property. For example, consider our `post-photo` component
    that displays the images as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we use the `tagName` property to specify that its element is an image
    tag. We also specify that this element will have an `src` attribute that will
    be aliased to the bound `photo` property. The `user-post` component then uses
    this component to display the images as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to compare how the following element concepts are customized across
    views, components, and even templates:'
  prefs: []
  type: TYPE_NORMAL
- en: Tag names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing events in components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like views, components can catch user-generated events such as those from
    the keyboard, mouse, and touch devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways in which the handlers to these events can be defined, the
    first of which is to attach the `.on` function to the event-subscriber method.
    For example, the `post-input` component uses this function to define two handlers.
    This button component implements a file-picker dialog that can be opened from
    an invisible file input, as described at [https://github.com/component/file-picker](https://github.com/component/file-picker).
    As soon as the component gets rendered, the event is fired, which results in the
    hidden form element containing a single input file to be appended into DOM as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This form will be used later to upload the images. Next, we define the handler
    that will initiate the file dialog to open. Note that we use the `.on` method
    to subscribe to the button''s click event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this handler, we set up a listener that will get invoked when the user
    selects an image file, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the handler which does the upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This last handler adds the image to the photo controller as a new post. Note
    that we don't check the mime type of the uploads, so the user might upload other
    media types, such as videos. This check is left out as an implementation exercise
    to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we subscribe to these events to implement a method whose name corresponds
    to the target event, as shown by the rating widget component previously discussed.
    This component keeps count of the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selected`: This is the selected/hovered star position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_selected`: This is the cached position of the last clicked star'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We mentioned that the widget is composed of the `post-rating-item` components
    that represent each of the stars. When the user hovers over any of them, we updated
    the `selected` property of the parent component as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, we defined a method that corresponded to the `mouseEnter` event.
    This handler sets the `active` property of all the rating item components to the
    left to `True`, since the trick here is to apply the style, as expected, to all
    stars to the left-hand side of the currently selected one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, those to the right-hand side lose the `active` class because
    their `active` property gets recalculated to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user doesn''t click on any of the stars, they expect the earlier rating
    to be restored. Therefore, leaving the currently focused component uses the cached
    `_selected` property to reset the `selected` property, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we only need to implement the `mouseLeave` event hook. Lastly, clicking
    on any of the components gives us the actual rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we cache the `_selected` property of the parent component since this
    will be used in the preceding checks. The `active` class updates the components
    state appropriately as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Defining component actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned that components define classes that act as their controllers that
    are isolated from the rest of the application. For example, an application controller
    cannot define a component class as a dependency in its `needs` property. However,
    since they are considered as controllers, they can define handlers to action expressions
    defined in their corresponding templates in an `actions` object property. For
    example, let''s define a message box component that can be used in any application
    that needs to implement the chat functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this component, one simply needs to provide the `Messages` container
    in which new messages will be stored. Here''s a possible example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The component form defines an action that binds the `save` action handler of
    the component class to the form's `submit` event. When the user submits the form
    by hitting the *Enter* key, the handler sanitizes the message before pushing it
    to the provided container. You'll realize that these actions are similar to the
    ones we learned earlier in [Chapter 4](part0044_split_000.html#page "Chapter 4. Writing
    Application Templates"), *Writing Application Templates*. However, there's no
    event bubbling in components. A failure to locate the handler in the class will
    lead to an appropriate error being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing a component with the rest of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components, as mentioned earlier, are not completely sandboxed, but they can
    interact with the rest of the application in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Bind to properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have already seen how components are able to bind to other application properties
    by passing the properties in the template expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Components also have the ability to send their actions to controllers in an
    application. To demonstrate this, let''s create a simple checkout button for an
    e-commerce site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we intend to add a product to cart whenever its corresponding
    checkout button is clicked via an event handler. We utilize the component''s `sendAction`
    method to bubble this action to the parent controller. However, there are two
    things we need to fix in order to realize this. First, we need to rename our event
    handler in the controller to something descriptive. Moreover, the same `click`
    event handler can catch events from other elements as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to send the selected product to the `addToCart` handler with
    a little modification of the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This just lets the component be able to access the product. Finally, we send
    the product to the controller event handler as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first argument to `sendAction` is always `action` followed by
    the object(s) we wish to send.
  prefs: []
  type: TYPE_NORMAL
- en: Components as layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A component''s template can act as a layout for other application templates.
    These layouts are not specified in the view layer; they use block expressions
    instead. Additional content can then be inserted inside these templates without
    losing scope. For example, imagine we wish to create a component that will use
    the `content-editable` element. This kind of component will need to wrap a section
    of some HTML content as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, the component uses custom Handlebars tags that match its namespaced
    template name. The content inside and outside the component will still enjoy the
    same scope. Can you guess how this component will be implemented? One implementation
    will be to turn the wrapped content into `content-editable` when double-clicked
    or focused, and back to `div` when the mouse leaves the element as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The two event-defined handlers toggle the `isEditing` property, which then results
    in the `content-editable` attribute to be added or removed from the element accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a little interesting, imagine we want to upgrade our `content-editable`
    component into a WYSIWYG editor. We will need to define a template that is used
    to host the different controls to manipulate the content, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a toolbar that will house standard editor controls. We can
    bind action handlers, as discussed in the previous sections, to perform the manipulations;
    this will be a worthy attempt by the reader. In the content section, we use the
    `yield` expression we discussed in the previous chapter to tell the component
    to render the wrapped content in this portion of the template. With this powerful
    feature, both the component and the wrapped content can define expressions that
    bind to isolated contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll find components useful when you want to modularize your application.
    There are various open source tools that will enable you to ship these components
    to your application. In the last chapter of this book, we will learn how to ship
    these components and mixins into your application using the component''s ([http://github.com/component](http://github.com/component))
    asset manager and build. Therefore, it''s best practice to abstract modular objects
    in your application into either mixins or components. The following are some of
    the things we learned about components:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing component elements and attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing actions inside components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing components with the rest of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to sync data between Ember.js applications
    and REST backends. We will particularly learn how to use Ember.js data to simplify
    this need.
  prefs: []
  type: TYPE_NORMAL
