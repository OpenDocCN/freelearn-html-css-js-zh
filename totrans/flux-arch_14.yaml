- en: Chapter 14. Flux and the Software Development Lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux is about information architecture, first and foremost. This is the reason
    that Flux is a set of patterns instead of a framework implementation. When we
    design front-end architectures that scale, the specific implementation matters
    very little, relative to the design of the overall system. It's things like unidirectional
    data-flows and synchronous update rounds that have a lasting impact on the scalability
    of the system. In fact, Flux can be influential enough that it changes the way
    we develop our software.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we'll look at the software development lifecycle through the
    lens of Flux. We'll open the chapter with a discussion on the open-ended possibilities
    with Flux implementations. Then we'll compare the types of development activities
    that take place at the beginning of a new Flux project with what happens with
    a maturing Flux project.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also think about the concepts that make Flux appealing to begin with,
    and how to extract these ideas and apply them to other software systems. Lastly,
    we'll end the chapter with a look at creating monolithic Flux systems versus packaging
    Flux components.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is open to interpretation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One problem with JavaScript frameworks is that they're just one instantiation
    of a full spectrum of possible solutions. One solution isn't as universal as we
    might hope. Even a specification such as Flux that contains just a handful of
    patterns is open for interpretation. The fact that they're just patterns makes
    it easier for one group to go and implement their software one way, while another
    group uses the same patterns to implement their software how they see fit.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll reiterate the fact that Flux is just a set of patterns
    to follow. We'll revisit the possibility of using a Flux library, each of which
    has a different take on implementing the Flux patterns. Then we'll consider the
    trade-offs of implementing our own Flux components.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation option 1 – just the patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flux is just patterns for us to follow. We might not even follow them exactly.
    Pattern efficacy isn't what's important—what's important is that we get the fundamental
    value of Flux out of our design. For example, actions describe something that
    has happened, and they carry with them a payload of new data to enter the system.
    Once the new data has been dispatched, it continues in one direction until it
    is rendered. Flux just happens to use the concept of a dispatcher and a store.
    We could call our implementation of Flux a conveyor belt if we wanted to. If the
    data-flow is unidirectional and predictable, then we've met one Flux goal.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, we can implement the dispatcher and the store components to our liking.
    There are probably tweaks that we could make to a store component that would better
    serve our application. These could be for performance reasons, or they could be
    simple developer conveniences. Either of these things are fine to introduce, as
    long as the data-flow stays unidirectional and synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: These ideas of unidirectional data-flow and synchronous update rounds aren't
    unique to Flux. We could work within the confines of other architectures, such
    as MVC, and achieve the same principles. What is unique about Flux is that it
    was born out of frustration. Engineers at Facebook decided that they needed a
    vehicle to explicitly state just how to get these design principles right.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation option 2 – use a Flux library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We certainly don't have to implement every Flux component ourselves. There's
    plenty of choice out there when it comes to Flux libraries. What's interesting
    is that this Flux library ecosystem reinforces the assertion that Flux is open
    to interpretation. Perhaps the best example of this is Redux. This library is
    not an implementation of the concepts outlined in the Flux documentation. Instead,
    Redux takes a different route to implementing Flux principles.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there's no dispatcher in Redux, and we can only create one store,
    which consists of reducer functions. What's important is that we still get the
    unidirectional data-flow and that the update rounds are synchronous. Then there's
    `Alt.js`, which takes a more traditional approach to implementing Flux in that
    it has the same abstractions as outlined in the Flux documentation. But `Alt.js`
    also builds its own ideas on top of these concepts to make implementing Flux that
    much easier and more enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Is it all-or-nothing when we decide to leverage a Flux library? Not necessarily.
    This fear of all-or-nothing stems from monolithic frameworks that prescribe a
    certain way of doing things, and there's no easy way to work around these. With
    libraries, the idea is to be able to pick and choose the bits that you need in
    order to compose larger behavior. Take the view layer in a Flux architecture—this
    is most commonly made up of React components. However, neither Redux or `Alt.js`
    require that we use React. Redux is small enough that we can just use its store
    component for our application state, and `Alt.js` has several smaller modules
    that we can pick and choose from—there are probably several that we'll never use.
  prefs: []
  type: TYPE_NORMAL
- en: Roll your own Flux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that there are so many approaches to implementing a Flux system, is there
    any utility in implementing our own? In other words, would we be re-inventing
    the wheel by rolling our own Flux components instead of depending on one of the
    many Flux libraries out there? Not at all. There's a strong possibility that none
    of the Flux libraries meet the needs of what we're trying to accomplish. Or maybe
    there are several things about the Flux components that we want to customize,
    so that it makes less sense to depend on an implementation that we're going to
    change completely.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the code in this book has been based on our own implementations of Flux
    components. We've relied on the reference implementation of the Flux dispatcher,
    but then we went and implemented our own, without much difficulty. The positive
    aspect of implementing our own Flux components is that we have the freedom to
    tweak the components to meet the needs of our application as it evolves. This
    is more difficult to do when we depend on someone else's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: One possibility is that we use a library like `Alt.js` for inspiration for rolling
    our own implementation. This way, we can implement the cool features from that
    library while modifying them as we see fit. On the other hand, we could be better
    off just using a Flux library as-is. The best bet is to think about this sort
    of thing while you're building a skeleton Flux architecture. Don't depend on any
    libraries upfront, but decide early on if you're going to use something like Redux,
    so you don't have to throw out too many components.
  prefs: []
  type: TYPE_NORMAL
- en: Development methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at the development methodologies that take place
    at different stages of a Flux project. Keep in mind that these are just guidelines,
    as methodologies can vary quite drastically from team to team. If two different
    teams are implementing a Flux system, there will no doubt be some commonalities.
  prefs: []
  type: TYPE_NORMAL
- en: First we'll think about what happens during the initial phases of a new Flux
    project. Then we'll think about Flux projects that have had a chance to mature,
    and what the process might look like for adding a new feature to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Upfront Flux activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many software development methodologies frown upon big upfront design. The reason
    is simple—we spend too much time designing before any software is written and
    tested. Incrementally delivering pieces of software gives us a chance to validate
    any assumptions we may have made while writing code. The question is, does Flux
    require big upfront design, or can we incrementally implement parts of a Flux
    system?
  prefs: []
  type: TYPE_NORMAL
- en: As you saw earlier in the book, the first step to designing a Flux architecture
    is writing code. At first, we're only interested in producing a skeleton architecture
    so that we can get a feel for the types of information our components will need.
    We don't spend time implementing UI components initially, because doing so will
    likely be a time sink and a distraction from thinking about the other Flux components
    that we'll need—such as stores and actions.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, can building a skeleton architecture fit into the regular flow
    of developing software without being big on upfront design? I think so.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to spend too much time on a skeleton architecture, because that's
    just a recipe for bike-shedding. We could, however, set sprint goals for building
    pieces of the skeleton architecture and reviewing with a larger group. Something
    like a sprint demo might actually be the ideal forum to decide whether or not
    we've built enough of the skeleton architecture and whether we're happy with it.
    Then it's time to start building features in earnest.
  prefs: []
  type: TYPE_NORMAL
- en: Maturing a Flux application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've moved well beyond the skeleton architecture phase, we hopefully have
    in place a solid product with features that our customers will enjoy using. Ideally,
    this means that we've hit a sweet spot with our Flux architecture—it scales well,
    it's easy to maintain, and we're able to keep our customers happy by delivering
    new features. The application is mature, in other words. So how did we get to
    this point, and how do we keep it going?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a feature that we''ve been asked to build. We have a team of
    all-purpose programmers to build it. How should we go about decomposing the feature
    into implementation tasks? Flux makes this fairly easy to figure out, because
    there are a limited number of component types. So if we can get a small team assembled
    to deliver a feature, then one person can focus on implementing the views, another
    on the stores and actions, and another to build the back-end data services. Here''s
    an illustration of a team and the Flux components they build to realize a feature
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Maturing a Flux application](img/B05419_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An alternative approach would be to have teams that focus on the same types
    of components. For example, a store team would be spread across features but each
    member would work on a store component at any given time. This approach is inferior
    because a team of Flux programmers working on the same deliverable have collective
    insight into how the feature is going to provide maximum customer value.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing ideas from Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux forces us to think about the information architecture of our application
    in new and interesting ways. Rarely does adopting a new approach like this happen
    in a vacuum. The ideas tend to spread to other parts of the technology stack.
    With Flux, it's the architectural principles of data-flow direction and feature-driven
    information that stand out as having a positive impact. If these things can have
    a positive impact on the frontend code, why couldn't they influence the design
    of the system as a whole?
  prefs: []
  type: TYPE_NORMAL
- en: Unidirectional data flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The unidirectional flow of data through a Flux architecture is probably the
    key aspect that enables it to scale. By itself, unidirectional data-flow makes
    the code we write easy to reason about. In places, this approach can be a little
    more verbose, but this is a conscious trade-off that we make in order to facilitate
    predictability. For example, with the two-way data binding capabilities found
    in some frameworks, we can get away with writing less code. This, however, is
    a developer convenience that trades off predictability.
  prefs: []
  type: TYPE_NORMAL
- en: This is the type of lesson from Flux that may in fact be applicable to other
    areas of our technology stack. For example, are there pieces of code that are
    difficult to reason about because the data that flows through them moves in several
    directions? Can we change that?
  prefs: []
  type: TYPE_NORMAL
- en: It might be hard to enforce unidirectional data-flows to the extent that Flux
    does, but we can at least think about the benefits that this brings to the front-end
    of the application and try to apply the same principles to other code. For instance,
    maybe we can't get a unidirectional data-flow in place but we can slim down the
    component by removing flows that are particularly difficult to predict.
  prefs: []
  type: TYPE_NORMAL
- en: Information design is king
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flux architectures start with information that the user interacts with, and
    work their its way backward, toward the API. This approach is different from other
    front-end architectures where you have the API entities, and you then create front-end
    models, and the views (or view models) figure out the transformations necessary
    to create information that's relevant to the user. The challenge with putting
    information first is that we might come up with something that's just not feasible
    from the API perspective.
  prefs: []
  type: TYPE_NORMAL
- en: However, if this is the case then we probably have a dysfunctional team structure
    to begin with, because it's easy to isolate oneself in one's own technology bubble
    (back-end, network, front-end, and so on), but this simply does not work in a
    feature-driven product. All contributing members need to know what's going on
    in every layer of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: If we can sort out the teams so that each contributor is fully aware of what's
    happening in the various parts of the code-base, then we can adopt an *information
    is king* attitude toward feature development. Flux works well for this, and it
    turns out that this is actually the best way to serve our customers. If we know
    what information is needed, we can figure out how to get it.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we're biased about what can and cannot be done because we
    already have an API to work with. This, however, should never be the determining
    factor of when and how we're able to implement a feature. Like Flux, we should
    design our abstractions around the information required by the feature, and not
    the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging Flux components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last section, we'll think about the composition of large Flux applications
    from the point of view of packages. First, we'll make the case for a monolithic
    distribution of a Flux application, and the point at which this approach becomes
    untenable. Then we'll talk about packages, and how they help us scale up the Flux
    application development effort. Finally, we'll walk through an example of how
    this might work.
  prefs: []
  type: TYPE_NORMAL
- en: The case for monolithic Flux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anyone who has been caught in dependency hell knows that it's an unpleasant
    place to be. Generally speaking, we bring these issues on ourselves by relying
    too heavily on third-party packages. For example, we might use a couple components
    from a gigantic library, or we might use an exceedingly simple library for something
    we could have written ourselves. In any case, we end up with more dependencies
    than what's justified for the size and scope of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Just because we're implementing a Flux architecture for our application, we
    don't have to scale it up for scaling's sake. In other words, we can still use
    Flux for simple applications and acknowledge the fact that there's no need to
    scale it yet. In this case, we're probably better off avoiding dependencies wherever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: The composition of our simple Flux application can be monolithic as well. By
    this, I don't mean putting everything into a few modules. A monolithic Flux application
    would be distributed as a single NPM package. We can probably do this for quite
    some time. For example, we could successfully ship software for years without
    this ever being a problem. However, when extensibility becomes an issue, we have
    to rethink the best way to compose and package our Flux application.
  prefs: []
  type: TYPE_NORMAL
- en: Packages enable scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications will eventually become a victim of their own success. If an application
    manages to stay around long enough and gain enough attention from customers, it
    will eventually have more features than it can feasibly handle. That's not to
    say that our Flux architecture can't handle a lot of features—it can. But look
    at things from the customers' viewpoint. They probably don't want or need everything
    that other customers use.
  prefs: []
  type: TYPE_NORMAL
- en: This requires that we seriously think about the composition of our Flux architecture,
    because you can bet that we're going to need more fine-grained management of features.
    Installable features, in other words. But just how fine-grained do these components,
    and the packages through which we install them, need to be? Well, I think a top-level
    feature might be a good unit of measurement.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we typically model the state of a given top-level feature of our
    application in a single store. Other features have their own stores, we can depend
    on them, and so on. This means that our application needs to take into consideration
    that a given feature component might not be installed on the system. For instance,
    if we were to create a Flux component that implements user management functionality,
    our application that loads these components would require this feature as though
    it were any other third-party package.
  prefs: []
  type: TYPE_NORMAL
- en: Installable Flux components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll walk through an example application—albeit a simple one—to
    illustrate how we can go about installing the major pieces of our application
    components. It's beneficial to be able to excise the major parts from our core
    application, because this decouples them from the application, and it makes it
    easier to use the package elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the main module of the application, which will help
    set the context for the other two NPM packages that make up two main features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll start at the top—where we're importing stores and views from the `my-users`
    and the `my-groups` packages. This is the code for our application, but note that
    we're not using a relative import path. This is because they're installed as NPM
    packages. This means that another application could easily share these components,
    and that they can be updated independently of the applications that use them.
    After these imports, we have the rest of the application components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apple's legal team will be happy to see that I named the store *AppData* instead
    of *AppStore*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the store instances. You can see that each store has a reference
    to the dispatcher passed to it. This is how we communicate with Flux components
    that we're dependent on for composing a larger application. We'll look at the
    stores shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The `renderApp()` function then renders the main `App` React component, and
    the two components from our NPM packages as children. It's this function that
    we've registered with each of the store instances, so that when any of these stores
    change state, the UI is re-rendered. Finally, the `init()` action creator function
    is called, which populates the main navigation.
  prefs: []
  type: TYPE_NORMAL
- en: This main module is key to being able to compose larger applications out of
    smaller, separately installable Flux packages. We import them and configure them
    all in one place. The dispatcher is the main communication mechanism—it's passed
    to both the stores and the views. We don't have to touch more than one file in
    order to important and make use of big application features, which is hugely important
    for scaling up the development effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll take a look at the app store (not Apple''s) to see how the navigation
    data is driven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that this store has two sets of state–one is for the initial
    state of the store, and one is the actual state that's passed to view components
    for rendering. The state has empty properties by default so that views using this
    store don't actually render anything. The `INIT` action will cause the state to
    be populated from `initialState`, and this results in the view being updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this view now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the store state is empty, as it is by default, all that's rendered is an
    empty `div`, and an empty `ul`. This is enough to completely remove the view from
    the screen. The click event is interesting. It's using the dispatcher to dispatch
    actions. The action type comes from the store data, and, by default, this application
    doesn't actually do anything with the `LOAD_USERS` or `LOAD_GROUPS` actions. But
    the two packages we've imported and set up in the main module do listen to these
    actions. This is a big part of what makes this approach scale–different NPM Flux
    packages can dispatch or react to actions–but this doesn't mean either will actually
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the gist of our application. Now we''ll walk through the `my-users`
    package. The `my-groups` package is nearly identical, so we won''t list that code
    here. First we have the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two key actions that this store handles. The first is `LOAD_USERS`,
    which takes the initial state and uses it to populate the store state. The `LOAD_USER`
    action changes the content of the header state, and this action is dispatched
    when a user link is clicked. By default, the store state is cleared out. Now let''s
    take a look at the React component that renders the store data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The key difference between this view and your typical Flux view is that the
    dispatcher itself is passed in as a prop. Then, as the links are rendered, the
    dispatcher instance is bound as the first argument to the handler function.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly recommend downloading and experimenting with the code from this example.
    The two packages that are installed are very simple, just enough to illustrate
    how we can get the basic mechanisms in place that enable us to break major features
    out of the application and into their own installable packages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter looked at Flux in the larger context of the software development
    life-cycle. Since Flux is a set of architectural patterns for us to follow, they're
    largely open to interpretation as far as implementation goes. At the beginning
    of a Flux project, the emphasis is on iteratively delivering pieces of a skeleton
    architecture. Once we have a mature application with several features, the focus
    shifts to managing complexity.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed the possibility that other areas of our technology stack might
    want to borrow ideas from Flux. Things like unidirectional data-flows mean that
    there's less chance of side-effects and that the system as a whole is more predictable.
    Finally, we closed the chapter with a look at how we could potentially compose
    larger applications out of separately installable features made out of Flux components.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this book has been an enlightening read on Flux architecture. The goal
    wasn't necessarily to nail down the *ideal* Flux implementation–I don't think
    there is such a thing. Instead, I wanted to impart the style of thinking that
    goes along with the important principles of Flux. If you find yourself implementing
    something, and start thinking about unidirectional data-flows and predictability,
    then I might have succeeded.
  prefs: []
  type: TYPE_NORMAL
