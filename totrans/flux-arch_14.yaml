- en: Chapter 14. Flux and the Software Development Lifecycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章. Flux与软件开发生命周期
- en: Flux is about information architecture, first and foremost. This is the reason
    that Flux is a set of patterns instead of a framework implementation. When we
    design front-end architectures that scale, the specific implementation matters
    very little, relative to the design of the overall system. It's things like unidirectional
    data-flows and synchronous update rounds that have a lasting impact on the scalability
    of the system. In fact, Flux can be influential enough that it changes the way
    we develop our software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Flux首先关注的是信息架构。这就是为什么Flux是一组模式而不是框架实现的原因。当我们设计可扩展的前端架构时，相对于整体系统的设计，具体的实现几乎无关紧要。单向数据流和同步更新轮次等因素对系统的可扩展性有着持久的影响。事实上，Flux的影响足以改变我们开发软件的方式。
- en: In this chapter we'll look at the software development lifecycle through the
    lens of Flux. We'll open the chapter with a discussion on the open-ended possibilities
    with Flux implementations. Then we'll compare the types of development activities
    that take place at the beginning of a new Flux project with what happens with
    a maturing Flux project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过Flux的视角来审视软件开发生命周期。我们将以对Flux实现开放可能性的讨论开始本章。然后，我们将比较在新Flux项目开始时发生的开发活动类型与成熟Flux项目发生的情况。
- en: We'll also think about the concepts that make Flux appealing to begin with,
    and how to extract these ideas and apply them to other software systems. Lastly,
    we'll end the chapter with a look at creating monolithic Flux systems versus packaging
    Flux components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将思考使Flux一开始就具有吸引力的概念，以及如何提取这些想法并将它们应用于其他软件系统。最后，我们将以创建单体Flux系统与打包Flux组件的比较来结束本章。
- en: Flux is open to interpretation
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux具有开放性
- en: One problem with JavaScript frameworks is that they're just one instantiation
    of a full spectrum of possible solutions. One solution isn't as universal as we
    might hope. Even a specification such as Flux that contains just a handful of
    patterns is open for interpretation. The fact that they're just patterns makes
    it easier for one group to go and implement their software one way, while another
    group uses the same patterns to implement their software how they see fit.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript框架的一个问题是，它们只是可能解决方案全谱中的一种实例化。一种解决方案并不像我们希望的那样通用。即使是只包含少量模式的Flux这样的规范也是开放的，可以解释。它们只是模式的事实使得一个群体可以按照自己的方式实现软件，而另一个群体则使用相同的模式以他们认为合适的方式实现软件。
- en: In this section, we'll reiterate the fact that Flux is just a set of patterns
    to follow. We'll revisit the possibility of using a Flux library, each of which
    has a different take on implementing the Flux patterns. Then we'll consider the
    trade-offs of implementing our own Flux components.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重申Flux只是一组要遵循的模式的事实。我们将回顾使用Flux库的可能性，每个库都对实现Flux模式有不同的看法。然后，我们将考虑实现我们自己的Flux组件的权衡。
- en: Implementation option 1 – just the patterns
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现选项1 – 只遵循模式
- en: Flux is just patterns for us to follow. We might not even follow them exactly.
    Pattern efficacy isn't what's important—what's important is that we get the fundamental
    value of Flux out of our design. For example, actions describe something that
    has happened, and they carry with them a payload of new data to enter the system.
    Once the new data has been dispatched, it continues in one direction until it
    is rendered. Flux just happens to use the concept of a dispatcher and a store.
    We could call our implementation of Flux a conveyor belt if we wanted to. If the
    data-flow is unidirectional and predictable, then we've met one Flux goal.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，Flux只是一组要遵循的模式。我们甚至可能不会完全遵循它们。模式的有效性并不重要——重要的是我们从设计中获得了Flux的基本价值。例如，动作描述了已经发生的事情，并携带新数据的有效载荷进入系统。一旦新数据被分发，它就会沿着一个方向继续，直到被渲染。Flux恰好使用了分发器和存储的概念。如果我们愿意，我们可以把我们的Flux实现称为传送带。如果数据流是单向且可预测的，那么我们就达到了Flux的一个目标。
- en: Likewise, we can implement the dispatcher and the store components to our liking.
    There are probably tweaks that we could make to a store component that would better
    serve our application. These could be for performance reasons, or they could be
    simple developer conveniences. Either of these things are fine to introduce, as
    long as the data-flow stays unidirectional and synchronous.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以根据喜好实现调度器和 store 组件。我们可能对 store 组件进行一些调整，以更好地服务于我们的应用程序。这些调整可能是出于性能原因，也可能是为了方便开发者。只要数据流保持单向和同步，引入这些是完全可以接受的。
- en: These ideas of unidirectional data-flow and synchronous update rounds aren't
    unique to Flux. We could work within the confines of other architectures, such
    as MVC, and achieve the same principles. What is unique about Flux is that it
    was born out of frustration. Engineers at Facebook decided that they needed a
    vehicle to explicitly state just how to get these design principles right.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单向数据流和同步更新轮次的想法并不仅限于 Flux。我们可以在其他架构的约束下工作，如 MVC，并实现相同的原则。Flux 的独特之处在于它起源于挫败感。Facebook
    的工程师们决定他们需要一个工具来明确地表达如何正确地实现这些设计原则。
- en: Implementation option 2 – use a Flux library
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现选项 2 – 使用 Flux 库
- en: We certainly don't have to implement every Flux component ourselves. There's
    plenty of choice out there when it comes to Flux libraries. What's interesting
    is that this Flux library ecosystem reinforces the assertion that Flux is open
    to interpretation. Perhaps the best example of this is Redux. This library is
    not an implementation of the concepts outlined in the Flux documentation. Instead,
    Redux takes a different route to implementing Flux principles.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然不必自己实现每个 Flux 组件。在 Flux 库方面有很多选择。有趣的是，这个 Flux 库生态系统强化了 Flux 可以被解释的断言。也许最好的例子就是
    Redux。这个库并不是 Flux 文档中概述的概念的实现。相反，Redux 采取了不同的路线来实现 Flux 原则。
- en: For example, there's no dispatcher in Redux, and we can only create one store,
    which consists of reducer functions. What's important is that we still get the
    unidirectional data-flow and that the update rounds are synchronous. Then there's
    `Alt.js`, which takes a more traditional approach to implementing Flux in that
    it has the same abstractions as outlined in the Flux documentation. But `Alt.js`
    also builds its own ideas on top of these concepts to make implementing Flux that
    much easier and more enjoyable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Redux 中没有调度器，我们只能创建一个包含还原函数的 store。重要的是我们仍然获得了单向数据流和同步的更新轮次。然后是 `Alt.js`，它在实现
    Flux 方面采取了更传统的做法，因为它具有与 Flux 文档中概述的相同抽象。但 `Alt.js` 还在这些概念之上构建了自己的想法，使得实现 Flux
    更加容易和愉快。
- en: Is it all-or-nothing when we decide to leverage a Flux library? Not necessarily.
    This fear of all-or-nothing stems from monolithic frameworks that prescribe a
    certain way of doing things, and there's no easy way to work around these. With
    libraries, the idea is to be able to pick and choose the bits that you need in
    order to compose larger behavior. Take the view layer in a Flux architecture—this
    is most commonly made up of React components. However, neither Redux or `Alt.js`
    require that we use React. Redux is small enough that we can just use its store
    component for our application state, and `Alt.js` has several smaller modules
    that we can pick and choose from—there are probably several that we'll never use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们决定利用 Flux 库时，是不是必须全盘接受？不一定。这种全有或全无的恐惧源于那些规定做事方式的单体框架，而且没有简单的方法来绕过这些问题。使用库的想法是能够挑选和选择你需要的部分来组合更大的行为。以
    Flux 架构中的视图层为例——这通常由 React 组件组成。然而，Redux 或 `Alt.js` 并不要求我们使用 React。Redux 足够小，我们可以直接使用其
    store 组件来处理我们的应用程序状态，而 `Alt.js` 有几个较小的模块供我们选择——可能有一些我们永远不会使用。
- en: Roll your own Flux
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自行实现 Flux
- en: Given that there are so many approaches to implementing a Flux system, is there
    any utility in implementing our own? In other words, would we be re-inventing
    the wheel by rolling our own Flux components instead of depending on one of the
    many Flux libraries out there? Not at all. There's a strong possibility that none
    of the Flux libraries meet the needs of what we're trying to accomplish. Or maybe
    there are several things about the Flux components that we want to customize,
    so that it makes less sense to depend on an implementation that we're going to
    change completely.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到有这么多实现Flux系统的方法，我们自己实现是否有任何实用性？换句话说，如果我们不依赖众多Flux库之一，而是自己实现Flux组件，是否会重蹈覆辙？根本不会。有很大可能性，没有任何Flux库能满足我们试图达成的目标。或者，可能有几个关于Flux组件的问题我们想要定制，这样依赖一个我们打算完全更改的实现就不再有意义。
- en: Most of the code in this book has been based on our own implementations of Flux
    components. We've relied on the reference implementation of the Flux dispatcher,
    but then we went and implemented our own, without much difficulty. The positive
    aspect of implementing our own Flux components is that we have the freedom to
    tweak the components to meet the needs of our application as it evolves. This
    is more difficult to do when we depend on someone else's implementation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大部分代码都是基于我们自己的Flux组件实现。我们依赖Flux派发器的参考实现，但后来我们实现了自己的版本，并没有遇到太多困难。自己实现Flux组件的积极方面是我们有自由调整组件以满足我们应用发展的需求。当我们依赖他人的实现时，这样做会更困难。
- en: One possibility is that we use a library like `Alt.js` for inspiration for rolling
    our own implementation. This way, we can implement the cool features from that
    library while modifying them as we see fit. On the other hand, we could be better
    off just using a Flux library as-is. The best bet is to think about this sort
    of thing while you're building a skeleton Flux architecture. Don't depend on any
    libraries upfront, but decide early on if you're going to use something like Redux,
    so you don't have to throw out too many components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能性是，我们使用像`Alt.js`这样的库来获取灵感，以实现我们自己的版本。这样，我们可以在修改它们的同时实现该库中的酷炫功能。另一方面，我们可能更倾向于直接使用现成的Flux库。最好的办法是在构建Flux架构框架时考虑这类事情。一开始不要依赖任何库，但尽早决定是否要使用像Redux这样的库，这样你就不必丢弃太多组件。
- en: Development methodologies
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发方法论
- en: In this section, we'll look at the development methodologies that take place
    at different stages of a Flux project. Keep in mind that these are just guidelines,
    as methodologies can vary quite drastically from team to team. If two different
    teams are implementing a Flux system, there will no doubt be some commonalities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在Flux项目不同阶段发生的开发方法论。请记住，这些只是指导方针，因为方法论可以从一个团队到另一个团队有相当大的差异。如果两个不同的团队正在实现Flux系统，无疑会有一些共同点。
- en: First we'll think about what happens during the initial phases of a new Flux
    project. Then we'll think about Flux projects that have had a chance to mature,
    and what the process might look like for adding a new feature to the system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将思考在一个新的Flux项目初始阶段会发生什么。然后，我们将思考那些已经成熟起来的Flux项目，以及向系统中添加新功能的过程可能是什么样子。
- en: Upfront Flux activities
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预先Flux活动
- en: Many software development methodologies frown upon big upfront design. The reason
    is simple—we spend too much time designing before any software is written and
    tested. Incrementally delivering pieces of software gives us a chance to validate
    any assumptions we may have made while writing code. The question is, does Flux
    require big upfront design, or can we incrementally implement parts of a Flux
    system?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件开发方法论都不赞成大范围的预先设计。原因很简单——我们在编写和测试任何软件之前花费了太多时间进行设计。逐步交付软件片段给我们提供了一个机会来验证我们在编写代码时可能做出的任何假设。问题是，Flux是否需要大范围的预先设计，或者我们能否逐步实现Flux系统的各个部分？
- en: As you saw earlier in the book, the first step to designing a Flux architecture
    is writing code. At first, we're only interested in producing a skeleton architecture
    so that we can get a feel for the types of information our components will need.
    We don't spend time implementing UI components initially, because doing so will
    likely be a time sink and a distraction from thinking about the other Flux components
    that we'll need—such as stores and actions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书前面看到的，设计Flux架构的第一步是编写代码。起初，我们只对产生骨架架构感兴趣，以便我们可以了解组件将需要哪些类型的信息。我们最初不花时间实现UI组件，因为这很可能是时间陷阱，并且会分散我们对其他Flux组件（如存储和动作）的思考。
- en: The question is, can building a skeleton architecture fit into the regular flow
    of developing software without being big on upfront design? I think so.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，构建骨架架构能否融入软件开发常规流程中，而不需要过多的前期设计？我认为可以。
- en: We don't want to spend too much time on a skeleton architecture, because that's
    just a recipe for bike-shedding. We could, however, set sprint goals for building
    pieces of the skeleton architecture and reviewing with a larger group. Something
    like a sprint demo might actually be the ideal forum to decide whether or not
    we've built enough of the skeleton architecture and whether we're happy with it.
    Then it's time to start building features in earnest.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在骨架架构上花费太多时间，因为这只会导致无谓的讨论。然而，我们可以为构建骨架架构的各个部分设定冲刺目标，并与更大的团队进行审查。实际上，冲刺演示可能是一个理想的论坛，以决定我们是否已经构建了足够的骨架架构，并且我们对它是否满意。然后就是开始认真构建功能的时候了。
- en: Maturing a Flux application
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成熟化Flux应用程序
- en: Once we've moved well beyond the skeleton architecture phase, we hopefully have
    in place a solid product with features that our customers will enjoy using. Ideally,
    this means that we've hit a sweet spot with our Flux architecture—it scales well,
    it's easy to maintain, and we're able to keep our customers happy by delivering
    new features. The application is mature, in other words. So how did we get to
    this point, and how do we keep it going?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们远远超出骨架架构阶段，我们希望有一个稳固的产品，其中包含客户会喜欢的功能。理想情况下，这意味着我们已经找到了Flux架构的甜蜜点——它具有良好的可扩展性，易于维护，并且我们能够通过交付新功能来保持客户的满意度。换句话说，应用程序已经成熟。那么我们是如何达到这个阶段的，又是如何保持其发展的？
- en: 'Let''s consider a feature that we''ve been asked to build. We have a team of
    all-purpose programmers to build it. How should we go about decomposing the feature
    into implementation tasks? Flux makes this fairly easy to figure out, because
    there are a limited number of component types. So if we can get a small team assembled
    to deliver a feature, then one person can focus on implementing the views, another
    on the stores and actions, and another to build the back-end data services. Here''s
    an illustration of a team and the Flux components they build to realize a feature
    of the application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个我们被要求构建的功能。我们有一个全能型程序员团队来构建它。我们应该如何将这个功能分解为实施任务？Flux使得这一点相对容易理解，因为组件类型有限。所以如果我们能组织一个小团队来交付一个功能，那么一个人可以专注于实现视图，另一个人专注于存储和动作，还有一个人来构建后端数据服务。以下是一个团队和他们构建的Flux组件以实现应用程序功能的示例：
- en: '![Maturing a Flux application](img/B05419_14_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![成熟化Flux应用程序](img/B05419_14_01.jpg)'
- en: An alternative approach would be to have teams that focus on the same types
    of components. For example, a store team would be spread across features but each
    member would work on a store component at any given time. This approach is inferior
    because a team of Flux programmers working on the same deliverable have collective
    insight into how the feature is going to provide maximum customer value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是有团队专注于相同类型的组件。例如，一个存储团队可能会跨越多个功能，但每个成员在任何给定时间都会工作在一个存储组件上。这种方法较差，因为专注于同一可交付成果的Flux程序员团队对如何使功能提供最大客户价值有集体见解。
- en: Borrowing ideas from Flux
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Flux中借鉴想法
- en: Flux forces us to think about the information architecture of our application
    in new and interesting ways. Rarely does adopting a new approach like this happen
    in a vacuum. The ideas tend to spread to other parts of the technology stack.
    With Flux, it's the architectural principles of data-flow direction and feature-driven
    information that stand out as having a positive impact. If these things can have
    a positive impact on the frontend code, why couldn't they influence the design
    of the system as a whole?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Flux迫使我们以新的有趣方式思考应用的信息架构。采用这种新方法很少是在真空中发生的。这些想法往往会传播到技术栈的其他部分。在Flux中，数据流方向和以功能驱动的信息架构的架构原则脱颖而出，显示出积极的影响。如果这些事情可以对前端代码产生积极影响，为什么不能影响整个系统的设计呢？
- en: Unidirectional data flow
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向数据流
- en: The unidirectional flow of data through a Flux architecture is probably the
    key aspect that enables it to scale. By itself, unidirectional data-flow makes
    the code we write easy to reason about. In places, this approach can be a little
    more verbose, but this is a conscious trade-off that we make in order to facilitate
    predictability. For example, with the two-way data binding capabilities found
    in some frameworks, we can get away with writing less code. This, however, is
    a developer convenience that trades off predictability.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Flux架构中数据单向流动可能是它能够扩展的关键方面。单从数据流的角度来看，我们编写的代码更容易理解。在某些地方，这种方法可能稍微有点冗长，但这是我们为了提高可预测性而有意做出的权衡。例如，在一些框架中发现的双向数据绑定功能，我们可以通过编写更少的代码来完成任务。然而，这却是以牺牲可预测性为代价的开发者便利性。
- en: This is the type of lesson from Flux that may in fact be applicable to other
    areas of our technology stack. For example, are there pieces of code that are
    difficult to reason about because the data that flows through them moves in several
    directions? Can we change that?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是从Flux中学到的一种可能适用于我们技术栈其他领域的教训。例如，是否有难以理解的代码片段，因为通过它们流动的数据在多个方向上移动？我们能改变这种情况吗？
- en: It might be hard to enforce unidirectional data-flows to the extent that Flux
    does, but we can at least think about the benefits that this brings to the front-end
    of the application and try to apply the same principles to other code. For instance,
    maybe we can't get a unidirectional data-flow in place but we can slim down the
    component by removing flows that are particularly difficult to predict.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可能很难像Flux那样强制执行单向数据流，但我们可以至少思考这给应用前端带来的好处，并尝试将相同的原理应用到其他代码中。例如，我们可能无法实现单向数据流，但我们可以通过移除特别难以预测的流来简化组件。
- en: Information design is king
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息设计为王
- en: Flux architectures start with information that the user interacts with, and
    work their its way backward, toward the API. This approach is different from other
    front-end architectures where you have the API entities, and you then create front-end
    models, and the views (or view models) figure out the transformations necessary
    to create information that's relevant to the user. The challenge with putting
    information first is that we might come up with something that's just not feasible
    from the API perspective.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Flux架构从用户交互的信息开始，逆向工作，直至API。这种方法与其他前端架构不同，在其他架构中，你有API实体，然后创建前端模型，视图（或视图模型）确定创建与用户相关的信息的必要转换。将信息放在首位的一个挑战是，我们可能会提出一些从API角度来看根本不可行的方案。
- en: However, if this is the case then we probably have a dysfunctional team structure
    to begin with, because it's easy to isolate oneself in one's own technology bubble
    (back-end, network, front-end, and so on), but this simply does not work in a
    feature-driven product. All contributing members need to know what's going on
    in every layer of the stack.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果情况确实如此，那么我们可能一开始就有一个功能失调的团队结构，因为很容易孤立于自己的技术泡沫（后端、网络、前端等），但在以功能驱动的产品中这根本行不通。所有贡献者都需要了解堆栈每一层的状况。
- en: If we can sort out the teams so that each contributor is fully aware of what's
    happening in the various parts of the code-base, then we can adopt an *information
    is king* attitude toward feature development. Flux works well for this, and it
    turns out that this is actually the best way to serve our customers. If we know
    what information is needed, we can figure out how to get it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够整理好团队，让每个贡献者都完全了解代码库的各个部分正在发生的事情，那么我们就可以在功能开发中采取“信息为王”的态度。Flux在这方面表现良好，而且实际上这是为我们的客户服务的最佳方式。如果我们知道需要什么信息，我们就可以想出如何获取它。
- en: On the other hand, we're biased about what can and cannot be done because we
    already have an API to work with. This, however, should never be the determining
    factor of when and how we're able to implement a feature. Like Flux, we should
    design our abstractions around the information required by the feature, and not
    the other way around.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们对什么可以做和什么不可以做有所偏见，因为我们已经有一个可以工作的API。然而，这永远不应该成为我们何时以及如何实现功能的决定因素。就像Flux一样，我们应该围绕功能所需的信息来设计我们的抽象，而不是反过来。
- en: Packaging Flux components
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包Flux组件
- en: In this last section, we'll think about the composition of large Flux applications
    from the point of view of packages. First, we'll make the case for a monolithic
    distribution of a Flux application, and the point at which this approach becomes
    untenable. Then we'll talk about packages, and how they help us scale up the Flux
    application development effort. Finally, we'll walk through an example of how
    this might work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，我们将从包的角度来思考大型Flux应用程序的组成。首先，我们将论证Flux应用程序的单一分布，以及这种做法变得不可行的时候。然后，我们将讨论包以及它们如何帮助我们扩展Flux应用程序的开发工作。最后，我们将通过一个例子来展示这可能如何运作。
- en: The case for monolithic Flux
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一Flux的案例
- en: Anyone who has been caught in dependency hell knows that it's an unpleasant
    place to be. Generally speaking, we bring these issues on ourselves by relying
    too heavily on third-party packages. For example, we might use a couple components
    from a gigantic library, or we might use an exceedingly simple library for something
    we could have written ourselves. In any case, we end up with more dependencies
    than what's justified for the size and scope of our project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 任何陷入依赖地狱的人都知道那是一个令人不愉快的地方。一般来说，我们通过过度依赖第三方包来引发这些问题。例如，我们可能从一个庞大的库中使用了几个组件，或者我们可能使用了一个极其简单的库来完成我们自己可以编写的事情。无论如何，我们最终拥有的依赖项比我们项目的大小和范围所证明的要多。
- en: Just because we're implementing a Flux architecture for our application, we
    don't have to scale it up for scaling's sake. In other words, we can still use
    Flux for simple applications and acknowledge the fact that there's no need to
    scale it yet. In this case, we're probably better off avoiding dependencies wherever
    possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就因为我们正在为我们的应用程序实现Flux架构，并不意味着我们必须为了扩展而扩展。换句话说，我们仍然可以使用Flux来处理简单的应用程序，并承认目前还没有必要对其进行扩展。在这种情况下，我们可能最好尽可能避免依赖项。
- en: The composition of our simple Flux application can be monolithic as well. By
    this, I don't mean putting everything into a few modules. A monolithic Flux application
    would be distributed as a single NPM package. We can probably do this for quite
    some time. For example, we could successfully ship software for years without
    this ever being a problem. However, when extensibility becomes an issue, we have
    to rethink the best way to compose and package our Flux application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的Flux应用程序的组成也可以是单一的。通过这种方式，我并不是说把所有东西都放入几个模块中。一个单一的Flux应用程序将以单个NPM包的形式分发。我们可能可以这样做相当长一段时间。例如，我们可以成功地将软件发布多年而不会出现任何问题。然而，当可扩展性成为一个问题时，我们必须重新思考最佳的方式来组合和打包我们的Flux应用程序。
- en: Packages enable scale
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包实现规模
- en: Applications will eventually become a victim of their own success. If an application
    manages to stay around long enough and gain enough attention from customers, it
    will eventually have more features than it can feasibly handle. That's not to
    say that our Flux architecture can't handle a lot of features—it can. But look
    at things from the customers' viewpoint. They probably don't want or need everything
    that other customers use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序最终会成为其自身成功的受害者。如果一个应用程序能够长时间存在并从客户那里获得足够的关注，它最终会拥有比它实际能够处理的更多功能。这并不是说我们的Flux架构不能处理很多功能——它可以。但从客户的角度来看，他们可能不需要或不需要使用其他客户使用的一切。
- en: This requires that we seriously think about the composition of our Flux architecture,
    because you can bet that we're going to need more fine-grained management of features.
    Installable features, in other words. But just how fine-grained do these components,
    and the packages through which we install them, need to be? Well, I think a top-level
    feature might be a good unit of measurement.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求我们认真思考我们的 Flux 架构的组成，因为我们可以肯定我们需要对功能进行更精细的管理。换句话说，可安装的功能。但是，这些组件以及我们通过它们安装的包需要多精细呢？我认为顶级功能可能是一个很好的度量单位。
- en: For example, we typically model the state of a given top-level feature of our
    application in a single store. Other features have their own stores, we can depend
    on them, and so on. This means that our application needs to take into consideration
    that a given feature component might not be installed on the system. For instance,
    if we were to create a Flux component that implements user management functionality,
    our application that loads these components would require this feature as though
    it were any other third-party package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们通常在一个单独的存储中模拟我们应用程序的给定顶级功能的状态。其他功能有自己的存储，我们可以依赖它们，依此类推。这意味着我们的应用程序需要考虑这样一个事实，即某个特定的功能组件可能没有安装在系统上。例如，如果我们创建一个实现用户管理功能的
    Flux 组件，加载这些组件的应用程序将需要这个功能，就像它需要任何其他第三方包一样。
- en: Installable Flux components
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可安装的 Flux 组件
- en: In this section, we'll walk through an example application—albeit a simple one—to
    illustrate how we can go about installing the major pieces of our application
    components. It's beneficial to be able to excise the major parts from our core
    application, because this decouples them from the application, and it makes it
    easier to use the package elsewhere.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个示例应用程序——尽管它很简单——来展示我们如何安装应用程序组件的主要部分。能够从我们的核心应用程序中移除主要部分是有益的，因为这将它们与应用程序解耦，并使得在其他地方使用这些包变得更容易。
- en: 'Let''s start by looking at the main module of the application, which will help
    set the context for the other two NPM packages that make up two main features:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看应用程序的主要模块，这将有助于为构成两个主要功能的另外两个 NPM 包设定上下文：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll start at the top—where we're importing stores and views from the `my-users`
    and the `my-groups` packages. This is the code for our application, but note that
    we're not using a relative import path. This is because they're installed as NPM
    packages. This means that another application could easily share these components,
    and that they can be updated independently of the applications that use them.
    After these imports, we have the rest of the application components.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从顶部开始——在这里，我们从 `my-users` 和 `my-groups` 包中导入存储和视图。这是我们的应用程序代码，但请注意，我们没有使用相对导入路径。这是因为它们作为
    NPM 包安装。这意味着另一个应用程序可以轻松共享这些组件，并且它们可以独立于使用它们的那些应用程序进行更新。在这些导入之后，我们有应用程序的其他组件。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Apple's legal team will be happy to see that I named the store *AppData* instead
    of *AppStore*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的法律团队会很高兴看到我命名存储为 *AppData* 而不是 *AppStore*。
- en: Next, we create the store instances. You can see that each store has a reference
    to the dispatcher passed to it. This is how we communicate with Flux components
    that we're dependent on for composing a larger application. We'll look at the
    stores shortly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建存储实例。你可以看到每个存储都有一个引用传递给它。这是我们与依赖于它们来组合更大应用程序的 Flux 组件进行通信的方式。我们稍后会查看存储。
- en: The `renderApp()` function then renders the main `App` React component, and
    the two components from our NPM packages as children. It's this function that
    we've registered with each of the store instances, so that when any of these stores
    change state, the UI is re-rendered. Finally, the `init()` action creator function
    is called, which populates the main navigation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderApp()` 函数随后渲染主要的 `App` React 组件，以及来自我们的 NPM 包的两个组件作为子组件。正是这个函数我们在每个存储实例上进行了注册，所以当任何这些存储改变状态时，UI
    将重新渲染。最后，调用 `init()` 动作创建函数，它填充了主要导航。'
- en: This main module is key to being able to compose larger applications out of
    smaller, separately installable Flux packages. We import them and configure them
    all in one place. The dispatcher is the main communication mechanism—it's passed
    to both the stores and the views. We don't have to touch more than one file in
    order to important and make use of big application features, which is hugely important
    for scaling up the development effort.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主模块对于能够将较小的、可单独安装的Flux包组合成较大的应用程序至关重要。我们在这里导入并配置它们。分发器是主要的通信机制——它被传递给存储和视图。我们不需要修改超过一个文件就能导入并使用大型应用程序的功能，这对于扩大开发工作非常重要。
- en: 'Now we''ll take a look at the app store (not Apple''s) to see how the navigation
    data is driven:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看应用程序存储（不是苹果的）以了解导航数据是如何驱动的：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here you can see that this store has two sets of state–one is for the initial
    state of the store, and one is the actual state that's passed to view components
    for rendering. The state has empty properties by default so that views using this
    store don't actually render anything. The `INIT` action will cause the state to
    be populated from `initialState`, and this results in the view being updated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到这个存储有两个状态集——一个是存储的初始状态，另一个是传递给视图组件进行渲染的实际状态。状态默认有空的属性，这样使用这个存储的视图实际上不会渲染任何内容。《INIT》动作将导致状态从`initialState`填充，这导致视图被更新。
- en: 'Let''s take a look at this view now:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看这个视图：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the store state is empty, as it is by default, all that's rendered is an
    empty `div`, and an empty `ul`. This is enough to completely remove the view from
    the screen. The click event is interesting. It's using the dispatcher to dispatch
    actions. The action type comes from the store data, and, by default, this application
    doesn't actually do anything with the `LOAD_USERS` or `LOAD_GROUPS` actions. But
    the two packages we've imported and set up in the main module do listen to these
    actions. This is a big part of what makes this approach scale–different NPM Flux
    packages can dispatch or react to actions–but this doesn't mean either will actually
    happen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当存储状态为空时，默认情况下，渲染的只是一个空的`div`和一个空的`ul`。这足以完全从屏幕上移除视图。点击事件很有趣。它使用分发器来分发动作。动作类型来自存储数据，默认情况下，这个应用程序实际上并没有对`LOAD_USERS`或`LOAD_GROUPS`动作做任何事情。但是我们在主模块中导入并设置的两个包确实会监听这些动作。这是使这种方法可扩展的一个重要部分——不同的NPM
    Flux包可以分发或响应动作——但这并不意味着任何动作都会实际发生。
- en: 'This is the gist of our application. Now we''ll walk through the `my-users`
    package. The `my-groups` package is nearly identical, so we won''t list that code
    here. First we have the store:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的应用程序的核心。现在我们将逐步介绍`my-users`包。`my-groups`包几乎相同，所以我们在这里不会列出那个代码。首先我们有存储：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are two key actions that this store handles. The first is `LOAD_USERS`,
    which takes the initial state and uses it to populate the store state. The `LOAD_USER`
    action changes the content of the header state, and this action is dispatched
    when a user link is clicked. By default, the store state is cleared out. Now let''s
    take a look at the React component that renders the store data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该存储处理两个关键动作。第一个是`LOAD_USERS`，它接受初始状态并使用它来填充存储状态。`LOAD_USER`动作改变头部状态的内容，并且当点击用户链接时触发这个动作。默认情况下，存储状态会被清除。现在让我们看看渲染存储数据的React组件：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The key difference between this view and your typical Flux view is that the
    dispatcher itself is passed in as a prop. Then, as the links are rendered, the
    dispatcher instance is bound as the first argument to the handler function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与你典型的Flux视图相比，这个视图的关键区别在于分发器本身被作为属性传递。然后，随着链接的渲染，分发器实例被绑定到处理函数的第一个参数。
- en: I strongly recommend downloading and experimenting with the code from this example.
    The two packages that are installed are very simple, just enough to illustrate
    how we can get the basic mechanisms in place that enable us to break major features
    out of the application and into their own installable packages.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议下载并尝试使用这个示例中的代码。安装的两个包非常简单，仅足够说明我们如何将基本机制放在适当的位置，从而能够将主要功能从应用程序中分离出来，并作为可安装的包。
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter looked at Flux in the larger context of the software development
    life-cycle. Since Flux is a set of architectural patterns for us to follow, they're
    largely open to interpretation as far as implementation goes. At the beginning
    of a Flux project, the emphasis is on iteratively delivering pieces of a skeleton
    architecture. Once we have a mature application with several features, the focus
    shifts to managing complexity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在软件开发生命周期的更大背景下探讨了 Flux。由于 Flux 是一套我们遵循的架构模式，因此在实现方面它们在很大程度上是开放的。在 Flux 项目的开始阶段，重点在于迭代交付骨架架构的各个部分。一旦我们拥有了一个具有多个功能的成熟应用程序，焦点就转向了复杂性管理。
- en: We then discussed the possibility that other areas of our technology stack might
    want to borrow ideas from Flux. Things like unidirectional data-flows mean that
    there's less chance of side-effects and that the system as a whole is more predictable.
    Finally, we closed the chapter with a look at how we could potentially compose
    larger applications out of separately installable features made out of Flux components.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了其他技术栈领域可能希望从 Flux 中借鉴想法的可能性。例如，单向数据流意味着副作用的可能性更小，整个系统也更加可预测。最后，我们以探讨如何可能地使用由
    Flux 组件构成的独立可安装特性来组合更大的应用程序来结束这一章节。
- en: I hope this book has been an enlightening read on Flux architecture. The goal
    wasn't necessarily to nail down the *ideal* Flux implementation–I don't think
    there is such a thing. Instead, I wanted to impart the style of thinking that
    goes along with the important principles of Flux. If you find yourself implementing
    something, and start thinking about unidirectional data-flows and predictability,
    then I might have succeeded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书对 Flux 架构的阅读能有所启发。目标并不是一定要确定 *理想* 的 Flux 实现——我认为没有这样的事情。相反，我想要传达与 Flux
    的重要原则相伴随的思考方式。如果你发现自己正在实现某些东西，并开始思考单向数据流和可预测性，那么我可能已经成功了。
