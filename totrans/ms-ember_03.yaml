- en: Chapter 3. Routing and State Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn URL-based state management in Ember.js, which
    constitutes **routing**. Routing enables us to translate different states in our
    applications into URLs and vice-versa. It is a key concept in Ember.js that enables
    developers to easily separate application logic. It also enables users to link
    back to content in the application via the usual HTTP URLs. That being said, by
    the end of this chapter, we should be able to accomplish the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define resources and routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a route's model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform a redirect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accomplish asynchronous routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the application's router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know that in traditional web development, every request is linked by
    a URL that enables the server make a decision on the incoming request. Typical
    actions include sending back a resource file or JSON payload, redirecting the
    request to a different resource, or sending back an error response such as in
    the case of unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ember.js strives to preserve these ideas in the browser environment by enabling
    association between these URLs and state of the application. The main component
    that manages these states is the application router. As mentioned in the introductory
    section, it is responsible for restoring an application to a state matching the
    given URL. It also enables the user to navigate between the application''s history
    as expected. The router is automatically created on application initialization
    and can be referenced as `MyApplicationNamespace.Router`. Before we proceed, we
    will be using the bundled chapter sample to better understand this extremely convenient
    component. The sample is a simple implementation of the Contacts OS X application
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the application''s router](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It enables users to add new contacts as well as edit and delete existing ones.
    For simplicity, we won't support avatars, but that could be an implementation
    exercise for the reader at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already mentioned some of the states in which this application can transition
    into. These states have to be registered in the same way server-side frameworks
    have URL dispatchers that backend programmers use to map URL patters to views.
    The chapter sample already illustrates how these possible states are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the already instantiated router was referenced as `App.Router`.
    Calling its `map` method gives the application an opportunity to register its
    possible states. In addition, two other methods are used to classify these states
    into *routes* and *resources*.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping URLs to routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first argument specifies the name of the resource and coincidentally, the
    path to match the request URL. The next argument is optional and holds configurations
    that we may need to specify, as we shall see later. The last one is a function
    that is used to define the routes of that particular resource. For example, the
    first defined resource in the samples says, let the `contacts` resource handle
    any requests whose URL starts with `/contacts`. It also specifies one route, `new`,
    that is used to handle the creation of new contacts. Routes on the other hand,
    accept the same arguments for the function argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must be asking yourself, "So how are routes different from resources?"
    The two are essentially the same, other than the former offers a way to categorize
    states (routes) that perform actions on a specific entity. We can think of an
    Ember.js application as a tree, composed of a trunk (the router), branches (resources),
    and leaves (routes). For example, the `contact` state (a resource) caters for
    a specific contact. This resource can be displayed in two modes: read and write;
    hence, the `index` and `edit` routes respectively, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Because Ember.js encourages convention, there are two components of routes
    and resources that are always autodefined:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A default application resource: This is the master resource into which all
    other resources are defined. We therefore do not need to define it in the router.
    It''s not mandatory to define resources on every state. For example, our `about`
    state is a route because it only needs to display static content to the user.
    It can however be thought to be a route of the already autodefined application
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A default `index` route on every resource: Again, every resource has a default
    index route. It''s autodefined because an application cannot settle on a resource
    state. The application therefore uses this route if no other route within this
    same resource was intended to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resources can be nested depending on the architecture of the application. In
    our case, we need to load contacts in the sidebar before displaying any of them
    to the user. Therefore, we need to define the contact resource inside the contacts.
    On the other hand, in an application such as Twitter, it won't make sense to define
    a `tweet` resource embedded inside a `tweets` resource because an extra overhead
    will be incurred when a user just wants to view a single tweet linked from an
    external application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the state transition cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A request is handled in the same way water travels from the roots (the application),
    up the trunk, and is eventually lost off leaves. This request we are referring
    to is a change in the browser location that can be triggered in a number of ways,
    as we shall discover more in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed into finer details about routes, let''s discuss what happened
    when the application was first loaded. On boot, a few things happened as outlined:'
  prefs: []
  type: TYPE_NORMAL
- en: The application first transitioned into the application state, then the index
    state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the application index route redirected the request to the contacts resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our application uses the browser's local storage to store the contacts and so
    for demoing purposes, the contacts resource populated this store with fixtures
    (located at `fixtures.js`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application then transitioned into the corresponding contacts resource index
    route, `contacts.index`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, here we made a few decisions based on whether our store contained any
    data. Since we indeed have data, we redirected the application into the contact
    resource, passing the ID of the first contact along.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as in the two preceding resources, the application transitioned from this
    last resource into the corresponding index route, `contact.index`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure gives a good view of the preceding state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the state transition cycle](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The router can be customized in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging state transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the root app URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing browser location lookup method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During development, it may be necessary to track the states into which the
    application transitions. Enabling these logs is as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As illustrated, we enable the `LOG_TRANSITIONS` flag when creating the application.
    If an application is not served at the root of the website domain, then it may
    be necessary to specify the path name used, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One other modification we may need to make revolves around the techniques Ember.js
    uses to subscribe to the browser''s location changes. This makes it possible for
    the router to do its job of transitioning the app into the matched URL state.
    Two of these methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to the `hashchange` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `history.pushState` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default technique used is provided by the `HashLocation` class documented
    at [http://emberjs.com/api/classes/Ember.HashLocation.html](http://emberjs.com/api/classes/Ember.HashLocation.html).
    This means that URL paths are usually prefixed with the hash symbol, for example,
    `/#/contacts/1/edit`. The other one is provided by the `HistoryLocation` class
    located at [http://emberjs.com/api/classes/Ember.HistoryLocation.html](http://emberjs.com/api/classes/Ember.HistoryLocation.html).
    This does not distinguish URLs from the traditional ones and can be enabled as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also opt to let Ember.js pick which method is best suited for our app
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t need any of these techniques, we could opt to do so especially
    when performing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a route's path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now know that when defining a route or resource, the resource name used
    also serves as the path the router uses to match request URLs. Sometimes, it may
    be necessary to specify a different path to use to match states. There are two
    common reasons that may lead us to do this, the first of which is good for delegating
    route handling to another route. Although, we have not yet covered route handlers,
    we already mentioned that our application transitions from the application `index`
    route into the `contacts.index` state. We may however specify that the contacts
    route handler should manage this path as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, to specify an alternative path for a route, simply pass the desired
    route in a hash as the second argument during resource definition. This also applies
    when defining routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second reason would be when a resource contains dynamic segments. For example,
    our contact resource handles contacts who should obviously have different URLs
    linking back to them. Ember.js uses URL pattern matching techniques used by other
    open source projects such as Ruby on Rails, Sinatra, and Express.js. Therefore,
    our contact resource should be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Defining route and resource handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have defined all the possible states that our application can transition
    into, we need to define handlers to these states. From this point onwards, we
    will use the terms *route* and *resource handlers* interchangeably. A route handler
    performs the following major functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing data (model) to be used by the current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the view and/or template to use to render the provided data to the
    user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting an application away into another state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we move into discussing these roles, we need to know that a route handler
    is defined from the `Ember.Route` class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is used to define handlers for both resources and routes and therefore,
    the naming should not be a concern. Just as routes and resources are associated
    with paths and handlers, they are also associated with controllers, views, and
    templates using the Ember.js naming conventions. For example, when the application
    initializes, it enters into the `application` state and therefore, the following
    objects are sought:'
  prefs: []
  type: TYPE_NORMAL
- en: The application route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the spirit of *do more with reduced boilerplate* code, Ember.js autogenerates
    these objects unless explicitly defined in order to override the default implementations.
    As another example, if we examine our application, we notice that the `contact.edit`
    route has a corresponding `App.ContactEditController` controller and `contact/edit`
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not need to define its route handler or view. Having seen this example,
    when referring to routes, we normally separate the resource name from the route
    name by a period as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of templates, we may use a period or a forward slash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The other objects are usually camelized and suffixed by the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For example, the following table shows all the objects used in our chapter sample.
    As mentioned earlier, some are autogenerated.
  prefs: []
  type: TYPE_NORMAL
- en: '| Route Name | Controller | Route Handler | View | Template |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `applicationApplicationControllerApplicationRoute` | `ApplicationViewapplication`
    |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `indexIndexControllerIndexRoute` | `IndexViewindex` |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `about` | `AboutController` | `AboutRoute` | `AboutView` | `about` |'
  prefs: []
  type: TYPE_TB
- en: '| `contactsContactsControllerContactsRoute` | `ContactsView` |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `contacts.indexContactsIndexControllerContactsIndexRoute` | `ContactsIndexViewcontacts/index`
    |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `contacts.newContactsNewController` | `ContactsNewRoute` |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `contact` | `ContactController` | `ContactRoute` | `ContactView` | `contact`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `contact.index` | `ContactIndexController` | `ContactIndexRoute` | `ContactIndexView`
    | `contact/index` |'
  prefs: []
  type: TYPE_TB
- en: '| `contact.edit` | `ContactEditController` | `ContactEditRoute` | `ContactEditView`
    | `contact/edit` |'
  prefs: []
  type: TYPE_TB
- en: One thing to note is that objects associated with the intermediary application
    state do not need to carry the suffix; hence, just `index` or `about`.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a route's model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first chapter, we mentioned that route handlers provide controllers,
    the data needed to be displayed by templates. These handlers have a `model` hook
    that can be used to provide this data in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, the route `contacts` handler in the chapter sample loads any
    saved contacts from local storage as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have abstracted this logic into our `App.Contact` model. Notice how we reopen
    the class in order to define this static method. As a recap of this lesson in
    [Chapter 2](part0019_split_000.html#page "Chapter 2. Understanding Ember.js Objects
    and Mixins"), *Understanding Ember.js Objects and Mixins*, a static method can
    only be called by the class of that method and not its instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If no arguments are passed to the method, it goes ahead and calls the `findAll`
    method, which uses the local storage helper to retrieve the contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we want to deal with contact objects, we iteratively convert the contents
    of the loaded contact list. If we examine the corresponding template, `contacts`,
    we notice that we are able to populate the sidebar as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not worry about the template syntax at this point if you''re new to Ember.js.
    The important thing to note is that the model was accessed via the `model` variable.
    Of course, before that, we check to see if the model has any content in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we shall see later, if the list was empty, the application would be forced
    to transition into the `contacts.new` state, in order for the user to add the
    first contact as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying a route''s model](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `contact` handler is a different case. Remember we mentioned that its path
    has a dynamic segment that would be passed to the handler. This information is
    passed to the model hook in an options hash as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are able to access the contact''s ID via the `contact_id` attribute
    of the hash. This time, the `find` method calls the `findOne` static method of
    the contact''s class, which performs a search for the contact matching the provided
    ID, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Serializing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve mentioned that Ember.js supports content to be linked back externally.
    Internally, Ember.js simplifies creating these links in templates. In our sample
    application, when the user selects a contact, the application transitions into
    the `contact.index` state, passing his/her ID along. This is possible through
    the use of the `link-to` handlebars expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we will revisit this later, in detail, in [Chapter 4](part0044_split_000.html#page
    "Chapter 4. Writing Application Templates"), *Writing Application Templates*,
    but for now, the important thing to note is that this expression enables us to
    construct a link that points to the said resource by passing the resource name
    and the affected model. The destination resource or route handler is responsible
    for yielding this path constituting **serialization**. To serialize a resource,
    we need to override the matching `serialize` hook as in the contact handler case
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Serialization means that the hook is supposed to return the values of all the
    specified segments. It receives two arguments, the first of which is the affected
    resource and the second is an array of all the specified segments during the resource
    definition. In our case, we only had one and so we returned the required hash
    that resembled the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we, for example, defined a resource with multiple segments like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The serialization hook would need to return something close to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In actual apps, we would often need to load the model data in an asynchronous
    fashion. There are various approaches that can be used to deliver this kind of
    data. The most robust way to load asynchronous data is through use of **promises**.
    Promises are objects whose unknown value can be set at a later point in time.
    It is very easy to create promises in Ember.js. For example, if our contacts were
    located in a remote resource, we could use jQuery to load them as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'jQuery''s HTTP utilities also return promises that Ember.js can consume. As
    a by-the-way, jQuery can also be referenced as `Ember.$` in an Ember.js application.
    In the preceding snippet, once data is loaded, Ember.js would set it as the model
    of the resource. However, one thing is missing. We require that the loaded data
    be converted to the defined contact model, as shown in the following little modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We first create the promise, kick off the XHR request, and then return the promise
    while the request is still being processed. Ember.js will resume routing once
    this promise is rejected or resolved. The XHR call also creates a promise, so
    we need to attach to it the `then` method which essentially says, *invoke the
    passed resolve or reject function on successful or failed load respectively*.
    The `resolve` function converts the loaded data and resolves the promise; passing
    the data along thereby resumes routing. If the promise was rejected, the transition
    fails with an error. We will see how to handle this error in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there are two other flavors we can use to create promises in Ember.js,
    as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The second example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a route's controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just learned that routes provide their corresponding controllers, data that
    they proxy to templates and views. This usually happens in the `setupController`
    hook of the route. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we''ll rarely need to use it, this hook provides a good opportunity
    to modify other controllers. For example, we could set a property on the `application`
    controller as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we may want to specify a different controller that a handler should
    use. For example, the `contact.edit` route is used to edit the `contact` resource
    model. In this case, we needed to specify that the former depended on the latter
    via the `needs` property. That way, as we''ll learn in [Chapter 5](part0061_split_000.html#page
    "Chapter 5. Controllers"), *Controllers*, the `contact.edit` route''s template
    was able to access the model that was set on the controller as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative approach would be to use this controller directly by specifying
    it in the handler as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The result would be that the `contact.edit` template would be similar to that
    of the `contacts.new` template and, therefore both can be removed as explained
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the route's template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss more on route handler template rendering, it''s worth discussing
    what happens when the application transitions between states in the context of
    templates. This section will be revisited in detail in the next chapter. In our
    chapter example, the application eventually knows the transition, as outlined
    in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contacts state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contact state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contact.index state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, the `application` template is first rendered on the screen. The
    next template, `contacts`, is then rendered into the application template to constitute
    the sidebar. Next, the `contact` template is inserted into the `contacts` template.
    Lastly, the `contact.index` template was inserted into the `contact` template
    to complete the transition. Each template specifies an `outlet` portion into which
    child route handlers can render their templates. For example, note the outlet
    expression in the following application template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A route handler can specify the template to use in the same way as controllers.
    Again, revisiting the `contact.edit` route template, it uses a partial, which
    we shall discuss in the next chapter, and includes the shared `contacts.form`
    template into the host template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `renderTemplate` hook is the last chance for the handler to specify a custom
    template to use by invoking the `render` method and passing in the template to
    use along, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can therefore get rid of the defined controllers and routes
    of the `contacts.new` and `contact.edit` routes. Lastly, templates are not limited
    to a single outlet. This means that you can render different templates with different
    controller contexts in the current state template. For example, in a game application,
    we could define two outlets to host two different templates serving different
    purposes as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, render them via the handler as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common use of a handler is to redirect the application into another state
    in the same way we may be redirected to a `404` page if the requested resource
    was not found by the underlying server. In our sample app, the index controller
    overrides the route handler''s `redirect` hook in order to redirect the application
    into the `contacts` state using the `transitionTo` method, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two cases where we may need to perform this redirection. The first
    is when we don''t need to know the model of the route handler. We used one of
    these hooks, `beforeModel`, to populate the contact list local store with fixtures
    just before the same handler went ahead to load them, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can either use the `redirect` and `afterModel` hooks
    if we needed to wait for the handler''s model to load. In fact, the latter actually
    just calls the former. For example, we used the `afterModel` hook in the `contacts`
    route handler in the chapter sample to determine whether we needed to force the
    user to add a new contact or redirect them to view the first contact, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Catching routing errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a transition into a route fails, for example, failure to load the model,
    Ember.js emits the error action in that handler. Although we have not covered
    actions, think of them as events that can be delegated to a handler from templates
    or other route handlers and controllers. The following example catches such errors
    by redirecting the application to an appropriate error handling route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has detailed how states are managed in Ember.js. We have particularly
    discussed how an Ember.js application boots from an application state into other
    nested states. A few concepts were introduced in the chapter sample and will be
    discussed in detail in the next chapter. That being said, in the next chapter,
    we will discuss templates, especially how they render the data proxied by controllers
    and how they delegate user generated actions back to routes. Therefore, you should
    have a solid understanding of the following topics covered in this chapter since
    they''ll be frequently revisited:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining application routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining an application route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a route's model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a route's controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a route's template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing asynchronous routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter will describe how to include templates using script tags or
    compiling and bundling/shipping templates from the server.
  prefs: []
  type: TYPE_NORMAL
