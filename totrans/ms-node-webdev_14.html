<html><head></head><body>
<div><h1 class="chapternumber">13</h1>
<h1 class="chaptertitle" id="_idParaDest-226">Using Sessions</h1>
<p class="normal1">In this chapter, I explain how Node.js applications can correlate HTTP requests to create <em class="italic">sessions</em>, which allow the results of one request to affect the outcome of future requests. <em class="italic">Table 13.1</em> puts this chapter in context.</p>
<p class="packt_figref">Table 13.1: Putting sessions in context</p>
<table class="table-container" id="table001-10">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What are they?</p>
</td>
<td class="table-cell">
<p class="normal">Sessions correlate the requests made by a user, allowing requests to be associated with one another.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why are they useful?</p>
</td>
<td class="table-cell">
<p class="normal">Sessions allow stateful application features to be implemented using stateless HTTP requests.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How are they used?</p>
</td>
<td class="table-cell">
<p class="normal">Cookies are used to transmit small amounts of data or a session ID that is associated with data stored by the server, which identifies related requests.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">Browsers sometimes use cookies in ways that are unhelpful for managing sessions, but with care, sessions have few pitfalls.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">Cookie-based sessions are the only reliable way to correlate HTTP requests, but not all applications require request correlation.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 13.2</em> summarizes the chapter.</p>
<p class="packt_figref">Table 13.2: Chapter summary</p>
<table class="table-container" id="table002-10">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Correlate related HTTP requests</p>
</td>
<td class="table-cell">
<p class="normal">Set and read cookies</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">2-5, 8-10</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Prevent the data stored in cookies from being altered</p>
</td>
<td class="table-cell">
<p class="normal">Sign and verify cookies</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">6, 7</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Store larger amounts of data</p>
</td>
<td class="table-cell">
<p class="normal">Use sessions where the data is stored by the application and accessed using a key stored in a cookie</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">11-15, 19-21</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Persistently store session data</p>
</td>
<td class="table-cell">
<p class="normal">Use a database </p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">16-18</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-227">Preparing for this chapter</h1>
<p class="normal1">This chapter uses the <code class="inlinecode">part2app</code> project from <em class="italic">Chapter 12</em>. No changes are required for this chapter. Run the command shown in <em class="italic">Listing 13.1</em> in the <code class="inlinecode">part2app</code> folder to start the development tools.</p>
<p class="packt_figref">Listing 13.1: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000,</code> fill out the form, and click the <strong class="screentext">Submit</strong> button, as shown in <em class="italic">Figure 13.1</em>.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<figure class="mediaobject"><img alt="" src="img/B21959_13_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 13.1: Running the example application</p>
<h1 class="heading" id="_idParaDest-228">Correlating stateless HTTP requests</h1>
<p class="normal1">HTTP requests are <em class="italic">stateless</em>, meaning that each request is self-contained and contains no information that associates it with any other request, even when made by the <a id="_idIndexMarker626" class="calibre3"/>same browser. You can see the problem this creates by opening two browser windows and filling out the form with the same name but different ages and number of years, simulating two users with the same name.</p>
<p class="normal"> The only information the server has to work with is the data in the form and it has no way to figure out that these are requests from different users, so the users see each other’s data, and any other data created by users with the same name, as shown in <em class="italic">Figure 13.2</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_13_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 13.2: The effect of stateless requests</p>
<p class="normal">Most applications are <em class="italic">stateful</em>, and that means the server has to be able to <em class="italic">correlate</em> requests so that the application can reflect past actions in future responses. In <a id="_idIndexMarker627" class="calibre3"/>the case of the example, this would allow the application to show just the requests made by one user and not just all requests made by anyone who happens to have the same name. </p>
<h2 class="heading1" id="_idParaDest-229">Using cookies to correlate requests</h2>
<p class="normal1">The <a id="_idIndexMarker628" class="calibre3"/>most common way to correlate requests is with a <em class="italic">cookie</em>. Cookies are small fragments of text that a server includes in an HTTP response header. The browser includes the cookies in subsequent requests, which means that if the server creates cookies with unique IDs, those requests can be identified as related. (There are other ways to correlate requests, such as including unique IDs in URLs, but cookies are the most robust and reliable approach.)</p>
<p class="normal">Cookies can be set just like any response header. Add a file named <code class="inlinecode">cookies.ts</code> to the <code class="inlinecode">src/server</code> folder, with the content shown in <em class="italic">Listing 13.2</em>. </p>
<p class="packt_figref">Listing 13.2: The contents of the cookies.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { ServerResponse } from "http";
const setheaderName = "Set-Cookie";
export const setCookie = (resp: ServerResponse, name: string, 
        val: string) =&gt; {
    let cookieVal: any[] = [`${name}=${val}; Max-Age=300; SameSite=Strict }`];   
    if (resp.hasHeader(setheaderName)) {
        cookieVal.push(resp.getHeader(setheaderName));
    }
    resp.setHeader("Set-Cookie", cookieVal);   
}
export const setJsonCookie = (resp: ServerResponse, name: string,
        val: any) =&gt; {
    setCookie(resp, name, JSON.stringify(val));
}
</code></pre>
<p class="normal">Cookies <a id="_idIndexMarker629" class="calibre3"/>are sent to the browser using the <code class="inlinecode">Set-Cookie</code> header, and the header value is a cookie name, a value, and one or more attributes that tell the browser how to manage the cookie. A response can set multiple cookies by including multiple <code class="inlinecode">Set-Cookie</code> headers. For this reason, the code in <em class="italic">Listing 13.2</em> checks to see whether there is an existing <code class="inlinecode">Set-Cookie</code> header and adds its value to the array of values passed to the <code class="inlinecode">setHeader</code> method. When the response is written, Node.js will add a <code class="inlinecode">Set-Cookie</code> header for each element in the array.</p>
<div><p class="normal"><strong class="screentext">User caution</strong></p>
<p class="normal">Consent is required for cookies in some parts of the world, most notably within the EU with the <strong class="screentext">General Data Protection Regulation</strong> (<strong class="screentext">GDPR</strong>). I am not a lawyer, and I am in no way qualified to provide legal advice, but you should make sure you understand the laws in each region where your application has users and make sure you comply with the rules.</p>
</div>
<p class="normal">A header produced by the <code class="inlinecode">setCookie</code> function in <em class="italic">Listing 13.2</em> will look like this:</p>
<pre class="programlisting"><code class="hljs-code">...
Set-Cookie: user=Alice; Max-Age=300; SameSite=Strict
...
</code></pre>
<p class="normal">The cookie name is <code class="inlinecode">user</code>, its value is <code class="inlinecode">Alice</code>, and the cookie has been configured with the <code class="inlinecode">Max-Age</code> and <code class="inlinecode">SameSite</code> attributes, which tell the browser how long<a id="_idIndexMarker630" class="calibre3"/> the cookie is valued for and when to send the cookie. The cookie attributes are described in <em class="italic">Table 13.3</em>. </p>
<p class="packt_figref">Table 13.3: Cookie attributes</p>
<table class="table-container" id="table003-10">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">Domain=value</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This attribute specifies the cookie’s domain, as described after this table.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">Expires=date</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This attribute specifies the time and date when the cookie expires. The data format is described at <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date" class="calibre3">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date</a>. For most projects, the <code class="inlinecode">Max-Age</code> attribute is easier to use.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">HttpOnly</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This attribute tells the browser to prevent JavaScript code from reading the cookie. This is rarely set for web applications that have client-side JavaScript code.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">Max-Age=second</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This attribute specifies the number of seconds until the cookie expires. This attribute takes precedence over <code class="inlinecode">Expires</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">Path=path</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This attribute specifies a path that must be in the URL for the browser to include the cookie.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">SameSite=policy</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This attribute tells the browser whether the cookie should be included in cross-site requests, as described later. The policy options are <code class="inlinecode">Strict</code>, <code class="inlinecode">Lax</code>, and <code class="inlinecode">None</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">Secure</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">When this option is set, the browser will only include the cookie in HTTPS requests and not plain HTTP requests.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Two of the cookie attributes require additional explanation. The <code class="inlinecode">Domain</code> attribute is used to widen the range of requests for which the browser will include a cookie. If a request is sent to <a href="https://users.acme.com" class="calibre3">https://users.acme.com</a>, for example, any cookies that are returned won’t be included in requests to <a href="https://products.acme.com" class="calibre3">https://products.acme.com</a>, which can be a problem for some projects. This can be resolved with the <code class="inlinecode">Domain</code> attribute, which can be set to <code class="inlinecode">acme.com</code>, and telling the browser to include the cookie more broadly. </p>
<p class="normal">The <code class="inlinecode">SameSite</code> attribute is used to control whether the cookie will be included in requests that originate from outside the site that created the cookie, known as the <em class="italic">first-party</em> or same-site <em class="italic">context.</em> The options for the <code class="inlinecode">SameSite</code> attribute are: <code class="inlinecode">Strict</code>, meaning that cookies are only included for requests made <a id="_idIndexMarker631" class="calibre3"/>from the same website that created the cookie, <code class="inlinecode">Lax</code>, which tells the browser to include the cookie when following a link but not for cross-site requests, such as the email, and <code class="inlinecode">None</code>, which means that the cookie is always included.</p>
<p class="normal">Imagine that a user has previously visited <a href="https://www.acme.com" class="calibre3">https://www.acme.com</a> and has received a cookie, after which the user navigates to <code class="inlinecode">www.example.com</code>. The response from <code class="inlinecode">www.example.com</code> contains a link back to <code class="inlinecode">www.acme.com</code>. If the cookie was created with the <code class="inlinecode">Strict</code> option, the browser won’t send the cookie in the request, but it will be included with the <code class="inlinecode">Lax</code> option. The <code class="inlinecode">None</code> option will also cause the browser to include the cookie and will also allow it to be included in requests that are made within frames or that are for images.</p>
<p class="normal">Revisiting the cookies created by the code in <em class="italic">Listing 13.2</em>, you can see that the <code class="inlinecode">Max-Age</code> attribute has been used to give the cookie a 300-second (5-minute) life and that the <code class="inlinecode">SameSite</code> policy is set to <code class="inlinecode">Strict</code>, which means cookies will not be included in requests from outside the cookie’s domain:</p>
<pre class="programlisting"><code class="hljs-code">...
Set-Cookie: user=Alice; <strong class="screentext">Max-Age=300; SameSite=Strict</strong>
...
</code></pre>
<p class="normal">The <code class="inlinecode">setJsonCookie</code> function produces cookies with the same configuration but accepts arbitrary objects that are serialized into the JSON format before being used as the cookie value. </p>
<div><p class="normal"><strong class="screentext">Avoiding cookies without expires and Max-Age attributes</strong></p>
<p class="normal">A cookie that is created without either the <code class="inlinecode">Expires</code> or <code class="inlinecode">Max-Age</code> attributes is a <em class="italic">session cookie</em>, which is a confusing term because this type of cookie isn’t especially useful for creating user sessions, a process I demonstrate later in this chapter. The name “session cookies” means that a cookie is valid for a browsing session, which means they are invalidated when the user closes the browser window, for example.</p>
<p class="normal">Browsers have changed since this type of cookie was created, and session cookies should be avoided because leaving the browser to decide when to invalidate a cookie can produce unexpected results, and cookies can have long and unpredictable lives, especially now that browsers allow users to resurrect browser tabs long after they are closed. Cookies should always be given a fixed life with the <code class="inlinecode">Expires</code> or <code class="inlinecode">Max-Age</code> attributes. </p>
</div>
<h3 class="heading2" id="_idParaDest-230">Receiving cookies</h3>
<p class="normal1">The <a id="_idIndexMarker632" class="calibre3"/>browser includes cookies in requests using the <code class="inlinecode">Cookie</code> header, which contains one or more <code class="inlinecode">name=value</code> pairs, separated by semicolons (the <code class="inlinecode">;</code> character). The attributes used with the <code class="inlinecode">Set-Cookie</code> header are not included, so the header looks like this:</p>
<pre class="programlisting"><code class="hljs-code">...
Cookie: user=Alice; otherCookie=othervalue
...
</code></pre>
<p class="normal"><em class="italic">Listing 13.3</em> defines a function to parse the header and extract the individual cookies. There is also a method for parsing JSON cookie values. </p>
<p class="packt_figref">Listing 13.3: Parsing cookies in the cookies.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { IncomingMessage, ServerResponse } from "http";</strong>
const setheaderName = "Set-Cookie";
export const setCookie = (resp: ServerResponse, name: string, 
        val: string) =&gt; {
    let cookieVal: any[] = [`${name}=${val}; Max-Age=300; SameSite=Strict }`];   
    if (resp.hasHeader(setheaderName)) {
        cookieVal.push(resp.getHeader(setheaderName));
    }
    resp.setHeader("Set-Cookie", cookieVal);   
}
export const setJsonCookie = (resp: ServerResponse, name: string,
        val: any) =&gt; {
    setCookie(resp, name, JSON.stringify(val));
}
<strong class="screentext">export const getCookie = (req: IncomingMessage,</strong>
<strong class="screentext">        key: string): string | undefined</strong><strong class="screentext"> =&gt; {</strong>
<strong class="screentext">    let result: string | undefined = undefined;</strong>
<strong class="screentext">    req.headersDistinct["cookie"]?.forEach(header =&gt; {</strong>
<strong class="screentext">        header.split</strong><strong class="screentext">(";").forEach(cookie =&gt; {</strong>
<strong class="screentext">            const { name, val }</strong>
<strong class="screentext">                = /^(?&lt;name&gt;.*)=(?&lt;val&gt;.*)$/.exec(cookie)?.groups as any;</strong>
<strong class="screentext">            if (name.</strong><strong class="screentext">trim() === key) {</strong>
<strong class="screentext">                result = val;</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">        })</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    return result;</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export const getJsonCookie = (req: IncomingMessage, key: string) : any =&gt; {</strong>
<strong class="screentext">    const cookie = getCookie</strong><strong class="screentext">(req, key);</strong>
<strong class="screentext">    return cookie ? JSON.parse(cookie) : undefined;</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">getCookie</code> function<a id="_idIndexMarker633" class="calibre3"/> uses JavaScript string processing and regular expression features to split up the cookie string and get the name and value to locate a specific cookie. This is not an efficient approach because the cookie header is processed each time a cookie is requested, but it does show how the header can be handled and will be improved upon later in this chapter.</p>
<h3 class="heading2" id="_idParaDest-231">Setting and reading cookies</h3>
<p class="normal1"><em class="italic">Listing 13.4</em> updates <a id="_idIndexMarker634" class="calibre3"/>the code that handles the <code class="inlinecode">/form</code> requests to set a cookie that keeps track of the user’s requests. The cookie’s contents are updated each time a new request is received, and the cookie’s value is read from every request and added to the <a id="_idIndexMarker635" class="calibre3"/>context data passed to the template used to generate a response.</p>
<p class="packt_figref">Listing 13.4: Using cookies in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import repository  from "./data";
<strong class="screentext">import { getJsonCookie, setJsonCookie } from "./cookies";</strong>
const rowLimit = 10;
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", async (req, resp) =&gt; {
        resp.render("age", {
            history: await repository.getAllResults(rowLimit),
           <strong class="screentext"> personalHistory: getJsonCookie(req, "personalHistory")</strong>
        });
    });
    app.post("/form", async (req, resp) =&gt; {
        const nextage = Number.parseInt(req.body.age)
            + Number.parseInt(req.body.years);
        await repository.saveResult({...req.body, nextage });
        <strong class="screentext">let pHistory = [{</strong>
<strong class="screentext">            name: req.body.name, age: req.body.age,</strong>
<strong class="screentext">            years: req.body.</strong><strong class="screentext">years, nextage},</strong>
<strong class="screentext">            ...(getJsonCookie(req, "personalHistory") || [])].splice(0, 5);</strong>
<strong class="screentext"> </strong>
<strong class="screentext">        setJsonCookie(resp, "personalHistory", pHistory);</strong>
<strong class="screentext"> </strong>
<strong class="screentext">        const context = {</strong>
<strong class="screentext">            ...req.body, nextage,</strong>
<strong class="screentext"> </strong><strong class="screentext">history: await repository.getAllResults(rowLimit),</strong>
<strong class="screentext">            personalHistory: pHistory</strong>
        };
        resp.render("age", context);  
    });
}
</code></pre>
<p class="normal">A cookie<a id="_idIndexMarker636" class="calibre3"/> is <a id="_idIndexMarker637" class="calibre3"/>used to store the last five results created for the user. Each new <code class="inlinecode">POST</code> request creates a new <code class="inlinecode">Set-Cookie</code> header in the response, with a new five-minute expiry time. If the user keeps submitting requests, new cookies will be created, effectively extending the user’s session. If no request is made before the cookie expires, then the browser <a id="_idIndexMarker638" class="calibre3"/>will <a id="_idIndexMarker639" class="calibre3"/>discard the cookie and won’t include it in future requests. </p>
<p class="normal"><em class="italic">Listing 13.5</em> updates the partial view that displays recent queries to display the personal history when it is available.</p>
<p class="packt_figref">Listing 13.5: Displaying data in the history.handlebars file in the templates/serve/partials folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">{{#if personalHistory }}</strong>
<strong class="screentext">    &lt;h4&gt;Your History&lt;/h4&gt;</strong>
<strong class="screentext">    &lt;table class="table table-sm table-striped my-2"&gt;</strong>
<strong class="screentext">        {{#each personalHistory }}</strong>
<strong class="screentext">            &lt;tr&gt;</strong>
<strong class="screentext">                &lt;td&gt;{{ this.name }} &lt;/td&gt;</strong>
<strong class="screentext">                &lt;td&gt;{{ this.age }} &lt;/td&gt;</strong>
<strong class="screentext">                &lt;td</strong><strong class="screentext">&gt;{{ this.years }} &lt;/td&gt;</strong>
<strong class="screentext">                &lt;td&gt;{{ this.nextage }} &lt;/td&gt;</strong>
<strong class="screentext">            &lt;/tr&gt;</strong>
<strong class="screentext">        {{/each }}</strong>
<strong class="screentext">    &lt;/table&gt;</strong>
<strong class="screentext">{{/if }}</strong>
&lt;h4&gt;Recent Queries&lt;/h4&gt;
&lt;table class="table table-sm table-striped my-2"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Age&lt;/th&gt;&lt;th&gt;Years&lt;/th&gt;&lt;th&gt;Result&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{#unless history }}
            &lt;tr&gt;&lt;td colspan="4"&gt;No data available&lt;/td&gt;&lt;/tr&gt;
        {{/unless }}
        {{#each history }}
            &lt;tr&gt;
                &lt;td&gt;{{ this.name }} &lt;/td&gt;
                &lt;td&gt;{{ this.age }} &lt;/td&gt;
                &lt;td&gt;{{ this.years }} &lt;/td&gt;
                &lt;td&gt;{{ this.nextage }} &lt;/td&gt;
            &lt;/tr&gt;
        {{/each }}
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p class="normal">Browsers share cookies between tabs so the most reliable way to test the changes to <a id="_idIndexMarker640" class="calibre3"/>the example is to open one regular browser tab and one private or incognito <a id="_idIndexMarker641" class="calibre3"/>browsing tab. Navigate to <code class="inlinecode">http://localhost:5000</code> with both tabs and fill out the form using the same name but different ages and years. Submit the forms and you will see that each browser tab has its own history, as shown in <em class="italic">Figure 13.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_13_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 13.3: Using cookies to correlate requests</p>
<h2 class="heading1" id="_idParaDest-232">Signing cookies</h2>
<p class="normal1">Users<a id="_idIndexMarker642" class="calibre3"/> can change the contents of cookies, and browsers make it easy to add, delete, and alter cookies. The Chrome F12 developer tools, for example, allow cookies to be edited in the <strong class="screentext">Application/Cookies</strong> pane. </p>
<p class="normal">This means that cookies cannot be trusted unless their contents can be verified to ensure they have not been tampered with. Add a file named <code class="inlinecode">cookies_signed.ts</code> to the <code class="inlinecode">src/server</code> folder with the content shown in <em class="italic">Listing 13.6</em>.</p>
<p class="packt_figref">Listing 13.6: The contents of the cookies_signed.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { createHmac, timingSafeEqual } from "crypto";
export const signCookie = (value: string, secret: string) =&gt; {
    return value + "." + createHmac("sha512", secret)
        .update(value).digest("base64url");
}
export const validateCookie = (value: string, secret: string) =&gt; {
    const cookieValue = value.split(".")[0];
    const compareBuf = Buffer.from(signCookie(cookieValue, secret));
    const candidateBuf = Buffer.from(value);
    if (compareBuf.length == candidateBuf.length &amp;&amp;
        timingSafeEqual(compareBuf, candidateBuf)) {
            return cookieValue;
    }
    return undefined;
}
</code></pre>
<p class="normal">Node.js <a id="_idIndexMarker643" class="calibre3"/>provides a comprehensive cryptography API in the <code class="inlinecode">crypto</code> module, which includes support for <strong class="screentext">hash-based message authentication codes</strong> (<strong class="screentext">HMACs</strong>), which are hash codes created using a secret key that can be used to verify data. The <code class="inlinecode">signCookie</code> function in <em class="italic">Listing 13.6</em> uses the Node.js API to create a hash code that can be used as a cookie value.</p>
<p class="normal">The <code class="inlinecode">createHmac</code> function is used to create the hash code generator, using the <strong class="screentext">SHA-512</strong> algorithm and the secret key:</p>
<pre class="programlisting"><code class="hljs-code">...
<strong class="screentext">createHmac("</strong><strong class="screentext">sha512", secret)</strong>.update(value).digest("base64url");
...
</code></pre>
<p class="normal">The <code class="inlinecode">update</code> method is used to apply the hashing algorithm to the cookie value, and the <code class="inlinecode">digest</code> method returns the hash code in the <code class="inlinecode">Base64</code> URL encoding, which allows the hash code to be safely included in the cookie. The result is the data value, followed by a period, followed by the hash code, which will look like this:</p>
<pre class="programlisting"><code class="hljs-code">...
myCookieData.hn5jneGWS_oBL7ww5IHZm9KuzfUwWnnDz01vhNc5xNMwb-kQnxb357Tp
...
</code></pre>
<p class="normal">Real hash codes are longer, but what’s important is that the cookie value isn’t encrypted and can still be seen by the user. The user can still edit the cookie, but the hash code allows those changes to be detected.</p>
<p class="normal">When the<a id="_idIndexMarker644" class="calibre3"/> cookie is submitted, the <code class="inlinecode">validateCookie</code> method generates a new hash code for the cookie value and compares it to the one received in the cookie. Hash codes are <em class="italic">one way</em>, which means they are validated by generating a new hash code for the cookie value included in the HTTP request and comparing it with the previous hash code. </p>
<p class="normal">The Node.js <code class="inlinecode">crypto</code> module provides the <code class="inlinecode">timingSafeEqual</code> function, which performs a byte-by-byte comparison of two <code class="inlinecode">Buffer</code> objects, which are created from the two hash codes to compare.</p>
<p class="normal">The user may be able to alter the cookie value but doesn’t have the secret key required to generate a valid hash code for the altered value. If the hash code received from the request doesn’t match, the cookie data is discarded. <em class="italic">Listing 13.7</em> updates the <code class="inlinecode">setCookie</code> and <code class="inlinecode">getCookie</code> functions so that all the cookies created by the application are signed. </p>
<div><p class="normal"><strong class="screentext">Caution</strong></p>
<p class="normal">Be careful not to commit secret keys to public source code repositories, such as GitHub. One approach is to define sensitive data in <code class="inlinecode">.env</code> files, which can be excluded from code commits. See <em class="italic">Part 3</em> of this book for an example of using this type of configuration file.</p>
</div>
<p class="packt_figref">Listing 13.7: Signing cookies in the cookies.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">import { signCookie, validateCookie } from "./cookies_signed";</strong>
const setheaderName = "Set-Cookie";
<strong class="screentext">const cookieSecret = "mysecret";</strong>
export const setCookie = (resp: ServerResponse, name: string, 
        val: string) =&gt; {
    <strong class="screentext">const signedCookieVal = signCookie(val, cookieSecret);</strong>
<strong class="screentext">    let </strong><strong class="screentext">cookieVal: any[] =</strong>
<strong class="screentext"> [`${name}=${signedCookieVal}; Max-Age=300; SameSite=Strict`];  </strong>         
    if (resp.hasHeader(setheaderName)) {
        cookieVal.push(resp.getHeader(setheaderName));
    }
    resp.setHeader("Set-Cookie", cookieVal);   
}
export const setJsonCookie = (resp: ServerResponse, name: string,
        val: any) =&gt; {
    setCookie(resp, name, JSON.stringify(val));
}
export const getCookie = (req: IncomingMessage,
        key: string): string | undefined =&gt; {
    let result: string | undefined = undefined;
    req.headersDistinct["cookie"]?.forEach(header =&gt; {
        header.split(";").forEach(cookie =&gt; {
            const { name, val }
                = /^(?&lt;name&gt;.*)=(?&lt;val&gt;.*)$/.exec(cookie)?.groups as any;
            if (name.trim() === key) {
                <strong class="screentext">result = validateCookie(val, cookieSecret);</strong>
            }
        })
    });
    return result;
}
export const getJsonCookie = (req: IncomingMessage, key: string) : any =&gt; {
    const cookie = getCookie(req, key);
    return cookie ? JSON.parse(cookie) : undefined;
}
</code></pre>
<p class="normal">There is no<a id="_idIndexMarker645" class="calibre3"/> change in the behavior of the application, but if you use your browser’s developer tools to alter a cookie, you will find that it is ignored when the browser sends a request.</p>
<h2 class="heading1" id="_idParaDest-233">Using a package to manage cookies</h2>
<p class="normal1">The <a id="_idIndexMarker646" class="calibre3"/>previous examples not only demonstrated how the <code class="inlinecode">Set-Cookie</code> and <code class="inlinecode">Cookie</code> headers can be used but also showed that working directly with cookies can be awkward. Express includes support for parsing cookies, as well as generating JSON and signed cookies, without the need to manually format or parse headers. </p>
<p class="normal">Parsing <code class="inlinecode">cookies</code><code class="inlinecode"><a id="_idIndexMarker647" class="calibre3"/></code><code class="inlinecode">.cpp</code> is done using a middleware component, which isn’t included in the main Express package. Run the commands shown in <em class="italic">Listing 13.8</em> in the <code class="inlinecode">part2app</code> folder to install the parsing package and the TypeScript description of its API.</p>
<p class="packt_figref">Listing 13.8: Installing the cookie middleware package</p>
<pre class="programlisting1"><code class="hljs-con">npm install cookie-parser@1.4.6
npm install --save-dev @types/cookie-parser@1.4.6
</code></pre>
<p class="normal"><em class="italic">Listing 13.9</em> enables the cookie parsing middleware and specifies the secret key that will be used for signed cookies.</p>
<p class="packt_figref">Listing 13.9: Applying middleware in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import repository  from "./data";
import { getJsonCookie, setJsonCookie } from "./cookies";
<strong class="screentext">import cookieMiddleware from "cookie-parser"</strong><strong class="screentext">;</strong>
const rowLimit = 10;
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}));
    <strong class="screentext">app.use(cookieMiddleware("mysecret"));</strong>
}
export const registerFormRoutes = (app: Express) =&gt; {
    // ...statements omitted for brevity...
}
</code></pre>
<p class="normal">The middleware populates the <code class="inlinecode">Request</code> object’s <code class="inlinecode">cookies</code> property for regular cookies and the <code class="inlinecode">signedCookies</code> property for signed cookies. Cookies are set using a <code class="inlinecode">cookie</code> property defined by the <code class="inlinecode">Response</code> object. <em class="italic">Listing 13.10</em> uses these features to generate the cookies the application requires and adds a parameter to the <code class="inlinecode">setCookie</code> method to allow the default cookie options to be overridden.</p>
<p class="packt_figref">Listing 13.10: Using the Express cookie features in the cookies.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">//import { IncomingMessage, ServerResponse } from "http";</strong>
<strong class="screentext">//import { signCookie, validateCookie } from "./cookies_signed";</strong>
<strong class="screentext">import { CookieOptions</strong><strong class="screentext">, Request, Response } from "express";</strong>
<strong class="screentext">// const setheaderName = "Set-Cookie";</strong>
<strong class="screentext">// const cookieSecret = "mysecret";</strong>
<strong class="screentext">export const setCookie = (resp: Response, name: string,  val: string,</strong>
<strong class="screentext">        opts?: CookieOptions) =&gt; {</strong>
<strong class="screentext">    resp.</strong><strong class="screentext">cookie(name, val, {</strong>
<strong class="screentext">        maxAge: 300 * 1000,</strong>
<strong class="screentext">        sameSite: "strict",</strong>
<strong class="screentext">        signed: true,</strong>
<strong class="screentext">        ...opts</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">}</strong>
export const setJsonCookie = (resp: Response, name: string, val: any) =&gt; {;
    <strong class="screentext">setCookie(resp, name, JSON.stringify(val));</strong>
}
export const getCookie = (req: Request, key: string): string | undefined =&gt; {
    <strong class="screentext">return req.signedCookies[key];</strong>
}
export const getJsonCookie = (req: Request, key: string) : any =&gt; {
    <strong class="screentext">const cookie = getCookie(req, key);</strong>
<strong class="screentext">    return cookie ? JSON.parse(cookie) : undefined;</strong>
}
</code></pre>
<p class="normal">Express and<a id="_idIndexMarker648" class="calibre3"/>.the cookie middleware take responsibility for creating the <code class="inlinecode">Set-Cookie</code> header in responses and parsing <code class="inlinecode">Cookie</code> headers in requests. The <code class="inlinecode">Response.cookie</code> method is used to create cookies and it accepts a name, a value, and a configuration object. The configuration object has properties that correspond to the cookie attributes described in <em class="italic">Table 13.3</em>, although there are some oddities. For example, the <code class="inlinecode">maxAge</code> configuration is specified in milliseconds, rather than the seconds used by the <code class="inlinecode">Max-Age</code> attribute (which is why the value in <em class="italic">Listing 13.10</em> is multiplied by 1,000).</p>
<p class="normal">The configuration object accepted by the <code class="inlinecode">cookie</code> method supports a <code class="inlinecode">signed</code> property, which enables cookie signing. The key is obtained from the configuration used to set up the cookie middleware, which is another oddity but works, nonetheless. Cookies are signed using an HMAC, in a similar way to the custom code.</p>
<p class="normal">Cookies<a id="_idIndexMarker649" class="calibre3"/> received in requests are available through the <code class="inlinecode">Request.cookies</code> and <code class="inlinecode">Request.signedCookies</code> properties, which return objects whose properties correspond to the names of the cookies in the request. Signed cookies are easily detected because the <code class="inlinecode">Response.cookie</code> method creates signed cookie values with the prefix <code class="inlinecode">s.</code>, and the values are automatically verified using the secret key with which the middleware was configured.</p>
<p class="normal">The changes in <em class="italic">Listing 13.10</em> don’t change the behavior of the application, but the cookies have a different format, and cookies created using the custom code won’t pass verification.</p>
<h1 class="heading" id="_idParaDest-234">Using sessions</h1>
<p class="normal1">Cookies <a id="_idIndexMarker650" class="calibre3"/>are suited to storing small amounts of data, but that data has to be sent to the application with every request, and any changes to that data have to be signed and sent in the response. </p>
<p class="normal">An alternative is to have the application store the data and include just a reference to that data in the cookie. This allows larger amounts of data to be stored without that data being included in every request and response.</p>
<p class="normal">Session data can be stored as a set of key/value pairs, which makes it easy to use JavaScript objects to represent data. I am going to start by creating a memory-based session system and then introduce persistent storage with a database, using a repository layer to make the transition easier. Create the <code class="inlinecode">src/server/sessions</code> folder and add to it a file named <code class="inlinecode">repository.ts</code> with the content shown in <em class="italic">Listing 13.11</em>. </p>
<p class="packt_figref">Listing 13.11: The contents of the repository.ts file in the src/server/sessions folder</p>
<pre class="programlisting"><code class="hljs-code">export type Session = {
    id: string,
    data: { [key: string]: any }
}
export interface SessionRepository {
    createSession() : Promise&lt;Session&gt;;
    getSession(id: string): Promise&lt;Session | undefined&gt;;
    saveSession(session: Session, expires: Date): Promise&lt;void&gt;;
    touchSession(session: Session, expires: Date) : Promise&lt;void&gt;
}
</code></pre>
<p class="normal">The <code class="inlinecode">SessionRepository</code> interface defines methods for creating a session, retrieving <a id="_idIndexMarker651" class="calibre3"/>a previously stored session, and saving or updating a session. The <code class="inlinecode">Session</code> type defines the minimum requirements for a <code class="inlinecode">Session</code>, which entails an ID and a <code class="inlinecode">data</code> property that can be assigned arbitrary data indexed by string values.</p>
<p class="normal">To create a memory-based implementation of the interface, add a file named <code class="inlinecode">memory_repository.ts</code> to the <code class="inlinecode">src/server/sessions</code> folder with the content shown in <em class="italic">Listing 13.12</em>.</p>
<p class="packt_figref">Listing 13.12: The contents of the memory_repository.ts file in the src/server/sessions folder</p>
<pre class="programlisting"><code class="hljs-code">import { Session, SessionRepository } from "./repository";
import { randomUUID } from "crypto";
type SessionWrapper = {
    session: Session,
    expires: Date
}
export class MemoryRepository implements SessionRepository {
    store = new Map&lt;string, SessionWrapper&gt;();
   
    async createSession(): Promise&lt;Session&gt; {
        return { id: randomUUID(), data: {} };
    }
    async getSession(id: string): Promise&lt;Session | undefined&gt; {
        const wrapper = this.store.get(id);
        if (wrapper &amp;&amp; wrapper.expires &gt; new Date(Date.now())) {
            return structuredClone(wrapper.session)
        }
    }
    async saveSession(session: Session, expires: Date): Promise&lt;void&gt; {
        this.store.set(session.id, { session, expires });
    }
    async touchSession(session: Session, expires: Date): Promise&lt;void&gt; {
        const wrapper = this.store.get(session.id);
        if (wrapper) {
            wrapper.expires = expires;
        }
    }
}
</code></pre>
<p class="normal">The Node.js <code class="inlinecode">crypto</code> package defines the <code class="inlinecode">randomUUID</code> function, which generates unique IDs that <a id="_idIndexMarker652" class="calibre3"/>are suitable for use as session IDs. The rest of the implementation uses a <code class="inlinecode">Map</code> to store <code class="inlinecode">Session</code> objects, which are checked for expiration when they are read.</p>
<p class="normal">One point of note is that the <code class="inlinecode">getSession</code> method doesn’t return the <code class="inlinecode">Session</code> from the store, but instead creates a new object, like this: </p>
<pre class="programlisting"><code class="hljs-code">...
if (wrapper &amp;&amp; wrapper.expires &gt; new Date(Date.now())) {
    return <strong class="screentext">structuredClone</strong>(wrapper.session)
}
...
</code></pre>
<p class="normal">The <code class="inlinecode">structuredClone</code> function is part of the standard JavaScript API and it creates a deep copy of an object. Session data should only be modified for <code class="inlinecode">POST</code> requests because the other HTTP methods are idempotent and creating new objects makes it easy to discard changes that are accidentally made for other HTTP methods, which you will see in the next section. This is an issue only when storing states as JavaScript objects, where the <code class="inlinecode">Session</code> object associated with the request is the same as the one in the store. It doesn’t arise when session data is stored in a database.</p>
<h2 class="heading1" id="_idParaDest-235">Creating the session middleware</h2>
<p class="normal1">Sessions <a id="_idIndexMarker653" class="calibre3"/>need to be stored after the response has been generated so that any changes made to the session data are not lost, and that can most easily be done by creating an Express middleware component. Add a file <code class="inlinecode">middleware.ts</code> to the <code class="inlinecode">src/server/sessions</code> folder with the content shown in <em class="italic">Listing 13.13</em>. </p>
<p class="packt_figref">Listing 13.13: The contents of the middleware.ts file in the src/server/sessions folder</p>
<pre class="programlisting"><code class="hljs-code">import { Request, Response, NextFunction } from "express";
import { SessionRepository, Session } from "./repository";
import { MemoryRepository } from "./memory_repository";
import { setCookie, getCookie } from "../cookies";
const session_cookie_name = "custom_session";
const expiry_seconds = 300;
const getExpiryDate = () =&gt; new Date(Date.now() + (expiry_seconds * 1_000));
export const customSessionMiddleware = () =&gt; {
    const repo: SessionRepository = new MemoryRepository();
    return async (req: Request, resp: Response, next: NextFunction) =&gt; {
       
        const id = getCookie(req, session_cookie_name);
   
        const session = (id ? await repo.getSession(id) : undefined)
                            ?? await repo.createSession();
       
        (req as any).session = session;
        setCookie(resp, session_cookie_name, session.id, {
            maxAge: expiry_seconds * 1000
        })
        resp.once("finish", async () =&gt; {
            if ( Object.keys(session.data).length &gt; 0) {
                if (req.method == "POST") {
                    await repo.saveSession(session, getExpiryDate());
                } else {
                    await repo.touchSession(session, getExpiryDate());
                }
            }
        })
       
        next();
    }
}
</code></pre>
<p class="normal">This middleware component reads a cookie that contains a session ID and uses it to get the session from the repository and associate it with the <code class="inlinecode">Request</code> object by adding a property named <code class="inlinecode">session</code>. If there is no cookie, or no session can be found with the ID, then a new session is started.</p>
<p class="normal">The session<a id="_idIndexMarker654" class="calibre3"/> can only be safely stored once the response has been generated and when it is certain that no further changes will be made. The <code class="inlinecode">finish</code> event is triggered once a response is complete, and the <code class="inlinecode">once</code> method is used to handle the event and store the session.</p>
<p class="normal">Sessions are only stored for HTTP <code class="inlinecode">POST</code> requests and when properties have been assigned to the <code class="inlinecode">data</code> object. For other HTTP methods, the <code class="inlinecode">touchSession</code> method is used to extend the session expiry time but the session data isn’t stored.</p>
<p class="normal">Updating the session expiry after every request creates a <em class="italic">sliding expiry</em>, which means that the session can remain valid indefinitely. This is the most common approach because it means sessions are valid for as long as the user is active and will time out after a period of inactivity.</p>
<h2 class="heading1" id="_idParaDest-236">Using the session feature</h2>
<p class="normal1">The <a id="_idIndexMarker655" class="calibre3"/>middleware component adds a <code class="inlinecode">session</code> property to requests, but this isn’t a part of the standard Express <code class="inlinecode">Request</code> type and isn’t known by the TypeScript compiler. There are two good ways to solve this problem: a helper function that reads the <code class="inlinecode">session</code> property or a new type that extends the one provided by Express. Add a file named <code class="inlinecode">session_helpers.ts</code> to the <code class="inlinecode">src/server/sessions</code> folder with the content shown in <em class="italic">Listing 13.14</em>. </p>
<p class="packt_figref">Listing 13.14: The contents of the session_helpers.ts file in the src/server/sessions folder</p>
<pre class="programlisting"><code class="hljs-code">import { Request } from "express";
import { Session } from "./repository";
export const getSession = (req: Request): Session =&gt; (req as any).session;
declare global {
    module Express {
        interface Request {
            session: Session
        }
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">getSession</code> function receives a <code class="inlinecode">Request</code> object and returns the <code class="inlinecode">session</code> property by <a id="_idIndexMarker656" class="calibre3"/>using <code class="inlinecode">as any</code> to work around the TypeScript type checks. The <code class="inlinecode">declare</code> keyword is used to tell TypeScript that the <code class="inlinecode">Request</code> interface has an additional property.</p>
<p class="normal">Of the two approaches, my preference is the helper function, which isn’t as elegant, but which is more easily understood and makes it obvious how the <code class="inlinecode">Session</code> object is being obtained. <em class="italic">Listing 13.15</em> applies both approaches to switch from storing session data in the cookie to using the session repository.</p>
<p class="packt_figref">Listing 13.15: Using the session repository in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import repository  from "./data";
import { getJsonCookie, setJsonCookie } from "./cookies";
import cookieMiddleware from "cookie-parser";
<strong class="screentext">import { customSessionMiddleware } from "./sessions/middleware";</strong>
<strong class="screentext">import { getSession } from "./sessions/session_helpers";</strong>
const rowLimit = 10;
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
    app.use(cookieMiddleware("mysecret"));
    <strong class="screentext">app.use(customSessionMiddleware());</strong>
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", async (req, resp) =&gt; {
        resp.render("age", {
            history: await repository.getAllResults(rowLimit),
            <strong class="screentext">personalHistory: getSession(req).data.</strong><strong class="screentext">personalHistory</strong>
        });
    });
    app.post("/form", async (req, resp) =&gt; {
        const nextage = Number.parseInt(req.body.age)
            + Number.parseInt(req.body.years);
        await repository.saveResult({...req.body, nextage });
        <strong class="screentext">req.session.data.personalHistory = [{</strong>
<strong class="screentext">            name: req.</strong><strong class="screentext">body.name, age: req.body.age,</strong>
<strong class="screentext">            years: req.body.years, nextage},</strong>
<strong class="screentext">            ...(req.session.data.</strong><strong class="screentext">personalHistory || [])].splice(0, 5);</strong>
       
        const context = {
            ...req.body, nextage,
            history: await repository.getAllResults(rowLimit),
           <strong class="screentext"> personalHistory: req.</strong><strong class="screentext">session.data.personalHistory</strong>
        };
        resp.render("age", context);  
    });
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker657" class="calibre3"/>changes enable the session middleware and store the user’s history using the new session feature. Once again, there is no change in the way the application behaves, because the changes are invisible to the user. As the form is submitted, the cookie sent by the browser is used to load the session data from the repository, which is used in the response, as shown in <em class="italic">Figure 13.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_13_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 13.4: Using session data</p>
<h2 class="heading1" id="_idParaDest-237">Storing session data in a database</h2>
<p class="normal1">Storing session <a id="_idIndexMarker658" class="calibre3"/>data in memory is a good way to understand how the pieces fit together but isn’t ideal for real projects where more persistent storage is usually required. The conventional approach is to store session data in a database, which ensures that sessions are persistent, and allows for large numbers of sessions without exhausting system memory.</p>
<p class="normal">Add a file named <code class="inlinecode">orm_models.ts</code> to the <code class="inlinecode">src/server/sessions</code> folder, with the content shown in <em class="italic">Listing 13.16</em>. </p>
<p class="packt_figref">Listing 13.16: The contents of the orm_models.ts file in the src/server/sessions folder</p>
<pre class="programlisting"><code class="hljs-code">import { DataTypes, InferAttributes, InferCreationAttributes, Model,
    Sequelize } from "sequelize";
export class SessionModel extends Model&lt;InferAttributes&lt;SessionModel&gt;,
        InferCreationAttributes&lt;SessionModel&gt;&gt; {
    declare id: string
    declare data: any;
    declare expires: Date
}
export const initializeModel = (sequelize: Sequelize) =&gt; {
    SessionModel.init({
        id: { type: DataTypes.STRING, primaryKey: true },
        data: { type: DataTypes.JSON },
        expires: { type: DataTypes.DATE }
    }, { sequelize });
}
</code></pre>
<p class="normal">A single <a id="_idIndexMarker659" class="calibre3"/>model class can represent a session and the IDs generated by the <code class="inlinecode">crypto.randomUUID</code> function can be used as primary keys. Sequelize has good support for working with JavaScript dates and will automatically serialize and deserialize objects when the type of a column is <code class="inlinecode">DataTypes.JSON</code>. To create a session repository, add a file named <code class="inlinecode">orm_repository.ts</code> in the <code class="inlinecode">src/server/sessions</code> folder, with the content shown in <em class="italic">Listing 13.17</em>. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The <code class="inlinecode">initModelAndDatabase</code> method in <em class="italic">Listing 13.17</em> calls the <code class="inlinecode">drop</code> method, which will reset the database every time the application is started or restarted. This should not be done in a real project, but it is helpful for an example and ensures that any changes in the code files will be reflected in the database.</p>
</div>
<p class="packt_figref">Listing 13.17: The contents of the orm_repository.ts file in the src/server/sessions folder</p>
<pre class="programlisting"><code class="hljs-code">import { Op, Sequelize } from "sequelize";
import { Session, SessionRepository } from "./repository";
import { SessionModel, initializeModel } from "./orm_models";
import { randomUUID } from "crypto";
export class OrmRepository implements SessionRepository {
    sequelize: Sequelize;
    constructor() {
        this.sequelize = new Sequelize({
            dialect: "sqlite",
            storage: "orm_sessions.db",
            logging: console.log,
            logQueryParameters: true
        });
        this.initModelAndDatabase();
    }
   
    async initModelAndDatabase() : Promise&lt;void&gt; {
        initializeModel(this.sequelize);
        await this.sequelize.drop();       
        await this.sequelize.sync();
    }
    async createSession(): Promise&lt;Session&gt; {
        return { id: randomUUID(), data: {} };
    }
    async getSession(id: string): Promise&lt;Session | undefined&gt; {
        const dbsession = await SessionModel.findOne({
            where: { id, expires: { [Op.gt] : new Date(Date.now()) }}
        });
        if (dbsession) {
            return { id, data: dbsession.data };
        }
    }
    async saveSession(session: Session, expires: Date): Promise&lt;void&gt; {
        await SessionModel.upsert({
            id: session.id,
            data: session.data,
            expires
        });
    }
    async touchSession(session: Session, expires: Date): Promise&lt;void&gt; {
        await SessionModel.update({ expires }, { where: { id: session.id } });
    }
}
</code></pre>
<p class="normal">The repository is similar to the one created for application data, but there are a couple of points that show how an ORM (Object Relational Mapping) like Sequelize can<a id="_idIndexMarker660" class="calibre3"/> simplify dealing with a database, albeit with awkward JavaScript code. The <code class="inlinecode">getSession</code> method queries the database to find a row with a given primary key and an expiry date in the future, which is done using the <code class="inlinecode">findOne</code> method and a <code class="inlinecode">where</code> expression, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
const dbsession = await SessionModel.findOne({
    <strong class="screentext">where: { id, expires: { [Op.gt] : new </strong><strong class="screentext">Date(Date.now()) }}</strong>
});
...
</code></pre>
<p class="normal">The <code class="inlinecode">Op.gt</code> value represents a greater comparison and allows the search to match rows where the date stored in the <code class="inlinecode">expires</code> column is greater than the current date. This isn’t the most natural way to express queries, but it works and allows queries to be expressed without needing to write SQL.</p>
<p class="normal">The Sequelize <code class="inlinecode">upsert</code> method is used to update a data row if it exists and insert one if not, which makes it easy to implement the <code class="inlinecode">saveSession</code> method. The <code class="inlinecode">touchSession</code> method is implemented with the <code class="inlinecode">update</code> method, which allows specific columns to be updated.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">I have not added any support for deleting expired sessions in this chapter. As a rule, I avoid deleting any data automatically because it is easy for things to go wrong. Storage space is relatively affordable but if you need to actively manage the size of the session database, then backing up before a manual cleanup is a safer option. </p>
</div>
<p class="normal">The final step is to update the session middleware to use the new repository, as shown in <em class="italic">Listing 13.18</em>.</p>
<p class="packt_figref">Listing 13.18: Changing repository in the middleware.ts file in the src/server/sessions folder</p>
<pre class="programlisting"><code class="hljs-code">import { Request, Response, NextFunction } from "express";
import { SessionRepository, Session } from "./repository";
<strong class="screentext">//import { MemoryRepository } from "./memory_repository";</strong>
import { setCookie, getCookie } from "../cookies";
i<strong class="screentext">mport { OrmRepository } from "</strong><strong class="screentext">./orm_repository";</strong>
const session_cookie_name = "custom_session";
const expiry_seconds = 300;
const getExpiryDate = () =&gt; new Date(Date.now() + (expiry_seconds * 1_000));
export const customSessionMiddleware = () =&gt; {
    <strong class="screentext">//const repo: SessionRepository = new MemoryRepository();</strong>
<strong class="screentext">    const repo: SessionRepository = </strong><strong class="screentext">new OrmRepository();</strong>
    return async (req: Request, resp: Response, next: NextFunction) =&gt; {
       
        // ...statements omitted for brevity...
    }
}
</code></pre>
<p class="normal">No other<a id="_idIndexMarker661" class="calibre3"/> change is required to use the database because the new repository implements the same interface as the old one. </p>
<p class="normal">The key difference is that you will see the database queries being logged by the Node.js console as the application is running, starting with the statement that creates the database table:</p>
<pre class="programlisting1"><code class="hljs-con">...
Executing (default): CREATE TABLE IF NOT EXISTS `SessionModels` (`id` VARCHAR(255)
    PRIMARY KEY, `data` JSON, `expires` DATETIME, `createdAt` DATETIME NOT NULL,
    `updatedAt` DATETIME NOT NULL);
...
</code></pre>
<p class="normal">No SQL was required to prepare or query the database and the process of creating and parsing JSON is handled automatically.</p>
<h1 class="heading" id="_idParaDest-238">Using a package for sessions</h1>
<p class="normal1">Now that<a id="_idIndexMarker662" class="calibre3"/> you understand how sessions work, it is time to replace the custom code with an off-the-shelf sessions package, such as the one provided by Express. Run the commands shown in <em class="italic">Listing 13.19</em> in the <code class="inlinecode">part2app</code> folder to install the sessions package, the type description package for its API, and a package that stores sessions in a database <a id="_idIndexMarker663" class="calibre3"/>using Sequelize. (There is a wide range of database options for the express-sessions package, described at <a href="https://github.com/expressjs/session" class="calibre3">https://github.com/expressjs/session</a>). </p>
<p class="packt_figref">Listing 13.19: Installing packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install express-session@1.17.3
npm install connect-session-sequelize@7.1.7
npm install --save-dev @types/express-session@1.17.10
</code></pre>
<p class="normal"><em class="italic">Listing 13.20</em> prepares <a id="_idIndexMarker664" class="calibre3"/>the application to use the session package and the storage package.</p>
<p class="packt_figref">Listing 13.20: Using the session package in the session_helpers.ts file in the src/server/sessions folder</p>
<pre class="programlisting"><code class="hljs-code">import { Request } from "express";
<strong class="screentext">//import { Session } from "./repository";</strong>
<strong class="screentext">import session, { SessionData } from "express-session";</strong>
<strong class="screentext">import sessionStore from "</strong><strong class="screentext">connect-session-sequelize";</strong>
<strong class="screentext">import { Sequelize } from "sequelize";</strong>
<strong class="screentext">import { Result } from "../data/repository";</strong>
<strong class="screentext">export</strong><strong class="screentext"> const getSession = (req: Request): SessionData =&gt; (req as any).session;</strong>
<strong class="screentext">// declare global {</strong>
<strong class="screentext">//     module Express {</strong>
<strong class="screentext">//         interface Request {</strong>
<strong class="screentext">//             session: Session</strong>
<strong class="screentext">//         }</strong>
<strong class="screentext">//     }</strong>
<strong class="screentext">// }</strong>
<strong class="screentext">declare module "express-session" {</strong>
<strong class="screentext">    interface </strong><strong class="screentext">SessionData {</strong>
<strong class="screentext">       personalHistory: Result[];</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export const sessionMiddleware = () =&gt; {</strong>
<strong class="screentext">    const sequelize = new Sequelize({</strong>
<strong class="screentext">        dialect: "</strong><strong class="screentext">sqlite",</strong>
<strong class="screentext">        storage: "pkg_sessions.db"</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    const store = new (sessionStore(session.Store))({</strong>
<strong class="screentext">        db: sequelize</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    store.sync();</strong>
<strong class="screentext">    return </strong><strong class="screentext">session({</strong>
<strong class="screentext">        secret: "mysecret",</strong>
<strong class="screentext">        store: store,</strong>
<strong class="screentext">        cookie: { maxAge: 300 * 1000, sameSite: "strict" },</strong>
<strong class="screentext"> </strong><strong class="screentext">resave: false, saveUninitialized: false</strong>
<strong class="screentext">    })</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">Adjustments <a id="_idIndexMarker665" class="calibre3"/>are required to use the package, including <em class="italic">commenting out</em> the <code class="inlinecode">declare</code> statement that adds the <code class="inlinecode">Request.session</code> property because there is a similar statement defined by the <code class="inlinecode">express-session</code> package.</p>
<p class="normal">A new <code class="inlinecode">declare</code> statement is required to add custom properties to the <code class="inlinecode">SessionData</code> object, which is the type used to represent session data by the package. There is a <code class="inlinecode">Session</code> type, but it serves a purpose similar to the wrapper type employed by the custom code. In this case, a <code class="inlinecode">personHistory</code> property has been added to minimize the changes required to use the package.</p>
<p class="normal">The <code class="inlinecode">sessionMiddleware</code> function creates a <code class="inlinecode">Sequelize</code> object that uses SQLite and uses it to create a store for session data using the <code class="inlinecode">connect-session-sequelize</code> package. The <code class="inlinecode">sync</code> method is called to initialize the database, and the default export from the <code class="inlinecode">express-session</code> package is used to create a middleware component. The configuration options for the session store are described at <a href="https://github.com/expressjs/session" class="calibre3">https://github.com/expressjs/session</a>, but the configuration in <em class="italic">Listing 13.20</em> specifies the secret key for signing cookies, the Sequelize store, and the cookie settings so that the package behaves in the same way as the custom code. Small changes are required to use the session package, as shown in <em class="italic">Listing 13.21</em>.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The <code class="inlinecode">cookie-parser</code> package can be used in the same application as the <code class="inlinecode">express-session</code> package, but you must ensure that both are configured with the same secret key.</p>
</div>
<p class="packt_figref">Listing 13.21: Using the session package in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import repository  from "./data";
import { getJsonCookie, setJsonCookie } from "./cookies";
import cookieMiddleware from "cookie-parser";
import { customSessionMiddleware } from "./sessions/middleware";
<strong class="screentext">import { getSession, sessionMiddleware } from "./sessions/session_helpers";</strong>
const rowLimit = 10;
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
    app.use(cookieMiddleware("mysecret"));
    <strong class="screentext">//app.use(customSessionMiddleware());</strong>
<strong class="screentext">    app.use(sessionMiddleware());</strong>
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", async (req, resp) =&gt; {
        resp.render("age", {
            history: await repository.getAllResults(rowLimit),
            <strong class="screentext">personalHistory: getSession(req).personalHistory</strong>
        });
    });
    app.post("/form", async (req, resp) =&gt; {
        const nextage = Number.parseInt(req.body.age)
            + Number.parseInt(req.body.years);
        await repository.saveResult({...req.body, nextage });
        <strong class="screentext">req.session.personalHistory = [{</strong>
            id: 0, name: req.body.name, age: req.body.age,
            years: req.body.years, nextage},
            ..<strong class="screentext">.(req.session.personalHistory || [])].splice(0, 5);</strong>
       
        const context = {
            ...req.body, nextage,
            history: await repository.getAllResults(rowLimit),
            <strong class="screentext">personalHistory: req.session.personalHistory</strong>
        };
        resp.render("age", context);  
    });
}
</code></pre>
<p class="normal">The changes replace<a id="_idIndexMarker666" class="calibre3"/> the custom middleware and read the <code class="inlinecode">personalHistory</code> property directly on the object returned by the <code class="inlinecode">session</code> property. The schema of the database used to store sessions is different, which you can see in the SQL statements that are written out by the Node.js console, but otherwise, the behavior of the application is unchanged.</p>
<h1 class="heading" id="_idParaDest-239">Summary</h1>
<p class="normal1">In this chapter, I explained how an application can use cookies to correlate HTTP requests to create a stateful user experience over a stateless protocol:</p>
<ul class="calibre4">
<li class="bulletlist">Cookies are created by adding the <code class="inlinecode">Set-Cookie</code> header to responses.</li>
<li class="bulletlist1">Browers include cookies in requests with the <code class="inlinecode">Cookie</code> header.</li>
<li class="bulletlist1">Cookies are configured using cookie attributes, including setting an expiration time, after which the browser will no longer include the cookie in requests.</li>
<li class="bulletlist1">Cookies can be signed, which reveals when they have been altered.</li>
<li class="bulletlist1">Cookies can be used to store small amounts of data, but this data must then be repeatedly transferred between the browser and the server.</li>
<li class="bulletlist1">Cookies can also be used to store session IDs, which are used to load data stored by the server. This makes the server more complicated but means that only the ID is transferred between the browser and the server.</li>
</ul>
<p class="normal">In the next chapter, I will describe how RESTful web services can be used to provide data to clients without including HTML.</p>
</div>
</body></html>