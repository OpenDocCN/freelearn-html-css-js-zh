<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-109"><a id="_idTextAnchor108"/>7</h1>
<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Creating a Full Stack Framework</h1>
<p>In <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a>, we learned a practical example of building a simple JavaScript testing framework. In this chapter, we will continue this practical approach, further diving into the development of frameworks.</p>
<p>The next goal is to develop a full stack framework that will enable developers to build large and small web applications. This chapter will start off by developing the backend parts of such a framework, focusing on the server-side components and integrating essential developer tooling. These backend components, once established, will help us support the frontend elements of the framework we will create in <a href="B19014_08.xhtml#_idTextAnchor138"><em class="italic">Chapter 8</em></a>. Developing the backend feature set in this chapter will help us do the following:</p>
<ul>
<li>Define the technical architecture and goals of our new full stack framework. This is similar to the <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a> exercise, but now we will switch the context and focus more on the technical challenges of the backend server functionality.</li>
<li>Learn more about the components that are required to produce functioning full stack tooling. We will study and explore the abstractions we can build and the core parts of the framework that will make it usable in many development scenarios.</li>
<li>Identify the features that will improve usability, focusing on the features that empower developers and increase efficiency. These comprise tools that help automatically generate the framework scaffold from a template and enhance development productivity.</li>
</ul>
<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/>Technical requirements</h1>
<p>The implemented framework code is in the book repository at <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>. The assets and code are in the <code>chapter7</code> directory. As with <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a>, we will utilize Node.js v20 or higher for this project.</p>
<p>Refer to the <code>README.md</code> file of the framework in the chapter directory if you want to run or tweak the framework files locally. <code>npm scripts</code> can be handy to use shortcuts during development. As with other projects, to begin working on the framework, you need to install the dependencies with <code>npm install</code>.</p>
<p>The framework provides an executable that helps create the scaffold outline of the project, run the newly created application, and more. To locally install the <code>componium</code> framework executable from the <code>chapter7</code> directory, you can link the executable to use it in different directories. To achieve this, from the checked-out repository directory, use <code>npm link &lt;path&gt;/chapter7/componium</code>. This will link a global framework executable to your terminal shell that you can use in a sample project. In addition, if you make any changes to the framework files, the executable will pick up the changes instantly, as the script is directly linked. Check out the detailed <code>npm link</code> instructions at <a href="https://docs.npmjs.com/cli/commands/npm-link">docs.npmjs.com/cli/commands/npm-link</a> and the following note about Windows compatibility.</p>
<p class="callout-heading">A note about Windows compatibility</p>
<p class="callout">There are a few things to keep in mind when working with framework executables and commands such as <code>npm link</code> in the Windows OS. When running <code>npm link chapter7\componium</code> or other commands, you may experience some issues with the executable environment. There are a few common errors that can occur, including the following.</p>
<p class="callout">If you get an error related to <code>enoent ENOENT: no such file or directory AppData\Roaming\npm</code>, make sure to create that directory in the mentioned path. This is usually an artifact of the <code>npm</code> installer on Windows.</p>
<p class="callout">If you get an issue with <code>UnauthorizedAccessException</code>, this is a standard security measure of Windows. To fix this, run <code>Set-ExecutionPolicy RemoteSigned</code> and allow the execution. For more information, refer to Microsoft’s documentation at <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy">learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy</a>.</p>
<p class="callout">You can also refer to the <em class="italic">Common errors</em> article for npm at <a href="https://docs.npmjs.com/common-errors">docs.npmjs.com/common-errors</a>. If you can successfully run <code>componium --version</code> using your PowerShell or Command Prompt, then your environment is correctly configured.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Full stack framework goals</h1>
<p>Before <a id="_idIndexMarker479"/>we get to the software architecture part of this project, we need to get a better insight into what a full stack framework will entail, especially in the JavaScript context and the language’s ecosystem. When developing a full stack JavaScript framework, we get to create a blend of abstractions and conventions to help developers produce a combination of frontend and backend components, given the modular nature of the JavaScript language and its ecosystem. From the JavaScript-language point of view, the framework can utilize the latest syntax and functional improvements, such as ES6 modules and modern web APIs. Ecosystem-wise, we will heavily rely on already-established modules to enable certain functionality. Similar to the approach in <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a>, this strategy allows us to stay focused on the larger system design and achieve much better feature coverage.</p>
<p>The primary objective of a full stack framework is to simplify the application development process, making it faster and more efficient by providing a structured and standardized way to build applications. We have seen examples of the variety of these technical solutions in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, where frameworks such as Next.js create a much more streamlined and opinionated workflow across the whole stack. The projects, similar to Next.js, encapsulate all aspects of development and cover many use cases, seeking to eliminate the necessity of deciding on different technologies for different layers of development and offer a single unified vision. One of the goals of our sample framework project in this chapter is to focus on similar examples of developing a unified feature set, where components fit naturally together.</p>
<p>The implementation vision of the framework in this chapter should offer a unified API such that the developers utilizing the API can easily get acquainted with its structure and functionality, reducing the learning curve typically associated with new technology adoption. The familiarity and interoperability between different features ensure a seamless experience for developers. The framework API provides abstractions (highlighted in <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a> in the <em class="italic">About abstractions</em> section) that make complex operations simple without compromising the flexibility required for advanced use cases. The approach to creating easy-to-use public framework API interfaces is essential to support the varying skill levels of developers and the requirements of robust applications. When you develop or support a full stack framework similar to the practical example in this chapter, you will also have to take a variety of features into consideration. You will find that in your particular scenario, you will invest more in a feature set that is a higher priority for your organization.</p>
<p>Looking at the<a id="_idIndexMarker480"/> server-side feature set first, a full stack JavaScript framework must be able to provide a set of fundamental building blocks to handle standard use cases, based on different technological challenges. The features powered by such building blocks could include request routing, database integrations, unified interfaces for events, logging, and performance scaling. In some cases, a framework can also offer features beyond what a developer requires in their projects. Therefore, as part of the development process, we have to strike a balance between using the built-in features and offering a variety of extensibility options. We have seen instances of this in the <em class="italic">Plugin and extension APIs</em> section of <a href="B19014_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, where the server-side frameworks included a way to extend and enable additional functionality. Besides providing a sizeable, flexible feature set with the best developer experience, the applications must be easily deployable and have a way to be monitored once operating in production environments. In this case, pursue a goal of making it easy for developers to deploy their applications, scale those applications up as they get more traffic, and monitor latency and error rates. This involves building in utilities to set up multiple server instances, defining database migrations, and more.</p>
<p>As we define the<a id="_idIndexMarker481"/> expected functionality of a full stack framework, we need to define how much the frontend and backend features will interact with each other and where we would like to start the initial development. Considerations for those two sides of a full stack framework are explored in the next sections.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Frontend functionality</h2>
<p>On the frontend side of a<a id="_idIndexMarker482"/> full stack framework, the emphasis should be on providing seamless integration of frontend components that interact well with backend services. Examples of these types of features could be easily fetching data from the server, rendering frontend components, and having access to the static files. Ember.js, along with EmberData, provides real-world examples of how to effectively collaborate with server-side systems. Another example is Next.js, which provides a tightly integrated solution for both the server and the client. Generally, the opinionated components can define how the framework interacts with the data received from the network requests, and how the data is bound to views and components on the frontend.</p>
<p>The frontend<a id="_idIndexMarker483"/> feature set should be capable of handling standard frontend requirements as well. These could include working with popular libraries by offering an easy way to integrate those libraries into projects. An extensive frontend solution should facilitate client-side routing and the ability to manage dependencies and handle form validation, user input sanitization, and JavaScript code bundling. Application state management is another significant component that can help manage the complexity of larger projects.</p>
<div><div><img alt="Figure 7.1: The focus of a full stack framework" src="img/Figure_7.1_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: The focus of a full stack framework</p>
<p>Ultimately, the process of developing a comprehensive full stack framework calls for the exploration of considerable facets of technology. This initiative also necessitates a broad spectrum of programming skills. You’ll be expected to delve into both the complexities of the frontend features, where you will be concerned with user experience, and the backend challenges, focusing on servers, databases, and application logic. The development process enhances your coding abilities and promotes a better understanding of the entire web development ecosystem. In <em class="italic">Figure 7</em><em class="italic">.1</em>, we break down the two important aspects of our framework development. The <strong class="bold">Features</strong> will provide the<a id="_idIndexMarker484"/> necessary functionality to build frontend and backend components, interacting with services such as a database, and the <strong class="bold">Developer Experience</strong> will make these features reusable and easily accessible for application projects. The result of all this work will be a project usable by a variety of stakeholders, satisfying the respective needs of developers to produce web applications that power new services and web-based software products.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>Backend functionality</h2>
<p>We start with backend feature<a id="_idIndexMarker485"/> development first. This approach will serve the project as a foundation to later add frontend features on top of it to complete the full stack feature set. We will focus on frontend features and architecture in the next chapter. For now, we will imagine that our backend framework can deliver files to the browser client and can be used with any frontend framework. Browser-based applications can make requests to the server-side components to fetch data, static files, or web pages.</p>
<div><div><img alt="Figure 7.2: Our full stack framework logo" src="img/Figure_7.2_B19014.png.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Our full stack framework logo</p>
<p>We will reuse the same Componium project identity and branding that was established in <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a>. We now have a new logo, as shown in <em class="italic">Figure 7</em><em class="italic">.2</em>, to serve as a branding example that identifies our full stack project. The Componium term and branding will cover all parts of the framework will be utilized in the command-line interface as well. Keeping the target developer user base in mind, here is a list of potential starter backend features for this project:</p>
<ul>
<li><strong class="bold">API deployment</strong>: The<a id="_idIndexMarker486"/> ability to deploy an API service. The API functionality should be flexible enough to allow us to easily configure endpoints and add functional middleware to a selection of endpoints. The API capabilities should also include a modular approach to defining GraphQL resources and schemas.</li>
<li><strong class="bold">Page rendering features</strong>: The ability to deliver web pages with custom and reusable layouts containing <a id="_idIndexMarker487"/>static and dynamic data.</li>
<li><strong class="bold">Middleware mechanisms</strong>: Features that can add various types of server middleware, such as<a id="_idIndexMarker488"/> authentication, to all or some of the routes of the application.</li>
<li><strong class="bold">Database capabilities</strong>: Database <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) capabilities that provide the <a id="_idIndexMarker489"/>ability to use different types of database<a id="_idIndexMarker490"/> technologies.</li>
<li><strong class="bold">Application scalability</strong>: Designed to<a id="_idIndexMarker491"/> handle high-load situations and offer scalability and performance optimization options. The framework should provide the necessary tools to test, debug, and deploy an application.</li>
<li><strong class="bold">Development tools</strong>: The framework offers a variety of helpers to ease the development process. The<a id="_idIndexMarker492"/> tools can include application bootstrapping and scaffolding of standard components. Live-reloading of the backend server can also save a lot of time by avoiding manually restarting the process on every change.</li>
</ul>
<p>These<a id="_idIndexMarker493"/> functionality goals are now defined in enough detail, covering both the frontend and backend experiences. Utilizing the considerations in this section, we are ready to proceed to the exciting steps of architecting the initial parts of the full stack framework.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Architecture</h1>
<p>Now that<a id="_idIndexMarker494"/> we have a clearer definition of the backend features, we can start architecting the packages and components of the framework. We will need encapsulation for server and routing interfaces, as well as additional components that allow us to communicate with databases, fetch particular application configurations, and report metrics or logs through logging.</p>
<div><div><img alt="Figure 7.3: The request life cycle" src="img/Figure_7.3_B19014.png.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: The request life cycle</p>
<p><em class="italic">Figure 7</em><em class="italic">.3</em> represents a simplified view of the request life cycle that our framework will process. The requests can originate in a browser client or, potentially, be direct requests to an API endpoint of the server that our framework needs to handle. You can find a sample<a id="_idIndexMarker495"/> application built using our framework in the chapter directory under <code>tests/sample</code>.</p>
<div><div><img alt="Figure 7.4: A sample application layout" src="img/Figure_7.4_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: A sample application layout</p>
<p>We now have<a id="_idIndexMarker496"/> an overview of how a framework processes requests through its internals. <em class="italic">Figure 7</em><em class="italic">.4</em> shows an example of an application layout, consisting of the backend API and GraphQL routes. Developers can utilize this structure to build different types of server-side applications. In the following sections, we will take an in-depth look at the entry points, router, configuration, database, and observability features that make this application layout possible. You can find the files in the chapter directory under <code>componium/tests/sample</code>. Some of the files, such as the <code>*.log</code> files, will automatically generate when the application starts and produces some logging; normally, these log files are ignored by the version control system.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Entry point</h2>
<p>The server file is the entry point to<a id="_idIndexMarker497"/> provide most of the capabilities of our backend framework. It bootstraps a process, loads the appropriate configuration, connects to a database if specified, and establishes the request route handlers. In <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a>, we had a simpler server (located in the project file at <code>componium-test/blob/main/packages/browser/server.js</code>), developed using the <code>http.createServer(...)</code> Node.js APIs. We can follow the same strategy and build a new server from scratch. However, for a full stack framework, we need a more established solution that has many server interfaces already in place. An excellent middle-ground choice for this project is to use the <code>express</code> module and create abstractions on top of it. <em class="italic">Express</em> will allow us to define middleware, custom routers, parse requests, craft API responses, and much more. If this sounds familiar, this is because this is a similar architecture to the NestJS framework project previewed in <a href="B19014_04.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>.</p>
<p>To expand the server functionality, we will also allow developers to create multiple servers in the same application context, like so:</p>
<pre class="source-code">
import Componium from "componium";
const app = await Componium.initialize();
const server = await app.createServer({...});</pre>
<p>With the<a id="_idIndexMarker498"/> server interfaces in place, we can now accept requests on a port and configure the servers with options that fit our requirements. Once the server is created, as seen in the preceding code, the main purpose of it is to handle endpoints and perform backend tasks. For the purposes of handling endpoints, we will introduce the <em class="italic">router</em> interface. It comes into play to accept requests and enable the API features.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Router</h2>
<p>In this framework, we want to <a id="_idIndexMarker499"/>provide options for file-based and dynamic routing. This involves using a similar feature to file-based routers in Next.js. We saw this concept in the overview of the building blocks in <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>. The router implementations can be found in the server package of the framework – for example, the file-based router is in <code>packages/server/file-router.js</code>.</p>
<p>The file-based router implementation is capable of recursively loading API endpoints from a directory structure. The file-based feature allows for some manual configuration. By default, the framework can look in a <code>routes</code> directory of a project. However, that can be adjusted by passing a file-router directory option to the server configuration. For details on the implementation of a file-based router, refer to the following package – <code>packages/server/file-router.js</code>.</p>
<p>As we need to handle different HTTP methods in our file router, we can establish a pattern for the HTTP methods. This way, if you make a <code>POST</code> or <code>DELETE</code> request, you are still able to indicate what type of HTTP method the file should respond to. To enable this functionality, we will configure the framework to handle files in the following manner. Files ending with a <code>.post.js</code> will indicate that this route is a <code>POST</code> method route. Files omitting this configuration will default to a <code>GET</code> handler. To handle index or root endpoint routes, we will use an <code>_index.js</code> file. This indicates that it is the root handler. For example, the <code>api/</code> directory can have the <code>_index.js</code> file, which will handle the requests to the root endpoint of the API. Refer to <em class="italic">Figure 7</em><em class="italic">.4</em> to see the directory structure of the <code>api/</code> directory. You can find an example of this in the sample application in the GitHub repository at <code>componium/tests/sample/routes/api/_index.js</code>.</p>
<p>Besides file-based routing, developers will sometimes need to define the routes and modular routers directly or programmatically in their code. To support those use cases, our framework offers several server methods to allow flexibility around routes, middlewares, and custom<a id="_idIndexMarker500"/> routers, as shown in the following code block:</p>
<pre class="source-code">
server.addMiddleware("middleware1", () =&gt; {
  console.log("Server middleware log");
});
server.addRoute("/dynamic", function (request, response) {
  return response.send("Dynamic Path");
});
const router = server.createRouter("/router");
router.addMiddleware("routerMiddleware", (request) =&gt; {
  console.log("Router middleware:", request.originalUrl);
});
router.addRoute("/sample", function (request, response) {
  return response.send("Router Sample");
});</pre>
<p>Reading the preceding middleware code, we can see some of the methods that our framework offers to enable dynamic routing. Backed by the primitives from the <code>express</code> package, we can create a more abstract system that provides a custom way to describe router definitions. As always, it also allows us to swap out the <code>express</code> module in favor of something else later on if required. The <code>addRoute</code> methods are present on both the server and custom router objects. These allow us to add custom route handlers instead of using file-based handlers. The <code>addRoute</code> function takes an argument of the route path and a function that has request/response arguments, used to process the request. This route-handling flow is visualized in the preceding code, which creates a server middleware, a new route, and an additional router with its own routing entities. Further details on router capabilities can be found at <a href="https://expressjs.com/en/guide/routing.html">expressjs.com/en/guide/routing.html</a>.</p>
<p>In addition to routing methods, we have additional middleware management functions, such as <code>addMiddleware</code>. These methods allow us to configure any self-developed or external middleware. In this case, it makes our framework compatible with other express-based middleware. For example, we can use it to add authentication to our endpoints using the <code>passport</code> module (<a href="https://github.com/jaredhanson/passport">github.com/jaredhanson/passport</a>); this will enable the framework to support a huge variety of authentication options.</p>
<p>The <a id="_idIndexMarker501"/>established architecture of the router and entry points allows us to actually create an application process that can accept requests. In the following subsections, we will define the ability to configure different components of our framework.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Configuration</h2>
<p>Developers expect a clean way to<a id="_idIndexMarker502"/> configure a framework-based application, with capabilities to run it in local, test, and production environments. To enable this, we will utilize the <code>config</code> package (located at <a href="https://npmjs.com/package/config">npmjs.com/package/config</a>). This package will allow us to elegantly organize the configuration options and let the application code base behave differently, based on the environment.</p>
<p>To provide a simple example, if we had only one property to configure, then our configuration file, <code>default.json</code>, would look something like this:</p>
<pre class="source-code">
{
  "database": {
    "connection_uri": "sqlite::memory"
  }
}</pre>
<p>With the <code>config</code> package, we<a id="_idIndexMarker503"/> can access the configuration in any of the framework modules and allow it to be used for any developer purposes from within the code base:</p>
<pre class="source-code">
import config from "config";
console.log("config", config.get
  ("database.connection_uri"));</pre>
<p>The <code>config</code> package automatically loads the required file and allows us to fetch data out of that configuration storage and access all the set properties. In the preceding configuration code, we get to fetch the database connection URL that can be used to bootstrap the database connection from the application.</p>
<p>As with other modules, we can create abstraction on the <code>config</code> package. However, we want to offer the core features of the package for developers’ use. The <code>config</code> package supports several file formats for application configuration, such<a id="_idIndexMarker504"/> as YAML (<a href="https://yaml.org">yaml.org</a>), JSON, or straight-up JavaScript. Providing a choice of formats is helpful, as it enables us to meet the requirements of the application deployment tools. For example, developer operations might prefer to structure all the production configurations with YAML files.</p>
<p>Configuring aspects of applications within a framework can become remarkably complex, due to the variety of configuration formats and methods available. The JavaScript ecosystem provides dozens of packages that can help you with configuration. Try to evaluate some of them to find the one that fits your needs best. Consider the types of configuration file extensions that a package supports and what kind of validation it can perform. Furthermore, in the following subsection, we will highlight how your framework should offer a set of defaults that work for your users.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Sensible defaults</h2>
<p><code>config</code> package features will allow us to specify the defaults in the <code>default.js</code> file. This file will act as a template for an application’s configuration. The configuration file can also be scaffolded in different ways; we will look into this further in the <em class="italic">Developer </em><em class="italic">experience</em> section.</p>
<p>Reducing the <a id="_idIndexMarker508"/>amount of configuration in your framework is something to strive for. It is key to creating a consistent experience and reducing the burdens of building new projects with your framework.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Database</h2>
<p>As we add the <code>database</code> functionality to<a id="_idIndexMarker509"/> our framework, we need to make sure to support a wide variety of databases. The project should also offer a unified, abstract way to work with database objects. To support these use cases, we can rely on a higher abstract library that enables ORM. For this chapter’s example, we will rely on an open source ORM library called <strong class="bold">Sequelize</strong> (<a href="https://sequelize.org">sequelize.org</a>). This library gives us support for MySQL, PostgreSQL, and <a id="_idIndexMarker510"/>MSSQL out of the box. It also enables us to use SQLite in local development and other environments, which makes it really easy to work with database operations and not connect to more complex database services. An ORM library such as Sequelize will add capabilities to interact with a database using JavaScript. It will allow us to treat database entities as objects, simplifying data manipulation and extraction.</p>
<p>In Componium, the database interface can be found in the <code>db</code> package. While some parts of interaction with Sequelize are abstracted, we still rely on the users of our framework to get familiar with the library and its features directly. It is common to see large frameworks rely on separate ORM layers, due to the fact that implementing and supporting several database engines requires a lot of investment in code and time.</p>
<p>When a new application is initialized in code, a framework automatically tries to make a connection to the configured database. To operate with database entities, the application needs to load the model files. In the Componium framework, the models are stored in the <code>models</code> directory and loaded during the initialization as well. This application structure allows framework users to keep data models organized and modular. The models can then be used within your route handlers to interact with the database, whether you need to create, read, update, or delete data. Here’s an example of a model we can use in the app:</p>
<pre class="source-code">
import { DataTypes, Model } from "sequelize";
class Package extends Model {}
Package.init(
  {
    title: DataTypes.STRING,
    address: DataTypes.STRING,
    created: DataTypes.DATE,
  },
  { sequelize: componium.db, modelName: "package" }
);</pre>
<p>To get <a id="_idIndexMarker511"/>access or mutate this model in our route handlers, we can use the <code>componium</code> object to get to the database entity object and perform an operation:</p>
<pre class="source-code">
export default async (req, res) =&gt; {
  const packages = await componium.models
    ["package"].findAll();
  componium.logger.info(`Found packages ${JSON.stringify
    (packages)}`);
  res.json(packages);
};</pre>
<p>The preceding <a id="_idIndexMarker512"/>code, located in the application under <code>sample/api/packages.js</code>, queries the packages stored in the <code>Package</code> model. Finally, it returns all the objects found in a query in the route handler. For the purposes of this chapter, the database implementation is fairly simple, but you can take up the challenge to make the code more accommodating to handle multiple databases and improve model file coupling if desired.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>GraphQL support</h2>
<p>In addition to the several options to<a id="_idIndexMarker513"/> define API endpoints, our framework also supports <strong class="bold">GraphQL</strong>, a powerful query language that is useful for backend data retrieval. Some <a id="_idIndexMarker514"/>developers might prefer to use GraphQL with our framework, and they should have good experience in integrating this system.</p>
<p>The GraphQL module can be found in the chapter files under <code>packages/server/graphql.js</code>. Following a similar design for a file-based router, the <code>componium</code> framework has a feature to make it easier to develop modular schemas for GraphQL. These schemas can be defined in separate files and later assembled into full schemas that are supported by every Componium server object. Every GraphQL type definition can be defined in its own <code>*.gql.js</code> file. Here’s an example of a <code>packages.gql.js</code> file:</p>
<pre class="source-code">
const typeDefs = `#graphql
  scalar Date
  type Package {
    title: String,
    address: String,
    created: Date,
  }
  type Query {
    packages: [Package]
  }
`;</pre>
<p>First, we define a sample definition for the package type so that we can query the data for that particular model:</p>
<pre class="source-code">
const resolvers = {
  Query: {
    packages: async () =&gt; {
      const packages = await componium.models
        ["package"].findAll();
      componium.logger.info(`Found packages ${JSON.
        stringify(packages)}`);
      return packages;
    },
  },
};
export {typeDefs, resolvers };</pre>
<p>The preceding<a id="_idIndexMarker515"/> code uses the schema definition for a Package type that queries the entries for the objects related to the <code>Package</code> model, retrieving all the stored packages in the database. The <code>.findAll()</code> call is the built-in interface related to the ORM package that is used under the hood.</p>
<div><div><img alt="Figure 7.5: An Apollo GraphQL sandbox request" src="img/Figure_7.5_B19014.png.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: An Apollo GraphQL sandbox request</p>
<p>The database <a id="_idIndexMarker516"/>items can now be retrieved using the query language. <em class="italic">Figure 7</em><em class="italic">.5</em> shows an interface of the <code>@apollo/server</code> package. GraphQL support can be enabled or disabled by specifying the <code>gql</code> option when we create new Componium servers, by calling the <code>app.createServer({gql: </code><code>false})</code> method.</p>
<p>If you are looking to learn more about GraphQL, check out some of the publications related to it at <a href="https://packtpub.com/search?query=graphql&amp;products=Book">packtpub.com/search?query=graphql&amp;products=Book</a>, especially the <em class="italic">Full Stack Web Development with GraphQL and React</em> book. Many aspects of GraphQL can get really complex quickly, but it is a good example of a feature you can add to your <a id="_idIndexMarker517"/>framework to enable a powerful query language based on an established specification.</p>
<p>The next subsection focuses on observability, which will help to make sure the GraphQL feature works properly in applications and we can acquire enough visibility into the internals of the projects using logging.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Observability</h2>
<p>The final feature that is worth highlighting <a id="_idIndexMarker518"/>has to deal with <strong class="bold">observability</strong>. Our framework should offer an interface to allow developers to log essential operations to a file. The framework itself should automatically log any sensitive operations that the developer should be aware of.</p>
<p>This is where the <em class="italic">winston</em>-based <code>Logger</code> class comes into play; you can find the implementation in the framework’s <code>packages/app/logger.js</code> file. winston (<a href="https://github.com/winstonjs/winston">github.com/winstonjs/winston</a>) is a logging library that can output the logs in flexible ways and is compatible with various deployment environments. It provides a simple and straightforward interface for logging, allowing developers to easily incorporate logging into their applications with minimal effort. This not only ensures that developers have granular control over what gets logged but also standardizes the way logs are generated across an application.</p>
<p>The logger class is designed to be flexible with respect to the logging environment. It is configured to log to a console in non-production environments, allowing for real-time debugging during the development stages. In production, the logs are written to specified files, providing a permanent record of the application’s operation and behavior that can be referred back to when needed. This separation of environments also provides a level of safety, ensuring that sensitive data is not inadvertently exposed during development. These logs can then be used to diagnose and troubleshoot issues, enhancing the observability and reliability of the application. As discussed in the <em class="italic">GraphQL support</em> section earlier, we will use the logger to keep track of the found packages:</p>
<pre class="source-code">
componium.logger.info(`Found packages ${JSON.
  sstringify(packages)}`);</pre>
<p>In development mode, this logger will provide information in the terminal console; this way, this information can effortlessly be seen during the feature development phase. Once the application is deployed and running in the production environment, it will log into the <code>error.log</code> and <code>combined.log</code> files. The format of the logs in those files will be JSON, such as the following:</p>
<pre class="source-code">
{"level":"info","message":"Found packages [{\"id\":1,\"title\":\"Paper Delivery\",\"address\":\"123 Main St.\",\"createdAt\":\"2023-02-01T05:00:00.000Z\",\"updatedAt\":\"2023-02-01T05:00:00.000Z\"}]","service":"package-service"}</pre>
<p>This <code>logger</code> class has the interface to log <code>.info</code>, <code>.warn</code>, and <code>.error</code> messages. It will empower developers by providing a way to keep track of the application behavior, debug issues, and store necessary logs that can later be parsed.</p>
<p>Concluding <a id="_idIndexMarker519"/>the <em class="italic">Architecture</em> section, we now have insight into entry points, routing, logging, database, and endpoint support. These are plenty of features for the first iteration of the project. Further, we will connect these features with an improved developer experience.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Developer experience</h1>
<p>With several<a id="_idIndexMarker520"/> essential backend features built, we can now focus on the developer experience aspects. Earlier referenced in <em class="italic">Figure 7</em><em class="italic">.1</em>, this is the second important aspect of the framework we will focus on. The goal behind introducing framework-adjacent developer tools is to lessen the friction of adapting the features of our framework. It also helps to streamline the experience and create a unified way to work with the framework’s primitives.</p>
<p>To enable most of this experience, we will rely on the <code>componium</code> executable that ships with the framework when it is installed. This executable will take care of a lot of mundane tasks, such as initializing applications and scaffolding standard components. It will also eliminate common points of friction by enabling features such as live server reload.</p>
<p>In the next three subsections, we will explore three potential developer experience offerings that you can provide to the users of your framework.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Bootstrapping a new application</h2>
<p>The Componium<a id="_idIndexMarker521"/> framework’s <code>componium</code> executable shipped with the library simplifies the process of bootstrapping a new application. Rather than setting up a new application from scratch, the developer can just run the <code>npx componium init</code> command. This command will provide options to create a basic project structure with all the necessary configurations and dependencies set up. The initialization process saves a significant amount of time and ensures consistency across different projects built using the framework. The command has the flexibility to accept parameters such as <code>npx componium init my-app</code> to create a new application structure in the <code>my-app</code> directory. The <code>init</code> feature is great for developers, since it automates the repetitive and error-prone process of creating new applications from nothing.</p>
<p>Making this bootstrapping process easy is key for new developers to get started using the framework. Looking back to <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, you will find that almost every framework offers one or several ways of bootstrapping projects, using a CLI tool or a similar mechanism.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Scaffolding</h2>
<p>To continue on the theme of reducing<a id="_idIndexMarker522"/> error-prone tasks, scaffolding is a highly beneficial feature that further enhances the developer experience. It allows developers to automatically generate boilerplate code for components that are supported by the framework. In the framework exercise of this chapter, we will support creating things such as models, GraphQL schemas, and routes.</p>
<div><div><img alt="Figure 7.6: An example of the scaffolding experience" src="img/Figure_7.6_B19014.png.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: An example of the scaffolding experience</p>
<p><em class="italic">Figure 7</em><em class="italic">.6</em> showcases the developer experience when running the framework executable to scaffold some new components inside of new applications. A highly detailed description can be provided for each option that helps explain the potential options of each operation. The <code>create</code> command can also support a direct set of parameters to avoid the <code>Select</code> interface for more advanced users of the framework. The scaffolding commands can demonstrate best practices and quickly teach developers about the framework’s capabilities.</p>
<p>In addition, the new project initialization scaffolding options can include the framework features a developer wants to use. For example, they can choose the defaults or customize the project and choose their database type, enable GraphQL support, opt in for the file-based router, and so on. To successfully perform this workflow step, the framework has to provide clear instructions related to initializing and setting up the project.</p>
<p>Scaffolding is<a id="_idIndexMarker523"/> super common in many projects and is a must-have for new projects. In some cases, the scaffolding features can ship separately from the main project. However, providing the ability to scaffold greatly improves interaction with your framework.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>File watching</h2>
<p>File watching<a id="_idIndexMarker524"/> is another <a id="_idIndexMarker525"/>valuable feature provided by the <code>componium</code> executable. In this case, it’s used for internal usage via the <code>componium dev</code> command. This feature watches for changes in the source code files of the application. It later automatically rebuilds and restarts the server whenever a change is detected. This means that developers can see the results of their changes faster and iterate faster. This file-watching infrastructure will come in handy as we further develop the backend features of the framework. It can also be beneficial for the next chapter, where we introduce frontend components that will need to be rebuilt as they are iterated upon.</p>
<p>The combination of these features – easy initialization, detailed code scaffolding, and file watching – creates an excellent developer experience, as it allows developers to focus on the project’s requirements. We shall see how these developer features are relevant in the next section, as they relate to an example workflow utilizing our newly developed framework.</p>
<p>The three examples of improvements to the developer experience help to define the specific tasks in which framework authors can invest. These enhancements aim to improve the overall usability of the project. In the next section, the workflow that we will discuss how these scaffolding and file-watching tools can be utilized and accompany the framework project and makes it more pleasant to use.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Developer workflow</h1>
<p>In the previous sections of the chapter, we<a id="_idIndexMarker526"/> identified the project goals, developed the architecture, and described a few sample features of the framework. In this workflow section, let us summarize how developers can take advantage of the project and understand their workflow.</p>
<p>Here are the parts of the workflow, including some of the steps required on the framework developer side to make the project available for consumption.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Framework distribution</h2>
<p>A newly created<a id="_idIndexMarker527"/> JavaScript framework is published publicly or privately on the <code>npm</code> package registry. When a framework author wants to keep the project fully private, it can be consumed from a private Git repository within the internal infrastructure. This whole framework package includes a <code>README</code> file and framework documentation that helps external developers start building a new application.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>New project requirements</h2>
<p>To use an example of<a id="_idIndexMarker528"/> framework usage, a developer wants to build a sample application that keeps track of packages. The system needs to be able to list inbound and outbound packages, change the properties of those packages, and add and remove new ones. Ultimately, the developer would like to enable these features and deploy them to a remote environment, where the application interacts with a production/staging database environment.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>Starting a project</h2>
<p>To start building the application, the <a id="_idIndexMarker529"/>developer installs the framework. They can use a command such as <code>npm install -g componium</code>. The command globally installs the framework. This is similar to the <code>npm link</code> command that we used before to get access to the executable. However, in this case, the framework is downloaded from the npm package manager database. In your case, you can use the npm-linked version of the executable if it makes it easier.</p>
<p>With the framework installed, the developer can now run <code>componium init</code> to create a new application structure. The terminal will show the following:</p>
<pre class="console">
&gt; cd new-app
&gt; componium init
Creating /Users/user/dev/new-app/app.js...
...
Installing dependencies...
New Componium application initialized.</pre>
<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>Using the framework</h2>
<p>The initialization script <a id="_idIndexMarker530"/>automatically installs the necessary parts of the project, including a <code>package.json</code> file. The code scaffolds the necessary files into the project directory based on those choices. The starting point now leaves the developer with a brand-new project directory, where they can begin development. The expectation of this workflow ensures minimal friction during installation and presents the developer with an example of running application code. The next step for the developer is to use either the <code>componium dev</code> or <code>componium create</code> command. The first command, <code>dev</code>, will start the development server in the project directory, and the second command, <code>create</code>, can scaffold new components within the project. It is up to the developer to decide whether they want to use the scaffolding helpers or write code from scratch using the provided framework documentation. These two commands will come in handy in the next parts of the workflow, where a developer can start adding new API models and server endpoints.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Creating an API and a model</h2>
<p>Now, by<a id="_idIndexMarker531"/> following the docs on route creation and <a id="_idIndexMarker532"/>handling, the developer can create the necessary endpoints to support the requirements of the project that they are building. For example, they can begin by using the file-based router to define two endpoints – one to create new <em class="italic">package</em> entries and another to list them. To do this, they can make a directory called <code>api</code> and add a new file, <code>api/packages.js</code>. You can find an example of this file at <code>chapter7/componium/tests/sample/models/package.js</code>.</p>
<p>Instead of doing this manually, the scaffolding tool can also help generate a new route file and a new model file, later placing them into the correct directory. For the route generation, the command looks like this:</p>
<pre class="console">
&gt; componium create
? What would you like to scaffold? Route
? Enter a name for your ROUTE packages</pre>
<p>This will now provide an endpoint to handle requests. The developer will likely start looking for ways to enrich the API endpoints with actual data. The API creation step requires the application author to understand the available options and the mechanisms to create new endpoints. Most likely, they can learn this from the framework documentation and provided sample apps.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Expanding the API</h2>
<p>With the <a id="_idIndexMarker533"/>API routes functioning, it is time to enable data persistence. In this case, the developer needs to add database capabilities to save and list <em class="italic">packages</em>. The framework already ensures that it can connect to a development database locally so that step is taken care of. The next step in the workflow is to add a <em class="italic">Package</em> model and load it in the API endpoints. The scaffolding tooling can generate a model file in the right location using a CLI prompt or command. For example, the CLI can run <code>componium create</code> to prompt the developer for the database model details. To successfully achieve this workflow task, the application author needs to be aware of the scaffolding tools or manual ways to manage database models within the framework. Once we create the model, we can update the <code>models/package.js</code> file to store the properties of different packages:</p>
<pre class="source-code">
import Package from "../../models/package.js";
export default async (req, res) =&gt; {
  const model = await Package();
  const sample = await model.create({
    title: "Paper Delivery",
    address: "123 Main St.",
    created: new Date(2023, 1, 1),
  });
  const packages = await model.findAll();
  componium.logger.info(`Found packages ${JSON.
    stringify(packages)}`);
  res.json(packages);
};</pre>
<p>In the preceding<a id="_idIndexMarker534"/> code, we can both create new packages and then respond with all the packages in the database. Furthermore, we can split the creation logic and the query logic into different routes. The full packages file can be found in <code>tests/sample/routes/api/packages.js</code>.</p>
<p>By the end of this workflow step, the endpoint should now have the code logic to interact with the newly created Package model and list the records when the <code>packages.js</code> route is accessed.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Adding tests</h2>
<p>At this <a id="_idIndexMarker535"/>point in our workflow, we have a working API that interacts with the database. The developer has already tested the endpoints manually using sample requests. They can also land some functional test cases to make sure the API works properly. To successfully add tests, there needs to be documentation on the suggested ways to test endpoints. These suggestions can include the use of third-party<a id="_idIndexMarker536"/> test libraries or the built-in <code>componium-test</code> library from <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a>.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Configuring environments</h2>
<p>With the <a id="_idIndexMarker537"/>routes tested, it is time to attempt to deploy the application to see whether it works in the remote environment. The application frameworks that we saw in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> pride themselves on the ease of deployment. Therefore, the expectations are high to make the application as easy as possible to deploy.</p>
<p>To successfully achieve this step, our framework provides a production configuration file, <code>config/production.json</code>. This JSON file contains various environment-specific settings that the application uses when running in the production environment. It is still up to the developer to properly understand how to securely specify the database information and other configuration options. The framework documentation can guide the application authors to suggest optimal ways to make this step work. While the framework provides this file, it’s still the responsibility of the developer to understand how to securely specify the required attributes. The way these details are specified can significantly impact the security and performance of the application, making it critical to get it right.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Deploying the application</h2>
<p>With the <a id="_idIndexMarker538"/>production configuration correctly configured, the developer can now deploy the application to their server environment and test out the new API. This step completes our sample workflow, and if the developer can successfully test out their changes and interact with the database, then the workflow is successful.</p>
<p>This is just one example of a framework workflow, which allows us to document the steps from installation to a working application. There are more steps that could potentially be added; it largely depends on how far we are willing to explore this workflow. For example, using the middleware APIs of the framework, we can explore how common middleware such as authentication can be easily added to the new endpoints. We also didn’t cover the use cases where an application author needs to have frontend views to manage and interact with the endpoints.</p>
<p>The process of figuring out these types of workflows can help us identify friction and opportunities to make the framework’s developer experience much better. It also ensures that we figure out what types of documentation and tooling improvements can be added to the project as we develop it further.</p>
<p>At this point of<a id="_idIndexMarker539"/> deployment of the application, we conclude the workflow’s standard progression. The additional steps in the more extensive workflow can involve doing more in-depth database operations and using the framework’s GraphQL features. Overall, focusing on several of these types of workflows can help framework authors fine-tune how stakeholders interact with their systems. In the following section, we will take a look at a list of the external dependencies that made all this possible.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Dependencies</h1>
<p>The workflow that <a id="_idIndexMarker540"/>we mentioned in the previous section is made possible by several external libraries and modules. Here’s a recap of some of the modules that we used in the Componium framework from this chapter:</p>
<ul>
<li><code>@apollo/server</code> and <code>@graphql-tools/schema</code>: The combination of these two tools allows us to offer the GraphQL features of this framework project. Apollo Server is able to integrate with Componium servers, and it also provides an easy-to-use sandbox to test GraphQL schemas.</li>
<li><code>Chokidar</code>: This is the file-watching library that helps to create a better experience by watching for changes to the application files and performing steps, such as restarting the development server.</li>
<li><code>@inquirer</code> and <code>yargs</code>: These libraries allow us to create the <code>componium</code> command-line tool. <em class="italic">Inquirer</em> can create interactive terminal interfaces, useful for Componium development commands, such as <code>componium create</code>. <em class="italic">Yargs</em> helps us work with command-line commands, flags, and options, making it easier to quickly develop a sleek development interface for our project.</li>
<li><code>express</code> and <code>body-parser</code>: These are the underlying server libraries that make it possible to initialize Componium servers and add routes and middleware.</li>
<li><code>Winston</code>: This is the logging library that is used in the underlying <code>Logging</code> class. It helps us provide a way for the Componium applications to log to different types of logs.</li>
<li><code>sequelize</code>: This is the ORM layer library that helps applications integrate with a variety of databases.</li>
<li><code>componium-test</code>: This is the testing library from <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a> that we can utilize to test the backend framework.</li>
<li><code>debug</code>: This is the logging module used to track down and debug internal issues of a framework during development. As mentioned in <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a>, it supports scoping a debug level to a particular component by using the <code>DEBUG=componium:* </code><code>environment</code> variable.</li>
<li><code>config</code>: This <a id="_idIndexMarker541"/>is the configuration manager module that helps store and organize the application configuration in different formats.</li>
</ul>
<p>Some of these modules are quite common in server-side frameworks and other Node.js tools at large. For the purposes of your own framework, you can choose the packages we just discussed or find alternatives that better fit your use cases. Luckily, the Node.js ecosystem has a lot to offer in terms of ORM, logging, and testing solutions.</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Summary</h1>
<p>In this chapter, we have taken a step further, from the earlier experience with the testing framework, by composing a brand-new server-side framework that is capable of routing requests, handling API calls, and much more. This supports our plan to develop a full stack framework that covers both frontend and backend features, with components interacting with each other within the same unified vision. Our goal was to create something that is used and reused for multiple application use cases and feature set combinations.</p>
<p>We started by defining our project’s goals, and we later developed the core architecture aspects of the framework. This architecture included producing features such as server process management, environment configuration, and database interaction. To enable usability and empower developer productivity, we also focused on producing several features that focus on developer experience.</p>
<p>This was the second practical exercise in our framework experience, and hopefully, this gives you even more confidence in your skills to develop your own frameworks. To take this a step further, the next chapter will focus on our final challenge – building frontend components for our full stack framework. The introduction of the frontend components in the next chapter will enable the whole full stack experience of our newly created framework.</p>
</div>
</body></html>