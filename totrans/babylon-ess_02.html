<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;The Fundamentals of Babylon.js and Available Tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. The Fundamentals of Babylon.js and Available Tools</h1></div></div></div><p>This chapter presents the fundamentals of Babylon.js. It includes the notions of <span class="emphasis"><em>engine</em></span>, <span class="emphasis"><em>scene</em></span>, <span class="emphasis"><em>camera</em></span>, <span class="emphasis"><em>light</em></span>, <span class="emphasis"><em>mesh</em></span>, and so on. By practicing, you'll understand the basic tools used in 3D such as vectors and how/where they are used in 3D engines. You'll also practice with graph structures and understand the architecture of Babylon.js.</p><p>The following topics will be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discussing the Babylon.js structure and graphs</li><li class="listitem" style="list-style-type: disc">Creating your first scene</li></ul></div><div class="section" title="The Babylon.js structure and graphs"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec11"/>The Babylon.js structure and graphs</h1></div></div></div><p>First, let's create and explain the necessary tools to draw things on the screen, such as an engine that will handle a scene to draw a 3D object and use a camera and light.</p><div class="section" title="The engine and a scene"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>The engine and a scene</h2></div></div></div><p>The engine is the core of Babylon.js and a scene allows you to create and manage entities that you'll draw on the screen (objects, lights, cameras, and so on), thanks to an engine. You can see the engine like a gateway to communicate with the video card (GPU) while a scene is a high-level interface that handles the following multiple entities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">3D objects (more on this in <a class="link" href="ch03.html" title="Chapter 3. Create, Load, and Draw 3D Objects on the Screen">Chapter 3</a>, <span class="emphasis"><em>Create, Load, and Draw 3D Objects on the Screen</em></span>)</li><li class="listitem" style="list-style-type: disc">Cameras</li><li class="listitem" style="list-style-type: disc">Lights</li><li class="listitem" style="list-style-type: disc">Particle systems (smoke, rain, and others)</li><li class="listitem" style="list-style-type: disc">Textures</li><li class="listitem" style="list-style-type: disc">Skeletons (animated 3D objects)</li><li class="listitem" style="list-style-type: disc">Post-processes (effects)</li><li class="listitem" style="list-style-type: disc">Materials (more on this in <a class="link" href="ch04.html" title="Chapter 4. Using Materials to Customize 3D Objects Appearance">Chapter 4</a>, <span class="emphasis"><em>Using Materials to Customize 3D Objects Appearance</em></span>)</li><li class="listitem" style="list-style-type: disc">Sprites</li></ul></div><p>In other words, a scene handles multiple entities and will call the engine to draw these entities on the screen.</p><p>To draw on the screen, the web page (<code class="literal">index.html</code>) must contain a canvas. The canvas is used to create the WebGL context that the engine will use. The only parameter needed to create an engine is the canvas and the only parameter needed to create a scene is an engine.</p><p>The canvas in the web page is as follows:</p><pre class="programlisting">&lt;canvas id="renderCanvas"&gt;&lt;/canvas&gt; &#13;
</pre><p>The following code is performed to render on the entire page:</p><pre class="programlisting">&lt;style&gt; &#13;
    html, body { &#13;
        overflow: hidden; &#13;
        width: 100%; &#13;
        height: 100%; &#13;
        margin: 0; &#13;
        padding: 0; &#13;
    } &#13;
 &#13;
    #renderCanvas { &#13;
        width: 100%; &#13;
        height: 100%; &#13;
    } &#13;
&lt;/style&gt; &#13;
</pre><p>To create an engine, you have to give the canvas reference as a parameter. Get the reference of the DOM object as follows:</p><pre class="programlisting">var canvas = document.getElementById("renderCanvas"); &#13;
</pre><p>Create an engine by passing the canvas reference:</p><pre class="programlisting">var engine: BABYLON.Engine = new BABYLON.Engine(canvas); &#13;
</pre><p>Create a scene as follows:</p><pre class="programlisting">var scene: BABYLON.Scene = new BABYLON.Scene(engine); &#13;
</pre><p>Each new scene created is stored in <code class="literal">engine.scenes</code>, which is an array of <code class="literal">BABYLON.Scene</code>.</p><p>Once you create a scene, you can render every frame (60 frames per second in a perfect case and less if your hardware isn't sufficient). To perform this action, you have to call the <code class="literal">engine.runRunderLoop(function)</code> function. The anonymous function <code class="literal">function</code> is called every frame and this is the place to draw the scene:</p><pre class="programlisting">// runRenderLoop with TypeScript. The anonymous function doesn't &#13;
// have any parameter &#13;
engine.runRenderLoop(() =&gt; { &#13;
    scene.render(); &#13;
}); &#13;
</pre><p>The <code class="literal">scene.render()</code> function is called to draw every object on the screen during the frame.</p></div><div class="section" title="Adding cameras and lights"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Adding cameras and lights</h2></div></div></div><p>Once you create a scene, you can create objects such as lights and cameras. The minimal scene requirement is composed of a camera (needed to get a view in the scene) and light (that illuminates the 3D objects in the scene, but this is not required if objects in the scene are self-illuminated).</p><div class="section" title="Adding a camera"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec6"/>Adding a camera</h3></div></div></div><p>There are several types of cameras and lights. The Babylon.js framework provides you with a fixed camera (no movements), FPS camera, rotation camera (turns around a point), gamepad camera (XBOX 360 gamepad), and touch camera (for touch devices). All these cameras can be created in the scene with a minimum number of lines of code. For example, let's start with a free camera (FPS) with its position at coordinates (<code class="literal">x=10</code>,<code class="literal">y=20</code>,<code class="literal">z=30</code>). This is the occasion to introduce the <code class="literal">BABYLON.Vector3</code> class:</p><pre class="programlisting">var camera =  new BABYLON.FreeCamera("cameraName", new BABYLON.Vector3(10, 20, 30), scene); &#13;
</pre><p>The constructor needs a name (<code class="literal">cameraName</code>), position for the camera, and scene reference (where to add the camera). The position is in the <code class="literal">BABYLON.Vector3(x, y, z)</code> type, which is the 3D vector class of Babylon.js. The <code class="literal">Vector3</code> object provides mathematical functions such as addition, subtraction, multiplication, division, and more.</p><p>Once you create the camera, let's change the camera's position and perform a <code class="literal">Vector3</code> addition:</p><pre class="programlisting">camera.position = new BABYLON.Vector3(10, 0, 10).addInPlace(new BABYLON.Vector3(0, 10, 0)); &#13;
</pre><p>The <code class="literal">.addInPlace</code> method modifies the current instance of <code class="literal">Vector3</code>, but you can also call the <code class="literal">.add</code> method that will return a new instance of <code class="literal">Vector3</code> with the addition applied.</p><p>The new position of the camera is now (<code class="literal">x=10</code>,<code class="literal">y=10</code>,<code class="literal">z=10</code>). Modifying the <code class="literal">.position</code> property does not work for all the cameras, especially the rotation camera (<code class="literal">BABYLON.ArcRotateCamera</code>). The rotation camera turns around a point (which is the target of the camera) and can be explained as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_001-1024x768.png" alt="Adding a camera"/></div><p>
</p><p>The cube is at the position (<code class="literal">x=0</code>,<code class="literal">y=0</code>,<code class="literal">z=0</code>) and is the target of the camera. To change the camera's position, you have to call the <code class="literal">camera.setPosition(position)</code> function. This function will calculate the appropriate values for the alpha (angle around Y), beta (angle around X), and radius. Then, the .<code class="literal">position</code> property is only left to read.</p></div><div class="section" title="Adding a light"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec7"/>Adding a light</h3></div></div></div><p>Once you create your camera, let's add a light. The different lights allow you to perform lighting in your scene with different features. The point lights and hemispheric lights tend to illuminate the objects in the scene, while the spot lights and directional lights also provide support for the real-time shadows.</p><p>Let's start with a point light. Lights work like cameras, which means that you have to provide the scene reference (where to add the light):</p><pre class="programlisting">var light = new BABYLON.PointLight("lightName", BABYLON.Vector3.Zero(), scene); &#13;
</pre><p>The second parameter is the light position. <code class="literal">BABYLON.Vector3.Zero()</code> is a static method that is a shortcut to create a <code class="literal">Vector3</code> instance with coordinates (<code class="literal">x=0</code>,<code class="literal">y=0</code>,<code class="literal">z=0</code>). Now, let's play with the light's parameters:</p><pre class="programlisting">light.position = new BABYLON.Vector3(20, 20, 20); &#13;
light.diffuse = new BABYLON.Color3(0, 1, 0); &#13;
light.specular = new BABYLON.Color3(1, 0, 0); &#13;
light.intensity = 1.0; &#13;
</pre><p>The following are the parameters of the preceding code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<code class="literal">.diffuse</code> parameter represents the native color of the light, which is green in the example</li><li class="listitem" style="list-style-type: disc">The<code class="literal">.specular</code> parameter represents the light color reflected by a surface, which is red here</li><li class="listitem" style="list-style-type: disc">The<code class="literal">.intensity</code> parameter is the light's intensity that is equal to 1.0 by default</li></ul></div><p>The following is the result of these parameters applied to a 3D object:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_002.png" alt="Adding a light"/></div><p>
</p><p>The following is achieved by modifying the specular color to red and blue:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_003.png" alt="Adding a light"/></div><p>
</p></div></div><div class="section" title="Adding a mesh"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Adding a mesh</h2></div></div></div><p>What are meshes? In fact, 3D objects are what we call meshes. Their structure is pretty simple as they have two important buffers in memory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The vertex buffer is an array of 3D points: the vertices. The vertices represent the 3D points needed to build geometrical forms such as cubes, spheres, characters, weapons, and so on. For example, a cube has eight vertices.</li><li class="listitem" style="list-style-type: disc">The index buffer, which is an array of numbers, represents the indices in the vertex buffer to build triangles. Indeed, graphic cards are optimized to calculate and render triangles on the screen. For example, a face of a cube will be rendered using two triangles, as shown in the following image, where the green lines show the face:<p>
</p><div class="mediaobject"><img src="graphics/image_02_004.png" alt="Adding a mesh"/></div><p>
</p></li></ul></div><p>The job of graphic cards is separated into two steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They project (transformation) the vertices (3D points) of the vertex buffer on the screen. These operations are performed by a GPU program named vertex shader. In other words, the vertex shader computes the 2D position of each triangle.</li><li class="listitem" style="list-style-type: disc">They fill the pixels associated with the triangles with their colors using a GPU program named pixel shader.</li></ul></div><p>To conclude the graphic cards' job, the vertex shader computes the 2D triangles on the screen and the pixel shader illuminates the pixels with different colors.</p></div><div class="section" title="Using Babylon.js to create meshes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Using Babylon.js to create meshes</h2></div></div></div><p>Babylon.js provides you with static methods in the <code class="literal">BABYLON.Mesh</code> class that allow you to create basic meshes such as boxes, spheres, and torus. Every created mesh is an instance of <code class="literal">BABYLON.Mesh</code>. Let's start with a box:</p><pre class="programlisting">var box = BABYLON.Mesh.CreateBox("boxName", size, scene); &#13;
</pre><p>The <code class="literal">size</code> parameter represents the distance between the vertices (for example, 5) and the <code class="literal">scene</code> parameter is the scene reference (where to add the mesh). Once you get the mesh created, you can access its properties and methods as follows:</p><pre class="programlisting">box.position = new BABYLON.Vector3(0, 2.5, 0); &#13;
box.rotation = new BABYLON.Vector3(0, Math.PI / 4, 0); &#13;
box.scaling = new BABYLON.Vector3(2, 2, 2); &#13;
</pre><p>The <code class="literal">.rotation</code> parameter represents the mesh's rotation expressed in radians <code class="literal">[0, 2π]</code>, and then, in degrees, <code class="literal">π = 180 degrees</code> and <code class="literal">2π = 360 degrees</code>.</p><p>The <code class="literal">.scaling</code> parameter represents the mesh's scale in three directions (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>,<span class="emphasis"><em>z</em></span>). In the example, the mesh is two times bigger.</p><p>Let's see the result if you modify its rotation only:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_005.png" alt="Using Babylon.js to create meshes"/></div><p>
</p><p>The following image is the result of applying a new scale, (<code class="literal">x=2</code>,<code class="literal">y=2</code>,<code class="literal">z=2</code>):</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_006.png" alt="Using Babylon.js to create meshes"/></div><p>
</p><div class="section" title="Some other basic meshes"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec8"/>Some other basic meshes</h3></div></div></div><p>There exist multiple basic meshes that <code class="literal">BABYLON.Mesh</code> can create for you, such as spheres and planes. Let's create a sphere and plane using the <code class="literal">BABYLON.Mesh</code> class:</p><pre class="programlisting">var sphere = BABYLON.Mesh.CreateSphere("sphereName", segments, size, scene); &#13;
var plane = BABYLON.Mesh.CreatePlane("planeName", size, scene); &#13;
</pre><p>The sphere's <code class="literal">segments</code> parameter represents the level of detail for the sphere, for example, 10.</p><p>The plane's <code class="literal">size</code> parameter represents the distance between vertices, for example, 10.</p></div></div><div class="section" title="Managing a scene graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Managing a scene graph</h2></div></div></div><p>The scene can be managed using a graph of nodes named scene graph. In Babylon.js, each mesh, light, and camera extends the <code class="literal">BABYLON.Node</code> class. In other words, each <code class="literal">BABYLON.Node</code> is in the scene graph.</p><p>Each node has an array of children and one, and only one, parent. Each created node is a child of the graph's root by default.</p><p>To modify the parent of a node, just modify the node's reference:</p><pre class="programlisting">light.parent = camera; &#13;
</pre><p>Now, because the light is a child of the camera, the light's position depends on the camera's position. Indeed, the light space is a subspace of the camera. In other words, you can see the position (<code class="literal">x=0</code>,<code class="literal">y=0</code>,<code class="literal">z=0</code>) as the position of the camera.</p><p>When setting a parent, the transformation properties (position, rotation, and scaling) of the children are influenced by the parent.</p><div class="section" title="An example"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec9"/>An example</h3></div></div></div><p>Let's manage the scene graph with two nodes (<code class="literal">node1</code> and <code class="literal">node2</code>) and compare it with the equivalent code if you were to do it manually:</p><pre class="programlisting">node1.position = new BABYLON.Vector3(0, 0, 0); &#13;
node1.parent = node2; &#13;
</pre><p>This is equivalent to the following code:</p><pre class="programlisting">engine.runRenderLoop(() =&gt; { &#13;
  node1.position = node2.position; &#13;
  node1.rotation = node2.rotation; &#13;
  node1.scaling = node2.scaling; &#13;
}); &#13;
</pre><p>The following schema explains the preceding code:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_007.png" alt="An example"/></div><p>
</p></div></div></div></div>
<div class="section" title="Creating your first scene"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Creating your first scene</h1></div></div></div><p>Now, you have all the necessary elements to build your first scene. Here, the scene will be composed of a rotation camera, point light, and box. Let's create a class using TypeScript and practice with Babylon.js.</p><div class="section" title="Creating a class and the scene nodes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Creating a class and the scene nodes</h2></div></div></div><p>The following class creates the Babylon.js elements directly in the constructor:</p><pre class="programlisting">export class BasicScene { &#13;
  public camera: BABYLON.ArcRotateCamera; // Our camera &#13;
  public light: BABYLON.PointLight; // Our light &#13;
  public box: BABYLON.Mesh; // Our box &#13;
 &#13;
  private _engine: BABYLON.Engine; // The Babylon.js engine &#13;
  private _scene: BABYLON.Scene; // The scene where to add the nodes &#13;
 &#13;
  // Our constructor. The constructor provides the canvas reference &#13;
  // Then, we can create the Babylon.js engine &#13;
  constructor(canvas: HTMLCanvasElement) { &#13;
    // Create engine &#13;
    this._engine = new BABYLON.Engine(canvas); &#13;
 &#13;
    // Create the scene &#13;
    this._scene = new BABYLON.Scene(this._engine); &#13;
 &#13;
    // Create the camera &#13;
    this.camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 30,        BABYLON.Vector3.Zero(), &#13;
        this._scene); &#13;
    this.camera.attachControl(canvas, true); &#13;
 &#13;
    // Create the light &#13;
    this.light = new BABYLON.PointLight("light",new BABYLON.Vector3(20, 20, 20), &#13;
        this._scene); &#13;
    this.light.diffuse = new BABYLON.Color3(0, 1, 0); &#13;
this.light.specular = new BABYLON.Color3(1, 0, 1); &#13;
this.light.intensity = 1.0; &#13;
 &#13;
// Create the box &#13;
this.box = BABYLON.Mesh.CreateBox("cube", 5, this._scene); &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Call the runRenderLoop method"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Call the runRenderLoop method</h2></div></div></div><p>Let's add a method to the class that will call the <code class="literal">runRenderLoop</code> method:</p><pre class="programlisting">public runRenderLoop(): void { &#13;
  this._engine.runRenderLoop(() =&gt; { &#13;
    this._scene.render(); &#13;
  }); &#13;
} &#13;
</pre><p>This scene is exactly the same as mentioned in the previous image—there is a box and green light.</p></div><div class="section" title="Managing the scene graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Managing the scene graph</h2></div></div></div><p>To practice with the scene graph, let's create a method that will set the light as a child of the camera. The method will set the light's position at coordinates (<code class="literal">x=0</code>,<code class="literal">y=0</code>,<code class="literal">z=0</code>) and set the parent of the light as the camera:</p><pre class="programlisting">public setCameraParentOfLight(): void { &#13;
  this.light.parent = this.camera; &#13;
} &#13;
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Summary</h1></div></div></div><p>In this chapter, you learned how to create a minimal HTML page to handle a Babylon.js engine and draw a scene. You also learned how to use Babylon.js' built-in nodes such as lights, cameras, and meshes.</p><p>Don't hesitate to practice with the built-in meshes such as torus, torus-knots, and spheres and play with the scene graph and node's properties such as position.</p><p>In the next chapter, you'll learn how scenes are built with designers and how they are imported using Babylon.js. You'll also see that interfacing 3D software to create scenes with Babylon.js is pretty easy as all the tools are provided by the Babylon.js solution (such as exporters and importers).</p><p>The next chapter will also explain how artists work to create 3D scenes for the web as their problems are different from desktop software such as games for consoles and PCs.</p></div></body></html>