["```js\n  const size = 1\n  const amount = 5000\n  const range = 20\n  const group = new THREE.Group()\n  const mat = new THREE.MeshNormalMaterial()\n  mat.blending = THREE.NormalBlending\n  mat.opacity = 0.1\n  mat.transparent = true\n  for (let i = 0; i < amount; i++) {\n    const x = Math.random() * range - range / 2\n    const y = Math.random() * range - range / 2\n    const z = Math.random() * range - range / 2\n    const g = new THREE.BoxGeometry(size, size, size)\n    const m = new THREE.Mesh(g, mat)\n    m.position.set(x, y, z)\n    group.add(m)\n  }\n```", "```js\n  const size = 1\n  const amount = 250000\n  const range = 20\n  const mat = new THREE.MeshNormalMaterial()\n  mat.opacity = 0.1\n  mat.transparent = true\n  mat.blending = THREE.NormalBlending\n  const g = new THREE.BoxGeometry(size, size, size)\n  const mesh = new THREE.InstancedMesh(g, mat, amount)\n  for (let i = 0; i < amount; i++) {\n    const x = Math.random() * range - range / 2\n    const y = Math.random() * range - range / 2\n    const z = Math.random() * range - range / 2\n    const matrix = new THREE.Matrix4()\n    matrix.makeTranslation(x, y, z)\n    mesh.setMatrixAt(i, matrix)\n  }\n```", "```js\n  const size = 1\n  const amount = 500000\n  const range = 20\n  const mat = new THREE.MeshNormalMaterial()\n  mat.blending = THREE.NormalBlending\n  mat.opacity = 0.1\n  mat.transparent = true\n  const geoms = []\n  for (let i = 0; i < amount; i++) {\n    const x = Math.random() * range - range / 2\n    const y = Math.random() * range - range / 2\n    const z = Math.random() * range - range / 2\n    const g = new THREE.BoxGeometry(size, size, size)\n    g.translate(x, y, z)\n    geoms.push(g)\n  }\n  const merged = BufferGeometryUtils.\n    mergeBufferGeometries(geoms)\n  const mesh = new THREE.Mesh(merged, mat)\n```", "```js\nconst asJson = mesh.toJSON()\nlocalStorage.setItem('json', JSON.stringify(asJson))\n```", "```js\n{\n  \"metadata\": {\n    \"version\": 4.5,\n    \"type\": \"Object\",\n    \"generator\": \"Object3D.toJSON\"\n  },\n  \"geometries\": [\n    {\n      \"uuid\": \"15a98944-91a8-45e0-b974-0d505fcd12a8\",\n      \"type\": \"TorusKnotGeometry\",\n      \"radius\": 1,\n      \"tube\": 0.1,\n      \"tubularSegments\": 200,\n      \"radialSegments\": 10,\n      \"p\": 6,\n      \"q\": 7\n    }\n  ],\n  \"materials\": [\n    {\n      \"uuid\": \"38e11bca-36f1-4b91-b3a5-0b2104c58029\",\n      \"type\": \"MeshStandardMaterial\",\n      \"color\": 16770655,\n      // left out some material properties    \n      \"stencilFuncMask\": 255,\n      \"stencilFail\": 7680,\n      \"stencilZFail\": 7680,\n      \"stencilZPass\": 7680\n    }\n  ],\n  \"object\": {\n    \"uuid\": \"373db2c3-496d-461d-9e7e-48f4d58a507d\",\n    \"type\": \"Mesh\",\n    \"castShadow\": true,\n    \"layers\": 1,\n    \"matrix\": [\n      0.5,\n      ...\n      1\n    ],\n    \"geometry\": \"15a98944-91a8-45e0-b974-0d505fcd12a8\",\n    \"material\": \"38e11bca-36f1-4b91-b3a5-0b2104c58029\"\n  }\n}\n```", "```js\nconst fromStorage = localStorage.getItem('json')\nif (fromStorage) {\n  const structure = JSON.parse(fromStorage)\n  const loader = new THREE.ObjectLoader()\n  const mesh = loader.parse(structure)\n  mesh.material.color = new THREE.Color(0xff0000)\n  scene.add(mesh)\n}\n```", "```js\nconst asJson = scene.toJSON()\nlocalStorage.setItem('scene', JSON.stringify(asJson))\n```", "```js\nv -0.032442 0.010796    0.025935\nv -0.028519 0.013697    0.026201\nv -0.029086 0.014533    0.021409\nusemtl Material \ns   1   \nf   2731    2735 2736 2732\nf   2732    2736 3043 3044\n```", "```js\nnewmtl Material\nNs  56.862745   \nKa  0.000000    0.000000    0.000000\nKd  0.360725    0.227524    0.127497\nKs  0.010000    0.010000    0.010000\nNi  1.000000        \nd 1.000000\nillum 2\n```", "```js\nimport { OBJLoader } from 'three/examples/jsm/\n  loaders/OBJLoader'\nnew OBJLoader().loadAsync('/assets/models/\n  baymax/Bigmax_White_OBJ.obj').then((model) => {\n  model.scale.set(0.05, 0.05, 0.05)\n  model.translateY(-1)\n  visitChildren(model, (child) => {\n    child.receiveShadow = true\n    child.castShadow = true\n  })\n  return model\n})\n```", "```js\nconst model = new OBJLoader().load('/assets/models/baymax\n  /Bigmax_White_OBJ.obj', (model) => {\n  model.scale.set(0.05, 0.05, 0.05)\n  model.translateY(-1)\n  visitChildren(model, (child) => {\n    child.receiveShadow = true\n    child.castShadow = true\n  })\n  // do something with the model\n  scene.add(model)\n})\n```", "```js\nconst model = mtlLoader.loadAsync('/assets/models/butterfly/\n  butterfly.mtl').then((materials) => {\n  objLoader.setMaterials(materials)\n  return objLoader.loadAsync('/assets/models/butterfly/\n    butterfly.obj').then((model) => {\n    model.scale.set(30, 30, 30)\n    visitChildren(model, (child) => {\n      // if there are already normals, we can't merge \n        vertices\n      child.geometry.deleteAttribute('normal')\n      child.geometry = BufferGeometryUtils.\n        mergeVertices(child.geometry)\n      child.geometry.computeVertexNormals()\n      child.material.opacity = 0.1\n      child.castShadow = true\n    })\n    const wing1 = model.children[4]\n    const wing2 = model.children[5]\n    [0, 2, 4, 6].forEach(function (i) { \n      model.children[i].rotation.z = 0.3 * Math.PI })\n    [1, 3, 5, 7].forEach(function (i) { \n      model.children[i].rotation.z = -0.3 * Math.PI })\n    wing1.material.opacity = 0.9\n    wing1.material.transparent = true\n    wing1.material.alphaTest = 0.1\n    wing1.material.side = THREE.DoubleSide\n    wing2.material.opacity = 0.9\n    wing2.material.depthTest = false\n    wing2.material.transparent = true\n    wing2.material.alphaTest = 0.1\n    wing2.material.side = THREE.DoubleSide\n    return model\n  })\n})\n```", "```js\nconst loader = new GLTFLoader()\nreturn loader.loadAsync('/assets/models/sea_house/\n  scene.gltf').then((structure) => {\n  structure.scene.scale.setScalar(0.2, 0.2, 0.2)\n  visitChildren(structure.scene, (child) => {\n    if (child.material) {\n      child.material.depthWrite = true\n    }\n  })\n  scene.add(structure.scene)\n})\n```", "```js\nloader.loadAsync('/assets/models/lego/10174-1-ImperialAT-ST-UCS.mpd_Packed.mpd').'/assets/models/lego/10174-1-ImperialAT-ST-UCS.mpd_Packed.mpd'.then((model) => {\n  model.scale.set(0.015, 0.015, 0.015)\n  model.rotateZ(Math.PI)\n  model.rotateY(Math.PI)\n  model.translateY(1)\n  visitChildren(model, (child) => {\n    child.castShadow = true\n    child.receiveShadow = true\n  })\n  scene.add(model))\n})\n```", "```js\nnew VOXLoader().loadAsync('/assets/models/vox/monu9.vox').then((chunks) => {\n  const group = new THREE.Group()\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i]\n    const mesh = new VOXMesh(chunk)\n    mesh.castShadow = true\n    mesh.receiveShadow = true\n    group.add(mesh)\n  }\n  group.scale.setScalar(0.1)\n  scene.add(group)\n})\n```", "```js\nPDBLoader().loadAsync('/assets/models/molecules/caffeine.pdb').then((geometries) => {\n  const group = new THREE.Object3D()\n  // create the atoms\n  const geometryAtoms = geometries.geometryAtoms\n  for (let i = 0; i < geometryAtoms.attributes.\n    position.count; i++) {\n    let startPosition = new THREE.Vector3()\n    startPosition.x = geometryAtoms.attributes.\n      position.getX(i)\n    startPosition.y = geometryAtoms.attributes.\n      position.getY(i)\n    startPosition.z = geometryAtoms.attributes.position.getZ(i)\n    let color = new THREE.Color()\n    color.r = geometryAtoms.attributes.color.getX(i)\n    color.g = geometryAtoms.attributes.color.getY(i)\n    color.b = geometryAtoms.attributes.color.getZ(i)\n    let material = new THREE.MeshPhongMaterial({\n      color: color\n    })\n    let sphere = new THREE.SphereGeometry(0.2)\n    let mesh = new THREE.Mesh(sphere, material)\n    mesh.position.copy(startPosition)\n    group.add(mesh)\n  }\n  // create the bindings\n  const geometryBonds = geometries.geometryBonds\n  for (let j = 0; j < \n    geometryBonds.attributes.position.count; j += 2) {\n    let startPosition = new THREE.Vector3()\n    startPosition.x = geometryBonds.attributes.\n      position.getX(j)\n    startPosition.y = geometryBonds.attributes.position.\n      getY(j)\n    startPosition.z = geometryBonds.attributes.position.\n      getZ(j)\n    let endPosition = new THREE.Vector3()\n    endPosition.x = geometryBonds.attributes.position.\n      getX(j + 1)\n    endPosition.y = geometryBonds.attributes.position.\n      getY(j + 1)\n    endPosition.z = geometryBonds.attributes.position.\n      getZ(j + 1)\n    // use the start and end to create a curve, and use the \n      curve to draw\n    // a tube, which connects the atoms\n    let path = new THREE.CatmullRomCurve3([startPosition, \n      endPosition])\n    let tube = new THREE.TubeGeometry(path, 1, 0.04)\n    let material = new THREE.MeshPhongMaterial({\n      color: 0xcccccc\n    })\n    let mesh = new THREE.Mesh(tube, material)\n    group.add(mesh)\n  }\n  group.scale.set(0.5, 0.5, 0.5)\n  scene.add(group)\n})\n```", "```js\n    let sphere = new THREE.SphereGeometry(0.2)\n    let mesh = new THREE.Mesh(sphere, material)\n    mesh.position.copy(startPosition)\n    group.add(mesh)\n```", "```js\nlet path = new THREE.CatmullRomCurve3([startPosition, \n  endPosition])\nlet tube = new THREE.TubeGeometry(path, 1, 0.04)\nlet material = new THREE.MeshPhongMaterial({\n  color: 0xcccccc\n})\nlet mesh = new THREE.Mesh(tube, material)\ngroup.add(mesh)\n```", "```js\nconst texture = new THREE.TextureLoader().load('/assets\n  /textures/particles/glow.png')\nconst material = new THREE.PointsMaterial({\n  size: 0.15,\n  vertexColors: false,\n  color: 0xffffff,\n  map: texture,\n  depthWrite: false,\n  opacity: 0.1,\n  transparent: true,\n  blending: THREE.AdditiveBlending\n})\nreturn new PLYLoader().loadAsync('/assets/\n  models/carcloud/carcloud.ply').then((model) => {\n  const points = new THREE.Points(model, material)\n  points.scale.set(0.7, 0.7, 0.7)\n  scene.add(points)\n})\n```"]