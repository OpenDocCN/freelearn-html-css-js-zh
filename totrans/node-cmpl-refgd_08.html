<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Multiuser Authentication the Microservice Way</h1>
                </header>
            
            <article>
                
<p>Now that our Notes application can save its data in a database, we can think about the next phase of making this a real application, namely authenticating our users. </p>
<p><span>It's so natural to log in to a website to use its services. We do it every day, and we even trust banking and investment organizations to secure our financial information through login procedures on a website. HTTP is a stateless protocol, and a web application cannot tell much about one HTTP request versus another. Because HTTP is stateless, HTTP requests do not natively know whether the user driving the web browser is logged in, the user's identity, or even whether the HTTP request was initiated by a human being.</span></p>
<p>The typical method for user authentication is to send a cookie to the browser containing a token to carry user identity. The cookie needs to contain data identifying the browser and whether that browser is logged in. The cookie will then be sent with every request, letting the application track which user account is associated with the browser.</p>
<p class="mce-root"/>
<p>With Express, the best way to do this is with the <kbd>express-session</kbd> middleware. It stores data as a cookie and looks for that data on every browser request. It is easy to configure, but is not a complete solution for user authentication. There are several add-on modules that handle user authentication, and some even support authenticating users against third-party websites, such as Facebook or Twitter.</p>
<p>One package appears to be leading the pack in user authentication – Passport (<a href="http://passportjs.org/"><span class="URLPACKT">http://passportjs.org/</span></a>). It supports a long list of services against which to authenticate, making it easy to develop a website that lets users sign up with credentials from another website, for example, Twitter. Another, express-authentication (<a href="https://www.npmjs.com/package/express-authentication"><span class="URLPACKT">https://www.npmjs.com/package/express-authentication</span></a>), bills itself as the opinionated alternative to Passport.</p>
<p>We will use Passport to authenticate users against both a locally stored user credentials database and using OAuth2 to authenticate against a Twitter account. We'll also take this as an opportunity to explore REST-based microservice implementation with Node.js. </p>
<p> In this chapter, we'll discuss the following three aspects of this phase:</p>
<ul>
<li>Creating a microservice to store user profile/authentication data.</li>
<li>User authentication with a locally stored password.</li>
<li>Using OAuth2 to support<span> </span>authentication via third-party services. Specifically, we'll use Twitter as a third-party authentication service.</li>
</ul>
<p>Let's get started!</p>
<p>The first thing to do is duplicate the code used for the previous chapter. For example, if you kept that code in <kbd>chap07/notes</kbd>, create a new directory, <kbd>chap08/notes</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a user information microservice</h1>
                </header>
            
            <article>
                
<p>We could implement user authentication and accounts by simply adding a user model, and a few routes and views to the existing <em>Notes</em> application. While it would be accomplishable, is this what we would do in a real-world production application?</p>
<p>Consider the high value of user identity information, and the super-strong need for robust and reliable user authentication. Website intrusions happen regularly, and it seems the item most frequently stolen is user identities. </p>
<p>Can you design and build a user authentication system with the required level of security?  One that is probably safe against all kinds of intruders?</p>
<p>As with so many other software development problems, it's best to use a pre-existing authentication library, preferably one with a long track record, where significant bugs have been fixed already.</p>
<p>Another issue is architectural choices to promote security. Bugs will occur and the talented miscreants will break in. Walling off the user information database is an excellent idea to limit the risk.</p>
<p>Keeping a user information database enables you to authenticate your users, present user profiles, help users connect with each other, and so forth. Those are useful services to offer to website users, but how can you limit the risk that data will fall into the wrong hands?</p>
<p>In this chapter, we'll develop a user authentication microservice. The plan is to eventually segregate that service into a well-protected barricaded area. This mimics an architectural choice made by some sites, to strictly control API and even physical access to the user information database, implementing as many technological barriers as possible against unapproved access.</p>
<p>Microservices are, of course, not a panacea, meaning we shouldn't try to force-fit every application into the microservice box. By analogy, microservices are like the Unix philosophy of small tools each doing one thing well, which we mix/match/combine into larger tools. Another word for this is composability. While we can build a lot of useful software tools with that philosophy, does it work for applications such as Photoshop or LibreOffice?  While composing a system out of single-purpose tools is highly flexible, one loses the advantages gained by tight integration of components.</p>
<p>The first question is whether to use a REST-service oriented framework, code the REST application on bare Node.js, or what? You could implement REST services on the built-in <kbd>http</kbd> module. The advantage of using an application framework is the framework authors will have already baked-in a lot of best practices and bug fixing and security measures. Express, for example, is widely used, very popular, and can easily be used for REST services. There are other frameworks more aligned with developing REST services, and we'll use one of them – Restify <span>(</span><a href="http://restify.com/"><span class="URLPACKT">http://restify.com/</span></a><span>).</span></p>
<p>The user authentication server will require two modules:</p>
<ul>
<li>Using Restify, implementing the REST interface</li>
<li>A data model using Sequelize to store user data objects in an SQL database</li>
</ul>
<p>To test the service, we'll write a couple of simple scripts for administering user information in the database. We won't be implementing an administrative user interface in the <em>Notes</em> application, and will rely on the scripts to administer the users. As a side effect, we'll have a tool to run a couple of simple tests against the user service.</p>
<p>After this service is functioning correctly, we'll set about modifying the Notes application to access user information from the service, while using Passport to handle authentication.</p>
<p>The first step is creating a new directory to hold the User Information microservice. This should be a sibling directory to the Notes application. If you created a directory named <kbd>chap08/notes</kbd> to hold the Notes application, then create a directory named <kbd>chap08/users</kbd> to hold the microservice.</p>
<p>Then run the following commands:</p>
<pre><strong>$ cd users
$ npm init
.. answer questions 
.. name - user-auth-server
$ npm install debug@^2.6.x fs-extra@^5.x js-yaml@^3.10.x \
       restify@^6.3.x restify-clients@^1.5.x sequelize@^4.31.x \
       sqlite3@^3.1.x --save</strong></pre>
<p>This gets us ready to start coding. We'll use the <kbd>debug</kbd> module for logging messages, <kbd>js-yaml</kbd> to read the Sequelize configuration file, <kbd>restify</kbd> for its REST framework, and <kbd>sequelize/mysql/sqlite3</kbd> for database access.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">User information model</h1>
                </header>
            
            <article>
                
<p>We'll be storing the user information using a Sequelize-based model in an SQL database. As we go through this, ponder a question: should we integrate the database code directly into the REST API implementation? Doing so would reduce the user information microservice to one module, with database queries mingled with REST handlers. By separating the REST service from the data storage model, we have the freedom to adopt other data storage systems besides Sequelize/SQL. Further, the data storage model could conceivably be used in ways <span>other</span> than the REST service.</p>
<p>Create a new file named <kbd>users-sequelize.mjs</kbd> in <kbd>users</kbd>, containing the following:</p>
<pre>import Sequelize from "sequelize";<br/>import jsyaml from 'js-yaml';<br/>import fs from 'fs-extra';<br/>import util from 'util';<br/>import DBG from 'debug';<br/>const log = DBG('users:model-users'); <br/>const error = DBG('users:error'); <br/><br/>var SQUser;<br/>var sequlz;<br/><br/>async function connectDB() {<br/>    <br/>    if (SQUser) return SQUser.sync();<br/>    <br/>    const yamltext = await fs.readFile(process.env.SEQUELIZE_CONNECT, <br/>    'utf8');<br/>    const params = await jsyaml.safeLoad(yamltext, 'utf8');<br/>    <br/>    if (!sequlz) sequlz = new Sequelize(params.dbname, params.username,<br/>                                        params.password, <br/>    params.params);<br/>    <br/>    // These fields largely come from the Passport / Portable Contacts <br/>    schema.<br/>    // See http://www.passportjs.org/docs/profile<br/>    //<br/>    // The emails and photos fields are arrays in Portable Contacts. <br/>    // We'd need to set up additional tables for those.<br/>    //<br/>    // The Portable Contacts "id" field maps to the "username" field <br/>    here<br/>    if (!SQUser) SQUser = sequlz.define('User', {<br/>        username: { type: Sequelize.STRING, unique: true },<br/>        password: Sequelize.STRING,<br/>        provider: Sequelize.STRING,<br/>        familyName: Sequelize.STRING,<br/>        givenName: Sequelize.STRING,<br/>        middleName: Sequelize.STRING,<br/>        emails: Sequelize.STRING(2048),<br/>        photos: Sequelize.STRING(2048)<br/>    });<br/>    return SQUser.sync();<br/>}</pre>
<p>As with our Sequelize-based model for Notes, we use a YAML file to store connection configuration. We're even using the same environment variable, <kbd>SEQUELIZE_CONNECT</kbd>.</p>
<p>What is the best storage service for user authentication data? By using Sequelize, we have our pick of SQL databases to choose from. While NoSQL databases are all the rage, is there any advantage to using one to store user authentication data?  Nope. An SQL server will do the job just fine, and Sequelize allows us the freedom of choice.</p>
<p>It's tempting to simplify the overall system by using the same database instance to store notes and user information, and to use Sequelize for both. But we've chosen to simulate a secured server for user data. That calls for the data to be in separate database instances, preferably on separate servers. A highly secure application deployment might put the user information service on completely separate servers, perhaps in a physically isolated data center, with carefully configured firewalls, and there might even be armed guards at the door. </p>
<p>The user profile schema shown here is derived from the normalized profile provided by Passport; refer to <a href="http://www.passportjs.org/docs/profile"><span class="URLPACKT">http://www.passportjs.org/docs/profile</span></a> for more information. Passport will harmonize information given by third-party services into a single object definition. To simplify our code, we're simply using the schema defined by Passport:</p>
<pre>export async function create(username, password, provider, familyName, givenName, middleName, emails, photos) {<br/>    const SQUser = await connectDB();<br/>    return SQUser.create({<br/>        username, password, provider,<br/>        familyName, givenName, middleName,<br/>        emails: JSON.stringify(emails), photos: JSON.stringify(photos)<br/>    });<br/>}<br/><br/>export async function update(username, password, provider, familyName, givenName, middleName, emails, photos) {<br/>    const user = await find(username);<br/>    return user ? user.updateAttributes({<br/>        password, provider,<br/>        familyName, givenName, middleName,<br/>        emails: JSON.stringify(emails),<br/>        photos: JSON.stringify(photos)<br/>    }) : undefined;<br/>}</pre>
<p>Our <kbd>create</kbd> and <kbd>update</kbd> functions take user information and either add a new record or update an existing record:</p>
<pre>export async function find(username) {<br/>    const SQUser = await connectDB();<br/>    const user = await SQUser.find({ where: { username: username } });<br/>    const ret = user ? sanitizedUser(user) : undefined;<br/>    return ret;<br/>}</pre>
<p>This lets us look up a user information record, and we return a sanitized version of that data.</p>
<div class="packt_infobox"><span>Remember that Sequelize returns a </span><kbd>Promise</kbd><span> object. Because this is executed inside an </span><kbd>async</kbd><span> function, the </span><kbd>await</kbd><span> keyword will resolve the Promise, causing </span>any<span> error to be thrown or results to be provided as the return value. In turn, async functions return a </span><kbd>Promise</kbd><span> to the caller.</span></div>
<p>Because we're segregating the user data from the rest of the Notes application, we want to return a sanitized object rather than the actual <kbd>SQUser</kbd> object. What if there was some information leakage because we simply sent the <kbd>SQUser</kbd> object back to the caller? The <kbd>sanitizedUser</kbd> function, shown later, creates an anonymous object with exactly the fields we want exposed to the other modules:</p>
<pre>export async function destroy(username) {<br/>    const SQUser = await connectDB();<br/>    const user = await SQUser.find({ where: { username: username } });<br/>    if (!user) throw new Error('Did not find requested '+ username +' to delete');<br/>    user.destroy();<br/>}</pre>
<p>This lets us support deleting user information. We do this as we did for the Notes Sequelize model, by first finding the user object and then calling its <kbd>destroy</kbd> method:</p>
<pre>export async function userPasswordCheck(username, password) {<br/>    const SQUser = await connectDB();<br/>    const user = await SQUser.find({ where: { username: username } });<br/>    if (!user) {<br/>        return { check: false, username: username, message: "Could not <br/>        find user" };<br/>    } else if (user.username === username &amp;&amp; user.password === <br/>    password) {<br/>        return { check: true, username: user.username };<br/>    } else {<br/>        return { check: false, username: username, message: "Incorrect <br/>        password" };<br/>    }<br/>}</pre>
<p>This lets us support the checking of user passwords. The three conditions to handle are as follows:</p>
<ul>
<li>Whether there's no such user</li>
<li>Whether the passwords matched</li>
<li>Whether they did not match</li>
</ul>
<p>The object we return lets the caller distinguish between those cases. The <kbd>check</kbd> field indicates whether to allow this user to be logged in. If <kbd>check</kbd> is false, there's some reason to deny their request to log in, and the <kbd>message</kbd> is what should be displayed to the user:</p>
<pre>export async function findOrCreate(profile) {<br/>    const user = await find(profile.id);<br/>    if (user) return user;<br/>    return await create(profile.id, profile.password, profile.provider,<br/>                    profile.familyName, profile.givenName, profile.middleName,<br/>                    profile.emails, profile.photos);<br/>}</pre>
<p>This combines two actions in one function: first, to verify whether the named user exists and, if not, to create that user. Primarily, this will be used while authenticating against third-party services:</p>
<pre>export async function listUsers() {<br/>    const SQUser = await connectDB();<br/>    const userlist = await SQUser.findAll({});<br/>    return userlist.map(user =&gt; sanitizedUser(user));<br/>}</pre>
<p>List the existing users. The first step is using <kbd>findAll</kbd> to give us the list of the users as an array of <kbd>SQUser</kbd> objects. Then we sanitize that list so we don't expose any data that we don't want exposed:</p>
<pre>export function sanitizedUser(user) {<br/>    var ret = {<br/>        id: user.username, username: user.username,<br/>        provider: user.provider,<br/>        familyName: user.familyName, givenName: user.givenName,<br/>        middleName: user.middleName,<br/>        emails: JSON.parse(user.emails),<br/>        photos: JSON.parse(user.photos)<br/>    };<br/>    try {<br/>        ret.emails = JSON.parse(user.emails);<br/>    } catch(e) { ret.emails = []; }<br/>    try {<br/>        ret.photos = JSON.parse(user.photos);<br/>    } catch(e) { ret.photos = []; }<br/>    return ret;<br/>}</pre>
<p>This is our utility function to ensure we expose a carefully controlled set of information to the caller. With this service, we're emulating a secured user information service that's walled off from other applications. As we said earlier, this function returns an anonymous sanitized object where we know exactly what's in the object.</p>
<p>It's very important to decode the JSON string we put into the database. Remember that we stored the <kbd>emails</kbd> and <kbd>photos</kbd> data using <kbd>JSON.stringify</kbd> in the database. Using <kbd>JSON.parse</kbd>, we decode those values, just like adding hot water to instant coffee produces a drinkable beverage.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A REST server for user information</h1>
                </header>
            
            <article>
                
<p>We are building our way towards integrating user information and authentication into the Notes application. The next step is to wrap the user data model we just created into a REST server. After that, we'll create a couple of scripts so that we can add some users, perform other administrative tasks, and generally verify that the service works. Finally, we'll extend the Notes application with login and logout support.</p>
<p>In the <kbd>package.json</kbd> file, change the <kbd>main</kbd> tag to the following line of code:</p>
<pre> "main": "user-server.mjs", </pre>
<p>Then create a file named <kbd>user-server.mjs</kbd>, containing the following code:</p>
<pre>import restify from 'restify';<br/>import util from 'util';<br/><br/>import DBG from 'debug';<br/>const log = DBG('users:service'); <br/>const error = DBG('users:error'); <br/><br/>import * as usersModel from './users-sequelize';<br/><br/>var server = restify.createServer({<br/>    name: "User-Auth-Service",<br/>    version: "0.0.1"<br/>});<br/><br/>server.use(restify.plugins.authorizationParser());<br/>server.use(check);<br/>server.use(restify.plugins.queryParser());<br/>server.use(restify.plugins.bodyParser({<br/>    mapParams: true<br/>}));</pre>
<p>The <kbd>createServer</kbd> method can take a long list of configuration options. These two may be useful for identifying information.</p>
<p>As with Express applications, the <kbd>server.use</kbd> calls initialize what Express would call middleware functions, but which Restify calls handler functions. These are callback functions whose API is <kbd>function (req, res, next)</kbd>. As with Express, these are the request and response objects, and <kbd>next</kbd> is a function which, when called, carries execution to the next handler function.</p>
<p>Unlike Express, every handler function must call the <kbd>next</kbd> function. In order to tell Restify to stop processing through handlers, the <kbd>next</kbd> function must be called as <kbd>next(false)</kbd>. Calling <kbd>next</kbd> with an <kbd>error</kbd> object also causes the execution to end, and the error is sent back to the requestor.</p>
<p>The handler functions listed here do two things: authorize requests and handle parsing parameters from both the URL and the <kbd>post</kbd> request body. The <kbd>authorizationParser</kbd> function looks for HTTP basic auth headers. The <kbd>check</kbd> function is shown later and emulates the idea of an API token to control access.</p>
<p>Refer to <a href="http://restify.com/docs/plugins-api/">http://restify.com/docs/plugins-api/</a> for more information on the built-in handlers available in Restify.</p>
<p>Add this to <kbd>user-server.mjs</kbd>:</p>
<pre>// Create a user record<br/>server.post('/create-user', async (req, res, next) =&gt; {<br/>    try {<br/>        var result = await usersModel.create(<br/>                 req.params.username, req.params.password, <br/>        req.params.provider,<br/>                 req.params.familyName, req.params.givenName, <br/>        req.params.middleName,<br/>                 req.params.emails, req.params.photos);<br/>        res.send(result);<br/>        next(false);<br/>    } catch(err) { res.send(500, err); next(false); }<br/>});</pre>
<p>As for Express, the <kbd>server.VERB</kbd> functions let us define the handlers for specific HTTP actions. This route handles a POST on <kbd>/create-user</kbd>, and, as the name implies, this will create a user by calling the <kbd>usersModel.create</kbd> function.</p>
<p>As a <kbd>POST</kbd> request, the parameters arrive in the body of the request rather than as URL parameters. Because of the <kbd>mapParams</kbd> flag on the <kbd>bodyParams</kbd> handler, the arguments passed in the HTTP body are added to <kbd>req.params</kbd>.</p>
<p>We simply call <kbd>usersModel.create</kbd> with the parameters sent to us. When completed, the <kbd>result</kbd> object should be a <kbd>user</kbd> object, which we send back to the requestor using <kbd>res.send</kbd>:</p>
<pre>// Update an existing user record<br/>server.post('/update-user/:username', async (req, res, next) =&gt; {<br/>    try {<br/>        var result = await usersModel.update(<br/>              req.params.username, req.params.password, <br/>        req.params.provider,<br/>              req.params.familyName, req.params.givenName,  <br/>        req.params.middleName,<br/>              req.params.emails, req.params.photos);<br/>        res.send(usersModel.sanitizedUser(result));<br/>        next(false);<br/>    } catch(err) { res.send(500, err); next(false); }<br/>});</pre>
<p>The <kbd>/update-user</kbd> route is handled in a similar way. However, we have put the <kbd>username</kbd> parameter on the URL. Like Express, Restify lets you put named parameters in the URL like as follows. Such named parameters are also added to <kbd>req.params</kbd>.</p>
<p>We simply call <kbd>usersModel.update</kbd> with the parameters sent to us. That, too, returns an object we send back to the caller with <kbd>res.send</kbd>:</p>
<pre>// Find a user, if not found create one given profile information<br/>server.post('/find-or-create', async (req, res, next) =&gt; {<br/>    log('find-or-create '+ util.inspect(req.params));<br/>    try {<br/>        var result = await usersModel.findOrCreate({<br/>            id: req.params.username, username: req.params.username,<br/>            password: req.params.password, provider:  <br/>            req.params.provider,<br/>            familyName: req.params.familyName, givenName: <br/>            req.params.givenName,<br/>            middleName: req.params.middleName,<br/>            emails: req.params.emails, photos: req.params.photos<br/>        });<br/>        res.send(result);<br/>        next(false);<br/>    } catch(err) { res.send(500, err); next(false); }<br/>});</pre>
<p>This handles our <kbd>findOrCreate</kbd> operation. We simply delegate this to the model code, as done previously.</p>
<p>As the name implies, we'll look to see whether the named user already exists and, if so, simply return that user, otherwise it will be created:</p>
<pre>// Find the user data (does not return password)<br/>server.get('/find/:username', async (req, res, next) =&gt; {<br/>    try {<br/>        var user = await usersModel.find(req.params.username);<br/>        if (!user) {<br/>            res.send(404, new Error("Did not find "+ <br/>            req.params.username));<br/>        } else {<br/>            res.send(user);<br/>        }<br/>        next(false);<br/>    } catch(err) { res.send(500, err); next(false); }<br/>});</pre>
<p>Here, we support looking up the user object for the provided <kbd>username</kbd>.</p>
<p>If the user was not found, then we return a 404 status code because it indicates a resource that does not exist. Otherwise, we send the object that was retrieved:</p>
<pre>// Delete/destroy a user record<br/>server.del('/destroy/:username', async (req, res, next) =&gt; {<br/>    try {<br/>        await usersModel.destroy(req.params.username);<br/>        res.send({}); <br/>        next(false); <br/>    } catch(err) { res.send(500, err); next(false); }<br/>});</pre>
<p>This is how we delete a user from the Notes application. The <kbd>DEL</kbd> HTTP verb is meant to be used to delete things on a server, making it the natural choice for this functionality:</p>
<pre>// Check password<br/>server.post('/passwordCheck', async (req, res, next) =&gt; {<br/>    try {<br/>        await usersModel.userPasswordCheck(<br/>                        req.params.username, req.params.password);<br/>        res.send(check);<br/>        next(false); <br/>    } catch(err) { res.send(500, err); next(false); }<br/>});</pre>
<p>This is another aspect of keeping the password solely within this server. The password check is performed by this server, rather than in the Notes application. We simply call the <kbd>usersModel.userPasswordCheck</kbd> function shown earlier and send back the object it returns:</p>
<pre>// List users<br/>server.get('/list', async (req, res, next) =&gt; {<br/>    try {<br/>        var userlist = await usersModel.listUsers();<br/>        if (!userlist) userlist = [];<br/>        res.send(userlist);<br/>        next(false);<br/>    } catch(err) { res.send(500, err); next(false); }<br/>});</pre>
<p>Then, finally, if required, we send a list of Notes application users back to the requestor. In case no list of users is available, we at least send an empty array:</p>
<pre>server.listen(process.env.PORT, "localhost", function() { 
  log(server.name +' listening at '+ server.url); 
}); 
 
// Mimic API Key authentication. 
 
var apiKeys = [ { 
    user: 'them', 
    key: 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF' 
} ]; 
 
function check(req, res, next) { 
    if (req.authorization) { 
        var found = false; 
        for (let auth of apiKeys) { 
            if (auth.key  === req.authorization.basic.password 
             &amp;&amp; auth.user === req.authorization.basic.username) { 
                found = true; 
                break; 
            } 
        } 
        if (found) next(); 
        else { 
            res.send(401, new Error("Not authenticated")); 
            next(false); 
        } 
    } else { 
        res.send(500, new Error('No Authorization Key'));
        next(false); 
    } 
} </pre>
<p>As with the Notes application, we listen to the port named in the <kbd>PORT</kbd> environment variable. By explicitly listening only on <kbd>localhost</kbd>, we'll limit the scope of systems that can access the user authentication server. In a real deployment, we might have this server behind a firewall with a tight list of host systems allowed to have access.</p>
<p>This last function, <kbd>check</kbd>, implements authentication for the REST API itself. This is the handler function we added earlier.</p>
<p>It requires the caller to provide credentials on the HTTP request using the basic auth headers. The <kbd>authorizationParser</kbd> handler looks for this and gives it to us on the <kbd>req.authorization.basic</kbd> object. The <kbd>check</kbd> function simply verifies that the named user and password combination exists in the local array.</p>
<p>This is meant to mimic assigning an API key to an application. There are several ways of doing so; this is just one.</p>
<p>This approach is not limited to just authenticating using HTTP basic auth. The Restify API lets us look at any header in the HTTP request, meaning we could implement any kind of security mechanism we like. The <kbd>check</kbd> function could implement some other security method, with the right code.</p>
<p>Because we added <kbd>check</kbd> with the initial set of <kbd>server.use</kbd> handlers, it is called on every request. Therefore, every request to this server must provide the HTTP basic auth credentials required by this check.</p>
<p>This strategy is good if you want to control access to every single function in your API. For the user authentication service, that's probably a good idea. Some REST services in the world have certain API functions that are open to the world and others protected by an API token. To implement that, the <kbd>check</kbd> function should not be configured among the <kbd>server.use</kbd> handlers. Instead, it should be added to the appropriate route handlers as follows:</p>
<pre>server.get('/request/url', authHandler, (req, res, next) =&gt; { 
  .. 
});</pre>
<p>Such an <kbd>authHandler</kbd> would be coded similarly to our <kbd>check</kbd> function. A failure to authenticate is indicated by sending an error code and using <kbd>next(false)</kbd> to end the routing function chain.</p>
<p>We now have the complete code for the user authentication server. It defines several request URLs, and for each, the corresponding function in the user model is called.</p>
<p>Now we need a YAML file to hold the database credentials, so create <kbd>sequelize-sqlite.yaml</kbd>, containing the following code:</p>
<pre>dbname: users 
username: 
password: 
params: 
    dialect: sqlite 
    storage: users-sequelize.sqlite3 </pre>
<p>Since this is Sequelize, it's easy to switch to other database engines simply by supplying a different configuration file. Remember that the filename of this configuration file must appear in the <kbd>SEQUELIZE_CONNECT</kbd> environment variable.</p>
<p>Finally, <kbd>package.json</kbd> should look as follows:</p>
<pre>{<br/>  "name": "user-auth-server",<br/>  "version": "0.0.1",<br/>  "description": "",<br/>  "main": "user-server.js",<br/>  "scripts": {<br/>    "start": "DEBUG=users:* PORT=3333 SEQUELIZE_CONNECT=sequelize-sqlite.yaml node --experimental-modules user-server"<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "engines": {<br/>    "node": "&gt;=8.9"<br/>  },<br/>  "dependencies": {<br/>    "debug": "^2.6.9",<br/>    "fs-extra": "^5.x",<br/>    "js-yaml": "^3.10.x",<br/>    "mysql": "^2.15.x",<br/>    "restify": "^6.3.x",<br/>    "restify-clients": "^1.5.x",<br/>    "sqlite3": "^3.1.x",<br/>    "sequelize": "^4.31.x"<br/>  }<br/>}</pre>
<p>We configure this server to listen on port <kbd>3333</kbd> using the database credentials we just gave and with debugging output for the server code.</p>
<p>You can now start the user authentication server:</p>
<pre><strong>$ npm start
    
&gt; user-auth-server@0.0.1 start /Users/david/chap08/users
&gt; DEBUG=users:* PORT=3333 SEQUELIZE_CONNECT=sequelize-mysql.yaml node user-server
    
  users:server User-Auth-Service listening at http://127.0.0.1:3333 +0ms</strong> </pre>
<p>But we don't have any way to interact with this server, yet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scripts to test and administer the user authentication server</h1>
                </header>
            
            <article>
                
<p>To give ourselves assurance that the user authentication server works, let's write a couple of scripts to exercise the API. Because we're not going to take the time to write an administrative backend to the Notes application, these scripts will let us add and delete users who are allowed access to Notes. These scripts will live within the user authentication server package directory. </p>
<p>The Restify package supports coding REST servers. For the REST clients, we're using a companion library, <span><kbd>restify-clients</kbd>, which has been spun out of Restify</span>. </p>
<p>Create a file named <kbd>users-add.js</kbd>, containing the following code:</p>
<pre>'use strict';<br/><br/>const util = require('util');<br/>const restify = require('restify-clients');<br/><br/>var client = restify.createJsonClient({<br/>  url: 'http://localhost:'+process.env.PORT,<br/>  version: '*'<br/>});<br/><br/>client.basicAuth('them', 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF');<br/><br/>client.post('/create-user', {<br/>    username: "me", password: "w0rd", provider: "local",<br/>    familyName: "Einarrsdottir", givenName: "Ashildr", middleName: "",<br/>    emails: [], photos: []<br/>},<br/>(err, req, res, obj) =&gt; {<br/>    if (err) console.error(err.stack);<br/>    else console.log('Created '+ util.inspect(obj));<br/>});</pre>
<p>This is the basic structure of a Restify client. We create the <kbd>Client</kbd> object – we have a choice between the <kbd>JsonClient</kbd>, as used here, the <kbd>StringClient</kbd>, and the <kbd>HttpClient</kbd>. The HTTP <kbd>basicAuth</kbd> credentials are easy to set, as shown here.</p>
<p>Then we make the request, in this case a <kbd>POST</kbd> request on <kbd>/create-user</kbd>. Because it is a <kbd>POST</kbd> request, the object we specify here is formatted by Restify into <kbd>HTTP POST</kbd> body parameters. As we saw earlier, the server has the <kbd>bodyParser</kbd> handler function configured, which converts those body parameters into the <kbd>req.param</kbd> object.</p>
<p>In the Restify client, as for the Restify server, we use the various HTTP methods by calling <kbd>client.METHOD</kbd>. Because it is a <kbd>POST</kbd> request, we use <kbd>client.post</kbd>. When the request finishes, the callback function is invoked.</p>
<p>Before running these scripts, start the authentication server in one window using the following command:</p>
<pre><strong>$ npm start</strong></pre>
<p>Now run the test script using the following command:</p>
<pre><strong>$ PORT=3333 node users-add.js 
Created { id: 1, username: 'me', password: 'w0rd', provider: 'local',
  familyName: 'Einarrsdottir', givenName: 'Ashildr',
  middleName: '',
  emails: '[]', photos: '[]',
  updatedAt: '2016-02-24T02:34:41.661Z',
  createdAt: '2016-02-24T02:34:41.661Z' } </strong> </pre>
<p>We can inspect our handiwork using the following command:</p>
<pre><strong>$ sqlite3 users-sequelize.sqlite3 
SQLite version 3.10.2 2016-01-20 15:27:19
Enter ".help" for usage hints.
sqlite&gt; .schema users
CREATE TABLE `Users` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `username` VARCHAR(255) UNIQUE, `password` VARCHAR(255), `provider` VARCHAR(255), `familyName` VARCHAR(255), `givenName` VARCHAR(255), `middleName` VARCHAR(255), `emails` VARCHAR(2048), `photos` VARCHAR(2048), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, UNIQUE (`username`));</strong><br/><strong>sqlite&gt; select * from users;
2|me|w0rd|local|Einarrsdottir|Ashildr||[]|[]|2018-01-21 05:34:56.629 +00:00|2018-01-21 05:34:56.629 +00:00
sqlite&gt; ^D </strong> </pre>
<p>Now let's write a script, <kbd>users-find.js</kbd>, to look up a given user:</p>
<pre>'use strict';<br/><br/>const util = require('util');<br/>const restify = require('restify-clients');<br/><br/>var client = restify.createJsonClient({<br/>  url: 'http://localhost:'+process.env.PORT,<br/>  version: '*'<br/>});<br/><br/>client.basicAuth('them', 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF');<br/><br/>client.get('/find/'+ process.argv[2], <br/>(err, req, res, obj) =&gt; {<br/>    if (err) console.error(err.stack);<br/>    else console.log('Found '+ util.inspect(obj));<br/>});</pre>
<p>This simply calls the <kbd>/find</kbd> URL, specifying the <kbd>username</kbd> that the user supplies as a command-line argument. Note that the <kbd>get</kbd> operation does not take an object full of parameters. Instead, any parameters would be added to the URL.</p>
<p>It's run as follows:</p>
<pre><strong>$ PORT=3333 node users-find.js me
Found { username: 'me', provider: 'local',
  familyName: 'Einarrsdottir', givenName: 'Ashildr',
  middleName: '',
  emails: '[]', photos: '[]' } </strong> </pre>
<p>Similarly, we can write scripts against the other REST functions. But we need to get on with the real goal of integrating this into the Notes application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Login support for the Notes application</h1>
                </header>
            
            <article>
                
<p>Now that we have proved that the user authentication service is working, we can set up the Notes application to support user logins. We'll be using Passport to support login/logout, and the authentication server to store the required data.</p>
<p>Among the available packages, Passport stands out for simplicity and flexibility. It integrates directly with the Express middleware chain, and the Passport community has developed hundreds of so-called Strategy modules to handle authentication against a long list of third-party services. See <a href="http://www.passportjs.org/">http://www.passportjs.org/</a> for information and documentation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accessing the user authentication REST API</h1>
                </header>
            
            <article>
                
<p>The first step is to create a user data model for the Notes application. Rather than retrieving data from data files or a database, it will use REST to query the server we just created. We could have created user model code that directly accesses the database but, for reasons already discussed, we've decided to segregate user authentication into a separate service.</p>
<p>Let us now turn to the Notes application, which you may have stored as <kbd>chap08/notes</kbd>. We'll be modifying the application, first to access the user authentication REST API, and then to use Passport for authorization and authentication.</p>
<p>For the test/admin scripts that we created earlier, we used the <kbd>restify-clients</kbd> module. That package is a companion to the <kbd>restify</kbd> library, where <kbd>restify</kbd> supports the server side of the REST protocol and <kbd>restify-clients</kbd> supports the client side. Their names might give away the purpose.</p>
<p>However nice the <kbd>restify-clients</kbd> library is, it doesn't support a Promise-oriented API, as is required to play well with <kbd>async</kbd> functions. Another library, <kbd>superagent</kbd>, does support a Promise-oriented API, plays well in <kbd>async</kbd> functions, and there is a companion to that package, Supertest, that's useful in unit testing. We'll use Supertest in <a href="">Chapter 11</a>, <em>Unit Testing and Functional Testing</em>, when we talk about unit testing. For documentation, see <a href="https://www.npmjs.com/package/superagent">https://www.npmjs.com/package/superagent</a>:</p>
<pre><strong> $ npm install superagent@^3.8.x</strong></pre>
<p>Create a new file, <kbd>models/users-superagent.mjs</kbd>, containing the following code:</p>
<pre>import request from 'superagent';<br/>import util from 'util';<br/>import url from 'url'; <br/>const URL = url.URL;<br/>import DBG from 'debug';<br/>const debug = DBG('notes:users-superagent'); <br/>const error = DBG('notes:error-superagent'); <br/> <br/>function reqURL(path) {<br/>    const requrl = new URL(process.env.USER_SERVICE_URL);<br/>    requrl.pathname = path;<br/>    return requrl.toString();<br/>}</pre>
<p>The <kbd>reqURL</kbd> function replaces the <kbd>connectXYZZY</kbd> functions that we wrote in earlier modules. With <kbd>superagent</kbd>, we don't leave a connection open to the service, but open a new connection on each request. The common thing to do is to formulate the request URL. The user is expected to provide a base URL, such as <kbd>http://localhost:3333/</kbd>, in the <kbd>USER_SERVICE_URL</kbd> environment variable. This function modifies that URL, using the new WHATWG URL support in Node.js, to use a given URL path:</p>
<pre>export async function create(username, password, <br/>            provider, familyName, givenName, middleName, <br/>            emails, photos) {<br/>    var res = await request<br/>        .post(reqURL('/create-user'))<br/>        .send({ <br/>            username, password, provider, <br/>            familyName, givenName, middleName, emails, photos <br/>        })<br/>        .set('Content-Type', 'application/json')<br/>        .set('Acccept', 'application/json')<br/>        .auth('them', 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF');<br/>    return res.body;<br/>}
 
export async function update(username, password, <br/>            provider, familyName, givenName, middleName, <br/>            emails, photos) { <br/>    var res = await request<br/>        .post(reqURL(`/update-user/${username}`))<br/>        .send({ <br/>            username, password, provider, <br/>            familyName, givenName, middleName, emails, photos <br/>        })<br/>        .set('Content-Type', 'application/json')<br/>        .set('Acccept', 'application/json')<br/>        .auth('them', 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF');<br/>    return res.body;<br/>}</pre>
<p><span>These are our </span><kbd>create</kbd><span> and </span><kbd>update</kbd><span> functions. In each case, they take the data provided, construct an anonymous object, and </span><kbd>POST</kbd><span> it to the server.</span></p>
<p>The <kbd>superagent</kbd> library uses an API style where one chains together method calls to construct a request. The chain of method calls can end in a <kbd>.then</kbd> or <kbd>.end</kbd> clause, either of which take a callback function. But leave off both, and it will return a Promise.</p>
<p>All through this library, we'll use the <kbd>.auth</kbd> clause to set up the required authentication key. </p>
<div class="packt_infobox"><span>These anonymous objects are a little different than usual. We're using a new ES-2015 feature here that we haven't discussed so far. Rather than specifying the object fields using the </span><kbd>fieldName: fieldValue</kbd><span> notation, ES-2015 gives us the option to shorten this when the variable name used for </span><kbd>fieldValue</kbd><span> matches the desired </span><kbd>fieldName</kbd><span>. In other words, we can just list the variable names, and the field name will automatically match the variable name.</span></div>
<p>In this case, we've purposely chosen variable names for the parameters to match field names of the object with parameter names used by the server. By doing so, we can use this shortened notation for anonymous objects, and our code is a little cleaner by using consistent variable names from beginning to end:</p>
<pre>export async function find(username) {<br/>    var res = await request<br/>        .get(reqURL(`/find/${username}`))<br/>        .set('Content-Type', 'application/json')<br/>        .set('Acccept', 'application/json')<br/>        .auth('them', 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF');<br/>    return res.body;<br/>}</pre>
<p>Our <kbd>find</kbd> operation lets us look up user information:</p>
<pre>export async function userPasswordCheck(username, password) { <br/>    var res = await request<br/>        .post(reqURL(`/passwordCheck`))<br/>        .send({ username, password })<br/>        .set('Content-Type', 'application/json')<br/>        .set('Acccept', 'application/json')<br/>        .auth('them', 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF');<br/>    return res.body;<br/>} </pre>
<p>We're sending the request to check passwords to the server. </p>
<p>A point about this method is useful to note. It could have taken the parameters in the URL, instead of the request body as is done here. But since request URL are routinely logged to files, putting the username and password parameters in the URL means user identity information would be logged to files and part of activity reports. That would obviously be a very bad choice. Putting those parameters in the request body not only avoids that bad result, but if an HTTPS connection to the service were used, the transaction would be encrypted:</p>
<pre>export async function findOrCreate(profile) {  <br/>    var res = await request<br/>        .post(reqURL('/find-or-create'))<br/>        .send({ <br/>            username: profile.id, password: profile.password, <br/>            provider: profile.provider, <br/>            familyName: profile.familyName, <br/>            givenName: profile.givenName, <br/>            middleName: profile.middleName, <br/>            emails: profile.emails, photos: profile.photos <br/>        })<br/>        .set('Content-Type', 'application/json')<br/>        .set('Acccept', 'application/json')<br/>        .auth('them', 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF');<br/>    return res.body;<br/>}</pre>
<p>The <kbd>findOrCreate</kbd> function either discovers the user in the database, or creates a new user. The <kbd>profile</kbd> object will come from Passport, but take careful note of what we do with <kbd>profile.id</kbd>. The Passport documentation says it will provide the username in the <kbd>profile.id</kbd> field. But we want to store it as <kbd>username</kbd>, instead:</p>
<pre>export async function listUsers() { <br/>    var res = await request<br/>        .get(reqURL('/list'))<br/>        .set('Content-Type', 'application/json')<br/>        .set('Acccept', 'application/json')<br/>        .auth('them', 'D4ED43C0-8BD6-4FE2-B358-7C0E230D11EF'); <br/>    return res.body;<br/>}</pre>
<p>Finally, we can retrieve a list of users.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Login and logout routing functions</h1>
                </header>
            
            <article>
                
<p>What we've built so far is a user data model, with a REST API wrapping that model to create our authentication information service. Then, within the Notes application, we have a module that requests user data from this server. As of yet, nothing in the Notes application knows that this user model exists. The next step is to create a routing module for login/logout URLs and to change the rest of Notes to use user data.</p>
<p>The routing module is where we use <kbd>passport</kbd> to handle user authentication. The first task is to install the required modules:</p>
<pre><strong>$ npm install passport@^0.4.x passport-local@1.x --save</strong></pre>
<p>The <kbd>passport</kbd> module gives us the authentication algorithms. To support different authentication mechanisms, the passport authors have developed several strategy implementations. The authentication mechanisms, or strategies, correspond to the various third-party services that support authentication, such as using OAuth2 to authenticate against services such as Facebook, Twitter, or GitHub.</p>
<p>The <kbd>LocalStrategy</kbd> authenticates solely using data stored local to the application, for example, our user authentication information service.</p>
<p>Let's start by creating the routing module, <kbd>routes/users.mjs</kbd>:</p>
<pre>import path from 'path';<br/>import util from 'util';<br/>import express from 'express'; <br/>import passport from 'passport'; <br/>import passportLocal from 'passport-local';<br/>const LocalStrategy = passportLocal.Strategy; <br/>import * as usersModel from '../models/users-superagent';<br/>import { sessionCookieName } from '../app';<br/><br/>export const router = express.Router();<br/><br/>import DBG from 'debug';<br/>const debug = DBG('notes:router-users'); <br/>const error = DBG('notes:error-users'); </pre>
<p>This brings in the modules we need for the <kbd>/users</kbd> router. This includes the two <kbd>passport</kbd> modules and the REST-based user authentication model. </p>
<p>In <kbd>app.mjs</kbd>, we will be adding <em>session</em> support so our users can log in and log out. That relies on storing a cookie in the browser, and the cookie name is found in this variable exported from <kbd>app.mjs</kbd>. We'll be using that cookie in a moment:</p>
<pre>export function initPassport(app) { <br/>  app.use(passport.initialize()); <br/>  app.use(passport.session()); <br/>}<br/> <br/>export function ensureAuthenticated(req, res, next) { <br/>  try {<br/>    // req.user is set by Passport in the deserialize function <br/>    if (req.user) next(); <br/>    else res.redirect('/users/login'); <br/>  } catch (e) { next(e); }<br/>}</pre>
<p>The <kbd>initPassport</kbd> function will be called from <kbd>app.mjs</kbd>, and it installs the <kbd>Passport</kbd> middleware into the Express configuration. We'll discuss the implications of this later when we get to <kbd>app.mjs</kbd> changes, but <kbd>Passport</kbd> uses sessions to detect whether this HTTP request is authenticated or not. It looks at every request coming into the application, looks for clues about whether this browser is logged in or not, and attaches data to the request object as <kbd>req.user</kbd>.</p>
<p>The <kbd>ensureAuthenticated</kbd> function will be used by other routing modules and is to be inserted into any route definition that requires an authenticated logged-in user. For example, editing or deleting a note requires the user to be logged in, and therefore the corresponding routes in <kbd>routes/notes.mjs</kbd> must use <kbd>ensureAuthenticated</kbd>. If the user is not logged in, this function redirects them to <kbd>/users/login</kbd> so that they can do so:</p>
<pre>outer.get('/login', function(req, res, next) { <br/>  try {<br/>    res.render('login', { title: "Login to Notes", user: req.user, }); <br/>  } catch (e) { next(e); }<br/>}); <br/> <br/>router.post('/login', <br/>  passport.authenticate('local', { <br/>    successRedirect: '/', // SUCCESS: Go to home page <br/>    failureRedirect: 'login', // FAIL: Go to /user/login <br/>  }) <br/>);<br/> </pre>
<p>Because this router is mounted on <kbd>/users</kbd>, all these routes will have <kbd>/user</kbd> prepended. The <kbd>/users/login</kbd> route simply shows a form requesting a username and password. When this form is submitted, we land in the second route declaration, with a <kbd>POST</kbd> on <kbd>/users/login</kbd>. If <kbd>passport</kbd> deems this a successful login attempt using <kbd>LocalStrategy</kbd>, then the browser is redirected to the home page. Otherwise, it is redirected to the <kbd>/users/login</kbd> page:</p>
<pre>router.get('/logout', function(req, res, next) { <br/>  try {<br/>    <strong>req.session.destroy();</strong><br/>    req.logout(); <br/>    <strong>res.clearCookie(sessionCookieName);</strong><br/> res.redirect('/'); <br/> } catch (e) { next(e); }<br/>});</pre>
<p>When the user requests to log out of Notes, they are to be sent to <kbd>/users/logout</kbd>. We'll be adding a button to the header template for this purpose. The <kbd>req.logout</kbd> function instructs Passport to erase their login credentials, and they are then redirected to the home page.</p>
<p>This function deviates from what's in the Passport documentation. There, we are told to simply call <kbd>req.logout</kbd>. But calling only that function sometimes results in the user not being logged out. It's necessary to destroy the session object, and to clear the cookie, in order to ensure that the user is logged out. The cookie name is defined in <kbd>app.mjs</kbd>, and we imported <kbd>sessionCookieName</kbd> for this function:</p>
<pre>passport.use(new LocalStrategy( <br/>  async (username, password, done) =&gt; { <br/>    try {<br/>      var check = await usersModel.userPasswordCheck(username, <br/>      password);<br/>      if (check.check) { <br/>        done(null, { id: check.username, username: check.username }); <br/>      } else { <br/>        done(null, false, check.message); <br/>      } <br/>    } catch (e) { done(e); }<br/>  } <br/>)); </pre>
<p>Here is where we define our implementation of <kbd>LocalStrategy</kbd>. In the callback function, we call <kbd>usersModel.userPasswordCheck</kbd>, which makes a REST call to the user authentication service. Remember that this performs the password check and then returns an object indicating whether they're logged in or not.</p>
<p>A successful login is indicated when <kbd>check.check</kbd> is <kbd>true</kbd>. For this case, we tell Passport to use an object containing the <kbd>username</kbd> in the session object. Otherwise, we have two ways to tell Passport that the login attempt was unsuccessful. In one case, we use <kbd>done(null, false)</kbd> to indicate an error logging in, and pass along the error message we were given. In the other case, we'll have captured an exception, and pass along that exception.</p>
<p>You'll notice that Passport uses a callback-style API. Passport provides a <kbd>done</kbd> function, and we are to call that function when we know what's what. While we use an <kbd>async</kbd> function to make a clean asynchronous call to the backend service, Passport doesn't know how to grok the Promise that would be returned. Therefore, we have to throw a <kbd>try/catch</kbd> around the function body to catch any thrown exception:</p>
<pre>passport.serializeUser(function(user, done) { <br/>  try {<br/>    done(null, user.username); <br/>  } catch (e) { done(e); }<br/>}); <br/> <br/>passport.deserializeUser(async (username, done) =&gt; { <br/>  try {<br/>    var user = await usersModel.find(username);<br/>    done(null, user);<br/>  } catch(e) { done(e); }<br/>}); </pre>
<p>The preceding functions take care of encoding and decoding authentication data for the session. All we need to attach to the session is the <kbd>username</kbd>, as we did in <kbd>serializeUser</kbd>. The <kbd>deserializeUser</kbd> object is called while processing an incoming HTTP request and is where we look up the user profile data. Passport will attach this to the request object.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Login/logout changes to app.js</h1>
                </header>
            
            <article>
                
<p>We have a few changes required in <kbd>app.mjs</kbd>, some of which we've already touched on. We did carefully isolate the Passport module dependencies to <kbd>routes/users.mjs</kbd>. The changes required in <kbd>app.mjs</kbd> support the code in <kbd>routes/users.mjs</kbd>.</p>
<p>It's now time to uncomment a line we told you to comment out way back in <a href="e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Your First Express Application. </em>The imports for the routing modules will now look as follows:</p>
<pre>import { router as index } from './routes/index';<br/>import { router as users, initPassport } from './routes/users';<br/>import { router as notes } from './routes/notes'; </pre>
<p>The User router supports the <kbd>/login</kbd> and <kbd>/logout</kbd> URL's as well as using <kbd>Passport</kbd> for authentication. We need to call <kbd>initPassport</kbd> for a little bit of initialization:</p>
<pre>import session from 'express-session';<br/>import sessionFileStore from 'session-file-store';<br/>const FileStore = sessionFileStore(session); <br/>export const sessionCookieName = 'notescookie.sid';</pre>
<p>Because <kbd>Passport</kbd> uses sessions, we need to enable session support in Express, and these modules do so. The <kbd>session-file-store</kbd> module saves our session data to disk so that we can kill and restart the application without losing sessions. It's also possible to save sessions to databases with appropriate modules. A filesystem session store is suitable only when all Notes instances are running on the same server computer. For a distributed deployment situation, you'll need to use a session store that runs on a network-wide service, such as a database.</p>
<p>We're defining <kbd>sessionCookieName</kbd> here so it can be used in multiple places. By default, <kbd>express-session</kbd> uses a cookie named <kbd>connect.sid</kbd> to store the session data. As a small measure of security, it's useful when there's a published default to use a different non-default value. Any time we use the default value, it's possible that an attacker might know a security flaw depending on that default. </p>
<p>Use the following command to install the modules:</p>
<pre><strong>$ npm install express-session@1.15.x session-file-store@1.2.x --save</strong></pre>
<p>Express Session support, including all the various Session Store implementations, is documented on its GitHub project page at <a href="https://github.com/expressjs/session"><span class="URLPACKT">https://github.com/expressjs/session</span></a>.<span class="URLPACKT"> </span></p>
<p>Add this in <kbd>app.mjs</kbd>:</p>
<pre>app.use(session({ 
  store: new FileStore({ path: "sessions" }), 
  secret: 'keyboard mouse',<br/>  resave: true,<br/>  saveUninitialized: true,<br/>  name: sessionCookieName<br/>})); <br/>initPassport(app);</pre>
<p>Here we initialize the session support. The field named <kbd>secret</kbd> is used to sign the session ID cookie. The session cookie is an encoded string that is encrypted in part using this secret. In the Express Session documentation, they suggest the string <kbd>keyboard cat</kbd> for the secret. But, in theory, what if Express has a vulnerability, such that knowing this secret can make it easier to break the session logic on your site? Hence, we chose a different string for the secret just to be a little different and perhaps a little more secure.</p>
<p>Similarly, the default cookie name used by <kbd>express-session</kbd> is <kbd>connect.sid</kbd>. Here's where we change the cookie name to a non-default name.</p>
<p>The <kbd>FileStore</kbd> will store its session data records in a directory named <kbd>sessions</kbd>. This directory will be auto-created as needed:</p>
<pre>app.use('/', index); 
app.use('/users', users); 
app.use('/notes', notes); </pre>
<p>The preceding are the three routers used in the Notes application. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Login/logout changes in routes/index.mjs</h1>
                </header>
            
            <article>
                
<p>This router module handles the home page. It does not require the user to be logged in, but we want to change the display a little if they are logged in:</p>
<pre>router.get('/', async (req, res, next) =&gt; {<br/>  try {<br/>    let keylist = await notes.keylist();<br/>    let keyPromises = keylist.map(key =&gt; { return notes.read(key) });<br/>    let notelist = await Promise.all(keyPromises);<br/>    res.render('index', { <br/>      title: 'Notes', notelist: notelist,<br/>      user: req.user ? req.user : undefined<br/>    });<br/>  } catch (e) { next(e); }<br/>});</pre>
<p>Remember that we ensured that <kbd>req.user</kbd> has the user profile data, which we did in <kbd>deserializeUser</kbd>. We simply check for this and make sure to add that data when rendering the views template.</p>
<p>We'll be making similar changes to most of the other route definitions. After that, we'll go over the changes to the view templates in which we use <kbd>req.user</kbd> to show the correct buttons on each page.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Login/logout changes required in routes/notes.mjs</h1>
                </header>
            
            <article>
                
<p>The changes required here are more significant, but still straightforward:</p>
<pre>import { ensureAuthenticated } from './users'; </pre>
<p>We need to use the <kbd>ensureAuthenticated</kbd> function to protect certain routes from being used by users who are not logged in. Notice how ES6 modules let us import just the function(s) we require. Since that function is in the user router module, we need to import it from there:</p>
<pre>router.get('/add', <strong>ensureAuthenticated</strong>, (req, res, next) =&gt; {<br/>    try {<br/>        res.render('noteedit', {<br/>            title: "Add a Note",<br/>            docreate: true, notekey: "",<br/>            <strong>user: req.user,</strong> note: undefined<br/>        });<br/>    } catch (e) { next(e); }<br/>});</pre>
<p>The first thing we added is to call <kbd>usersRouter.ensureAuthenticated</kbd> in the route definition. If the user is not logged in, they'll redirect to <kbd>/users/login</kbd>, thanks to that function.</p>
<p>Because we've ensured that the user is authenticated, we know that <kbd>req.user</kbd> will already have their profile information. We can then simply pass it to the view template.</p>
<p>For the other routes, we need to make similar changes:</p>
<pre>router.post('/save', <strong>ensureAuthenticated</strong>, (req, res, next) =&gt; { 
  .. 
}); </pre>
<p>The <kbd>/save</kbd> route requires only this change to call <kbd>ensureAuthenticated</kbd> to make sure that the user is logged in:</p>
<pre>router.get('/view', (req, res, next) =&gt; {<br/>    try {<br/>        var note = await notes.read(req.query.key);<br/>        res.render('noteview', {<br/>            title: note ? note.title : "",<br/>            notekey: req.query.key,<br/>            <strong>user: req.user ? req.user : undefined,</strong> <br/>            note: note<br/>        });<br/>    } catch (e) { next(e); }
}); </pre>
<p>For this route, we don't require the user to be logged in. We do need the user's profile information, if any, sent to the view template:</p>
<pre>router.get('/edit', <strong>ensureAuthenticated</strong>, (req, res, next) =&gt; { <br/>    try {<br/>        var note = await notes.read(req.query.key);<br/>        res.render('noteedit', {<br/>            title: note ? ("Edit " + note.title) : "Add a Note",<br/>            docreate: false,<br/>            notekey: req.query.key,<br/>            <strong>user: req.user ? req.user : undefined,</strong> <br/>            note: note<br/>        });<br/>    } catch (e) { next(e); }
}); 
router.get('/destroy', <strong>ensureAuthenticated</strong>, (req, res, next) =&gt; { <br/>    try {<br/>        var note = await notes.read(req.query.key);<br/>        res.render('notedestroy', {<br/>            title: note ? `Delete ${note.title}` : "",<br/>            notekey: req.query.key,<br/>            <strong>user: req.user ? req.user : undefined,</strong> <br/>            note: note<br/>        });<br/>    } catch (e) { next(e); }
}); 
router.post('/destroy/confirm', <strong>ensureAuthenticated</strong>, (req, res, next) =&gt; { 
  .. 
}); </pre>
<p>For these routes, we require the user to be logged in. In most cases, we need to send the <kbd>req.user</kbd> value to the view template.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">View template changes supporting login/logout</h1>
                </header>
            
            <article>
                
<p><span>So far, we've created a backend user authentication service, a REST module, to access that service, a router module to handle routes related to logging in and out of the website, and changes in </span><kbd>app.mjs</kbd><span> to use those modules. W</span>e're almost ready, but we've got a number of outstanding changes to make in the templates. We're passing the <kbd>req.user</kbd> object to every template because each one must be changed to accommodate whether the user is logged in or not.</p>
<p>In <kbd>partials/header.hbs</kbd>, make the following additions:</p>
<pre>...<br/>    {{#if user}}<br/>        &lt;div class="collapse navbar-collapse"   <br/>         id="navbarSupportedContent"&gt;<br/>            &lt;span class="navbar-text text-dark col"&gt;{{ title }}&lt;/span&gt;<br/>            &lt;a class="btn btn-dark col-auto" href="/users/logout"&gt;<br/>            Log Out &lt;span class="badge badge-light"&gt;{{ user.username }}<br/>         &lt;/span&gt;&lt;/a&gt;<br/>            &lt;a class="nav-item nav-link btn btn-dark col-auto" <br/>         href='/notes/add'&gt;<br/>                                    ADD Note&lt;/a&gt;<br/>        &lt;/div&gt;<br/>    {{else}}<br/>        &lt;div class="collapse navbar-collapse" id="navbarLogIn"&gt;<br/>            &lt;a class="btn btn-primary" href="/users/login"&gt;Log in&lt;/a&gt;<br/>        &lt;/div&gt;<br/>    {{/if}}<br/>...</pre>
<p>What we're doing here is controlling which buttons to display at the top of the screen depending on whether the user is logged in or not. The earlier changes ensure that the <kbd>user</kbd> variable will be <kbd>undefined</kbd> if the user is logged out, otherwise it will have the user profile object. Therefore, it's sufficient to check the <kbd>user</kbd> variable as shown here to render different user interface elements.</p>
<p>A logged-out user doesn't get the <span class="packt_screen">ADD Note</span> button, and gets a <span class="packt_screen">L</span><span class="packt_screen">og in</span> button. Otherwise, the user gets an <span class="packt_screen">ADD Note</span> button and a <span class="packt_screen">Log Out</span> button. The <span class="packt_screen">Log in </span>button takes the user to <kbd>/users/login</kbd>, while the <span class="packt_screen">Log Out</span> button takes them to <kbd>/users/logout</kbd>. Both of those are handled in <kbd>routes/users.js</kbd>, and perform the expected function.</p>
<p>The <span class="packt_screen">Log Out</span> button has a Bootstrap badge component displaying the username. This adds a little visual splotch, in which we'll put the username that's logged in. As we'll see later, it will serve as a visual cue to the user as to their identity.</p>
<p>We need to create <kbd>views/login.hbs</kbd>:</p>
<pre>&lt;div class="container-fluid"&gt;<br/>  &lt;div class="row"&gt;<br/>    &lt;div class="col-12 btn-group-vertical" role="group"&gt;<br/><br/>        &lt;form method='POST' action='/users/login'&gt; <br/>        &lt;div class="form-group"&gt; <br/>        &lt;label for="username"&gt;User name:&lt;/label&gt; <br/>        &lt;input class="form-control" type='text' id='username' <br/>               name='username' value='' placeholder='User Name'/&gt; <br/>        &lt;/div&gt; <br/>        &lt;div class="form-group"&gt; <br/>        &lt;label for="password"&gt;Password:&lt;/label&gt; <br/>        &lt;input class="form-control" type='password' id='password' <br/>               name='password' value='' placeholder='Password'/&gt; <br/>        &lt;/div&gt; <br/>        &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; <br/>        &lt;/form&gt; <br/><br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p>This is a simple form decorated with Bootstrap goodness to ask for the username and password. When submitted, it creates a <kbd>POST</kbd> request to <kbd>/users/login</kbd>, which invokes the desired handler to verify the login request. The handler for that URL will start the Passport's process to decide whether the user is authenticated or not.</p>
<p>In <kbd>views/notedestroy.hbs</kbd>, we want to display a message if the user is not logged in. Normally, the form to cause the note to be deleted is displayed, but if the user is not logged in, we want to explain the situation:</p>
<pre>&lt;form method='POST' action='/notes/destroy/confirm'&gt;<br/>&lt;div class="container-fluid"&gt;<br/>    {{#if user}}<br/>    &lt;input type='hidden' name='notekey' value='{{#if note}}{{notekey}}{{/if}}'&gt;<br/>    &lt;p class="form-text"&gt;Delete {{note.title}}?&lt;/p&gt;<br/><br/>    &lt;div class="btn-group"&gt;<br/>        &lt;button type="submit" value='DELETE' <br/>                class="btn btn-outline-dark"&gt;DELETE&lt;/button&gt;<br/>        &lt;a class="btn btn-outline-dark" <br/>            href="/notes/view?key={{#if note}}{{notekey}}{{/if}}" <br/>            role="button"&gt;Cancel&lt;/a&gt;<br/>    &lt;/div&gt;<br/>    {{else}}<br/>    {{&gt; not-logged-in }}<br/>    {{/if}}<br/>&lt;/div&gt;<br/>&lt;/form&gt;</pre>
<p>That's straightforward; if the user is logged in, display the form, otherwise display the message in <kbd>partials/not-logged-in.hbs</kbd>. We determine our approach based on the <kbd>user</kbd> variable.</p>
<p>We could put something like this in <kbd>partials/not-logged-in.hbs</kbd>:</p>
<div>
<pre><span>&lt;</span><span>div</span><span> </span><span>class=</span><span>"jumbotron"</span><span>&gt;</span><span> <br/></span><span> </span><span>&lt;</span><span>h1</span><span>&gt;</span><span>Not Logged In</span><span>&lt;/</span><span>h1</span><span>&gt;</span><span> <br/></span><span> </span><span>&lt;</span><span>p</span><span>&gt;</span><span>You are required to be logged in for this action, but you are not. <br/> You should not see this message. It's a bug if this message appears.   <br/></span><span> &lt;/</span><span>p</span><span>&gt;</span><span> <br/></span><span> </span><span>&lt;</span><span>p</span><span>&gt;&lt;</span><span>a</span><span> </span><span>class=</span><span>"btn btn-primary"</span><span> </span><span>href=</span><span>"/users/login"</span><span>&gt;</span><span>Log in</span><span>&lt;/</span><span>a</span><span>&gt;&lt;/</span><span>p</span><span>&gt;</span><span> <br/></span><span>&lt;/</span><span>div</span><span>&gt;</span></pre></div>
<p>In <kbd>views/noteedit.hbs</kbd>, we need a similar change:</p>
<pre>.. 
&lt;div class="row"&gt;&lt;div class="col-xs-12"&gt; 
{{#if user}}
.. 
<strong>{{else}}</strong><br/><strong>{{&gt; not-logged-in }}</strong><br/><strong>{{/if}}</strong>
&lt;/div&gt;&lt;/div&gt; 
.. </pre>
<p>That is, at the bottom we add a segment that, for non-logged-in users, pulls in the <kbd>not-logged-in</kbd> partial.</p>
<p>The <strong>Bootstrap jumbotron</strong> component makes a nice and large text display that stands out nicely, and will catch the viewer's attention. However, the user should never see this because each of those templates is used only when we've preverified that the user is logged in.</p>
<p>A message such as this is useful as a check against bugs in your code. Suppose that we slipped up and failed to properly ensure that these forms were displayed only to logged-in users. Suppose that we had other bugs that didn't check the form submission to ensure it's requested only by a logged-in user. Fixing the template in this way is another layer of prevention against displaying forms to users who are not allowed to use that functionality.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running the Notes application with user authentication</h1>
                </header>
            
            <article>
                
<p>Now we're ready to run the Notes application and try our hand at logging in and out.</p>
<p>We need to change the scripts section of <kbd>package.json</kbd> as follows:</p>
<pre>"scripts": {<br/>    "start": "DEBUG=notes:* SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 node --experimental-modules ./bin/www.mjs",<br/>    "dl-minty": "mkdir -p minty &amp;&amp; npm run dl-minty-css &amp;&amp; npm run dl-<br/>    minty-min-css",<br/>    "dl-minty-css": "wget https://bootswatch.com/4/minty/bootstrap.css <br/>    -O minty/bootstrap.css",<br/>    "dl-minty-min-css": "wget https://bootswatch.com/4/minty/bootstrap.min.css -O minty/bootstrap.min.css"<br/>},</pre>
<p>In the previous chapters, we built up quite a few combinations of models and databases for running the Notes application. This leaves us with one, configured to use the Sequelize model for Notes, using the SQLite3 database, and to use the new user authentication service that we wrote earlier. We can simplify the <kbd>scripts</kbd> section by deleting those other configurations. All the other Notes data models are still available just by setting the environment variables appropriately.</p>
<p>The <kbd>USER_SERVICE_URL</kbd> needs to match the port number that we designated for that service.</p>
<p>In one window, start the user authentication service as follows:</p>
<pre><strong>$ cd users
$ npm start
    
&gt; user-auth-server@0.0.1 start /Users/david/chap08/users
&gt; DEBUG=users:* PORT=3333 SEQUELIZE_CONNECT=sequelize-sqlite.yaml node user-server
    
  users:server User-Auth-Service listening at http://127.0.0.1:3333  </strong><br/><strong>  +0ms</strong></pre>
<p>Then, in another window, start the Notes application:</p>
<pre><strong>$ cd notes
$ DEBUG=notes:* npm start
    
&gt; notes@0.0.0 start /Users/david/chap08/notes
&gt; SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=models/notes-sequelize USERS_MODEL=models/users-rest USER_SERVICE_URL=http://localhost:3333 node ./bin/www
    
  notes:server Listening on port 3000 +0ms</strong></pre>
<p>You'll be greeted with the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/e80c39ba-4a49-467f-a29b-2c538f7b7225.png" style="width:40.33em;height:12.92em;" width="802" height="257"/></div>
<p>Notice the new button, <span class="packt_screen">Log in</span>, and the lack of an <span class="packt_screen">ADD Note</span> button. We're not logged in, and therefore <kbd>partials/header.hbs</kbd> is rigged to show only the <span class="packt_screen">Log in</span> button.</p>
<p>Click on the <span class="packt_screen">Log in</span> button, and you will see the login screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0713ca75-9e6f-4d2c-9b5d-3ca5e5178d45.png" style="width:41.25em;height:18.83em;" width="802" height="366"/></div>
<p>This is our login form from <kbd>views/login.hbs</kbd>. You can now log in, create a note or three, and you might end up with the following on the home page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8a54e0a3-df46-44ba-ab10-925f5be169fd.png" style="width:43.75em;height:14.92em;" width="802" height="273"/></div>
<p>You now have both <span class="packt_screen">Log Out</span> and <span class="packt_screen">ADD Note</span> buttons.</p>
<p>You'll notice that the <span class="packt_screen">Log Out</span> button has the username (<span class="packt_screen">me</span>) shown. After some thought and consideration, this seemed the most compact way to show whether the user is logged in or not, and which user is logged in. This might drive the user experience team nuts, and you won't know whether this user interfaces design works until it's tested with users, but it's good enough for our purpose at the moment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Twitter login support for the Notes application</h1>
                </header>
            
            <article>
                
<p>If you want your application to hit the big time, it's a great idea to allow users to register using third-party credentials. Websites all over the internet allow you to log in using Facebook, Twitter, or accounts from other services. Doing so removes hurdles to prospective users signing up for your service. Passport makes it extremely easy to do this.</p>
<p>Supporting Twitter requires installing <strong>TwitterStrategy</strong>, registering a new application with Twitter, and adding a couple of routes into <kbd>routes/user.mjs</kbd> and a small change in <kbd>partials/header.hbs</kbd>. Integrating other third-party services requires similar steps.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Registering an application with Twitter</h1>
                </header>
            
            <article>
                
<p>Twitter, as with every other third-party service, uses OAuth to handle authentication and requires an authentication key to write software using their API. It's their service, so you have to play by their rules, of course.</p>
<p>To register a new application with Twitter, go to <a href="https://apps.twitter.com/"><span class="URLPACKT">https://apps.twitter.com/</span></a>. <span>Then you click on the </span><em><span class="packt_screen">Create New App</span></em><span> button. Since we haven't deployed the</span> Notes <span>application to a regular server and, more importantly, there isn't a valid domain name for the application, we have to give Twitter the configuration required for testing on our local laptop.</span></p>
<p><span>Every service offering OAuth2 authentication has an administrative backend for registering new applications. The common purpose is to describe the application to the service so that the service can correctly recognize the application when requests are made using the authentication tokens. The normal situation is that the application is deployed to a regular server, and is accessed through a domain name such as </span><kbd>MyNotes.info</kbd><span>.  We've done neither as of this moment.</span></p>
<p>At the time of writing, there are four pieces of information requested by the Twitter sign-up process:</p>
<ul>
<li><strong>Name</strong>: This is the application name, and it can be anything you like. It would be good form to use test in the name in case Twitter's staff decide to do some validation.</li>
<li><strong>Description</strong>: Descriptive phrase, and again it can be anything you like. Again, it would be good form to, at this time, describe it as a test application.</li>
<li><strong>Website</strong>: This would be your desired domain name. Here, the help text helpfully suggests <em>If you don't have a URL yet, just put a placeholder here but remember to change it later</em>.</li>
<li><strong>Callback URL</strong>: This is the URL to return to after successful authentication. Since we don't have a public URL to supply, this is where we specify a value referring to your laptop. It's been found that<span> </span><kbd>http://localhost:3000</kbd><span> </span>works just fine. m<span>acOS users have another option because of the </span><kbd>.local</kbd><span> domain name, which is automatically assigned to their laptop. All along, we could have used a URL similar to this to access the</span> Notes <span>application at </span><kbd>http://MacBook-Pro-2.local:3000/</kbd><span>. </span></li>
</ul>
<p>It was found by attempting this procedure with different services that Facebook (and other) services are not lenient about test applications hosted on laptops. At least Twitter is keen for developers to configure a test application on their laptop. Passport's other OAuth-based strategies will work similarly enough to Twitter, so the knowledge we're gaining will transfer to those other authentication strategies.</p>
<p>The last thing to notice is the extremely sensitive nature of the authentication keys. It's bad form to check these into a source code repository or otherwise put them in a place where anybody can access the key.</p>
<p><span>Twitter does change the signup page from time to time, but it should look something like the following:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f7bd3f21-c2c0-470f-b5df-27ac96f8ae4f.png" style="width:52.83em;height:41.25em;" width="1062" height="830"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing TwitterStrategy</h1>
                </header>
            
            <article>
                
<p>As with many web applications, we have decided to allow our users to log in using Twitter credentials. The OAuth2 protocol is widely used for this purpose and is the basis for authenticating on one website using credentials maintained by another website.</p>
<p>The application registration process you just followed at <kbd>apps.twitter.com</kbd> generated for you a pair of API keys, a consumer key, and, consumer secret. These keys are part of the OAuth protocol, and will be supplied by any OAuth service you register with, and the keys should be treated with the utmost care. Think of them as the username and password your service uses to access the OAuth-based service (Twitter et al). The more people who can see these keys, the more likely a miscreant can see them and then cause trouble. Anybody with those secrets can write access the service API as if they are you.</p>
<p>Dozens of Strategy packages for various third-party services are available within the Passport ecosystem. Let's install the package required to use <kbd>TwitterStrategy</kbd>:</p>
<pre><strong>$ npm install passport-twitter@1.x --save</strong></pre>
<p>In <kbd>routes/users.mjs</kbd>, let's start making some changes:</p>
<pre>import passportTwitter from 'passport-twitter';<br/>const TwitterStrategy = passportTwitter.Strategy; </pre>
<p>To bring in the package we just installed, add the following:</p>
<pre>const twittercallback = process.env.TWITTER_CALLBACK_HOST<br/>    ? process.env.TWITTER_CALLBACK_HOST<br/>    : "http://localhost:3000";<br/><br/>passport.use(new TwitterStrategy({ <br/>  consumerKey: process.env.TWITTER_CONSUMER_KEY, <br/>  consumerSecret: process.env.TWITTER_CONSUMER_SECRET, <br/>  callbackURL: `${twittercallback}/users/auth/twitter/callback` <br/>}, <br/>async function(token, tokenSecret, profile, done) { <br/>  try {<br/>    done(null, await usersModel.findOrCreate({ <br/>      id: profile.username, username: profile.username, password: "", <br/>      provider: profile.provider, familyName: profile.displayName, <br/>      givenName: "", middleName: "", <br/>      photos: profile.photos, emails: profile.emails <br/>    }));<br/>  } catch(err) { done(err); }<br/>})); </pre>
<p>This registers <kbd>TwitterStrategy</kbd> with <kbd>passport</kbd>, arranging to call the user authentication service as users register with the Notes application. This <kbd>callback</kbd> function is called when users successfully authenticate using Twitter.</p>
<p>We defined the <kbd>usersModel.findOrCreate</kbd> function specifically to handle user registration from third-party services such as Twitter. Its task is to look for the user described in the profile object and, if that user does not exist, to autocreate that user account in Notes.</p>
<div class="packt_infobox"><span>The </span><kbd>consumerKey</kbd><span> and </span><kbd>consumerSecret</kbd><span> values are supplied by </span>Twitter,<span> after you've registered your application. These secrets are used in the OAuth protocol as proof of identity to Twitter.</span></div>
<p><span>The</span><span> </span><kbd>callbackURL</kbd><span> </span><span>setting in the <kbd>TwitterStrategy</kbd> configuration is a holdover from Twitter's OAuth1-based API implementation. In OAuth1, the callback URL was passed as part of the OAuth request. Since </span><span><kbd>TwitterStrategy</kbd> uses Twitter's OAuth1 service, we have to supply the URL here. We'll see in a moment where that URL is implemented in Notes.</span></p>
<p>The <kbd>callbackURL</kbd>, <kbd>consumerKey</kbd>, and <kbd>consumerSecret</kbd> are all injected using environment variables. It is tempting, because of the convenience, to just put those keys in the source code. But, how widely distributed is your source code?  In the Slack API documentation (<a href="https://api.slack.com/docs/oauth-safety">https://api.slack.com/docs/oauth-safety</a>), we're warned <span><em>Do not distribute client secrets in email, distributed native applications, client-side JavaScript, or public code repositories</em>.</span></p>
<p>In <a href="7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml">Chapter 10</a>,<em> Deploying Node.js Applications</em>, we'll put these keys into a Dockerfile. That's not entirely secure because the Dockerfile will also be committed to a source repository somewhere.</p>
<p>It was found while debugging that the profile object supplied by the <kbd>TwitterStrategy</kbd> did not match the documentation on the <kbd>passport</kbd> website. Therefore, we have mapped the object actually supplied by <kbd>passport</kbd> into something that Notes can use:</p>
<pre>router.get('/auth/twitter', passport.authenticate('twitter')); </pre>
<p>To start the user logging in with Twitter, we'll send them to this URL. Remember that this URL is really <kbd>/users/auth/twitter</kbd>, and, in the templates, we'll have to use that URL. When this is called, the passport middleware starts the user authentication and registration process using <kbd>TwitterStrategy</kbd>.</p>
<p>Once the user's browser visits this URL, the OAuth dance begins. It's called a dance because the OAuth protocol involves carefully designed redirects between several websites. Passport sends the browser over to the correct URL at Twitter, where Twitter asks the user whether they agree to authenticate using Twitter, and then Twitter redirects the user back to your callback URL. Along the way, specific tokens are passed back and forth in a very carefully designed dance between websites.</p>
<p>Once the OAuth dance concludes, the browser lands here:</p>
<pre>router.get('/auth/twitter/callback', 
  passport.authenticate('twitter', { successRedirect: '/', 
                       failureRedirect: '/users/login' })); </pre>
<p>This route handles the callback URL, and it corresponds to the <kbd>callbackURL</kbd> setting configured earlier. Depending on whether it indicates a successful registration or not, passport will redirect the browser to either the home page or back to the <kbd>/users/login</kbd> page. </p>
<p>Because <kbd>router</kbd> is mounted on <kbd>/user</kbd>, this URL is actually <kbd>/user/auth/twitter/callback</kbd>. Therefore, the full URL to use in configuring the <kbd>TwitterStrategy</kbd>, and to supply to Twitter, is <kbd>http://localhost:3000<span>/user/auth/twitter/callback</span></kbd></p>
<p>In the process of handling the callback URL, Passport will invoke the callback function shown earlier. Because our callback uses the <kbd>usersModel.findOrCreate</kbd> function, the user will be automatically registered if necessary.</p>
<p>We're almost ready, but we need to make a couple of small changes elsewhere in Notes.</p>
<p>In <kbd>partials/header.hbs</kbd>, make the following changes to the code:</p>
<pre>...<br/>{{else}}<br/>&lt;div class="collapse navbar-collapse" id="navbarLogIn"&gt;<br/>    &lt;span class="navbar-text text-dark col"&gt;&lt;/span&gt;<br/>    &lt;a class="nav-item nav-link btn btn-dark col-auto" href="/users/login"&gt;<br/>                                Log in&lt;/a&gt;<br/>    &lt;a class="nav-item nav-link btn btn-dark col-auto" href="/users/auth/twitter"&gt;<br/>    &lt;img width="15px"<br/>         src="/assets/vendor/twitter/Twitter_Social_Icon_Rounded_Square_Color.png"/&gt;<br/>         Log in with Twitter&lt;/a&gt; <br/>&lt;/div&gt;<br/>{{/if}}</pre>
<p>This adds a new button that, when clicked, takes the user to <kbd>/users/auth/twitter</kbd>, which, of course, kicks off the Twitter authentication process. </p>
<p>The image being used is from the official Twitter brand assets page at <a href="https://about.twitter.com/company/brand-assets"><span class="URLPACKT">https://about.twitter.com/company/brand-assets</span></a>. Twitter recommends using these branding assets for a consistent look across all services using Twitter. Download the whole set and then pick one you like. For the URL shown here, place the chosen image in a directory named <kbd>public/assets/vendor/twitter</kbd>. Notice that we force the size to be small enough for the navigation bar.</p>
<p>With these changes, we're ready to try logging in with Twitter.</p>
<p>Start the Notes application server as done previously:</p>
<pre><strong>$ npm start</strong><br/><br/><strong>&gt; notes@0.0.0 start /Users/David/chap08/notes</strong><br/><strong>&gt; DEBUG=notes:* SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 node --experimental-modules ./bin/www.mjs</strong><br/><br/><strong>(node:42095) ExperimentalWarning: The ESM module loader is experimental.</strong><br/><strong>  notes:server-debug Listening on port 3000 +0ms</strong></pre>
<p>Then use a browser to visit <kbd>http://localhost:3000</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7c4b072f-7f67-4306-91be-d8b3940a897c.png" style="width:44.08em;height:13.50em;" width="802" height="246"/></div>
<p>Notice the new button. It looks about right, thanks to having used the official Twitter branding image. The button is a little large, so maybe you want to consult a designer. Obviously, a different design is required if you're going to support dozens of authentication services.</p>
<p>Clicking on this button takes the browser to <kbd>/users/auth/twitter</kbd>, which starts Passport running the OAuth2 protocol transactions necessary to authenticate. And then, once you're logged in with Twitter, you'll see something like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/a13f58f3-02dd-4107-b131-241723950d75.png" style="width:41.33em;height:13.25em;" width="802" height="257"/></div>
<p>We're now logged in, and notice that our Notes username is the same as our Twitter username. You can browse around the application and create, edit, or delete notes. In fact, you can do this to any note you like, even ones created by others. That's because we did not create any sort of access control or permissions system, and therefore every user has complete access to every note. That's a feature to put on the backlog.</p>
<p>By using multiple browsers or computers, you can simultaneously log in as different users, one user per browser.</p>
<p>You can run multiple instances of the Notes application by doing what we did earlier:</p>
<pre>  "scripts": { 
    "start": "SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=models/notes-sequelize USERS_MODEL=models/users-rest USER_SERVICE_URL=http://localhost:3333 node ./bin/www", 
    "start-server1": "SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=models/notes-sequelize USERS_MODEL=models/users-rest USER_SERVICE_URL=http://localhost:3333 PORT=3000 node ./bin/www", 
    "start-server2": "SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=models/notes-sequelize USERS_MODEL=models/users-rest USER_SERVICE_URL=http://localhost:3333 PORT=3002 node ./bin/www", <br/>    "dl-minty": "mkdir -p minty &amp;&amp; npm run dl-minty-css &amp;&amp; npm run dl-minty-min-css",<br/>    "dl-minty-css": "wget https://bootswatch.com/4/minty/bootstrap.css -O minty/bootstrap.css",<br/>    "dl-minty-min-css": "wget https://bootswatch.com/4/minty/bootstrap.min.css -O minty/bootstrap.min.css"
  },</pre>
<p>Then, in one command window, run the following command:</p>
<pre><strong>$ npm run start-server1</strong><br/><br/><strong>&gt; notes@0.0.0 start-server1 /Users/David/chap08/notes</strong><br/><strong>&gt; DEBUG=notes:* SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 PORT=3000 node --experimental-modules ./bin/www.mjs</strong><br/><br/><strong>(node:43591) ExperimentalWarning: The ESM module loader is experimental.</strong><br/><strong>  notes:server-debug Listening on port 3000 +0ms</strong></pre>
<p>In another command window, run the following command:</p>
<pre><strong>$ npm run start-server2</strong><br/><br/><strong>&gt; notes@0.0.0 start-server2 /Users/David/chap08/notes</strong><br/><strong>&gt; DEBUG=notes:* SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 PORT=3002 node --experimental-modules ./bin/www.mjs</strong><br/><br/><strong>(node:43755) ExperimentalWarning: The ESM module loader is experimental.</strong><br/><strong>  notes:server-debug Listening on port 3002 +0ms</strong></pre>
<p>As previously, this starts two instances of the Notes server, each with a different value in the <kbd>PORT</kbd> environment variable. In this case, each instance will use the same user authentication service. As shown here, you'll be able to visit the two instances at <kbd>http://localhost:3000</kbd> and <kbd>http://localhost:3002</kbd>. And, as previously, you'll be able to start and stop the servers as you wish, see the same notes in each, and see that the notes are retained after restarting the server.</p>
<p>Another thing to try is to fiddle with the <strong>session store</strong>. Our session data is being stored in the <kbd>sessions</kbd> directory. These are just files in the filesystem, and we can take a look:</p>
<pre>$ ls -l sessions/<br/>total 32<br/>-rw-r--r-- 1 david wheel 139 Jan 25 19:28 -QOS7eX8ZBAfmK9CCV8Xj8v-3DVEtaLK.json<br/>-rw-r--r-- 1 david wheel 139 Jan 25 21:30 T7VT4xt3_e9BiU49OMC6RjbJi6xB7VqG.json<br/>-rw-r--r-- 1 david wheel 223 Jan 25 19:27 ermh-7ijiqY7XXMnA6zPzJvsvsWUghWm.json<br/>-rw-r--r-- 1 david wheel 139 Jan 25 21:23 uKzkXKuJ8uMN_ROEfaRSmvPU7NmBc3md.json
$ cat sessions/T7VT4xt3_e9BiU49OMC6RjbJi6xB7VqG.json <br/>{"cookie":{"originalMaxAge":null,"expires":null,"httpOnly":true,"path":"/"},"__lastAccess":1516944652270,"passport":{"user":"7genblogger"}}</pre>
<p>This is after logging in using a Twitter account; you can see that the Twitter account name is stored here in the session data.</p>
<p>What if you want to clear a session? It's just a file in the filesystem. Deleting the session file erases the session, and the user's browser will be forcefully logged out.</p>
<p>The session will time out if the user leaves their browser idle for long enough. One of the <kbd>session-file-store</kbd> options, <kbd>ttl</kbd>, controls the timeout period, which defaults to 3,600 seconds (an hour). With a timed-out session, the application reverts to a logged-out state.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securely keeping secrets and passwords</h1>
                </header>
            
            <article>
                
<p>We've cautioned several times about the importance of safely handling user identification information. The intention to safely handle that data is one thing, but it is important to follow through and actually do so. While we're using a few good practices so far, as it stands, the Notes application would not withstand any kind of security audit:</p>
<ul>
<li>User passwords are kept in clear text in the database</li>
<li>The authentication tokens for Twitter <em>et al</em>, are in the source code in clear text</li>
<li>The authentication service API key is not a cryptographically secure anything, it's just a cleartext UUID</li>
</ul>
<p>If you don't recognize the phrase clear text, it simply means unencrypted. Anyone could read the text of user passwords or the authentication tokens. It's best to keep both encrypted to avoid information leakage.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Notes application stack</h1>
                </header>
            
            <article>
                
<p>Did you notice earlier when we said run the Notes application stack? It's time to explain to the marketing team what's meant by that phrase. They'll perhaps need to put an architecture diagram on marketing brochures and the like. It's also useful for developers like us to take a step back and draw a picture of what we've created, or are planning to create. </p>
<p>Here's the sort of diagram that an engineer might draw to show the marketing team the system design. The marketing team will, of course, hire a graphics artist to clean it up:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/10d38f27-e686-4a9b-a61e-2039a23497d8.png" style="width:27.00em;height:29.50em;" width="677" height="740"/></div>
<p>The box labeled Notes Application is the public-facing code implemented by the templates and the router modules. As currently configured, it's visible from our laptop on port 3000. It can use one of several data storage services. It communicates with the backend <strong>User Authentication Service</strong> over port 3333 (as currently configured).</p>
<p>In <a href="7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml">Chapter 10</a>,<em> Deploying Node.js Applications,</em> we'll be expanding this picture a bit as we learn how to deploy on a real server.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>You've covered a lot of ground in this chapter, looking at not only user authentication in Express applications, but also microservice development.</p>
<p>Specifically, you covered session management in Express, using Passport for user authentication, including Twitter/OAuth, using router middleware to limit access, creating a REST service with Restify, and when to create a microservice.</p>
<p>In the next chapter, we'll take the <em>Notes</em> application to a new level-semi-real-time communication between application users. To do this, we'll write some browser-side JavaScript and explore how the <kbd>Socket.io</kbd> package can let us send messages between users.</p>


            </article>

            
        </section>
    </div>



  </body></html>