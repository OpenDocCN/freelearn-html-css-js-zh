<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with ECMAScript</h1>
                </header>
            
            <article>
                
<p><span><strong>ECMAScript 2017</strong></span> (<span><strong>ES8</strong></span>) <span>was released at the end of June 2017 by </span><strong>Technical Committee number 39</strong> (<strong>TC39</strong>). It's part of ECMA, the institution that standardizes the JavaScript language under the ECMAScript specification. Currently, the standard aims to publish a new ES specification version once a year. ES6 was published in 2015 and ES7 was published in 2016. A lot changed when ES6 was released<span> (arrow functions, classes, generators, module loaders, async programming, and so on)</span><span> and</span> even more interesting stuff <span>keeps happening, as time goes by.</span></p>
<p>In this chapter, we'll be starting off with the fundamentals of JavaScript, starting off with ES6 basics and heading towards ES8 stuff. Furthermore, we'll be taking a look at some interesting aspects of traditional JS such as closures, and some new ones such as arrow functions.</p>
<p>As an autodidact, I highly recommend not only reading this book, but also trying to apply whatever you're learning here in some small but interesting projects. This will help you to retain a lot of stuff effortlessly.</p>
<p><span>In this chapter, we'll be covering:</span></p>
<ul>
<li>Creating block-scoped variables using the <kbd>let</kbd> keyword</li>
<li>Creating constant variables using the <kbd>const</kbd> keyword</li>
<li>The spread operator and the rest parameter</li>
<li>Hoisting</li>
<li>Extracting data from iterables and objects using a destructuring assignment</li>
<li>Arrow functions</li>
<li>Closures and how to deal with them</li>
<li>Use of semicolons in JavaScript</li>
<li>Benchmarking <kbd>let</kbd> versus <kbd>var</kbd> versus <kbd>const</kbd></li>
<li>The new syntaxes for creating object properties</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The let keyword</h1>
                </header>
            
            <article>
                
<p>The <kbd>let</kbd> keyword is used to declare a block-scoped variable (more on this later), optionally initializing it to a value. Programmers who come from a different programming language background, but are new to JavaScript, often end up writing error-prone JavaScript programs, believing that the JavaScript variables created using the traditional<span> </span><kbd>var</kbd><span> </span>keyword are block-scoped. Almost every popular programming language has the same set of rules when it comes to the variable scopes, but JavaScript acts a bit differently due to a lack of block-scoped<span> </span>variables. Due to the fact that JavaScript variables are not block-scoped, there are chances of memory leaks and JavaScript programs are harder to read and debug.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring function-scoped variables</h1>
                </header>
            
            <article>
                
<p>The JavaScript variables that are declared using the<span> </span><kbd>var</kbd><span> </span>keyword are called<span> </span><strong>function-scoped<span> </span>variables</strong>. Function-scoped<span> </span>variables are accessible globally to the script, that is, throughout the<span> </span>script,<span> </span>if declared outside a function. Similarly, if the function scoped variables are declared inside a function, then they become accessible throughout the function, but not outside the function. Let's take a look at an example:</p>
<pre> var a = 12; // accessible everywhere<br/> function myFunction() {<br/>   console.log(a); // alerts 12<br/>   var b = 13;<br/>   if(true) {<br/>     var c = 14; // this is also accessible throughout the function!<br/>     alert(b); // alerts 13<br/>   }<br/>   alert(c); // alerts 14<br/> }<br/> myFunction();<br/> alert(b); // alerts undefined</pre>
<p>Clearly, variables initialized inside a function are restricted inside that function only. However, variables declared in a block scope (that is, inside curly braces <kbd>{ }</kbd> that is not a function (that is, <kbd>if</kbd> statements)) can be used outside those blocks as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring block-scoped variables</h1>
                </header>
            
            <article>
                
<p>Variables that are declared using the <kbd>let</kbd> keyword are called <strong>block-scoped variables</strong>. Block-scoped variables behave the same way as function-scoped variables when declared outside a function, that is, they are accessible globally. But when block-scoped variables are declared inside a block, they are accessible inside the block that they are defined in (and also any sub-blocks) but not outside the block:</p>
<pre> let a = 12; // accessible everywhere<br/> function myFunction() {<br/>   console.log(a); // alerts 12<br/>   let b = 13;<br/>   if(true) {<br/>     let c = 14; // this is <strong>NOT</strong> accessible throughout the function!<br/>     alert(b); // alerts 13<br/>   }<br/>   <strong>alert(c); // alerts undefined</strong><br/> }<br/> myFunction();<br/> alert(b); // alerts undefined</pre>
<p>Study the code carefully. This is the same as the preceding example, but with  <kbd>var</kbd> replaced by <kbd>let</kbd> everywhere. Observe how C alerts <kbd>undefined</kbd> now (<kbd>let</kbd> makes it inaccessible outside <kbd>if {}</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Re-declaring variables</h1>
                </header>
            
            <article>
                
<p>When you declare a variable using the <kbd>var</kbd> keyword that is already declared using  the <kbd>var</kbd> keyword (in the same scope) then it's <strong>overwritten</strong>. Consider this example:</p>
<pre>var a = 0;<br/>var a = 1;<br/>alert(a); // alerts 1<br/>function myFunction() {<br/> var b = 2;<br/> var b = 3;<br/> alert(b); // alerts 3<br/>}<br/>myFunction();</pre>
<p>The result is as expected. But the variables created using the <kbd>let</kbd> keyword don't behave in the same way.</p>
<p>When you declare a variable using the <kbd>let</kbd> keyword that is already declared using the <kbd>let</kbd> keyword in the same scope, then it throws a <strong>SyntaxError exception</strong>. Consider this example:</p>
<pre>let a = 0;<br/>let a = 1; // SyntaxError<br/>function myFunction() {<br/> let b = 2;<br/> let b = 3; // SyntaxError<br/> if(true) {<br/>    let c = 4;<br/>    let c = 5; // SyntaxError<br/> }<br/>}<br/>myFunction();</pre>
<p>When you declare a variable with a name that's already accessible in a function (or inner function), or is a sub-block using <kbd>var</kbd> or the <kbd>let</kbd> keyword respectively, then it's a different variable. Here, is an example this shows the behavior:</p>
<pre> var a = 1;<br/> let b = 2;<br/> function myFunction() {<br/>   var a = 3; // different variable<br/>   let b = 4; // different variable<br/>   if(true) {<br/>     var a = 5; // overwritten<br/>     let b = 6; // different variable<br/>     console.log(a); // 5<br/>     console.log(b); // 6<br/> }<br/>     console.log(a); // 5<br/>     console.log(b); // 4<br/> }<br/> myFunction();<br/> console.log(a);<br/> console.log(b);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Closures and let keyword</h1>
                </header>
            
            <article>
                
<p>Congratulations on making it to here! Let's face it, JavaScript has got some weird (and some bad) sides. <strong>Closures</strong> are on the weird side of JavaScript. Let's see what the term closure actually means.</p>
<p>When you declare a local variable, that variable has a restricted scope, that is, it cannot be used outside that particular scope within which it is declared (depends on <kbd>var</kbd> and <kbd>let</kbd>). As discussed earlier, local variables are not available outside the block (as in the case of <kbd>let</kbd>) or function scope (as in the case of <kbd>var</kbd> or <kbd>let</kbd>).</p>
<p>Let's take a look at the following example to understand what the preceding paragraph states:</p>
<pre>function() {<br/>  var a = 1;<br/>  console.log(a); // 1<br/>} <br/>console.log(a); // Error</pre>
<p>When a function is fully executed, that is, has returned its value, its local variables are no longer required and cleaned from memory. However, a closure is a <em>persistent local variable scope</em>.<strong> </strong></p>
<p>Consider the following example:</p>
<pre>function counter () {<br/>  var count = 0;<br/>  return function () {<br/>    count += 1;<br/>    return count;<br/>  }<br/>}</pre>
<p>Clearly, the returned function makes use of the <span>local </span>variable to the <kbd>counter()</kbd> function. What happens when you call counter?</p>
<pre>let myCounter = counter(); // returns a function (with count = 1)<br/>myCounter(); // now returns 2<br/>myCounter(); // now returns 3</pre>
<p>Look carefully, we are not executing <kbd>counter()</kbd> again and again. We stored the returned value of the <kbd>counter</kbd> in the <kbd>myCounter</kbd> <span>variable </span>and then kept calling the returned function.</p>
<p>The returned <kbd>myCounter</kbd> <span>function </span>will count up by one each time it's called. When you call <kbd>myCounter()</kbd>, you are executing a function that contains a reference to a variable (<kbd>count</kbd>), which exists in a parent function and technically should've been destroyed after its complete execution. However, JavaScript preserves used variables inside a returned function in a kind of different stack. This property is called a closure.</p>
<p>Closures have been around for a long time, so what's different? Using it with the <kbd>let</kbd> keyword.<strong> </strong>Have a look at this one:</p>
<pre>for(var i=0;i&lt;5;i++){<br/>  setTimeout(function() {<br/>    console.log(i);<br/>  }, 1000);<br/>}</pre>
<p>The output will be:</p>
<pre><strong> 5 5 5 5 5 </strong></pre>
<p>Why? Because till the time <kbd>setTimeout</kbd> fires, the loop has already ended and the <kbd>i</kbd> variable was already <kbd>5</kbd>. But this does not happen with <kbd>let</kbd>:</p>
<pre>for(let i=0;i&lt;5;i++){<br/>  setTimeout(function() {<br/>    console.log(i);<br/>  }, 1000);<br/>}</pre>
<p>Output:</p>
<pre class="mce-root"><strong>0 1 2 3 4</strong></pre>
<p class="mce-root">The fact that <kbd>let</kbd> binds variables to the block (thus, in this case, the <kbd>for</kbd> loop) means that it binds the variable to every iteration. So, when the loop is finished, you have five <kbd>setTimeout</kbd> functions (with <kbd>i</kbd> = <kbd>0</kbd>, <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, <kbd>4</kbd>) waiting to fire one after another.</p>
<p><kbd>let</kbd> achieves this by creating a closure of its own in every iteration. This happens behind the scenes with <kbd>let</kbd>, so you do not need to code that aspect.</p>
<p>To fix this code without <kbd>let</kbd>, we'll need to create an <strong>Immediately Invoked Function Expression</strong> (<strong>IIFE</strong>), which looks something like this:</p>
<pre>for(var i=0;i&lt;5;i++){<br/>  (function(arg) {<br/>    setTimeout(function() {<br/>      console.log(arg); <br/>    }, 1000);<br/>  }(i));<br/>}</pre>
<p>This is more or less what <kbd>let</kbd> does behind the scenes. So what happened here?</p>
<p>We created an anonymous function that is immediately invoked at every loop cycle with the correct <kbd>i</kbd> value associated with it. Now, this function has the correct <kbd>i</kbd> value passed as <kbd>arg</kbd> in the function argument. Finally, we use <kbd>console.log</kbd> after a second to get the correct output as <kbd>0 1 2 3 4</kbd>.</p>
<p>So you can observe, a simple <kbd>let</kbd> statement can simplify the code a lot in such cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The const keyword</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>const</kbd> keyword, you can create variables that cannot change their values (hence they're  called <strong>constants</strong>) once they're initialized, that is, you cannot reinitialize them with another value later in your code.</p>
<p>If you try to reinitialize a <kbd>const</kbd> variable, a read-only exception is thrown. Furthermore, you cannot just declare and not initialize a <kbd>const</kbd> variable. It'll also throw an exception.</p>
<p>For instance, you might want your JavaScript to crash if someone tries to change a particular constant, say <kbd>pi</kbd>, in your calculator. Here's how to achieve that:</p>
<pre class="mce-root">const pi = 3.141;<br/>pi = 4; // not possible in this universe, or in other terms, <br/>        // throws Read-only error</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The scope of const variables</h1>
                </header>
            
            <article>
                
<p>The <kbd>const</kbd> variables are block-scoped variables, that is, they follow the same scoping rules as the variables that are declared using the <kbd>let</kbd> keyword. The following example demonstrates the scope of the constant variables:</p>
<pre>const a = 12; // accessible globally<br/>function myFunction() {<br/>  console.log(a);<br/>  const b = 13; // accessible throughout function<br/>  if(true) {<br/>    const c = 14; // accessible throughout the "if" statement<br/>    console.log(b);<br/>  }<br/>console.log(c);<br/>}<br/>myFunction();</pre>
<p>The output of the preceding code is:</p>
<pre><strong>12</strong><br/><strong>13</strong><br/><strong>ReferenceError Exception</strong></pre>
<p>Here, we can see that constant variables behave in the same way as block-scoped variables when it comes to scoping rules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Referencing objects using constant variables</h1>
                </header>
            
            <article>
                
<p>When we assign an object to a variable, the reference of the object is what the variable holds and not the object itself. So, when assigning an object to a constant variable, the reference of the object becomes constant to that variable and not to the object itself. Therefore, the object is mutable.<br/>
<br/>
Consider this example:</p>
<pre>const a = {<br/>  name: "Mehul"<br/>};<br/>console.log(a.name);<br/>a.name = "Mohan";<br/>console.log(a.name);<br/>a = {}; //throws read-only exception<br/><br/></pre>
<p>The output of the preceding code is:</p>
<pre><strong>Mehul</strong><br/><strong>Mohan</strong><br/><strong>&lt;Error thrown&gt;</strong></pre>
<p>In this example, the <kbd>a</kbd> variable stores the address (that is, reference) of the object. So the address of the object is the value of the <kbd>a</kbd> variable, and it cannot be changed. But the object is mutable. So when we tried to assign another object to the <kbd>a</kbd> variable, we got an exception as we were trying to change the value of the <kbd>a</kbd> variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to use var/let/const </h1>
                </header>
            
            <article>
                
<p>The difference between <kbd>const</kbd> and <kbd>let</kbd> is that <kbd>const</kbd> makes sure that rebinding will not happen. That means you cannot reinitialize a <kbd>const</kbd> variable, but a <kbd>let</kbd> variable can be reinitialized (but not redeclared).</p>
<p class="mce-root">Within a particular scope, a <kbd>const</kbd> variable always refers to the same object. Because <kbd>let</kbd> can change its value at runtime, there is no guarantee that a <kbd>let</kbd> variable always refers to the same value. Therefore, as a rule of thumb, you can (not strictly) follow these:</p>
<ul>
<li class="mce-root">Use <kbd>const</kbd> by default if you know that you'll not change the value (max performance boost)</li>
<li class="mce-root">Only use <kbd>let</kbd> if you think reassignment is required/can happen somewhere in your code (modern syntax)</li>
<li class="mce-root">Avoid using <kbd>var</kbd> (<kbd>let</kbd> does not create global variables when defined in a block scope; this makes it less confusing for you if you come from a C, C++, Java, or any similar background)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Let versus var versus const performance benchmarks</h1>
                </header>
            
            <article>
                
<p>Currently, running a benchmark test on my own laptop (MacBook Air, Google Chrome <span>Version 61.0.3163.100</span> <span>(official build) (64-bit)) produces the following result:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="236" src="assets/fad02c03-9357-48ec-b5fd-86ad946f0e58.png" width="500"/></div>
<p>Clearly, performance-wise on Chrome, <span class="packt_screen">let</span> on the global scope is slowest, while <kbd>let</kbd> inside a block is fastest, and so is <span class="packt_screen">const</span>.</p>
<p>First of all, the aforementioned benchmark tests are performed by running a loop 1000 x 30 times and the operation performed in the loop was appending a value to an array. That is, the array starts from [1], then becomes [1,2] in the next iteration, then [1,2,3], and so on.</p>
<p>What do the results mean? One inference we can draw from these results is that <kbd>let</kbd> is slower in a <kbd>for</kbd> loop when used inside the declaration: <kbd>for(let i=0;i&lt;1000;i++)</kbd>.</p>
<p>This is because <kbd>let</kbd> is redeclared every time for each iteration (relate this to the closure section you read earlier), whereas <kbd>for(var i=0;i&lt;1000;i++)</kbd> declares the <kbd>i</kbd> variable for the whole block of code. This makes <kbd>let</kbd> a bit slower when used in a loop definition.</p>
<p>However, when <kbd>let</kbd> is not used inside the loop body but declared outside the loop, it performs quite well. For example:</p>
<pre>let myArr = [];<br/>for(var i = 0;i&lt;1000;i++) {<br/>   myArr.append(i);<br/>}</pre>
<p>This will give you the best results. However, if you're not performing tens of hundreds of iterations, it should not matter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutability in JavaScript</h1>
                </header>
            
            <article>
                
<p>Immutability, defined in a single line, means that once that value is assigned, then it can never be <em>changed</em>: </p>
<pre>var string1 = "I am an immutable";<br/>var string2 = string1.slice(4, 8);</pre>
<p><kbd>string1.slice</kbd> does not change the value of <kbd>string1</kbd>. In fact, no string methods change the string they operate on, they all return new strings. The reason is that strings are immutable—they cannot change.</p>
<p>Strings are not the only immutable entity in JavaScript. Numbers, too, are immutable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object.freeze versus const</h1>
                </header>
            
            <article>
                
<p>Earlier, we saw that even if you create objects with <kbd>const</kbd> in front of them, a programmer is still able to modify its properties. This is because <kbd>const</kbd> creates an immutable binding, that is, you cannot assign a new value to the binding.</p>
<p>Therefore, in order to truly make objects constants (that is, unmodifiable properties), we have to use something called <kbd>Object.freeze</kbd>. However, <kbd>Object.freeze</kbd> is, again, a shallow method, that is, you need to recursively apply it on nested objects to protect them. Let's clear this up with a simple example.</p>
<p>Consider this example:</p>
<pre>var ob1 = {<br/>   prop1 : 1,<br/>    prop2 : {<br/>        prop2_1 : 2 <br/>    }<br/>};<br/><strong>Object.freeze( ob1 );</strong><br/><br/>const ob2 = {<br/>   prop1 : 1,<br/>    prop2 : {<br/>        prop2_1 : 2 <br/>    }<br/>}<br/><br/>ob1.prop1 = 4; // (frozen) ob1.prop1 is not modified <br/>ob2.prop1 = 4; // (const) ob2.foo gets modified<br/><br/>ob1.prop2.prop2_1 = 4; // (frozen) modified, because ob1.prop2.prop2_1 is nested<br/>ob2.bar.value = 4; // (const) modified <br/><br/>ob1.prop2 = 4; // (frozen) not modified, bar is a key of obj1<br/>ob2.prop2 = 4; // (const) modified<br/><br/>ob1 = {}; // (frozen) ob1 redeclared (ob1's declaration is not frozen)<br/>ob2 = {}; // (const) ob2 not redeclared (used const)</pre>
<p>We froze <kbd>ob1</kbd> so all of its first-level hierarchical properties got frozen (that is, cannot be modified). A frozen object will not throw an error when attempted to be modified, but rather it'll simply ignore the modification done.</p>
<p>However, as we go deeper, you'll observe that <kbd>ob1.bar.value</kbd> got modified because it's 2 levels down and is not frozen. So, you'll need to recursively freeze nested objects in order to make them <em>constant</em>.</p>
<p>Finally, if we look at the last two lines, you'll realize when to use <kbd>Object.freeze</kbd> and when to use <kbd>const</kbd>. The <kbd>const</kbd> declaration is not declared again, whereas <kbd>ob1</kbd> is redeclared because it's not constant (it's <kbd>var</kbd>). <kbd>Object.freeze</kbd> does not freeze the original variable binding and hence is not a replacement for <kbd>const</kbd>. Similarly, <kbd>const</kbd> does not freeze properties and is not a replacement for <kbd>Object.freeze</kbd>.</p>
<div class="packt_tip packt_infobox">Also, once an object is frozen, you can no longer add properties to it. However, you can add properties to nested objects (if present).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default parameter values</h1>
                </header>
            
            <article>
                
<p>In JavaScript, there is no defined way to assign default values to function parameters that are not passed. So programmers usually check for parameters with the <kbd>undefined</kbd> value (as it is the default value for missing parameters) and assign the default values to them. The following example demonstrates how to do this:</p>
<pre> function myFunction(x, y, z) {<br/> x = x === undefined ? 1 : x;<br/> y = y === undefined ? 2 : y;<br/> z = z === undefined ? 3 : z;<br/> console.log(x, y, z); //Output "6 7 3"<br/> }<br/> myFunction(6, 7);</pre>
<p>This can be done in an easier way by providing a default value to function arguments. Here is the code that demonstrates how to do this:</p>
<pre>function myFunction(x = 1, y = 2, z = 3) {<br/> console.log(x, y, z); <br/>}<br/>myFunction(6,7); // Outputs 6 7 3</pre>
<p>In the preceding code block, since we've passed first two arguments in the function calling statement, the default values (that is <kbd>x = 1</kbd> and <kbd>y = 2</kbd>) will be overwritten with our passed values (that is <kbd>x = 6</kbd> and <kbd>y = 7</kbd>). The third argument is not passed, hence its default value (that is <kbd>z =3</kbd>) is used.</p>
<p>Also, passing <kbd>undefined</kbd> is considered as missing an argument. The following example demonstrates this:</p>
<pre>function myFunction(x = 1, y = 2, z = 3) {<br/>   console.log(x, y, z); // Outputs "1 7 9"<br/> }<br/> myFunction(undefined,7,9);</pre>
<p>A similar thing happens here. If you want to omit the first argument, just pass <kbd>undefined</kbd> in that.</p>
<p>Defaults can also be expressions. The following example demonstrates this:</p>
<pre> function myFunction(x = 1, y = 2, z = x + y) {<br/>   console.log(x, y, z); // Output "6 7 13"<br/> }<br/> myFunction(6,7);</pre>
<p>Here, we're making use of the argument variables themselves inside a default argument value! That is, whatever you pass as the first two arguments, if the third argument is not passed it'll take the value of the sum of the first two arguments. Since we passed <kbd>6</kbd> and <kbd>7</kbd> to the first and second argument, <kbd>z</kbd> becomes <em>6 + 7 = 13</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The spread operator</h1>
                </header>
            
            <article>
                
<p>A <strong>spread operator</strong> is represented by the <kbd>...</kbd> token. A spread operator splits an iterable object into its individual values.</p>
<div class="packt_infobox">An <strong>iterable</strong> is an object that contains a group of values and implements the ES6 iterable protocol to let us iterate through its values. An <strong>array</strong> is an example of a built-in iterable object.</div>
<p>A spread operator can be placed wherever multiple function arguments or multiple elements (for array literals) are expected in code.</p>
<p>The spread operator is commonly used to spread the values of an iterable object into the arguments of a function. Let's take the example of an array and see how to split it into the arguments of a function.</p>
<p>To provide the values of an array as a function argument, you can use the <kbd>apply()</kbd> method of <kbd>Function</kbd>. This method is available to every function. The following example demonstrates:</p>
<pre>function myFunction(a, b) {<br/>  return a + b;<br/>}<br/>var data = [1, 4];<br/>var result = myFunction.apply(null, data);<br/>console.log(result); //Output "5"</pre>
<p>Here, the <kbd>apply</kbd> method takes an array, extracts the values, passes them as individual arguments to the function, and then calls it.</p>
<p>Here's an example using the modern way, that is, with the spread operator:</p>
<pre>function myFunction(a, b) {<br/>    return a + b; <br/>}<br/>let data = [1, 4];<br/>let result = myFunction(...data);<br/>console.log(result); //Output "5"</pre>
<p>During runtime, before the JavaScript interpreter calls the <kbd>myFunction</kbd> function, it replaces <kbd>...data</kbd> with the <kbd>1,4</kbd> expression:</p>
<pre>let result = myFunction(...data);</pre>
<p>The previous code is replaced with:</p>
<pre>let result = myFunction(1,4);</pre>
<p>After this, the function is called.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other uses of the spread operator</h1>
                </header>
            
            <article>
                
<p>The spread operator is not just limited to spreading an iterable object into function arguments, but it can be used wherever multiple elements (for example, array literals) are expected in code. So it has many uses. Let's see some other use cases of the spread operator for arrays.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making array values a part of another array</h1>
                </header>
            
            <article>
                
<p>The spread operator can also be used to make array values a part of another array. The following example code that demonstrates how to make the values of an existing array a part of another array while creating it:</p>
<pre>let array1 = [2,3,4];<br/>let array2 = [1, ...array1, 5, 6, 7];<br/>console.log(array2); //Output "1, 2, 3, 4, 5, 6, 7"</pre>
<p>Consider the following code:</p>
<pre> let array2 = [1, ...array1, 5, 6, 7];</pre>
<p>This previous code is equivalent to:</p>
<pre> let array2 = [1, 2, 3, 4, 5, 6, 7];</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pushing the values of an array into another array</h1>
                </header>
            
            <article>
                
<p>Sometimes, we may need to push the values of an existing array into the end of another existing array.<br/>
This is how programmers used to do it:</p>
<pre>var array1 = [2,3,4];<br/>var array2 = [1];<br/>Array.prototype.push.apply(array2, array1);<br/>console.log(array2); //Output "1, 2, 3, 4"</pre>
<p>But from ES6 onward we have a much cleaner way to do it, which is as follows:</p>
<pre>let array1 = [2,3,4];<br/>let array2 = [1];<br/>array2.push(...array1);<br/>console.log(array2); //Output "1, 2, 3, 4"</pre>
<p class="mce-root">Here the <kbd>push</kbd> method takes a series of variables and adds them to the end of the array on which it is called.<br/>
See the following line:</p>
<pre>array2.push(...array1);</pre>
<p>This will be replaced with the following line:</p>
<pre>array2.push(2, 3, 4);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spreading multiple arrays</h1>
                </header>
            
            <article>
                
<p>Multiple arrays can be spread on a single-line expression. For example, take the following code:</p>
<pre>let array1 = [1];<br/>let array2 = [2];<br/>let array3 = [...array1, ...array2, ...[3, 4]];//multi arrayspread<br/>let array4 = [5];<br/>function myFunction(a, b, c, d, e) {<br/>  return a+b+c+d+e;<br/>}<br/>let result = myFunction(...array3, ...array4); //multi array spread<br/>console.log(result); //Output "15"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The rest parameter</h1>
                </header>
            
            <article>
                
<p>The <strong>rest parameter</strong> is also represented by the <kbd>...</kbd> token. The last parameter of a function with <kbd>...</kbd> is called a rest parameter. The rest parameter is an array type and contains the rest of the parameters of a function when the number of arguments exceeds the number of named parameters.<br/>
The rest parameter is used to capture a variable number of function arguments from within a function.<br/>
The <kbd>arguments</kbd> object can also be used to access all arguments passed. The <kbd>argument</kbd> object is not strictly an array, but it provides some interfaces that are similar to an array.<br/>
The following example code shows how to use the <kbd>arguments</kbd> object to retrieve the extra arguments:</p>
<pre>function myFunction(a, b) {<br/>    const args = Array.prototype.slice.call(arguments, myFunction.length);<br/>    console.log(args);<br/>}<br/>myFunction(1, 2, 3, 4, 5); //Output "3, 4, 5"</pre>
<p>This can be done in a much easier and cleaner way, by using the rest parameter. The following example demonstrates to use the rest parameter:</p>
<pre>function myFunction(a, b, ...args) {<br/>    console.log(args); //Output "3, 4, 5"<br/>}<br/>myFunction(1, 2, 3, 4, 5);</pre>
<p>The <kbd>arguments</kbd> object is not an array object. Therefore, to do array operations on the <kbd>arguments</kbd> object, you need to convert it to an array. The rest parameter is easy to work with.</p>
<div class="packt_infobox">What is the <kbd>...</kbd> token called?<br/>
The <kbd>...</kbd> token is called the spread operator or rest parameter, depending on where and how it's used.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hoisting</h1>
                </header>
            
            <article>
                
<p><strong>Hoisting</strong> is JavaScript's default behavior: moving declarations to the top. That means the following code will work in JavaScript:</p>
<pre>bookName("ES8 Concepts");<br/>function bookName(name) {<br/>   console.log("I'm reading " + name);<br/>}</pre>
<p>If you're coming from a C/C++ background, this might seem a little weird at first because those languages do not allow you to call a function before at least declaring its prototype. But JavaScript, behind the scenes, hoists the function, that is, all function declarations are moved to the top of the context. So, essentially, the preceding code is the same as the following:</p>
<pre>function bookName(name) {<br/>   console.log("I'm reading " + name);<br/>}<br/><br/>bookName("ES8 Concepts");</pre>
<p><span>Hoisting only moves the declarations to the top, not the initializations. Therefore, although the preceding code works, the following code won't work:</span></p>
<pre>bookName("ES8 Concepts"); // bookName is not a function<br/>var bookName = function(name) {<br/>   console.log("I'm reading " + name);<br/>}</pre>
<p>This is because, as we said earlier, only declarations are hoisted. Therefore, what a browser sees is something like this:</p>
<pre>var bookName; // hoisted above<br/>bookName("ES8 Concepts"); // bookName is not function <br/>                          // because bookName is undefined<br/>bookName = function(name) { // initalization is not hoisted<br/>   console.log("I'm reading " + name);<br/>}</pre>
<p>Guess the output of the following code:</p>
<pre>function foo(a) {<br/>   a();<br/>   function a() {<br/>      console.log("Mehul");<br/>   }<br/>}<br/><br/>foo(); // ??<br/>foo( undefined ); // ??<br/>foo( function(){ console.log("Not Mehul"); } ); // ??</pre>
<p>Ready to find out? Your possible answers are:</p>
<ul>
<li>
<pre><strong>Mehul</strong><br/><strong>undefined</strong><br/><strong>Not Mehul</strong></pre></li>
<li>
<pre><strong>Program throws error</strong></pre></li>
<li>
<pre><strong>Mehul</strong><br/><strong>Mehul</strong><br/><strong>Mehul</strong></pre></li>
</ul>
<p>The output will be :</p>
<pre><strong>Mehul</strong><br/><strong>Mehul</strong><br/><strong>Mehul</strong></pre>
<p>Why? Because this is how your browser see this code (after applying the hoisting thing):</p>
<pre>function foo(a) { <br/>   // the moment below function is declared, <br/>   //the argument 'a' passed is overwritten.<br/>   function a() {<br/>      console.log("Mehul");<br/>   }<br/>   a();<br/>}<br/><br/>foo();<br/>foo( undefined );<br/>foo( function(){ console.log("Not Mehul"); } );</pre>
<p>Once the function is hoisted, it doesn't matter what you pass in that function. It is always overwritten with the function defined inside the <kbd>foo</kbd> function.</p>
<p>Therefore, the output is just <kbd>Mehul</kbd> written three times. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring assignments</h1>
                </header>
            
            <article>
                
<p><span>A <strong>destructuring assignment</strong> is an expression that allows you to assign the values or properties of an iterable or object to variables, using a syntax that looks similar to the array or object construction literals respectively.</span></p>
<div class="page">
<div class="layoutArea">
<div class="column">
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>A destructuring assignment makes it easy to extract data from iterables or objects by providing a shorter syntax. A destructuring assignment is already present in programming languages such as</span> <span>Perl</span> <span>and</span> <span>Python</span><span>, and works the same way everywhere.</span></p>
<p><span>There are two kinds of destructuring assignment expressions: <strong>array</strong> and <strong>object</strong>. Let's see each of them in detail.</span></p>
</div>
</div>
</div>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The array destructuring assignment</h1>
                </header>
            
            <article>
                
<p><span>An <strong>array destructuring assignment</strong> is used to extract the values of an iterable object and assign them to the variables. It's called an</span> <span>array destructuring assignment</span> <span>because the expression is similar to an array construction literal.</span></p>
<p><span>Programmers used to do it this way to assign the values of an array to the variables:</span></p>
<pre><span> var myArray = [1, 2, 3];
 var a = myArray[0];
 var b = myArray[1];
 var c = myArray[2];
</span></pre>
<p><span>Here, we are extracting the values of an array and assigning them to the</span> <kbd><span>a</span></kbd><span>,</span> <kbd><span>b</span></kbd><span>,</span> <kbd><span>c</span></kbd> <span>variables respectively.</span></p>
<p><span>With an array destructuring assignment we can do this in a one-line statement:</span></p>
<pre><span>let myArray = [1, 2, 3];
let a, b, c;
</span><span>[a, b, c] = myArray; //array destructuring assignment syntax
</span></pre>
<p><span>As you can see,</span> <kbd><span>[a, b, c]</span></kbd> <span>is an array destructuring expression.</span></p>
<p><span>On the left-hand side of the array destructuring statement, we need to place the variables to which we want to assign the array values, using a syntax similar to an array literal. On the right-hand side, we need to place an array (actually any iterable object) whose values we want to extract.</span></p>
<p><span>The previous example code can be made even shorter in this way:</span></p>
<pre><span>let [a, b, c] = [1, 2, 3];
</span></pre>
<p><span>Here, we create the variables on the same statement, and instead of providing the array variable, we provide the array with a construction literal.</span></p>
<p><span>If there are fewer variables than items in the array, then only the first items</span> <span>are considered.</span></p>
<div class="packt_infobox">If you place a non-iterable object on the right-hand side of the array destructuring assignment syntax, then a TypeError exception is thrown.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ignoring values</h1>
                </header>
            
            <article>
                
<p>We can also ignore some of the values of the iterable. Here is example code that shows how to do this:</p>
<pre> let [a, , b] = [1, 2, 3]; // notice --&gt;, ,&lt;-- (2 commas)<br/> console.log(a);<br/> console.log(b);</pre>
<p>The output is as follows:</p>
<pre><strong>1 3</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the rest operator in an array destructuring assignment</h1>
                </header>
            
            <article>
                
<div class="column">
<p><span>We can prefix the last</span> <span>variable of an array destructuring expression using the</span> <kbd><span>...</span></kbd><span> token. In this case, the variable is always converted into an array object that holds the rest of the values of the iterable object, if the number of other variables is less than the values in the iterable object.</span></p>
</div>
<p><span>Consider this example to understand it:</span></p>
<pre><span>   let [a, ...b] = [1, 2, 3, 4, 5, 6];
</span><span>   console.log(a);
   console.log(Array.isArray(b));
   console.log(b);
</span></pre>
<p><span>The output is as follows:</span></p>
<pre><strong>   1
   true
   2,3,4,5,6
</strong></pre>
<p><span>In the previous example code, you can see that the</span> <kbd><span>b</span></kbd> <span>variable is converted into an array, and it holds all the other values of the right-hand side array.</span></p>
<p><span>Here the</span> <kbd><span>...</span></kbd><span> token is called the</span> <span>rest operator</span><span>.<br/>
We can also ignore the values while using the rest operator. The following example demonstrates </span><span>this:</span></p>
<pre><span>   let [a, , ,...b] = [1, 2, 3, 4, 5, 6];
</span><span>   console.log(a);
   console.log(b);
</span></pre>
<p><span>The output is as follows:</span></p>
<pre><strong>1 4,5,6</strong></pre>
<p><span>Here, we ignored the</span> <span><kbd>2</kbd>, <kbd>3</kbd></span> <span>values.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default values for variables</h1>
                </header>
            
            <article>
                
<p><span>While destructuring, you can also provide default values for the variables if an array index is</span> <kbd><span>undefined</span></kbd><span>. The following example demonstrates this:</span></p>
<pre><span>   let [a, b, c = 3] = [1, 2];
   console.log(c); //Output "3"
</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nested array destructuring</h1>
                </header>
            
            <article>
                
<p><span>We can also extract the values from a multidimensional array and assign them to variables. The following example demonstrates this:</span></p>
<pre><span>   let [a, b, [c, d]] = [1, 2, [3, 4]];
</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a destructuring assignment as a parameter</h1>
                </header>
            
            <article>
                
<p><span>We can also use an array destructuring expression as the function parameter for extracting the values of an iterable object, passed as an argument into the function parameters. The following example demonstrates this:</span></p>
<pre><span>   function myFunction([a, b, c = 3]) {
</span><span>     console.log(a, b, c); //Output "1 2 3"
   }
</span><span>   myFunction([1, 2]);
</span></pre>
<p><span>Earlier in this chapter, we saw that if we pass</span> <kbd><span>undefined</span></kbd> <span>as an argument to a function call, then JavaScript checks for the default parameter value. So, we can provide a default array here too, which will be used if the argument is</span> <kbd><span>undefined</span></kbd><span>. The following example demonstrates this:</span></p>
<pre><span>   function myFunction([a, b, c = 3] = [1, 2, 3]) {
</span><span>     console.log(a, b, c);  //Output "1 2 3"
   }<br/></span>    myFunction(undefined);</pre>
<p class="mce-root"><span>Here, we passed</span> <kbd><span>undefined</span></kbd> as an argument and therefore the default array, which is <kbd><span>[1, 2, 3]</span></kbd><span>, was used to extract the values.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object destructuring assignments</h1>
                </header>
            
            <article>
                
<div class="column">
<p><span>An <strong>object destructuring assignment</strong> is used to the extract property values of an object and assign them to the variables.</span></p>
</div>
<p><span>This is a traditional (and still useful) way of assigning property values to an object:</span></p>
<pre><span>   var object = {"name" : "John", "age" : 23};
   var name = object.name;
   var age = object.age;
</span></pre>
<p><span>We can do this in a one-line statement, using the object destructuring assignment:</span></p>
<pre><span>   let object = {"name" : "John", "age" : 23};
   let name, age;
</span><span>   ({name, age} = object); //object destructuring assignment syntax
</span></pre>
<p><span>On the left-hand side of the object destructuring statement, we need to place the variables to which we want to assign the object property values using a syntax similar to that of an object literal. On the right-hand side, we need to place an object whose property</span> <span>values we want</span> <span>to extract. The statement is finally closed using the</span> <kbd>( )</kbd> <span>token.</span></p>
<p><span>Here the variable names must be the same as the object property names. If you want to assign different variable names, then you can do it this way:</span></p>
<pre><span>   let object = {"name" : "John", "age" : 23};
   let x, y;
</span><span>   ({name: x, age: y} = object);
</span></pre>
<p><span>The previous code can be made even shorter this way:</span></p>
<pre><span>   let {name: x, age: y} = {"name" : "John", "age" : 23};
</span></pre>
<p><span>Here we are creating the variables and object on the same line. We don't need to close the statement using the</span> <kbd><span>( )</span></kbd> <span>token, as we are creating the variables on the same statement.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default values for variables</h1>
                </header>
            
            <article>
                
<p><span>You can also provide default values for the variables if the object property is</span> <kbd><span>undefined</span></kbd> <span>while destructuring. The following example demonstrates this:</span></p>
<pre><span>   let {a, b, c = 3} = {a: "1", b: "2"};
   console.log(c); //Output "3"
</span></pre>
<p><span>Some property names are constructed dynamically using expressions. In this case, to extract the property values, we can use the</span> <kbd><span>[ ]</span></kbd> <span>token to provide the property name with an expression. The following example demonstrates this:</span></p>
<pre><span>   let {["first"+"Name"]: x} = { firstName: "Eden" };
   console.log(x); //Output "Eden"
</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring nested objects</h1>
                </header>
            
            <article>
                
<p><span>We can also extract property values from nested objects, that is, objects within objects. The following example demonstrates this:</span></p>
<pre><span>   var {name, otherInfo: {age}} = {name: "Eden", otherInfo: {age:
   23}};
   console.log(name, age); //Eden 23
</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the object destructuring assignment as a parameter</h1>
                </header>
            
            <article>
                
<p><span>Just like the array destructuring assignment, we can also use the object destructuring assignment as a function parameter. The following example demonstrates this:</span></p>
<pre><span>   function myFunction({name = 'Eden', age = 23, profession = <br/>                       "Designer"} = {})   {
</span><span>     console.log(name, age, profession); // Outputs "John 23 Designer"
   }
</span><span>   myFunction({name: "John", age: 23});
</span></pre>
<p><span>Here, we passed an empty object as a default parameter value, which will be used as a default object if</span> <kbd><span>undefined</span></kbd> <span>is passed as a function argument.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arrow functions</h1>
                </header>
            
            <article>
                
<p>An <strong>arrow function</strong> is, at first glance, just a fancy way to create regular JavaScript functions (however, there are some surprises). Using arrow functions, you can create concise one-liner functions that actually work!</p>
<p><span>The following example demonstrates</span> how to create an arrow function:</p>
<pre>let circumference = (pi, r) =&gt; {<br/>  let ans = 2 * pi * r;<br/>  return ans;<br/>}<br/>let result = circumference(3.141592, 3);<br/>console.log(result); // Outputs 18.849552</pre>
<p>Here, circumference is a variable, referencing to the anonymous arrow function.<br/>
The previous code is similar to the following code in ES5:</p>
<pre>var circumference = function(pi, r) {<br/>  var area = 2 * pi * r;<br/>  return area;<br/>}<br/>var result = circumference(3.141592, 3);<br/>console.log(result); //Output 18.849552</pre>
<p>If your function contains just a single statement (and you want to return the result of that statement), then you don't have to use the <kbd>{}</kbd> brackets to wrap the code. This makes it a one-liner. <span>The following example demonstrates this</span>:</p>
<pre>let circumference = (pi, r) =&gt; 2 * pi * r;<br/>let result = circumference(3.141592, 3);<br/>console.log(result); //Output 18.849552</pre>
<p>When <kbd>{}</kbd> brackets are not used then the value of the statement in the body is automatically returned. The preceding code is equivalent to the following:</p>
<pre>let circumference = function(pi, r) { return 2 * pi * r; }<br/>let result = circumference(3.14, 3);<br/>console.log(result); //Output 18.84</pre>
<p>Also, if there's only a single argument, you can omit the brackets to make the code even shorter. Consider the following example:</p>
<pre>let areaOfSquare = side =&gt; side * side;<br/>let result = areaOfSquare(10);<br/>console.log(result); //Output 100</pre>
<p>Since there is only one argument, <kbd>side</kbd>, we can omit the circular brackets for this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The value of "this" in an arrow function</h1>
                </header>
            
            <article>
                
<p>In arrow functions, the value of the <kbd>this</kbd> keyword is the same as the value of the <kbd>this</kbd> keyword of the enclosing scope (the global or function scope, whichever the arrow function is defined inside). That means, instead of referring to the context object (that is, the object inside which the function is a property), which is the value of <kbd>this</kbd> in traditional functions, <kbd>this</kbd> instead refers to global or function scope, in which the function is called.<br/>
Consider this example to understand the difference between the traditional functions and the arrow functions, this value:</p>
<pre>var car = {<br/>  name: 'Bugatti',<br/>  fuel: 0,<br/>  // site A<br/>  addFuel: function() {<br/>             // site B<br/>             setInterval(function() {<br/>              // site C<br/>              this.fuel++;<br/>              console.log("The fuel is now " + this.fuel);<br/>             }, 1000)<br/>           }<br/>}<br/><br/><br/></pre>
<p>What do you think will happen when you call the <kbd>car.addFuel()</kbd> method? If you guessed <kbd>The fuel is now undefined</kbd> will appear forever, then you are right! But why?!</p>
<p>When you define the <kbd>addFuel</kbd> method inside the <strong><kbd>function() {}</kbd> </strong>(above site B), your <kbd>this</kbd> keyword refers to the current object. However, once you go another level deeper into functions (site C), your <kbd>this</kbd> now points to that particular function and its prototypes. Hence, you cannot access the parent object's property with the <kbd>this</kbd> keyword.</p>
<p>How do we fix this? Take a look at these arrow functions!</p>
<pre>var car = {<br/>  name: 'Bugatti',<br/>  fuel: 0,<br/>  // site A<br/>  addFuel: function() {<br/>             // site B<br/>             setInterval(<strong>() =&gt; {</strong> // notice!<br/>              // site C<br/>              this.fuel++;<br/>              console.log("The fuel is now " + this.fuel);<br/>             }, 1000)<br/>           }<br/>}</pre>
<p>Now, inside site C, the <kbd>this</kbd> keyword refers to the parent object. Hence, we're able to access the <kbd>fuel</kbd> property using the <kbd>this</kbd> keyword only.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other differences between arrow and traditional functions</h1>
                </header>
            
            <article>
                
<p><span>A</span>rrow functions cannot be used as <strong>object constructors</strong>, that is, the <kbd>new</kbd> operator cannot be applied to them.<br/>
Apart from <strong>syntax</strong>, the <strong>value</strong>, and the <kbd>new</kbd> operator, everything else is the same between arrow and traditional functions, that is, they are both instances of the <kbd>Function</kbd> constructor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhanced object literals</h1>
                </header>
            
            <article>
                
<p>Once, JavaScript required developers to write complete function names, property names, even when the function name / property name values matched each other (example: <kbd>var a = { obj: obj }</kbd>). However, ES6/ES7/ES8 and beyond relaxes this and allows the minification and readability of code in a number of ways. Let us see how.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining properties</h1>
                </header>
            
            <article>
                
<p>ES6 brought in a shorter syntax for assigning object properties to the values of variables that have the same name as the properties.<br/>
Traditionally, you would've done this:</p>
<pre>var x = 1, y = 2;<br/>var object = {<br/> x: x,<br/> y: y <br/>};<br/>console.log(object.x); //output "1"</pre>
<p>But now, you can do it this way:</p>
<pre>let x = 1, y = 2;<br/>let object = { x, y };<br/>console.log(object.x); //output "1"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining methods</h1>
                </header>
            
            <article>
                
<p>ES6 onwards provides a new syntax for defining the methods on an object. <span>The following example demonstrates</span> the new syntax:</p>
<pre>let object = {<br/>    myFunction(){<br/>        console.log("Hello World!!!"); //Output "Hello World!!!"<br/>    }<br/>}<br/>object.myFunction();</pre>
<p>This concise function allows the use of <kbd>super</kbd> in them, whereas traditional object methods don't allow the use of <kbd>super</kbd>. We will learn more about this later in the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computed property names</h1>
                </header>
            
            <article>
                
<p>Property names that are evaluated during runtime are called computed property names. An expression is usually resolved to find the property name dynamically.<br/>
Computed properties were once defined in this way:</p>
<pre>var object = {};<br/>object["first"+"Name"] = "Eden";//"firstName" is the property name<br/>//extract<br/>console.log(object["first"+"Name"]); //Output "Eden"</pre>
<p>Here, after creating the object, we attach the properties to the object. But in ES6, we can add the properties with the computed name while creating the object. <span>The following example demonstrates this</span>:</p>
<pre>let object = {<br/>["first" + "Name"]: "Eden",<br/>};<br/>//extract<br/>console.log(object["first" + "Name"]); //Output "Eden"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trailing commas and JavaScript</h1>
                </header>
            
            <article>
                
<p><strong>Trailing commas</strong> are those commas found at the end of an array list, object, or function arguments. They can be useful when adding new elements, parameters, or properties to JavaScript code. It just makes it a little more convenient for developers that they can choose to write an array as <kbd>[1,2,3]</kbd> or <kbd>[1,2,3,]</kbd> (notice the comma in the second example)</p>
<p>JavaScript has allowed trailing commas in arrays and objects for a long time. Finally, in ECMAScript 2017 (ES8), the standard now allows you to add trailing commas to function parameters as well.</p>
<p>That means all the following examples are valid JavaScript code:</p>
<p>Arrays:</p>
<pre>var arr = [1, 2, 3,,,];<br/>arr.length; // 5<br/>arr[3]; // undefined<br/><br/>var arr2 = [1, 2, 3,];<br/>arr2.length; // 3</pre>
<p>The preceding example is clearly valid JavaScript code and <kbd>arr</kbd> is created as <kbd>[1, 2, 3, undefined, undefined]</kbd></p>
<p>Let us now explore how objects behave with trailing commas.</p>
<p>Objects:</p>
<pre>var book = { <br/>  name: "Learning ES8", <br/>  chapter: "1",<br/>  reader: "awesome", // trailing comma allowed here<br/>};</pre>
<p>It can be seen that the code does not throw any error even after putting a comma after the last property name. Let's move on to functions now.</p>
<p>Functions:</p>
<pre>function myFunc(arg) {<br/>   console.log(arg);<br/>}<br/><br/>function myFunc2(arg,) {<br/>   console.log(arg)<br/>} <br/><br/>let myFunc3 = (arg) =&gt; {<br/>   console.log(arg);<br/>};<br/><br/>let myFunc4 = (arg,) =&gt; {<br/>   console.log(arg);<br/>}</pre>
<p>All the aforementioned function definitions are valid from the ES2017 (ES8) spec.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The semicolon dilemma</h1>
                </header>
            
            <article>
                
<p>You must've seen a lot of JavaScript code with semicolons, and a lot without semicolons as well. And surprisingly, both work fine! While languages such as C, C++, Java, and so on are strict about the use of semicolons, and on the other hand languages such as Python are strict about not using semicolons (only indentations), there is no such fixed rule for JavaScript.</p>
<p>So let's see when is semicolon required in JavaScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automatic semicolon insertion in JavaScript</h1>
                </header>
            
            <article>
                
<p>The ECMAScript Language specification (<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.9">http://www.ecma-international.org/ecma-262/5.1/#sec-7.9</a>) states that:</p>
<div class="mce-root packt_quote">"Certain ECMAScript statements must be terminated with semicolons. Such semicolons may always appear explicitly in the source text"</div>
<p class="mce-root">But the spec also says:</p>
<div class="mce-root packt_quote">"For convenience, however, such semicolons may be omitted from the source text in certain situations."</div>
<p>Therefore, the specification states that JavaScript is able to handle automatic semicolon insertion by its own judgment. However, it is extremely error-prone in some cases and not intuitive at all.</p>
<p>Consider this example:</p>
<pre><span class="kd">var</span><span> </span><span class="nx">a</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span> <br/></span><span class="kd">var</span><span> </span><span class="nx">b</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span> <br/></span><span class="kd">var</span><span> </span><span class="nx">c</span><span> </span><span class="o">=</span><span> </span><span class="mi">3</span></pre>
<p>JavaScript automatically inserts semicolon to make code look like:</p>
<pre><span class="kd">var</span><span> </span><span class="nx">a</span><span> </span><span class="o">=</span><span> </span><span class="mi">1;</span><span><br/></span><span class="kd">var</span><span> </span><span class="nx">b</span><span> </span><span class="o">=</span><span> </span><span class="mi">2;</span><span><br/></span><span class="kd">var</span><span> </span><span class="nx">c</span><span> </span><span class="o">=</span><span> </span><span class="mi">3;<br/></span></pre>
<p>So far so good.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Where to insert semicolons in JavaScript?</h1>
                </header>
            
            <article>
                
<p>At times, you will find yourself skipping semicolons somewhere and you'll see that your code still works! This is strictly opposite to what you find in languages such as C or C++. Let us take a look at a scenario where you can get trapped by not using semicolons properly. </p>
<p>Consider this code:</p>
<pre>var fn = function (arg) {<br/>    console.log(arg);<br/>} // Semicolon missing<br/><br/>// self invoking function<br/>(function () {<br/>    alert(5);<br/>})() // semicolon missing<br/><br/>fn(7)</pre>
<p><span>T</span>ake a good look and guess what possible alerts might be, with their orders as well. When you're ready with your answer, look at the following, the code to which JavaScript compiles (not really, just the code after inserting automatic semicolons):</p>
<pre>var fn = function (arg) {<br/>    alert(arg);<br/>}(function () { // &lt;-- semicolon was missing here, <br/>                // this made it an argument for the function<br/>    alert(5);<br/>})();<br/><br/>fn(7);</pre>
<p>So instead of invoking that self-invoking function, what you do apparently is, pass that whole function as an argument to the first one. Therefore, try to use semicolons to avoid ambiguity in your code. You can always use JavaScript compressors later on, which will take care of necessary places to leave semicolons intact. The takeaway from here is <strong>use semicolons.</strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about variable scopes, read-only variables, splitting arrays into individual values, passing indefinite parameters to a function, extracting data from objects and arrays, arrow functions, and new syntaxes for creating object properties, hoisting, IIFE, semicolon usage, and more.<br/>
In the next chapter, we will learn about built-in objects and symbols, and we will discover tons of fundamental tools JavaScript natively provides us with out-of-the-box.</p>


            </article>

            
        </section>
    </body></html>