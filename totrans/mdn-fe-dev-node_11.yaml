- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Alternative Runtimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve seen what advantages and benefits the Node.js ecosystem offers
    to create great web applications. However, as with almost everything, there are
    a few downsides to the design decisions forming what we refer to as Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest challenges in Node.js is the so-called *dependency hell*
    – where many small packages are put together to create a slightly larger package.
    Another challenge is that Node.js is not guarding any of these dependencies from
    accessing system resources. As such, importing anything from a third-party package
    may have unwanted side effects.
  prefs: []
  type: TYPE_NORMAL
- en: While ecosystem reliability and security can help us guard against dependency
    hell, improving performance is also an important strategy. Overall, the performance
    of Node.js can be regarded as decent; however, certain areas such as package resolution
    or processor core utilization could be improved by a fair share. Hence, performance
    is another area that could be regarded as a downside.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll get to know the two most popular alternative runtimes
    for mitigating some of the disadvantages that come with Node.js. To evaluate these
    alternatives in depth, we will keep a closer eye on their compatibility status
    with the existing Node.js ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Deno runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Bun for bundling web apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter11](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3Uqi9aq](https://bit.ly/3Uqi9aq).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Deno runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Node.js is a tremendous success story, not everyone is a fan. Some critics
    say that the huge fragmentation combined with the lack of system controls offers
    too great an attack surface. In the past, we’ve seen countless attacks that have
    abused the vulnerabilities introduced by exactly this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that Node.js did have to invent a lot of APIs – for example,
    to interact with the filesystem. There was no API available in the browser that
    looked similar to what was desired. Of course, as we now know, the browser APIs
    kept improving and even things such as filesystem access are implemented there.
    However, the APIs never aligned, mostly because the variants for Node.js are neither
    controllable nor fully asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Surely, the aforementioned problems were all known for a while, but it took
    several years until an alternative implementation to solve these issues appeared.
    Again, it was Ryan Dahl – the original creator of Node.js – who worked on the
    solution. The solution is called **Deno**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main benefits of Deno are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It introduces system access controls to allow or block access to resources such
    as the filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses explicit imports instead of magically resolved ones – no more implied
    package lookups or index files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It tries to be interchangeable with the browser – bringing exclusively native
    browser APIs instead of custom ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It features first-class TypeScript support, not only improving the development
    experience but also strengthening the reliability of written code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It comes with handy tooling, such as an application bundler out of the box –
    reducing the need to install dependencies for starting development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the hood, Deno uses the Rust programming language instead of C++. Here,
    the choice was made to avoid any potential memory leaks or vulnerabilities that
    are just a bit more likely with C++ than **Rust**. This also means that *libuv*,
    which is the main driver for Node.js as discussed in [*Chapter 1*](B18989_01.xhtml#_idTextAnchor015),
    *Learning about the Internals of Node.js*, is gone. Instead, Deno uses another
    event loop system called **Tokio**. Still, both runtimes use **V8** to actually
    run JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Tokio
  prefs: []
  type: TYPE_NORMAL
- en: Tokio is an asynchronous runtime for Rust applications providing everything
    needed for interacting with networks. It is reliable, fast, and flexible. Besides
    being Rust-native, one of the core reasons for Deno to use Tokio was that it is
    also quite easy to integrate. Tokio comes with I/O helpers, timers, filesystem
    access, synchronization, and scheduling capabilities, making it a complete libuv
    replacement. More information can be found at [https://tokio.rs/](https://tokio.rs/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of Deno is shown in *Figure 11**.1*. Notably, the diagram
    is almost an exact match for *Figure 1**.1*, which showed the architecture of
    Node.js. The most striking difference is the acceptance of TypeScript, which will
    be translated into JavaScript by a combination of `swc` (transpilation) and `tsc`
    (type checking). Another crucial difference is the additional isolation layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 11.1 – The architecture of Deno ](img/Figure_11.1_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The architecture of Deno
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of Deno can be done on the command line. For instance, on
    macOS and Linux, you can just run the following Shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas on Windows, you can use the PowerShell for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Alternative installations for common application package managers such as Scoop,
    Chocolatey, or Homebrew exist, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try Deno, you can run the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things happening already. First, we are not using a local
    source to run, but an address. Second, since this is an address, the source needs
    to be downloaded. Third, Deno always prefers to receive explicit versions, so
    it will complain that we just used whatever version of `stdlib` here. Instead,
    it redirects to the latest version, which was `0.159.0` at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you run the script again, you’ll just see the output without any
    download or warning. This is due to Deno’s cache. In order to stay well performing,
    every downloaded module is assumed to be immutable and will be cached locally.
    Future references will therefore not require another download, which makes their
    startup time acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big question is now: can Deno also just run Node.js libraries and applications?
    The unsatisfying answer is maybe. In theory, just JavaScript files can be used
    – however, Deno only supports ESM modules. Since many Node.js libraries are written
    using CommonJS, we would not have any success here.'
  prefs: []
  type: TYPE_NORMAL
- en: As mitigation, we could just transpile a package – bundle it into one file and
    run it without any trouble – but even then, we might face the issue of incompatibility
    with the ecosystem, as standard packages such as `fs` are available in Node.js
    but not in Deno.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way out of this is to use the *Node compatibility mode* of Deno. Before
    version *1.25*, it worked by running `deno` with the `--unstable` and `--compat`
    flags. Right now, Deno seems to only allow this via custom imports. Let’s try
    this out to see it in action. For this, you can create a new Node.js project with
    a single third-party package and some code using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this, the following code provides a solid basis:'
  prefs: []
  type: TYPE_NORMAL
- en: index.node.mjs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code uses a third-party dependency made for Node.js together with a Node.js
    core module. It also makes use of modern features such as top-level `await` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try running this with Node.js to see it working, but more interesting
    is the case of running this with Deno:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, by default, Deno requires explicit paths. Without them, Deno
    does not work. Let’s modify this code to reflect the compatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: index.deno.mjs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While the majority of the preceding code remains unchanged in comparison to
    `index.node.mjs`, the imports have been adapted slightly. The referenced npm packages
    need to be referenced using the `npm:` protocol. For Node.js core modules, we
    can refer to the `std/node` modules provided by Deno.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the code with the `–``unstable` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we did not provide any additional CLI flags, Deno will run in a mode where
    every resource request will be reflected by a question on the command line. In
    the session here, every request was confirmed with *yes*, granting the access
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could have used a Deno feature that we discussed already
    in [*Chapter 2*](B18989_02.xhtml#_idTextAnchor023), *Dividing Code into Modules
    and Packages*, while discussing import maps. Let’s try to run our *unmodified*
    file again with the following import map:'
  prefs: []
  type: TYPE_NORMAL
- en: importmap.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The job of the import map is to teach Deno what to look for. Originally, Deno
    could not make sense of an import to `axios`, but now it knows that this should
    be resolved via npm. Similarly, the core Node.js packages can be added in there,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we set the `--allow-all` flag to skip all the access confirmations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And… it just works. No more work needed – all done with Deno primitives. Of
    course, quite often full compatibility cannot be achieved so easily.
  prefs: []
  type: TYPE_NORMAL
- en: While Deno is mostly focused on security, a presumably even more interesting
    area is performance. This is where another alternative shines, which is called
    Bun.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bun for bundling web apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Deno seems quite different from Node.js on first glance, it also offers
    a lot of similarities. After all, both runtimes use V8 and can work with ESMs,
    but what if you want to be even more compatible with Node.js? Another approach
    is to be Node.js-compatible without using libuv or V8 at all. Enter **Bun**.
  prefs: []
  type: TYPE_NORMAL
- en: Bun is an alternative to Node.js that follows the approach of Deno in terms
    of developer friendliness. Here, tooling such as a npm client or an application
    bundler is also included out of the box. However, to speed things up significantly,
    Bun does not use libuv and V8\. Instead, Bun is created using the programming
    language **Zig** and uses **JavaScriptCore** as its JavaScript runtime. JavaScriptCore
    is also the runtime behind the **Webkit** browser engine, empowering browsers
    such as **Safari**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main benefits of Bun are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It comes with useful utilities out of the box, such as a bundler, a transpiler,
    a package manager, and a task runner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It outperforms Node.js, especially in terms of startup performance or request
    handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It embraces the Node.js ecosystem, but also includes some standard web APIs
    such as `fetch` or `WebSocket`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A comparison of the high-level architecture of Node.js and Bun is shown in
    *Figure 11**.2*. Most importantly, while extra tools such as a package manager
    or a bundler are required with Node.js, Bun comes with batteries already included.
    All these tools are available after installation – and since all of these tools
    are integrated into the Bun executable, they provide the best performance possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – High-level comparison of Node.js and Bun ](img/Figure_11.2_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – High-level comparison of Node.js and Bun
  prefs: []
  type: TYPE_NORMAL
- en: As with Deno, Bun can be installed via a Shell script. At the time of writing,
    Bun is not available as a direct installation for Windows. Instead, you’ll need
    to fall back to the **Windows Subsystem for Linux** (**WSL**) if you want to try
    out Bun.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Bun on macOS and Linux, you can run the following Shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Running a simple example (`hello.ts`) with Bun looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the code is really simple – just using the console
    output here:'
  prefs: []
  type: TYPE_NORMAL
- en: hello.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting aspect of Bun is that it also has the ability to automatically
    create a server. If we use a default export with a `fetch` function, then Bun
    will create a server, which, by default, runs on port `3000`. The port can also
    be changed by having another property called `port` in there:'
  prefs: []
  type: TYPE_NORMAL
- en: http.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Calling `bun run http.ts` will open the server. To see the result, go to the
    `http://localhost:3000` address using your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s use Bun as a bundler for the small demo project we did in [*Chapter
    6*](B18989_06.xhtml#_idTextAnchor057). The first thing you should notice is that
    you don’t need any development dependencies – just the runtime ones. Also, instead
    of running `npm install` or similar, you should resolve the dependencies via `bun
    install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Frankly, `react`, `react-dom`, `react-router-dom`, and `video.js` comprise
    only four packages, but their installation speed is still quite good. Now, it’s
    time to bundle the JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The result is quite different to the bundlers we’ve seen beforehand. We get
    a single file, `node_modules.bun`, which contains the resulting JavaScript, as
    well as all the associated metadata. The file itself is an executable – ready
    to spit out the contained code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting the JavaScript contained in the `node_modules.bun` file can be done
    by running the executable – and piping the output to a JavaScript file. For instance,
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Is this sufficient for all our bundling needs? Certainly not. Right now, the
    integrated bundler is essentially ignoring our code and only bundling together
    the code from the external packages sitting in the `node_modules` directory. However,
    even if our code was bundled, the process is not really ideal. Currently, Bun
    only considers JavaScript, TypeScript, JSON, and CSS files. There is no way to
    include assets such as images or videos.
  prefs: []
  type: TYPE_NORMAL
- en: For the future, all these capabilities are planned. While Bun (in version *0.1.13*)
    is still experimental technology, what is out there is promising. All things considered,
    it’s certainly something to keep on the radar, but nothing that can be actively
    used to create production-ready code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s recap what you’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned why alternatives to Node.js exists and what the
    most popular options are. You’ve explored what Deno is all about and how it distinguishes
    itself from Node.js. You’ve also seen an up-and-coming alternative with Bun.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with this knowledge, you are not only capable of writing tools that
    might be able to run in other runtimes than Node.js but you are also capable of
    deciding where your existing tools should run. Overall, this does not constrain
    you to the disadvantages of Node.js and gives you freedom to make the right choice
    aligned with the problem you want to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Epilogue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, it makes sense to view Node.js as a great helper for getting the
    job done. The whole ecosystem – from its module system to its command-line utilities
    and from its libraries to its frameworks – is vast. Almost every problem has been
    cracked and a solution has been published.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that with this book, you have a proper guide to walk you through the
    jungle of available helpers, making you not only a more efficient user of Node.js
    but also a contributor. While the existing tools are all helpful and powerful,
    they are certainly not the end of the line. Everyone has a unique view and things
    progress all the time. Don’t wait for somebody else to solve a problem – tackle
    it yourself and share your solution.
  prefs: []
  type: TYPE_NORMAL
- en: All the best!
  prefs: []
  type: TYPE_NORMAL
