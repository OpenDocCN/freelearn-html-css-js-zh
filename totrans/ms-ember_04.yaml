- en: Chapter 4. Writing Application Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to manage the states in Ember.js applications using routes,
    this chapter will help us master how to present application logic to users using
    templates. You will soon realize that the bulk of your application resides in
    templates. This being said, the chapter will frequently revisit what we already
    learned so far. Therefore, by the end of this chapter, the following concepts
    will be learned:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing binding template expressions and conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing contexts in templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating event listeners in templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing custom template helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As promised, we will continue to explore the chapter sample introduced in the
    previous chapter in the context of templates. When an application transitions
    into a state, each of the route handlers in that state path renders a template
    into the page. These templates are defined in the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, templates are registered using **script** tags of the `text/x-handlebars`
    type. The `id` or `data-template-name` attribute is used to identify the template.
    For instance, the chapter sample `contacts` template was defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note is that it''s wiser to identify templates using the `data-template-name`
    attribute instead of the `id` attribute, as the former is more likely to collide
    with other existing elements. Also, notice that the first template was not *identified*.
    This is because any unidentified template is considered as the `application` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Inserting templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed how a state in an application is composed
    of various routes whose handlers are sequentially called in order to perform various
    functions that make up this state. As a recap, when the user loaded the application
    in the chapter sample, the application transitioned into the `application` state.
    The `application` route handler then rendered its corresponding `application`
    template into the DOM. The next route handler to be called was the `contacts`
    route handler that also loaded and rendered its template into the `application`
    template. We already discussed that the `{{outlet}}` Handlebars expression was
    the portion of the `application` template that got swapped out. This process repeated
    itself until the application settled on the destination state.
  prefs: []
  type: TYPE_NORMAL
- en: As we will discuss later, a *parent* template can specify named outlets into
    which multiple *child* templates can be rendered. Route (not resource) handlers
    need not include this expression because they usually render the final template.
  prefs: []
  type: TYPE_NORMAL
- en: Writing out templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, Ember.js templates are written in the Handlebars ([www.handlebarsjs.com](http://www.handlebarsjs.com))
    syntax whose library was created by the same authors to simplify the creation
    of client-side templates. Handlebars is a powerful templating library that offers
    many features, which will be discussed in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just mentioned that templates are backed by data that is proxied by the
    corresponding controller. Handlebars walks down a template, replacing defined
    expressions with matching values obtained from this data. These expressions are
    usually variable names enclosed in curly braces. The `{{outlet}}` expression we
    just discussed is one such expression. In the chapter sample, the `contact.index`
    state is responsible for displaying a contact''s detail on the right-hand side
    of the page. In its corresponding template, we notice that the contact''s attributes
    are expressed using these expressions, but later get replaced, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, Handlebars finds the name expression, retrieves this
    variable from the provided model, and performs the swap. Handlebars always works
    in the provided controller context, which in turn proxies requests to its model.
    Therefore, the value used to swap the preceding expression is evaluated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This value can also be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the `name` variable reference request is made, Ember.js first checks
    if the controller defines the variable. Since this is not true, the controller
    *proxies* this request to its model.
  prefs: []
  type: TYPE_NORMAL
- en: Writing bound and unbound expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just learned that an expression is resolved by referencing the specified
    variable from the binding context. Ember.js goes further and makes these expressions
    *reactive*. This means that if the underlying variable changes, the replaced expression
    portion will also be updated. Sometimes, we might not want to suppress this behavior,
    especially when the variable is too large and constitutes unbound expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'These expressions only resolve once on render, and no further changes of the
    corresponding variable are subscribed. These expressions are written using three
    braces instead of two, as shown in the following example, where the main content
    of an Ember.js-powered blog post can be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Adding comments in templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comments in Handlebars have the `{{! … }}` signature. For example, we can add
    a documentation that signifies the end of a footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These expressions serve the same purpose as normal HTML comments, other than
    the fact that they are not actually converted to the latter. Therefore, a good
    reason to use them is when we don't want comments to appear in the rendered output.
  prefs: []
  type: TYPE_NORMAL
- en: Writing conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handlebars supports the `if`, `if...else`, `unless`, and `unless...else` conditionals.
    This means that we can render different portions of our templates based on specified
    conditions. They are block expressions that wrap template portions and usually
    begin and end with the `{{#` and `{{/` template tags, respectively. For example,
    if the user has no stored contacts in the `contacts` template of the chapter sample,
    the application will transition into the `contacts.new` state to force the user
    to add one. Therefore, we need to display a placeholder string in the now blank
    left-hand side of the page. We do this by checking whether the passed contact
    list is indeed empty, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The placeholder element is placed inside the `else` block. As illustrated,
    the block expression is only met when the value passed evaluates to `True`. Hence,
    the following values will result in the `else` block being rendered instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[] (empty array)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unless` expression, on the other hand, is only met when the variable evaluated
    is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Handlebars is `logic-less`, hence we cannot express conditions using
    the bitwise operators, as in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, however, define these conditions in the controller layer using computed
    properties or bindings. For example, the preceding samples can be implemented
    correctly as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Switching contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously discussed, Ember.js resolves expressions against the model context.
    The `{{#with}}...{{/with}}` helper allows us to specify the context to prioritize
    during the check. A good case is illustrated in the chapter sample, where we need
    to reuse the form used to create or update contacts. This form is contained in
    the `contacts/form` template. The only problem is that while the context of the
    `contacts/new` template is a newly created contact object, the `contact/edit`
    template has to reference the contact proxied by the contact controller. Thanks
    to the `with` helper and controller dependencies, we are able to change the context
    of the latter template as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will revisit this case when discussing the `partial` helper, but the important
    thing to note is that the main context is not the corresponding route handler
    model now, it is rather the `contact` controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `each` helper, we can create a new context without losing the
    existing one, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the two cases, the `email` field in the form, for example, will now need
    to bind to the contact context as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Rendering enumerable data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, applications will need to display enumerable data that can be accomplished
    using the `{{#each}} ... {{/each}}` block expression. For example, our `contacts`
    template used this expression to display the list of contacts on the left as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We left out the `link-to` expression, which we''ll discuss shortly. The `each`
    block expression switches the working context on each iteration, as discussed
    in the previous section. If we don''t wish to do so, we can specify the name of
    the current iteration object, as shown in the following reimplementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'One good thing about this block expression is that we can check if the iterator
    is empty using the `else` expression. For example, the use of the `else` and `if...else`
    expressions in our `contacts` template can be reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Writing template bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Writing bound and unbound expressions* section, we mentioned that the
    Ember.js Handlers library enables a variable defined in an expression to subscribe
    and, hence, updates to the changes of the bound context. The library also enables
    us to bind these variables to HTML element attributes, including classes using
    the `{{bind-attr .. }}` helper. In the following example, we define a link whose
    `href` property is bound to the provided user profile as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'By now we all know how the profile context will be provided by the route handler''s
    model hook. For example, if this is the application''s template, the corresponding
    route handler will provide the context as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting rendered template will then resemble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Every time the profile link changes, the link element's `href` property will
    automatically be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might also wish to toggle states in attributes, for example, the commonly
    used `required` and `disabled` attributes. A common use case is when we want to
    allow single clicks in e-commerce applications, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, when the user clicks on the checkout button, the checkout
    action should toggle the `isCheckedOut` property, which will result in the button
    being disabled. Therefore, attributes can be added or removed from DOM elements
    if the passed conditions become `True` or `False`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Element class names can also be dynamically updated in the same way, with a
    little difference in the binding behavior. For example, we might wish to add an
    `active` property to a clicked link in an application, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the context''s `selected` property evaluates to `active`, the link will
    be updated to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if the property becomes undefined, the link changes to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like an attribute''s presence can be updated dynamically, class names
    can also be inserted and removed from elements, depending on specified bound conditions.
    Hence, the preceding example can be reimplemented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, the element's class will be `active` and `inactive` when the context's
    `selected` property becomes `True` and `False`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'If only one argument is passed after the semicolon, the passed argument will
    be used as the class name instead. For example, the following code demonstrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following if the context''s `isSelected` property becomes `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also worth noting that `camelCase` class names get *dasherized*, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike other attributes, we can bind to multiple classes with the same signature,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we might want to use both bound and unbound classes in an element.
    The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, the unbound class names begin with a semicolon. Note that the following
    example won''t work since all the class names should be defined inside the `bind-attr`
    expression if one of them is bound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Defining route links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A typical Ember.js application has several routes that we might need to link
    to in templates. The `{{#link-to}}...{{/link-to}}` helper serves this purpose
    and lets the application create anchors to these routes easily. For example, the
    list on the left-hand side of our sample application is composed of links that
    the user can use to view the details of the various contacts. We use this helper
    to generate these links as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we inspect one of the generated links, we notice that it resembles the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The helper takes the route name as the first handler, followed by the resources
    needed by the corresponding route. As discussed in the previous chapter, since
    the path of the affected route has dynamic segments, its handler is responsible
    for resolving the required parameters to replace these segments. In this case,
    the `contact` route path has one dynamic segment, `contact_id`, which is used
    as discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to link to the blog route, we only need to specify the route name
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `bind-to` expression, the `link-to` expression also accepts other
    element attributes such as `rel`, `target`, or `class`. The following example
    opens the link in a new tab or window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Registering DOM element event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In vanilla JavaScript, an application script traverses the DOM, setting up
    event listeners along the way. A typical form might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Ember.js provides an abstraction over this, which allows developers to easily
    subscribe to element-specific events using the `{{action ...}}` helper. Our chapter
    contains such a form, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The function to call is usually defined in the `actions` property of the route
    and takes an unlimited number of arguments. By default, the default event type
    to bind to is usually the `click` event. However, you can specify this type using
    the `on` attribute. The `actions` property can be defined on either the corresponding
    route or controller. For example, the action handler for the preceding action
    was defined in the `contacts` route as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, this action can still be defined in the controller layer as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The main point to consider when deciding where to put an action is when we need
    to take advantage of the **bubbling** action. When an action is triggered, the
    function specified is looked up in the corresponding controller. If this action
    is defined, it gets executed. If the action is not defined, Ember.js performs
    the check in the corresponding route handler. If this action is defined in either
    controller or route handler and returns a value equal to `True`, Ember.js goes
    ahead and checks for a similar function in the parent route handlers, until one
    of them doesn't contain the function or does not define it.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important thing to note is that the bubbling action occurs in the route
    handler layer only. This is one of the reasons we will opt to define the function
    in the route handler. For example, since we should be able to call the `saveContact`
    action from both the `contacts.new` and `contact.edit` templates, we define it
    in the `contacts` route. Here''s an illustration of how the action is propagated
    in both cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering DOM element event listeners](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding action function can still be located in any controller if we
    specify the `target` object of the action. The `target` object contains the `actions`
    hash that Ember.js checks for the `action` function. By default, it is usually
    the corresponding controller of the template, as shown in the preceding figure.
    Therefore, we can define the `action` function in the `contact` controller, and
    then set the target as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Writing form inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing forms is a common practice that Ember.js simplifies by providing template
    helpers of the many HTML5 form controls. The following table shows these common
    controls and the attributes they can accept:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Control | Attributes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `input` | `value``size``name``pattern``placeholder``disabled``maxlength``tabindex`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `textarea` | `checked``disabled``tabindex``indeterminate``name` |'
  prefs: []
  type: TYPE_TB
- en: '| `checkbox` | `rows``cols``placeholder``disabled``maxlength``tabindex` |'
  prefs: []
  type: TYPE_TB
- en: 'In the sample application, the user is able to edit a contact by clicking on
    the **edit** button in the footer, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing form inputs](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the user edits the first name of the contact, we notice that their names
    are updated in the sidebar. The input helper is used in the `contacts/form` template
    to *bind* the input element''s value with the first name of the contact as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined four attributes that were either bound or unbound. A bound
    attribute gets updated each time the specified variable changes and vice versa.
    For example, in the preceding case, the `value` attribute was bound while the
    `required` attribute was not. Unbound attributes are quoted while those bound
    are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are more examples that show how to use the other two form helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Extending templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the course of application development, you might find the need to abstract
    templates for reuse. There are several helpers that can help us implement this
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '`partial`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`named outlets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `partial` helper is used to include templates inside others. It simply
    inserts the desired template where the `partial` expression has been specified.
    As discussed earlier, the chapter sample used this helper in two instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This helper takes the template that should be inserted into the current template
    as the only argument. One thing to note is that using the helper doesn't lead
    to the loss of context, as seen in the `contact/edit` case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might also wish to insert views inside other templates. In this case, the
    view''s template will be inserted into the specified portion of the current template
    and the defined event listeners will be set up. For example, the first name input
    we saw earlier can also be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will discuss this in more detail in [Chapter 6](part0069_split_000.html#page
    "Chapter 6. Views and Event Management"), *Views and Event Management*, where
    we will deal with views. The important thing to note here is that the input helpers
    named are actually Handlebars helpers defined from these views. We will discuss
    how these helpers are created in a moment. The `render` helper works in the same
    way as the `partial` helper, except that it takes an optional context as the second
    argument. For example, we will define the `contact/edit` and `contact/edit` templates
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Instead of switching the context in the first template, we simply passed the
    controller to be used as the context. Note that, by default, the context passed
    is the corresponding controller instance, and so we did not need to specify this
    context in the case of the `contacts/new` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last way to extend templates is by the use of named outlets we already
    discussed in the preceding chapter. Here is the example we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We then render the outlets via the handler as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It's very similar to how the `partial` helper is used, but in this case, we
    also specify the template in the route handler's `renderTemplate` hook.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handlebars provides ways to create your own helpers. The following is the format
    used to register new helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s create a `heading` helper that creates `h1` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be used in our application templates as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, yield the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example also demonstrates how to create helpers from existing
    views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This can now be used simply as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Creating subexpressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A subexpression, as the name suggests, is an expression contained in another
    expression, which takes the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example that implements a `Number.toFixed` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used inside a `link-to` helper as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This has been an exciting chapter that walked us through the template layer.
    This chapter will be revisited when we will discuss controllers in the next chapter.
    Here are the key concepts we learned and those that will be revisited in the next
    chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing binding template expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing conditionals in templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing contexts in templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating event listeners in templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing custom template helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
