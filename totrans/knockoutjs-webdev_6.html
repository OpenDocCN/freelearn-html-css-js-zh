<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Packaged Elegance"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Packaged Elegance</h1></div></div></div><p>First there was HTML and JavaScript, then CSS. Next came AJAX to usher in Web 2.0, as it is called. After that, templates drove us to a more dynamic, creative platform. The next advancement in web development was custom HTML components. KnockoutJS allows us to jump right in with some game-changing elegance for designers and developers. In this chapter, we will focus on:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An introduction to components</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bring Your Own Tags</strong></span> (<span class="strong"><strong>BYOT</strong></span>)</li><li class="listitem" style="list-style-type: disc">Enhancing attribute handling</li><li class="listitem" style="list-style-type: disc">Making your own libraries</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Asynchronous module definition</strong></span> (<span class="strong"><strong>AMD</strong></span>)—on <a id="id308" class="indexterm"/>demand resource loading</li><li class="listitem" style="list-style-type: disc">Component-based <span class="strong"><strong>Single-Page Applications</strong></span> (<span class="strong"><strong>SPA</strong></span>)</li></ul></div><p>This entire chapter is about packaging your code for reuse. Using these techniques, you can make your code more approachable and elegant.</p><div class="section" title="Introduction to components"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Introduction to components</h1></div></div></div><p>We hope<a id="id309" class="indexterm"/> you enjoyed learning about templates in the last chapter. Perhaps the best explanation of a component is a packaged template with an isolated ViewModel. Here is the syntax we would use to declare a <code class="literal">like</code> component on the page:</p><div class="informalexample"><pre class="programlisting">&lt;div data-bind="component: "like"''"&gt;&lt;/div&gt;</pre></div><p>If you are passing no parameters through to the component, this is the correct syntax. If you wish to pass parameters through, you would use a JSON style structure as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div data-bind="component:
{name: 'like-widget',params:{ approve: like} }"&gt;&lt;/div&gt;</pre></div><p>This would allow us to pass named parameters through to our custom component. In this case, we are passing<a id="id310" class="indexterm"/> a parameter named <code class="literal">approve</code>. This would mean we had a bound <code class="literal">viewModel</code> variable by the name of <code class="literal">like</code>. Look at how this would be coded. Create a page called <code class="literal">components.html</code> using the <code class="literal">_base.html</code> file to speed things up as we have done in all our other chapters. In your <code class="literal">script</code> section, create the following ViewModel:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
ViewModel = function(){
  self = this;
  self.like = ko.observable(true);
}
;
// insert custom component here
vm = new ViewModel();
ko.applyBindings(vm);
&lt;/script&gt;</pre></div><p>Now, we will create our custom component. Here is the basic component we will use for this first component. Place the code where the comment is, as we want to make sure it is added before our <code class="literal">applyBindings</code> method is executed:</p><div class="informalexample"><pre class="programlisting">ko.components.register('like-widget', {
  viewModel: function(params) {
    this.approve = params.approve;
    // Behaviors:
    this.toggle = function(){ 
      this.approve(!this.approve()); 
    }.bind(this);
  },
  template:
    '&lt;div class="approve"&gt;\
      &lt;button data-bind="click: toggle"&gt;\
        &lt;span data-bind="visible: approve" class="glyphicon  glyphicon-thumbs-up"&gt;&lt;/span&gt;\
        &lt;span data-bind="visible:! approve()" class="glyphicon  glyphicon-thumbs-down"&gt;&lt;/span&gt;\
      &lt;/button&gt;\
    &lt;/div&gt;'
});</pre></div><p>There are two sections to our components: the <a id="id311" class="indexterm"/>
<code class="literal">viewModel</code> and<a id="id312" class="indexterm"/> <code class="literal">template</code> sections. In the previous chapter, we learned how to use Knockout templates. In this chapter, we will be using those details inside the component.</p><p>The standard Knockout<a id="id313" class="indexterm"/> component passes variables to the component using the <code class="literal">params</code> structure. We can either use this structure or you could optionally use the <a id="id314" class="indexterm"/>
<span class="emphasis"><em>self = this</em></span> approach if desired. In addition to setting the variable structure, it is also possible to create behaviors for our components. If we look in the template code, we can see we have data-bound the click event to toggle the approve setting in our component. Then, inside the button, by binding to the visible trait of the <code class="literal">span</code> element, either the thumbs up or thumbs down image will be shown to the user. Yes, we are using a Bootstrap icon element rather than a graphic here. Here is a screenshot of the initial state:</p><div class="mediaobject"><img src="graphics/1028OS_06_01.jpg" alt="Introduction to components"/></div><p>When we click on the thumb image, it will toggle between the thumbs up and the thumbs down version. Since we also passed in the external variable that is bound to the page ViewModel, we see that the value in the matched span text will also toggle. Here is the markup we would add to the page to produce these results in the View section of our code:</p><div class="informalexample"><pre class="programlisting">&lt;div data-bind="component: {name: 'like-widget', params:{ approve: like} }"&gt;&lt;/div&gt;
&lt;span data-bind="text: like"&gt;&lt;/span&gt;</pre></div><p>You could build this type of functionality with a jQuery plugin as well, but it is likely to take a bit more code to do two-way binding and match the tight functionality we have achieved here. This doesn't mean jQuery plugins are bad, as this is also a jQuery-related technology. What it does mean is we have ways to do things even better. It is this author's opinion that features like this would still make great additions to the core jQuery library. Yet, I am not holding my breath waiting for them to adopt a Knockout-type project to the wonderful collection of projects they have at this point, and do not feel we should hold that against them. Keeping focused on what they do best is one of the reasons libraries like Knockout can provide a wider array of options. It seems the decisions are working on our behalf <a id="id315" class="indexterm"/>even if they are taking a different approach than I expected.</p><div class="section" title="Dynamic component selection"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Dynamic component selection</h2></div></div></div><p>You<a id="id316" class="indexterm"/> should have noticed when we selected the component that we did so using a quoted declaration. While at first it may seem to be more constricting, remember that it is actually a power feature. By using a variable instead of a hardcoded value, you can dynamically select the component you would like to be inserted. Here is the markup code:</p><div class="informalexample"><pre class="programlisting">&lt;div data-bind="component: { name: widgetName, params: widgetParams }"&gt;&lt;/div&gt;
&lt;span data-bind="text:widgetParams.approve"&gt;&lt;/span&gt;</pre></div><p>Notice that we are passing in both <code class="literal">widgetName</code> as well as <code class="literal">widgetParams</code>. Because we are binding the structure differently, we also need to show the bound value differently in our span. Here is the <code class="literal">script</code> part of our code that needs to be added to our <code class="literal">viewModel</code> code:</p><div class="informalexample"><pre class="programlisting">  self.widgetName = ko.observable("like-widget");
  self.widgetParams = {
    approve: ko.observable(true)
  };</pre></div><p>We will get the same visible results but notice that each of the like buttons is acting independent of the other. What would happen if we put more than one of the same elements on the page? If we do that, Knockout components will act independent of other components. Well, most of the time they act independent. If we bound them to the same variable they would not be independent. In your <code class="literal">viewModel</code> declaration code, add another variable called <code class="literal">like2</code> as follows:</p><div class="informalexample"><pre class="programlisting">self.like2 = ko.observable(false);</pre></div><p>Now, we will add another like button to the page by copying our first like View code. This time, change the value from <code class="literal">like</code> to <code class="literal">like2</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;like-widget params="approve: like2"&gt;&lt;/like-widget&gt;
&lt;span data-bind="text: like2"&gt;&lt;/span&gt;</pre></div><p>This time when the page loads, the other likes display with a thumbs up, but this like will display with a thumbs down. The text will also show <span class="strong"><strong>false</strong></span> stored in the bound value. Any of the like buttons will act independently because each of them is bound to unique values. Here is a screenshot of the third button:</p><div class="mediaobject"><img src="graphics/1028OS_06_02.jpg" alt="Dynamic component selection"/></div></div><div class="section" title="Bring Your Own Tags (BYOT)"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Bring Your Own Tags (BYOT)</h2></div></div></div><p>What is an element? Basically, an<a id="id317" class="indexterm"/> element<a id="id318" class="indexterm"/> is a component that you reach using the tag syntax. This is the way it is expressed in the official documentation at this point and it is likely to stay that way. It is still a component under the hood. Depending on the crowd you are in, this distinction will be more or less important. Mostly, just be aware of the distinction in case someone feels it is important, as that will let you be on the same page in discussions. Custom tags<a id="id319" class="indexterm"/> are a part of the forthcoming HTML feature called Web Components. Knockout allows you to start using them today. Here is the View code:</p><div class="informalexample"><pre class="programlisting">&lt;like-widget params="approve: like3"&gt;&lt;/like-widget&gt;
&lt;span data-bind="text: like3"&gt;&lt;/span&gt;</pre></div><p>You may want to code some tags with a single tag rather than a double tag, as in an opening and closing tag syntax. Well, at this time, there are challenges getting each browser to see the custom element tags when declared as a single tag. This means custom tags, or elements, will need to be declared as opening and closing tags for now.</p><p>We will also need to create our <code class="literal">like3</code> bound variable for <code class="literal">viewModel</code> with the following code:</p><div class="informalexample"><pre class="programlisting">self.like3 = ko.observable(true);</pre></div><p>Running the code gives us the same wonderful functionality as our <code class="literal">data-bind</code> approach, but now we are creating our own HTML tags. Has there ever been a time you wanted a special HTML tag that just didn't exist? There is a chance you could create that now using Knockout component element-style coding.</p></div></div></div>
<div class="section" title="Enhancing attribute handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Enhancing attribute handling</h1></div></div></div><p>Now,<a id="id320" class="indexterm"/> while custom tags are awesome, there is just something different about passing everything in with a single param attribute. The reason for this is that this process matches how our tags work when we are using the <code class="literal">data-bind</code> approach to coding. In the following example, we will look at passing things in via individual attributes. This is not meant to work as a <code class="literal">data-bind</code> approach, but it is focused completely on the custom tag element component.</p><p>The first <a id="id321" class="indexterm"/>thing you want to do is make sure this enhancement doesn't cause any issues with the normal elements. We did this by checking the custom elements for a standard prefix. You do not need to work through this code as it is a bit more advanced. The easiest thing to do is to include our Knockout components tag with the following <code class="literal">script</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;script src="/share/js/knockout.komponents.js"&gt;&lt;/script&gt;</pre></div><p>In this tag, we have this code segment to convert the tags that start with <code class="literal">kom-</code> to tags that use individual attributes rather than a JSON translation of the attributes. Feel free to borrow the code to create libraries of your own. We are going to be creating a standard set of libraries on GitHub for these component tags. Since the HTML tags are Knockout components, we are calling these libraries "KOmponents". The<a id="id322" class="indexterm"/> resource can be found at <a class="ulink" href="https://github.com/sosensible/komponents">https://github.com/sosensible/komponents</a>.</p><p>Now, with that library included, we will use our View code to connect to the new tag. Here is the code to use in the View:</p><div class="informalexample"><pre class="programlisting">&lt;kom-like approve="tagLike"&gt;&lt;/kom-like&gt;
&lt;span data-bind="text: tagLike"&gt;&lt;/span&gt;</pre></div><p>Notice that in our HTML markup, the tag starts with the library prefix. This will also require <code class="literal">viewModel</code> to have a binding to pass into this tag as follows:</p><div class="informalexample"><pre class="programlisting">self.tagLike = ko.observable(true);</pre></div><p>The following is the code for the actual "attribute-aware version" of Knockout components. Do not place this in the code as it is already included in the library in the shared directory:</p><div class="informalexample"><pre class="programlisting">// &lt;kom-like /&gt; tag
ko.components.register('kom-like', {
  viewModel: function(params) {
    // Data: value must but true to approve
    this.approve = params.approve;
    // Behaviors:
    this.toggle = function(){ 
      this.approve(!this.approve()); 
    }.bind(this);
  },
  template:
    '&lt;div class="approve"&gt;\
      &lt;button data-bind="click: toggle"&gt;\
        &lt;span data-bind="visible: approve" class="glyphicon glyphicon-thumbs-up"&gt;&lt;/span&gt;\
        &lt;span data-bind="visible:! approve()" class="glyphicon glyphicon-thumbs-down"&gt;&lt;/span&gt;\
      &lt;/button&gt;\
    &lt;/div&gt;'
});</pre></div><p>The tag in the<a id="id323" class="indexterm"/> View changed as we passed the information in via named attributes and not as a JSON structure inside a param attribute. We also made sure to manage these tags by using a prefix. The reason for this is that we did not want our fancy tags to break the standard method of passing params commonly practiced with regular Knockout components.</p><p>As we see, again we have another functional component with the added advantage of being able to pass the values in a style more familiar to those used to coding with HTML tags.</p></div>
<div class="section" title="Building your own libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Building your own libraries</h1></div></div></div><p>Again, we <a id="id324" class="indexterm"/>are calling our custom components KOmponents. We will be creating a number of library solutions over time and welcome others to join in. Tags will not do everything for us, as there are some limitations yet to be conquered. That doesn't mean we wait for all the features before doing the ones we can for now. In the previous chapter, we showed a <code class="literal">KOmponent</code> tag for using templates. That is also included in the base KOmponent library.</p><p>In this segment of the chapter, we will also be showing some tags from our Bootstrap <code class="literal">KOmponents</code> library. First we will need to include the Bootstrap <code class="literal">KOmponents</code> library:</p><div class="informalexample"><pre class="programlisting">&lt;script src="/share/js/knockout.komponents.bs.js"&gt;&lt;/script&gt;</pre></div><p>Above <code class="literal">viewModel</code> in our script, we need to add a function to make this section of code simpler. At times, when passing items into observables, we can pass in richer bound data using a function like this. Again, create this function above the <code class="literal">viewModel</code> declaration of the script, shown as follows:</p><div class="informalexample"><pre class="programlisting">var listItem = function(display, students){
  this.display = ko.observable(display);
  this.students = ko.observable(students);
  this.type = ko.computed(function(){
    switch(Math.ceil(this.students()/5)){
      case 1:
      case 2:
        return 'danger';
        break;
      case 3:
        return 'warning';
        break;
      case 4:
        return 'info';
        break;
      default:
        return 'success';
    }
  },this);
};</pre></div><p>Now, inside<a id="id325" class="indexterm"/> <code class="literal">viewModel</code>, we will declare a set of data to pass to a Bootstrap style <code class="literal">listGroup</code> as follows:</p><div class="informalexample"><pre class="programlisting">self.listData = ko.observableArray([
  new listItem("HTML5",12),
  new listItem("CSS",8),
  new listItem("JavaScript",19),
  new listItem("jQuery",48),
  new listItem("Knockout",33)
]);</pre></div><p>Each item in our array will have display, students, and type variables. We are using a number of features in Bootstrap here but packaging them all up inside our Bootstrap smart tag. This tag starts to go beyond the bare basics. It is still very implementable, but we don't want to throw too much at you to absorb at one time, so we will not go into the detailed code for this tag. What we do want to show is how much power can be wrapped into custom Knockout tags. Here is the markup we will use to call this tag and bind the correct part of <code class="literal">viewModel</code> for display:</p><div class="informalexample"><pre class="programlisting">&lt;kom-listgroup data="listData" badgeField="'students'" typeField="'type'"&gt;&lt;/kom-listgroup&gt;</pre></div><p>That is it. You should take note of a couple of special details. The data is passed in as a bound Knockout ViewModel. The badge field is passed in as a string name to declare the field on the data collection where the badge count will be pulled. The same string approach has been used for the type field. The type will set the colors as per standard Bootstrap types. The <a id="id326" class="indexterm"/>theme here is that if there are not enough students to hold a class, then it shows the danger color in the list group custom tag. Here is what it looks like in the browser when we run the code:</p><div class="mediaobject"><img src="graphics/1028OS_06_03.jpg" alt="Building your own libraries"/></div><p>While this is neat, let's jump into our browser tools console and change the value of one of the items. Let's say there was a class on some cool web technology called jQuery. What if people had not heard of it and didn't know what it was and you really wanted to take the class? Well, it would be nice to encourage a few others to check it out. How would you know whether the class was at a danger level or not? Well, we could simply use the badge and the numbers, but how awesome is it to also use the color coding hint? Type the following code into the console and see what changes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>vm.listData()[3].display()</strong></span>
</pre></div><p>Because JavaScript starts counting with zero for the first item, we will get the following result:</p><div class="mediaobject"><img src="graphics/1028OS_06_04.jpg" alt="Building your own libraries"/></div><p>Now we know <a id="id327" class="indexterm"/>we have the right item, so let's set the student count to nine using the following code in the browser console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>vm.listData()[3].students(9)</strong></span>
</pre></div><p>Notice the change in the jQuery class. Both the badge and the type value have updated. This screenshot of the update shows how much power we can wield with very little manual coding:</p><div class="mediaobject"><img src="graphics/1028OS_06_05.jpg" alt="Building your own libraries"/></div><p>We should also take a moment to see how the type was managed. Using the functional assignment, we were able to use the Knockout computed binding for that value. Here is the code for that part again:</p><div class="informalexample"><pre class="programlisting">this.type = ko.computed(function(){
  switch(Math.ceil(this.students()/5)){
    case 1:
    case 2:
      return 'danger';
      break;
    case 3:
      return 'warning';
      break;
    case 4:
      return 'info';
      break;
    default:
      return 'success';
  }
},this);</pre></div><p>While the <a id="id328" class="indexterm"/>code is outside the <code class="literal">viewModel</code> declaration, it is still able to bind properly to make our code run even inside a custom tag created with Knockout's component binding.</p><div class="section" title="Bootstrap component example"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Bootstrap component example</h2></div></div></div><p>Here is<a id="id329" class="indexterm"/> another example of binding with Bootstrap. The general best practice for using modal display boxes is to place them higher in the code, perhaps under the <code class="literal">body</code> tag, to make sure there are no conflicts with the rest of the code. Place this tag right below the <code class="literal">body</code> tag as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;kom-modal id="'komModal'" title="komModal.title()" body="komModal.body()"&gt;&lt;/kom-modal&gt;</pre></div><p>Again, we will need to make some declarations inside <code class="literal">viewModel</code> for this to work right. Enter this code into the declarations of <code class="literal">viewModel</code>:</p><div class="informalexample"><pre class="programlisting">self.komModal = {
  title: ko.observable('Modal KOMponent'),
  body: ko.observable('This is the body of the &lt;strong&gt;modal KOMponent&lt;/strong&gt;.')
};</pre></div><p>We will also create a button on the page to call our <code class="literal">viewModel</code>. The button will use the binding that is part of Bootstrap. The <code class="literal">data-toggle</code> and <code class="literal">data-target</code> attributes are not Knockout binding features. Knockout works side-by-side wonderfully though. Another point of interest is the standard ID attribute, which tells how Bootstrap items, like this button, interact with the modal box. This is another reason it may be beneficial to use KOmponents or a library like it. Here is the markup code:</p><div class="informalexample"><pre class="programlisting">&lt;button type="button" data-toggle="modal" data- target="#komModal"&gt;Open Modal KOmponent&lt;/button&gt;</pre></div><p>When<a id="id330" class="indexterm"/> we click on the button, this is the requestor we see:</p><div class="mediaobject"><img src="graphics/1028OS_06_06.jpg" alt="Bootstrap component example"/></div><p>Now, to understand the power of Knockout working with our requestor, head back over to your browser tools console. Enter the following command into the prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>vm.komModal.body("Wow, live data binding!")</strong></span>
</pre></div><p>The following screenshot shows the change:</p><div class="mediaobject"><img src="graphics/1028OS_06_07.jpg" alt="Bootstrap component example"/></div><p>Who knows what type of creative modular boxes we can build using this type of technology. This<a id="id331" class="indexterm"/> brings us closer towards creating what we can imagine. Perhaps it may bring us closer to building some of the wild things our customers imagine. While that may not be your main motivation for using Knockout, it would be nice to have a few less roadblocks when we want to be creative. It would also be nice to have this wonderful ability to package and reuse these solutions across a site without using copy and paste and searching back through the code when the client makes a change to make updates.</p><p>Again, feel free to look at the file to see how we made these components work. They are not extremely complicated once you get the basics of using Knockout and its components. If you are looking to build components of your own, they will help you get some insight on how to do things inside as you move your skills to the next level.</p></div></div>
<div class="section" title="Understanding the AMD approach"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Understanding the AMD approach</h1></div></div></div><p>We are <a id="id332" class="indexterm"/>going to look into the concept of what makes an AMD-style website. The point of this approach to sites is to pull content on demand. The content, or modules as they are defined here, does not need to be loaded in a particular order. If there are pieces that depend on other pieces, that is, of course, managed. We will be using the <span class="emphasis"><em>RequireJS</em></span> library to manage this part of our code.</p><p>We will create four files in this example, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">amd.html</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">amd.config.js</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">pick.js</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">pick.html</code></li></ul></div><p>In our AMD page, we are going to create a configuration file for our RequireJS functionality. That will be the <code class="literal">amd.config.js</code> file mentioned in the aforementioned list. We will start by creating this file with the following code:</p><div class="informalexample"><pre class="programlisting">// require.js settings
var require = {
    baseUrl: ".",
    paths: {
        "bootstrap":        "/share/js/bootstrap.min",
        "jquery":           "/share/js/jquery.min",
        "knockout":         "/share/js/knockout",
        "text":             "/share/js/text"
    },
    shim: {
        "bootstrap": { deps: ["jquery"] },
        "knockout": { deps: ["jquery"] },
    }
};</pre></div><p>We see here that <a id="id333" class="indexterm"/>we are creating some alias names and setting the paths these names point to for this page. The file could, of course, be working for more than one page, but in this case, it has specifically been created for a single page. The configuration in RequireJS does not need the <code class="literal">.js</code> extension on the file names, as you would have noted.</p><p>Now, we will look at our <code class="literal">amd.html</code> page where we pull things together. We are again using the standard page we have used for this course, which you will notice if you preview the <code class="literal">done</code> file example of the code. There are a couple of differences though, because the JavaScript files do not all need to be called at the start. RequireJS handles this well for us. We are not saying this is a standard practice of AMD, but it is an introduction of the concepts.</p><p>We will need to include the following three script files in this example:</p><div class="informalexample"><pre class="programlisting">&lt;script src="/share/js/knockout.js"&gt;&lt;/script&gt;
&lt;script src="amd.config.js"&gt;&lt;/script&gt;
&lt;script src="/share/js/require.js"&gt;&lt;/script&gt;</pre></div><p>Notice that the configuration settings need to be set before calling the <code class="literal">require.js</code> library. With that set, we can create the code to wire Knockout binding on the page. This goes in our <code class="literal">amd.html</code> script at the bottom of the page:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
ko.components.register('pick', {
  viewModel: { require: 'pick' },
  template: { require: 'text!pick.html' }
});
viewModel = function(){
  this.choice = ko.observable();
}
vm = new viewModel();
ko.applyBindings(vm);
&lt;/script&gt;</pre></div><p>Most of this code should look very familiar. The difference is that the external files are being used to set the content for <code class="literal">viewModel</code> and <code class="literal">template</code> in the <code class="literal">pick</code> component. The <code class="literal">require</code> setting smartly knows to include the <code class="literal">pick.js</code> file for the <code class="literal">pick</code> setting. It does need to be passed as a string, of course. When we include the template, you will see that we use <code class="literal">text!</code> in front of the file we are including. We also declare the extension on the file name in this case. The text method actually needs to know where the text is coming from, and you will see in our <code class="literal">amd.config.js</code> file that we created an alias for the inclusion of the text function.</p><p>Now, we will <a id="id334" class="indexterm"/>create the <code class="literal">pick.js</code> file and place it in the same directory as the <code class="literal">amd.html</code> file. It could have been in another directory, and you would have to just set that in the component declaration along with the filename. Here is the code for this part of our AMD component:</p><div class="informalexample"><pre class="programlisting">define(['knockout'], function(ko) {
    function LikeWidgetViewModel(params) {
        this.chosenValue = params.value;
        this.land = Math.round(Math.random()) ? 'heads' : 'tails';
    }
    LikeWidgetViewModel.prototype.heads = function() {
        this.chosenValue('heads');
    };
    LikeWidgetViewModel.prototype.tails = function() {
        this.chosenValue('tails');
    };
    return LikeWidgetViewModel;
});</pre></div><p>Notice that our code starts with the <code class="literal">define</code> method. This is our AMD functionality in place. It is saying that before we try to execute this section of code we need to make sure the Knockout library is loaded. This allows us to do on-demand loading of code as needed. The code inside the <code class="literal">viewModel</code> section is the same as the other examples we have looked at with one exception. We return <code class="literal">viewModel</code> as you see at the end of the preceding code. We used the shorthand code to set the value for <code class="literal">heads</code> and <code class="literal">tails</code> in this example.</p><p>Now, we will look at our template file, <code class="literal">pick.html</code>. This is the code we will have in this file:</p><div class="informalexample"><pre class="programlisting">&lt;div class="like-or-dislike" data-bind="visible: !chosenValue()"&gt;
&lt;button data-bind="click: heads"&gt;Heads&lt;/button&gt;
&lt;button data-bind="click: tails"&gt;Tails&lt;/button&gt;
&lt;/div&gt;
&lt;div class="result" data-bind="visible: chosenValue"&gt;
    You picked &lt;strong data-bind="text: chosenValue"&gt;&lt;/strong&gt;
    The correct value was &lt;strong data-bind="text: land"&gt;&lt;/strong&gt;
&lt;/div&gt;</pre></div><p>This template <a id="id335" class="indexterm"/>follows the same concepts as the ones we looked at in the previous chapter. There is nothing special other than the code needed to make this example work. The goal is to allow a custom tag to offer up heads or tails options on the page. We also pass in a bound variable from <code class="literal">viewModel</code>. We will be passing it into three identical tags.</p><p>The tags are actually going to load the content instantly in this example. The goal is to get familiar with how the code works. We will take it to full practice at the end of the chapter. Right now, we will put this code in the View segment of our <code class="literal">amd.html</code> page:</p><div class="informalexample"><pre class="programlisting">&lt;h2&gt;One Choice&lt;/h2&gt;
&lt;pick params="value: choice"&gt;&lt;/pick&gt;&lt;br&gt;
&lt;pick params="value: choice"&gt;&lt;/pick&gt;&lt;br&gt;
&lt;pick params="value: choice"&gt;&lt;/pick&gt;</pre></div><p>Notice that we have included the <code class="literal">pick</code> tag three times. While we are passing in the bound choice item from <code class="literal">viewModel</code>, each tag will randomly choose heads or tails. When we run the code, this is what we will see:</p><div class="mediaobject"><img src="graphics/1028OS_06_08.jpg" alt="Understanding the AMD approach"/></div><p>Since we passed the same bound item into each of the three tags, when we click on any heads or tails set, it will immediately pass that value out to <code class="literal">viewModel</code>, which will in turn immediately pass the<a id="id336" class="indexterm"/> value back into the other two tag sets. They are all wired together through <code class="literal">viewModel</code> binding being the same variable. This is the result we get if we click on <span class="strong"><strong>Tails</strong></span>:</p><div class="mediaobject"><img src="graphics/1028OS_06_09.jpg" alt="Understanding the AMD approach"/></div><p>Well, it is the results we got that time. Actually, the results change pretty much every time we refresh the page. Now, we are ready to do something extra special by combining our AMD approach with Knockout modules.</p></div>
<div class="section" title="Component-based SPAs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Component-based SPAs</h1></div></div></div><p>Now, we can look at one of the fastest growing trends in web development, the concept of <a id="id337" class="indexterm"/>single-page applications. The name is fancier than the practice because it is wrapped in confusion, but we will help you get over that here.</p><p>First, think of your website as a computer or mobile device. You can put multiple applications on your system. The apps can work together or independently. While we understand this for our computing systems, we seem to get confused when we move to web servers. Everything is not one application, or better put, rarely should everything be one application. There was a day, before Windows, when your spreadsheet and your word processor were shipped as one application. This was very popular, but over time we figured out packaging two apps was smarter than trying to build cross functionality into one app. Thus, we created office suites.</p><p>Today, we<a id="id338" class="indexterm"/> are suffering from the effects of mistakes made on most server platforms. When our backend server languages were created, many of them created a packaging approach that was wrapped around the term "application". So, when you built a website with a shopping cart, forum, and blog, they all ran under the same application scope. In hindsight, we should have labeled these site scopes and sub-divided the shopping "application", the forum "application", and the blog "application" as items under the "site".</p><p>Single-page applications seem to be having the same folly. The architecture and naming conventions tend to cause confusion. As a fellow seasoned developer, let me be vain for a moment and give you my permission to think outside the box on this. Forget the name SPA for a moment and let's step back and just understand what it does. Once you understand what it does, you will be able to smartly figure out how to apply it. Good implementation is after all, or it should be, the goal.</p><div class="section" title="Best development strategies"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Best development strategies</h2></div></div></div><p>There are<a id="id339" class="indexterm"/> many goals connected to the best development strategies. The truth is that there is no single best strategy. It is <a id="id340" class="indexterm"/>similar to the truth commonly shared as an answer in tech circles: it depends. This means the first thing you need to know is the target needs before you figure out what fits the best. Some people get caught up thinking bleeding-edge solutions are the best strategies. Sometimes they are, but not universally. It should be a heads-up, wide awake decision. The truth is that unless we are getting business done, technology doesn't add anything to the picture.</p><p>Technology is powerful. Technology is about knowing. If we properly understand the challenges then we can better choose our technology, our methodologies, and our solutions. Sometimes we may choose Knockout and other times just stay with jQuery. Sometimes, we bring in other mixes of products such as RequireJS and more.</p><div class="section" title="Getting real"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec05"/>Getting real</h3></div></div></div><p>Another thing<a id="id341" class="indexterm"/> we should avoid is trying to apply technology we have never actually used anywhere. This is a high-stakes gamble, and this is why I hope you have been doing the code examples as you go through this book.</p><p>We are now going to create a solution, by popular name, an SPA, using Knockout and its components to drive the views. Because the concept is called SPA, we will call these dynamically loaded views "pages". We will be building on the AMD concept of dynamically loaded content using a few other SPA concepts as well. The goal here is not to teach you all the ins and outs of SPAs, but this will give you a pretty good launching point if you have never jumped in before.</p><p>Our page content, code<a id="id342" class="indexterm"/> if you prefer, will be sectioned off into a pages directory with each page having its template and <code class="literal">viewModel</code> in separate files. Earlier, we repeated the template and the ViewModel for on-page components. This time, we will be using components for on-page content as well as for declaring the main view content using components. For clarity, we have created a <code class="literal">components</code> folder for the non-page components; for instance, the navigation bar will be put in the <code class="literal">components</code> folder.</p><p>What makes an SPA fit for the basic description of a single page is that the browser only loads a base page at a time. After that, all content is pulled and injected into the page. So it is technically correct that there be only one page. The display of content on the page is loaded and updated on the fly, but technically speaking, it is still on the original page. This will be our <code class="literal">index.html</code> file. If you look in your exercise root folder, you will see a subdirectory called <code class="literal">spa</code> and another called <code class="literal">myspa</code>.</p><p>If you want to see a completed SPA, you can peek ahead and look at the SPA version. My suggestion is to build it up and take the discovery route. Only then compare it to the SPA version if you feel like you made a mistake. Here is a screenshot of our starting point with our <code class="literal">myspa</code> example:</p><div class="mediaobject"><img src="graphics/1028OS_06_10.jpg" alt="Getting real"/></div><p>This looks rather plain, but it is actually more complex than you would think. Power tools often look unimpressive while sitting on the shelf. It is worth looking at the code of the home page. Here is the View or the template file for the page:</p><div class="informalexample"><pre class="programlisting">&lt;h2&gt;Home&lt;/h2&gt;
&lt;p data-bind=: message'"html"&gt;&lt;/p&gt;</pre></div><p>Normally, when we<a id="id343" class="indexterm"/> look in Knockout for the binding data, we are looking for the base <code class="literal">viewModel</code> data. In this case, we are looking at the data contained in the <code class="literal">viewModel</code> component. Let's look at the code of the component and see where it comes from by looking for our message variable:</p><div class="informalexample"><pre class="programlisting">define(["knockout", "text!./view.html"], function(ko, homeTemplate) {
  function myViewModel(route) {
    this.message = ko.observable('This is dynamic content presented on the home page.');
  console.log(vmSPA);
  }
  return { viewModel: myViewModel, template: homeTemplate };
});</pre></div><p>We see the <code class="literal">define</code> method here again, which tells us we are taking care of dependencies properly using RequireJS. We see in the <code class="literal">myViewModel</code> section of code the <code class="literal">viewModel</code> attribute message. Remember to use the <code class="literal">this</code> type scope or the attributes will not be properly bound and visible on <code class="literal">viewModel</code>.</p><p>We are just getting exposed to the tools of SPA sites and pages. While it may not be amazing yet, the beauty will present itself as you learn to use the tools here. It's like looking at the paint brushes of great artists. You would not have been able to predict the amazing paintings that came from them. It's time to teach you how to use the tools that create powerful SPA solutions and improve your mastery over web development.</p></div></div><div class="section" title="Coding time"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Coding time</h2></div></div></div><p>The first thing<a id="id344" class="indexterm"/> we will look at is our single page where everything is presented. Here is the code for the super-duper everything page:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;title&gt;SPA Guide&lt;/title&gt;
  &lt;link href="/share/css/bootstrap.min.css" rel="stylesheet"&gt;
  &lt;link href="css/styles.css" rel="stylesheet"&gt;
  &lt;script src="app/require.config.js"&gt;&lt;/script&gt;
  &lt;script data-main="app/startup" src="/share/js/require.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="page" class="container" data-bind="component: { name: route().page, params: route }"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>We see two JavaScript files here. The first is a configuration file and the second is the RequireJS file. That <a id="id345" class="indexterm"/>is not all the JavaScript requires, but the RequireJS file will manage pulling in the core libraries needed for this site to run properly. This is contained in the configuration file. Let's take a look at that file:</p><div class="informalexample"><pre class="programlisting">// require.js looks for the following global when initializing
var require = {
    baseUrl: ".",
    paths: {
        "bootstrap":            "/share/js/bootstrap.min",
        "crossroads":           "/share/js/crossroads.min",
        "hasher":               "/share/js/hasher.min",
        "jquery":               "/share/js/jquery.min",
        "knockout":             "/share/js/knockout",
        "knockout-projections": "/share/js/knockout-projections.min",
        "signals":              "/share/js/signals.min",
        "text":                 "/share/js/text"
    },
    shim: {
        "bootstrap": { deps: ["jquery"] }
    }
};</pre></div><p>This is the same kind of logic we used in our AMD example previously. You will notice that we are using several libraries in our code here. RequireJS handles much of the loading on demand, or as needed, if you prefer to state it that way.</p><p>You will also notice that in the <code class="literal">body</code> section of the <code class="literal">index.html</code> page there is a Knockout bound <code class="literal">div</code> element like this:</p><div class="informalexample"><pre class="programlisting">&lt;div id="page" class="container" data-bind="component: { name: route().page, params: route }"&gt;&lt;/div&gt;</pre></div><p>This is how we pull the page content and drive it to the View for the user. If you are new to this kind of app, there is something that will appear to be missing. There is another file that is actually being called that is not immediately apparent. Look at the <code class="literal">script</code> tag that calls <code class="literal">require.js</code> into the page:</p><div class="informalexample"><pre class="programlisting">&lt;script data-main="app/startup" src="/share/js/require.js"&gt;&lt;/script&gt;</pre></div><p>Notice the <code class="literal">data-main</code> attribute binding. This tells the page to load in the <code class="literal">starup.js</code> file from the <code class="literal">app</code> folder. Let's look at that file here:</p><div class="informalexample"><pre class="programlisting">define(['jquery', 'knockout', './router', 'bootstrap', 'knockout- projections'], function($, ko, router) {
  // General Components (can be packaged as AMD modules):
  // dynamic page components
  ko.components.register('home-page', { require: 'page/home/home' });
  // static page components
  // Start the application
  vmSPA = function() { 
    this.route = router.currentRoute;
  };
  vm = new vmSPA();
  ko.applyBindings(vm);});</pre></div><p>We see<a id="id346" class="indexterm"/> the <code class="literal">RequireJS define</code> method, and there is no return needed as the functionality here is to make sure things are bound right with Knockout. You will also see that it is declaring all the libraries it needs upfront, based on the array list with the settings in our <code class="literal">require.config.js</code> file.</p><p>The next thing you will see is the dynamic page components being registered. We only have one page at this time, so if you look in the <code class="literal">page</code>/<code class="literal">home</code> folder, you will see <code class="literal">home.js</code> and <code class="literal">view.html</code> as the files located there. We will look at those shortly, but they are the <code class="literal">viewModel</code> and <code class="literal">template</code> items for our page component.</p><p>Another aspect common to most SPAs is routing. The other JavaScript libraries handle this, and that is what is being bound to our global binding via the <code class="literal">route</code> attribute. All of this working together called that "less-than-awesome" page in the previous screenshot. The <code class="literal">router</code> file is the last piece of core pieces we need to work with as we build out, expanding our SPA. Let's look at its code:</p><div class="informalexample"><pre class="programlisting">define(["knockout", "crossroads", "hasher"], function(ko, crossroads, hasher) {
  
  return new Router({
    routes: [
      { url: '', params: { page: 'home-page' } }
    ]
  });
  function Router(config) {
    var currentRoute = this.currentRoute = ko.observable({});
    ko.utils.arrayForEach(config.routes, function(route) {
      crossroads.addRoute(route.url, function(requestParams) {
      currentRoute(ko.utils.extend(requestParams, route.params));
    });
  });
  activateCrossroads();
  }
  function activateCrossroads() {
          function parseHash(newHash, oldHash) { 
                crossroads.parse(newHash); 
          }
    crossroads.normalizeFn = crossroads.NORM_AS_OBJECT;
    hasher.initialized.add(parseHash);
    hasher.changed.add(parseHash);
    hasher.init();
  }
});</pre></div><p>Again, we see the<a id="id347" class="indexterm"/> <code class="literal">define</code> method in action here, keeping dependencies properly managed. There is also the routing which includes routes, or will include routes. At this time, there is only one route, and that is to our home page view. This is where we will be handling more page views. The rest of the code here is needed for the routes to function, but you don't have to understand it any more than you have to understand jQuery core code to use jQuery. So, if you want to explore it, you are welcome to do so. Otherwise, just focus on what you need to know, which is the routes array segment of this code.</p></div><div class="section" title="Adding navigation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Adding navigation</h2></div></div></div><p>We <a id="id348" class="indexterm"/>need to do two things to add the <a id="id349" class="indexterm"/>navigation. The component for navigation has already been created, so we are just adding it into our SPA solution. First, open the <code class="literal">startup.js</code> file in the <code class="literal">app</code> folder. Under the general components comment, add this line of code:</p><div class="informalexample"><pre class="programlisting">  ko.components.register('nav-bar', { require: 'components/nav-bar/nav-bar' });</pre></div><p>We need to register components before they are called, and this is where we are doing that in our SPA. Now, we will be able to add the <code class="literal">nav-bar</code> tag to the top of the <code class="literal">body</code> section of our body on the <code class="literal">index.html</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;nav-bar params="route: route"&gt;&lt;/nav-bar&gt;</pre></div><p>Oh, while <a id="id350" class="indexterm"/>that does cover code, there is one more thing needed. To show our navigation, we need to take<a id="id351" class="indexterm"/> the content and the page view, and move it down enough to show the navigation. We put an ID of the page onto the element; so, open the <code class="literal">css/style.css</code> file and enter this code there:</p><div class="informalexample"><pre class="programlisting">#page {
  margin-top: 80px;
}</pre></div><p>Go ahead and save and close that file as we will not need it again in this exercise. We now have a basic navigation bar for our SPA. This is how things look now:</p><div class="mediaobject"><img src="graphics/1028OS_06_11.jpg" alt="Adding navigation"/></div><div class="section" title="Adding pages"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec06"/>Adding pages</h3></div></div></div><p>Let's add<a id="id352" class="indexterm"/> an <span class="strong"><strong>About</strong></span> page next. The <span class="strong"><strong>About</strong></span> page will be different from our <span class="strong"><strong>Home</strong></span> page because it will only contain static content. We will not be binding to <code class="literal">viewModel</code> this time. In the <code class="literal">startup.js</code> file, under the static page components comment, add this code:</p><div class="informalexample"><pre class="programlisting">  ko.components.register('about-page', {
    template: { require: 'text!page/about/about.html' }
  });</pre></div><p>Notice we are only adding in a template, with no <code class="literal">viewModel</code>. We also need to add the link to our navigation. The code here is based on the use of Bootstrap. This is the code we would add after the home link in the code in the <code class="literal">components/nav-bar/nav-bar.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;li data-bind="css: { active: route().page === 'about-page' }"&gt;
&lt;a href="#about"&gt;About&lt;/a&gt;
&lt;/li&gt;</pre></div><p>I like how easy it is to <a id="id353" class="indexterm"/>manage the active setting based on whether this route matches this page. If you look at the component we registered and the <code class="literal">route().page</code> comparison, you will see that the values will make the page active when they match. There is one more thing we will need to have our <code class="literal">about</code> page work—the <code class="literal">about</code> page component itself. In the <code class="literal">page</code> folder, copy the <code class="literal">_base</code> file as <code class="literal">about</code>.</p><p>The last thing to do to create a new page is to add the page to our <code class="literal">Router</code> array, which is in the <code class="literal">app</code>/<code class="literal">router.js</code> file:</p><div class="informalexample"><pre class="programlisting">{ url: 'about',     params: { page: 'about-page' } }</pre></div><p>This is what our page looks like when we select the <code class="literal">about</code> navigation item. (If you are having problems getting it to show, reload the application to make it work once changes have been made.)</p><div class="mediaobject"><img src="graphics/1028OS_06_12.jpg" alt="Adding pages"/></div><p>Notice the highlighting works wonderfully, giving the user feedback to validate the page they are actually viewing. The static content on this page and the dynamic content on the home page give us the foundation to understand how to build SPA sites. Yet, we can do better than that. We are going to add in a page that will allow us to update the Bootstrap skin that we are using to view the site.</p></div><div class="section" title="Time for some custom style"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec07"/>Time for some custom style</h3></div></div></div><p>We will <a id="id354" class="indexterm"/>start off by listing the things we do when we are adding another page to this form of Knockout-based SPA site:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a page component registration to the <code class="literal">startup.js</code> file in the <code class="literal">app</code> folder.</li><li class="listitem">Add a menu item in the <code class="literal">nav-bar</code> tag if desired.</li><li class="listitem">Add the router configuration to the <code class="literal">router.js</code> file in the <code class="literal">app</code> folder.</li><li class="listitem">Create a new page in the <code class="literal">page</code> folder with appropriate files for <code class="literal">viewModel</code> and <code class="literal">template</code> code.</li></ol></div><p>Here is the<a id="id355" class="indexterm"/> code for the first three steps. First is the registration code for the <code class="literal">startup.js</code> file. Add this right after the <code class="literal">home-page</code> component registration, as follows:</p><div class="informalexample"><pre class="programlisting">ko.components.register('bootstrap-page', { require: 'page/bootstrap/bootstrap' });</pre></div><p>Then we will add the following code to the <code class="literal">nav-bar</code> component:</p><div class="informalexample"><pre class="programlisting">&lt;li data-bind="css: { active: route().page === 'bootstrap-page' }"&gt;
&lt;a href="#bootstrap"&gt;Bootstrap&lt;/a&gt;
&lt;/li&gt;</pre></div><p>Next, we will add the following code to that <code class="literal">router.js</code> file so our system knows how to handle the new routed item.</p><div class="informalexample"><pre class="programlisting">{ url: 'bootstrap', params: { page: 'bootstrap-page' } },</pre></div><p>The final phase, of course, will be creating the actual page component files. Again, we will copy the <code class="literal">_base</code> folder. This time, rename the copy as <code class="literal">boostrap</code>. Inside the folder, rename the <code class="literal">_base.js</code> file as <code class="literal">bootstrap.js</code> and you will be ready to code. Here is the <code class="literal">template</code> code to get started. Place this code in the <code class="literal">view.html</code> file under the <code class="literal">page</code>/<code class="literal">bootstrap</code> folder as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h2&gt;Bootstrap&lt;/h2&gt;
&lt;p data-bind='html: message'&gt;&lt;/p&gt;</pre></div><p>This will be our <code class="literal">viewModel</code> code to place in the <code class="literal">boostrap.js</code> file under the <code class="literal">page</code>/<code class="literal">bootstrap</code> folder:</p><div class="informalexample"><pre class="programlisting">define(["knockout", "text!./view.html"], function(ko, bootstrapTemplate) {
  function myViewModel(route) {
    this.message = ko.observable('Welcome to Bootstrap Page.');
  }
  return { viewModel: myViewModel, template: bootstrapTemplate };
});</pre></div><p>Now, when we run this code, here is the view we get after clicking on the <span class="strong"><strong>Bootstrap</strong></span> nav menu. Ah, wait! Before saving the screenshot, it appeared to me that the header of the template was not visible. My CSS had not been saved, so the offset was not working right. Now, with the <a id="id356" class="indexterm"/>correction made, here is the correct view. You should find that the other views will also show correctly now. How many of you caught that looking at my screenshots? Here again, we will show the screenshot:</p><div class="mediaobject"><img src="graphics/1028OS_06_13.jpg" alt="Time for some custom style"/></div><p>That certainly looks better. It is also starting to shape up and offer a promising site. We need to go in and modify our ViewModel to make this page highly functional. Before we do that, we need to actually go back to the main <code class="literal">index.html</code> file and add an <code class="literal">id</code> attribute to the page style tag as follows:</p><div class="informalexample"><pre class="programlisting">&lt;link id="page_style" href="/share/css/bootstrap.min.css" rel="stylesheet"&gt;</pre></div><p>This will allow us to use jQuery to target and update the page style for the page. Yes, we are using jQuery here and not Knockout. It still happens. Now, in the <code class="literal">boostrap.js</code> file, replace the message variable with the following code:</p><div class="informalexample"><pre class="programlisting">var self = this;
self.message = ko.observable('Hello from the bootstrap component! \
On this page we will be letting you choose from different &lt;a target="_blank" href="http://bootswatch.com/"&gt;Bootswatch&lt;/a&gt; themes.');
  self.theme = ko.observable('none');
  self.themes = ko.observableArray([]);
  self.themesVisible = ko.observable(true);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Notice that we have used a slash as a line break to continue coding on the next line. Some of us are familiar with that shortcut, but others may appreciate the tip if they are not.</p></div></div><p>We then add the <code class="literal">theme</code>, <code class="literal">themes</code>, and <code class="literal">themesVisible</code> attributes to our ViewModel. We will also need a couple of methods added to the page. These will be the <code class="literal">loadThemes</code> and <code class="literal">changeTheme</code> methods.</p><p>The<a id="id357" class="indexterm"/> <code class="literal">loadThemes</code> method will be pulling a JSON-based data file, AJAX style. Again, we will be using jQuery for this functionality. Here is the content of the JSON file. I would suggest just copying the file over from the matching SPA if you are not a perfect typist. This will also go into the <code class="literal">page</code>/<code class="literal">bootstrap</code> folder:</p><div class="informalexample"><pre class="programlisting">{
  "theme": [
    { "name": "cerulean", "bg":"light"},
    { "name": "cosmo", "bg":"light"},
    { "name": "cyborg", "bg":"dark"},
    { "name": "darkly", "bg":"dark"},
    { "name": "flatly", "bg":"light"},
    { "name": "journal", "bg":"light"},
    { "name": "lumen", "bg":"light"},
    { "name": "paper", "bg":"light"},
    { "name": "readable", "bg":"light"},
    { "name": "sandstone", "bg":"light"},
    { "name": "simplex", "bg":"light"},
    { "name": "slate", "bg":"dark"	},
    { "name": "spacelab", "bg":"light"},
    { "name": "superhero", "bg":"dark"},
    { "name": "united", "bg":"light"},
    { "name": "yeti", "bg":"light" }
  ]
}</pre></div><p>Now, we need to add the rest of the code to the <code class="literal">bootstrap.js</code> file in the <code class="literal">page</code>/<code class="literal">bootstrap</code> folder. First, we will add the <code class="literal">loadThemes</code> method. Here is the code for that:</p><div class="informalexample"><pre class="programlisting">myViewModel.prototype.loadThemes = function() {
  jQuery.getJSON("page/bootstrap/data.json")
.done(function(data){
    self.themes(data.theme);
    self.themesVisible(false);
  }).fail(function(data){
    alert('fail data pull for Bootstrap page');
  });
};</pre></div><p>This code will pull the data and push the data right into the data-bound themes array. Notice that we also<a id="id358" class="indexterm"/> included some code to show a very basic concept of exception handling. Now, add the code for the <code class="literal">changeTheme</code> function:</p><div class="informalexample"><pre class="programlisting">myViewModel.prototype.changeTheme = function(data,event) {
  var style = '/share/css/bootswatch/'+data.name+'/bootstrap.min.css';
  jQuery('#page_style').attr('href',style);
  vm.bg(data.bg);
};</pre></div><p>We will be able to bind these methods in <code class="literal">viewModel</code> to handle event triggers in our template code. There is one extra thing though that we need to handle this functionality. Notice <code class="literal">vm.bg(data.bg)</code> at the end of that method. We are setting the value of the incoming item to set a global variable. It tells the system whether the background we are using is a light or dark background. We won't be using that yet, but we are creating it now to be used shortly. In order to do that, we need to add the following bit of code to our main site <code class="literal">starup.js</code> file in the <code class="literal">app</code> folder:</p><div class="informalexample"><pre class="programlisting">vmSPA = function(){ 
  this.route = router.currentRoute;
  this.bg = ko.obervable("light");
};</pre></div><p>Now we can add our template code to the <code class="literal">view.html</code> file below the existing code. Notice that the button visibility is managed to improve user experience. When our data is loaded, we make the button invisible. We are also wiring the click method of the images to the <code class="literal">changeTheme</code> method on our <code class="literal">viewModel</code> component. At this time, there is no base variable alias for the component base, so we will use the <code class="literal">$parent</code> alias to target the method on the parent level of this data structure. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;button data-bind="click: loadThemes, visible: themesVisible'"&gt;Load Themes&lt;/button&gt;
&lt;div class="row" data-bind="foreach: themes"&gt;
&lt;div class="col-xs-6 col-md-3" style="text-align: center;"&gt;
  &lt;img class="img-responsive img-thumbnail" data-bind="attr:{ 'src':'/share/css/bootswatch/'+$data.name+'/thumbnail.png'}, click: $parent.changeTheme"&gt;&lt;/img&gt;
  &lt;br/&gt;&lt;br/&gt;
&lt;/div&gt;
&lt;/div&gt;</pre></div><p>Okay, we are all wired up now. If you have issues, compare the code to the code in the <code class="literal">SPA</code> folder as that is <a id="id359" class="indexterm"/>working and is from where the example code for this rebuild practice exercise came. Here is the initial screenshot when reloading and selecting the Bootstrap navigation item:</p><div class="mediaobject"><img src="graphics/1028OS_06_14.jpg" alt="Time for some custom style"/></div><p>Oh, if you do not recognize them, these skin styles are open source styles offered by <a class="ulink" href="http://bootswatch.com">bootswatch.com</a> for us to use. They also have commercial solutions there.</p><p>Now, we will click on the button to load our themes from the JSON-based data. This also could have been a live dynamic server location URL. This is what we get after clicking on the button:</p><div class="mediaobject"><img src="graphics/1028OS_06_15.jpg" alt="Time for some custom style"/></div><p>If we scroll down <a id="id360" class="indexterm"/>and click on <span class="strong"><strong>Superhero</strong></span> and move our mouse, this is what we will see:</p><div class="mediaobject"><img src="graphics/1028OS_06_16.jpg" alt="Time for some custom style"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>I'm not sure why we have to move the mouse, but that will work most of the time; we would figure out an instant update if it was a live website, of course.</p></div></div><p>Now we are <a id="id361" class="indexterm"/>able to update the styles by choice on demand. If you move to different pages, you will see that the look stays. If this were a live login site, we would use AJAX to store the user style choices back on the server. We could also choose to store them in cookie variables, but then if the user goes to another machine, their choices will not travel with them. This is why we suggest you store them on a server when possible.</p></div><div class="section" title="Bonus item"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec08"/>Bonus item</h3></div></div></div><p>Oh, we <a id="id362" class="indexterm"/>have a bonus for this part of the book. This book is based on Knockout 3.2, but there is a nice change proposed for Knockout 3.3 that will let us address the component code with a component alias. It is very simple to update our code to try that out. First, we need to go to the <code class="literal">require.config.js</code> file in the <code class="literal">app</code> folder and make one change. We have to change the file the Knockout alias is targeting like so:</p><div class="informalexample"><pre class="programlisting">"knockout": "/share/js/knockout.3_3_alpha:</pre></div><p>Then, we jump back into our <code class="literal">view.html</code> file in the <code class="literal">bootstrap</code> folder and change the <code class="literal">$parent</code> variable to <code class="literal">$component</code>. Next, we run our code again, which should work fine. This is more practical code, and if the data structure in a component were more complex, this pragmatic alias would just keep the code as simple as it should.</p></div><div class="section" title="Building cross-page interaction"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec09"/>Building cross-page interaction</h3></div></div></div><p>When <a id="id363" class="indexterm"/>we did our Bootstrap page, we loaded the data on demand. This means it did not load till the user clicked and told the themes to load. In this page, the data will instantly, automatically load onto the page. It seemed helpful to show both approaches to save you from having to figure these options out.</p><p>We will be using a jQuery page this time. We choose that for a couple of reasons. Firstly, we happen to appreciate all jQuery has done for the community over the years. The second reason is we noticed they have dark and light logo styles. We borrowed their graphics to show what they would look like on a dark Boostrap theme as well as on a light Bootstrap theme.</p><p>Here is the code for our jQuery page. First is the registration code for the <code class="literal">startup.js</code> file. Add this code after the Bootstrap registration:</p><div class="informalexample"><pre class="programlisting">ko.components.register('jquery-page', 
{ require: 'page/jquery/jquery' });</pre></div><p>Then we will <a id="id364" class="indexterm"/>add the following code to the <code class="literal">nav-bar</code> component:</p><div class="informalexample"><pre class="programlisting">&lt;li data-bind="css: { active: route().page === 'jquery-page' }"&gt;
  &lt;a href="#jquery"&gt;jQuery&lt;/a&gt;
&lt;/li&gt;</pre></div><p>Next, we will add this code to the <code class="literal">router.js</code> file so our system knows how to handle the new routed item. This is the full router section of code at this point:</p><div class="informalexample"><pre class="programlisting">return new Router({
  routes: [
    { url: '',          params: {page: 'home-page' } },
    { url: 'about',     params: {page: 'about-page' } },
    { url: 'bootstrap', params: {page: 'bootstrap-page' } },
    { url: 'jquery',     params:{ page: 'jquery-page' } }
  ]
});</pre></div><p>The final phase, of course, will be creating the actual page component files. Again, we will copy the <code class="literal">_base</code> folder. This time, rename the copy as <code class="literal">jquery</code>. Inside the folder, rename the <code class="literal">_base.js</code> file as <code class="literal">jquery.js</code> and you will be ready to code. We also have files to pull over from the working version of this SPA. We will be pulling the <code class="literal">data.json</code> file and the <code class="literal">logos</code> folder.</p><p>We can now edit our <code class="literal">viewmodel</code> file first. Here is the code for the <code class="literal">jquery.js</code> file:</p><div class="informalexample"><pre class="programlisting">define(['knockout', 'text!./view.html'], function(ko, templateMarkup) {
  function myViewModel(params) {
    var self = this;
    self.message = ko.observable('Hello from the jQuery component!');
    self.project = ko.observableArray();
  jQuery.getJSON('page/jquery/data.json').done(function(data){
      self.project(data.project);
    }).fail(function(){
      alert("AJAX error on jQuery Page View.");
    });
  }
  myViewModel.prototype.logo = function(data,event) {
    var url = 'page/jquery/logos/'+data.base+'-mark- '+vm.bg()+'.gif';
    return url;
  };
  // This runs when the component is torn down. Put here any logic necessary to clean up,
  // for example cancelling setTimeouts or disposing Knockout subscriptions/computeds.
  myViewModel.prototype.dispose = function() { };
  return { viewModel: myViewModel, template: templateMarkup };
});</pre></div><p>We <a id="id365" class="indexterm"/>again have our <code class="literal">defined</code> method, which takes the values of the two items and passes them into the function as parameters. The declarations are straightforward with one difference. This time, we are passing the results of a <code class="literal">jQuery JSON</code> request into the <code class="literal">self.project</code> binding. We again have a very basic exception handling, in case there are exceptions, as they are part of awesome coding. This time, the method we are creating in this component is a method to set the logo name. Here is our <code class="literal">view.html</code> code so we can look at how it was integrated. Note that inside the method, we are again using the main SPA <code class="literal">viewModel</code> binding to pull the light or dark background:</p><div class="informalexample"><pre class="programlisting">&lt;h2&gt;jQuery&lt;/h2&gt;
&lt;p data-bind="text: message'"&gt;&lt;/p&gt;
&lt;div class="row" data-bind="foreach: project"&gt;
  &lt;div class="col-md-4"&gt;
    &lt;img class="img-responsive img-thumbnail" data-bind="attr:{ 'src':$ component.logo($data)}"&gt;
  &lt;/div&gt;
  &lt;div class="col-md-8"&gt;
    &lt;h3 data-bind="text:$ data.name"&gt;&lt;/h3&gt;
    &lt;span data-bind="html:$ data.description"&gt;&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;</pre></div><p>Here, we see our template will loop through each project that was returned from our AJAX call to the JSON data. Notice that we are using the <code class="literal">$component</code> item for the logo. If you are still not using Knockout 3.3 alpha code, or need to deploy with something else, you should change that back to <code class="literal">$parent</code> to make sure it works correctly without that enhancement. Otherwise, this is standard template code.</p><p>With this in place, here is what the jQuery page will look like with a fresh reload and selection of the<a id="id366" class="indexterm"/> jQuery navigation tab:</p><div class="mediaobject"><img src="graphics/1028OS_06_17.jpg" alt="Building cross-page interaction"/></div><p>By default, the setting for the background is set to light and the logos it shows are the lighter logos. Now, we will jump to the Bootstrap page and select a darker style. This is what it will look like with the style we select:</p><div class="mediaobject"><img src="graphics/1028OS_06_18.jpg" alt="Building cross-page interaction"/></div><p>Now we have <a id="id367" class="indexterm"/>a very nice looking app to show off. While it may not do everything you have seen on any website, what it does will impress many a client or friend.</p></div></div></div>
<div class="section" title="What next?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>What next?</h1></div></div></div><p>There are many plugins and ways to package and advance your abilities as a developer using Knockout. I <a id="id368" class="indexterm"/>will be opening up a resource at <a class="ulink" href="http://knockout.developers.zone">http://knockout.developers.zone</a> where we will be sharing links and tips, and hope to have a meet-up or two over the next year for fellow Knockout developers.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Summary</h1></div></div></div><p>This chapter has pulled together concepts from every chapter and shown the awesome power of templates working together with ViewModels within Knockout components. You should now have an awesome foundation to do more with less than ever before. You should know how to mingle your jQuery code with the Knockout code side by side.</p><p>To review, in this chapter, we learned what Knockout components are. We learned how to use the components to create custom HTML elements that are interactive and powerful. We learned how to enhance custom elements to allow variables to be managed using the more common attributes approach. We learned how to use an AMD-style approach to coding with Knockout. We also learned how to AJAX everything and integrate jQuery to enhance Knockout-based solutions.</p><p>Many people struggle to understand the concept of SPA or single-page application sites. We were able to create a single-page application that provides understanding and perspective. In fact, this could be the beginning of your next site.</p><p>What's next? That is up to you. One thing is for sure, the possibilities are broader using Knockout than they were before. Happy coding and congratulations on completing your study of KnockoutJS!</p></div></body></html>