<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Building Media Queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Building Media Queries</h1></div></div></div><p>The days of simply using one device to browse an online site are long since gone: responsive sites will work on a range of devices, from smart phones through to digital TVs and laptops. A key element of making sites responsive is the use of media queries. In this chapter, we'll explore how to create them using PostCSS, see how they compare to the likes of Less and SASS, and how the use of PostCSS makes for a more flexible approach in comparison to standard preprocessors. This chapter will cover the following technical topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Revisiting media queries</li><li class="listitem" style="list-style-type: disc">Working through the basics of media queries using PostCSS</li><li class="listitem" style="list-style-type: disc">Adding responsive support</li><li class="listitem" style="list-style-type: disc">Optimizing media queries</li><li class="listitem" style="list-style-type: disc">Retrofitting support for older browsers</li><li class="listitem" style="list-style-type: disc">Taking things further—exploring the hover feature in CSS4 media queries</li></ul></div><p>Let's make a start…!</p><div class="section" title="Revisiting media queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Revisiting media queries</h1></div></div></div><p>If you spend<a id="id150" class="indexterm"/> any time viewing sites on different devices, then it will hardly come as a surprise to see media queries in the style sheet—they form the basis for responsive design and declarations allow us to control what is displayed on screen, according to the available screen width.</p><p>The principles behind media queries are simple. In a nutshell, we have to define the device or media, and the resolution (or width) at which point the rule (or breakpoint) either kicks in or stops being applied. Take this simple example:</p><div class="informalexample"><pre class="programlisting">@media only screen and (max-width: 768px) {
  /* CSS Styles */
  ...
}</pre></div><p>Any styles within will be applied only when we're viewing on screen, and our available screen estate is <code class="literal">768px</code> or less. This is a simple example, they can be as simple or as complex as required; it's down to us as developers to work out exactly where our content breaks and to build a suitable breakpoint to manage the change.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>To get a feel for<a id="id151" class="indexterm"/> some of the more recent media queries that are <a id="id152" class="indexterm"/>possible, take a look at this post by Chris Coyier, who has queries for laptops, PCs, and even wearable devices! The list is available at <a class="ulink" href="https://css-tricks.com/snippets/css/media-queries-for-standard-devices/">https://css-tricks.com/snippets/css/media-queries-for-standard-devices/</a>.</p></div></div><p>Okay, let's make a start: PostCSS makes it easy to manage queries for both text and images; we'll begin our journey with a look at handling images.</p></div></div>
<div class="section" title="Exploring custom media queries in PostCSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Exploring custom media queries in PostCSS</h1></div></div></div><p>Making the switch to <a id="id153" class="indexterm"/>using PostCSS is a cinch, we can use<a id="id154" class="indexterm"/> the <code class="literal">postcss-custom-media</code> plugin for<a id="id155" class="indexterm"/> this purpose, available at <a class="ulink" href="https://github.com/postcss/postcss-custom-media">https://github.com/postcss/postcss-custom-media</a>.</p><p>The plugin is easy to install, it follows<a id="id156" class="indexterm"/> the same principles as all of the other plugins we've covered, so without further ado, let's get that out of the way now:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Fire up a Node.js command prompt, then navigate to the working directory.</li><li class="listitem">At the prompt, enter this command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install --save-dev postcss-custom-media</strong></span>
</pre></div></li><li class="listitem">Keep the command prompt open for now, we will use it in the next few steps.<p>With the plugin installed, we can now use it, before we get stuck into converting our previous demo, let's work through a simple example, so you can see it in action:</p></li><li class="listitem">In a new file, add the following code, saving it as <code class="literal">style.css</code> within the <code class="literal">src</code> folder at the root of our project area:<div class="informalexample"><pre class="programlisting">@custom-media --apple-watch (max-device-width: 42mm) and (min-device-width: 38mm);

@media (--apple-watch) {
  h2 {
    font-size: 0.8rem;
  }
}</pre></div></li><li class="listitem">Remove the existing <code class="literal">gulpfile.js</code> file from the root of the project area.</li><li class="listitem">In a new file, add the<a id="id157" class="indexterm"/> following code, this will form a new <code class="literal">gulpfile.js</code> file; save this to the root of our project area:<div class="informalexample"><pre class="programlisting">var gulp = require('gulp');
var postcss = require('gulp-postcss');
var customMedia = require('postcss-custom-media');

gulp.task('default', function() {
    return gulp.src('src/*.css')
    .pipe(postcss([ customMedia() ]))
    .pipe(gulp.dest('dest/'));
});

var watcher = gulp.watch('src/*.css', ['default']);
watcher.on('change', function(event) {
  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
});</pre></div></li><li class="listitem">Revert back to<a id="id158" class="indexterm"/> the command prompt session we had open earlier, then enter <code class="literal">gulp</code> at the command prompt, and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">If all is well, we should see this code if we open up the compiled <code class="literal">style.css</code> from within the <code class="literal">dest</code> folder of our project area:<div class="informalexample"><pre class="programlisting">@media (max-device-width: 42mm) and (min-device-width: 38mm) {
  h2 {
    font-size: 0.8rem;
  }
}</pre></div></li></ol></div><p>Believe it or not, this is all that is required to use the plugin; let's take a moment to consider what we've covered through this demo.</p><p>At first glance, you might be forgiven for thinking that this plugin doesn't actually do anything to help us—it's a valid point, but there is one key benefit to using this plugin. We can separate out the media breakpoints into separate variable statements, and store these at the top of our style sheet. This means that if we should ever need to update a particular breakpoint, we only need to do it once. Our code is then updated automatically at the compilation stage.</p><p>With that in mind, let's get stuck into a demo; we're going to work through the previous plain CSS version of our parallax scrolling example, and convert it to use PostCSS.</p><div class="section" title="Beginning with plain CSS"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Beginning with plain CSS</h2></div></div></div><p>Over the next few <a id="id159" class="indexterm"/>pages, we're going to use a relatively recent technique as the basis for our demo—parallax scrolling. Just in case you've been under a rock, parallax scrolling is a single page application, which allows us to scroll through content whilst showing a number of fixed images behind our content:</p><div class="mediaobject"><img src="graphics/BO5194_04_01.jpg" alt="Beginning with plain CSS"/></div><p>We'll be using a demo created by Nick Salloum, which is available at <a class="ulink" href="http://callmenick.com/_development/simple-parallax-effect/">http://callmenick.com/_development/simple-parallax-effect/</a> (I've simplified some of the CSS <a id="id160" class="indexterm"/>styles used, removed vendor prefixes, and reduced the number of separate files called by the example). We'll start with a plain CSS version of our demo—go ahead and extract a copy of <code class="literal">Tutorial11</code> to our project area. Try running <code class="literal">index.html</code>; if all is well, we should see something akin to the screenshot at the head of this section.</p><p>It's a great effect when used well, our interest is in the last section of the CSS file, from around line 133; this section contains the media queries we will convert in our next demo.</p></div><div class="section" title="Altering our demo to use PostCSS"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Altering our demo to use PostCSS</h2></div></div></div><p>If media queries are<a id="id161" class="indexterm"/> used correctly, this can open up a world of possibilities; we can tweak our style sheet for anything from an iPhone through to a printer. In our demo, we've used a couple to adjust how content is displayed on sites where displays are larger than <code class="literal">600px</code> or <code class="literal">960px</code> width; altering these to work in PostCSS is a cinch.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>The <a id="id162" class="indexterm"/>CSS3 Media Queries site has a large list of different types of queries that are available; if you check out the site on a target PC or device, it will show you if that query is supported on that device. The full list is available at <a class="ulink" href="http://www.cssmediaqueries.com">http://www.cssmediaqueries.com</a>.</p></div></div><p>We only need to make a couple of changes in the style sheet to switch to using PostCSS, so let's make a start:</p><p>Let's make a start on the changes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by copying the <code class="literal">style.css</code> file from <code class="literal">Tutorial11</code> folder to the <code class="literal">src</code> folder in our project area.</li><li class="listitem">We need to edit the file, to convert our media queries to use the PostCSS plugin—go ahead and add these two lines at lines 4 and 5:<div class="informalexample"><pre class="programlisting">@custom-media --small-viewport all and (min-width: 600px);
@custom-media --medium-viewport all and (min-width: 960px);</pre></div></li><li class="listitem">Further down, replace lines 161 and 182 with this code:<div class="informalexample"><pre class="programlisting">@media (--small-viewport) {</pre></div></li><li class="listitem">On line 200, replace that line with this code:<div class="informalexample"><pre class="programlisting">@media (--medium-viewport) {</pre></div></li><li class="listitem">Save the file—next, go ahead and replace the current <code class="literal">gulpfile.js</code> file with the version from the root of the <code class="literal">Tutorial12</code> folder. It has the same initial PostCSS task, but this has been renamed and extended with additional tasks that we've already used from earlier chapters.</li><li class="listitem">Next, go ahead and save a copy of the <code class="literal">package.json</code> file from the same location to the root of our project area—this contains updated links to the plugins used in this demo.<p>Fire up a Node.js command prompt window, then change the working directory to our project area. At the prompt, enter <code class="literal">gulp</code> then press <span class="emphasis"><em>Enter</em></span>.</p></li><li class="listitem">If all is well, we should have a compiled CSS file appear in the <code class="literal">dest</code> folder—go ahead and copy this into the <code class="literal">css</code> folder of the <code class="literal">Tutorial12</code> folder.</li><li class="listitem">Go ahead and run <code class="literal">index.html</code> in our project area, to preview the results—if all is well, we should not see anything different, but a quick check in the source code should show that we're using the minified version of our code:<div class="mediaobject"><img src="graphics/BO5194_04_02.jpg" alt="Altering our demo to use PostCSS"/></div></li></ol></div><p>It's worth noting that in our demo, we used a typical format of media query: we could for example extend or <a id="id163" class="indexterm"/>alter our style sheet to work on handheld devices such as Galaxy tablets; the same principles apply, but clearly different width values will need to be used! For details on the values to use, take<a id="id164" class="indexterm"/> a look at <a class="ulink" href="http://cssmediaqueries.com">http://cssmediaqueries.com</a>, which has a useful list of queries to use for recent devices.</p><p>If we want to push the boundaries of what is possible, there are a couple of options that we can consider:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">postcss-media-variables</code>: This plugin (available at <a class="ulink" href="https://github.com/WolfgangKluge/postcss-media-variables">https://github.com/WolfgangKluge/postcss-media-variables</a>) works in the same way, but allows us to use variables in media queries. The benefit of using this plugin is that we can hive off width values into a central <code class="literal">:root</code> rule; we <a id="id165" class="indexterm"/>can potentially use one fixed value, but work out others based on this value:<div class="informalexample"><pre class="programlisting">/* input */
:root {
    --min-width: 1000px;
    --smallscreen: 480px;
}
@media (min-width: var(--min-width)) {}
@media (max-width: calc(var(--min-width) - 1px)) {}

@custom-media --small-device (max-width: var(--smallscreen));
@media (--small-device) {}
/* output */
@media (min-width: 1000px) {}
@media (max-width: 999px) {}
@media (max-width: 480px) {}</pre></div><p>The downside is that it is considered as non-standard, the plugin must be called twice, and if other plugins are used, be called in a certain order—this means it might only suit a specific set of circumstances!</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">postcss-quantity-queries</code>: This plugin (available at <a class="ulink" href="https://github.com/pascalduez/postcss-quantity-queries">https://github.com/pascalduez/postcss-quantity-queries</a>) is based on the SASS <a id="id166" class="indexterm"/>quantity queries mixins by Daniel Guillan. This allows us to use rules such as this:<div class="informalexample"><pre class="programlisting">ul &gt; li:at-least(4) { color: rebeccapurple; }</pre></div><p>Which will compile to this:</p><div class="informalexample"><pre class="programlisting">ul &gt; li:nth-last-child(n+4),
ul &gt; li:nth-last-child(n+4) ~ li {
  color: rebeccapurple;
}</pre></div></li></ul></div><p>This is one of four pseudo-selector extensions we can use with this plugin, it's a perfect way to style items <a id="id167" class="indexterm"/>such as navigation entries, or if we wanted a numbered list of items with different styles for even or odd numbers. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>For a useful<a id="id168" class="indexterm"/> reference article on using quantity queries in CSS, head over to the post by Heydon Pickering at <a class="ulink" href="http://alistapart.com/article/quantity-queries-for-css">http://alistapart.com/article/quantity-queries-for-css</a>.</p></div></div><p>Let's change tack now, and focus on our content. So far, we've concentrated on the page layout, but we can take it further by making images truly responsive; let's dive in and take a look.</p></div></div>
<div class="section" title="Making images responsive"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Making images responsive</h1></div></div></div><p>A key element of <a id="id169" class="indexterm"/>making any site responsive has of course to be images—after all, we can always construct a site without images, but how effective would it <span class="emphasis"><em>really</em></span> be?</p><p>Sure, one can always use a data<a id="id170" class="indexterm"/> <span class="strong"><strong>Uniform Resource Identifier</strong></span> (<span class="strong"><strong>URI</strong></span>) to convert images to CSS equivalents, but this is at the risk of dramatically inflating our style sheet to the point of it becoming impossible to manage. The reality is that we have to have some form of images—if we are to make them behave, we clearly need to ensure that they expand or contract in size, according to available screen estate.</p><p>The easiest way to adapt images for responsive layouts is to set a <code class="literal">max-width</code> value to <code class="literal">100%</code>, along with <code class="literal">height: auto</code> and <code class="literal">display: block</code>, and remove any attribute that defines either a fixed <a id="id171" class="indexterm"/>height or width for that image element. We can make the changes manually, but this is time-consuming; instead, let's take a look at a PostCSS plugin that allows us to set these three values at compilation, by adding one single line of code to each image.</p><div class="section" title="Making an image responsive with PostCSS"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Making an image responsive with PostCSS</h2></div></div></div><p>Adding responsive<a id="id172" class="indexterm"/> capabilities to a site using PostCSS is simple; it will depend largely on your requirements as to how we make the images<a id="id173" class="indexterm"/> responsive, but the two key plugins to look out for are <code class="literal">postcss-responsive-images</code> (available at <a class="ulink" href="https://github.com/azat-io/postcss-responsive-images">https://github.com/azat-io/postcss-responsive-images</a>), and <a id="id174" class="indexterm"/>
<code class="literal">postcss-at2x</code> (available at <a class="ulink" href="https://github.com/simonsmith/postcss-at2x">https://github.com/simonsmith/postcss-at2x</a>).</p><p>We will cover the use <a id="id175" class="indexterm"/>of the <code class="literal">postcss-at2x</code> plugin in a moment, but for now, let's take a look at using the <code class="literal">postcss-re</code>
<code class="literal">sponsive-images</code> plugin.</p></div><div class="section" title="Implementing responsive capabilities to images"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Implementing responsive capabilities to images</h2></div></div></div><p>Making our images<a id="id176" class="indexterm"/> responsive requires a single line of code to be added to any image-based rule; let's dive in and add this capability to a copy of the <code class="literal">Tutorial13</code> folder from the code download that accompanies this book:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start, as always, by installing the plugin—for this, fire up a Node.js command prompt, then run the commands as shown in this screenshot:<div class="mediaobject"><img src="graphics/BO5194_04_03.jpg" alt="Implementing responsive capabilities to images"/></div></li><li class="listitem">We'll start by extracting a copy of the <code class="literal">Tutorial13</code> folder from the code download that accompanies this book, then saving it to our project area.</li><li class="listitem">Open up <code class="literal">style.css</code> from the <code class="literal">css</code> folder within the <code class="literal">Tutorial13</code> folder, then remove this rule:<div class="informalexample"><pre class="programlisting">img { 
  width: 584px; 
  height: 389px;
}</pre></div></li><li class="listitem">In its place, add the following line:<div class="informalexample"><pre class="programlisting">#retina img { image-size: responsive; }</pre></div></li><li class="listitem">Save the file, then copy it to the <code class="literal">src</code> folder underneath our project area (not within the <code class="literal">Tutorial</code> folder!).</li><li class="listitem">For this <a id="id177" class="indexterm"/>exercise, we're going to replace the Gulp task file—go ahead and add this code to a new file, saving it as <code class="literal">gulpfile.js</code> at the root of our project area:<div class="informalexample"><pre class="programlisting">var gulp = require('gulp');
var postcss = require('gulp-postcss');
var responsiveimages = require('postcss-responsive-images');

gulp.task('default', function() {
    return gulp.src('src/*.css')
    .pipe(postcss([ responsiveimages ]))
    .pipe(gulp.dest('dest/'));
});

var watcher = gulp.watch('src/*.css', ['default']);
watcher.on('change', function(event) {
  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
});</pre></div><p>Note that we're concentrating on just making our image responsive with this <code class="literal">gulp</code> file, hence why it is a lot shorter than previous versions we have used to date.</p></li><li class="listitem">Fire up a Node.js command prompt, then change the working directory to our project area—at the prompt, enter <code class="literal">gulp</code> then press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">Node will go away and compile our code—if all is well, the compiled code for <code class="literal">#retina img</code> will look like this:<div class="mediaobject"><img src="graphics/BO5194_04_04.jpg" alt="Implementing responsive capabilities to images"/></div></li><li class="listitem">Copy the compiled CSS file from the <code class="literal">dest</code> folder into the <code class="literal">css</code> folder of the <code class="literal">Tutorial13</code> folder.</li><li class="listitem">Go ahead <a id="id178" class="indexterm"/>and preview the results—try resizing the browser; if all is well, the image will automatically resize the image for us.</li></ol></div><p>Although it's easy enough to install and use this plugin, it works best when referencing images directly in our HTML code, and not through the use of <code class="literal">background:</code> or <code class="literal">content: url(…)</code> attributes in our CSS.</p><p>What does this mean for us? It's a little limiting, as the purists amongst us may prefer to hive off asset attributes to CSS style sheets such is open source software, though this is one limitation that is bound to be fixed in the fullness of time!</p><p>The keen-eyed amongst you will spot that the image presentation clearly needs further work—for example, the paper clip isn't repositioning when the window is resized, and we need to set a minimum width so that there is some white space around the image when we resize it:</p><div class="mediaobject"><img src="graphics/BO5194_04_05.jpg" alt="Implementing responsive capabilities to images"/></div><p>The key principles remain the same though, irrespective of the presentation, removing the fixed image sizes and<a id="id179" class="indexterm"/> replacing with a <code class="literal">max-width</code> of <code class="literal">100%</code> is a good step to making an image responsive.</p><p>To get a true responsive image though, we ideally would use the new HTML5 <code class="literal">&lt;picture&gt;</code> tags—trouble is, PostCSS doesn't yet have a plugin to implement these tags!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>If you're interested<a id="id180" class="indexterm"/> in some of the more general techniques of making images responsive (and outside of the world of PostCSS), then take a look at <a class="ulink" href="https://jakearchibald.com/2015/anatomy-of-responsive-images/">https://jakearchibald.com/2015/anatomy-of-responsive-images/</a>.</p></div></div><p>In the absence of any available capability to handle the use of <code class="literal">&lt;picture&gt;</code> tags within PostCSS, we can instead take a more traditional route and use media queries to help switch between different images, depending on the available screen estate.</p><p>We can go a step further, and even switch in images of better resolution if the device supports it—I'm thinking of course of Apple iPads or iPhones, which support retina images. We can easily use this format when working with PostCSS; for this, we need to make use of the <a id="id181" class="indexterm"/>
<code class="literal">postcss-at2x</code> plugin by Simon Smith, available at <a class="ulink" href="https://github.com/simonsmith/postcss-at2x">https://github.com/simonsmith/postcss-at2x</a>. I feel a couple of demos coming on, so without further ado, let's go explore using this plugin.</p></div><div class="section" title="Adding support for retina images"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Adding support for retina images</h2></div></div></div><p>Retina images, a term coined by Apple's marketing team, contain up to twice as many pixels in the same space as standard images. This allow us to switch in images of higher quality (or resolution) automatically, provided we're using a device that supports their use.</p><p>This might be as <a id="id182" class="indexterm"/>simple as an iPhone, or something more substantial like an iPad—Apple's marketing clout means that they are probably two of the most popular portable devices that people own! But I digress…</p><p>At a technical level, we have two routes available for adding retina images, before we explore these in more detail, let's just remind ourselves of the basics:</p><div class="informalexample"><pre class="programlisting">@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) { 
  #retina img {
    content: url("../img/mothorchid@2x.png");
  } 
}</pre></div><p>This code is an extract from the CSS style sheet in the <code class="literal">Tutorial15</code> folder, which is available in the code download that accompanies this book; try previewing <code class="literal">index.html</code> in a browser.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>For best results, it is strongly recommended that you use Google Chrome—it's a great browser for simulating the effects of switching between low and high resolution images.</p></div></div><p>The image displayed displays the text <span class="emphasis"><em>8-bit version</em></span>—to switch, try this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Press <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>I</em></span> to display the Developer toolbar.</li><li class="listitem">Click on the mobile phone icon to enable Responsive Design mode<div class="mediaobject"><img src="graphics/BO5194_04_14.jpg" alt="Adding support for retina images"/></div></li></ol></div><p>We can then switch between different devices using the dropdown—try switching to <span class="strong"><strong>Apple iPad</strong></span>; you may need to press <span class="emphasis"><em>F5</em></span> to refresh the display. If all is well, it will switch between 8-bit and 24-bit versions of the orchid image.</p></div><div class="section" title="Taking the next steps"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Taking the next steps</h2></div></div></div><p>This is all good, but <a id="id183" class="indexterm"/>we're clearly not using PostCSS here—what are our options? Well, we have two that we can use: <code class="literal">customMedia()</code> or the <code class="literal">postcss-at2x</code> plugin. We've already covered the basics of using <code class="literal">customMedia</code> in the <span class="emphasis"><em>Exploring custom media queries in PostCSS</em></span> section; for this, we would use a variable such as this:</p><div class="informalexample"><pre class="programlisting">/* media query for hi-resolution image support */
@custom-media --hi-resolution screen and (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi);</pre></div><p>This would be coupled with a query such as this:</p><div class="informalexample"><pre class="programlisting">@media (--hi-resolution) { 
  #retina img {
    content: url("../img/mothorchid@2x.png");
  } 
}</pre></div><p>When compiled, and run in Google Chrome (to take advantage of its responsive design tools), we can see the image switch from 8-bit:</p><div class="mediaobject"><img src="graphics/BO5194_04_15.jpg" alt="Taking the next steps"/></div><p>…to a 24-bit version of the image:</p><div class="mediaobject"><img src="graphics/BO5194_04_06.jpg" alt="Taking the next steps"/></div><p>A peek at the active style rules view shows the media query update automatically:</p><div class="mediaobject"><img src="graphics/BO5194_04_07.jpg" alt="Taking the next steps"/></div><p>This is good, but<a id="id184" class="indexterm"/> still a manual approach that takes time—instead, we can use a quicker route to achieve similar results. The alternative route, using <code class="literal">postcss-at2x</code>, is a simpler option—instead of working out what resolution ratio to use, we simply add the term <code class="literal">at-2x</code> to our style rule:</p><div class="informalexample"><pre class="programlisting">#retina img { background: url("../img/mothorchid.png") at-2x; }</pre></div><p>This automatically compiles to produce the relative resolution statements for us in our style sheet. It's a useful trick to use when working with iPads and other devices that can support hi-res images.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>Make sure the <code class="literal">src</code> and <code class="literal">dest</code> folders at the root of our project area are clear of files before starting this demo, otherwise you might find they have some undesired effects during compilation!</p></div></div><p>Let's dive in and take a look at this in more detail.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start, as usual by installing the plugin—fire up a Node.js command prompt, then change the working directory to our project area.</li><li class="listitem">At the prompt, enter the commands shown in this screenshot, pressing <span class="emphasis"><em>Enter</em></span> after each:<div class="mediaobject"><img src="graphics/BO5194_04_08.jpg" alt="Taking the next steps"/></div><p>Keep the window handy, we will need it in a few steps!</p></li><li class="listitem">Let's now set up our markup, extract a copy of the <code class="literal">Tutorial17</code> folder from the code download that accompanies this book, and save the folder to our project area.</li><li class="listitem">Extract a copy of the <code class="literal">gulp</code> file from this folder and use it to replace the existing one <a id="id185" class="indexterm"/>at the root of our project area.</li><li class="listitem">Extract a copy of <code class="literal">style – pre-compile.css</code> from the <code class="literal">Tutorial17</code> folder, then copy it to the <code class="literal">src</code> folder at the root of our project area. Rename it as <code class="literal">style.css</code>.</li><li class="listitem">Switch back to the Node.js command prompt window we had up earlier—at the prompt, enter <code class="literal">gulp</code> then press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">PostCSS will go away and compile our code—if all is well, we should see something akin to this extract in the compiled file within the <code class="literal">dest</code> folder:<div class="informalexample"><pre class="programlisting">#retina img {
  padding: 4px;
  border: solid 1px #bbb;
  background: #fff;
  box-shadow: 0 1px 2px rgba(0,0,0,.2);
  content: url("../img/mothorchid.png"); 
}
…
@media screen and (-webkit-min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) { 
  #retina img {
    content: url("../img/mothorchid@2x.png");
  } 
}</pre></div></li><li class="listitem">Go ahead and copy the contents of the <code class="literal">dest</code> folder to the <code class="literal">css</code> folder within the <code class="literal">Tutorial17</code> folder.</li><li class="listitem">Try previewing the demo—if all is well, we should see that orchid flower as before, and force Chrome to display the hi-res version as we did in our previous demo.</li></ol></div><p>The great thing about this plugin is that it deals with creating the media query for us; all we need to do is add the <code class="literal">at2x</code> tag to any image where we want to display hi-resolution versions in the browser. There is always a risk that we may end up producing queries that are not 100% optimized (for example, combining identical breakpoints into one block, and so on); we will explore a couple of options to help keep our queries working efficiently towards the end of this chapter.</p><p>As an aside, a more concise option for working with hi-res images which is frequently forgotten, is the<a id="id186" class="indexterm"/> use of <code class="literal">image-set()</code>; this performs in a similar fashion, by providing different versions for devices that support high-resolution images. PostCSS provides a fallback option in<a id="id187" class="indexterm"/> the form of <code class="literal">postcss-image-set</code> (available from <a class="ulink" href="https://github.com/alex499/postcss-image-set">https://github.com/alex499/postcss-image-set</a>), which sets a basic image that will work in those browsers that don't support the use of <code class="literal">image-</code>
<code class="literal">set()</code> within a style sheet.</p></div><div class="section" title="Exploring other media possibilities"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Exploring other media possibilities</h2></div></div></div><p>So, we've covered a <a id="id188" class="indexterm"/>number of key topics around making content responsive, using media queries; what does this mean when using PostCSS? The simple answer is that it opens up a world of possibilities—if your site needs to use media queries, then it is very likely that we can use PostCSS to compile our queries into valid CSS rules. To pique your interest, here are a couple of options to consider:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a responsive slider<a id="id189" class="indexterm"/> using the <code class="literal">bxSlider</code> plugin, available from <a class="ulink" href="http://www.bxslider.com">http://www.bxslider.com</a>. Granted, it uses jQuery to move between each slide, but who's to say you couldn't eventually convert this to an all-CSS option?</li><li class="listitem" style="list-style-type: disc">How about using responsive image sprites? A classic use for this is credit card symbols on an e-commerce shopping cart, with a bit of care, we can even make the image adapt to display hi-res versions, if the device being used supports it. We'll cover more of this in <a class="link" href="ch05.html" title="Chapter 5. Managing Colors, Images, and Fonts">Chapter 5</a>, <span class="emphasis"><em>Managing Colors, Images and Fonts</em></span>, if<a id="id190" class="indexterm"/> you want to give this a try, take a look at the postcss-sprites plugin, available from <a class="ulink" href="https://github.com/2createStudio/postcss-sprites">https://github.com/2createStudio/postcss-sprites</a>.</li></ul></div><p>Okay, we've covered making images responsive using PostCSS, but what about text? Pages won't look good if text doesn't flow properly when content is resized. Thankfully we can apply similar principles to text, using the <code class="literal">postcss-responsive-type</code> plugin by Sean King—let's take a look at it in action.</p></div></div>
<div class="section" title="Adding responsive text support"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Adding responsive text support</h1></div></div></div><p>The process <a id="id191" class="indexterm"/>of making text responsive within PostCSS shares some similarities to the postcss-responsive-images plugin we've already used, in both cases, all we need to add is a simple attribute to make our content responsive.</p><p>The plugin we need to use for text though is the <code class="literal">PostCSS-responsive-type</code> plugin by Sean King (available<a id="id192" class="indexterm"/> at <a class="ulink" href="https://github.com/seaneking/postcss-responsive-type">https://github.com/seaneking/postcss-responsive-type</a>); adding font-size, being responsive to a rule in our style sheet is enough to get us started. Of course, we almost certainly want to specify our own rules; for example, we can use something like this:</p><div class="informalexample"><pre class="programlisting">html {
  font-size: responsive 12px 21px; /* min-size, max-size */
  font-range: 420px 1280px; /* range of viewport widths */
}</pre></div><p>This compiles into<a id="id193" class="indexterm"/> two media queries—one at <code class="literal">480px</code>, and the other at <code class="literal">1280px</code>; the former sets a text size of <code class="literal">12px</code>, with the latter setting <code class="literal">21px</code> as the font size. Without further ado, let's get stuck in and start using this plugin in anger:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Fire up a Node.js command and change the working directory to the project area.</li><li class="listitem">Enter the command shown in this screenshot, then press <span class="emphasis"><em>Enter</em></span>:<div class="mediaobject"><img src="graphics/BO5194_04_09.jpg" alt="Adding responsive text support"/></div></li></ol></div><p>At this point, the plugin is installed—we can start to use it:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by extracting a copy of the <code class="literal">Tutorial18</code> folder from the code download that accompanies this book; save it to the root area of our project folder.</li><li class="listitem">In a new file, add the following code—this contains some simple font styling for our demo; save it as <code class="literal">style.css</code> in the <code class="literal">src</code> folder of our project area:<div class="informalexample"><pre class="programlisting">@font-face {
  font-family: 'robotoregular';
  src: url('Roboto-Regular-webfont.eot');
  src: url('Roboto-Regular-webfont.eot?#iefix') format('embedded-opentype'),
       url('Roboto-Regular-webfont.woff') format('woff'),
       url('Roboto-Regular-webfont.ttf') format('truetype'),
       url('Roboto-Regular-webfont.svg#robotoregular') format('svg');
  font-weight: normal;
  font-style: normal;
}

body {
  font-family: "robotoregular", sans-serif;
  font-size: responsive 12px 21px; 
  font-range: 420px 1280px; 
}</pre></div></li><li class="listitem">Next, open up a copy of the <code class="literal">gulpfile.js</code> file at the root of our project area.</li><li class="listitem">Note how a reference to the <code class="literal">postcss-responsive-type</code> plugin has been added, as indicated:<div class="informalexample"><pre class="programlisting">var at2x = require('postcss-at2x');
<span class="strong"><strong>var responsivetype = require('postcss-responsive-type')</strong></span>;</pre></div></li><li class="listitem">The<a id="id194" class="indexterm"/> <code class="literal">autoprefixer</code> task has also been amended—it has a reference to the <code class="literal">postcss-responsive-type </code>plugin, using the variable that has been declared at the top of the file:<div class="informalexample"><pre class="programlisting">gulp.task('autoprefixer', function() {
  return gulp.src('src/*.css')
  .pipe(postcss([at2x(), responsivetype(), autoprefixer]))
  .pipe(gulp.dest('dest/'));
});</pre></div></li><li class="listitem">We can now compile the code from a Node.js command prompt, change the working directory to the project area, and run this command:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>gulp</strong></span>
</pre></div></li><li class="listitem">Once the code has compiled, copy the contents of the <code class="literal">dest</code> folder to the <code class="literal">css</code> folder of the <code class="literal">Tutorial18</code> folder; if all is well, we should see this when previewing the results in a browser:<div class="mediaobject"><img src="graphics/BO5194_04_10.jpg" alt="Adding responsive text support"/></div></li></ol></div><p>Try resizing the window to make it larger or smaller—you should notice that the text size increases or decreases in size, according to the size of the available screen estate. We can then use this as a basis for adding images; if we apply both <code class="literal">postcss-responsive-images</code> and <code class="literal">postcss-responsive-type</code> plugins, we can use this as a solid basis for adding responsive capabilities to our sites.</p><p>A small point to<a id="id195" class="indexterm"/> note though—we've used pixel values throughout our code. Historical convention recommended the use of <code class="literal">em</code> (or even better <code class="literal">rem</code>) values, as these scaled better than standard pixel values. However, some developers now argue that this convention is no longer valid; there are occasions when pixel <code class="literal">em</code> or <code class="literal">rem</code> values should be used. It's up to us to decide which unit of value to use, and when it should be used!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>For a good discussion on the<a id="id196" class="indexterm"/> merits of using pixel versus rem values, take a look at this post by Gion Kunz, at <a class="ulink" href="https://mindtheshift.wordpress.com/2015/04/02/r-i-p-rem-viva-css-reference-pixel/">https://mindtheshift.wordpress.com/2015/04/02/r-i-p-rem-viva-css-reference-pixel/</a>.</p></div></div><p>Leaving aside what is possible when working with media queries, there are a couple of key topics we should explore—optimizing media queries, and how we can retrofit some form of support for older browsers. We'll start with optimizing queries—PostCSS has a couple of useful plugins available to help with maintaining our code.</p></div>
<div class="section" title="Optimizing media queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Optimizing media queries</h1></div></div></div><p>Throughout this<a id="id197" class="indexterm"/> chapter, we've explored using PostCSS to compile our media queries; while there are plenty of options open to us in terms of what we create, we should be mindful of what we create, to ensure that we're not creating a monster that slows our site down!</p><p>PostCSS has a couple of plugins available to help us here. They are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">postcss-mq-keyframes</code>: Available at <a class="ulink" href="https://github.com/TCotton/postcss-mq-keyframes">https://github.com/TCotton/postcss-mq-keyframes</a>), this is a simple plugin that <a id="id198" class="indexterm"/>moves all keyframes out of <a id="id199" class="indexterm"/>existing queries, to the bottom of a style sheet. This allows us to rationalize our keyframe rules—in the event that we have multiple media queries, we can apply the same rule to each of these media queries.<p>For example, the highlighted code below would be moved out of the query, and become a rule in its own right:</p><div class="informalexample"><pre class="programlisting">@media only screen and (min-width: 415px) {
  .pace {
    animation: pace-anim 5s;
  }

<span class="strong"><strong>  @keyframes pace-anim {</strong></span>
<span class="strong"><strong>    100% {</strong></span>
<span class="strong"><strong>      opacity</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">css-mqpacker</code>: Available at <a class="ulink" href="https://github.com/hail2u/node-css-mqpacker">https://github.com/hail2u/node-css-mqpacker</a>), this plugin parses our code and merges any identical rules into one <a id="id200" class="indexterm"/>media query rule. It is arguable how much<a id="id201" class="indexterm"/> benefit we are likely to get from this plugin; we will likely only see any significant benefit from using it on larger, more complex sites!</li></ul></div><p>Both plugins can be installed using the same process as all of the plugins we've used to date; it's worth noting that we should not overuse our queries. Instead of designing for specific platforms, try designing for instances where content clearly breaks and becomes unusable. The fewer queries we have, the easier it becomes to manage our code; simplicity is absolutely key to a successful site.</p><p>Looking further afield, there is one area we should not forget when optimizing our code—what browsers should we support? I'm all for pushing the proverbial browser boat out and using modern browsers where possible. However, some of you may still have to support older browsers (and please don't tell me that includes IE6!). Let's explore an option available in PostCSS to help those of you still having to support applications that really should be put out to pasture, so to speak.</p></div>
<div class="section" title="Retrofitting support for older browsers"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Retrofitting support for older browsers</h1></div></div></div><p>For those of you <a id="id202" class="indexterm"/>who still have to support older browsers, such as IE6-8, then PostCSS can help—we can use the <code class="literal">postcss-mqwidth-to-class</code> plugin to generate hardcoded class rules, based on the media queries we specify, such as this example:</p><div class="informalexample"><pre class="programlisting">@media (min-width: 1024px) and (max-width: 1298px) {
  .bar { float: left; }
}</pre></div><p>If we compile it using this plugin, it will produce this result:</p><div class="informalexample"><pre class="programlisting">.min-width-1024px.max-width-1298px .bar { float: left; }</pre></div><p>Anyone spot the danger here? The code may be <span class="emphasis"><em>technically</em></span> correct, but it suffers from some limitations which make it less attractive: a risk of high levels of CSS specificity, media types are ignored (such as screen or print); and JavaScript may be required if adding classes to the <code class="literal">&lt;body&gt;</code> or <code class="literal">&lt;html&gt;</code> tags.</p><p>Ultimately it is down to us to decide what we need to use, but we should always be mindful that our code doesn't introduce new issues if we have to support older browsers! In this instance, a better <a id="id203" class="indexterm"/>alternative to consider is the <code class="literal">postcss-unmq</code> plugin (the source is available at <a class="ulink" href="https://github.com/jonathantneal/postcss-unmq">https://github.com/jonathantneal/postcss-unmq</a>); this removes media queries in favor of allowing us to create rules that adhere to specific screen sizes.</p><p>Now, whilst browsers such as IE8 should indeed be (forcibly) retired from active service, there is something to be said for considering if we can take it one step further, and start to move away from using responsive design techniques.</p><p>For example, conventional wisdom suggests that using rem values were a better alternative than using pixels. There is now a recent shift that suggests a blanket use (as many developers may have done) of rem units is less preferable, and that we should perhaps consider a blend of different units, to ensure content is correctly resized and maintains sufficient clarity. This is an important concept to consider as part of our development work in PostCSS, so let's take a moment to consider what this might mean for us.</p></div>
<div class="section" title="Moving away from responsive design"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Moving away from responsive design</h1></div></div></div><p>
<span class="emphasis"><em>"Moving away from responsive</em></span><a id="id204" class="indexterm"/>
<span class="emphasis"><em> design?? Have you really lost your marbles…??"</em></span>
</p><p>In answer to what many might consider a perfectly valid question, the answer is no—or as <span class="emphasis"><em>Polonius</em></span> might have put it in <span class="emphasis"><em>Hamlet</em></span>, "<span class="emphasis"><em>Though there be madness, yet there is method in't</em></span>".</p><p>In short, there is a good reason for considering this topic, as creating breakpoints using PostCSS is a cinch, but working out what they should be is the key to the success of our code. Many developers<a id="id205" class="indexterm"/> have blogged online about different types of media queries to use—examples for tablets, desktops, and laptops are widely available, and are frequently updated or replaced, if hardware changes.</p><p>Since Ethan Marcotte's popularization of the term "responsive web design" in 2010, many have accepted responsive design as an accepted standard for creating content for multiple devices or platforms. As a concept though, it is starting to lose favor with developers; an inherent weakness is the need to download multiple assets, even though only select versions of those assets may be used (such as larger or smaller versions of images). This of course increases bandwidth usage, and ultimately makes a site slower to navigate.</p><p>So, should we not use responsive design at all? Well, not entirely, but it depends on your circumstances. Instead of blindly adding media queries that add a layer of complexity, take a moment to consider if you <span class="emphasis"><em>really</em></span> need that media query.</p><p>As an alternative, consider using content specific breakpoints, in place of media equivalents; instead of tying our design to specific devices, we can work out where content can no longer be consumed properly, and build our breakpoint on this, rather than a known device width, which is likely to be changed.</p><p>Images, or specifically hi-resolution versions, are no longer an issue; in place of using a low and high res version of each, consider switching to SVG format. This scales beautifully (irrespective of device), and removes any issue with scalability on devices at a stroke. Granted, there are some known issues with support for IE, but most other browsers should be able to handle SVG without causing too many problems!</p><p>Fonts are another area where we can begin to reduce our use of media queries—here, we would need to look at using <code class="literal">vw</code>, <code class="literal">vh</code>, <code class="literal">vmin,</code> or <code class="literal">vmax</code> units; text will automatically resize if the browser viewport is resized. Adapting our code will require some manual changes; we can use the <code class="literal">postcss-vmin</code> plugin to provide some fallback for older versions of Internet Explorer.</p><p>Hopefully this has given you some food for thought—the key message here is that whilst the PostCSS plugin for media queries makes it really easy to implement, we should not blindly go ahead and implement lots of media queries, without considering if there are alternative means to achieve the same results.</p><p>Okay, let's move on: time to push the boat out a little; let's take a look at how we can take things further with CSS4 (as it is popularly known). We'll work on an example that allows us to simulate the new greater than or less than operators that can be used as part of CSS level 4 media <a id="id206" class="indexterm"/>queries.</p></div>
<div class="section" title="Taking things further with CSS4"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Taking things further with CSS4</h1></div></div></div><p>One of those small <a id="id207" class="indexterm"/>pet hates when working with media queries is that the query itself isn't really semantic; most queries will show something like <code class="literal">max-width: 1024px</code>, when we really mean <span class="emphasis"><em>…less than…</em></span> or <span class="emphasis"><em>…greater than…</em></span>.</p><p>Thankfully, with the upcoming changes to CSS in what most people call CSS4, we will be able to use <code class="literal">&gt;</code>, <code class="literal">&lt;</code>, or <code class="literal">=</code> symbols to express what we really mean in our code. The beauty about PostCSS is that we can emulate that<a id="id208" class="indexterm"/> functionality now, with the <code class="literal">postcss-media-minmax</code> plugin (available at <a class="ulink" href="https://github.com/postcss/postcss-media-minmax">https://github.com/postcss/postcss-media-minmax</a>); the plugin will convert these to the more familiar min- or max- statements that we already know.</p><p>It's a really easy plugin to use—we're going to break with convention here though, and use CodePen to demonstrate the plugin in action. CodePen will support a limited number of plugins, of which this is one of them—it's a perfect opportunity to see the effect of our query in action. For our demo, we're going to use the Font Awesome library to create some social media icons—our demo is loosely based on a version by Amey Raut:</p><div class="mediaobject"><img src="graphics/BO5194_04_11.jpg" alt="Taking things further with CSS4"/></div><p>You can see the demo at <a class="ulink" href="http://codepen.io/alibby251/pen/wKNMGL">http://codepen.io/alibby251/pen/wKNMGL</a>—the code that is of interest to us is from lines 70 to 79—notice the use of <code class="literal">&lt;=</code> and <code class="literal">&gt;=</code> in line 71:</p><div class="mediaobject"><img src="graphics/BO5194_04_12.jpg" alt="Taking things further with CSS4"/></div><p>When compiled, it shows this valid CSS:</p><div class="mediaobject"><img src="graphics/BO5194_04_13.jpg" alt="Taking things further with CSS4"/></div><p>The use of <a id="id209" class="indexterm"/>operators such as <code class="literal">&lt;</code> or <code class="literal">&gt;</code> in media queries is just a small part of what is coming in CSS4; for more details, take a look at the <a id="id210" class="indexterm"/>W3C editorial draft at <a class="ulink" href="http://dev.w3.org/csswg/">http://dev.w3.org/csswg/</a>—note, it makes for dry reading!</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Summary</h1></div></div></div><p>For anyone creating responsive sites, media queries are a core part of this process—PostCSS can easily help with creating the appropriate media queries that are needed for our projects. We've covered a number of key topics over the last few pages, so let's take a moment to consider what we've covered in this chapter.</p><p>For anyone creating responsive sites, media queries are a core part of this process—PostCSS can easily help with creating the appropriate media queries that are needed for our projects. We've covered a number of key topics over the last few pages, so let's take a moment to consider what we've covered in this chapter.</p><p>We kicked off with a quick review of standard media queries in CSS, before altering our code to use PostCSS as the basis for our queries. We then put this to good use in making images responsive, with a look first at the options available in PostCSS, before working through an example using PostCSS. We then switched to a common use of media queries for images, with a look at switching in a high resolution version for those devices that support their use.</p><p>We then switched to making text responsive, and discovered that it is a similar process that takes place, albeit using a different plugin. We then moved onto look at optimizing queries using PostCSS, before a quick review of some of the options available when retrofitting support for older browsers. We then rounded out the chapter to look at how we can use alternative techniques to make our sites responsive, without the need for media queries, before finishing with discovering a small part of what is available within CSS4, and how PostCSS can be used to make those techniques available today.</p><p>Phew, we certainly covered a lot: it doesn't stop there though! The next stop on our journey promises to be just as interesting; every website or online application will use different fonts, images, or colors in some form throughout the site. We'll take a look at how we can use PostCSS to make our lives just that little bit easier….</p></div></body></html>