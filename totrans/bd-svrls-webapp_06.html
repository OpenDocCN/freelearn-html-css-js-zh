<html><head></head><body>
        

                            
                    <h1 class="header-title">Developing the Backend</h1>
                
            
            
                
<p>Developing the backend without servers is the main drive of the serverless concept and what makes it so interesting. In this model, a paradigm shift is to break the project into small pieces of logic that can be deployed separately instead of one single bloated application. How to architecture this separation is covered in this chapter. Also, we will continue the development of our serverless online store building the backend using the REST principles.</p>
<p>In a nutshell, we will cover the following topics:</p>
<ul>
<li>An overview of serverless architectures</li>
<li>Organizing the project's code</li>
<li>How to create RESTful services</li>
</ul>
<p>After this chapter, you'll have built the backend of our serverless online store.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the project architecture</h1>
                
            
            
                
<p>In this section, we will cover four different architectural approaches for serverless projects:</p>
<ul>
<li><strong>Nanoservices</strong>: This is where <strong>each functionality</strong> has its <strong>own Lambda</strong> function</li>
<li><strong>Microservices</strong>: This is where <strong>each Lambda</strong> handles <strong>all HTTP verbs</strong> of a single resource</li>
<li><strong>Monolith</strong>: This is where <strong>one single Lambda</strong> function handles <strong>all functionalities</strong></li>
<li><strong>Graph</strong>: This uses the <strong>GraphQL</strong> standard, which is an alternative to REST APIs</li>
</ul>
<p>As we will see, each architectural approach has its pros and cons and there is no <em>silver bullet</em>. You need to weigh the benefits and choose what you think is the best for your specific use case. Let's see more about them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Monolith versus Microservices</h1>
                
            
            
                
<p>The first thing that we need to think about when choosing a serverless architecture is if the application will execute with just one Lambda function (<strong>Monolith</strong> or <strong>Graph</strong>) or if it will have multiple Lambdas (<strong>Microservices</strong> or <strong>Nanoservices</strong>). The number of Lambda functions represents how many deployment units it has.</p>
<p>A monolith is a self-contained application where all functionalities are developed in a single solution and a modification in one piece of the code requires a new deployment of the whole solution.</p>
<p>The microservices architecture is the opposite. You have multiple units that can be deployed separately, where each one is responsible for a distinct part of the whole solution. To follow the microservices architecture, you need to add modularity to the application. You break a large application into a set of small services that can communicate with each other through HTTP requests.</p>
<p>Microservices uses the concept of bounded context. For example, in an online store, we have a context for <strong>sales</strong>, which represents all business rules related to selling products, and another context for <strong>support</strong>, which involves the features related with customer service. We can separate those concerns considering that they have different business rules and are able to evolve independently. Modifications in a support rule must not impact a sales feature, so you can deploy one service without deploying the other, which makes it easier for different teams to work in different contexts at the same time.</p>
<p>In general, microservices offer the following benefits:</p>
<ul>
<li>Better separation of concerns and modularity</li>
<li>Independent and frequent deployment</li>
<li>Easier parallel development using separated teams</li>
</ul>
<p>As with everything else, it is accompanied with some drawbacks, which are as follows:</p>
<ul>
<li>More DevOps effort (which is mitigated by the Serverless Framework)</li>
<li>A distributed system adds complexity</li>
<li>Integration tests between multiple services are harder</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Nanoservices</h1>
                
            
            
                
<p>A nanoservice is the smallest part that you can extract from a monolithic application. You can split a monolith into multiple microservices, but those microservices can also be split into multiple nanoservices.</p>
<p>For example, you can have a <strong>users</strong> microservice that is responsible for handling all operations related with users such as create, retrieve, update, delete, password recovery, and others. <em>Retrieving</em> a user is a single functionality that can be very simple, implemented with less than 10 lines of code. If you create a Lambda function just for this piece of logic, you are creating a nanoservice.</p>
<p>The following diagram shows that each exposed functionality has its own Lambda function and an HTTP endpoint:</p>
<div><img class="image-border" height="212" src="img/fbbf9f4c-58b2-4876-8d33-3589541e5bcb.png" width="414"/></div>
<p>To build an application like this, we need to configure the <kbd>serverless.yml</kbd> file giving each function its own endpoint:</p>
<pre>
    functions:<br/>      retrieveUsers:<br/>        handler: handlers.retrieveUsers<br/>        events:<br/>          - http: GET users<br/>      deleteUser:<br/>        handler: handlers.deleteUser<br/>        events:<br/>          - http: DELETE users<br/>      retrieveProducts:<br/>        handler: handlers.retrieveProducts<br/>        events:<br/>          - http: GET products<br/>      createProduct:<br/>        handler: handlers.createProduct<br/>        events:<br/>          - http: POST products
</pre>
<div><p>Due to simplicity, this example has ignored the <kbd>OPTIONS</kbd> verb that would be required in this solution because the browser, in cross-origin requests, preflights an <kbd>OPTIONS</kbd> request to check the CORS headers before executing <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>PATCH</kbd>, and <kbd>DELETE</kbd>. We'll cover more about this later in this chapter.</p>
</div>
<p>For this architecture, we can list the pros and cons as follows:</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>Separation of concerns allows you to modify one feature without affecting other parts of your system. Autonomous teams will also benefit from a minimized number of conflicts.</li>
<li>Debugging problems is much easier when a function has a single responsibility.</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Performance can be slower. Since some functions will be rarely triggered, cold start delays will be more frequent.</li>
<li>In a big project, you can end up with hundreds of functions! A huge number of logical parts may cause more harm than benefit.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Microservices</h1>
                
            
            
                
<p>The microservices pattern adds modularization of functionalities related to the bounded context of an application. In this architecture, each Lambda function handles all HTTP verbs of a single resource. It generally results in having five endpoints (<strong>GET</strong>, <strong>POST</strong>, <strong>PUT</strong>, <strong>DELETE</strong>, <strong>OPTIONS</strong>) per function:</p>
<div><img class="image-border" height="197" src="img/979fae5f-25dd-479d-8655-30052162db06.png" width="376"/></div>
<p>The preceding system can be defined by the <kbd>serverless.yml</kbd> file as two bounded contexts, where all HTTP verbs of a given context reference the same Lambda function:</p>
<pre>
    functions:<br/>      users:<br/>        handler: handlers.users<br/>        events:<br/>          - http: GET users<br/>          - http: DELETE users<br/>      products:<br/>        handler: handlers.products<br/>        events:<br/>          - http: GET products<br/>          - http: POST products
</pre>
<p>This architecture has the following pros and cons:</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>Results in a reduced number of Lambda functions to manage</li>
<li>With less cold starts, performance can be slightly better than nanoservices</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Debugging is a little bit more complicated, since each function has more options and possible outcomes</li>
<li>Requires implementing a routing mechanism to handle each request correctly</li>
</ul>
<p>This routing mechanism can be implemented with a simple <kbd>switch…case</kbd> statement using the Lambda event to find the HTTP method and the REST resource:</p>
<pre>
    module.exports.users = (event, context, callback) =&gt; {<br/><br/>      switch(`${event.httpMethod} ${event.resource}`) {<br/>        case 'GET /users':      <br/>          users.retrieveUsers(callback);<br/>          break;<br/>        case 'DELETE /users':  <br/>          let id = JSON.parse(event.body).id;    <br/>          users.deleteUser(id, callback);<br/>          break;<br/>        default:<br/>          // handle unexpected path<br/>      }<br/>    };
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Monolith</h1>
                
            
            
                
<p>The monolith pattern uses just one Lambda function to handle all functionalities of our application. In this case, we have all of the application's endpoints triggering the same Lambda function:</p>
<div><img class="image-border" height="215" src="img/ac0aba89-cf96-4c75-8112-823ef5d39353.png" width="412"/></div>
<p>The preceding example can be represented as follows:</p>
<pre>
    functions:<br/>      store:<br/>        handler: handler.store<br/>        events:<br/>          - http: GET users<br/>          - http: DELETE users<br/>          - http: GET products<br/>          - http: POST products
</pre>
<p>A monolith architecture is not necessarily bad. For small applications that need to minimize cold delays, it can be indeed the best option. Let's now look at the pros and cons.</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>When all endpoints use the same Lambda function, the code will be constantly cached and cold starts will hardly happen</li>
<li>Fast deployments as there is just one resource</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Requires building a complex routing system to handle each request, for big applications, it can be transformed in a <em>big ball of mud</em></li>
<li>If the code base grows too much with too many dependencies, the performance of a single execution will be reduced</li>
<li>Debugging problems will be much more difficult</li>
<li>It's much harder to provision memory and set timeouts since each code path has a distinct execution</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Graph</h1>
                
            
            
                
<p>The Graph pattern is based on the GraphQL standard that was proposed by Facebook. It is an emerging technology with the objective to provide an alternative to RESTful APIs. Since it is growing in popularity among serverless projects, it deserves a section in this book.</p>
<p>In this pattern, we have just one Lambda function with a single endpoint. This endpoint is a query that will trigger the GraphQL to fetch the corresponding data in any form that the client needs:</p>
<div><img class="image-border" height="68" src="img/6ee76037-ced9-489e-a48d-b9e81f1866ed.png" width="404"/></div>
<p>Having just one endpoint is not a restriction. You can have multiple endpoints, but the objective of this pattern is to reduce the number of interfaces.</p>
<p>The <kbd>serverless.yml</kbd> file is very simplified:</p>
<pre>
    functions:<br/>      store:<br/>        handler: handler.store<br/>        events:<br/>          - http: POST query
</pre>
<p>Here, we will see a simple example of how to build a GraphQL API inside a Lambda function. Let's take a look at the following steps:</p>
<ol>
<li>Install the GraphQL module (<kbd>npm install graphql --save</kbd>) and require it inside the <kbd>handler.js</kbd> function:</li>
</ol>
<pre>
        const { graphql, buildSchema } = require('graphql');
</pre>
<ol start="2">
<li>The next step is to describe how your data is organized. In the following example, we have a <kbd>ShoppingCart</kbd> entity which contains a list of <kbd>Products</kbd> that the user wants to buy. The object key is the property name and the value is its data type. The schema is a string input that will be compiled by the <kbd>buildSchema</kbd> function:</li>
</ol>
<pre>
        const schema = buildSchema(`<br/>          type Query {<br/>            cart: ShoppingCart<br/>          }<br/><br/>          type ShoppingCart {<br/>            products: [Product],<br/>            promotionCode: String,<br/>            discountPercentage: Int<br/>          }<br/><br/>          type Product {<br/>            name: String,<br/>            code: String,<br/>            quantity: Int,<br/>            price: Int<br/>          }<br/>        `);
</pre>
<div><p>The <kbd>decimal</kbd> data type is not a built-in data type, but you can count money in pennies instead of dollars with the <kbd>integer</kbd> type. GraphQL offers the <kbd>float</kbd> data type, but it is not reliable for handling currencies.</p>
</div>
<ol start="3">
<li>Now, take a look in this JSON object that follows the defined schema:</li>
</ol>
<pre>
        const data = {<br/>          "cart": {<br/>            "products": [<br/>              {<br/>                "name": "Lonely Bird",<br/>                "code": "FOO",<br/>                "quantity": 1,<br/>                "price": 2999<br/>              },<br/>              {<br/>                "name": "Solid Friendship",<br/>                "code": "BAR",<br/>                "quantity": 1,<br/>                "price": 1999<br/>              }<br/>            ],<br/>            promotionCode: null,<br/>            discountPercentage: 0<br/>          }<br/>        };
</pre>
<p>In this example, the entire dataset will be provided as an input to the <kbd>graphql</kbd> function through the <kbd>data</kbd> variable. However, in a real-world application, it would not be feasible to load the entire database to memory. What is done in this case is to define a resolver function in the schema definition that tells the GraphQL engine how to fetch the required data, which means how to query the database.</p>
<ol start="4">
<li>After defining how your data is structured and where it is, you can use <kbd>graphql</kbd> to query the data. This query will be defined by the client and will be available in the <kbd>event</kbd> input of the Lambda function. For example, consider this query sent by the client:</li>
</ol>
<pre>
        const query = `{<br/>          cart {<br/>            products {<br/>              name<br/>              quantity<br/>              price<br/>            }<br/>            discountPercentage<br/>          }<br/>        }`;
</pre>
<div><br/>
In this query, the client wants to know the list of selected products, but there is some information that the client is not interested in. For example, the client doesn't want to know the <kbd>code</kbd> of the products or whether there is a <kbd>promotionCode</kbd> associated with this cart.</div>
<ol start="5">
<li>To use it in a Lambda function, call the <kbd>graphql</kbd> function passing the <kbd>schema</kbd>, <kbd>query</kbd>, and <kbd>data</kbd> arguments:</li>
</ol>
<pre>
        module.exports.store = (event, context, callback) =&gt; {<br/><br/>          const query = JSON.parse(event.body);<br/><br/>          graphql(schema, query, data).then((resp) =&gt; {<br/><br/>            const response = {<br/>              statusCode: 200, <br/>              body: JSON.stringify(resp)<br/>            };<br/><br/>            callback(null, response);<br/>          });<br/>        };
</pre>
<ol start="6">
<li>A request to this function would return the following JSON object:</li>
</ol>
<pre>
        {<br/>          "data": {<br/>            "cart": {<br/>              "products": [<br/>                {<br/>                  "name": "Lonely Bird",<br/>                  "quantity": 1,<br/>                  "price": 2999<br/>                },<br/>                {<br/>                  "name": "Solid Friendship",<br/>                  "quantity": 1,<br/>                  "price": 1999<br/>                }<br/>              ],<br/>              discountPercentage: 0<br/>            } <br/>          }<br/>        }
</pre>
<p>What makes GraphQL powerful is its simple syntax, that allows the client to request exactly what it needs and receive that data in the format that it expects. In this model, a single request can bring data from multiple resources. It can be an interesting alternative to RESTful APIs, but it also has its limitations. Ignoring the pros and cons related to REST, the following list compares the Graph pattern as a solution for a serverless architecture:</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>The Graph query can be a better replacement for the routing mechanism of the monolithic approach</li>
<li>When all endpoints use the same Lambda function, the code will be constantly cached and cold starts will hardly happen</li>
<li>Fast deployments as there is just one function and one endpoint</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>The Lambda size may hurt the performance if the code base grows too much with too many dependencies</li>
<li>It's much harder to provision memory and set timeouts since each query has a distinct execution</li>
</ul>
<p>GraphQL has many other features and requires extensive material, which is not the focus of this book. For a start, you can learn more at <a href="http://graphql.org/learn">http://graphql.org/learn</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Naming differences</h1>
                
            
            
                
<p>The Serverless Framework's team shares a similar view of the serverless architectures, which you can check out at <a href="https://serverless.com/blog/serverless-architecture-code-patterns">https://serverless.com/blog/serverless-architecture-code-patterns</a>.</p>
<p>However, what I call “nanoservices”, they call “microservices”. In my opinion, microservice is not a good term to describe the architecture style where every single feature is considered as one microservice. The concept of microservices was created to designate monolithic applications that were broken down into a few distinct pieces to better handle the management and evolution of features. When you have too many pieces, the principles do not apply so easily. Fortunately, the Serverless Framework makes it easier to handle dozens of services, but for a traditional application, when a microservice is too fine-grained, the overhead of maintenance and communication overweighs its benefits and, for the purpose of differentiation, it is called here a nanoservice.</p>
<p>Also, note that they have named the pattern that I call “microservices” as “services”. You can name these patterns as you prefer, but understand that those terms can be confusing.</p>
<p>The following diagram illustrates the difference between <strong>Monolith</strong>, <strong>Microservices</strong>, and <strong>Nanoservices</strong> architectures in my point of view:</p>
<div><img class="image-border" height="116" src="img/ce9ba8e3-a048-4e04-aba2-4171ecd97410.png" width="388"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing the backend</h1>
                
            
            
                
<p>After this overview of architectures, we can start building the backend. In this sample, which is only an experiment, I've opted for the monolith architecture because it reduces the cold start delays and our backend logic is very small. In your solution, you need to think about the use cases and weigh the benefits and drawbacks of each option.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the functionalities</h1>
                
            
            
                
<p>In the previous chapter, we developed the frontend and hardcoded some data to display static pages. Now, we are going to create the backend to expose the necessary information that will be used by the frontend. Take a look at the following frontend views and what functionalities they will need from the backend:</p>
<ol>
<li><strong>Home page</strong>: This page requires a list of all available products to display</li>
<li><strong>Product details</strong>: This page requires the detailed information about a product, including the list of user comments</li>
<li><strong>Shopping Cart</strong>: This page needs to display the selected products and allow the user to save or checkout the cart</li>
<li><strong>Signup page</strong>: The logic of this page will be implemented in <a href="5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml">Chapter 8</a>, <em>Securing the Serverless Application</em></li>
<li><strong>Login page</strong>: The logic of this page will also be implemented in <a href="5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml">Chapter 8</a>, <em>Securing the Serverless Application</em></li>
<li><strong>Page not found</strong>: There is no need to request the backend when the URL is invalid</li>
<li><strong>Error page</strong>: This page won't make any additional request to the backend when an error occurs</li>
</ol>
<p>Besides those pages, we have a Navbar component that will be displayed for all pages and it has a notification icon. We are going to implement this feature in <a href="ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml">Chapter 9</a>, <em>Handling Serverless Notifications</em>.</p>
<p>In a nutshell, we need to implement now the following functionalities:</p>
<ol>
<li>Retrieve all available products to sell</li>
<li>Retrieve the details of a specific product</li>
<li>Retrieve the list of selected products of the user's Shopping Cart</li>
<li>Save the list of selected products</li>
<li>Checkout a Shopping Cart</li>
</ol>
<p>To make it simpler, second and third features will be provided in the result of the first feature, which means that when the user requests the list of all available products, the response object will bring all information about each product, as well as the information on whether the user has added the product to the Shopping Cart.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing the code</h1>
                
            
            
                
<p>Choosing how to organize the files of a project is a personal choice. You just need to place the files using meaningful names that will make it easier to find them later. In this project, I've used the following structure:</p>
<div><img class="image-border" src="img/28bda533-e59c-4168-b0a6-dc249ef3672c.png"/></div>
<p>Here's a brief description about each folder shown in the preceding screenshot:</p>
<ul>
<li><kbd>functions</kbd>: These are the Lambda functions that will be directly deployed to AWS. We have just one function because our application is a monolith. This function will handle all things related to products. We don't need a Lambda function to handle user creation/authentication because we are going to use Cognito for this task.</li>
<li><kbd>lib</kbd>: This is the common application logic that can be used by different Lambda functions.</li>
<li><kbd>node_modules</kbd>: These are Node dependencies that were installed in this project folder and are referenced by the <kbd>package.json</kbd> file. They will be zipped to be used by the Lambda functions.</li>
<li><kbd>repositories</kbd>: This folder holds the infrastructure code to connect with the database and define the queries. It will be implemented in <a href="436e582c-0a4c-4257-b8eb-aa2c1dbd98c4.xhtml">Chapter 7</a>, <em>Using a Serverless Database</em>. In the screenshot, you can see that we are going to implement queries for SimpleDB and DynamoDB. The FakeDB will be used in this chapter to provide hardcoded data for testing.</li>
<li><kbd>test</kbd>: This folder holds the unit and integration test files. It will be implemented in <a href="">Chapter 10</a>, <em>Testing, Deploying, and Monitoring</em>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Referencing Lambda functions in other folders</h1>
                
            
            
                
<p>When you create a new service with the Serverless Framework, it will create a <kbd>serverless.yml</kbd> file to reference a sample function:</p>
<pre>
    functions:<br/>      hello:<br/>        handler: handler.hello
</pre>
<p>What you should note here is that <kbd>handler.hello</kbd> means that the Serverless Framework will try to find a <kbd>handler.js</kbd> file in the <em>same directory</em> as your <kbd>serverless.yml</kbd> file and look for an exported <kbd>hello</kbd> function. When you have a big project, you may prefer to separate your handler functions in subfolders. The syntax is pretty straightforward, <kbd>foldername/file.function</kbd>.</p>
<p>Consider the following example:</p>
<pre>
    functions:<br/>      hello:<br/>        handler: subfolder/handler.hello<br/>      goodbye:<br/>        handler: lambdas/greetings.bye
</pre>
<p>In this project, I've used the following code:</p>
<pre>
    functions:<br/>      products:<br/>        handler: functions/products.handler
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using multiple services</h1>
                
            
            
                
<p>Another thing that you should note is that the Serverless Framework will create a ZIP folder only with the contents that are in the same level of the <kbd>serverless.yml</kbd> file or lower. It is not possible to include dependencies of upper levels. The implication is that if your project uses two different services, each one of them with a distinct <kbd>serverless.yml</kbd> file, you can't share dependencies directly between them.</p>
<p>The following screenshot illustrates an example of a project with this issue:</p>
<div><img class="image-border" src="img/bfd77654-e53b-40e5-9bce-1cdf0157220c.png"/></div>
<p>The <kbd>greetings.js</kbd> file is a simple Node.js module with just one line of code:</p>
<pre>
    module.exports.saySomething = () =&gt; 'hello';
</pre>
<p>Both the <kbd>handler.js</kbd> files from <kbd>service1</kbd> and <kbd>service2</kbd> were implemented to return a message using the <kbd>greetings</kbd> module:</p>
<pre>
    const response = {<br/>      statusCode: 200,<br/>      body: JSON.stringify({<br/>       message: <strong>greetings.saySomething()</strong><br/>      })<br/>    };
</pre>
<p>The only difference between them is how the <kbd>greetings</kbd> module is loaded. In the first service, as it is in the same level, we load using the following code:</p>
<pre>
    const greetings = require('./greetings');
</pre>
<p>In the second service, we need to reference the <kbd>service1</kbd> file:</p>
<pre>
    const greetings = require('../service1/greetings');
</pre>
<p>If you test the <kbd>service2</kbd> function locally (<kbd>serverless invoke local --function hello</kbd>), it will run without problems, but it will fail if deployed to AWS because the ZIP file will not be published with the dependency.</p>
<p>The following are two solutions for this problem:</p>
<ul>
<li>Avoid using several services. Aggregate them into a single service and place the merged <kbd>serverless.yml</kbd> file in the project root.</li>
<li>Use local npm packages to manage common dependencies.</li>
</ul>
<p>Although I prefer the first option, the second option is also valid. To create a local npm package, browse to the folder that contains the common dependencies and run the following command:</p>
<pre>
<strong>    npm pack</strong>
</pre>
<p>This command will create a zipped package with the exact same format that would be created for a public <kbd>npm</kbd> module.</p>
<p>Now, in the folder that contains your serverless service, install the package locally using the following command:</p>
<pre>
<strong>    npm install ../path/to/pack.tgz</strong>
</pre>
<p>You need to repeat this process every time that the common dependency is modified. If it is constantly updated, you would need to include this stage into your build workflow.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting the endpoints</h1>
                
            
            
                
<p>As we already know, we need to create the API Gateway endpoints to expose to the world our serverless functions. This is done in the <kbd>serverless.yml</kbd> file, and the following example shows how to create the endpoints for the serverless store:</p>
<pre>
    functions:<br/>      products:<br/>        handler: functions/products.handler<br/>        events:<br/>          - http: GET products<br/>          - http: POST cart     # create the cart (new order)<br/>          - http: OPTIONS cart<br/>          - http: PUT checkout  # update the order (status = sent)<br/>          - http: OPTIONS checkout
</pre>
<p>Setting an <kbd>OPTIONS</kbd> endpoint is mandatory in cases where you want to support the <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>PATCH</kbd>, or <kbd>DELETE</kbd> verbs in a cross-origin request. The reason is a security measure used by browsers, that is, before making an HTTP request that can modify the resource, it preflights a request with <kbd>OPTIONS</kbd> to check whether CORS is enabled and whether the HTTP verb is allowed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RESTful APIs</h1>
                
            
            
                
<p>If you are not already familiar with RESTful APIs, you should know at least the following common HTTP verbs and how they are used:</p>
<ul>
<li><kbd>GET</kbd>: This is used to request data to the server</li>
<li><kbd>POST</kbd>: This is used to create or modify resources:
<ul>
<li><kbd>POST/resource</kbd>: Without an ID, a new element will be created</li>
<li><kbd>POST/resource/id</kbd>: If you know the ID and pass it in the request, the element will be updated, however, it is typically used only to create and not to update resources</li>
<li><kbd>POST/resource/new-id</kbd>: If there is no resource for a given ID, this request must return an error</li>
</ul>
</li>
<li><kbd>PUT</kbd>: This is used to create or modify the following resources:
<ul>
<li><kbd>PUT/resource</kbd>: This should return an error because the ID is expected</li>
<li><kbd>PUT/resource/id</kbd>: This replaces the entire object with the data provided</li>
<li><kbd>PUT/resource/new-id</kbd>: If there is no resource for a given ID, it will be created</li>
</ul>
</li>
<li><kbd>PATCH</kbd>: This is used to do partial updates, instead of replacing the entire resource with the given data, it won't update or remove properties that do not match with the input</li>
<li><kbd>DELETE</kbd>: This is used to delete resources and an ID must be provided</li>
<li><kbd>OPTIONS</kbd>: This returns the allowed HTTP verbs and informs if CORS is enabled</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Routing the HTTP verbs</h1>
                
            
            
                
<p>As already exemplified, for our routing strategy, we can use a <kbd>switch…case</kbd> statement using <kbd>httpMethod</kbd> and <kbd>resource</kbd> to identify the path. I suggest adding a <kbd>try…catch</kbd> statement to warn the client about unexpected errors instead of letting Lambda swallow the messages.</p>
<p>The following example shows how to implement the routes for the <kbd>products</kbd> function:</p>
<pre>
    module.exports.handler = (event, context, callback) =&gt; {<br/><br/>      const userId = '1'; // TODO: retrieve from authentication headers<br/>      try {<br/>        switch(`<strong>${event.httpMethod} ${event.resource}</strong>`) { <br/><strong>          case 'GET /products': </strong><br/>            products.retrieveAll(userId, callback);<br/>            break;<br/><strong>          case 'POST /cart': </strong><br/>            const selectedProducts = JSON.parse(event.body).products;<br/>            cart.saveCart(userId, selectedProducts, callback);<br/>            break;<br/><strong>          case 'OPTIONS /cart': </strong><br/>            utils.optionsHandler(callback);<br/>            break;<br/><strong>          case 'PUT /checkout': <br/></strong>            const id = JSON.parse(event.body).id;<br/>            checkout.processCheckout(id, callback);<br/>            break; <br/><strong>          case 'OPTIONS /checkout': </strong><br/>            utils.optionsHandler(callback);<br/>            break;<br/>          default:<br/>            utils.notFoundHandler(callback);<br/>        }<br/>      } catch (err) {<br/>        utils.errorHandler(err, callback);<br/>      }<br/>    };
</pre>
<p>Remember that you need to run <kbd>serverless deploy</kbd> to create the Lambda function and endpoints, but after that, the command <kbd>serverless deploy function --function products</kbd> can be used for a faster deployment.</p>
<p>The next section will explain how the <kbd>utils</kbd> module was created to handle the responses.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling HTTP responses</h1>
                
            
            
                
<p>Usually, we need to handle at least four response types:</p>
<ol>
<li><strong>Success</strong>: Return HTTP <kbd>200 OK</kbd> when the request is processed successfully.</li>
<li><strong>Error</strong>: Return HTTP <kbd>500 Internal Server Error</kbd> when an error happens in the backend.</li>
<li><strong>Not found</strong>: Return HTTP <kbd>404 Not Found</kbd> when the client requests a resource that doesn't exist.</li>
<li><strong>Options</strong>: Return HTTP <kbd>200 OK</kbd> along with the allowed methods for this resource.</li>
</ol>
<p>There are many other HTTP status codes, like <kbd>400 Bad Request</kbd> when the client sends a request without the necessary parameters, but covering an extensive list of status codes is out of the scope of this book and most of them are not used in the majority of applications.</p>
<p>The following code snippet shows how to implement those handlers:</p>
<pre>
    const corsHeaders = { <br/>      'Access-Control-Allow-Origin': '*' <br/>    };<br/><br/>    module.exports.successHandler = (obj, callback) =&gt; {<br/>      callback(null, {<br/>        statusCode: 200,<br/>        headers: corsHeaders,<br/>        body: JSON.stringify(obj)<br/>      });<br/>    };<br/><br/>    module.exports.errorHandler = (err, callback) =&gt; {<br/>      callback(null, {<br/>        statusCode: 500,<br/>        headers: corsHeaders,<br/>        body: JSON.stringify({<br/>          message: 'Internal Server Error',<br/>          error: err.toString()<br/>        })<br/>      });<br/>    };<br/><br/>    module.exports.notFoundHandler = (callback) =&gt; {<br/>      callback(null, {<br/>        statusCode: 404,<br/>        headers: corsHeaders,<br/>        body: JSON.stringify({ message: 'Not Found' })<br/>      });<br/>    };
</pre>
<p>Regarding the <kbd>OPTIONS</kbd> verb, we need to answer the requests with the status code <kbd>200 OK</kbd> and set the allowed methods and headers:</p>
<pre>
    module.exports.optionsHandler = (callback) =&gt; {<br/>      callback(null, {<br/>        statusCode: 200,<br/>        headers: {<br/>          "Access-Control-Allow-Origin": "*",<br/>          "Access-Control-Allow-Methods":<br/>            "GET, POST, PUT, PATCH, DELETE, OPTIONS",<br/>          "Access-Control-Allow-Headers":<br/>            "Accept, Content-Type, Origin"<br/>        }<br/>      });<br/>    };
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the Lambda functions</h1>
                
            
            
                
<p>In this section, we are going to see how to implement the backend features. After implementing and deploying the Lambda functions, we can modify the frontend code to make Ajax requests to the backend.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Retrieving all products</h1>
                
            
            
                
<p>This feature has the following three responsibilities:</p>
<ul>
<li>Retrieve all products from the products table</li>
<li>Retrieve all user comments/ratings and join them with the product list</li>
<li>Retrieve the user Shopping Cart and merge with the product list to identify what products were already selected</li>
</ul>
<p>Those queries will be created and executed by <kbd>repository</kbd> and its implementation will be defined in the next <a href="cb2f92df-5bc3-4c8e-8872-fbee58e5b0be.xhtml">Chapter 7</a>, <em>Managing a Serverless Database</em>.</p>
<p>By now, let's use the FakeDB to return hardcoded values:</p>
<pre>
    const db = require('../repositories/fakedb');<br/>    const utils = require('./utils');<br/><br/>    module.exports.retrieveAll = (userId, callback) =&gt; {<br/>      db.retrieveAllProducts(userId, (err, res) =&gt; {<br/>        if (err) utils.errorHandler(err, callback);<br/>        else utils.successHandler(res, callback);<br/>      });<br/>    };
</pre>
<p>In this case, the FakeDB will just return a list of products:</p>
<pre>
    module.exports.retrieveAllProducts = (userId, callback) =&gt; {<br/>      const comments = [{<br/>        id: 1,<br/>        username: "John Doe",<br/>        age: "3 days ago",<br/>        text: "I'm using this to decorate my desk. I liked it."<br/>      }];<br/><br/>      const products = [{<br/>        id: "lonely-bird",<br/>        name: "Lonely Bird",<br/>        image: 'https://s3.amazonaws.com/...',<br/>        price: 29.99,<br/>        isSelected: yes,<br/>        comments: comments<br/>      }];<br/><br/>      callback(null, products);<br/>    };
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Saving the Shopping Cart</h1>
                
            
            
                
<p>This request receives as the input a list of selected products and the <kbd>UserID</kbd>. In our sample application, the <kbd>UserID</kbd> will uniquely identify the shopping cart, which means that each user has just one cart.</p>
<p>If the user is logged in, the frontend knows the <kbd>UserID</kbd>. However, we can't receive an <kbd>ID</kbd> directly from the client and take actions trusting that this information is valid. We know that a malicious user can modify the JavaScript code to send an <kbd>ID</kbd> of another user.</p>
<p>For a reliable operation, we must analyze the authentication tokens that are passed through the headers of all requests from logged users and check if the <kbd>ID</kbd> is correct. This step will be implemented in <a href="5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml">Chapter 8</a>, <em>Securing the Serverless Application</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking out</h1>
                
            
            
                
<p>Handling payments is a complex feature that won't be covered in this book. So, when the user tries to checkout the Shopping Cart, a message will be displayed to show that this is just a demo application.</p>
<p>However, we can use this feature to learn how serverless notifications work. When the user starts a payment process, the backend receives the credit card information and makes a request to process the payment. As this step can take a long time, instead of using the client to make repetitive requests (polling), we can use WebSockets to notify the user when the response is available. Serverless notifications will be covered using IoT in <a href="ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml">Chapter 9</a>, <em>Handling Serverless Notifications</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you have learned the serverless architectures such as nanoservices, microservices, monolith, and Graph. For our serverless store, the monolith architecture was selected and used to build the backend. We also covered how to structure the project's code and build RESTful APIs.</p>
<p>In the next chapter, you will learn about the SimpleDB serverless database. Due to the fact that SimpleDB may not be good enough for most applications, we are also going to learn about DynamoDB, which is not a serverless database, but requires minimal management.</p>


            

            
        
    </body></html>