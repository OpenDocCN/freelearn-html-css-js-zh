- en: Chapter 3. Building a Live Data Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is going to be a fun chapter. So far, we've created two relatively simple
    applications. In both cases, we mainly created and read data from the browser.
    While it's all browser-side stuff, it's pretty static. This time, we're going
    to do something a lot more interesting; we're going to build a table that keeps
    a track of events. In an interesting twist, though, we'll build a table that will
    automatically update based on changes made in other browsers that have our app
    open.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a couple of chapter spoilers:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at better code organization through multiple files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll write code to update and delete model instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll build an app that polls the server to keep its collection up to date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once again, we''ll start with the project template; however, there are a few
    modifications we need to make in our last two projects. You may have noticed that
    our `app.js` file was getting a bit lengthy; this makes it tough to navigate between
    our components and to keep our code clean and manageable in general. So in this
    project, we''re going to split our Backbone code into multiple files. We''re going
    to keep our models and collections in `models.js`, our views in `views.js` and
    our router in `router.js`. You can go ahead and create these files (they''ll be
    empty for now) in the `public` folder; also, remove `app.js`. Then, in the `index.ejs`
    file, we''ll need to replace the script tag for `app.js` with script tags for
    those new files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Planning our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we started writing code immediately. However, in the
    real world, you're not going to have me to tell you what to write from the beginning.
    You're going to have to plan your own application. So let's take a moment and
    do that now.
  prefs: []
  type: TYPE_NORMAL
- en: We want to build an application that will show us a list of past and upcoming
    events. An event will have a title, a description, and a date on which it occurs.
    This type of data can be nicely displayed in a table. We'll need to be able to
    create new events, but we also want to be able to edit and delete the existing
    events. We also want to periodically poll the server for changes to the set of
    events so that all the connected clients are up to date.
  prefs: []
  type: TYPE_NORMAL
- en: As this is a pretty basic application, that will be all. Now that we've clarified
    what it needs to do, we can start thinking in terms of Backbone components. Obviously,
    we'll need an `Event` model and an `Events` collection. The table will be an `EventsView`
    instance, and each row will be an `EventView` instance. We'll need a form that
    is used for creating new events, say the `CreateEventView` class, and another
    form that is used for editing the existing events, say the `EditEventView` class.
    We don't need a whole view used for removing events; we just need a button, probably
    in the `EventView` class.
  prefs: []
  type: TYPE_NORMAL
- en: What about routes? The whole table can be displayed at the home route, which
    is `/`. The creation form can be at `/create`, and the edit form can be at `/edit/<id>`.
  prefs: []
  type: TYPE_NORMAL
- en: And that's about it! This doesn't really represent the planning process of a
    real application, but it should make you realize that building applications is
    about much more than just writing code. There are smart processes you can follow
    to facilitate the process. If you're relatively new to programming, you should
    look into topics such as agile development or test-driven development. When you're
    starting out, these ideas may seem to make your projects take longer than necessary,
    but believe me, they will make building and maintaining big projects much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up precompiled templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by talking about the templates we use for our view classes. In the
    previous chapter, we've put our template source text right in the `index.ejs`
    file, inside script tags. This time we're going to do something different. We're
    going to precompile our templates. Think about the timeline of a template; it
    starts as text in a script tag. We've been getting that text and passing it to
    the `_.template` function that compiles the text into a `template` function, which
    it returns to us. Then, we pass our data to that function and get the HTML with
    our data interpolated back. All this must be done before we can display anything
    for the user.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do is cut a few steps out of this process. We want to send the
    `template` function to the browser, instead of sending the template text and having
    the browser compile it. To do this, we need to compile the templates as part of
    our development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to do this is to use Grunt, a handy build tool. First, we''ll
    need to install it, using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We won't be learning Grunt in depth here. If you aren't familiar with the library,
    there are many great resources to learn about it online. Start on the home page
    [http://gruntjs.com/](http://gruntjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: We're using npm to install both Grunt and the **JavaScript Templates** (**JST**)
    Grunt plugin. JST will do the compiling for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to need a `Gruntfile.js` file, which will configure this
    plugin. Put `Gruntfile.js` in the root of our project directory. In that file,
    start with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You might recollect that, in the previous chapter, we used the `exports` object
    to export functions from our `signin.js` module. We can also completely overwrite
    that `exports` object; however, when we do that, we have to use its full name,
    `module.exports`. To this we assign a function that takes a `grunt` object as
    a parameter. Inside this function, then, we configure Grunt for our project.
  prefs: []
  type: TYPE_NORMAL
- en: We start by calling the `initConfig` method, which configures all the plugins.
    After this, we register the plugin with Grunt; and finally, we can register a
    task. We're creating the default task, which will run when we call `grunt` on
    the command line. We're simply telling it to run the `jst` task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to that `initConfig` method call for a second using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We start with a `jst` property, because that's the name of the task we're configuring.
    Inside that, we create a target, which is a set of options for our task and the
    files we want to perform the task on (with those options). We're calling our target
    `templates`. The first option is the `templateSettings` object, which we've used
    in both the previous chapters; it allows us to use the curly-brace delimiter syntax.
    The second option that we're setting is a function that will name the templates.
    Our templates will be HTML files in the `templates` folder, so by default their
    names will be their file paths; something like `templates/event.html`. The `processName`
    function will convert that to just `event`. This name is how we will refer to
    them from the view code.
  prefs: []
  type: TYPE_NORMAL
- en: In `files`, we choose what files to work on. Here, we're saying that all the
    template files that match the string, `templates/*.html`, will be compiled into
    `public/templates.js`.
  prefs: []
  type: TYPE_NORMAL
- en: This might seem like a lot to set up, but now all we need to do is run `grunt`
    on the command line to get precompiled templates. We'll test this out when we
    make our views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve set up our template-creating process, let''s begin with the
    project code. As earlier, we''ll begin with the models. These will go in `models.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For now, this will do. We'll be coming back later to make some interesting changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `server.js` file, we''ll make our route functions for the route we just
    defined in the `Events` class. Before that, though, we''ll need our database.
    We create that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This time, I'm putting the database JSON file in a folder of its own; if you
    want to do this, make sure you create the `db` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now, with the database in place, we can create the GET route. This will
    simply send all the records in our database back to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The POST route is where the data for new event objects will be sent. We''ll
    collect the properties into an object and insert it; our callback function can
    just send the updated record back to the browser. Here''s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One more server method, and that''s for the root route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This route is very similar to the get-all routes in both our previous chapters.
    It will render our `index.ejs` template, sending all our event records to the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin with some controls. As we had decided, we'll need to be able to
    open a form to create new events, so let's put a button for this on a control
    bar at the top of our page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with the template. If you haven''t yet started, create a directory
    named `templates` at the root of our project. Inside that, create a file named
    `controls.html`, and put the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re only going to have one control, and it doesn''t actually need to be
    a template, but this gives us the ability to easily extend it later. We can actually
    test out the precompiling now, by running `grunt` on the command line. When you
    do that, you should get a message saying that **File "public/templates.js" created**.
    Great! You can check out the content of that file if you want to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s rather messy, but it will do the job for us. The important thing to notice
    is that we can now reference this template function via `JST.controls`. The last
    step here is to include this script in our `index.ejs` file, just above our script
    tag from `views.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Speaking of `views.js`, we''re ready to open that up and get cracking at the
    view from this template. We''ll call it `ControlsView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As our template is a group of list items (well, a single list item), it makes
    sense that we use a `<ul>` element for this view. Then, notice that we're getting
    our template from the `templates.js` file, via `JST.controls`; handy, no? The
    `render` function is very basic. It just renders our template; we don't even need
    to pass it any data. It's more interesting that we're listening for the click
    event on our **Create Event** link. When that happens, we'll prevent the default
    behavior, which is requesting the `/create` route from the server, and instead
    we'll send it to our Backbone router.
  prefs: []
  type: TYPE_NORMAL
- en: We did this in [Chapter 1](ch01.html "Chapter 1. Building a Simple Blog"), *Building
    a Simple Blog*, but we did it differently. Back then, we used the actual router
    object inside our views; we just expected it to be available as a global variable.
    That was a bad idea. This time, we're improving on that in two ways. First, we're
    expecting to receive the router as a property in our `options` object when this
    view is created. You can see in the `initialize` function that we're assigning
    `this.nav` from `options.nav`. The second improvement is that this isn't actually
    the whole router object; it's just the router's `navigate` method. This way, we
    can give select views the power to change routes, and they still can't mess with
    the rest of the router.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a software design pattern known as dependency injection. Basically,
    the router's `navigate` method is a dependency that we are injecting into our
    `ControlsView` class. This allows us to keep unrelated code separate, which can
    make updating this code in the future a simpler process. For example, if we need
    to change the way routing is done in our application, we only need to inject a
    new or an updated dependency into this class, and hopefully not change much at
    all in this class. Dependency injection is one way to follow the dependency inversion
    principle, one of the five SOLID design principles. To read more about them, start
    at the Wikipedia page [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you're probably wondering about the `className` property. As you perhaps
    suspect, this sets the `class` attribute on our elements. But where are these
    classes coming from? Well, in this application, we're going to be using Twitter's
    Bootstrap library, and these classes create a basic navigation/controls bar.
  prefs: []
  type: TYPE_NORMAL
- en: Including Bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, for this to work, we''ll have to add this library to our projects.
    You can head over to [http://getbootstrap.com](http://getbootstrap.com) and click
    on **Download Bootstrap**. There are a bunch of files here, but we don''t need
    them all. In our project''s `public` directory, create a folder named `css`, and
    copy the `bootstrap.min.css` file into that. We''ll also need `bootstrap.min.js`,
    which we''ll put in the `public` folder. Bootstrap also comes with the GLYPHICONS
    fonts ([http://glyphicons.com/](http://glyphicons.com/)), so you''ll have to create
    a `fonts` folder in the `public` directory, and copy the font files from Bootstrap''s
    `font` directory. With these pieces in place, we can add a link to the `stylesheet`
    tag in the head of the `index.ejs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, at the bottom, we link to the JavaScript portion of Bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you aren't familiar with **GLYPHICONS**, it's a collection of symbols that
    you can use for icons within your web applications. Usually, you have to buy a
    license, but a few of them are provided with Bootstrap, free for its users.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to render our controls, we need to start building our router. We have
    created a `router.js` file, so let''s open that up, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From our `initialize` function, we can see that we expect to get our main element
    and an `Events` collection as properties of our `options` object. We're also creating
    a `nav` property; this is the `nav` method that we saw in `ControlsView`. It's
    important to realize that we can't just send `this.navigate`; we need to make
    sure that the function is bound to the router object, which we do with its `bind`
    method. When we bind a function in this way, we're creating a copy of the function
    whose value of `this` (inside the function copy) is whatever object we pass as
    a parameter to `bind`; so anywhere we call the function that is stored in `this.nav`,
    the value of `this` will be consistent. To learn more about `this` in JavaScript,
    the JavaScript Garden is a great resource and is available at [http://bonsaiden.github.io/JavaScript-Garden/#function.this](http://bonsaiden.github.io/JavaScript-Garden/#function.this).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our index route is pretty simple right now. We''re just rendering our controls.
    It''s a start, however! Now, in `index.ejs`, we can instantiate the router as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start the server up (`npm start`) and load the page. This should
    look like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the router](img/6997OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we now have a button, it makes sense to get that button working. Right now,
    when we click on the button, our route changes to `/create`; but nothing else
    changes, because we haven''t created that route yet. So add this to our router''s
    routes object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And then add the `following` function to the router as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We haven't created the `CreateEventView` view class yet, but you can see that
    we'll pass it our collection of events and our `nav` method. We'll render it and
    append it to the main element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might recall from the previous chapter that we didn't name the collection
    property `collection` when we weren't rendering it, so other developers reading
    our code won't confuse the purpose of giving the view a collection. However, we
    are naming it `collection` in this case because the `events` property is already
    used by Backbone to assign DOM events.
  prefs: []
  type: TYPE_NORMAL
- en: Building the CreateEventView class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So let's create the `CreateEventView` view class. Now, let's throw a twist in;
    since we have Bootstrap on our page, why don't we use its modal component to display
    our form?
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll begin by creating our template. Create `templates/createEvent.html`
    and put this in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a lot of HTML, but you can see the form in the middle there, right? Actually,
    the Bootstrap model requires another wrapping `<div>`, but the view class will
    provide that. Here''s the first portion of that view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we start with, and it''s a very basic view. The most important
    thing to notice here is the `className` property; these classes style the modal
    window. However, at this point, if we compile our template and click on our button,
    our modal window won''t appear. What''s up with that? If you inspect the page
    in the developer tools of your browser, you''ll see that the view''s HTML is added
    to the page, but it isn''t viewable. You can see that in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the CreateEventView class](img/6997OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The problem is that we need to use Bootstrap''s jQuery modal plugin, which
    we had loaded earlier (`bootstrap.min.js`). We can use this plugin to show and
    hide the modal. To show the form, it''s as easy as adding the following line of
    code to our `render` method, right after calling the `template` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We get the "jQuer-ified" element and call the `modal` method, passing it the
    command to show the modal window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add a few events to this class. There are two buttons to
    consider: the **Create Event** button (to create new `Event` model) and the **x**
    button (to close the modal window, not creating a new model):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `close` method will be very simple. See the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We prevent the default action of the button, and then hide the modal window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how about writing the `create` method? We write it using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We collect all the properties for our new event object and use the collection's
    `create` method to send the data to the server. We're passing the `wait` option
    because we'll soon have views listening for the creation of new events. This way,
    the views won't be notified until this event object has been successfully saved
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: There's one piece of this puzzle left; when either of the buttons are clicked,
    the modal is closed, but its DOM elements still exist. To get rid of the elements
    that make up the view, we need to call the view's `remove` method. This method
    gets rid of the elements and removes any event handlers connected to those elements.
    So when exactly should we call this `remove` method? Well, when we hide the modal,
    it will fade out; we need to remove the view after that. Handily, the jQuery plugin
    that we're using emits events at different points. We can listen for the `hidden.bs.modal`
    event, which will fire once the modal's fade-out sequence has completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the view''s `initialize` method, we''ll listen for that event using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When it fires, we''ll call the `hide` method on our view. That method looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We call the view's `remove` function to get rid of the DOM and events; then,
    we use the `nav` method to send our users back to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s pause for a moment and think about how the user might go through
    our application. They can start on the home page and click on the **Create Event**
    button, which will take them to the `/create` route. However, it doesn''t reload
    the page; it just fades in the modal. When they close the modal window (either
    by submitting the form or closing the form), they''ll be taken back to the home
    route; the form will fade out and the control bar will still be there. However,
    it''s also possible that the user will go directly to `/create`. They''ll get
    the form, which will work fine; however, when they close the modal, they''ll be
    taken back to the home route, but the page will be blank. This is because we''re
    not triggering the router''s `index` method when we move back to that route (no
    `{trigger: true}`). Why not trigger that method?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re not triggering it because there''s a better way here; even if the user
    goes directly to `/create`, we want to render the controls (and the table that
    will eventually be there). This means that, in the `create` router method, we
    need to check to see whether `index` has been called yet. In our case, we''ll
    do that simply by checking for the existence of the navigation. In the `create`
    method, add this just before appending the `CreateEventView` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, if a user goes directly to the `/create` route, the router's `index` method
    will be called if it hasn't been rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the events table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we're successfully creating new event records and storing them
    in our database. The next step is to display the table of events. We'll start
    with the `EventsView` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, we''ll start with template for this view. In `templates/events.html`,
    we''ll create the `thead` and `tbody` elements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our table will show the five fields that our events have. We
    also have a sixth column for actions: the edit and delete actions. We have a data
    attribute on each one of the table heading elements, with names that match the
    property names of the `Event` records. We''ll use these later for sorting. You
    can go ahead and run `grunt` on the command line to compile this template function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how about `EventsView`? We can compile this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We start by making the element for this view a table; we're also adding the
    class `table` to get Bootstrap's table styling. In the `initialize` method, we
    can see that we're taking the `nav` method in the `options` object so that we
    can change routes. In `render`, we're rendering the template and then calling
    `renderRows`. The `renderRows` method loops over every item in our `Events` collection
    and calls `addRow`. You might wonder why we don't put the single line of code
    in this method right in the `render` method; it's because we'll need it in its
    own method later. That `addRow` method will take a single event object as a property
    and render an `EventView` instance, placing it in that `tbody` element that we
    put in the template. We'll be coming back to this view to add and adjust things,
    but let's go over to the `EventView` class now.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did earlier, we''ll start with the template. The following code snippet
    should be the content of `templates/event.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first portion of the template is simple. We're just placing the properties
    of the `Event` object in the `<td>` elements. In the last `<td>` element, we've
    got two buttons; we're using Bootstrap's button and Glyphicon classes to get the
    right styling. These will be the edit and delete buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is the start of the `EventView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It is similar to the other views that we''ve seen so far. The `render` method,
    however, will be slightly more involved. Before that, we need to add another third-party
    library: Moment ([http://momentjs.com/](http://momentjs.com/)). This library is
    a great tool to use for quickly formatting dates. Download the script from the
    website and add it to the `index.ejs` file, anywhere above the `views.js` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, we can add a `render` method to the `EventView` class as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is easily the most complex `render` method that we've seen yet. We start
    with a few variables. We get the attributes of our model first. Then, we create
    a `moment` object and pass it the `date` property of our model. A `moment` object
    wraps a date and gives us access to several helpful date-related methods. Finally,
    we use Moment's `unix` method (which returns the time in seconds since the Unix
    Epoch) to get the difference between the time this event takes place and right
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use that `date` object we just created to overwrite the default date
    value in the attribute object to be something more readable. We're using Moment's
    `calendar` method to give us a date string such as `Monday at 6:30 PM` (or `10/30/2014`
    for dates further away). Then, we replace the `createdOn` property with a different
    date string. With the Moment's `fromNow` method, we get a string such as `6 hours
    ago`. Then, we pass our updated attributes object to the `this.template` function
    for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: After rendering, we make one final adjustment. Bootstrap has a few handy classes
    used for coloring table rows, so we'll color a row differently depending on the
    time of the event. If the value of `diff` is less than 0 (which means the event
    began some time before this table was rendered), we'll add the `danger` class,
    resulting in a red row. If the event occurs within the next two days (`diff <
    172800`), we'll go with `warning` (a yellow row). If the event is in the next
    week (`diff < 604800`), the `success` class gives us a green row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s head back to the router to put the `EventsView` and `EventView` classes
    to work. Here''s the new `index` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can reload the home page and see the table. If you add
    a few events, you should see something like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the events table](img/6997OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Things are looking pretty good at this point, you'll have to agree. However,
    there's still a lot to do before we finish this application. Let's begin by getting
    that delete button to actually delete a record.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the button is already in place, we just have to wire it up. In `EventView`,
    let''s add the event listener as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You know what''s next. We need to create the `destroy` method in the `EventView`
    class. It can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `destroy` method will call the model's `destroy` method and then call this
    view's `remove` method. Normally, that would be all, but we want to add a touch
    more. We want to fade the table row out and then remove the DOM elements. So,
    we're overwriting the default Backbone View `remove` method. We'll use jQuery
    to fade the element out. The `fadeOut` method that jQuery has takes a callback,
    a function that will be called after the fadeout is complete. We can get the usual
    Backbone View `remove` method from the `Backbone.View.prototype` object. Of course,
    we have to call it on the right view instance by binding the method to the current
    view, `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t called a Backbone model''s `destroy` method before, as we''re doing
    here in the view''s `destroy` method. This method sends a DELETE request to the
    server, to the route `/events/<id>`. We''ll need to create a method for this in
    our `server.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty basic; our database has a `delete` method, so we call that, passing
    it a query object with the `id` we get from the route. What we return is irrelevant,
    so we'll return an empty object.
  prefs: []
  type: TYPE_NORMAL
- en: With that code in place, you can now click on the delete button in any of our
    events' table rows, and that row will fade away. Refresh the page, and you'll
    see that it's gone for good.
  prefs: []
  type: TYPE_NORMAL
- en: Editing event records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to allow users to edit their event records. Wiring up our
    edit button will be simple. First, we listen for the click in the `events` object
    of `EventView`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And secondly, we navigate to the edit route for that event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We want our edit routes to act just like our create route does. If the user
    clicks on an edit button, a modal will fade in and allow editing of the event
    records. But they should also be able to go directly to the edit route and the
    table will load under the modal. This means that our router's `edit` method should
    be very similar to its `create` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll add the route to the router''s `route` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `edit` method itself using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We haven''t created `EditEventView` yet, but if you look back at the `create`
    method, you''ll see how similar these both are. That calls for a little refactoring
    as we have done in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We've pulled the common code out into a `modal` method. Then, in both `create`
    and `edit`, we pass the view we want to render to that method.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create the `EditEventView` class. If you pause for a moment
    and think about this, you'll realize that since we want it to act like the `CreateEventView`
    class, it'd be great if we could somehow reuse as much of the code for that view
    as possible. Really, the main difference between the `create` and `edit` views
    is that, in the `edit` view, the current values of the record will already be
    in the form input elements. We'll also want the form heading and button text to
    be appropriately changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with the `createEvent.html` file under `templates`. We''ll prepare
    it to take the values we need to pass to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we're not just expecting values in the form input elements, we're
    also expecting a heading and text for the button. And, as this template will be
    used by both `CreateEventView` and `EditEventView`, let's rename it to `templates/modifyEvent.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to recompile the template (`grunt`, on the command line).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since almost all the behavior we want for the `EditEventView` class is the
    same as we created for the `CreateEventView` class, let''s extract as much as
    possible out into a `ModifyEventView` class. The following code is what we have
    come up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There are a few key differences between this class and the `CreateEventView`
    class. First, notice that in the `render` method, we're adding `heading` and `btnText`
    to the data that we put into the template. We'll get to where these come from
    in a minute. The other thing is that, in the `modify` method, we're calling `this.save`
    instead of `this.collection.create`. This is one of the big differences between
    creating a record and updating a record; the way we save them. So we'll need to
    create a `save` method for each, saying how exactly to do the saving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if this view class acts as a parent class, or a superclass, what about
    the child views? Well, the `EditEventView` is very simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'First, notice how we''re creating this view: `ModifyEventView.extend`. Backbone''s
    class-creating functionality allows us to extend our own views in the same way
    that we extend `Backbone.View`. Of course, we get access to all the methods and
    properties of `ModifyEventView`, plus whatever we add. This is where we add the
    `heading` and `btnText`, which our `render` method uses. This is also where the
    `save` method comes in. In this view, we''re just using the model''s `save` method
    to send the updated attributes back to the server. We''ll create a server method
    for this in a second. But first, we need to update our `CreateEventView` to use
    `ModifyEventView` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Besides the `heading`, `btnText`, and `save` parts that we're familiar with,
    we're also overwriting the `initialize` method. We do call the parent class' `initialize`
    method in there, but there's something more. If you think about our template for
    a second, you'll see why. Our template expects to receive attributes to fill in
    the form inputs with, but the `CreateEventView` class doesn't have a model to
    give it; its job is to create a model! So what we're going to do is create a disposable
    `Event` object with blank attributes, so that no values are actually filled in,
    but we won't get any errors from the template function.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you probably realize that a blank `Event` object won''t actually have
    any attributes. What we need to do is add default values so that the `Event` objects
    will have empty properties to pass to the template. In the `models.js` file, insert
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is our updated model class. Very simple, but it solves our view problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget, we''re calling `this.model.save` in our `EditEventView` class.
    This will send the updated attributes to the server via a PUT request to `/events/<id>`.
    In `server.js`, here''s how we process those PUT requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We'll round up the attributes into an object and pass it to our database's `update`
    method. To find the right record to update, we'll pass a query object with the
    record's ID. Then, we will return the updated record to the browser as JSON to
    complete the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Making it live
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have a pretty decent application. We can create events that
    show up in our table. We can update and remove these events as well. However,
    if multiple people are using the same table of events, we might want to regularly
    poll the server for changes to the dataset. This way, someone could leave the
    page open, like a dashboard of sorts, and it would always be up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature sounds like it might be tricky to implement, but it''s actually
    much easier than you think. The first step is to go to the `model.js` file, and
    extend our `Events` collection by adding these methods to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `refresh` method is the important one here. Mainly, we're calling the collection's
    `fetch` method. This will get the set of models from the server and set them as
    the model for collection. However, it does it in a smart way. If there are any
    new models, it will fire an `add` event; if there are any updated models, it will
    fire a `change` event; and, if any models were removed, it will fire a `remove`
    event. And it will leave any untouched models alone. Then, we set a timeout, to
    call this method again after a certain number of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: We've also added an `initialize` method to allow the option of how many seconds
    to wait between fetches. If the `options` object has a `wait` property, we'll
    use that. Otherwise, it's 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `initialize` method for the `EventsView` class, we just have to
    call the collection''s `refresh` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Getting the updates is that simple. Now, we need to listen for the events and
    do the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any new records added to the collection from the update will fire an `add`
    event on the collection. Thus, in `EventsView`, we should listen for that. We
    also need to add this to its `initialize` method. So, here''s the whole `initialize`
    method, with both of these updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we used the `on` method to listen to events. However, `listenTo`
    is an alternative form. It does pretty much the same thing, but it allows the
    listener—the view, in this case—to keep a track of the events it is listening
    for. This way, if we ever delete the view object, the `remove` method can detach
    those events and conserve browser memory. Here, we're telling our view to listen
    for an `add` event on the collection; when this occurs, we call `addRow`. As we
    know, this will add an `EventView` class to our table.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of additions via AJAX updates. The `remove` and `change` events
    will be called on the event model. This means that we listen for the changes in
    our `EventView`. In its `initialize` method, we''ll listen for the events. Here''s
    the whole new `EventView` `initialize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We've already created the `render` and `remove` methods, so this is all that
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: And that's all! Now, you can open `http://localhost:3000` in multiple browser
    windows. Go ahead and add an event in one browser window; you should see it show
    up in the other, in less than 10 seconds. You can edit or remove an event, and
    you'll see the change in the other window. Pretty cool, eh? And it only required
    a minimal amount of code.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one more feature we're going to add to our application. We have a table
    of events, so why not add the ability to sort the rows by whichever field we click
    on?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to sort the models in the collection. You already know that
    when we make a collection object, we pass it an array of model objects. We can
    have the collection sort these upon creation, by adding a comparator to the `Events`
    class. In `models.js`, add the following line to the `Events` collection class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding this line will sort the models in the collection by the `date` field.
    This will sort the models initially added to the collection, and any models subsequently
    added. However, it will not re-sort the models after one of them has been changed.
    This is important because we want our table rows to reorder if necessary when
    we edit an event record. We can implement that rather easily. However, when we
    edit a model, it will emit a `change` event, which bubbles up to the collection.
    We can listen for this in the `Events` collection''s `initialize` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as listening for the `change` event on the collection itself;
    when that occurs, we manually call the `sort` method on the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s something more to do in the collection. The default `sort`
    method will only sort in one direction. We want to be able to click on a heading
    a second time and get a reverse sort. So, we''ll have to write a `reverse` method
    ourselves. Insert the following code in the `Events` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: First, we call `sort`; we pass it the `silent` option so that the `sort` event
    will not be fired. Then, we get the internal `models` property; this is the array
    that holds the model instances in our collection. We call the native array method
    `reverse` to reverse the order of the models in the array. We reassign this reversed
    array back to the `models` property. Finally, we trigger the `sort` event; this
    is the event that would usually be triggered by the `sort` method, but we silenced
    that one so that we could reverse the array. We pass the collection object and
    any options passed to `reverse` as parameters of the `sort` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our collection is sorted, when we loop over it in the `EventsView` class
    to add the record to a table, they will be added in the right order. But we want
    to be able to click on the table headings and sort the rows by the clicked heading.
    So the next step is to listen for the click event in our `EventsView` class. Add
    the following code to that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we listen for a click on any of the table headings that have the `data-field`
    attributes that we put into the template. So, let''s write this `sort` method
    in `EventsView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We start by getting the element that was clicked (the `target`); we also make
    a shorter variable for the collection, just because we use it a lot in this method.
    Next, we set the new comparator on the collection. Then, we need to figure out
    which direction we're trying to sort in. We do this by another attribute on our
    table headings `data-direction`. If the attribute is `asc`, we'll do the reverse
    sort. Otherwise, if it's `desc`, we'll do a regular sort.
  prefs: []
  type: TYPE_NORMAL
- en: 'But where does this attribute come from? We didn''t put it in the template.
    Well, notice the `fixSortIcon` method we''re calling. This method does two things.
    First, as we expect, it will set the `data-direction` attribute on the element.
    But we''re also setting an icon; an arrow that will indicate the direction of
    the sort. Here''s that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes two parameters: the target element (the table heading that
    the user clicked on) and the direction (`asc` or `desc`). First, we get the name
    for the Glyphicons arrow icons: up for `desc`, down for `asc`. To show this icon,
    we''re going to need an `<i>` element. But, for anything other than the first
    sort, there''s going to be an `<i>` element from the previous sort. The next step
    is to remove those. Then, we set the attribute on the target element. The last
    step is to create the `<i>` element, add the appropriate class, and append it
    to the target element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, when we click on a header, the collection will sort by that property.
    But, how do we actually reorder the table rows? As you know, when the collection
    is sorted, a `sort` event will be emitted. Let''s capture that in the `EventsView`
    `initialize` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw earlier, the `renderRows` function will add a row for each record
    in the collection. We already have rows in the table, so we have to figure out
    what to do with those. The easiest thing to do would be to simply empty the `<tbody>`
    element and make a bunch of new `EventView` instances. However, this isn''t great
    for memory management. We should properly remove the views with their `remove`
    method, to unhook event listeners, and then we could create new `EventViews` class.
    We''re going to take an alternate approach; however, we''re going to reorder the
    views that we''ve already created. This means that we need to keep references
    to the `EventView` instances. In the `EventsView` `initialize` method, let''s
    create a `children` property to keep track of these views. This can be done with
    the following little code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to change the `addRow` method so that it makes use of this property.
    It should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, this method will first check to see whether there's a property in our `children`
    object with the ID of this event. If not, we'll create a new `EventView` object,
    render it, and store it in the `children` object. Whether it's freshly created
    or not, we'll append it to `<tbody>`. The beauty of this is that even if it's
    already in `<tbody>`, this will move it to the end. After running through the
    collection, the table rows will be properly sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s everything in place! Now, head over to the browser and give the sorting
    feature a once around. The following screenshot shows the things in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sorting events](img/6997OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And now, sorting by the ID column can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sorting events](img/6997OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered a lot in this chapter. Previously, we''d only created and read
    models on the server. Now, we know how to update and delete models on the server
    as well. This is bread-and-butter stuff for Backbone applications. Many of the
    apps you build will use all the four CRUD operations: creating, reading, updating,
    and deleting.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to take away is the way we updated the collection by
    fetching from the server. You won't do it this way in every application—regularly
    polling the server—but the events that we listened for will be the same in every
    case. In fact, there's a common Backbone convention here; listen for the `change`
    event on a model and rerender the view that shows that model. Usually, you'll
    only need to call the `render` method to do that. As the main element of the view
    is already in the DOM, there's no need to reappend it; it will update when `render`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a notable thing in this chapter is the way we created a `view` class and
    then extended it with two child view classes. Don't forget that your models, collections,
    and views have the `extend` method, just like their Backbone parents. You can
    use this to your advantage when you find yourself creating two or more extremely
    similar components.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, remember that discarding views is about more than just deleting its
    DOM elements. It's important to do it properly, by calling the view's `remove`
    method. However, as we saw, it's more than just that. When listening for events
    in the view's `initialize` method, it's better to use `this.listenTo` than `this.model.on`
    or `this.collection.on`. This way, the view can unhook these events when we remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: After creating this `events` dashboard, you might look at it and think that
    it makes a neat calendar. However, we can do much better for a calendar. We'll
    build that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
