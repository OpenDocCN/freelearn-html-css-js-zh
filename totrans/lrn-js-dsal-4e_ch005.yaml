- en: 4 Stacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 栈
- en: '**Before you begin: Join our book community on Discord**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**在开始之前：加入我们的 Discord 书籍社区**'
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“学习 JavaScript 数据结构与算法 4e”频道下找到“EARLY
    ACCESS SUBSCRIPTION”）。
- en: '![](img/file0.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
- en: We learned in the previous chapter how to create and use arrays, which are the
    most common type of data structure in computer science. As we learned, we can
    add and remove elements from an array at any index desired. However, sometimes
    we need some form of data structure where we have more control over adding and
    removing items. There are two data structures that have some similarities to arrays,
    but which give us more control over the addition and removal of elements. These
    data structures are **stacks** and **queues**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建和使用数组，这是计算机科学中最常见的类型之一。正如我们所学的，我们可以在任何所需的索引处向数组中添加或移除元素。然而，有时我们需要某种形式的数据结构，使我们能够更多地控制添加和移除项目。有两种数据结构与数组有一些相似之处，但它们使我们能够更多地控制元素的添加和移除。这些数据结构是**栈**和**队列**。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The stack data structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈数据结构
- en: Adding elements to a stack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向栈中添加元素
- en: Popping elements from a stack
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从栈中弹出元素
- en: How to use the Stack class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Stack 类
- en: Different problems we can resolve using the stack data structure
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用栈数据结构解决的问题
- en: The stack data structure
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈数据结构
- en: 'Imagine you have a stack of trays in a cafeteria or food court, or a pile of
    books, as in the following image:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你在自助餐厅或食品广场有一堆托盘，或者像以下图像中那样有一堆书籍：
- en: '![Figure 4.1: A stack of books about programming languages and frameworks](img/file16.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：关于编程语言和框架的书籍堆](img/file16.png)'
- en: 'Figure 4.1: A stack of books about programming languages and frameworks'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：关于编程语言和框架的书籍堆
- en: Now suppose you need to add a new book to the pile. The standard practice is
    to simply add the new book on the top of the pile of books. And in case you need
    to put the books back into the bookshelf, you would pick the book that is on the
    top of the pile, put it away, and then get the next book that is on the top until
    all the books have been stored away. This behavior of adding or removing books
    from the pile of books follows the same principle of a stack data structure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你需要向这堆书中添加一本新书。标准做法是将新书简单地放在书籍堆的顶部。如果你需要将书籍放回书架，你会拿起堆顶的书籍，放好，然后取走堆顶的下一本书，直到所有书籍都被存放好。从书籍堆中添加或移除书籍的行为遵循栈数据结构的相同原则。
- en: A stack is an ordered collection of items that follows the *last in, first out*
    (**LIFO**) principle. The addition of new items or the removal of existing items
    takes place at the same end. The end of the stack is known as the **top**, and
    the beginning is known as the **base**. The newest elements are near the top,
    and the oldest elements are near the base.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是有序元素集合，遵循**后进先出**（**LIFO**）原则。新元素的添加或现有元素的移除发生在同一端。栈的末端被称为**顶部**，起始端被称为**底部**。最新元素靠近顶部，最旧元素靠近底部。
- en: A stack is used by compilers in programming languages, to store variables and
    method calls in the computer memory, and by the browser history (the browser's
    back button).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 栈在编程语言中的编译器中被使用，用于在计算机内存中存储变量和方法调用，以及浏览器历史记录（浏览器的后退按钮）。
- en: 'Another real-world example of a stack data structure is the *undo feature*
    in text editors such as Microsoft Word or Google Documents as showed in the following
    image:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个栈数据结构的真实世界例子是文本编辑器（如 Microsoft Word 或 Google 文档）中的*撤销功能*，如下面的图像所示：
- en: '![Figure 4.2: Image of the undo style feature in Microsoft Word software](img/file17.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：Microsoft Word 软件中撤销风格功能的图像](img/file17.png)'
- en: 'Figure 4.2: Image of the undo style feature in Microsoft Word software'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：Microsoft Word 软件中撤销风格功能的图像
- en: 'In this example, we have one stack being used internally by Microsoft Word:
    the *undo style* feature, where all the actions performed in the document are
    stacked and we can undo any action by clicking on the undo style button as many
    times as needed, until the stack of actions is empty.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们有一个由Microsoft Word内部使用的栈：*撤销样式*功能，其中所有在文档中执行的操作都被堆叠起来，我们可以通过点击撤销样式按钮多次来撤销任何操作，直到操作栈为空。
- en: Let's put these concepts into practice by creating our own Stack class using
    JavaScript and TypeScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用JavaScript和TypeScript创建自己的栈类来将这些概念付诸实践。
- en: Creating an array-based Stack class
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基于数组的栈类
- en: We are going to create our own class to represent a stack. The source code for
    this chapter is available inside the `src/04-stack` folder on GitHub.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自己的类来表示栈。本章的源代码可在GitHub上的`src/04-stack`文件夹中找到。
- en: We will start by creating the `stack.js` file which will contain our class that
    represents a stack using an array-based approach.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建`stack.js`文件，该文件将包含我们使用基于数组的策略表示栈的类。
- en: 'First, we will declare our `Stack` class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明我们的`Stack`类：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need a data structure that will store the elements of the stack. We can
    use an array to do this as we are already familiar with the array data structure
    (`{1}`). Also, note the prefix of the variable `items`: we are using a hash `#`
    prefix. This means the `#items` property can only be referenced inside the `Stack`
    class. This will allow us to protect this private array as the array data structure
    allows us to add or remove elements from any position in the data structure. Since
    the stack follows the LIFO principle, we will limit the functionalities that will
    be available for the insertion and removal of elements.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个数据结构来存储栈的元素。由于我们已经熟悉数组数据结构（`{1}`），我们可以使用数组来完成此操作。此外，注意变量`items`的前缀：我们使用了一个哈希`#`前缀。这意味着`#items`属性只能在`Stack`类内部引用。这将允许我们保护这个私有数组，因为数组数据结构允许我们在数据结构的任何位置添加或删除元素。由于栈遵循LIFO原则，我们将限制可用于插入和删除元素的功能。
- en: 'The following methods will be available in the `Stack` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack`类中将提供以下方法：'
- en: '`push(item)`: This method adds a new item to the top of the stack.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push(item)`: 此方法将新项目添加到栈的顶部。'
- en: '`pop()`: This method removes the top element from the stack. It also returns
    the removed element.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop()`: 此方法从栈中移除顶部元素。它还返回被移除的元素。'
- en: '`peek()`: This method returns the top element from the stack. The stack is
    not modified (it does not remove the element; it only returns the element for
    information purposes).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 此方法返回栈的顶部元素。栈不会被修改（它不会删除元素；它只返回元素以供信息用途）。'
- en: '`isEmpty()`: This method returns `true` if the stack does not contain any elements,
    and `false` if the size of the stack is bigger than 0.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 此方法返回`true`，如果栈不包含任何元素，如果栈的大小大于0，则返回`false`。'
- en: '`clear()`: This method removes all the elements of the stack.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 此方法移除栈中的所有元素。'
- en: '`size()`: This method returns the number of elements that the stack contains.
    It is similar to the `length` property of an array.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 此方法返回栈包含的元素数量。它与数组的`length`属性类似。'
- en: We will code each method in the following sections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中为每个方法编写代码。
- en: Pushing elements to the top of the stack
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将元素推送到栈顶
- en: 'The first method that we will implement is the `push` method. This method is
    responsible for adding new elements to the stack, with one very important detail:
    we can only add new items to the top of the stack, meaning at the end of the array
    (internally). The `push` method is represented as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一种方法是`push`方法。此方法负责向栈中添加新元素，有一个非常重要的细节：我们只能将新项目添加到栈顶，即数组的末尾（内部）。`push`方法表示如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we are using an array to store the elements of the stack, we can use the
    `push` method from the JavaScript `Array` class that we covered in the previous
    chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用数组来存储栈的元素，我们可以使用上一章中介绍的JavaScript `Array`类的`push`方法。
- en: Popping elements from the stack
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从栈中弹出元素
- en: 'Next, we are going to implement the `pop` method. This method is responsible
    for removing the items from the stack. As the stack uses the LIFO principle, the
    last item we added is removed. For this reason, we can use the `pop` method from
    the JavaScript `Array` class that we also covered in the previous chapter. The
    `Stack.pop` method is represented as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `pop` 方法。此方法负责从堆栈中移除项目。由于堆栈使用 LIFO 原则，我们将移除最后添加的项目。因此，我们可以使用 JavaScript
    `Array` 类中的 `pop` 方法，我们在上一章中也介绍了这个方法。`Stack.pop` 方法表示如下：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In case the stack is empty, this method will return the value `undefined`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果堆栈为空，此方法将返回值 `undefined`。
- en: With the `push` and `pop` methods being the only methods available for adding
    and removing items from the stack, the LIFO principle will apply to our own `Stack` class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `push` 和 `pop` 方法是唯一可用于向堆栈添加和移除项目的功能，LIFO 原则将适用于我们的 `Stack` 类。
- en: Peeking the element from the top of the stack
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看堆栈顶部的元素
- en: 'Next, we will implement additional helper methods in our class. If we would
    like to know what the last element added to our stack was, we can use the `peek` method.
    This method will return the item from the top of the stack:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的类中实现额外的辅助方法。如果我们想知道最后添加到我们的堆栈中的元素是什么，我们可以使用 `peek` 方法。此方法将返回堆栈顶部的项目：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we are using an array to store the items internally, we can obtain the last
    item from an array using `length - 1` as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用数组来内部存储项目，我们可以使用 `length - 1` 来从数组中获取最后一个项目，如下所示：
- en: '![Figure 4.3: A stack of four typing actions simulating the undo feature of
    a text editor.](img/file18.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：模拟文本编辑器撤销功能的四个打字动作的堆栈。](img/file18.png)'
- en: 'Figure 4.3: A stack of four typing actions simulating the undo feature of a
    text editor.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：模拟文本编辑器撤销功能的四个打字动作的堆栈。
- en: Suppose we are simulating the undo feature of a text editor. And we type "top
    of the stack". The feature we are developing will stack each word separately.
    So, we will end up with a stack with four items; therefore, the length of the
    internal array is 4\. The last position used in the internal array is 3\. As a
    result, the `length - 1` (4 - 1) is 3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在模拟文本编辑器的撤销功能。我们输入 "stack 的顶部"。我们正在开发的功能将分别堆叠每个单词。因此，我们将得到一个包含四个项目的堆栈；因此，内部数组的长度是
    4。在内部数组中使用的最后一个位置是 3。因此，`length - 1`（4 - 1）是 3。
- en: 'So, if we peek the top of the stack, we will get the following result: `{ action:
    ''typing'', text: ''stack'' }`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，如果我们查看堆栈的顶部，我们将得到以下结果：`{ action: ''typing'', text: ''stack'' }`。'
- en: Verifying whether the stack is empty and its size
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证堆栈是否为空及其大小
- en: 'The next method we will create is the `isEmpty` method, which returns `true` if
    the stack is empty (no element has been added), and `false` otherwise:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的下一个方法是 `isEmpty` 方法，它返回 `true` 如果堆栈为空（没有添加元素），否则返回 `false`：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the `isEmpty` method, we can simply verify whether the length of the internal
    array is 0.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `isEmpty` 方法，我们可以简单地验证内部数组的长度是否为 0。
- en: 'Like the `length` property from the array class, we can also add a getter for
    the length of our Stack class. For collections, we usually use the term *size* instead
    of length. And again, as we are using an array to store the elements internally,
    we can simply return its length:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从数组类继承的 `length` 属性一样，我们也可以为我们的 `Stack` 类添加一个获取长度的 getter。对于集合，我们通常使用术语 `size`
    而不是 `length`。同样，由于我们使用数组来内部存储元素，我们可以简单地返回其 `length`：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In JavaScript, we can leverage a getter to efficiently track the size of our
    stack data structure. Getters provide a cleaner syntax, allowing us to retrieve
    the size as if it were a property (`myStack.size`) rather than calling a method
    like `myStack.size()`. This enhances code readability and maintainability.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们可以利用 getter 来高效地跟踪我们的堆栈数据结构的大小。Getter 提供了更简洁的语法，允许我们像访问属性一样检索大小（`myStack.size`），而不是调用像
    `myStack.size()` 这样的方法。这增强了代码的可读性和可维护性。
- en: Clearing the elements of the stack
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除堆栈的元素
- en: 'Finally, we are going to implement the `clear` method. The clear method simply
    empties the stack, removing all its elements. The simplest way of implementing
    this method is by directly resetting the internal array to an empty array as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现 `clear` 方法。`clear` 方法简单地清空堆栈，移除所有元素。实现此方法的最简单方式是直接将内部数组重置为空数组，如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An alternative implementation would be calling the `pop` method until the stack
    is empty:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式是调用 `pop` 方法直到堆栈为空：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, the first implementation is considered better in most cases in JavaScript
    as it is more efficient. By directly resetting the internal array to an empty
    array, the operation is typically constant time (*O(1)*), regardless of the stack's
    size. The second approach (`clear2()`) iterates through the stack and pops each
    element individually, and the time complexity is linear (*O(n)*), where `n` is
    the number of elements in the stack – this means this operation gets slower as
    the stack grows. From a memory usage standpoint, for the first approach, while
    it might seem like creating a new empty array uses more memory, JavaScript engines
    often optimize this operation, reusing memory where possible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，JavaScript 中第一种实现被认为是更好的，因为它更高效。通过直接将内部数组重置为空数组，操作通常是常数时间（*O(1)*），无论栈的大小如何。第二种方法（`clear2()`）遍历栈并逐个弹出每个元素，时间复杂度是线性的（*O(n)*），其中
    `n` 是栈中元素的数量——这意味着随着栈的增长，这个操作会变慢。从内存使用角度来看，对于第一种方法，虽然创建一个新的空数组看起来会使用更多内存，但 JavaScript
    引擎通常会优化这个操作，尽可能重用内存。
- en: In rare cases, if the stack is extremely large, and there are concerns about
    memory usage with `clear()`, then `clear2()` could be slightly better due to its
    incremental approach. However, this is an edge case, and the efficiency difference
    would likely be negligible in most real-world scenarios. Also, for the `clear()`
    method, some developers might argue it is technically *O(n)* in the worst case
    due to garbage collection.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果栈非常大，并且对 `clear()` 的内存使用有顾虑，那么由于它的增量方法，`clear2()` 可能会稍微好一些。然而，这是一个边缘情况，在大多数实际场景中，效率差异可能微乎其微。此外，对于
    `clear()` 方法，一些开发者可能会争论，在最坏的情况下，它实际上是 *O(n)*，因为垃圾回收。
- en: Exporting the Stack data structure as a library class
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Stack 数据结构作为库类导出
- en: We have created a file `src/04-stack/stack.js` with our `Stack` class. And we
    would like to use the `Stack` class in a different file for easy maintainability
    of our code (`src/04-stack/01-using-stack-class.js`). How can we achieve this?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `src/04-stack/stack.js` 的文件，其中包含我们的 Stack 类。我们希望在不同的文件中使用 Stack 类以方便我们代码的维护性（`src/04-stack/01-using-stack-class.js`）。我们如何实现这一点？
- en: There are different approaches, depending on the environment you are working
    with.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你工作的环境，有不同的方法。
- en: 'The first approach we will learn is the **CommonJS Module** (`module.exports`).
    This is the traditional way of exporting modules in **Node.js**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要学习的第一种方法是 **CommonJS 模块**（`module.exports`）。这是在 **Node.js** 中导出模块的传统方式：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last line will expose our class so we can use it in a different file as
    follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将暴露我们的类，这样我们就可以在不同的文件中使用它，如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This CommonJS Module approach is the one we will use throughout this book as
    we are using the following command to see the output of our code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 CommonJS 模块方法，因为我们使用以下命令来查看我们代码的输出：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, if you would like to the code in the front-end, we can use **ECMAScript
    Modules** (`export default`) as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想在前端使用代码，我们可以使用 **ECMAScript 模块**（`export default`）如下所示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And to use it in a different file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 并且要在不同的文件中使用它：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A third approach that we can also use in the front-end is the **Named Exports**,
    which allows us to export multiple items from a module:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在前端使用的一种第三种方法是 **命名导出**，它允许我们从模块中导出多个项目：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And to use it in a different file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 并且要在不同的文件中使用它：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although we will use the Node.js approach, it is useful to know the other approaches
    so we can adapt our code to different environments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将使用 Node.js 方法，但了解其他方法是有用的，这样我们就可以根据不同的环境调整我们的代码。
- en: Using the Stack class
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Stack 类
- en: 'The time to test the Stack class has come! As discussed in the previous subsection,
    let''s go ahead and create a separate file so we can write as many tests as we
    like: `src/04-stack/01-using-stack-class.js`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Stack 类的时间到了！如前一小节所述，让我们继续创建一个单独的文件，这样我们就可以编写尽可能多的测试：`src/04-stack/01-using-stack-class.js`。
- en: 'The first thing we need to do is to import the code from the stack.js file
    and instantiate the Stack class we just created:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从 stack.js 文件中导入代码并实例化我们刚刚创建的 Stack 类：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we can verify whether it is empty (the output `is true`, because we have
    not added any elements to our stack yet):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以验证它是否为空（输出 `is true`，因为我们还没有向我们的栈中添加任何元素）：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, let's simulate the undo feature of a text editor. Suppose our text editor
    will store the action (such as typing), along with the text that is being typed.
    Each key stroke will be stored as one action.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们模拟文本编辑器的撤销功能。假设我们的文本编辑器将存储动作（如输入），以及正在输入的文本。每个按键都会被存储为一个动作。
- en: 'For example, let''s type *Stack*. After each key stroke, we will push the `action`
    and the `text` as an object to the stack. We will start with "St":'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们输入 *Stack*。在每次按键后，我们将 `action` 和 `text` 作为对象推入栈中。我们将从 "St" 开始。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we call the `peek` method, it is going to return the object with text `t`,
    because it was the last element that was added to the stack:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `peek` 方法，它将返回文本为 `t` 的对象，因为它是最后添加到栈中的元素：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s also check the stack size:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也检查栈的大小：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s type a few more characters: "*ack*". This will push another three
    characters to the stack:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再输入几个字符：“*ack*”。这将把另外三个字符推入栈中：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And if we check the size and if the stack is empty:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查大小并检查栈是否为空：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following diagram shows all the push operations we have executed so far,
    and the status of our stack:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了迄今为止执行的所有 push 操作以及我们的栈的状态：
- en: '![Figure 4.4: The push operations in the stack by typing Stack](img/file19.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4：通过输入 Stack 在栈中进行的 push 操作](img/file19.png)'
- en: 'Figure 4.4: The push operations in the stack by typing Stack'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：通过输入 Stack 在栈中进行的 push 操作
- en: 'Next, let''s undo the last two actions by removing two elements from the stack:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过从栈中移除两个元素来撤销最后两个动作：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before we evoked the `pop` method twice, our stack had five elements in it.
    After the execution of the pop method twice, the stack now has only three elements.
    We can check by outputting the size and peeking the top of the stack:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们两次调用 `pop` 方法之前，我们的栈中有五个元素。经过两次 `pop` 方法的执行后，栈现在只剩三个元素。我们可以通过输出大小和查看栈顶来检查：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following diagram exemplifies the execution of the pop method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 `pop` 方法的执行过程：
- en: '![Figure 4.5: The pop operations in the stack by popping two elements](img/file20.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5：通过弹出两个元素在栈中进行的 pop 操作](img/file20.png)'
- en: 'Figure 4.5: The pop operations in the stack by popping two elements'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：通过弹出两个元素在栈中进行的 pop 操作
- en: Enhancing the Stack by creating the toString method
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过创建 toString 方法增强栈
- en: 'If we try to execute the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行以下代码：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will get the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is not friendly at all, and we can enhance the output by creating a `toString`
    method in our `Stack` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点也不友好，我们可以通过在 `Stack` 类中创建一个 `toString` 方法来增强输出：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the stack is empty, we can return a message or simply `[]` (whichever is
    your preference). Since we are using an array-based Stack, we can leverage the
    `map` method to iterate and transform each element (`{1}`) of our Stack. For each
    item or element, we can check if the item is an object (`{2}`) and output the
    JSON version of the object for a user friendly output. Otherwise, we can use the
    item's own `toString` method (`{3}`). And to separate each element of the stack,
    we can use a comma and space (`{4}`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈为空，我们可以返回一条消息或简单地返回 `[]`（根据您的喜好）。由于我们使用基于数组的栈，我们可以利用 `map` 方法迭代并转换我们的栈中的每个元素（`{1}`）。对于每个项目或元素，我们可以检查项目是否是对象（`{2}`），并为用户友好的输出输出对象的
    JSON 版本。否则，我们可以使用项目的自身 `toString` 方法（`{3}`）。并且为了分隔栈中的每个元素，我们可以使用逗号和空格（`{4}`）。
- en: Reviewing the efficiency of our Stack class
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审查我们的栈类的效率
- en: 'As the Stack class is the first data structure we are creating from scratch,
    let''s review the efficiency of each method by review the Big O notation in terms
    of time of execution:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于栈类是我们从头开始创建的第一个数据结构，让我们通过回顾 Big O 符号来审查每个方法的效率，以时间执行为标准：
- en: '| **Method** | **Complexity** | **Explanation** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **复杂度** | **说明** |'
- en: '| `push(item)` | *O(1)* | Adding an item to the end of an array is usually
    constant time. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `push(item)` | *O(1)* | 将项目添加到数组的末尾通常是常数时间。 |'
- en: '| `pop()` | *O(1)* | Removing the last item from an array is usually constant
    time. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | *O(1)* | 从数组中移除最后一个项目通常是常数时间。 |'
- en: '| `isEmpty()` | *O(1)* | Checking the length of an array is a constant-time
    operation. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `isEmpty()` | *O(1)* | 检查数组的长度是一个常数时间的操作。 |'
- en: '| `get size()` | *O(1)* | Accessing the `length` property of an array is constant
    time. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `get size()` | *O(1)* | 访问数组的 `length` 属性是常数时间。 |'
- en: '| `clear()` | *O(1)* | Assigning a new empty array is typically considered
    constant time, although some developers might consider O(n) due to garbage collector
    in the worst-case scenario. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | *O(1)* | 分配一个新的空数组通常被认为是常数时间，尽管一些开发者可能会因为垃圾回收器在最坏情况下的表现而将其视为
    O(n)。|'
- en: '| `toString` | *O(n)* | Iterating through each element of the stack takes linear
    time. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `toString` | *O(n)* | 遍历栈中的每个元素需要线性时间。|'
- en: 'Table 4.1:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1：
- en: In the array-based implementation, operations like `push()` might occasionally
    take longer due to the array needing to be resized. However, on average, the time
    complexity still tends to be *O(1)* over many operations. JavaScript arrays are
    not fixed size like arrays in some other languages. They are dynamic, meaning
    they can grow or shrink as needed. Internally, they are typically implemented
    as dynamic arrays or hash tables.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于数组的实现中，由于数组需要调整大小，`push()` 等操作有时可能会更长。然而，平均而言，时间复杂度在多次操作中仍然倾向于 *O(1)*。JavaScript
    数组不像某些其他语言中的数组那样是固定大小的。它们是动态的，这意味着它们可以根据需要增长或缩小。内部，它们通常实现为动态数组或哈希表。
- en: JavaScript follows the ECMAScript standard, and each browser or engine might
    have its own implementation, meaning the array `push` method might have a different
    internal source code in Node.js, Chrome, Firefox, or Edge. Regardless of the implementation,
    the contract or the functionality will be the same, meaning the `push` method
    will add a new element to the end of the array, even if different engines have
    a different approach on how to do it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 遵循 ECMAScript 标准，每个浏览器或引擎可能有它自己的实现，这意味着 Node.js、Chrome、Firefox 或
    Edge 中的数组 `push` 方法可能有不同的内部源代码。无论实现如何，契约或功能都将相同，这意味着 `push` 方法将向数组的末尾添加一个新元素，即使不同的引擎在如何实现它方面有不同的方法。
- en: 'For the dynamic array approach, when you push an element onto an array, and
    it has no more space, it might need to allocate a larger block of memory, copy
    the existing elements over, and then add the new element. This resizing can be
    an expensive operation, taking *O(n)* time (where *n* is the number of elements).
    In some JavaScript engines, arrays might use hash tables internally for faster
    access: `push` and `pop` would still typically be `O(1)`, but the details can
    vary depending on the implementation. We will learn more about hash tables in
    *Chapter 8, Dictionaries and Hashes*.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态数组方法，当你将一个元素推入数组时，如果数组没有更多空间，可能需要分配一个更大的内存块，将现有元素复制过去，然后添加新元素。这种调整大小可能是一个昂贵的操作，需要
    *O(n)* 的时间（其中 *n* 是元素的数量）。在一些 JavaScript 引擎中，数组可能内部使用哈希表以实现更快的访问：`push` 和 `pop`
    操作通常仍然是 `O(1)`，但具体细节可能因实现而异。我们将在 *第 8 章，字典和哈希表* 中了解更多关于哈希表的内容。
- en: Creating a JavaScript object-based Stack class
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基于 JavaScript 对象的 `Stack` 类
- en: The easiest way of creating a Stack class is using an array to store its elements.
    When working with a large set of data (which is quite common in real-world projects),
    we also need to analyze what is the most efficient way of manipulating the data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Stack` 类的最简单方法就是使用数组来存储其元素。当处理大量数据（这在现实世界的项目中相当常见）时，我们还需要分析最有效率的操作数据的方式。
- en: When reviewing the efficiency of our array-based `Stack` class, we learned that
    some JavaScript engines might use hash tables to implement an array. We have not
    learned hash tables yet, but we can implement a Stack class using a JavaScript
    object to store the stack elements, and by doing so, we can access any element
    directly, with time complexity *O(1)*. And of course, comply with the LIFO principle.
    Let's see how we can achieve this behavior.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾基于数组的 `Stack` 类的效率时，我们了解到一些 JavaScript 引擎可能使用哈希表来实现数组。我们还没有学习哈希表，但我们可以使用
    JavaScript 对象来存储栈元素，并通过这样做，我们可以直接访问任何元素，时间复杂度为 *O(1)*。当然，也要遵守 LIFO 原则。让我们看看我们如何实现这种行为。
- en: 'We will start by declaring the Stack class (`src/04-stack/stack-object.js` file)
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先声明 `Stack` 类（`src/04-stack/stack-object.js` 文件）如下：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For this version of the `Stack` class, we will use a JavaScript empty object
    instead of an empty array (`{1}`) to store the data and a `count` property to
    help us keep track of the size of the stack (and, consequently, also help us in
    adding and removing elements).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '对于这个版本的 `Stack` 类，我们将使用一个 JavaScript 空对象而不是空数组 (`{1}`) 来存储数据，并使用一个 `count`
    属性来帮助我们跟踪栈的大小（并且，相应地，也有助于我们在添加和删除元素时）。 '
- en: Pushing elements to the stack
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向栈中推入元素
- en: 'We will declare our first method, used to add elements to the top of the stack:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明第一个方法，用于向栈顶添加元素：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In JavaScript, an object is a set of **key** and **value** pairs. To add an `item` to
    the stack, we will use the `count` variable as the key to the `items` object and
    the `item` will be its value. After pushing the element to the stack, we increment
    the `count`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，一个对象是一组 **键** 和 **值** 对。要将一个 **`item`** 添加到栈中，我们将使用 **`count`**
    变量作为 **`items`** 对象的键，而 **`item`** 将是其值。在将元素推入栈后，我们将增加 `count`。
- en: 'In JavaScript, we have two main ways to assign a value to a particular key
    within an object:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们有两种主要方式来为对象中的特定键赋值：
- en: '*Dot notation*: `this.#items.1 = item`. This is the most common and concise
    way to assign values when we know the key name in advance.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*点表示法*：`this.#items.1 = item`。当我们事先知道键名时，这是最常见且简洁的赋值方式。'
- en: '*Bracket Notation*: `this.#items[this.#count] = item`. Bracket notation offers
    more flexibility as can use variables or expressions to determine the key name.
    This notation is essential when dealing with dynamic keys, as it is our case in
    this scenario.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*括号表示法*：`this.#items[this.#count] = item`。括号表示法提供了更多的灵活性，因为可以使用变量或表达式来确定键名。在处理动态键时，这种表示法是必不可少的，正如我们在这个场景中所做的那样。'
- en: 'We can use the same example as before to use the `Stack` class and type "St":'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前的相同示例来使用 **`Stack`** 类并输入 "St"：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Internally, we will have the following values inside the `items` and `count` private
    properties:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我们将在 **`items`** 和 **`count`** 私有属性中拥有以下值：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Verifying whether the stack is empty and its size
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证栈是否为空及其大小
- en: 'The `#count` property also works as the size of the stack. So, for the `size`
    getter, we can simply return the `#count` property:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**`#count`** 属性也作为栈的大小。因此，对于 **`size`** 获取器，我们可以简单地返回 **`#count`** 属性：'
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And to verify whether the stack is empty, we can compare if the `#count` value
    is 0 as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证栈是否为空，我们可以比较 **`#count`** 值是否为 **`0`**，如下所示：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Popping elements from the stack
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从栈中弹出元素
- en: 'As we are not using an array to store the elements, we will need to implement
    the logic to remove an element manually. The `pop` method also returns the element
    that was removed from the stack. The `pop` method for the object-based implementation
    is presented as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有使用数组来存储元素，我们需要实现手动删除元素的逻辑。**`pop`** 方法也返回从栈中删除的元素。基于对象的 **`pop`** 方法如下所示：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we need to verify whether the stack is empty (`{1}`) and, if so, we return
    the value `undefined` (the array `pop` method returns undefined in case the array
    is empty, so we are following the same behavior). If the stack is not empty, we
    will decrement the `#count` property (`{2}`) and we will store the value from
    the top of the stack (`{3}`) temporarily so we can return it (`{5}`) after the
    element has been removed (`{4}`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要验证栈是否为空（`{1}`），如果是，则返回值 **`undefined`**（数组 `pop` 方法在数组为空时返回 undefined，因此我们遵循相同的行为）。如果栈不为空，我们将减少
    **`#count`** 属性（`{2}`），并将栈顶的值临时存储起来，以便在元素被删除后（`{4}`）返回它（`{5}`）。
- en: As we are working with a JavaScript object, to remove a specific value from
    the object, we can use the JavaScript `delete` operator as in line `{4}`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 JavaScript 对象，要从一个特定的值中删除，我们可以使用 JavaScript 的 **`delete`** 操作符，如第 `{4}`
    行所示。
- en: 'Let''s use the following internal values to emulate the `pop` action:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下内部值来模拟 **`pop`** 操作：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To access the element from the top of the stack (latest `text` added: `t`),
    we need to access the key with value `1`. To do so, we decrement the `#count`
    variable from `2` to `1`. We can access `#items[1]`, delete it, and return its
    value.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问栈顶的元素（最新添加的 **`text`**：`t`），我们需要访问值为 `1` 的键。为此，我们需要将 **`#count`** 变量从 `2`
    减少到 `1`。我们可以访问 `#items[1]`，删除它，并返回其值。
- en: Peeking the top of the stack and clearing it
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看栈顶并清除它
- en: 'To peek the element that is on the top of the stack we will use the following
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看栈顶的元素，我们将使用以下代码：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The behavior is like the peek method of the array-based implementation. In case
    the stack is empty, it will return `undefined`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 其行为类似于基于数组的实现中的 peek 方法。如果栈为空，它将返回 `undefined`。
- en: 'And to clear the stack, we can simply reset it to the same values we initialized
    the class with:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除栈，我们可以简单地将其重置为初始化类时的相同值：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating the toString method
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 toString 方法
- en: 'To create the `toString` method for the object-based Stack class, we will use
    the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要为基于对象的 **`Stack`** 类创建 **`toString`** 方法，我们将使用以下代码：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the stack is empty, we can return a message or `{}` (whichever is your preference).
    Next, we will transform the first element into a string (`{1}`) – this is in case
    the stack only has one element or so we do not need to append a comma at the end
    of the string. Next, we will iterate through all the elements (`{2}`) by using
    the `#count` property (that also works as a key within our `#items` object). For
    each additional element, we will append a comma, followed by the string version
    of the element (`{3}`). Since we need to stringify the first element and all the
    subsequent elements of the stack, instead of duplicating the code, we can create
    another method (`{4}`) that will transform an element into a string (this is the
    same logic we used in the array-based version). By prefixing the method with hash
    (`#`), JavaScript will not expose this method and it will not be available to
    be used outside this class (it is a private method).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈为空，我们可以返回一个消息或 `{}`（根据您的偏好）。接下来，我们将第一个元素转换为字符串 (`{1}`) – 这是在栈只有一个元素或我们不需要在字符串末尾添加逗号的情况下。接下来，我们将通过使用
    `#count` 属性（它也在我们的 `#items` 对象中作为键）迭代所有元素 (`{2}`)。对于每个额外的元素，我们将添加一个逗号，然后是元素的字符串版本
    (`{3}`)。由于我们需要将栈的第一个元素和所有后续元素转换为字符串，而不是重复代码，我们可以创建另一个方法 (`{4}`) 来将元素转换为字符串（这是我们在基于数组的版本中使用的相同逻辑）。通过在方法前加上哈希
    (`#`) 前缀，JavaScript 不会公开此方法，并且它将不可用于在类外部使用（这是一个私有方法）。
- en: Comparing object-based approach with array-based stack
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较基于对象的实现与基于数组的栈
- en: The time complexity of all methods for the object-based `Stack` class is constant
    time (*O(1)*) as we can access any element directly. The only method that is linear
    time (*O(n)*) is the `toString` method as we need to iterate through all the elements
    of the stack, where *n* is the stack size.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于对象的 `Stack` 类的所有方法，时间复杂度都是常数时间 (*O(1)*)，因为我们可以直接访问任何元素。唯一一个线性时间 (*O(n)*)
    的方法是 `toString` 方法，因为我们需要遍历栈中的所有元素，其中 *n* 是栈的大小。
- en: If we compare our array-based versus our object-based implementation, which
    one do you think is the best one?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将基于数组的实现与基于对象的实现进行比较，你认为哪一个更好？
- en: 'Let''s review both approaches:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这两种方法：
- en: '*Performance*: Both implementations have similar Big O complexities for most
    operations. However, array-based stacks might have a slight edge in overall performance
    due to potential resizing issues with object-based stacks.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能*：这两种实现对于大多数操作都具有相似的 Big O 复杂度。然而，由于基于对象的栈可能存在潜在的调整大小问题，基于数组的栈在整体性能上可能略有优势。'
- en: '*Element access*: Array-based stacks offer efficient random access by index,
    which can be useful in some scenarios. In some real-world examples, such as the
    undo feature, if the user wants to undo multiple steps at once, you can quickly
    access the relevant change based on its position in the stack using an index (in
    this case, the stack is not so strict to the LIFO behavior). If the stack operations
    primarily consist of pushing, popping, and peeking at the top element, then random
    access might not be a significant factor.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*元素访问*：基于数组的栈通过索引提供高效的随机访问，这在某些场景中可能很有用。在一些现实世界的例子中，例如撤销功能，如果用户想要一次性撤销多个步骤，可以根据其在栈中的位置快速访问相关更改（在这种情况下，栈对
    LIFO 行为不是那么严格）。如果栈操作主要是由推送、弹出和查看顶部元素组成，那么随机访问可能不是一个重要的因素。'
- en: '*Order*: If maintaining strict order of elements is important, array-based
    stacks are the preferred choice.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*顺序*：如果保持元素严格顺序很重要，基于数组的栈是首选选择。'
- en: '*Memory*: Array-based stacks are generally more memory-efficient.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存*：基于数组的栈通常更节省内存。'
- en: For most use cases involving stacks, the array-based implementation is generally
    recommended due to its order preservation, efficient access, and better memory
    usage. The object-based implementation might be considered in situations where
    order is not crucial, and you need a simple, straightforward implementation for
    basic stack operations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及栈的大多数用例，基于数组的实现通常推荐，因为它保留了顺序、高效的访问和更好的内存使用。在顺序不是关键，并且需要简单直接的基本栈操作实现的情况下，可以考虑基于对象的实现。
- en: Creating the Stack class using TypeScript
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TypeScript 创建 Stack 类
- en: 'As discussed previously in this book, using TypeScript to create a data structure
    API like our Stack class offers several significant advantages over plain JavaScript,
    such as:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书之前所述，使用 TypeScript 创建类似于我们的 Stack 类的数据结构 API 相比于纯 JavaScript 有几个显著的优势，例如：
- en: 'Enhanced type safety: early error detection with static typing catches type-related
    errors during development, preventing them from causing runtime failures. This
    is crucial when building APIs (such as our Stack class) that others will consume,
    as it helps ensure correct usage.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强类型安全性：通过静态类型在开发期间捕获类型相关错误，防止它们导致运行时失败。这在构建其他人将使用的 API（如我们的 Stack 类）时至关重要，因为它有助于确保正确的使用。
- en: 'Explicit contracts: TypeScript''s interfaces and type aliases let us define
    the exact structure and types of the data our stack will hold, making it easier
    for others to understand how to interact with it.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式合约：TypeScript 的接口和类型别名让我们能够定义我们的栈将持有的数据的精确结构和类型，这使得其他人更容易理解如何与之交互。
- en: 'Generics: We can make the Stack class more versatile by using generics to specify
    the type of data it will store. This allows for type-safe operations on various
    kinds of data (numbers, strings, objects, etc.).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型：我们可以通过使用泛型来指定 Stack 类将存储的数据类型，使 Stack 类更加通用。这允许对各种类型的数据（数字、字符串、对象等）进行类型安全的操作。
- en: 'Self-documenting code: TypeScript''s type annotations serve as built-in documentation,
    explaining the purpose of functions, parameters, and return values. This reduces
    the need for separate documentation and makes our code easier to understand.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自文档化代码：TypeScript 的类型注解作为内置文档，解释了函数、参数和返回值的目的。这减少了单独文档的需求，并使我们的代码更容易理解。
- en: 'Let''s check how we can rewrite our Stack class using array-based implementation
    using TypeScript:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 TypeScript 的基于数组的实现来重写我们的 Stack 类：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will use the generics (`{1}`) to make our class flexible. It can hold elements
    of any type (`T`), whether it''s numbers, strings, objects, or custom types. This
    is a major advantage over a JavaScript implementation as JavaScript allows mixed
    types of data in the data structure and by typing our Stack class, we are enforcing
    all elements will be of the same type (`{2}`). TypeScript also has a `private`
    keyword to declare private properties and methods. This feature became available
    years before JavaScript added the hash # prefix to allow private properties and
    methods.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用泛型（`{1}`）来使我们的类更灵活。它可以持有任何类型的元素（`T`），无论是数字、字符串、对象还是自定义类型。这比 JavaScript
    实现有更大的优势，因为 JavaScript 允许数据结构中混合类型的数据，通过为我们的 Stack 类添加类型，我们强制所有元素都将具有相同的类型（`{2}`）。TypeScript
    还有一个 `private` 关键字来声明私有属性和方法。这个特性在 JavaScript 添加哈希 # 前缀以允许私有属性和方法之前几年就已经可用。'
- en: The code inside the methods is the same as the JavaScript implementation. The
    advantage here is we can type any method arguments and their return type, facilitating
    reading the code with more ease.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 方法内的代码与 JavaScript 实现相同。这里的优势是我们可以为任何方法参数及其返回类型进行类型化，从而更容易地阅读代码。
- en: The export (`{3}`) syntax follows the ECMAScript approach we reviewed earlier
    in this chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 导出（`{3}`）语法遵循我们在本章前面回顾的 ECMAScript 方法。
- en: 'If we want to use this data structure in a separate file so we can test it,
    we can create another file (equivalent to the JavaScript file we created):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在单独的文件中使用这个数据结构以便进行测试，我们可以创建另一个文件（相当于我们创建的 JavaScript 文件）：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can create an enumerator to define all the types allowed in the text editor
    (`{4}`). This step is optional, but a good practice to avoid typo mistakes. Next,
    we can create an interface to define the type of the data our stack will store
    (`{5}`). Finally, when we instantiate the `Stack` data structure, we can type
    it to ensure all elements will be of the same type (`{6}`). The remaining sample
    code will be the same as in JavaScript.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个枚举器来定义文本编辑器中允许的所有类型（`{4}`）。这一步是可选的，但是一个良好的实践，可以避免打字错误。接下来，我们可以创建一个接口来定义我们的栈将存储的数据类型（`{5}`）。最后，当我们实例化
    `Stack` 数据结构时，我们可以对其进行类型化以确保所有元素都将具有相同的类型（`{6}`）。剩余的示例代码将与 JavaScript 中的相同。
- en: 'To see the output of the example file, we can use the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看示例文件的输出，我们可以使用以下命令：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `ts-node` package allows us to execute the TypeScript code without manually
    compiling it first. The output will be the same as the one in JavaScript.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts-node` 包允许我们在不先手动编译的情况下执行 TypeScript 代码。输出将与 JavaScript 中的相同。'
- en: Solving problems using stacks
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用栈解决问题
- en: Now that we know how to use the `Stack` class, let's use it to solve some computer
    science problems. In this section, we will cover the decimal to binary problem,
    and we will also transform the algorithm into a base converter algorithm.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用 `Stack` 类，让我们用它来解决一些计算机科学问题。在本节中，我们将介绍十进制转二进制问题，并将该算法转换为基数转换算法。
- en: Converting decimal numbers to binary
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将十进制数转换为二进制
- en: We are already familiar with the decimal base. However, binary representation
    is particularly important in computer science, as everything in a computer is
    represented by binary digits (0 and 1).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉十进制基数。然而，在计算机科学中，二进制表示尤为重要，因为计算机中的所有东西都是由二进制位（0 和 1）表示的。
- en: This is extremely helpful when working with data storage for example. Computers
    store all information as binary digits. When we save a file, the decimal representation
    of each character or pixel is converted to binary before being stored on the hard
    drive or other storage media. Some file formats, like image files (.bmp, .png)
    and audio files (.wav), store data partially or entirely in binary format. Understanding
    binary conversion is crucial for working with these files at a low level. Another
    application are barcodes, which are essentially binary patterns of black and white
    lines that represent decimal numbers. Scanners decode these patterns back into
    decimals to identify products and other information.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据存储时，例如，这非常有帮助。计算机将所有信息存储为二进制位。当我们保存文件时，每个字符或像素的十进制表示在存储到硬盘或其他存储介质之前会被转换为二进制。一些文件格式，如图像文件（.bmp,
    .png）和音频文件（.wav），部分或全部以二进制格式存储数据。理解二进制转换对于在低级别处理这些文件至关重要。另一个应用是条形码，它本质上是由黑白线条组成的二进制模式，代表十进制数。扫描仪将这些模式解码回十进制以识别产品和其他信息。
- en: 'To convert a decimal number into a binary representation, we can divide the
    number by 2 (binary is a base 2 number system) until the division result is 0\.
    As an example, we will convert the number 10 into binary digits:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要将十进制数转换为二进制表示，我们可以将数字除以 2（二进制是一个基数为 2 的数制）直到除法结果为 0。作为一个例子，我们将数字 10 转换为二进制位：
- en: '![Figure 4.6: A mathematical representation of converting the number 10 into
    binary digits](img/file21.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6：将数字 10 转换为二进制位数的数学表示](img/file21.png)'
- en: 'Figure 4.6: A mathematical representation of converting the number 10 into
    binary digits'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：将数字 10 转换为二进制位数的数学表示
- en: 'This conversion is one of the first things you learn in computer science classes.
    The decimal to binary algorithm is presented as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在计算机科学课程中最早学习的内容之一。十进制到二进制的算法如下所示：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the provided code, as long as the quotient of the division is non-zero (line
    `{1}`), we calculate the remainder using the modulo operator (line `{2}`) and
    push it onto the stack (line {3}). We then update the dividend for the next iteration
    by dividing it by 2 and discarding any fractional part using `Math.floor` (line
    `{4}`). This is necessary because JavaScript does not distinguish between integers
    and floating-point numbers. Finally, we pop elements from the stack until it's
    empty (line `{5}`), concatenating them into a string to form the binary representation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的代码中，只要除法的商非零（行 `{1}`），我们就使用取模运算符（行 `{2}`）计算余数并将其推入栈中（行 {3}）。然后我们通过除以 2 并使用
    `Math.floor`（行 `{4}`）丢弃任何小数部分来更新下一次迭代的被除数。这是必要的，因为 JavaScript 无法区分整数和浮点数。最后，我们弹出栈中的元素直到栈为空（行
    `{5}`），将它们连接成字符串以形成二进制表示。
- en: 'If we call `decimalToBinary(13)`, here''s how the process would unfold:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `decimalToBinary(13)`，这个过程将会是这样的：
- en: 13 % 2 = 1 (remainder pushed onto stack); 13 / 2 = 6 (integer division)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 13 % 2 = 1（余数推入栈中）；13 / 2 = 6（整数除法）
- en: 6 % 2 = 0 (remainder pushed onto stack); 6 / 2 = 3
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6 % 2 = 0（余数推入栈中）；6 / 2 = 3
- en: 3 % 2 = 1 (remainder pushed onto stack); 3 / 2 = 1
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3 % 2 = 1（余数推入栈中）；3 / 2 = 1
- en: 1 % 2 = 1 (remainder pushed onto stack); 1 / 2 = 0 (loop terminates)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1 % 2 = 1（余数推入栈中）；1 / 2 = 0（循环终止）
- en: 'Stack: [1, 1, 0, 1] (top to bottom)'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栈：[1, 1, 0, 1]（从上到下）
- en: 'Popping from the stack and building the result string: "1101"'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从栈中弹出并构建结果字符串："1101"
- en: The base converter algorithm
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基数转换算法
- en: 'We can modify the previous algorithm to make it work as a converter from decimal
    to the bases between `2` and `36`. Instead of dividing the decimal number by 2,
    we can pass the desired base as an argument to the method and use it in the division
    operations, as shown in the following algorithm:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改之前的算法，使其作为从 `2` 到 `36` 之间的十进制到基数的转换器工作。我们不需要将十进制数除以 2，而是可以将所需的基数作为方法的参数传递，并在除法操作中使用它，如下面的算法所示：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There is one more thing we need to change. In the conversion from decimal to
    binary, the remainders will be 0 or 1; in the conversion from decimal to octagonal,
    the remainders will be from 0 to 8; and in the conversion from decimal to hexadecimal,
    the remainders can be 0 to 9 plus the letters A to F (values 10 to 15). For this
    reason, we need to convert these values as well (lines `{6}` and `{7}`). So, starting
    at base 11, each letter of the alphabet will represent its base. The letter `A` represents
    base 11, `B` represents base 12, and so on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改一件事。在十进制到二进制的转换中，余数将是 0 或 1；在十进制到八进制的转换中，余数将是 0 到 8；在十进制到十六进制的转换中，余数可以是
    0 到 9 加上字母 A 到 F（值 10 到 15）。因此，我们需要将这些值也转换（`{6}` 和 `{7}` 行）。所以，从 base 11 开始，每个字母将代表其基数。字母
    `A` 代表 base 11，`B` 代表 base 12，以此类推。
- en: 'We can use the previous algorithm and output its result as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前的算法并输出其结果如下：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And when could we use this algorithm in the real-world? This algorithm has
    many applications such as:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们何时可以在现实世界中使用这个算法？这个算法有多个应用，例如：
- en: 'Hexadecimal (base 16): Web developers and graphic designers frequently use
    hexadecimal notation to represent colors in HTML, CSS, and other digital design
    tools. For example, the color white is represented as `#FFFFFF`, which is equivalent
    to the decimal value `16777215`. The `decimalToBase` algorithm could be used to
    convert color values between decimal and hexadecimal representations.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制（基数 16）：网络开发人员和图形设计师经常使用十六进制表示法在 HTML、CSS 和其他数字设计工具中表示颜色。例如，白色表示为 `#FFFFFF`，相当于十进制值
    `16777215`。`decimalToBase` 算法可用于在十进制和十六进制表示之间转换颜色值。
- en: 'Base64 encoding: Base64 is a common encoding scheme used to represent binary
    data (images, audio, and so on) as text. It uses a 64-character alphabet (A-Z,
    a-z, 0-9, +, /) and converts binary data into base-64 representation for easier
    transmission over text-based protocols like email. We could enhance our algorithm
    to convert to a base-64 (use this as a challenge to try on your own, you will
    find the resolution in the source code of this book).'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Base64 编码：Base64 是一种常见的编码方案，用于将二进制数据（图像、音频等）表示为文本。它使用一个 64 个字符的字母表（A-Z，a-z，0-9，+，/）并将二进制数据转换为
    base-64 表示，以便更容易地在基于文本的协议（如电子邮件）中传输。我们可以增强我们的算法以转换为 base-64（将其作为挑战尝试，你将在本书的源代码中找到解决方案）。
- en: 'Shortened URLs or unique identifiers: Services like [bit.ly](https://bit.ly)
    generate shortened URLs that use a mix of alphanumeric characters. These shortened
    URLs often represent unique numeric identifiers that have been converted to a
    higher base (for example: base 62) to make them more compact.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短网址或唯一标识符：像 [bit.ly](https://bit.ly) 这样的服务生成使用字母数字字符混合的短网址。这些短网址通常代表已转换为更高基数（例如：base
    62）的唯一数字标识符，以使其更加紧凑。
- en: You will also find the *Hanoi Tower* example when you download the source code
    of this book.
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你下载本书的源代码时，你也会找到 *汉诺塔* 的示例。
- en: Exercises
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: We will resolve a few array exercises from **LeetCode** using the concepts we
    learned in this chapter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章学到的概念解决来自 **LeetCode** 的几个数组练习。
- en: Valid Parentheses
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Valid Parentheses
- en: The first exercise we will resolve is the *20\. Valid Parentheses* problem available
    at [https://leetcode.com/problems/valid-parentheses/](https://leetcode.com/problems/valid-parentheses/).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决的第一个练习是 [https://leetcode.com/problems/valid-parentheses/](https://leetcode.com/problems/valid-parentheses/)
    上的 *20\. Valid Parentheses* 问题。
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `function isValid(s: string): boolean {}`, which
    receives a string it is expecting a boolean to be returned.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用 JavaScript 或 TypeScript 解决问题时，我们将在函数 `function isValid(s: string): boolean
    {}` 内部添加我们的逻辑，该函数接收一个字符串并期望返回一个布尔值。'
- en: 'The following are the sample input and expected output provided by the problem:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由问题提供的样本输入和预期输出：
- en: Input "()", output true.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 "()"，输出 true。
- en: Input "()", output true.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 "()"，输出 true。
- en: Input "(]", output false.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 "(]", 输出 false。
- en: 'An input string is valid if:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个输入字符串是有效的，如果：
- en: Open brackets must be closed by the same type of brackets.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开括号必须由相同类型的括号关闭。
- en: Open brackets must be closed in the correct order.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开括号必须以正确的顺序关闭。
- en: Every close bracket has a corresponding open bracket of the same type.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个闭合括号都有一个相同类型的对应开括号。
- en: 'The problem also provides three hints, which contain the logic we need to implement
    to resolve this problem:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 问题还提供了三个提示，其中包含我们需要实现以解决此问题的逻辑：
- en: Use a stack of characters.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符栈。
- en: When you encounter an opening bracket, push it to the top of the stack.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你遇到开括号时，将其推入栈顶。
- en: When you encounter a closing bracket, check if the top of the stack was the
    opening for it. If yes, pop it from the stack. Otherwise, return false.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你遇到闭括号时，检查栈顶是否为其开括号。如果是，则从栈中弹出。否则，返回false。
- en: 'Let''s write the `isValid` function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`isValid`函数：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code uses a stack data structure to keep track of the parentheses
    as provided in the hints (`{1}`). Although we are not using our own Stack class
    to resolve this problem, we learned we can use the array and apply the LIFO behavior
    by using the push and pop method from the JavaScript Array class. We also declared
    two arrays: `open` (`{2}`) and `close` (`{3}`), which contain the three types
    of opening and closing brackets, respectively. Then, we iterate over the string
    (`{4}`). If it encounters an opening bracket present in the `open` array (`{5}`),
    then it pushes it onto the stack. If it encounters a closing bracket present in
    the close array ((`{6}`)), it pops the last element from the stack (`{7}`) and
    checks if the popped opening bracket matches its respective closing bracket (`{8}`).
    After the loop, if the stack is empty (`{9}`), it means all opening brackets have
    been correctly matched with closing brackets, so the function returns `true`,
    otherwise if there are still elements left in the stack, it means there are unmatched
    opening brackets.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用栈数据结构来跟踪括号，如提示中所示（`{1}`）。尽管我们没有使用自己的栈类来解决这个问题，但我们了解到我们可以使用数组，并通过使用JavaScript数组类的push和pop方法来应用LIFO行为。我们还声明了两个数组：`open`（`{2}`）和`close`（`{3}`），分别包含三种开闭括号。然后，我们遍历字符串（`{4}`）。如果它遇到`open`数组中存在的开括号（`{5}`），则将其推入栈中。如果它遇到`close`数组中存在的闭括号（`{6}`），则从栈中弹出最后一个元素（`{7}`）并检查弹出的开括号是否与其相应的闭括号匹配（`{8}`）。在循环结束后，如果栈为空（`{9}`），则意味着所有开括号都已正确匹配闭括号，因此函数返回`true`，否则如果栈中仍有元素，则意味着存在未匹配的开括号。
- en: This is solution that passes all the tests and resolves the problem. However,
    if this exercise is being used in technical interviews, the interviewer might
    ask you to try a different solution that does not include arrays to track the
    open and close brackets, after all, the *includes* method alone is of time complexity
    O(n) as it might iterate over the entire array, even though our array only contains
    three elements.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过所有测试并解决问题的解决方案。然而，如果这个练习用于技术面试，面试官可能会要求你尝试一个不同的解决方案，该方案不包括用于跟踪开闭括号的数组，毕竟，`includes`方法的时间复杂度是O(n)，因为它可能会遍历整个数组，即使我们的数组只包含三个元素。
- en: 'We learned in this chapter we can use JavaScript objects for key-value pairs
    as well. So, we can rewrite the `isValid` function using a JavaScript object to
    map the open and close brackets:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到可以使用JavaScript对象来作为键值对。因此，我们可以使用JavaScript对象重写`isValid`函数，以映射开闭括号：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The logic is still the same, however, we can map the open brackets as keys and
    the close brackets as values (`{10}`). This allows us to directly access the elements
    within the object in lines `{11}` and `{12}`, avoiding iterating through the array.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑仍然是相同的，然而，我们可以将开括号映射为键，闭括号映射为值（`{10}`）。这允许我们在`{11}`和`{12}`行中直接访问对象内的元素，从而避免遍历数组。
- en: The time complexity of this function is *O(n)*, where *n* is the length of the
    string `s`. This is because the function iterates over the string `s` once, performing
    a constant amount of work for each character in the string (either pushing to
    the stack, popping from the stack, or comparing characters).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的时间复杂度是*O(n)*，其中*n*是字符串`s`的长度。这是因为函数遍历字符串`s`一次，对字符串中的每个字符执行恒定的操作（要么推入栈，要么从栈中弹出，要么比较字符）。
- en: The space complexity is also *O(n)*, as in the worst-case scenario (when all
    characters are opening brackets), the function would push all characters into
    the stack.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度也是*O(n)*，因为在最坏的情况下（当所有字符都是开括号时），函数会将所有字符推入栈中。
- en: Can you think of any optimizations we can apply to this algorithm?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到我们可以对这个算法应用哪些优化吗？
- en: 'Although our code is working, it can be further optimized by adding some validations
    for edge cases in the beginning of the algorithm:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的代码正在运行，但可以通过在算法开始时添加一些对边缘情况的验证来进一步优化：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The optimizations at the beginning of the function do not change the overall
    time complexity, as they are constant time operations. They may, however, improve
    the function's performance in certain scenarios by allowing it to exit early.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开头进行的优化不会改变整体的时间复杂度，因为它们是常数时间操作。然而，它们可能通过允许函数提前退出而提高函数在某些场景下的性能。
- en: In algorithm challenges, competitions, and technical interviews, these optimizations
    are especially important. Optimizations like these demonstrate that you pay attention
    to detail and care about writing clean, efficient code. This can be a positive
    signal to potential employers. The ability to identify and implement these optimizations
    shows you can think critically about code efficiency and have a good understanding
    of the problem's constraints. Interviewers often value this ability as it demonstrates
    a deeper understanding of algorithms and data structures.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法挑战、竞赛和技术面试中，这些优化特别重要。这样的优化表明你注重细节，关心编写干净、高效的代码。这可以向潜在雇主发出积极的信号。能够识别和实施这些优化表明你能够批判性地思考代码效率，并对问题的约束有良好的理解。面试官通常重视这种能力，因为它展示了你对算法和数据结构的更深入理解。
- en: Min Stack
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小栈
- en: The next exercise we will resolve is the *155\. Min Stack*, available at [https://leetcode.com/problems/min-stack](https://leetcode.com/problems/min-stack).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的下一个练习是*155. 最小栈*，可在[https://leetcode.com/problems/min-stack](https://leetcode.com/problems/min-stack)找到。
- en: This is a design problem that asks you to design a stack that supports push,
    pop, top, and retrieving the minimum element in constant time. The problem also
    states that you must implement a solution with *O(1)* time complexity for each
    function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个设计问题，要求你设计一个支持push、pop、top和在常数时间内检索最小元素的栈。问题还指出，你必须为每个函数实现一个*O(1)*时间复杂度的解决方案。
- en: We have already designed the Stack class in this chapter (the `top` method is
    our `peek` method). What we need to do is keep track of the minimum element in
    the stack.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章中设计了`Stack`类（`top`方法是我们的`peek`方法）。我们需要做的是跟踪栈中的最小元素。
- en: 'The sample input that is given is:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的示例输入是：
- en: '["MinStack","push","push","push","getMin","pop","top","getMin"]'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '["MinStack", "push", "push", "push", "getMin", "pop", "top", "getMin"]'
- en: '[[],[-2],[0],[-3],[],[],[],[]]'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[[], [-2], [0], [-3], [], [], [], []]'
- en: 'And the explanation given is:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 给出的解释是：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s review the MinStack design as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`MinStack`的设计如下：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To be able to return the minimum element of the stack in constant time, we also
    need to track the minimum value. There are different ways of achieving this, and
    the first approach chosen is to also keep a `minStack` to track the minimum values
    (`{1}`).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在常数时间内返回栈的最小元素，我们还需要跟踪最小值。有几种不同的方法可以实现这一点，而第一种选择是也保持一个`minStack`来跟踪最小值（`{1}`）。
- en: The `push` method takes a number `x` as an argument and pushes it onto the stack.
    Then checks if `minStack` is empty or if `x` is less than or equal to the current
    minimum element (which is the last element in `minStack`). If either condition
    is `true`, `x` is also pushed onto `minStack`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`方法接受一个数字`x`作为参数，并将其推入栈中。然后检查`minStack`是否为空或`x`是否小于或等于当前最小元素（这是`minStack`中的最后一个元素）。如果任一条件为真，`x`也将被推入`minStack`。'
- en: The `pop` method removes the top element from stack and assigns it to `x`. If
    `x` is equal to the current minimum element (again, the last element in `minStack`),
    it also removes the top element from `minStack`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop`方法从栈中移除顶部元素并将其赋值给`x`。如果`x`等于当前最小元素（再次，这是`minStack`中的最后一个元素），它也将从`minStack`中移除顶部元素。'
- en: The `top` method has the same implementation as our `peek` method. The `getMin`
    method is the same as doing a peek into the `minStack`, which always holds the
    minimum element of the current state of the stack on its top.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`方法与我们的`peek`方法有相同的实现。`getMin`方法与查看`minStack`相同，`minStack`始终在其顶部持有栈当前状态的最小元素。'
- en: A different approach would be to track the minimum element in a variable instead
    of a stack. We would initialize its value `min= +Infinity` with the biggest numeric
    value in JavaScript, inside the `push` method, we would update its value every
    time a new element is added to the stack (`this.min = Math.min(val, this.min)`)
    and inside the pop method, we would also update the minimum value if the same
    is being removed from the stack (`if (this.min === val) this.min = Math.min(...this.stack)`).
    And for the `getMin` method, we would simply return `this.min`. However, in this
    approach, the pop method would have *O(n)* because it uses `Math.min(...this.stack)`
    to find the new minimum every time an element is popped as this operation requires
    iterating over the entire stack, so it is not necessarily a better solution.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是跟踪变量中的最小元素而不是栈。我们会在`push`方法中将其初始化为`min= +Infinity`，这是JavaScript中最大的数值，每次向栈中添加新元素时，我们会更新其值（`this.min
    = Math.min(val, this.min)`），在`pop`方法中，如果从栈中移除相同的元素，我们也会更新最小值（`if (this.min ===
    val) this.min = Math.min(...this.stack)`）。而对于`getMin`方法，我们只需简单地返回`this.min`。然而，在这种方法中，`pop`方法的时间复杂度会是*O(n)*，因为它每次弹出元素时都会使用`Math.min(...this.stack)`来找到新的最小值，这个操作需要遍历整个栈，所以这并不一定是更好的解决方案。
- en: You will also find the *77\. Simplify Path* problem resolution when you download
    the source code of this book.
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你下载这本书的源代码时，你也会找到*第77题 简化路径*的解决方案。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the fundamental stack data structure. We implemented
    our own stack algorithms using both arrays and JavaScript objects, mastering how
    to efficiently add and remove elements with the `push` and `pop` methods.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了基本栈数据结构。我们使用数组和JavaScript对象实现了自己的栈算法，掌握了如何使用`push`和`pop`方法高效地添加和移除元素。
- en: We explored and compared diverse implementations of the Stack class, weighing
    factors like memory usage, performance, and order preservation to arrive at a
    well-informed recommendation for practical use cases. We have also reviewed the
    implementation of the Stack class using TypeScript and its benefits.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索并比较了Stack类的不同实现，权衡了内存使用、性能和顺序保持等因素，为实际用例提供了明智的建议。我们还审查了使用TypeScript实现的Stack类及其优点。
- en: Beyond implementation, we tackled renowned computer science problems using stacks
    and dissected exercises commonly encountered in technical interviews, analyzing
    their time and space complexities.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是实现，我们还使用栈解决了著名的计算机科学问题，并剖析了在技术面试中常见的一些练习题，分析了它们的时间和空间复杂度。
- en: In the next chapter, we'll shift our focus to queues, a closely related data
    structure that operates on a different principle than the LIFO (Last In, First
    Out) model that governs stacks.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把重点转向队列，这是一种与栈紧密相关的数据结构，它的工作原理与控制栈的LIFO（后进先出）模型不同。
