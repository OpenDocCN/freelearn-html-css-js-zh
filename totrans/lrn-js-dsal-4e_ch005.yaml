- en: 4 Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Before you begin: Join our book community on Discord**'
  prefs: []
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  prefs: []
  type: TYPE_NORMAL
- en: We learned in the previous chapter how to create and use arrays, which are the
    most common type of data structure in computer science. As we learned, we can
    add and remove elements from an array at any index desired. However, sometimes
    we need some form of data structure where we have more control over adding and
    removing items. There are two data structures that have some similarities to arrays,
    but which give us more control over the addition and removal of elements. These
    data structures are **stacks** and **queues**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The stack data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding elements to a stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popping elements from a stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Stack class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different problems we can resolve using the stack data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stack data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you have a stack of trays in a cafeteria or food court, or a pile of
    books, as in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: A stack of books about programming languages and frameworks](img/file16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: A stack of books about programming languages and frameworks'
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose you need to add a new book to the pile. The standard practice is
    to simply add the new book on the top of the pile of books. And in case you need
    to put the books back into the bookshelf, you would pick the book that is on the
    top of the pile, put it away, and then get the next book that is on the top until
    all the books have been stored away. This behavior of adding or removing books
    from the pile of books follows the same principle of a stack data structure.
  prefs: []
  type: TYPE_NORMAL
- en: A stack is an ordered collection of items that follows the *last in, first out*
    (**LIFO**) principle. The addition of new items or the removal of existing items
    takes place at the same end. The end of the stack is known as the **top**, and
    the beginning is known as the **base**. The newest elements are near the top,
    and the oldest elements are near the base.
  prefs: []
  type: TYPE_NORMAL
- en: A stack is used by compilers in programming languages, to store variables and
    method calls in the computer memory, and by the browser history (the browser's
    back button).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another real-world example of a stack data structure is the *undo feature*
    in text editors such as Microsoft Word or Google Documents as showed in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Image of the undo style feature in Microsoft Word software](img/file17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Image of the undo style feature in Microsoft Word software'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have one stack being used internally by Microsoft Word:
    the *undo style* feature, where all the actions performed in the document are
    stacked and we can undo any action by clicking on the undo style button as many
    times as needed, until the stack of actions is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's put these concepts into practice by creating our own Stack class using
    JavaScript and TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array-based Stack class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create our own class to represent a stack. The source code for
    this chapter is available inside the `src/04-stack` folder on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating the `stack.js` file which will contain our class that
    represents a stack using an array-based approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will declare our `Stack` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a data structure that will store the elements of the stack. We can
    use an array to do this as we are already familiar with the array data structure
    (`{1}`). Also, note the prefix of the variable `items`: we are using a hash `#`
    prefix. This means the `#items` property can only be referenced inside the `Stack`
    class. This will allow us to protect this private array as the array data structure
    allows us to add or remove elements from any position in the data structure. Since
    the stack follows the LIFO principle, we will limit the functionalities that will
    be available for the insertion and removal of elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods will be available in the `Stack` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`push(item)`: This method adds a new item to the top of the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop()`: This method removes the top element from the stack. It also returns
    the removed element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This method returns the top element from the stack. The stack is
    not modified (it does not remove the element; it only returns the element for
    information purposes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty()`: This method returns `true` if the stack does not contain any elements,
    and `false` if the size of the stack is bigger than 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This method removes all the elements of the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()`: This method returns the number of elements that the stack contains.
    It is similar to the `length` property of an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will code each method in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing elements to the top of the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first method that we will implement is the `push` method. This method is
    responsible for adding new elements to the stack, with one very important detail:
    we can only add new items to the top of the stack, meaning at the end of the array
    (internally). The `push` method is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we are using an array to store the elements of the stack, we can use the
    `push` method from the JavaScript `Array` class that we covered in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Popping elements from the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we are going to implement the `pop` method. This method is responsible
    for removing the items from the stack. As the stack uses the LIFO principle, the
    last item we added is removed. For this reason, we can use the `pop` method from
    the JavaScript `Array` class that we also covered in the previous chapter. The
    `Stack.pop` method is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In case the stack is empty, this method will return the value `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: With the `push` and `pop` methods being the only methods available for adding
    and removing items from the stack, the LIFO principle will apply to our own `Stack` class.
  prefs: []
  type: TYPE_NORMAL
- en: Peeking the element from the top of the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will implement additional helper methods in our class. If we would
    like to know what the last element added to our stack was, we can use the `peek` method.
    This method will return the item from the top of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are using an array to store the items internally, we can obtain the last
    item from an array using `length - 1` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: A stack of four typing actions simulating the undo feature of
    a text editor.](img/file18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: A stack of four typing actions simulating the undo feature of a
    text editor.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we are simulating the undo feature of a text editor. And we type "top
    of the stack". The feature we are developing will stack each word separately.
    So, we will end up with a stack with four items; therefore, the length of the
    internal array is 4\. The last position used in the internal array is 3\. As a
    result, the `length - 1` (4 - 1) is 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we peek the top of the stack, we will get the following result: `{ action:
    ''typing'', text: ''stack'' }`.'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying whether the stack is empty and its size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next method we will create is the `isEmpty` method, which returns `true` if
    the stack is empty (no element has been added), and `false` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using the `isEmpty` method, we can simply verify whether the length of the internal
    array is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `length` property from the array class, we can also add a getter for
    the length of our Stack class. For collections, we usually use the term *size* instead
    of length. And again, as we are using an array to store the elements internally,
    we can simply return its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In JavaScript, we can leverage a getter to efficiently track the size of our
    stack data structure. Getters provide a cleaner syntax, allowing us to retrieve
    the size as if it were a property (`myStack.size`) rather than calling a method
    like `myStack.size()`. This enhances code readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the elements of the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we are going to implement the `clear` method. The clear method simply
    empties the stack, removing all its elements. The simplest way of implementing
    this method is by directly resetting the internal array to an empty array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative implementation would be calling the `pop` method until the stack
    is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, the first implementation is considered better in most cases in JavaScript
    as it is more efficient. By directly resetting the internal array to an empty
    array, the operation is typically constant time (*O(1)*), regardless of the stack's
    size. The second approach (`clear2()`) iterates through the stack and pops each
    element individually, and the time complexity is linear (*O(n)*), where `n` is
    the number of elements in the stack – this means this operation gets slower as
    the stack grows. From a memory usage standpoint, for the first approach, while
    it might seem like creating a new empty array uses more memory, JavaScript engines
    often optimize this operation, reusing memory where possible.
  prefs: []
  type: TYPE_NORMAL
- en: In rare cases, if the stack is extremely large, and there are concerns about
    memory usage with `clear()`, then `clear2()` could be slightly better due to its
    incremental approach. However, this is an edge case, and the efficiency difference
    would likely be negligible in most real-world scenarios. Also, for the `clear()`
    method, some developers might argue it is technically *O(n)* in the worst case
    due to garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the Stack data structure as a library class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have created a file `src/04-stack/stack.js` with our `Stack` class. And we
    would like to use the `Stack` class in a different file for easy maintainability
    of our code (`src/04-stack/01-using-stack-class.js`). How can we achieve this?
  prefs: []
  type: TYPE_NORMAL
- en: There are different approaches, depending on the environment you are working
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first approach we will learn is the **CommonJS Module** (`module.exports`).
    This is the traditional way of exporting modules in **Node.js**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line will expose our class so we can use it in a different file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This CommonJS Module approach is the one we will use throughout this book as
    we are using the following command to see the output of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you would like to the code in the front-end, we can use **ECMAScript
    Modules** (`export default`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And to use it in a different file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A third approach that we can also use in the front-end is the **Named Exports**,
    which allows us to export multiple items from a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And to use it in a different file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Although we will use the Node.js approach, it is useful to know the other approaches
    so we can adapt our code to different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Stack class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The time to test the Stack class has come! As discussed in the previous subsection,
    let''s go ahead and create a separate file so we can write as many tests as we
    like: `src/04-stack/01-using-stack-class.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to import the code from the stack.js file
    and instantiate the Stack class we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can verify whether it is empty (the output `is true`, because we have
    not added any elements to our stack yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's simulate the undo feature of a text editor. Suppose our text editor
    will store the action (such as typing), along with the text that is being typed.
    Each key stroke will be stored as one action.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s type *Stack*. After each key stroke, we will push the `action`
    and the `text` as an object to the stack. We will start with "St":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the `peek` method, it is going to return the object with text `t`,
    because it was the last element that was added to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also check the stack size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s type a few more characters: "*ack*". This will push another three
    characters to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we check the size and if the stack is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows all the push operations we have executed so far,
    and the status of our stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The push operations in the stack by typing Stack](img/file19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: The push operations in the stack by typing Stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s undo the last two actions by removing two elements from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we evoked the `pop` method twice, our stack had five elements in it.
    After the execution of the pop method twice, the stack now has only three elements.
    We can check by outputting the size and peeking the top of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram exemplifies the execution of the pop method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: The pop operations in the stack by popping two elements](img/file20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: The pop operations in the stack by popping two elements'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the Stack by creating the toString method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we try to execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not friendly at all, and we can enhance the output by creating a `toString`
    method in our `Stack` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If the stack is empty, we can return a message or simply `[]` (whichever is
    your preference). Since we are using an array-based Stack, we can leverage the
    `map` method to iterate and transform each element (`{1}`) of our Stack. For each
    item or element, we can check if the item is an object (`{2}`) and output the
    JSON version of the object for a user friendly output. Otherwise, we can use the
    item's own `toString` method (`{3}`). And to separate each element of the stack,
    we can use a comma and space (`{4}`).
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the efficiency of our Stack class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the Stack class is the first data structure we are creating from scratch,
    let''s review the efficiency of each method by review the Big O notation in terms
    of time of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Complexity** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `push(item)` | *O(1)* | Adding an item to the end of an array is usually
    constant time. |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | *O(1)* | Removing the last item from an array is usually constant
    time. |'
  prefs: []
  type: TYPE_TB
- en: '| `isEmpty()` | *O(1)* | Checking the length of an array is a constant-time
    operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `get size()` | *O(1)* | Accessing the `length` property of an array is constant
    time. |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | *O(1)* | Assigning a new empty array is typically considered
    constant time, although some developers might consider O(n) due to garbage collector
    in the worst-case scenario. |'
  prefs: []
  type: TYPE_TB
- en: '| `toString` | *O(n)* | Iterating through each element of the stack takes linear
    time. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1:'
  prefs: []
  type: TYPE_NORMAL
- en: In the array-based implementation, operations like `push()` might occasionally
    take longer due to the array needing to be resized. However, on average, the time
    complexity still tends to be *O(1)* over many operations. JavaScript arrays are
    not fixed size like arrays in some other languages. They are dynamic, meaning
    they can grow or shrink as needed. Internally, they are typically implemented
    as dynamic arrays or hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript follows the ECMAScript standard, and each browser or engine might
    have its own implementation, meaning the array `push` method might have a different
    internal source code in Node.js, Chrome, Firefox, or Edge. Regardless of the implementation,
    the contract or the functionality will be the same, meaning the `push` method
    will add a new element to the end of the array, even if different engines have
    a different approach on how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the dynamic array approach, when you push an element onto an array, and
    it has no more space, it might need to allocate a larger block of memory, copy
    the existing elements over, and then add the new element. This resizing can be
    an expensive operation, taking *O(n)* time (where *n* is the number of elements).
    In some JavaScript engines, arrays might use hash tables internally for faster
    access: `push` and `pop` would still typically be `O(1)`, but the details can
    vary depending on the implementation. We will learn more about hash tables in
    *Chapter 8, Dictionaries and Hashes*.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JavaScript object-based Stack class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way of creating a Stack class is using an array to store its elements.
    When working with a large set of data (which is quite common in real-world projects),
    we also need to analyze what is the most efficient way of manipulating the data.
  prefs: []
  type: TYPE_NORMAL
- en: When reviewing the efficiency of our array-based `Stack` class, we learned that
    some JavaScript engines might use hash tables to implement an array. We have not
    learned hash tables yet, but we can implement a Stack class using a JavaScript
    object to store the stack elements, and by doing so, we can access any element
    directly, with time complexity *O(1)*. And of course, comply with the LIFO principle.
    Let's see how we can achieve this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by declaring the Stack class (`src/04-stack/stack-object.js` file)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For this version of the `Stack` class, we will use a JavaScript empty object
    instead of an empty array (`{1}`) to store the data and a `count` property to
    help us keep track of the size of the stack (and, consequently, also help us in
    adding and removing elements).
  prefs: []
  type: TYPE_NORMAL
- en: Pushing elements to the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will declare our first method, used to add elements to the top of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In JavaScript, an object is a set of **key** and **value** pairs. To add an `item` to
    the stack, we will use the `count` variable as the key to the `items` object and
    the `item` will be its value. After pushing the element to the stack, we increment
    the `count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, we have two main ways to assign a value to a particular key
    within an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dot notation*: `this.#items.1 = item`. This is the most common and concise
    way to assign values when we know the key name in advance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bracket Notation*: `this.#items[this.#count] = item`. Bracket notation offers
    more flexibility as can use variables or expressions to determine the key name.
    This notation is essential when dealing with dynamic keys, as it is our case in
    this scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the same example as before to use the `Stack` class and type "St":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, we will have the following values inside the `items` and `count` private
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Verifying whether the stack is empty and its size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `#count` property also works as the size of the stack. So, for the `size`
    getter, we can simply return the `#count` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And to verify whether the stack is empty, we can compare if the `#count` value
    is 0 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Popping elements from the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we are not using an array to store the elements, we will need to implement
    the logic to remove an element manually. The `pop` method also returns the element
    that was removed from the stack. The `pop` method for the object-based implementation
    is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to verify whether the stack is empty (`{1}`) and, if so, we return
    the value `undefined` (the array `pop` method returns undefined in case the array
    is empty, so we are following the same behavior). If the stack is not empty, we
    will decrement the `#count` property (`{2}`) and we will store the value from
    the top of the stack (`{3}`) temporarily so we can return it (`{5}`) after the
    element has been removed (`{4}`).
  prefs: []
  type: TYPE_NORMAL
- en: As we are working with a JavaScript object, to remove a specific value from
    the object, we can use the JavaScript `delete` operator as in line `{4}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the following internal values to emulate the `pop` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the element from the top of the stack (latest `text` added: `t`),
    we need to access the key with value `1`. To do so, we decrement the `#count`
    variable from `2` to `1`. We can access `#items[1]`, delete it, and return its
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: Peeking the top of the stack and clearing it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To peek the element that is on the top of the stack we will use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The behavior is like the peek method of the array-based implementation. In case
    the stack is empty, it will return `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And to clear the stack, we can simply reset it to the same values we initialized
    the class with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Creating the toString method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the `toString` method for the object-based Stack class, we will use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the stack is empty, we can return a message or `{}` (whichever is your preference).
    Next, we will transform the first element into a string (`{1}`) – this is in case
    the stack only has one element or so we do not need to append a comma at the end
    of the string. Next, we will iterate through all the elements (`{2}`) by using
    the `#count` property (that also works as a key within our `#items` object). For
    each additional element, we will append a comma, followed by the string version
    of the element (`{3}`). Since we need to stringify the first element and all the
    subsequent elements of the stack, instead of duplicating the code, we can create
    another method (`{4}`) that will transform an element into a string (this is the
    same logic we used in the array-based version). By prefixing the method with hash
    (`#`), JavaScript will not expose this method and it will not be available to
    be used outside this class (it is a private method).
  prefs: []
  type: TYPE_NORMAL
- en: Comparing object-based approach with array-based stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The time complexity of all methods for the object-based `Stack` class is constant
    time (*O(1)*) as we can access any element directly. The only method that is linear
    time (*O(n)*) is the `toString` method as we need to iterate through all the elements
    of the stack, where *n* is the stack size.
  prefs: []
  type: TYPE_NORMAL
- en: If we compare our array-based versus our object-based implementation, which
    one do you think is the best one?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review both approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Performance*: Both implementations have similar Big O complexities for most
    operations. However, array-based stacks might have a slight edge in overall performance
    due to potential resizing issues with object-based stacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Element access*: Array-based stacks offer efficient random access by index,
    which can be useful in some scenarios. In some real-world examples, such as the
    undo feature, if the user wants to undo multiple steps at once, you can quickly
    access the relevant change based on its position in the stack using an index (in
    this case, the stack is not so strict to the LIFO behavior). If the stack operations
    primarily consist of pushing, popping, and peeking at the top element, then random
    access might not be a significant factor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Order*: If maintaining strict order of elements is important, array-based
    stacks are the preferred choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Memory*: Array-based stacks are generally more memory-efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For most use cases involving stacks, the array-based implementation is generally
    recommended due to its order preservation, efficient access, and better memory
    usage. The object-based implementation might be considered in situations where
    order is not crucial, and you need a simple, straightforward implementation for
    basic stack operations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Stack class using TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed previously in this book, using TypeScript to create a data structure
    API like our Stack class offers several significant advantages over plain JavaScript,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhanced type safety: early error detection with static typing catches type-related
    errors during development, preventing them from causing runtime failures. This
    is crucial when building APIs (such as our Stack class) that others will consume,
    as it helps ensure correct usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explicit contracts: TypeScript''s interfaces and type aliases let us define
    the exact structure and types of the data our stack will hold, making it easier
    for others to understand how to interact with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generics: We can make the Stack class more versatile by using generics to specify
    the type of data it will store. This allows for type-safe operations on various
    kinds of data (numbers, strings, objects, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Self-documenting code: TypeScript''s type annotations serve as built-in documentation,
    explaining the purpose of functions, parameters, and return values. This reduces
    the need for separate documentation and makes our code easier to understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s check how we can rewrite our Stack class using array-based implementation
    using TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the generics (`{1}`) to make our class flexible. It can hold elements
    of any type (`T`), whether it''s numbers, strings, objects, or custom types. This
    is a major advantage over a JavaScript implementation as JavaScript allows mixed
    types of data in the data structure and by typing our Stack class, we are enforcing
    all elements will be of the same type (`{2}`). TypeScript also has a `private`
    keyword to declare private properties and methods. This feature became available
    years before JavaScript added the hash # prefix to allow private properties and
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: The code inside the methods is the same as the JavaScript implementation. The
    advantage here is we can type any method arguments and their return type, facilitating
    reading the code with more ease.
  prefs: []
  type: TYPE_NORMAL
- en: The export (`{3}`) syntax follows the ECMAScript approach we reviewed earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use this data structure in a separate file so we can test it,
    we can create another file (equivalent to the JavaScript file we created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can create an enumerator to define all the types allowed in the text editor
    (`{4}`). This step is optional, but a good practice to avoid typo mistakes. Next,
    we can create an interface to define the type of the data our stack will store
    (`{5}`). Finally, when we instantiate the `Stack` data structure, we can type
    it to ensure all elements will be of the same type (`{6}`). The remaining sample
    code will be the same as in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the output of the example file, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `ts-node` package allows us to execute the TypeScript code without manually
    compiling it first. The output will be the same as the one in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems using stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to use the `Stack` class, let's use it to solve some computer
    science problems. In this section, we will cover the decimal to binary problem,
    and we will also transform the algorithm into a base converter algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Converting decimal numbers to binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are already familiar with the decimal base. However, binary representation
    is particularly important in computer science, as everything in a computer is
    represented by binary digits (0 and 1).
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely helpful when working with data storage for example. Computers
    store all information as binary digits. When we save a file, the decimal representation
    of each character or pixel is converted to binary before being stored on the hard
    drive or other storage media. Some file formats, like image files (.bmp, .png)
    and audio files (.wav), store data partially or entirely in binary format. Understanding
    binary conversion is crucial for working with these files at a low level. Another
    application are barcodes, which are essentially binary patterns of black and white
    lines that represent decimal numbers. Scanners decode these patterns back into
    decimals to identify products and other information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a decimal number into a binary representation, we can divide the
    number by 2 (binary is a base 2 number system) until the division result is 0\.
    As an example, we will convert the number 10 into binary digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: A mathematical representation of converting the number 10 into
    binary digits](img/file21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: A mathematical representation of converting the number 10 into
    binary digits'
  prefs: []
  type: TYPE_NORMAL
- en: 'This conversion is one of the first things you learn in computer science classes.
    The decimal to binary algorithm is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the provided code, as long as the quotient of the division is non-zero (line
    `{1}`), we calculate the remainder using the modulo operator (line `{2}`) and
    push it onto the stack (line {3}). We then update the dividend for the next iteration
    by dividing it by 2 and discarding any fractional part using `Math.floor` (line
    `{4}`). This is necessary because JavaScript does not distinguish between integers
    and floating-point numbers. Finally, we pop elements from the stack until it's
    empty (line `{5}`), concatenating them into a string to form the binary representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call `decimalToBinary(13)`, here''s how the process would unfold:'
  prefs: []
  type: TYPE_NORMAL
- en: 13 % 2 = 1 (remainder pushed onto stack); 13 / 2 = 6 (integer division)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6 % 2 = 0 (remainder pushed onto stack); 6 / 2 = 3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3 % 2 = 1 (remainder pushed onto stack); 3 / 2 = 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1 % 2 = 1 (remainder pushed onto stack); 1 / 2 = 0 (loop terminates)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stack: [1, 1, 0, 1] (top to bottom)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Popping from the stack and building the result string: "1101"'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The base converter algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can modify the previous algorithm to make it work as a converter from decimal
    to the bases between `2` and `36`. Instead of dividing the decimal number by 2,
    we can pass the desired base as an argument to the method and use it in the division
    operations, as shown in the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There is one more thing we need to change. In the conversion from decimal to
    binary, the remainders will be 0 or 1; in the conversion from decimal to octagonal,
    the remainders will be from 0 to 8; and in the conversion from decimal to hexadecimal,
    the remainders can be 0 to 9 plus the letters A to F (values 10 to 15). For this
    reason, we need to convert these values as well (lines `{6}` and `{7}`). So, starting
    at base 11, each letter of the alphabet will represent its base. The letter `A` represents
    base 11, `B` represents base 12, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the previous algorithm and output its result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And when could we use this algorithm in the real-world? This algorithm has
    many applications such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hexadecimal (base 16): Web developers and graphic designers frequently use
    hexadecimal notation to represent colors in HTML, CSS, and other digital design
    tools. For example, the color white is represented as `#FFFFFF`, which is equivalent
    to the decimal value `16777215`. The `decimalToBase` algorithm could be used to
    convert color values between decimal and hexadecimal representations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Base64 encoding: Base64 is a common encoding scheme used to represent binary
    data (images, audio, and so on) as text. It uses a 64-character alphabet (A-Z,
    a-z, 0-9, +, /) and converts binary data into base-64 representation for easier
    transmission over text-based protocols like email. We could enhance our algorithm
    to convert to a base-64 (use this as a challenge to try on your own, you will
    find the resolution in the source code of this book).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shortened URLs or unique identifiers: Services like [bit.ly](https://bit.ly)
    generate shortened URLs that use a mix of alphanumeric characters. These shortened
    URLs often represent unique numeric identifiers that have been converted to a
    higher base (for example: base 62) to make them more compact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also find the *Hanoi Tower* example when you download the source code
    of this book.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will resolve a few array exercises from **LeetCode** using the concepts we
    learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Valid Parentheses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first exercise we will resolve is the *20\. Valid Parentheses* problem available
    at [https://leetcode.com/problems/valid-parentheses/](https://leetcode.com/problems/valid-parentheses/).
  prefs: []
  type: TYPE_NORMAL
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `function isValid(s: string): boolean {}`, which
    receives a string it is expecting a boolean to be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the sample input and expected output provided by the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Input "()", output true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input "()", output true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input "(]", output false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An input string is valid if:'
  prefs: []
  type: TYPE_NORMAL
- en: Open brackets must be closed by the same type of brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open brackets must be closed in the correct order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every close bracket has a corresponding open bracket of the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The problem also provides three hints, which contain the logic we need to implement
    to resolve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a stack of characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you encounter an opening bracket, push it to the top of the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you encounter a closing bracket, check if the top of the stack was the
    opening for it. If yes, pop it from the stack. Otherwise, return false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write the `isValid` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses a stack data structure to keep track of the parentheses
    as provided in the hints (`{1}`). Although we are not using our own Stack class
    to resolve this problem, we learned we can use the array and apply the LIFO behavior
    by using the push and pop method from the JavaScript Array class. We also declared
    two arrays: `open` (`{2}`) and `close` (`{3}`), which contain the three types
    of opening and closing brackets, respectively. Then, we iterate over the string
    (`{4}`). If it encounters an opening bracket present in the `open` array (`{5}`),
    then it pushes it onto the stack. If it encounters a closing bracket present in
    the close array ((`{6}`)), it pops the last element from the stack (`{7}`) and
    checks if the popped opening bracket matches its respective closing bracket (`{8}`).
    After the loop, if the stack is empty (`{9}`), it means all opening brackets have
    been correctly matched with closing brackets, so the function returns `true`,
    otherwise if there are still elements left in the stack, it means there are unmatched
    opening brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: This is solution that passes all the tests and resolves the problem. However,
    if this exercise is being used in technical interviews, the interviewer might
    ask you to try a different solution that does not include arrays to track the
    open and close brackets, after all, the *includes* method alone is of time complexity
    O(n) as it might iterate over the entire array, even though our array only contains
    three elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned in this chapter we can use JavaScript objects for key-value pairs
    as well. So, we can rewrite the `isValid` function using a JavaScript object to
    map the open and close brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The logic is still the same, however, we can map the open brackets as keys and
    the close brackets as values (`{10}`). This allows us to directly access the elements
    within the object in lines `{11}` and `{12}`, avoiding iterating through the array.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of this function is *O(n)*, where *n* is the length of the
    string `s`. This is because the function iterates over the string `s` once, performing
    a constant amount of work for each character in the string (either pushing to
    the stack, popping from the stack, or comparing characters).
  prefs: []
  type: TYPE_NORMAL
- en: The space complexity is also *O(n)*, as in the worst-case scenario (when all
    characters are opening brackets), the function would push all characters into
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of any optimizations we can apply to this algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: 'Although our code is working, it can be further optimized by adding some validations
    for edge cases in the beginning of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The optimizations at the beginning of the function do not change the overall
    time complexity, as they are constant time operations. They may, however, improve
    the function's performance in certain scenarios by allowing it to exit early.
  prefs: []
  type: TYPE_NORMAL
- en: In algorithm challenges, competitions, and technical interviews, these optimizations
    are especially important. Optimizations like these demonstrate that you pay attention
    to detail and care about writing clean, efficient code. This can be a positive
    signal to potential employers. The ability to identify and implement these optimizations
    shows you can think critically about code efficiency and have a good understanding
    of the problem's constraints. Interviewers often value this ability as it demonstrates
    a deeper understanding of algorithms and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Min Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next exercise we will resolve is the *155\. Min Stack*, available at [https://leetcode.com/problems/min-stack](https://leetcode.com/problems/min-stack).
  prefs: []
  type: TYPE_NORMAL
- en: This is a design problem that asks you to design a stack that supports push,
    pop, top, and retrieving the minimum element in constant time. The problem also
    states that you must implement a solution with *O(1)* time complexity for each
    function.
  prefs: []
  type: TYPE_NORMAL
- en: We have already designed the Stack class in this chapter (the `top` method is
    our `peek` method). What we need to do is keep track of the minimum element in
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample input that is given is:'
  prefs: []
  type: TYPE_NORMAL
- en: '["MinStack","push","push","push","getMin","pop","top","getMin"]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[[],[-2],[0],[-3],[],[],[],[]]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the explanation given is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the MinStack design as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To be able to return the minimum element of the stack in constant time, we also
    need to track the minimum value. There are different ways of achieving this, and
    the first approach chosen is to also keep a `minStack` to track the minimum values
    (`{1}`).
  prefs: []
  type: TYPE_NORMAL
- en: The `push` method takes a number `x` as an argument and pushes it onto the stack.
    Then checks if `minStack` is empty or if `x` is less than or equal to the current
    minimum element (which is the last element in `minStack`). If either condition
    is `true`, `x` is also pushed onto `minStack`.
  prefs: []
  type: TYPE_NORMAL
- en: The `pop` method removes the top element from stack and assigns it to `x`. If
    `x` is equal to the current minimum element (again, the last element in `minStack`),
    it also removes the top element from `minStack`.
  prefs: []
  type: TYPE_NORMAL
- en: The `top` method has the same implementation as our `peek` method. The `getMin`
    method is the same as doing a peek into the `minStack`, which always holds the
    minimum element of the current state of the stack on its top.
  prefs: []
  type: TYPE_NORMAL
- en: A different approach would be to track the minimum element in a variable instead
    of a stack. We would initialize its value `min= +Infinity` with the biggest numeric
    value in JavaScript, inside the `push` method, we would update its value every
    time a new element is added to the stack (`this.min = Math.min(val, this.min)`)
    and inside the pop method, we would also update the minimum value if the same
    is being removed from the stack (`if (this.min === val) this.min = Math.min(...this.stack)`).
    And for the `getMin` method, we would simply return `this.min`. However, in this
    approach, the pop method would have *O(n)* because it uses `Math.min(...this.stack)`
    to find the new minimum every time an element is popped as this operation requires
    iterating over the entire stack, so it is not necessarily a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: You will also find the *77\. Simplify Path* problem resolution when you download
    the source code of this book.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we delved into the fundamental stack data structure. We implemented
    our own stack algorithms using both arrays and JavaScript objects, mastering how
    to efficiently add and remove elements with the `push` and `pop` methods.
  prefs: []
  type: TYPE_NORMAL
- en: We explored and compared diverse implementations of the Stack class, weighing
    factors like memory usage, performance, and order preservation to arrive at a
    well-informed recommendation for practical use cases. We have also reviewed the
    implementation of the Stack class using TypeScript and its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond implementation, we tackled renowned computer science problems using stacks
    and dissected exercises commonly encountered in technical interviews, analyzing
    their time and space complexities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll shift our focus to queues, a closely related data
    structure that operates on a different principle than the LIFO (Last In, First
    Out) model that governs stacks.
  prefs: []
  type: TYPE_NORMAL
