- en: 4 Stacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Before you begin: Join our book community on Discord**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We learned in the previous chapter how to create and use arrays, which are the
    most common type of data structure in computer science. As we learned, we can
    add and remove elements from an array at any index desired. However, sometimes
    we need some form of data structure where we have more control over adding and
    removing items. There are two data structures that have some similarities to arrays,
    but which give us more control over the addition and removal of elements. These
    data structures are **stacks** and **queues**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The stack data structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding elements to a stack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popping elements from a stack
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Stack class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different problems we can resolve using the stack data structure
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stack data structure
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you have a stack of trays in a cafeteria or food court, or a pile of
    books, as in the following image:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: A stack of books about programming languages and frameworks](img/file16.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: A stack of books about programming languages and frameworks'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose you need to add a new book to the pile. The standard practice is
    to simply add the new book on the top of the pile of books. And in case you need
    to put the books back into the bookshelf, you would pick the book that is on the
    top of the pile, put it away, and then get the next book that is on the top until
    all the books have been stored away. This behavior of adding or removing books
    from the pile of books follows the same principle of a stack data structure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: A stack is an ordered collection of items that follows the *last in, first out*
    (**LIFO**) principle. The addition of new items or the removal of existing items
    takes place at the same end. The end of the stack is known as the **top**, and
    the beginning is known as the **base**. The newest elements are near the top,
    and the oldest elements are near the base.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A stack is used by compilers in programming languages, to store variables and
    method calls in the computer memory, and by the browser history (the browser's
    back button).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Another real-world example of a stack data structure is the *undo feature*
    in text editors such as Microsoft Word or Google Documents as showed in the following
    image:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Image of the undo style feature in Microsoft Word software](img/file17.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Image of the undo style feature in Microsoft Word software'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have one stack being used internally by Microsoft Word:
    the *undo style* feature, where all the actions performed in the document are
    stacked and we can undo any action by clicking on the undo style button as many
    times as needed, until the stack of actions is empty.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们有一个由Microsoft Word内部使用的栈：*撤销样式*功能，其中所有在文档中执行的操作都被堆叠起来，我们可以通过点击撤销样式按钮多次来撤销任何操作，直到操作栈为空。
- en: Let's put these concepts into practice by creating our own Stack class using
    JavaScript and TypeScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用JavaScript和TypeScript创建自己的栈类来将这些概念付诸实践。
- en: Creating an array-based Stack class
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基于数组的栈类
- en: We are going to create our own class to represent a stack. The source code for
    this chapter is available inside the `src/04-stack` folder on GitHub.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自己的类来表示栈。本章的源代码可在GitHub上的`src/04-stack`文件夹中找到。
- en: We will start by creating the `stack.js` file which will contain our class that
    represents a stack using an array-based approach.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建`stack.js`文件，该文件将包含我们使用基于数组的策略表示栈的类。
- en: 'First, we will declare our `Stack` class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明我们的`Stack`类：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need a data structure that will store the elements of the stack. We can
    use an array to do this as we are already familiar with the array data structure
    (`{1}`). Also, note the prefix of the variable `items`: we are using a hash `#`
    prefix. This means the `#items` property can only be referenced inside the `Stack`
    class. This will allow us to protect this private array as the array data structure
    allows us to add or remove elements from any position in the data structure. Since
    the stack follows the LIFO principle, we will limit the functionalities that will
    be available for the insertion and removal of elements.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个数据结构来存储栈的元素。由于我们已经熟悉数组数据结构（`{1}`），我们可以使用数组来完成此操作。此外，注意变量`items`的前缀：我们使用了一个哈希`#`前缀。这意味着`#items`属性只能在`Stack`类内部引用。这将允许我们保护这个私有数组，因为数组数据结构允许我们在数据结构的任何位置添加或删除元素。由于栈遵循LIFO原则，我们将限制可用于插入和删除元素的功能。
- en: 'The following methods will be available in the `Stack` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack`类中将提供以下方法：'
- en: '`push(item)`: This method adds a new item to the top of the stack.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push(item)`: 此方法将新项目添加到栈的顶部。'
- en: '`pop()`: This method removes the top element from the stack. It also returns
    the removed element.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop()`: 此方法从栈中移除顶部元素。它还返回被移除的元素。'
- en: '`peek()`: This method returns the top element from the stack. The stack is
    not modified (it does not remove the element; it only returns the element for
    information purposes).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 此方法返回栈的顶部元素。栈不会被修改（它不会删除元素；它只返回元素以供信息用途）。'
- en: '`isEmpty()`: This method returns `true` if the stack does not contain any elements,
    and `false` if the size of the stack is bigger than 0.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 此方法返回`true`，如果栈不包含任何元素，如果栈的大小大于0，则返回`false`。'
- en: '`clear()`: This method removes all the elements of the stack.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 此方法移除栈中的所有元素。'
- en: '`size()`: This method returns the number of elements that the stack contains.
    It is similar to the `length` property of an array.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 此方法返回栈包含的元素数量。它与数组的`length`属性类似。'
- en: We will code each method in the following sections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中为每个方法编写代码。
- en: Pushing elements to the top of the stack
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将元素推送到栈顶
- en: 'The first method that we will implement is the `push` method. This method is
    responsible for adding new elements to the stack, with one very important detail:
    we can only add new items to the top of the stack, meaning at the end of the array
    (internally). The `push` method is represented as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一种方法是`push`方法。此方法负责向栈中添加新元素，有一个非常重要的细节：我们只能将新项目添加到栈顶，即数组的末尾（内部）。`push`方法表示如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we are using an array to store the elements of the stack, we can use the
    `push` method from the JavaScript `Array` class that we covered in the previous
    chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用数组来存储栈的元素，我们可以使用上一章中介绍的JavaScript `Array`类的`push`方法。
- en: Popping elements from the stack
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从栈中弹出元素
- en: 'Next, we are going to implement the `pop` method. This method is responsible
    for removing the items from the stack. As the stack uses the LIFO principle, the
    last item we added is removed. For this reason, we can use the `pop` method from
    the JavaScript `Array` class that we also covered in the previous chapter. The
    `Stack.pop` method is represented as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In case the stack is empty, this method will return the value `undefined`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: With the `push` and `pop` methods being the only methods available for adding
    and removing items from the stack, the LIFO principle will apply to our own `Stack` class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Peeking the element from the top of the stack
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will implement additional helper methods in our class. If we would
    like to know what the last element added to our stack was, we can use the `peek` method.
    This method will return the item from the top of the stack:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we are using an array to store the items internally, we can obtain the last
    item from an array using `length - 1` as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: A stack of four typing actions simulating the undo feature of
    a text editor.](img/file18.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: A stack of four typing actions simulating the undo feature of a
    text editor.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we are simulating the undo feature of a text editor. And we type "top
    of the stack". The feature we are developing will stack each word separately.
    So, we will end up with a stack with four items; therefore, the length of the
    internal array is 4\. The last position used in the internal array is 3\. As a
    result, the `length - 1` (4 - 1) is 3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we peek the top of the stack, we will get the following result: `{ action:
    ''typing'', text: ''stack'' }`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Verifying whether the stack is empty and its size
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next method we will create is the `isEmpty` method, which returns `true` if
    the stack is empty (no element has been added), and `false` otherwise:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the `isEmpty` method, we can simply verify whether the length of the internal
    array is 0.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `length` property from the array class, we can also add a getter for
    the length of our Stack class. For collections, we usually use the term *size* instead
    of length. And again, as we are using an array to store the elements internally,
    we can simply return its length:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In JavaScript, we can leverage a getter to efficiently track the size of our
    stack data structure. Getters provide a cleaner syntax, allowing us to retrieve
    the size as if it were a property (`myStack.size`) rather than calling a method
    like `myStack.size()`. This enhances code readability and maintainability.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the elements of the stack
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we are going to implement the `clear` method. The clear method simply
    empties the stack, removing all its elements. The simplest way of implementing
    this method is by directly resetting the internal array to an empty array as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An alternative implementation would be calling the `pop` method until the stack
    is empty:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, the first implementation is considered better in most cases in JavaScript
    as it is more efficient. By directly resetting the internal array to an empty
    array, the operation is typically constant time (*O(1)*), regardless of the stack's
    size. The second approach (`clear2()`) iterates through the stack and pops each
    element individually, and the time complexity is linear (*O(n)*), where `n` is
    the number of elements in the stack – this means this operation gets slower as
    the stack grows. From a memory usage standpoint, for the first approach, while
    it might seem like creating a new empty array uses more memory, JavaScript engines
    often optimize this operation, reusing memory where possible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In rare cases, if the stack is extremely large, and there are concerns about
    memory usage with `clear()`, then `clear2()` could be slightly better due to its
    incremental approach. However, this is an edge case, and the efficiency difference
    would likely be negligible in most real-world scenarios. Also, for the `clear()`
    method, some developers might argue it is technically *O(n)* in the worst case
    due to garbage collection.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the Stack data structure as a library class
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have created a file `src/04-stack/stack.js` with our `Stack` class. And we
    would like to use the `Stack` class in a different file for easy maintainability
    of our code (`src/04-stack/01-using-stack-class.js`). How can we achieve this?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: There are different approaches, depending on the environment you are working
    with.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The first approach we will learn is the **CommonJS Module** (`module.exports`).
    This is the traditional way of exporting modules in **Node.js**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last line will expose our class so we can use it in a different file as
    follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This CommonJS Module approach is the one we will use throughout this book as
    we are using the following command to see the output of our code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, if you would like to the code in the front-end, we can use **ECMAScript
    Modules** (`export default`) as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And to use it in a different file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A third approach that we can also use in the front-end is the **Named Exports**,
    which allows us to export multiple items from a module:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And to use it in a different file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although we will use the Node.js approach, it is useful to know the other approaches
    so we can adapt our code to different environments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Using the Stack class
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The time to test the Stack class has come! As discussed in the previous subsection,
    let''s go ahead and create a separate file so we can write as many tests as we
    like: `src/04-stack/01-using-stack-class.js`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to import the code from the stack.js file
    and instantiate the Stack class we just created:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we can verify whether it is empty (the output `is true`, because we have
    not added any elements to our stack yet):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, let's simulate the undo feature of a text editor. Suppose our text editor
    will store the action (such as typing), along with the text that is being typed.
    Each key stroke will be stored as one action.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s type *Stack*. After each key stroke, we will push the `action`
    and the `text` as an object to the stack. We will start with "St":'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we call the `peek` method, it is going to return the object with text `t`,
    because it was the last element that was added to the stack:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s also check the stack size:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s type a few more characters: "*ack*". This will push another three
    characters to the stack:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And if we check the size and if the stack is empty:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following diagram shows all the push operations we have executed so far,
    and the status of our stack:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The push operations in the stack by typing Stack](img/file19.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: The push operations in the stack by typing Stack'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s undo the last two actions by removing two elements from the stack:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before we evoked the `pop` method twice, our stack had five elements in it.
    After the execution of the pop method twice, the stack now has only three elements.
    We can check by outputting the size and peeking the top of the stack:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following diagram exemplifies the execution of the pop method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: The pop operations in the stack by popping two elements](img/file20.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: The pop operations in the stack by popping two elements'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the Stack by creating the toString method
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we try to execute the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will get the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is not friendly at all, and we can enhance the output by creating a `toString`
    method in our `Stack` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the stack is empty, we can return a message or simply `[]` (whichever is
    your preference). Since we are using an array-based Stack, we can leverage the
    `map` method to iterate and transform each element (`{1}`) of our Stack. For each
    item or element, we can check if the item is an object (`{2}`) and output the
    JSON version of the object for a user friendly output. Otherwise, we can use the
    item's own `toString` method (`{3}`). And to separate each element of the stack,
    we can use a comma and space (`{4}`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the efficiency of our Stack class
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the Stack class is the first data structure we are creating from scratch,
    let''s review the efficiency of each method by review the Big O notation in terms
    of time of execution:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Complexity** | **Explanation** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `push(item)` | *O(1)* | Adding an item to the end of an array is usually
    constant time. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | *O(1)* | Removing the last item from an array is usually constant
    time. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `isEmpty()` | *O(1)* | Checking the length of an array is a constant-time
    operation. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `get size()` | *O(1)* | Accessing the `length` property of an array is constant
    time. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | *O(1)* | Assigning a new empty array is typically considered
    constant time, although some developers might consider O(n) due to garbage collector
    in the worst-case scenario. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `toString` | *O(n)* | Iterating through each element of the stack takes linear
    time. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In the array-based implementation, operations like `push()` might occasionally
    take longer due to the array needing to be resized. However, on average, the time
    complexity still tends to be *O(1)* over many operations. JavaScript arrays are
    not fixed size like arrays in some other languages. They are dynamic, meaning
    they can grow or shrink as needed. Internally, they are typically implemented
    as dynamic arrays or hash tables.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript follows the ECMAScript standard, and each browser or engine might
    have its own implementation, meaning the array `push` method might have a different
    internal source code in Node.js, Chrome, Firefox, or Edge. Regardless of the implementation,
    the contract or the functionality will be the same, meaning the `push` method
    will add a new element to the end of the array, even if different engines have
    a different approach on how to do it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'For the dynamic array approach, when you push an element onto an array, and
    it has no more space, it might need to allocate a larger block of memory, copy
    the existing elements over, and then add the new element. This resizing can be
    an expensive operation, taking *O(n)* time (where *n* is the number of elements).
    In some JavaScript engines, arrays might use hash tables internally for faster
    access: `push` and `pop` would still typically be `O(1)`, but the details can
    vary depending on the implementation. We will learn more about hash tables in
    *Chapter 8, Dictionaries and Hashes*.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JavaScript object-based Stack class
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way of creating a Stack class is using an array to store its elements.
    When working with a large set of data (which is quite common in real-world projects),
    we also need to analyze what is the most efficient way of manipulating the data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: When reviewing the efficiency of our array-based `Stack` class, we learned that
    some JavaScript engines might use hash tables to implement an array. We have not
    learned hash tables yet, but we can implement a Stack class using a JavaScript
    object to store the stack elements, and by doing so, we can access any element
    directly, with time complexity *O(1)*. And of course, comply with the LIFO principle.
    Let's see how we can achieve this behavior.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by declaring the Stack class (`src/04-stack/stack-object.js` file)
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For this version of the `Stack` class, we will use a JavaScript empty object
    instead of an empty array (`{1}`) to store the data and a `count` property to
    help us keep track of the size of the stack (and, consequently, also help us in
    adding and removing elements).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Pushing elements to the stack
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will declare our first method, used to add elements to the top of the stack:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In JavaScript, an object is a set of **key** and **value** pairs. To add an `item` to
    the stack, we will use the `count` variable as the key to the `items` object and
    the `item` will be its value. After pushing the element to the stack, we increment
    the `count`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, we have two main ways to assign a value to a particular key
    within an object:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '*Dot notation*: `this.#items.1 = item`. This is the most common and concise
    way to assign values when we know the key name in advance.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bracket Notation*: `this.#items[this.#count] = item`. Bracket notation offers
    more flexibility as can use variables or expressions to determine the key name.
    This notation is essential when dealing with dynamic keys, as it is our case in
    this scenario.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the same example as before to use the `Stack` class and type "St":'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Internally, we will have the following values inside the `items` and `count` private
    properties:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Verifying whether the stack is empty and its size
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `#count` property also works as the size of the stack. So, for the `size`
    getter, we can simply return the `#count` property:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And to verify whether the stack is empty, we can compare if the `#count` value
    is 0 as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Popping elements from the stack
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we are not using an array to store the elements, we will need to implement
    the logic to remove an element manually. The `pop` method also returns the element
    that was removed from the stack. The `pop` method for the object-based implementation
    is presented as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we need to verify whether the stack is empty (`{1}`) and, if so, we return
    the value `undefined` (the array `pop` method returns undefined in case the array
    is empty, so we are following the same behavior). If the stack is not empty, we
    will decrement the `#count` property (`{2}`) and we will store the value from
    the top of the stack (`{3}`) temporarily so we can return it (`{5}`) after the
    element has been removed (`{4}`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: As we are working with a JavaScript object, to remove a specific value from
    the object, we can use the JavaScript `delete` operator as in line `{4}`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the following internal values to emulate the `pop` action:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To access the element from the top of the stack (latest `text` added: `t`),
    we need to access the key with value `1`. To do so, we decrement the `#count`
    variable from `2` to `1`. We can access `#items[1]`, delete it, and return its
    value.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Peeking the top of the stack and clearing it
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To peek the element that is on the top of the stack we will use the following
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The behavior is like the peek method of the array-based implementation. In case
    the stack is empty, it will return `undefined`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'And to clear the stack, we can simply reset it to the same values we initialized
    the class with:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating the toString method
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the `toString` method for the object-based Stack class, we will use
    the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the stack is empty, we can return a message or `{}` (whichever is your preference).
    Next, we will transform the first element into a string (`{1}`) – this is in case
    the stack only has one element or so we do not need to append a comma at the end
    of the string. Next, we will iterate through all the elements (`{2}`) by using
    the `#count` property (that also works as a key within our `#items` object). For
    each additional element, we will append a comma, followed by the string version
    of the element (`{3}`). Since we need to stringify the first element and all the
    subsequent elements of the stack, instead of duplicating the code, we can create
    another method (`{4}`) that will transform an element into a string (this is the
    same logic we used in the array-based version). By prefixing the method with hash
    (`#`), JavaScript will not expose this method and it will not be available to
    be used outside this class (it is a private method).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈为空，我们可以返回一个消息或 `{}`（根据您的偏好）。接下来，我们将第一个元素转换为字符串 (`{1}`) – 这是在栈只有一个元素或我们不需要在字符串末尾添加逗号的情况下。接下来，我们将通过使用
    `#count` 属性（它也在我们的 `#items` 对象中作为键）迭代所有元素 (`{2}`)。对于每个额外的元素，我们将添加一个逗号，然后是元素的字符串版本
    (`{3}`)。由于我们需要将栈的第一个元素和所有后续元素转换为字符串，而不是重复代码，我们可以创建另一个方法 (`{4}`) 来将元素转换为字符串（这是我们在基于数组的版本中使用的相同逻辑）。通过在方法前加上哈希
    (`#`) 前缀，JavaScript 不会公开此方法，并且它将不可用于在类外部使用（这是一个私有方法）。
- en: Comparing object-based approach with array-based stack
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较基于对象的实现与基于数组的栈
- en: The time complexity of all methods for the object-based `Stack` class is constant
    time (*O(1)*) as we can access any element directly. The only method that is linear
    time (*O(n)*) is the `toString` method as we need to iterate through all the elements
    of the stack, where *n* is the stack size.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于对象的 `Stack` 类的所有方法，时间复杂度都是常数时间 (*O(1)*)，因为我们可以直接访问任何元素。唯一一个线性时间 (*O(n)*)
    的方法是 `toString` 方法，因为我们需要遍历栈中的所有元素，其中 *n* 是栈的大小。
- en: If we compare our array-based versus our object-based implementation, which
    one do you think is the best one?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将基于数组的实现与基于对象的实现进行比较，你认为哪一个更好？
- en: 'Let''s review both approaches:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这两种方法：
- en: '*Performance*: Both implementations have similar Big O complexities for most
    operations. However, array-based stacks might have a slight edge in overall performance
    due to potential resizing issues with object-based stacks.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能*：这两种实现对于大多数操作都具有相似的 Big O 复杂度。然而，由于基于对象的栈可能存在潜在的调整大小问题，基于数组的栈在整体性能上可能略有优势。'
- en: '*Element access*: Array-based stacks offer efficient random access by index,
    which can be useful in some scenarios. In some real-world examples, such as the
    undo feature, if the user wants to undo multiple steps at once, you can quickly
    access the relevant change based on its position in the stack using an index (in
    this case, the stack is not so strict to the LIFO behavior). If the stack operations
    primarily consist of pushing, popping, and peeking at the top element, then random
    access might not be a significant factor.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*元素访问*：基于数组的栈通过索引提供高效的随机访问，这在某些场景中可能很有用。在一些现实世界的例子中，例如撤销功能，如果用户想要一次性撤销多个步骤，可以根据其在栈中的位置快速访问相关更改（在这种情况下，栈对
    LIFO 行为不是那么严格）。如果栈操作主要是由推送、弹出和查看顶部元素组成，那么随机访问可能不是一个重要的因素。'
- en: '*Order*: If maintaining strict order of elements is important, array-based
    stacks are the preferred choice.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*顺序*：如果保持元素严格顺序很重要，基于数组的栈是首选选择。'
- en: '*Memory*: Array-based stacks are generally more memory-efficient.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存*：基于数组的栈通常更节省内存。'
- en: For most use cases involving stacks, the array-based implementation is generally
    recommended due to its order preservation, efficient access, and better memory
    usage. The object-based implementation might be considered in situations where
    order is not crucial, and you need a simple, straightforward implementation for
    basic stack operations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及栈的大多数用例，基于数组的实现通常推荐，因为它保留了顺序、高效的访问和更好的内存使用。在顺序不是关键，并且需要简单直接的基本栈操作实现的情况下，可以考虑基于对象的实现。
- en: Creating the Stack class using TypeScript
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TypeScript 创建 Stack 类
- en: 'As discussed previously in this book, using TypeScript to create a data structure
    API like our Stack class offers several significant advantages over plain JavaScript,
    such as:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书之前所述，使用 TypeScript 创建类似于我们的 Stack 类的数据结构 API 相比于纯 JavaScript 有几个显著的优势，例如：
- en: 'Enhanced type safety: early error detection with static typing catches type-related
    errors during development, preventing them from causing runtime failures. This
    is crucial when building APIs (such as our Stack class) that others will consume,
    as it helps ensure correct usage.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explicit contracts: TypeScript''s interfaces and type aliases let us define
    the exact structure and types of the data our stack will hold, making it easier
    for others to understand how to interact with it.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generics: We can make the Stack class more versatile by using generics to specify
    the type of data it will store. This allows for type-safe operations on various
    kinds of data (numbers, strings, objects, etc.).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Self-documenting code: TypeScript''s type annotations serve as built-in documentation,
    explaining the purpose of functions, parameters, and return values. This reduces
    the need for separate documentation and makes our code easier to understand.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s check how we can rewrite our Stack class using array-based implementation
    using TypeScript:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will use the generics (`{1}`) to make our class flexible. It can hold elements
    of any type (`T`), whether it''s numbers, strings, objects, or custom types. This
    is a major advantage over a JavaScript implementation as JavaScript allows mixed
    types of data in the data structure and by typing our Stack class, we are enforcing
    all elements will be of the same type (`{2}`). TypeScript also has a `private`
    keyword to declare private properties and methods. This feature became available
    years before JavaScript added the hash # prefix to allow private properties and
    methods.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The code inside the methods is the same as the JavaScript implementation. The
    advantage here is we can type any method arguments and their return type, facilitating
    reading the code with more ease.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The export (`{3}`) syntax follows the ECMAScript approach we reviewed earlier
    in this chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use this data structure in a separate file so we can test it,
    we can create another file (equivalent to the JavaScript file we created):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can create an enumerator to define all the types allowed in the text editor
    (`{4}`). This step is optional, but a good practice to avoid typo mistakes. Next,
    we can create an interface to define the type of the data our stack will store
    (`{5}`). Finally, when we instantiate the `Stack` data structure, we can type
    it to ensure all elements will be of the same type (`{6}`). The remaining sample
    code will be the same as in JavaScript.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the output of the example file, we can use the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `ts-node` package allows us to execute the TypeScript code without manually
    compiling it first. The output will be the same as the one in JavaScript.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems using stacks
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to use the `Stack` class, let's use it to solve some computer
    science problems. In this section, we will cover the decimal to binary problem,
    and we will also transform the algorithm into a base converter algorithm.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Converting decimal numbers to binary
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are already familiar with the decimal base. However, binary representation
    is particularly important in computer science, as everything in a computer is
    represented by binary digits (0 and 1).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely helpful when working with data storage for example. Computers
    store all information as binary digits. When we save a file, the decimal representation
    of each character or pixel is converted to binary before being stored on the hard
    drive or other storage media. Some file formats, like image files (.bmp, .png)
    and audio files (.wav), store data partially or entirely in binary format. Understanding
    binary conversion is crucial for working with these files at a low level. Another
    application are barcodes, which are essentially binary patterns of black and white
    lines that represent decimal numbers. Scanners decode these patterns back into
    decimals to identify products and other information.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a decimal number into a binary representation, we can divide the
    number by 2 (binary is a base 2 number system) until the division result is 0\.
    As an example, we will convert the number 10 into binary digits:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: A mathematical representation of converting the number 10 into
    binary digits](img/file21.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: A mathematical representation of converting the number 10 into
    binary digits'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'This conversion is one of the first things you learn in computer science classes.
    The decimal to binary algorithm is presented as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the provided code, as long as the quotient of the division is non-zero (line
    `{1}`), we calculate the remainder using the modulo operator (line `{2}`) and
    push it onto the stack (line {3}). We then update the dividend for the next iteration
    by dividing it by 2 and discarding any fractional part using `Math.floor` (line
    `{4}`). This is necessary because JavaScript does not distinguish between integers
    and floating-point numbers. Finally, we pop elements from the stack until it's
    empty (line `{5}`), concatenating them into a string to form the binary representation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call `decimalToBinary(13)`, here''s how the process would unfold:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 13 % 2 = 1 (remainder pushed onto stack); 13 / 2 = 6 (integer division)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6 % 2 = 0 (remainder pushed onto stack); 6 / 2 = 3
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3 % 2 = 1 (remainder pushed onto stack); 3 / 2 = 1
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1 % 2 = 1 (remainder pushed onto stack); 1 / 2 = 0 (loop terminates)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stack: [1, 1, 0, 1] (top to bottom)'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Popping from the stack and building the result string: "1101"'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The base converter algorithm
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can modify the previous algorithm to make it work as a converter from decimal
    to the bases between `2` and `36`. Instead of dividing the decimal number by 2,
    we can pass the desired base as an argument to the method and use it in the division
    operations, as shown in the following algorithm:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There is one more thing we need to change. In the conversion from decimal to
    binary, the remainders will be 0 or 1; in the conversion from decimal to octagonal,
    the remainders will be from 0 to 8; and in the conversion from decimal to hexadecimal,
    the remainders can be 0 to 9 plus the letters A to F (values 10 to 15). For this
    reason, we need to convert these values as well (lines `{6}` and `{7}`). So, starting
    at base 11, each letter of the alphabet will represent its base. The letter `A` represents
    base 11, `B` represents base 12, and so on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the previous algorithm and output its result as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And when could we use this algorithm in the real-world? This algorithm has
    many applications such as:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Hexadecimal (base 16): Web developers and graphic designers frequently use
    hexadecimal notation to represent colors in HTML, CSS, and other digital design
    tools. For example, the color white is represented as `#FFFFFF`, which is equivalent
    to the decimal value `16777215`. The `decimalToBase` algorithm could be used to
    convert color values between decimal and hexadecimal representations.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Base64 encoding: Base64 is a common encoding scheme used to represent binary
    data (images, audio, and so on) as text. It uses a 64-character alphabet (A-Z,
    a-z, 0-9, +, /) and converts binary data into base-64 representation for easier
    transmission over text-based protocols like email. We could enhance our algorithm
    to convert to a base-64 (use this as a challenge to try on your own, you will
    find the resolution in the source code of this book).'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shortened URLs or unique identifiers: Services like [bit.ly](https://bit.ly)
    generate shortened URLs that use a mix of alphanumeric characters. These shortened
    URLs often represent unique numeric identifiers that have been converted to a
    higher base (for example: base 62) to make them more compact.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also find the *Hanoi Tower* example when you download the source code
    of this book.
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will resolve a few array exercises from **LeetCode** using the concepts we
    learned in this chapter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Valid Parentheses
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first exercise we will resolve is the *20\. Valid Parentheses* problem available
    at [https://leetcode.com/problems/valid-parentheses/](https://leetcode.com/problems/valid-parentheses/).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `function isValid(s: string): boolean {}`, which
    receives a string it is expecting a boolean to be returned.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the sample input and expected output provided by the problem:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Input "()", output true.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input "()", output true.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input "(]", output false.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An input string is valid if:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Open brackets must be closed by the same type of brackets.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open brackets must be closed in the correct order.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every close bracket has a corresponding open bracket of the same type.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The problem also provides three hints, which contain the logic we need to implement
    to resolve this problem:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Use a stack of characters.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you encounter an opening bracket, push it to the top of the stack.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you encounter a closing bracket, check if the top of the stack was the
    opening for it. If yes, pop it from the stack. Otherwise, return false.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write the `isValid` function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code uses a stack data structure to keep track of the parentheses
    as provided in the hints (`{1}`). Although we are not using our own Stack class
    to resolve this problem, we learned we can use the array and apply the LIFO behavior
    by using the push and pop method from the JavaScript Array class. We also declared
    two arrays: `open` (`{2}`) and `close` (`{3}`), which contain the three types
    of opening and closing brackets, respectively. Then, we iterate over the string
    (`{4}`). If it encounters an opening bracket present in the `open` array (`{5}`),
    then it pushes it onto the stack. If it encounters a closing bracket present in
    the close array ((`{6}`)), it pops the last element from the stack (`{7}`) and
    checks if the popped opening bracket matches its respective closing bracket (`{8}`).
    After the loop, if the stack is empty (`{9}`), it means all opening brackets have
    been correctly matched with closing brackets, so the function returns `true`,
    otherwise if there are still elements left in the stack, it means there are unmatched
    opening brackets.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: This is solution that passes all the tests and resolves the problem. However,
    if this exercise is being used in technical interviews, the interviewer might
    ask you to try a different solution that does not include arrays to track the
    open and close brackets, after all, the *includes* method alone is of time complexity
    O(n) as it might iterate over the entire array, even though our array only contains
    three elements.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned in this chapter we can use JavaScript objects for key-value pairs
    as well. So, we can rewrite the `isValid` function using a JavaScript object to
    map the open and close brackets:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The logic is still the same, however, we can map the open brackets as keys and
    the close brackets as values (`{10}`). This allows us to directly access the elements
    within the object in lines `{11}` and `{12}`, avoiding iterating through the array.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of this function is *O(n)*, where *n* is the length of the
    string `s`. This is because the function iterates over the string `s` once, performing
    a constant amount of work for each character in the string (either pushing to
    the stack, popping from the stack, or comparing characters).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The space complexity is also *O(n)*, as in the worst-case scenario (when all
    characters are opening brackets), the function would push all characters into
    the stack.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of any optimizations we can apply to this algorithm?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Although our code is working, it can be further optimized by adding some validations
    for edge cases in the beginning of the algorithm:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The optimizations at the beginning of the function do not change the overall
    time complexity, as they are constant time operations. They may, however, improve
    the function's performance in certain scenarios by allowing it to exit early.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In algorithm challenges, competitions, and technical interviews, these optimizations
    are especially important. Optimizations like these demonstrate that you pay attention
    to detail and care about writing clean, efficient code. This can be a positive
    signal to potential employers. The ability to identify and implement these optimizations
    shows you can think critically about code efficiency and have a good understanding
    of the problem's constraints. Interviewers often value this ability as it demonstrates
    a deeper understanding of algorithms and data structures.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Min Stack
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next exercise we will resolve is the *155\. Min Stack*, available at [https://leetcode.com/problems/min-stack](https://leetcode.com/problems/min-stack).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: This is a design problem that asks you to design a stack that supports push,
    pop, top, and retrieving the minimum element in constant time. The problem also
    states that you must implement a solution with *O(1)* time complexity for each
    function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: We have already designed the Stack class in this chapter (the `top` method is
    our `peek` method). What we need to do is keep track of the minimum element in
    the stack.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample input that is given is:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '["MinStack","push","push","push","getMin","pop","top","getMin"]'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[[],[-2],[0],[-3],[],[],[],[]]'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the explanation given is:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s review the MinStack design as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To be able to return the minimum element of the stack in constant time, we also
    need to track the minimum value. There are different ways of achieving this, and
    the first approach chosen is to also keep a `minStack` to track the minimum values
    (`{1}`).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The `push` method takes a number `x` as an argument and pushes it onto the stack.
    Then checks if `minStack` is empty or if `x` is less than or equal to the current
    minimum element (which is the last element in `minStack`). If either condition
    is `true`, `x` is also pushed onto `minStack`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The `pop` method removes the top element from stack and assigns it to `x`. If
    `x` is equal to the current minimum element (again, the last element in `minStack`),
    it also removes the top element from `minStack`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The `top` method has the same implementation as our `peek` method. The `getMin`
    method is the same as doing a peek into the `minStack`, which always holds the
    minimum element of the current state of the stack on its top.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: A different approach would be to track the minimum element in a variable instead
    of a stack. We would initialize its value `min= +Infinity` with the biggest numeric
    value in JavaScript, inside the `push` method, we would update its value every
    time a new element is added to the stack (`this.min = Math.min(val, this.min)`)
    and inside the pop method, we would also update the minimum value if the same
    is being removed from the stack (`if (this.min === val) this.min = Math.min(...this.stack)`).
    And for the `getMin` method, we would simply return `this.min`. However, in this
    approach, the pop method would have *O(n)* because it uses `Math.min(...this.stack)`
    to find the new minimum every time an element is popped as this operation requires
    iterating over the entire stack, so it is not necessarily a better solution.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是跟踪变量中的最小元素而不是栈。我们会在`push`方法中将其初始化为`min= +Infinity`，这是JavaScript中最大的数值，每次向栈中添加新元素时，我们会更新其值（`this.min
    = Math.min(val, this.min)`），在`pop`方法中，如果从栈中移除相同的元素，我们也会更新最小值（`if (this.min ===
    val) this.min = Math.min(...this.stack)`）。而对于`getMin`方法，我们只需简单地返回`this.min`。然而，在这种方法中，`pop`方法的时间复杂度会是*O(n)*，因为它每次弹出元素时都会使用`Math.min(...this.stack)`来找到新的最小值，这个操作需要遍历整个栈，所以这并不一定是更好的解决方案。
- en: You will also find the *77\. Simplify Path* problem resolution when you download
    the source code of this book.
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你下载这本书的源代码时，你也会找到*第77题 简化路径*的解决方案。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the fundamental stack data structure. We implemented
    our own stack algorithms using both arrays and JavaScript objects, mastering how
    to efficiently add and remove elements with the `push` and `pop` methods.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了基本栈数据结构。我们使用数组和JavaScript对象实现了自己的栈算法，掌握了如何使用`push`和`pop`方法高效地添加和移除元素。
- en: We explored and compared diverse implementations of the Stack class, weighing
    factors like memory usage, performance, and order preservation to arrive at a
    well-informed recommendation for practical use cases. We have also reviewed the
    implementation of the Stack class using TypeScript and its benefits.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索并比较了Stack类的不同实现，权衡了内存使用、性能和顺序保持等因素，为实际用例提供了明智的建议。我们还审查了使用TypeScript实现的Stack类及其优点。
- en: Beyond implementation, we tackled renowned computer science problems using stacks
    and dissected exercises commonly encountered in technical interviews, analyzing
    their time and space complexities.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是实现，我们还使用栈解决了著名的计算机科学问题，并剖析了在技术面试中常见的一些练习题，分析了它们的时间和空间复杂度。
- en: In the next chapter, we'll shift our focus to queues, a closely related data
    structure that operates on a different principle than the LIFO (Last In, First
    Out) model that governs stacks.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把重点转向队列，这是一种与栈紧密相关的数据结构，它的工作原理与控制栈的LIFO（后进先出）模型不同。
