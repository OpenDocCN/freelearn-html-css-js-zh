- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Creational Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: 'A design pattern is a reusable solution to a recurring problem. The term is
    really broad in its definition and can span multiple domains of an application.
    However, the term is often associated with a well-known set of object-oriented
    patterns that were popularized in the 90s by the book, *Design Patterns: Elements
    of Reusable Object-Oriented Software*, *Pearson Education*, by the almost legendary **Gang
    of Four** (**GoF**): Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.
    We will often refer to these specific sets of patterns as *traditional* design
    patterns or GoF design patterns.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是对重复性问题的一种可重用解决方案。这个术语在定义上非常广泛，可以跨越应用程序的多个领域。然而，这个术语通常与90年代由几乎传奇的**四人帮**（**GoF**）在《设计模式：可复用面向对象软件元素》一书中普及的知名面向对象模式相关联：Erich
    Gamma、Richard Helm、Ralph Johnson和John Vlissides。我们通常会把这些特定的模式集称为**传统**设计模式或GoF设计模式。
- en: Applying this set of object-oriented design patterns in JavaScript is not as
    linear and formal as it would be in a classical object-oriented language. As we
    know, JavaScript is object-oriented, prototype-based, and has dynamic typing.
    It also treats functions as first-class citizens and allows functional programming
    styles. These characteristics make JavaScript a very versatile language, which
    gives tremendous power to the developer but at the same time, it causes fragmentation
    of programming styles, conventions, techniques, and ultimately the patterns of
    its ecosystem. With JavaScript, there are so many ways to achieve the same result
    that each developer has their own opinion on what's the best way to approach a
    problem. A clear demonstration of this phenomenon is the abundance of frameworks
    and opinionated libraries in the JavaScript ecosystem; probably no other language
    has ever seen so many, especially now that Node.js has given new astonishing possibilities
    to JavaScript and has created so many new scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中应用这组面向对象设计模式并不像在经典面向对象语言中那样线性化和正式。正如我们所知，JavaScript是面向对象、基于原型的，并且具有动态类型。它还将函数视为一等公民，并允许函数式编程风格。这些特性使JavaScript成为一种非常灵活的语言，为开发者提供了巨大的力量，但同时也导致了编程风格、约定、技术和最终其生态系统模式的碎片化。使用JavaScript，有如此多的方式可以达到相同的结果，以至于每个开发者都有自己的观点，认为这是解决问题的关键方法。这一现象的明显表现是JavaScript生态系统中框架和有偏见的库的丰富性；可能没有其他语言曾经见过这么多，尤其是在Node.js为JavaScript带来了新的惊人可能性并创造了如此多的新场景之后。
- en: In this context, the nature of JavaScript affects traditional design patterns
    too. There are so many ways in which traditional design patterns can be implemented
    in JavaScript that the traditional, strongly object-oriented implementation stops
    being relevant.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，JavaScript的本质也影响了传统设计模式。在JavaScript中实现传统设计模式的方式有很多，以至于传统的强面向对象实现不再相关。
- en: In some cases, the traditional implementation of these design patterns is not
    even possible because JavaScript, as we know, doesn't have *real* classes or abstract
    interfaces. What doesn't change, though, is the original idea at the base of each
    pattern, the problem it solves, and the concepts at the heart of the solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这些设计模式的传统实现甚至是不可能的，因为正如我们所知，JavaScript没有真正的类或抽象接口。然而，每个模式背后的原始想法、它解决的问题以及解决方案的核心概念并没有改变。
- en: In this chapter and in the two that follow, we will see how some of the most
    important GoF design patterns apply to Node.js and its philosophy, thus rediscovering
    their importance from another perspective. Among these traditional patterns, we
    will also have a look at some "less traditional" design patterns born from within
    the JavaScript ecosystem itself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及接下来的两章中，我们将看到一些最重要的GoF设计模式如何应用于Node.js及其哲学，从而从另一个角度重新发现它们的重要性。在这些传统模式中，我们还将探讨一些从JavaScript生态系统本身诞生的“不那么传统”的设计模式。
- en: In this chapter, in particular, we'll take a look at a class of design patterns
    called **creational**. As the name suggests, these patterns address problems related
    to the creation of objects. For example, the *Factory* pattern allows us to encapsulate
    the creation of an object within a function. The *Revealing Constructor* pattern
    allows us to expose private object properties and methods only during the object's
    creation, while the *Builder* pattern simplifies the creation of complex objects.
    Finally, the *Singleton* pattern and the *Dependency Injection* pattern help us
    with wiring the modules within our applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将特别探讨一类称为**创建型**的设计模式。正如其名称所暗示的，这些模式解决与对象创建相关的问题。例如，*工厂*模式允许我们将对象的创建封装在一个函数中。*揭示构造函数*模式允许我们在对象创建期间仅公开私有对象属性和方法，而*建造者*模式简化了复杂对象的创建。最后，*单例*模式和*依赖注入*模式帮助我们连接应用程序内部的模块。
- en: This chapter, as well as the following two, assume that you have some notion
    of how inheritance works in JavaScript. Please also be advised that we will often
    use generic and more intuitive diagrams to describe a pattern in place of standard
    UML. This is because many patterns can have an implementation based not only on
    classes but also on objects and even functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及接下来的两章假设您已经对JavaScript中的继承机制有所了解。同时，请被告知，我们通常会使用通用且更直观的图表来描述模式，而不是使用标准的UML图。这是因为许多模式不仅可以在类的基础上实现，还可以在对象甚至函数的基础上实现。
- en: Factory
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: We'll begin our journey from one of the most common design patterns in Node.js: **Factory**.
    As you will see, the Factory pattern is very versatile and has more than just
    one purpose. Its main advantage is its ability to decouple the creation of an
    object from one particular implementation. This allows us, for example, to create
    an object whose class is determined at runtime. Factory also allows us to expose
    "a surface area" that is much smaller than that of a class; a class can be extended
    or manipulated, while a factory, being just a function, offers fewer options to
    the user, making it more robust and easier to understand. Finally, a factory can
    also be used to enforce encapsulation by leveraging closures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Node.js中最常见的设计模式之一开始：**工厂**。正如您将看到的，工厂模式非常灵活，不仅仅只有一个用途。其主要优势在于它能够将对象的创建与特定的实现解耦。这使得我们能够创建在运行时确定类的对象。工厂还允许我们暴露比类更小的“表面区域”；类可以被扩展或操作，而工厂作为一个函数，提供给用户的选择更少，使其更健壮且更容易理解。最后，工厂还可以通过利用闭包来强制执行封装。
- en: Decoupling object creation and implementation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解耦对象创建和实现
- en: We already stressed the fact that, in JavaScript, the functional paradigm is
    often preferred to a purely object-oriented design for its simplicity, usability,
    and *small surface area*. This is especially true when creating new object instances.
    In fact, invoking a factory, instead of directly creating a new object from a
    class using the `new` operator or `Object.create()`, is so much more convenient
    and flexible in several respects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经强调过，在JavaScript中，函数式范式通常比纯面向对象设计更受欢迎，因为它简单、易用，且*表面区域小*。这在创建新对象实例时尤其如此。实际上，调用工厂，而不是使用`new`运算符或`Object.create()`直接从类创建新对象，在许多方面都更加方便和灵活。
- en: 'First and foremost, a factory allows us to *separate the creation of an object
    from its implementation*. Essentially, a factory wraps the creation of a new instance,
    giving us more flexibility and control in the way we do it. Inside the factory,
    we can choose to create a new instance of a class using the `new` operator, or
    leverage closures to dynamically build a stateful object literal, or even return
    a different object type based on a particular condition. The consumer of the factory
    is totally agnostic about how the creation of the instance is carried out. The
    truth is that, by using `new`, we are binding our code to one specific way of
    creating an object, while with a factory, we can have much more flexibility, almost
    for free. As a quick example, let''s consider a simple factory that creates an `Image` object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，工厂允许我们 *将对象的创建与其实现分离*。本质上，工厂封装了新实例的创建，使我们能够在创建方式上拥有更多的灵活性和控制。在工厂内部，我们可以选择使用
    `new` 操作符创建一个新实例，或者利用闭包动态构建一个具有状态的字面量对象，甚至根据特定条件返回不同的对象类型。工厂的消费者对实例的创建方式一无所知。事实是，通过使用
    `new`，我们使代码绑定到一种特定的对象创建方式，而使用工厂，我们可以获得几乎免费的更多灵活性。作为一个快速示例，让我们考虑一个简单的工厂，它创建一个 `Image`
    对象：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `createImage()` factory might look totally unnecessary; why not instantiate
    the `Image` class by using the `new` operator directly? Why not write something
    like the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`createImage()` 工厂可能看起来完全没有必要；为什么不直接使用 `new` 操作符实例化 `Image` 类呢？为什么不写点像下面这样的东西呢？'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we already mentioned, using `new` binds our code to one particular type of
    object, which in the preceding case is to the `Image` object type. A factory,
    on the other hand, gives us much more flexibility. Imagine that we want to refactor
    the `Image` class, splitting it into smaller classes, one for each image format
    that we support.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用 `new` 关键字将我们的代码绑定到一种特定的对象类型上，在前面的例子中是绑定到 `Image` 对象类型。另一方面，工厂（factory）提供了更大的灵活性。想象一下，如果我们想要重构
    `Image` 类，将其拆分成更小的类，每个类对应我们支持的每种图像格式。
- en: 'If we exposed a factory as the only means to create new images, we could simply
    rewrite it as follows, without breaking any of the existing code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将工厂作为创建新图像的唯一方式公开，我们可以简单地按照以下方式重写它，而不会破坏任何现有代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our factory also allows us to keep the classes hidden and prevents them from
    being extended or modified (remember the principle of small surface area?). In
    JavaScript, this can be achieved by exporting only the factory, while keeping
    the classes private.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工厂还允许我们隐藏类，并防止它们被扩展或修改（记住小表面面积原则？）。在 JavaScript 中，这可以通过仅导出工厂，同时保持类为私有来实现。
- en: A mechanism to enforce encapsulation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种强制封装的机制
- en: A factory can also be used as an **encapsulation** mechanism, thanks to closures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于闭包，工厂也可以用作 **封装** 机制。
- en: Encapsulation refers to controlling the access to some internal details of a
    component by preventing external code from manipulating them directly. The interaction
    with the component happens only through its public interface, isolating the external
    code from the changes in the implementation details of the component. Encapsulation
    is a fundamental principle of object-oriented design, together with inheritance,
    polymorphism, and abstraction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 封装（Encapsulation）指的是通过阻止外部代码直接操作某些组件的内部细节来控制对这些细节的访问。与组件的交互仅通过其公共接口进行，将外部代码与组件实现细节的变化隔离开来。封装是面向对象设计的基本原则之一，与继承、多态和抽象并列。
- en: 'In JavaScript, one of the main ways to enforce encapsulation is through function
    scopes and closures. A factory makes it straightforward to enforce private variables.
    Consider the following, for example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，强制封装的主要方法之一是通过函数作用域和闭包。工厂使得强制私有变量变得简单直接。例如，考虑以下内容：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we leverage a closure to create two objects: a `person` object,
    which represents the public interface returned by the factory, and a group of `privateProperties` that
    are inaccessible from the outside and that can be manipulated only through the
    interface provided by the `person` object. For example, in the preceding code,
    we make sure that a person''s `name` is never empty; this would not be possible
    to enforce if `name` was just a normal property of the `person` object.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们利用闭包创建了两个对象：一个代表工厂返回的公共接口的`person`对象，以及一组不可从外部访问且只能通过`person`对象提供的接口进行操作的`privateProperties`。例如，在前面的代码中，我们确保一个人的`name`永远不会为空；如果`name`只是`person`对象的一个普通属性，那么这种强制措施将不可能实现。
- en: 'Using closures is not the only technique that we have for enforcing encapsulation.
    In fact, other possible approaches are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包并不是我们用来强制封装的唯一技术。实际上，还有其他可能的方法：
- en: Using private class fields (the hashbang `#` prefix syntax), introduced in Node.js
    12\. More on this at [nodejsdp.link/tc39-private-fields](http://nodejsdp.link/tc39-private-fields).
    This is the most modern approach, but at the time of writing, the feature is still
    experimental and has yet to be included in the official ECMAScript specification.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js 12中引入的私有类字段（hashbang `#` 前缀语法）。更多关于这个话题的信息请参阅：[nodejsdp.link/tc39-private-fields](http://nodejsdp.link/tc39-private-fields)。这是最现代的方法，但在撰写本文时，该功能仍然是实验性的，并且尚未包含在官方ECMAScript规范中。
- en: Using WeakMaps. More on this at [nodejsdp.link/weakmaps-private](http://nodejsdp.link/weakmaps-private).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WeakMaps。更多关于这个话题的信息请参阅：[nodejsdp.link/weakmaps-private](http://nodejsdp.link/weakmaps-private)。
- en: 'Using symbols, as explained in the following article: [nodejsdp.link/symbol-private](http://nodejsdp.link/symbol-private).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如下文章中解释的，使用符号：[nodejsdp.link/symbol-private](http://nodejsdp.link/symbol-private)。
- en: 'Defining private variables in a constructor (as recommended by Douglas Crockford:
    [nodejsdp.link/crockford-private](http://nodejsdp.link/crockford-private)). This
    is the legacy but also the best-known approach.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数中定义私有变量（如Douglas Crockford所推荐：[nodejsdp.link/crockford-private](http://nodejsdp.link/crockford-private)）。这是传统但也是最知名的方法。
- en: Using conventions, for example, prefixing the name of a property with an underscore
    "`_`". However, this does not technically prevent a member from being read or
    modified from the outside.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用约定，例如，将属性名前缀为下划线"`_`"。然而，这从技术上讲并不能阻止成员被外部读取或修改。
- en: Building a simple code profiler
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个简单的代码分析器
- en: 'Now, let''s work on a complete example using a factory. Let''s build a simple *code
    profiler*, an object with the following properties:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个工厂来构建一个完整的示例。让我们构建一个简单的代码分析器，一个具有以下属性的对象：
- en: A `start()` method that triggers the start of a profiling session
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个触发分析会话开始的`start()`方法
- en: An `end()` method to terminate the session and log its execution time to the console
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`end()`方法来终止会话并将执行时间记录到控制台
- en: 'Let''s start by creating a file named `profiler.js`, which will have the following
    content:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`profiler.js`的文件开始，该文件将包含以下内容：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Profiler` class we just defined uses the default high resolution timer
    of Node.js to save the current time when `start()` is invoked, and then calculate
    the elapsed time when `end()` is executed, printing the result to the console.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义的`Profiler`类使用Node.js的默认高分辨率计时器在`start()`被调用时保存当前时间，然后在`end()`执行时计算经过的时间，并将结果打印到控制台。
- en: Now, if we are going to use such a profiler in a real-world application to calculate
    the execution time of different routines, we can easily imagine the huge amount
    of profiling information printed to the console, especially in a production environment.
    What we may want to do instead is redirect the profiling information to another
    source, for example, a dedicated log file, or alternatively, disable the profiler
    altogether if the application is running in production mode. It's clear that if
    we were to instantiate a `Profiler` object directly by using the `new` operator,
    we would need some extra logic in the client code or in the `Profiler` object
    itself in order to switch between the different logics.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打算在现实世界的应用程序中使用这样的分析器来计算不同例程的执行时间，我们可以很容易地想象出大量分析信息被打印到控制台，尤其是在生产环境中。我们可能想要做的是将分析信息重定向到另一个来源，例如，一个专门的日志文件，或者如果应用程序以生产模式运行，可以选择完全禁用分析器。很明显，如果我们直接使用`new`运算符实例化`Profiler`对象，我们将在客户端代码或`Profiler`对象本身中需要一些额外的逻辑来在不同的逻辑之间切换。
- en: 'Alternatively, we can use a factory to abstract the creation of the `Profiler` object
    so that, depending on whether the application runs in production or development
    mode, we can return a fully working `Profiler` instance or a mock object with
    the same interface but with empty methods. This is exactly what we are going to
    do in our `profiler.js` module. Instead of exporting the `Profiler` class, we
    will export only our factory. The following is its code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用工厂来抽象`Profiler`对象的创建，这样，根据应用程序是否在生产模式下运行，我们可以返回一个完全工作的`Profiler`实例或具有相同接口但方法为空的模拟对象。这正是我们将在`profiler.js`模块中做的。我们不会导出`Profiler`类，而是只导出我们的工厂。以下是其代码：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `createProfiler()` function is our factory and its role is abstracting the
    creation of a `Profiler` object from its implementation. If the application is
    running in production mode, we return `noopProfiler`, which essentially doesn't
    do anything, effectively disabling any profiling. If the application is not running
    in production mode, then we create and return a new, fully functional `Profiler` instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`createProfiler()`函数是我们的工厂，其作用是抽象`Profiler`对象的创建与其实现。如果应用程序在生产模式下运行，我们返回`noopProfiler`，它实际上什么也不做，有效地禁用了任何分析。如果应用程序不在生产模式下运行，那么我们将创建并返回一个新的、完全功能的`Profiler`实例。'
- en: Thanks to JavaScript's dynamic typing, we were able to return an object instantiated
    with the `new` operator in one circumstance and a simple object literal in the
    other (this is also known as **duck typing**, and you can read more about it at
    [nodejsdp.link/duck-typing](http://nodejsdp.link/duck-typing)). This confirms
    how we can create objects in any way we like inside the factory function. We could
    also execute additional initialization steps or return a different type of object
    based on particular conditions, all of this while isolating the consumer of the
    object from all these details. We can easily understand the power of this simple
    pattern.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了JavaScript的动态类型，我们能够在一种情况下使用`new`运算符返回一个对象，在另一种情况下返回一个简单的对象字面量（这也被称为**鸭子类型**，你可以在[nodejsdp.link/duck-typing](http://nodejsdp.link/duck-typing)上了解更多关于它的信息）。这证实了我们在工厂函数内部可以以任何我们喜欢的方式创建对象。我们还可以根据特定条件执行额外的初始化步骤或返回不同类型的对象，同时将对象的使用者与所有这些细节隔离开来。我们可以轻松理解这种简单模式的力量。
- en: 'Now, let''s play with our profiler factory a bit. Let''s create an algorithm
    to calculate all the factors of a given number and use our profiler to record
    its running time:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微玩一下我们的分析器工厂。让我们创建一个算法来计算给定数字的所有因子，并使用我们的分析器来记录其运行时间：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `profiler` variable contains our `Profiler` object, whose implementation
    will be decided by the `createProfiler()` factory at runtime, based on the `NODE_ENV`
    environment variable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`profiler`变量包含我们的`Profiler`对象，其实现将由运行时的`createProfiler()`工厂根据`NODE_ENV`环境变量来决定。'
- en: 'For example, if we run the module in production mode, we will get no profiling
    information:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们以生产模式运行模块，我们将不会得到任何分析信息：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While if we run the module in development mode, we will see the profiling information
    printed to the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在开发模式下运行模块时，我们会看到分析信息被打印到控制台：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The example that we just presented is just a simple application of the factory
    function pattern, but it clearly shows the advantages of separating an object's
    creation from its implementation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才展示的例子只是工厂函数模式的一个简单应用，但它清楚地显示了将对象的创建与其实现分离的优势。
- en: In the wild
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: As we said, factories are very common in Node.js. We can find one example in
    the popular *Knex* ([nodejsdp.link/knex](http://nodejsdp.link/knex)) package.
    Knex is a SQL query builder that supports multiple databases. Its package exports
    just a function, which is a factory. The factory performs various checks, selects
    the right dialect object to use based on the database engine, and finally creates
    and returns the Knex object. Take a look at the code at [nodejsdp.link/knex-factory](http://nodejsdp.link/knex-factory).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，工厂在Node.js中非常常见。我们可以在流行的*Knex* ([nodejsdp.link/knex](http://nodejsdp.link/knex))
    包中找到一个例子。Knex是一个支持多个数据库的SQL查询构建器。它的包只导出一个函数，这是一个工厂。工厂执行各种检查，根据数据库引擎选择正确的方言对象来使用，并最终创建并返回Knex对象。查看[nodejsdp.link/knex-factory](http://nodejsdp.link/knex-factory)中的代码。
- en: Builder
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建者
- en: Builder is a creational design pattern that simplifies the creation of complex
    objects by providing a fluent interface, which allows us to build the object step
    by step. This greatly improves the readability and the general developer experience
    when creating such complex objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Builder是一种创建型设计模式，通过提供流畅的接口简化了复杂对象的创建，允许我们逐步构建对象。这大大提高了创建此类复杂对象的可读性和开发者体验。
- en: The most apparent situation in which we could benefit from the Builder pattern
    is a class with a constructor that has a long list of arguments, or takes many
    complex parameters as input. Usually, these kinds of classes require so many parameters
    in advance because all of them are necessary to build an instance that is complete
    and in a consistent state, so it's necessary to take this into account when considering
    potential solutions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从Builder模式中受益的最明显的情况是，一个构造函数具有长列表的参数，或者接受许多复杂参数作为输入的类。通常，这类类需要预先设置许多参数，因为所有这些参数都是构建一个完整且一致状态的实例所必需的，因此在考虑潜在解决方案时必须考虑这一点。
- en: 'So, let''s see the general structure of the pattern. Imagine having a `Boat`
    class with a constructor such as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看该模式的一般结构。想象一下有一个`Boat`类，其构造函数如下所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Invoking such a constructor would create some hard to read code, which is easily
    prone to errors (which argument is what?). Take the following code, for example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这样的构造函数将生成一些难以阅读的代码，这些代码很容易出错（哪个参数是什么？）。以下代码为例：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A first step to improve the design of this constructor is to aggregate all
    arguments in a single object literal, such as the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 改进此构造函数设计的第一步是将所有参数聚合到一个单一的对象字面量中，如下所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can note from the previous code, this new constructor is indeed much
    better than the original one as it allows us to clearly see what is the parameter
    that receives each value. However, we can do even better than this. One drawback
    of using a single object literal to pass all inputs at once is that the only way
    to know what the actual inputs are is to look at the class documentation or, even
    worse, into the code of the class. In addition to that, there is no enforced protocol
    that guides the developers toward the creation of a coherent class. For example,
    if we specify `hasMotor: true`, then we are required to also specify a `motorCount`,
    a `motorBrand,` and a `motorModel`, but there is nothing in this interface that
    conveys this information to us.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们从之前的代码中可以注意到的，这个新的构造函数确实比原来的好，因为它允许我们清楚地看到每个参数接收的是什么值。然而，我们可以做得更好。使用单一对象字面量一次性传递所有输入的一个缺点是，唯一知道实际输入的方式是查看类文档，或者更糟糕的是，查看类的代码。除此之外，没有强制性的协议指导开发者创建一个连贯的类。例如，如果我们指定`hasMotor:
    true`，那么我们还需要指定`motorCount`、`motorBrand`和`motorModel`，但这个接口中没有传达这种信息给我们。'
- en: 'The Builder pattern fixes even these last few flaws and provides a fluent interface
    that is simple to read, self-documenting, and that provides guidance toward the
    creation of a coherent object. Let''s take a look at the `BoatBuilder` class,
    which implements the Builder pattern for the `Boat` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Builder模式甚至修复了这些最后的几个缺陷，并提供了一个简单易读、自我文档化的流畅接口，它为创建一个连贯的对象提供了指导。让我们看看`BoatBuilder`类，它实现了`Boat`类的Builder模式：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To fully appreciate the positive impact that the Builder pattern has on the
    way we create our `Boat` objects, let''s see an example of that:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分欣赏Builder模式对我们创建`Boat`对象方式产生的积极影响，让我们看看一个示例：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, the role of our `BoatBuilder` class is to collect all the parameters
    needed to create a `Boat` using some helper methods. We usually have a method
    for each parameter or set of related parameters, but there is not an exact rule
    to that. It is down to the designer of the Builder class to decide the name and
    behavior of each method responsible for collecting the input parameters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的`BoatBuilder`类的角色是收集创建`Boat`所需的所有参数，使用一些辅助方法。我们通常有一个方法用于每个参数或相关参数集，但并没有一个确切的规定。这取决于Builder类的设计者来决定每个负责收集输入参数的方法的名称和行为。
- en: 'We can instead summarize some general rules for implementing the Builder pattern,
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结一些实现Builder模式的一般规则，如下所示：
- en: The main objective is to break down a complex constructor into multiple, more
    readable, and more manageable steps.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要目标是把复杂的构造函数分解成多个更易读、更易管理的步骤。
- en: Try to create builder methods that can set multiple related parameters at once.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建可以一次性设置多个相关参数的建造者方法。
- en: Deduce and implicitly set parameters based on the values received as input by
    a setter method, and in general, try to encapsulate as much parameter setting
    related logic into the setter methods so that the consumer of the builder interface
    is free from doing so.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据接收到的setter方法输入的值推断并隐式设置参数，并且通常尝试将尽可能多的参数设置相关逻辑封装到setter方法中，以便建造者接口的消费者可以免于这样做。
- en: If necessary, it's possible to further manipulate the parameters (for example,
    type casting, normalization, or extra validation) before passing them to the constructor
    of the class being built to simplify the work left to do by the builder class
    consumer even more.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，可以在将参数传递给正在构建的类的构造函数之前进一步操作这些参数（例如，类型转换、归一化或额外验证），以进一步简化建造者类消费者剩余的工作。
- en: In JavaScript, the Builder pattern can also be applied to invoke functions,
    not just to build objects using their constructor. In fact, from a technical point
    of view, the two scenarios are almost identical. The major difference when dealing
    with functions is that instead of having a `build()` method, we would have an
    `invoke()` method that invokes the complex function with the parameters collected
    by the builder object and returns any eventual result to the caller.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，建造者模式不仅可以应用于调用函数，而不仅仅是使用构造函数来构建对象。实际上，从技术角度来看，这两种场景几乎是相同的。处理函数时的主要区别是，我们不会有一个
    `build()` 方法，而会有一个 `invoke()` 方法，它使用建造者对象收集的参数调用复杂的函数，并将任何最终结果返回给调用者。
- en: Next, we will work on a more concrete example that makes use of the Builder
    pattern we've just learned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个更具体的例子来应用我们刚刚学到的建造者模式（Builder pattern）。
- en: Implementing a URL object builder
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现URL对象建造者
- en: We want to implement a `Url` class that can hold all the components of a standard
    URL, validate them, and format them back into a string. This class in going to
    be intentionally simple and minimal, so for standard production use, we recommend
    the built-in `URL` class ([nodejsdp.link/docs-url](http://nodejsdp.link/docs-url)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望实现一个 `Url` 类，它可以保存标准URL的所有组件，验证它们，并将它们格式化回字符串。这个类将故意保持简单和最小化，因此对于标准的生产使用，我们建议使用内置的
    `URL` 类 ([nodejsdp.link/docs-url](http://nodejsdp.link/docs-url))。
- en: 'Now, let''s implement our custom `Url` class in a file called `url.js`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在名为 `url.js` 的文件中实现我们的自定义 `Url` 类：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A standard URL is made of several components, so to take them all in, the `Url`
    class'' constructor is inevitably big. Invoking such a constructor can be a challenge,
    as we have to keep track of the argument position to know what component of the
    URL we are passing. Take a look at the following example to get an idea of this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 标准URL由多个组件组成，因此为了包含所有这些组件，`Url` 类的构造函数不可避免地会很大。调用这样的构造函数可能是一个挑战，因为我们必须跟踪参数的位置，以知道我们正在传递URL的哪个组件。看看以下示例以了解这一点：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the perfect situation for applying the Builder pattern we just learned.
    Let''s do that now. The plan is to create a `UrlBuilder` class, which has a setter
    method for each parameter (or set of related parameters) needed to instantiate
    the `Url` class. Finally, the builder is going to have a `build()` method to retrieve
    a new `Url` instance that''s been created using all the parameters that have been
    set in the builder. So, let''s implement the builder in a file called `urlBuilder.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们刚刚学到的建造者模式适用的完美场景。现在就让我们来做这件事。计划是创建一个名为 `UrlBuilder` 的类，它为每个参数（或相关参数组）提供了一个设置方法，这些参数是实例化
    `Url` 类所必需的。最后，建造者将有一个 `build()` 方法，用于检索使用所有在建造者中设置的参数创建的新 `Url` 实例。因此，让我们在名为
    `urlBuilder.js` 的文件中实现建造者：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This should be pretty straightforward. Just note the way we coupled together
    the `username` and `password` parameters into a single `setAuthentication()` method.
    This clearly conveys the fact that if we want to specify any authentication information
    in the `Url`, we have to provide both `username` and `password`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该相当直接。只需注意我们如何将 `username` 和 `password` 参数组合成一个单独的 `setAuthentication()` 方法。这清楚地传达了这样一个事实：如果我们想在
    `Url` 中指定任何认证信息，我们必须提供 `username` 和 `password`。
- en: 'Now, we are ready to try our `UrlBuilder` and witness its benefits over using
    the `Url` class directly. We can do that in a file called `index.js`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好尝试我们的 `UrlBuilder` 并见证它相对于直接使用 `Url` 类的优势。我们可以在名为 `index.js` 的文件中这样做：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the readability of the code has improved dramatically. Each setter
    method clearly gives us a hint of what parameter we are setting, and on top of
    that, they provide some guidance on how those parameters must be set (for example,
    `username` and `password` must be set together).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码的可读性有了显著提高。每个设置方法清楚地给出了我们正在设置什么参数的提示，而且在此基础上，它们还提供了一些关于如何设置这些参数的指导（例如，`username`和`password`必须一起设置）。
- en: The Builder pattern can also be implemented directly into the target class.
    For example, we could have refactored the `Url` class by adding an empty constructor
    (and therefore no validation at the object's creation time) and the setter methods
    for the various components, rather than creating a separate `UrlBuilder` class.
    However, this approach has a major flaw. Using a builder that is separate from
    the target class has the advantage of always producing instances that are guaranteed
    to be in a consistent state. For example, every `Url` object returned by `UrlBuilder.build()`
    is guaranteed to be valid and in a consistent state; calling `toString()` on such
    objects will always return a valid URL. The same cannot be said if we implemented
    the Builder pattern on the `Url` class directly. In fact, in this case, if we
    invoke `toString()` while we are still setting the various URL components, its
    return value may not be valid. This can be mitigated by adding extra validations,
    but at the cost of adding more complexity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器模式也可以直接实现在目标类中。例如，我们可以通过添加一个空构造函数（因此没有在对象创建时的验证）和为各种组件设置的方法来重构`Url`类，而不是创建一个单独的`UrlBuilder`类。然而，这种方法有一个主要的缺陷。使用与目标类分离的构建器的好处是始终产生保证处于一致状态的实例。例如，`UrlBuilder.build()`返回的每个`Url`对象都保证是有效的并且处于一致状态；在这些对象上调用`toString()`将始终返回一个有效的URL。如果我们直接在`Url`类上实现Builder模式，则不能这么说。事实上，在这种情况下，如果我们正在设置各种URL组件时调用`toString()`，其返回值可能不是有效的。这可以通过添加额外的验证来缓解，但代价是增加了更多的复杂性。
- en: In the wild
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: 'The Builder pattern is a quite common pattern in Node.js and JavaScript as
    it provides a very elegant solution to the problem of creating complex objects
    or invoking complex functions. One perfect example is creating new HTTP(S) client
    requests with the `request()` API from the `http` and `https` built-in modules.
    If we look at its documentation (available at [nodejsdp.link/docs-http-request](http://nodejsdp.link/docs-http-request)),
    we can immediately see it accepts a large amount of options, which is the usual
    sign that the Builder pattern can potentially provide a better interface. In fact,
    one of the most popular HTTP(S) request wrappers, `superagent` ([nodejsdp.link/superagent](http://nodejsdp.link/superagent)),
    aims to simplify the creation of new requests by implementing the Builder pattern,
    thus providing a fluent interface to create new requests step by step. See the
    following code fragment for an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器模式在Node.js和JavaScript中相当常见，因为它提供了一个非常优雅的解决方案来创建复杂对象或调用复杂函数的问题。一个完美的例子是使用`http`和`https`内置模块的`request()`
    API创建新的HTTP(S)客户端请求。如果我们查看其文档（可在[nodejsdp.link/docs-http-request](http://nodejsdp.link/docs-http-request)找到），我们可以立即看到它接受大量的选项，这是Builder模式可能提供更好的接口的通常迹象。事实上，最受欢迎的HTTP(S)请求包装器之一，`superagent`([nodejsdp.link/superagent](http://nodejsdp.link/superagent))，旨在通过实现Builder模式来简化新请求的创建，从而提供一个流畅的接口来逐步创建新请求。以下代码片段是一个示例：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: From the previous code, we can note that this is an unusual builder; in fact,
    we don't have a `build()` or `invoke()` method (or any other method with a similar
    purpose), and have not used the `new` operator. What triggers the request instead
    is an invocation to the `then()` method. It's interesting to note that the `superagent`
    request object is not a promise but rather a custom *thenable* where the `then()`
    method triggers the execution of the request we have built with the builder object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的代码中，我们可以注意到这是一个不寻常的构建器；实际上，我们没有`build()`或`invoke()`方法（或任何具有类似目的的其他方法），也没有使用`new`运算符。触发请求的实际上是调用`then()`方法。值得注意的是，`superagent`请求对象不是一个Promise，而是一个自定义的*thenable*，其中`then()`方法触发了使用构建器对象构建的请求的执行。
- en: We already discussed *thenables* in *Chapter 5*, *Asynchronous Control Flow
    Patterns with Promises and Async/Await*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在**第五章**中讨论了*thenables*，即**异步控制流模式与Promises和Async/Await**。
- en: If you take a look at the library's code, you will see the Builder pattern in
    action in the `Request` class ([nodejsdp.link/superagent-src-builder](http://nodejsdp.link/superagent-src-builder)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看库的代码，你将看到在`Request`类中构建者模式的应用实例（[nodejsdp.link/superagent-src-builder](http://nodejsdp.link/superagent-src-builder)）。
- en: This concludes our exploration of the Builder pattern. Next, we'll look at the
    Revealing Constructor pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对构建者模式的探索结束。接下来，我们将探讨揭示构造者模式。
- en: Revealing Constructor
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示构造者
- en: 'The Revealing Constructor pattern is one of those patterns that you won''t
    find in the "Gang of Four" book, since it originated directly from the JavaScript
    and the Node.js community. It solves a very tricky problem, which is: how can
    we "reveal" some private functionality of an object only at the moment of the
    object''s creation? This is particularly useful when we want to allow an object''s
    internals to be manipulated only during its creation phase. This allows for a
    few interesting scenarios, such as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示构造者模式是那些你不会在“四人帮”书中找到的模式之一，因为它直接源于JavaScript和Node.js社区。它解决了一个非常棘手的问题，即：我们如何在对象的创建时刻“揭示”对象的某些私有功能？这在当我们希望只允许在对象的创建阶段操作对象的内部时尤其有用。这允许一些有趣的场景，例如：
- en: Creating objects that can be modified only at creation time
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建在创建时只能修改的对象
- en: Creating objects whose custom behavior can be defined only at creation time
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建在创建时只能定义自定义行为的对象
- en: Creating objects that can be initialized only once at creation time
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建在创建时只能初始化一次的对象
- en: 'These are just a few possibilities enabled by the Revealing Constructor pattern.
    But to better understand all the possible use cases, let''s see what the pattern
    is about by looking at the following code fragment:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是揭示构造者模式所启用的可能性中的一小部分。但要更好地理解所有可能的用例，让我们通过查看以下代码片段来了解模式的内容：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see from the previous code, the Revealing Constructor pattern is made
    of three fundamental elements; a **constructor** (1) that takes a function as
    input (the **executor** (2)), which is invoked at creation time and receives a
    subset of the object's internals as input (**revealed members** (3)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从之前的代码中可以看到，揭示构造者模式由三个基本元素组成；一个**构造函数**（1），它接受一个函数作为输入（**执行器**（2）），在创建时被调用，并接收对象内部的一部分作为输入（**揭示成员**（3））。
- en: For the pattern to work, the revealed functionality must otherwise be not accessible
    by the users of the object once it is created. This can be achieved with one of
    the encapsulation techniques we've mentioned in the previous section regarding
    the Factory pattern.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使模式生效，揭示的功能必须在其他情况下不可由对象的用户访问。这可以通过我们在上一节中提到的有关工厂模式的封装技术之一来实现。
- en: Domenic Denicola was the first to identify and name the pattern in one of his
    blog posts, which can be found at [nodejsdp.link/domenic-revealing-constructor](http://nodejsdp.link/domenic-revealing-constructor).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Domenic Denicola是第一个在他的博客文章中识别并命名该模式的人，该文章可以在[nodejsdp.link/domenic-revealing-constructor](http://nodejsdp.link/domenic-revealing-constructor)找到。
- en: Now, let's look at a couple of examples to better understand how the Revealing
    Constructor pattern works.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过几个例子来更好地理解揭示构造者模式的工作原理。
- en: Building an immutable buffer
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建不可变缓冲区
- en: '**Immutable** objects and data structures have many excellent properties that
    make them ideal to use in countless situations in place of their mutable (or changeable)
    counterparts. Immutable refers to the property of an object by which its data
    or state becomes unmodifiable once it''s been created.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变**对象和数据结构具有许多优秀的属性，使它们在无数情况下成为使用它们的可变（或可更改）对应物的理想选择。不可变指的是对象的一个属性，一旦创建，其数据或状态就变得不可修改。'
- en: With immutable objects, we don't need to create **defensive copies** before
    passing them around to other libraries or functions. We simply have a strong guarantee,
    by definition, that they won't be modified, even when they are passed to code
    that we don't know or control.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变对象，我们不需要在将它们传递给其他库或函数之前创建**防御性副本**。我们简单地有一个强有力的保证，根据定义，它们不会被修改，即使它们被传递到我们不知道或无法控制的代码中。
- en: Modifying an immutable object can only be done by creating a new copy and can
    make the code more maintainable and easier to reason about. We do this to make
    it easier to keep track of state changes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 修改不可变对象只能通过创建一个新的副本来完成，这可以使代码更易于维护和推理。我们这样做是为了更容易地跟踪状态变化。
- en: Another common use case for immutable objects is efficient change detection.
    Since every change requires a copy and if we assume that every copy corresponds
    to a modification, then detecting a change is as simple as using the strict equality
    operator (or triple equal `===`). This technique is used extensively in frontend
    programming to efficiently detect if the UI needs refreshing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象的另一个常见用例是高效的变更检测。由于每次变更都需要复制，如果我们假设每个副本都对应一个修改，那么检测变更就像使用严格相等运算符（或三元等`===`）一样简单。这种技术在前端编程中被广泛使用，以高效地检测UI是否需要刷新。
- en: In this context, let's now create a simple immutable version of the Node.js
    `Buffer` component ([nodejsdp.link/docs-buffer](http://nodejsdp.link/docs-buffer))
    using the Revealing Constructor pattern. The pattern allows us to manipulate an
    immutable buffer only at creation time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，现在让我们使用Revealing Constructor模式创建Node.js `Buffer`组件的简单不可变版本（[nodejsdp.link/docs-buffer](http://nodejsdp.link/docs-buffer)）。该模式允许我们仅在创建时操作不可变缓冲区。
- en: 'Let''s implement our immutable buffer in a new file called `immutableBuffer.js`,
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为`immutableBuffer.js`的新文件中实现我们的不可变缓冲区，如下所示：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s now see how our new `ImmutableBuffer` class works:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的新`ImmutableBuffer`类是如何工作的：
- en: First, we allocate a new Node.js `Buffer` (`buffer`) of the size specified in
    the `size` constructor argument.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们根据`size`构造函数参数指定的尺寸分配一个新的Node.js `Buffer`（`buffer`）。
- en: Then, we create an object literal (`modifiers`) to hold all the methods that
    can mutate the buffer.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个对象字面量（`modifiers`），用于保存所有可以修改缓冲区的函数。
- en: After that, we iterate over all the properties (own and inherited) of our internal
    `buffer`, making sure to skip all those that are not functions.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们遍历我们的内部`buffer`的所有属性（自有和继承的），确保跳过所有不是函数的属性。
- en: Next, we try to identify if the current `prop` is a method that allows us to
    modify the `buffer`. We do that by trying to match its name with one of the strings
    in the `MODIFIER_NAMES` array. If we have such a method, we bind it to the `buffer`
    instance, and then we add it to the `modifiers` object.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们尝试识别当前`prop`是否是一个允许我们修改`buffer`的方法。我们通过尝试将其名称与`MODIFIER_NAMES`数组中的字符串之一进行匹配来完成此操作。如果我们有这样的方法，我们将其绑定到`buffer`实例，然后将其添加到`modifiers`对象中。
- en: If our method is not a modifier method, then we add it directly to the current
    instance (`this`).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的方法不是修改器方法，那么我们将其直接添加到当前实例（`this`）中。
- en: Finally, we invoke the `executor` function received as input in the constructor
    and pass the `modifiers` object as an argument, which will allow `executor` to
    mutate our internal `buffer`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用构造函数中接收到的`executor`函数，并将`modifiers`对象作为参数传递，这将允许`executor`修改我们的内部`buffer`。
- en: In practice, our `ImmutableBuffer` is acting as a **proxy** between its consumers
    and the internal `buffer` object. Some of the methods of the `buffer` instance
    are exposed directly through the `ImmutableBuffer` interface (mainly the read-only
    methods), while others are provided to the `executor` function (the modifier methods).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们的`ImmutableBuffer`充当其消费者和内部`buffer`对象之间的**代理**。`buffer`实例的一些方法直接通过`ImmutableBuffer`接口（主要是只读方法）公开，而其他方法则提供给执行器函数（修改器方法）。
- en: We will analyze the Proxy pattern in more detail in *Chapter 8*, *Structural
    Design Patterns*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章*结构型设计模式*中更详细地分析Proxy模式。
- en: Please keep in mind that this is just a demonstration of the Revealing Constructor
    pattern, so the implementation of the immutable buffer is intentionally kept simple.
    For example, we are not exposing the size of the buffer or providing other means
    to initialize the buffer. We'll leave this to you as an exercise.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这只是一个Revealing Constructor模式的演示，因此不可变缓冲区的实现故意保持简单。例如，我们没有公开缓冲区的大小或提供其他初始化缓冲区的方法。我们将把这些留给你作为练习。
- en: 'Now, let''s write some code to demonstrate how to use our new `ImmutableBuffer`
    class. Let''s create a new file, `index.js`, containing the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些代码来演示如何使用我们新的`ImmutableBuffer`类。让我们创建一个名为`index.js`的新文件，包含以下代码：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing we can note from the previous code is how the executor function
    uses the `write()` function (which is part of the modifier methods) to write a
    string into the buffer (1). In a similar way, the executor function could've used
    `fill()`, `writeInt8()`, `swap16()` or any other method exposed in the `modifiers`
    object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的代码中，我们可以注意到的第一点是执行器函数如何使用`write()`函数（它是修改器方法的一部分）将字符串写入缓冲区（1）。以类似的方式，执行器函数本可以使用`fill()`、`writeInt8()`、`swap16()`或`modifiers`对象中公开的任何其他方法。
- en: The code we've just seen also demonstrates how the new `ImmutableBuffer` instance
    exposes only the methods that don't mutate the buffer, such as `readInt8()` (2),
    while it doesn't provide any method to change the content of the buffer (3).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的代码也展示了新的 `ImmutableBuffer` 实例仅暴露不修改缓冲区的方法，例如 `readInt8()`（2），而它不提供任何更改缓冲区内容的方法（3）。
- en: In the wild
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: The Revealing Constructor pattern offers very strong guarantees and for this
    reason, it's mainly used in contexts where we need to provide foolproof encapsulation.
    A perfect application of the pattern would be in components used by hundreds of
    thousands of developers that have to provide unopinionated interfaces and strict
    encapsulation. However, we can also use the pattern in our projects to improve
    reliability and simplify code sharing with other people and teams (since it can
    make an object safer to use by third parties).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示构造函数模式提供了非常强的保证，因此，它主要用在需要提供无懈可击封装的上下文中。该模式的一个完美应用是在由数十万开发者使用的组件中，这些组件必须提供无偏见接口和严格的封装。然而，我们也可以在我们的项目中使用该模式来提高可靠性，并简化与其他人和团队之间的代码共享（因为它可以使对象对第三方更安全）。
- en: 'A popular application of the Revealing Constructor pattern is in the JavaScript
    `Promise` class. Some of you may have already noticed it. When we create a new
    `Promise` from scratch, its constructor accepts as input an `executor` function
    that will receive the `resolve()` and `reject()` functions used to mutate the
    internal state of the `Promise`. Let''s provide a reminder of what this looks
    like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示构造函数模式的一个流行应用是在 JavaScript 的 `Promise` 类中。有些人可能已经注意到了这一点。当我们从头创建一个新的 `Promise`
    时，其构造函数接受一个 `executor` 函数作为输入，该函数将接收用于修改 `Promise` 内部状态的 `resolve()` 和 `reject()`
    函数。让我们回顾一下它的样子：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once created, the `Promise` state cannot be altered by any other means. All
    we can do is receive its fulfilment value or rejection reason using the methods
    we already learned about in *Chapter 5*, *Asynchronous Control Flow Patterns with
    Promises and Async/Await*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，`Promise` 状态就不能通过其他方式更改。我们所能做的就是使用我们在 *第五章* 中学习的方法来接收其实现值或拒绝原因，即 *异步控制流模式与
    Promises 和 Async/Await*。
- en: Singleton
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: Now, we are going to spend a few words on a pattern that is among the most used
    in object-oriented programming, which is the **Singleton** pattern. As we will
    see, Singleton is one of those patterns that has a trivial implementation in Node.js
    that's almost not worth discussing. However, there are a few caveats and limitations
    that every good Node.js developer must know.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将花一些时间讨论在面向对象编程中最常用的模式之一，即 **单例** 模式。正如我们将看到的，单例是那些在 Node.js 中有简单实现且几乎不值得讨论的模式之一。然而，有一些注意事项和限制，每个优秀的
    Node.js 开发者都必须知道。
- en: 'The purpose of the Singleton pattern is to enforce the presence of only one
    instance of a class and centralize its access. There are a few reasons for using
    a single instance across all the components of an application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的目的在于确保一个类只有一个实例，并集中其访问。在应用程序的所有组件中使用单个实例有几个原因：
- en: For sharing stateful information
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了共享有状态信息
- en: For optimizing resource usage
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了优化资源使用
- en: To synchronize access to a resource
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了同步对资源的访问
- en: 'As you can imagine, those are quite common scenarios. Take, for example, a
    typical `Database` class, which provides access to a database:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，这些场景相当常见。以一个典型的 `数据库` 类为例，它提供了对数据库的访问：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Typical implementations of such a class usually keep a pool of database connections,
    so it doesn't make sense to create a new `Database` instance for each request.
    Plus, a `Database` instance may store some stateful information, such as the list
    of pending transactions. So, our `Database` class meets two criterions for justifying
    the Singleton pattern. Therefore, what we usually want is to configure and instantiate
    one single `Database` instance at the start of our application and let every component
    use that single shared `Database` instance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个类的典型实现通常保持一个数据库连接池，因此，为每个请求创建一个新的 `数据库` 实例是没有意义的。此外，一个 `数据库` 实例可能存储一些有状态信息，例如挂起的交易列表。因此，我们的
    `数据库` 类符合单例模式的两项标准。因此，我们通常希望在应用程序开始时配置和实例化一个单一的 `数据库` 实例，并让每个组件使用这个单一的共享 `数据库`
    实例。
- en: 'A lot of people new to Node.js get confused about how to implement the Singleton
    pattern correctly; however, the answer is easier than what we might think. Simply
    exporting an instance from a module is already enough to obtain something very
    similar to the Singleton pattern. Consider, for example, the following lines of
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Node.js的新手对如何正确实现单例模式感到困惑；然而，答案比我们想象的要简单。只需从一个模块中导出一个实例就足以获得非常类似单例模式的东西。例如，以下代码行：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By simply exporting a new instance of our `Database` class, we can already assume
    that within the current package (which can easily be the entire code of our application),
    we are going to have only one instance of the `dbInstance` module. This is possible
    because, as we know from *Chapter 2*, *The Module System*, Node.js will cache
    the module, making sure not to execute its code at every import.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地导出我们`Database`类的新实例，我们就可以假设在当前包内（这可以很容易地是整个应用程序的代码），我们只会有一个`dbInstance`模块的实例。这是因为，正如我们从*第二章*，*模块系统*中了解到的，Node.js会缓存模块，确保在每次导入时不会执行其代码。
- en: 'For example, we can easily obtain a shared instance of the `dbInstance` module,
    which we defined earlier, with the following line of code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以很容易地通过以下代码行获得我们之前定义的`dbInstance`模块的共享实例：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: But there is a caveat. The module is cached using its full path as the lookup
    key, so it is only guaranteed to be a singleton within the current package. In
    fact, each package may have its own set of private dependencies inside its `node_modules`
    directory, which might result in multiple instances of the same package and therefore
    of the same module, resulting in our singleton not really being unique anymore!
    This is, of course, a rare scenario, but it's important to understand what its
    consequences are.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个注意事项。模块是使用其完整路径作为查找键进行缓存的，因此它只保证在当前包内是单例。实际上，每个包在其`node_modules`目录内可能都有自己的私有依赖集，这可能导致同一包和同一模块的多个实例，从而使我们的单例不再真正是唯一的！当然，这是一个罕见的情况，但了解其后果是很重要的。
- en: 'Consider, for example, the case in which the `Database.js` and `dbInstance.js`
    files that we saw earlier are wrapped into a package named `mydb`. The following
    lines of code would be in its `package.json` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以例如，我们之前看到的`Database.js`和`dbInstance.js`文件被封装在一个名为`mydb`的包中的情况为例。以下代码行将位于其`package.json`文件中：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, consider two packages (`package-a` and `package-b`), both of which have
    a single file called `index.js` containing the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑两个包（`package-a`和`package-b`），它们各自都有一个名为`index.js`的单个文件，包含以下代码：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both `package-a` and `package-b` have a dependency on the `mydb` package. However,
    `package-a` depends on version `1.0.0` of the `mydb` package, while `package-b`
    depends on version `2.0.0` of the same package (which, for our example, has an
    identical implementation, but just a different version specified in its `package.json`
    file).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`package-a`和`package-b`都依赖于`mydb`包。然而，`package-a`依赖于`mydb`包的`1.0.0`版本，而`package-b`依赖于同一包的`2.0.0`版本（在我们的例子中，它有一个相同的实现，但在其`package.json`文件中指定了不同的版本）。'
- en: 'Given the structure we just described, we would end up with the following package
    dependency tree:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚才描述的结构，我们最终会得到以下包依赖树：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We end up with a directory structure like the one here because `package-a` and
    `package-b` require two different incompatible versions of the `mydb` module (for
    example, `1.0.0` versus `2.0.0`). In this case, a typical package manager such
    as `npm` or `yarn` would not "hoist" the dependency to the top `node_modules`
    directory, but it will instead install a private copy of each package in an attempt
    to fix the version incompatibility.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到一个像这里这样的目录结构，因为`package-a`和`package-b`需要`mydb`模块的两个不同不兼容版本（例如，`1.0.0`与`2.0.0`）。在这种情况下，一个典型的包管理器，如`npm`或`yarn`，不会将依赖项“提升”到顶层的`node_modules`目录，而是会安装每个包的私有副本，试图解决版本不兼容问题。
- en: With the directory structure we just saw, both `package-a` and `package-b` have
    a dependency on the `mydb` package; in turn, the `app` package, which is our root
    package, depends on both `package-a` and `package-b`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚才看到的目录结构，`package-a`和`package-b`都依赖于`mydb`包；反过来，我们的根包`app`依赖于`package-a`和`package-b`。
- en: 'The scenario we just described will break the assumption about the uniqueness
    of the database instance. In fact, consider the following file (`index.js`) located
    in the root folder of the `app` package:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的场景将违反数据库实例唯一性的假设。实际上，考虑以下位于`app`包根目录的文件（`index.js`）：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you run the previous file, you will notice that the answer to *Is the db
    instance in package-a the same as package-b?* is `NO`. In fact, `package-a` and
    `package-b` will actually load two different instances of the `dbInstance` object
    because the `mydb` module will resolve to a different directory, depending on
    the package it is required from. This clearly break the assumptions of the Singleton
    pattern.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的文件，你会注意到对“包-a中的db实例与包-b中的实例是否相同？”这个问题的答案是“不”。实际上，“包-a”和“包-b”将实际加载两个不同的`dbInstance`对象实例，因为`mydb`模块将解析到不同的目录，这取决于它被要求的包。这显然违反了单例模式的假设。
- en: If instead, both `package-a` and `package-b` required two versions of the `mydb`
    package compatible with each other, for example, `^2.0.1` and `^2.0.7`, then the
    package manager would install the `mydb` package into the top-level `node_modules`
    directory (a practice known as **dependency hoisting**), effectively sharing the
    same instance with `package-a`, `package-b`, and the root package.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相反，`包-a`和`包-b`都需要两个相互兼容的`mydb`包版本，例如，`^2.0.1`和`^2.0.7`，那么包管理器会将`mydb`包安装到顶级`node_modules`目录中（这种做法被称为**依赖提升**），从而有效地与`包-a`、`包-b`和根包共享相同的实例。
- en: 'At this point, we can easily say that the Singleton pattern, as described in
    the literature, does not exist in Node.js, unless we use a real *global variable*
    to store it, such as the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以很容易地说，文献中描述的单例模式在Node.js中并不存在，除非我们使用真正的**全局变量**来存储它，如下所示：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This guarantees that the instance is the only one shared across the entire application
    and not just the same package. However, please consider that most of the time,
    we don't really need a *pure* singleton. In fact, we usually create and import
    singletons within the main package of an application or, at worst, in a subcomponent
    of the application that has been modularized into a dependency.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这保证了实例在整个应用程序中是唯一的，而不仅仅是同一个包中的。然而，请考虑，大多数时候，我们并不真的需要一个**纯**单例。实际上，我们通常在应用程序的主包中创建和导入单例，或者在应用程序的一个子组件中，该子组件已经被模块化成依赖项。
- en: If you are creating a package that is going to be used by third parties, try
    to keep it stateless to avoid the issues we've discussed in this section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个将被第三方使用的包，尽量保持其无状态，以避免本节中讨论的问题。
- en: Throughout this book, for simplicity, we will use the term singleton to describe
    a class instance or a stateful object exported by a module, even if this doesn't
    represent a real singleton in the strict definition of the term.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，为了简单起见，我们将使用术语单例来描述由模块导出的类实例或具有状态的对象，即使这并不代表严格意义上的单例。
- en: Next, we are going to see the two main approaches for dealing with dependencies
    between modules, one based on the Singleton pattern and the other leveraging the
    Dependency Injection pattern.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到处理模块之间依赖关系的两种主要方法，一种基于单例模式，另一种利用依赖注入模式。
- en: Wiring modules
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块连接
- en: Every application is the result of the aggregation of several components and,
    as the application grows, the way we connect these components becomes a win or
    lose factor for the maintainability and success of the project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都是几个组件的聚合结果，随着应用程序的增长，我们连接这些组件的方式成为维护性和项目成功与否的关键因素。
- en: When a component, A, needs component B to fulfill a given functionality, we
    say that "A is **dependent** on B" or, conversely, that "B is a **dependency**
    of A." To appreciate this concept, let's present an example.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件A需要组件B来满足某个功能时，我们说“A依赖于B”，或者相反，“B是A的依赖”。为了理解这个概念，让我们举一个例子。
- en: Let's say we want to write an API for a blogging system that uses a database
    to store its data. We can have a generic module implementing a database connection
    (`db.js`) and a blog module that exposes the main functionality to create and
    retrieve blog posts from the database (`blog.js`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个用于博客系统的API，该系统使用数据库来存储其数据。我们可以有一个通用的模块实现数据库连接（`db.js`）和一个博客模块，该模块公开创建和从数据库检索博客文章的主要功能（`blog.js`）。
- en: 'The following figure illustrates the relationship between the database module
    and the blog module:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了数据库模块和博客模块之间的关系：
- en: '![../../../Downloads/Untitled%20Diagram%20(13).png](img/B15729_07_01.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![../../../Downloads/Untitled%20Diagram%20(13).png](img/B15729_07_01.png)'
- en: 'Figure 7.1: Dependency graph between the blog module and the database module'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：博客模块和数据库模块之间的依赖关系图
- en: In this section, we are going to see how we can model this dependency using
    two different approaches, one based on the Singleton pattern and the other using
    the Dependency Injection pattern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用两种不同的方法来建模这种依赖关系，一种基于单例模式，另一种使用依赖注入模式。
- en: Singleton dependencies
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例依赖
- en: The simplest way to wire two modules together is by leveraging Node.js' module
    system. Stateful dependencies wired in this way are de facto singletons, as we
    discussed in the previous section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个模块连接起来的最简单方法是通过利用 Node.js 的模块系统。以这种方式连接的状态化依赖实际上是单例，正如我们在上一节中讨论的那样。
- en: 'To see how this works in practice, we are going to implement the simple blogging
    application that we described earlier using a singleton instance for the database
    connection. Let''s see a possible implementation of this approach (the file `db.js`):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到实际效果，我们将使用数据库连接的单例实例来实现我们之前描述的简单博客应用程序。让我们看看这种方法的可能实现（文件 `db.js`）：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the previous code, we are using SQLite ([nodejsdp.link/sqlite](http://nodejsdp.link/sqlite))
    as a database to store our posts. To interact with SQLite, we are using the module
    `sqlite3` ([nodejsdp.link/sqlite3](http://nodejsdp.link/sqlite3)) from npm. SQLite
    is a database system that keeps all the data in a single local file. In our database
    module, we decided to use a file called `data.sqlite` saved in the same folder
    as the module.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 SQLite ([nodejsdp.link/sqlite](http://nodejsdp.link/sqlite)) 作为数据库来存储我们的帖子。为了与
    SQLite 交互，我们使用 npm 中的模块 `sqlite3` ([nodejsdp.link/sqlite3](http://nodejsdp.link/sqlite3))。SQLite
    是一个数据库系统，它将所有数据保存在单个本地文件中。在我们的数据库模块中，我们决定使用一个名为 `data.sqlite` 的文件，该文件与模块保存在同一文件夹中。
- en: The preceding code creates a new instance of the database pointing to our data
    file and exports the database connection object as a singleton with the name `db`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个指向我们的数据文件的新数据库实例，并将数据库连接对象作为名为 `db` 的单例导出。
- en: 'Now, let''s see how we can implement the `blog.js` module:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何实现 `blog.js` 模块：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `blog.js` module exports a class called `Blog` containing three methods:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog.js` 模块导出一个名为 `Blog` 的类，包含三个方法：'
- en: '`initialize()`: Creates the `posts` table if it doesn''t exist. The table will
    be used to store the blog post''s data.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`: 如果不存在，则创建 `posts` 表。该表将用于存储博客帖子的数据。'
- en: '`createPost()`: Takes all the necessary parameters needed to create a post.
    It will execute an `INSERT` statement to add the new post to the database.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createPost()`: 接收创建帖子所需的所有必要参数。它将执行一个 `INSERT` 语句将新帖子添加到数据库中。'
- en: '`getAllPosts()`: Retrieves all the posts available in the database and returns
    them as an array.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAllPosts()`: 从数据库中检索所有可用的帖子，并将它们作为数组返回。'
- en: 'Now, let''s create a module to try out the functionality of the blog module
    we just created (the file `index.js`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个模块来尝试我们刚刚创建的博客模块（文件 `index.js`）的功能：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This preceding module is very simple. We retrieve the array with all the posts
    using `blog.getAllPosts()` and then we loop over it and display the data for every
    single post, giving it a bit of formatting.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模块非常简单。我们使用 `blog.getAllPosts()` 获取所有帖子的数组，然后遍历它，并为每个帖子显示数据，稍作格式化。
- en: You can use the provided `import-posts.js` module to load some sample posts
    into the database before running `index.js`. You can find `import-posts.js` in
    the code repository of this book, along with the rest of the files for this example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用提供的 `import-posts.js` 模块在运行 `index.js` 之前将一些示例帖子加载到数据库中。你可以在本书的代码存储库中找到
    `import-posts.js`，以及其他与此示例相关的文件。
- en: As a fun exercise, you could try to modify the `index.js` module to generate
    HTML files; one for the blog index and then a dedicated file for each blog post.
    This way, you would build your own minimalistic static website generator!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项有趣的练习，你可以尝试修改 `index.js` 模块以生成 HTML 文件；一个用于博客索引，然后为每个博客帖子创建一个专门的文件。这样，你就可以构建自己的最小化静态网站生成器了！
- en: As we can see from the preceding code, we can implement a very simple command-line
    blog management system by leveraging the Singleton pattern to pass the `db` instance
    around. Most of the time, this is how we manage stateful dependencies in our application;
    however, there are situations in which this may not be enough.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们可以通过利用单例模式传递`db`实例来实施一个非常简单的命令行博客管理系统。大多数时候，这就是我们管理应用中有状态依赖关系的方式；然而，在某些情况下，这可能不足以解决问题。
- en: Using a singleton, as we have done in the previous example, is certainly the
    most simple, immediate, and readable solution to pass stateful dependencies around.
    However, what happens if we want to mock our database during our tests? What can
    we do if we want to let the user of the blogging CLI or the blogging API select
    another database backend, instead of the standard SQLite backend that we provide
    by default? For these use cases, a singleton can be an obstacle for implementing
    a properly structured solution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的例子中所做的那样，使用单例当然是最简单、最直接和最易读的解决方案来传递有状态依赖关系。然而，如果我们想在测试期间模拟数据库，或者如果我们想允许博客CLI或API的用户选择另一个数据库后端，而不是我们默认提供的标准SQLite后端，会发生什么呢？对于这些用例，单例可能会成为实现良好结构化解决方案的障碍。
- en: We could introduce `if` statements in our `db.js` module to pick different implementations
    based on some environment condition or some configuration. Alternatively, we could
    fiddle with the Node.js module system to intercept the import of the database
    file and replace it with something else. But, as you can image, these solutions
    are far from elegant.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的`db.js`模块中引入`if`语句，根据某些环境条件或配置选择不同的实现。或者，我们可以篡改Node.js模块系统来拦截数据库文件的导入，并用其他东西替换它。但是，正如你可以想象的，这些解决方案远非优雅。
- en: In the next section, we will learn about another strategy for wiring modules,
    which can be the ideal solution to some of the issues we discussed here.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习另一种连接模块的策略，这可能是解决我们在此讨论的一些问题的理想解决方案。
- en: Dependency Injection
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: The Node.js module system and the Singleton pattern can serve as great tools
    for organizing and wiring together the components of an application. However,
    these do not always guarantee success. If, on the one hand, they are simple to
    use and very practical, then on the other, they might introduce a tighter *coupling*
    between components.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js模块系统和单例模式可以作为组织应用程序组件和连接组件的强大工具。然而，它们并不总是保证成功。一方面，它们易于使用且非常实用；另一方面，它们可能会在组件之间引入更紧密的*耦合*。
- en: In the previous example, we can see that the `blog.js` module is *tightly coupled*
    with the `db.js` module. In fact, our `blog.js` module cannot work without the
    `database.js` module by design, nor can it use a different database module if
    necessary. We can easily fix this tight coupling between the two modules by leveraging
    the **Dependency Injection pattern**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到`blog.js`模块与`db.js`模块紧密耦合。事实上，我们的`blog.js`模块按设计不能在没有`database.js`模块的情况下工作，也不能在必要时使用不同的数据库模块。我们可以通过利用**依赖注入模式**轻松修复这两个模块之间的紧密耦合。
- en: '**Dependency Injection** (**DI**) is a very simple pattern in which the dependencies
    of a component are *provided as input* by an external entity, often referred to
    as the **injector**.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）是一种非常简单的模式，其中组件的依赖关系由外部实体*提供*作为输入，通常被称为**注入器**。'
- en: The injector initializes the different components and ties their dependencies
    together. It can be a simple initialization script or a more sophisticated *global
    container* that maps all the dependencies and centralizes the wiring of all the
    modules of the system. The main advantage of this approach is improved decoupling,
    especially for modules depending on stateful instances (for example, a database
    connection). Using DI, each dependency, instead of being hardcoded into the module,
    is received from the outside. This means that the dependent module can be configured
    to use any compatible dependency, and therefore the module itself can be reused
    in different contexts with minimal effort.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注入器初始化不同的组件并将它们的依赖关系连接在一起。它可能是一个简单的初始化脚本，也可能是一个更复杂的*全局容器*，该容器映射所有依赖关系并集中连接系统的所有模块。这种方法的优点是提高了解耦性，特别是对于依赖于有状态实例（例如，数据库连接）的模块。使用依赖注入（DI），每个依赖关系都不是硬编码到模块中，而是从外部接收。这意味着依赖模块可以被配置为使用任何兼容的依赖关系，因此模块本身可以在不同的环境中以最小的努力重用。
- en: 'The following diagram illustrates this idea:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这个概念：
- en: '![../../../Downloads/Untitled%20Diagram%20(14).png](img/B15729_07_02.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![../../../Downloads/Untitled%20Diagram%20(14).png](img/B15729_07_02.png)'
- en: 'Figure 7.2: Dependency injection schematic'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：依赖注入示意图
- en: In *Figure 7.2*, we can see that a generic service expects a dependency with
    a predetermined interface. It's the responsibility of the **injector** to retrieve
    or create an actual concrete instance that implements such an interface and passes
    it (or "injects it") into the service. In other words, the injector has the goal
    of providing an instance that fulfills the dependency for the service.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.2*中，我们可以看到通用服务期望一个具有预定接口的依赖项。**注入器**负责检索或创建一个实际的具体实例，该实例实现了这样的接口并将其（或“注入”）到服务中。换句话说，注入器的目标是提供一个满足服务依赖项的实例。
- en: 'To demonstrate this pattern in practice, let''s refactor the simple blogging
    system that we built in the previous section by using DI to wire its modules.
    Let''s start by refactoring the `blog.js` module:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个模式在实际中的应用，让我们通过使用依赖注入（DI）来连接其模块，重构我们在上一节中构建的简单博客系统。让我们首先重构`blog.js`模块：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you compare the new version with the previous one, they are almost identical.
    There are only two small but important differences:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将新版本与旧版本进行比较，它们几乎相同。只有两个小但重要的区别：
- en: We are not importing the database module anymore
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再导入数据库模块
- en: The `Blog` class constructor takes `db` as an argument
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blog`类的构造函数接受`db`作为参数'
- en: The new constructor argument `db` is the expected dependency that needs to be
    provided at runtime by the client component of the `Blog` class. This client component
    is going to be the injector of the dependency. Since JavaScript doesn't have any
    way to represent abstract interfaces, the provided dependency is expected to implement
    the `db.run()` and `db.all()` methods. This is called duck typing, as mentioned
    earlier in this book.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 新的构造函数参数`db`是在运行时需要由`Blog`类的客户端组件提供的预期依赖项。这个客户端组件将成为依赖项的注入器。由于JavaScript没有表示抽象接口的方法，因此提供的依赖项预期将实现`db.run()`和`db.all()`方法。这被称为鸭子类型，正如本书前面提到的。
- en: 'Let''s now rewrite our `db.js` module. The goal here is to get rid of the Singleton
    pattern and to come up with an implementation that is more reusable and configurable:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在重写我们的`db.js`模块。这里的目的是摆脱单例模式，并设计出一个更可重用和可配置的实现：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This new implementation of the `db` module provides a factory function called
    `createDb()`, which allows us to create new instances of the database at runtime.
    It also allows us to pass the path to the database file at creation time so that
    we can create independent instances that can write to different files if we have
    to.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`db`模块实现提供了一个名为`createDb()`的工厂函数，它允许我们在运行时创建数据库的新实例。它还允许我们在创建时传递数据库文件的路径，这样我们就可以创建独立的实例，如果需要的话，可以写入不同的文件。
- en: 'At this point, we have almost all the building blocks in place, we are only
    missing the injector. We will give an example of the injector by reimplementing
    the `index.js` module:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经几乎拥有了所有的构建块，我们唯一缺少的是注入器。我们将通过重新实现`index.js`模块来给出注入器的示例：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code is also quite similar to the previous implementation, except for
    two important changes (highlighted in the preceding code):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的实现也非常相似，除了两个重要的变化（在前面代码中突出显示）：
- en: We create the database dependency (`db`) using the factory function `createDb()`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用工厂函数`createDb()`创建数据库依赖项（`db`）。
- en: We explicitly "inject" the database instance when we instantiate the `Blog`
    class.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们实例化`Blog`类时，我们明确地“注入”数据库实例。
- en: In this implementation of our blogging system, the `blog.js` module is totally
    decoupled from the actual database implementation, making it more composable and
    easy to test in isolation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们博客系统的这个实现中，`blog.js`模块与实际的数据库实现完全解耦，使其更易于组合和独立测试。
- en: We saw how to inject dependencies as constructor arguments (**constructor injection**),
    but dependencies can also be passed when invoking a function or method (**function
    injection**) or injected explicitly by assigning the relevant properties of an
    object (**property injection**).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何将依赖项作为构造函数参数注入（**构造函数注入**），但依赖项也可以在调用函数或方法时传递（**函数注入**）或通过分配对象的相关属性显式注入（**属性注入**）。
- en: Unfortunately, the advantages in terms of decoupling and reusability offered
    by the Dependency Injection pattern come with a price to pay. In general, the
    inability to resolve a dependency at *coding time* makes it more difficult to
    understand the relationship between the various components of a system. This is
    especially true in large applications where we might have a significant amount
    of services with a complex dependency graph.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，依赖注入模式在解耦和可重用性方面提供的优势是有代价的。一般来说，在编码时无法解决依赖关系使得理解系统各个组件之间的关系变得更加困难。这在大型应用中尤其如此，我们可能会有大量的服务，并且具有复杂的依赖图。
- en: Also, if we look at the way we instantiated our database dependency in our preceding
    example script, we can see that we had to make sure that the database instance
    was created before we could invoke any function from our `Blog` instance. This
    means that, when used in its raw form, Dependency Injection forces us to build
    the dependency graph of the entire application by hand, making sure that we do
    it in the right order. This can become unmanageable when the number of modules
    to wire becomes too high.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们回顾一下我们之前示例脚本中实例化数据库依赖的方式，我们可以看到我们必须确保在调用我们的`Blog`实例的任何函数之前创建了数据库实例。这意味着，当以原始形式使用时，依赖注入强制我们手动构建整个应用的依赖图，并确保我们以正确的顺序进行。当需要连接的模块数量变得过高时，这可能会变得难以管理。
- en: Another pattern, called **Inversion of Control**, allows us to shift the responsibility
    of wiring the modules of an application to a third-party entity. This entity can
    be a **service locator** (a simple component used to retrieve a dependency, for
    example, `serviceLocator.get('db')`) or a **dependency injection container** (a
    system that injects the dependencies into a component based on some metadata specified
    in the code itself or in a configuration file). You can find more about these
    components on Martin Fowler's blog at [nodejsdp.link/ioc-containers](http://nodejsdp.link/ioc-containers).
    Even though these techniques derail a bit from the Node.js way of doing things,
    some of them have recently gained some popularity. Check out `inversify` ([nodejsdp.link/inversify](http://nodejsdp.link/inversify))
    and `awilix` ([nodejsdp.link/awilix](http://nodejsdp.link/awilix)) to find out
    more.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个称为**控制反转**的模式允许我们将连接应用模块的责任转移到第三方实体。这个实体可以是一个**服务定位器**（一个用于检索依赖的简单组件，例如`serviceLocator.get('db')`）或一个**依赖注入容器**（一个根据代码本身或配置文件中指定的某些元数据将依赖注入到组件中的系统）。你可以在Martin
    Fowler的博客上找到更多关于这些组件的信息，网址为[nodejsdp.link/ioc-containers](http://nodejsdp.link/ioc-containers)。尽管这些技术有点偏离Node.js的做法，但其中一些最近已经获得了一些人气。查看`inversify`([nodejsdp.link/inversify](http://nodejsdp.link/inversify))和`awilix`([nodejsdp.link/awilix](http://nodejsdp.link/awilix))以了解更多信息。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were gently introduced to a set of traditional design patterns
    concerning the creation of objects. Some of those patterns are so basic, and yet
    essential at the same time, that you have probably already used them in one way
    or another.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你被温和地引入了一系列关于对象创建的传统设计模式。其中一些模式既基本又关键，你可能已经在某种方式或另一种方式中使用了它们。
- en: Patterns such as Factory and Singleton are, for example, two of the most ubiquitous
    in object-oriented programming in general. However, in JavaScript, their implementation
    and significance are very different from what was thought up by the *Gang of Four*
    book. For example, Factory becomes a very versatile pattern that works in perfect
    harmony with the hybrid nature of the JavaScript language, that is, half object-oriented
    and half functional. On the other hand, Singleton becomes so trivial to implement
    that it's almost a non-pattern, but it carries a set of caveats that you should
    have learned to take into account.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，工厂模式和单例模式是面向对象编程中最为普遍的两种模式。然而，在JavaScript中，它们的实现和意义与*四人帮*书中所设想的不同。例如，工厂模式变得非常灵活，与JavaScript语言的混合特性（即半面向对象和半函数式）完美地协同工作。另一方面，单例模式变得如此简单易实现，以至于它几乎不是一个模式，但它携带了一系列你应该注意的注意事项。
- en: Among the patterns you've learned in this chapter, the Builder pattern may seem
    the one that has retained most of its traditional object-oriented form. However,
    we've shown you that it can also be used to invoke complex functions and not just
    to build objects.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章你学到的模式中，建造者模式可能看起来是保留其传统面向对象形式最多的一种。然而，我们已经向你展示了它也可以用来调用复杂函数，而不仅仅是构建对象。
- en: The Revealing Constructor pattern, on the other hand, deserves a category of
    its own. Born from necessities arising from the JavaScript language itself, it
    provides an elegant solution to the problem of "revealing" certain private object
    properties at construction time only. It provides strong guarantees in a language
    that is relaxed by nature.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，揭示构造器模式值得一个单独的分类。它源于 JavaScript 语言本身的必要性，为在构造时仅“揭示”某些私有对象属性的问题提供了一个优雅的解决方案。在本质上较为宽松的语言中，它提供了强大的保证。
- en: 'Finally, you learned about the two main techniques for wiring components together:
    Singleton and Dependency Injection. We''ve seen how the first is the simplest
    and most practical approach, while the second is more powerful but also potentially
    more complex to implement.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了将组件连接起来的两种主要技术：单例和依赖注入。我们已经看到了第一种是最简单、最实用的方法，而第二种则更强大，但实施起来可能也更复杂。
- en: As we already mentioned, this was just the first of a series of three chapters
    entirely dedicated to traditional design patterns. In these chapters, we will
    try to teach the right balance between creativity and rigor. We want to show not
    only that there are patterns that can be reused to improve our code, but also
    that their implementation is not the most important detail; in fact, it can vary
    a lot, or even overlap with other patterns. What really matters, however, is the
    blueprint, the guidelines, and the idea at the base of each pattern. This is the
    real reusable piece of information that we can exploit to design better Node.js
    applications in a fun way.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，这仅仅是关于传统设计模式的一系列三个章节中的第一个。在这些章节中，我们将尝试在创造力和严谨性之间找到正确的平衡。我们不仅想展示可以重用来改进我们代码的模式，还想表明它们的实现并不是最重要的细节；实际上，它可以有很大的变化，甚至与其他模式重叠。然而，真正重要的是蓝图、指南和每个模式的基础思想。这是我们可以利用来以有趣的方式设计更好的
    Node.js 应用程序的真实可重用信息块。
- en: In the next chapter, you will learn about another category of traditional design
    patterns, called **structural** patterns. As the name suggests, these patterns
    are aimed at improving the way we combine objects together to build more complex,
    yet flexible and reusable structures.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习另一类传统设计模式，称为 **结构** 模式。正如其名所示，这些模式旨在改进我们组合对象的方式，以构建更复杂、更灵活且可重用的结构。
- en: Exercises
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**7.1 Console color factory**: Create a class called `ColorConsole` that has
    just one empty method called `log()`. Then, create three subclasses: `RedConsole`,
    `BlueConsole`, and `GreenConsole`. The `log()` method of every `ColorConsole`
    subclass will accept a string as input and will print that string to the console
    using the color that gives the name to the class. Then, create a factory function
    that takes color as input, such as `''red''`, and returns the related `ColorConsole`
    subclass. Finally, write a small command-line script to try the new console color
    factory. You can use this Stack Overflow answer as a reference for using colors
    in the console: [nodejsdp.link/console-colors](http://nodejsdp.link/console-colors).'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7.1 控制台颜色工厂**：创建一个名为 `ColorConsole` 的类，该类只有一个名为 `log()` 的空方法。然后，创建三个子类：`RedConsole`、`BlueConsole`
    和 `GreenConsole`。每个 `ColorConsole` 子类的 `log()` 方法将接受一个字符串作为输入，并将该字符串使用赋予类名的颜色打印到控制台。然后，创建一个工厂函数，该函数接受颜色作为输入，例如
    `''red''`，并返回相关的 `ColorConsole` 子类。最后，编写一个小型的命令行脚本以尝试新的控制台颜色工厂。您可以使用以下 Stack Overflow
    答案作为在控制台使用颜色的参考：[nodejsdp.link/console-colors](http://nodejsdp.link/console-colors)。'
- en: '**7.2 Request builder**: Create your own Builder class around the built-in
    `http.request()` function. The builder must be able to provide at least basic
    facilities to specify the HTTP method, the URL, the query component of the URL,
    the header parameters, and the eventual body data to be sent. To send the request,
    provide an `invoke()` method that returns a `Promise` for the invocation. You
    can find the docs for `http.request()` at the following URL: [nodejsdp.link/docs-http-request](http://nodejsdp.link/docs-http-request).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7.2 请求构建器**：围绕内置的 `http.request()` 函数创建自己的 Builder 类。该构建器必须能够提供至少基本的设施来指定
    HTTP 方法、URL、URL 的查询组件、头部参数以及最终要发送的正文数据。为了发送请求，提供一个返回调用 `Promise` 的 `invoke()`
    方法。您可以在以下网址找到 `http.request()` 的文档：[nodejsdp.link/docs-http-request](http://nodejsdp.link/docs-http-request)。'
- en: '**7.3 A tamper-free queue**: Create a `Queue` class that has only one publicly
    accessible method called `dequeue()`. Such a method returns a `Promise` that resolves
    with a new element extracted from an internal `queue` data structure. If the queue
    is empty, then the `Promise` will resolve when a new item is added. The `Queue`
    class must also have a revealing constructor that provides a function called `enqueue()`
    to the executor that pushes a new element to the end of the internal queue. The
    `enqueue()` function can be invoked asynchronously and it must also take care
    of "unblocking" any eventual `Promise` returned by the `dequeue()` method. To
    try out the `Queue` class, you could build a small HTTP server into the executor
    function. Such a server would receive messages or tasks from a client and would
    push them into the queue. A loop would then consume all those messages using the
    `dequeue()` method.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7.3 无篡改队列**：创建一个名为 `Queue` 的类，该类只有一个公开的方法，即 `dequeue()`。该方法返回一个 `Promise`，该
    `Promise` 在从内部 `queue` 数据结构中提取新元素时解析。如果队列为空，则 `Promise` 将在添加新项目时解析。`Queue` 类还必须有一个揭示性的构造函数，该构造函数向执行器提供一个名为
    `enqueue()` 的函数，该函数将新元素推送到内部队列的末尾。`enqueue()` 函数可以异步调用，并且还必须注意“解除”由 `dequeue()`
    方法返回的任何 `Promise`。为了尝试 `Queue` 类，你可以在执行器函数中构建一个小型 HTTP 服务器。这样的服务器将接收来自客户端的消息或任务，并将它们推入队列。然后，循环将使用
    `dequeue()` 方法消费所有这些消息。'
