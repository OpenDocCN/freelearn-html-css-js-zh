- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Creational Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: 'A design pattern is a reusable solution to a recurring problem. The term is
    really broad in its definition and can span multiple domains of an application.
    However, the term is often associated with a well-known set of object-oriented
    patterns that were popularized in the 90s by the book, *Design Patterns: Elements
    of Reusable Object-Oriented Software*, *Pearson Education*, by the almost legendary **Gang
    of Four** (**GoF**): Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.
    We will often refer to these specific sets of patterns as *traditional* design
    patterns or GoF design patterns.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是对重复性问题的一种可重用解决方案。这个术语在定义上非常广泛，可以跨越应用程序的多个领域。然而，这个术语通常与90年代由几乎传奇的**四人帮**（**GoF**）在《设计模式：可复用面向对象软件元素》一书中普及的知名面向对象模式相关联：Erich
    Gamma、Richard Helm、Ralph Johnson和John Vlissides。我们通常会把这些特定的模式集称为**传统**设计模式或GoF设计模式。
- en: Applying this set of object-oriented design patterns in JavaScript is not as
    linear and formal as it would be in a classical object-oriented language. As we
    know, JavaScript is object-oriented, prototype-based, and has dynamic typing.
    It also treats functions as first-class citizens and allows functional programming
    styles. These characteristics make JavaScript a very versatile language, which
    gives tremendous power to the developer but at the same time, it causes fragmentation
    of programming styles, conventions, techniques, and ultimately the patterns of
    its ecosystem. With JavaScript, there are so many ways to achieve the same result
    that each developer has their own opinion on what's the best way to approach a
    problem. A clear demonstration of this phenomenon is the abundance of frameworks
    and opinionated libraries in the JavaScript ecosystem; probably no other language
    has ever seen so many, especially now that Node.js has given new astonishing possibilities
    to JavaScript and has created so many new scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中应用这组面向对象设计模式并不像在经典面向对象语言中那样线性化和正式。正如我们所知，JavaScript是面向对象、基于原型的，并且具有动态类型。它还将函数视为一等公民，并允许函数式编程风格。这些特性使JavaScript成为一种非常灵活的语言，为开发者提供了巨大的力量，但同时也导致了编程风格、约定、技术和最终其生态系统模式的碎片化。使用JavaScript，有如此多的方式可以达到相同的结果，以至于每个开发者都有自己的观点，认为这是解决问题的关键方法。这一现象的明显表现是JavaScript生态系统中框架和有偏见的库的丰富性；可能没有其他语言曾经见过这么多，尤其是在Node.js为JavaScript带来了新的惊人可能性并创造了如此多的新场景之后。
- en: In this context, the nature of JavaScript affects traditional design patterns
    too. There are so many ways in which traditional design patterns can be implemented
    in JavaScript that the traditional, strongly object-oriented implementation stops
    being relevant.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，JavaScript的本质也影响了传统设计模式。在JavaScript中实现传统设计模式的方式有很多，以至于传统的强面向对象实现不再相关。
- en: In some cases, the traditional implementation of these design patterns is not
    even possible because JavaScript, as we know, doesn't have *real* classes or abstract
    interfaces. What doesn't change, though, is the original idea at the base of each
    pattern, the problem it solves, and the concepts at the heart of the solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这些设计模式的传统实现甚至是不可能的，因为正如我们所知，JavaScript没有真正的类或抽象接口。然而，每个模式背后的原始想法、它解决的问题以及解决方案的核心概念并没有改变。
- en: In this chapter and in the two that follow, we will see how some of the most
    important GoF design patterns apply to Node.js and its philosophy, thus rediscovering
    their importance from another perspective. Among these traditional patterns, we
    will also have a look at some "less traditional" design patterns born from within
    the JavaScript ecosystem itself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及接下来的两章中，我们将看到一些最重要的GoF设计模式如何应用于Node.js及其哲学，从而从另一个角度重新发现它们的重要性。在这些传统模式中，我们还将探讨一些从JavaScript生态系统本身诞生的“不那么传统”的设计模式。
- en: In this chapter, in particular, we'll take a look at a class of design patterns
    called **creational**. As the name suggests, these patterns address problems related
    to the creation of objects. For example, the *Factory* pattern allows us to encapsulate
    the creation of an object within a function. The *Revealing Constructor* pattern
    allows us to expose private object properties and methods only during the object's
    creation, while the *Builder* pattern simplifies the creation of complex objects.
    Finally, the *Singleton* pattern and the *Dependency Injection* pattern help us
    with wiring the modules within our applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将特别探讨一类称为**创建型**的设计模式。正如其名称所暗示的，这些模式解决与对象创建相关的问题。例如，*工厂*模式允许我们将对象的创建封装在一个函数中。*揭示构造函数*模式允许我们在对象创建期间仅公开私有对象属性和方法，而*建造者*模式简化了复杂对象的创建。最后，*单例*模式和*依赖注入*模式帮助我们连接应用程序内部的模块。
- en: This chapter, as well as the following two, assume that you have some notion
    of how inheritance works in JavaScript. Please also be advised that we will often
    use generic and more intuitive diagrams to describe a pattern in place of standard
    UML. This is because many patterns can have an implementation based not only on
    classes but also on objects and even functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及接下来的两章假设您已经对JavaScript中的继承机制有所了解。同时，请被告知，我们通常会使用通用且更直观的图表来描述模式，而不是使用标准的UML图。这是因为许多模式不仅可以在类的基础上实现，还可以在对象甚至函数的基础上实现。
- en: Factory
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: We'll begin our journey from one of the most common design patterns in Node.js: **Factory**.
    As you will see, the Factory pattern is very versatile and has more than just
    one purpose. Its main advantage is its ability to decouple the creation of an
    object from one particular implementation. This allows us, for example, to create
    an object whose class is determined at runtime. Factory also allows us to expose
    "a surface area" that is much smaller than that of a class; a class can be extended
    or manipulated, while a factory, being just a function, offers fewer options to
    the user, making it more robust and easier to understand. Finally, a factory can
    also be used to enforce encapsulation by leveraging closures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Node.js中最常见的设计模式之一开始：**工厂**。正如您将看到的，工厂模式非常灵活，不仅仅只有一个用途。其主要优势在于它能够将对象的创建与特定的实现解耦。这使得我们能够创建在运行时确定类的对象。工厂还允许我们暴露比类更小的“表面区域”；类可以被扩展或操作，而工厂作为一个函数，提供给用户的选择更少，使其更健壮且更容易理解。最后，工厂还可以通过利用闭包来强制执行封装。
- en: Decoupling object creation and implementation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解耦对象创建和实现
- en: We already stressed the fact that, in JavaScript, the functional paradigm is
    often preferred to a purely object-oriented design for its simplicity, usability,
    and *small surface area*. This is especially true when creating new object instances.
    In fact, invoking a factory, instead of directly creating a new object from a
    class using the `new` operator or `Object.create()`, is so much more convenient
    and flexible in several respects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经强调过，在JavaScript中，函数式范式通常比纯面向对象设计更受欢迎，因为它简单、易用，且*表面区域小*。这在创建新对象实例时尤其如此。实际上，调用工厂，而不是使用`new`运算符或`Object.create()`直接从类创建新对象，在许多方面都更加方便和灵活。
- en: 'First and foremost, a factory allows us to *separate the creation of an object
    from its implementation*. Essentially, a factory wraps the creation of a new instance,
    giving us more flexibility and control in the way we do it. Inside the factory,
    we can choose to create a new instance of a class using the `new` operator, or
    leverage closures to dynamically build a stateful object literal, or even return
    a different object type based on a particular condition. The consumer of the factory
    is totally agnostic about how the creation of the instance is carried out. The
    truth is that, by using `new`, we are binding our code to one specific way of
    creating an object, while with a factory, we can have much more flexibility, almost
    for free. As a quick example, let''s consider a simple factory that creates an `Image` object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，工厂允许我们 *将对象的创建与其实现分离*。本质上，工厂封装了新实例的创建，使我们能够在创建方式上拥有更多的灵活性和控制。在工厂内部，我们可以选择使用
    `new` 操作符创建一个新实例，或者利用闭包动态构建一个具有状态的字面量对象，甚至根据特定条件返回不同的对象类型。工厂的消费者对实例的创建方式一无所知。事实是，通过使用
    `new`，我们使代码绑定到一种特定的对象创建方式，而使用工厂，我们可以获得几乎免费的更多灵活性。作为一个快速示例，让我们考虑一个简单的工厂，它创建一个 `Image`
    对象：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `createImage()` factory might look totally unnecessary; why not instantiate
    the `Image` class by using the `new` operator directly? Why not write something
    like the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`createImage()` 工厂可能看起来完全没有必要；为什么不直接使用 `new` 操作符实例化 `Image` 类呢？为什么不写点像下面这样的东西呢？'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we already mentioned, using `new` binds our code to one particular type of
    object, which in the preceding case is to the `Image` object type. A factory,
    on the other hand, gives us much more flexibility. Imagine that we want to refactor
    the `Image` class, splitting it into smaller classes, one for each image format
    that we support.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用 `new` 关键字将我们的代码绑定到一种特定的对象类型上，在前面的例子中是绑定到 `Image` 对象类型。另一方面，工厂（factory）提供了更大的灵活性。想象一下，如果我们想要重构
    `Image` 类，将其拆分成更小的类，每个类对应我们支持的每种图像格式。
- en: 'If we exposed a factory as the only means to create new images, we could simply
    rewrite it as follows, without breaking any of the existing code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将工厂作为创建新图像的唯一方式公开，我们可以简单地按照以下方式重写它，而不会破坏任何现有代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our factory also allows us to keep the classes hidden and prevents them from
    being extended or modified (remember the principle of small surface area?). In
    JavaScript, this can be achieved by exporting only the factory, while keeping
    the classes private.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工厂还允许我们隐藏类，并防止它们被扩展或修改（记住小表面面积原则？）。在 JavaScript 中，这可以通过仅导出工厂，同时保持类为私有来实现。
- en: A mechanism to enforce encapsulation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种强制封装的机制
- en: A factory can also be used as an **encapsulation** mechanism, thanks to closures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于闭包，工厂也可以用作 **封装** 机制。
- en: Encapsulation refers to controlling the access to some internal details of a
    component by preventing external code from manipulating them directly. The interaction
    with the component happens only through its public interface, isolating the external
    code from the changes in the implementation details of the component. Encapsulation
    is a fundamental principle of object-oriented design, together with inheritance,
    polymorphism, and abstraction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 封装（Encapsulation）指的是通过阻止外部代码直接操作某些组件的内部细节来控制对这些细节的访问。与组件的交互仅通过其公共接口进行，将外部代码与组件实现细节的变化隔离开来。封装是面向对象设计的基本原则之一，与继承、多态和抽象并列。
- en: 'In JavaScript, one of the main ways to enforce encapsulation is through function
    scopes and closures. A factory makes it straightforward to enforce private variables.
    Consider the following, for example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，强制封装的主要方法之一是通过函数作用域和闭包。工厂使得强制私有变量变得简单直接。例如，考虑以下内容：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we leverage a closure to create two objects: a `person` object,
    which represents the public interface returned by the factory, and a group of `privateProperties` that
    are inaccessible from the outside and that can be manipulated only through the
    interface provided by the `person` object. For example, in the preceding code,
    we make sure that a person''s `name` is never empty; this would not be possible
    to enforce if `name` was just a normal property of the `person` object.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Using closures is not the only technique that we have for enforcing encapsulation.
    In fact, other possible approaches are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Using private class fields (the hashbang `#` prefix syntax), introduced in Node.js
    12\. More on this at [nodejsdp.link/tc39-private-fields](http://nodejsdp.link/tc39-private-fields).
    This is the most modern approach, but at the time of writing, the feature is still
    experimental and has yet to be included in the official ECMAScript specification.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WeakMaps. More on this at [nodejsdp.link/weakmaps-private](http://nodejsdp.link/weakmaps-private).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using symbols, as explained in the following article: [nodejsdp.link/symbol-private](http://nodejsdp.link/symbol-private).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defining private variables in a constructor (as recommended by Douglas Crockford:
    [nodejsdp.link/crockford-private](http://nodejsdp.link/crockford-private)). This
    is the legacy but also the best-known approach.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conventions, for example, prefixing the name of a property with an underscore
    "`_`". However, this does not technically prevent a member from being read or
    modified from the outside.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple code profiler
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s work on a complete example using a factory. Let''s build a simple *code
    profiler*, an object with the following properties:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: A `start()` method that triggers the start of a profiling session
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `end()` method to terminate the session and log its execution time to the console
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by creating a file named `profiler.js`, which will have the following
    content:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Profiler` class we just defined uses the default high resolution timer
    of Node.js to save the current time when `start()` is invoked, and then calculate
    the elapsed time when `end()` is executed, printing the result to the console.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we are going to use such a profiler in a real-world application to calculate
    the execution time of different routines, we can easily imagine the huge amount
    of profiling information printed to the console, especially in a production environment.
    What we may want to do instead is redirect the profiling information to another
    source, for example, a dedicated log file, or alternatively, disable the profiler
    altogether if the application is running in production mode. It's clear that if
    we were to instantiate a `Profiler` object directly by using the `new` operator,
    we would need some extra logic in the client code or in the `Profiler` object
    itself in order to switch between the different logics.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use a factory to abstract the creation of the `Profiler` object
    so that, depending on whether the application runs in production or development
    mode, we can return a fully working `Profiler` instance or a mock object with
    the same interface but with empty methods. This is exactly what we are going to
    do in our `profiler.js` module. Instead of exporting the `Profiler` class, we
    will export only our factory. The following is its code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `createProfiler()` function is our factory and its role is abstracting the
    creation of a `Profiler` object from its implementation. If the application is
    running in production mode, we return `noopProfiler`, which essentially doesn't
    do anything, effectively disabling any profiling. If the application is not running
    in production mode, then we create and return a new, fully functional `Profiler` instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to JavaScript's dynamic typing, we were able to return an object instantiated
    with the `new` operator in one circumstance and a simple object literal in the
    other (this is also known as **duck typing**, and you can read more about it at
    [nodejsdp.link/duck-typing](http://nodejsdp.link/duck-typing)). This confirms
    how we can create objects in any way we like inside the factory function. We could
    also execute additional initialization steps or return a different type of object
    based on particular conditions, all of this while isolating the consumer of the
    object from all these details. We can easily understand the power of this simple
    pattern.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s play with our profiler factory a bit. Let''s create an algorithm
    to calculate all the factors of a given number and use our profiler to record
    its running time:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `profiler` variable contains our `Profiler` object, whose implementation
    will be decided by the `createProfiler()` factory at runtime, based on the `NODE_ENV`
    environment variable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we run the module in production mode, we will get no profiling
    information:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While if we run the module in development mode, we will see the profiling information
    printed to the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The example that we just presented is just a simple application of the factory
    function pattern, but it clearly shows the advantages of separating an object's
    creation from its implementation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In the wild
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said, factories are very common in Node.js. We can find one example in
    the popular *Knex* ([nodejsdp.link/knex](http://nodejsdp.link/knex)) package.
    Knex is a SQL query builder that supports multiple databases. Its package exports
    just a function, which is a factory. The factory performs various checks, selects
    the right dialect object to use based on the database engine, and finally creates
    and returns the Knex object. Take a look at the code at [nodejsdp.link/knex-factory](http://nodejsdp.link/knex-factory).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Builder is a creational design pattern that simplifies the creation of complex
    objects by providing a fluent interface, which allows us to build the object step
    by step. This greatly improves the readability and the general developer experience
    when creating such complex objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The most apparent situation in which we could benefit from the Builder pattern
    is a class with a constructor that has a long list of arguments, or takes many
    complex parameters as input. Usually, these kinds of classes require so many parameters
    in advance because all of them are necessary to build an instance that is complete
    and in a consistent state, so it's necessary to take this into account when considering
    potential solutions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s see the general structure of the pattern. Imagine having a `Boat`
    class with a constructor such as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Invoking such a constructor would create some hard to read code, which is easily
    prone to errors (which argument is what?). Take the following code, for example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A first step to improve the design of this constructor is to aggregate all
    arguments in a single object literal, such as the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can note from the previous code, this new constructor is indeed much
    better than the original one as it allows us to clearly see what is the parameter
    that receives each value. However, we can do even better than this. One drawback
    of using a single object literal to pass all inputs at once is that the only way
    to know what the actual inputs are is to look at the class documentation or, even
    worse, into the code of the class. In addition to that, there is no enforced protocol
    that guides the developers toward the creation of a coherent class. For example,
    if we specify `hasMotor: true`, then we are required to also specify a `motorCount`,
    a `motorBrand,` and a `motorModel`, but there is nothing in this interface that
    conveys this information to us.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The Builder pattern fixes even these last few flaws and provides a fluent interface
    that is simple to read, self-documenting, and that provides guidance toward the
    creation of a coherent object. Let''s take a look at the `BoatBuilder` class,
    which implements the Builder pattern for the `Boat` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To fully appreciate the positive impact that the Builder pattern has on the
    way we create our `Boat` objects, let''s see an example of that:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, the role of our `BoatBuilder` class is to collect all the parameters
    needed to create a `Boat` using some helper methods. We usually have a method
    for each parameter or set of related parameters, but there is not an exact rule
    to that. It is down to the designer of the Builder class to decide the name and
    behavior of each method responsible for collecting the input parameters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'We can instead summarize some general rules for implementing the Builder pattern,
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The main objective is to break down a complex constructor into multiple, more
    readable, and more manageable steps.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to create builder methods that can set multiple related parameters at once.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deduce and implicitly set parameters based on the values received as input by
    a setter method, and in general, try to encapsulate as much parameter setting
    related logic into the setter methods so that the consumer of the builder interface
    is free from doing so.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If necessary, it's possible to further manipulate the parameters (for example,
    type casting, normalization, or extra validation) before passing them to the constructor
    of the class being built to simplify the work left to do by the builder class
    consumer even more.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In JavaScript, the Builder pattern can also be applied to invoke functions,
    not just to build objects using their constructor. In fact, from a technical point
    of view, the two scenarios are almost identical. The major difference when dealing
    with functions is that instead of having a `build()` method, we would have an
    `invoke()` method that invokes the complex function with the parameters collected
    by the builder object and returns any eventual result to the caller.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will work on a more concrete example that makes use of the Builder
    pattern we've just learned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a URL object builder
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to implement a `Url` class that can hold all the components of a standard
    URL, validate them, and format them back into a string. This class in going to
    be intentionally simple and minimal, so for standard production use, we recommend
    the built-in `URL` class ([nodejsdp.link/docs-url](http://nodejsdp.link/docs-url)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement our custom `Url` class in a file called `url.js`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A standard URL is made of several components, so to take them all in, the `Url`
    class'' constructor is inevitably big. Invoking such a constructor can be a challenge,
    as we have to keep track of the argument position to know what component of the
    URL we are passing. Take a look at the following example to get an idea of this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the perfect situation for applying the Builder pattern we just learned.
    Let''s do that now. The plan is to create a `UrlBuilder` class, which has a setter
    method for each parameter (or set of related parameters) needed to instantiate
    the `Url` class. Finally, the builder is going to have a `build()` method to retrieve
    a new `Url` instance that''s been created using all the parameters that have been
    set in the builder. So, let''s implement the builder in a file called `urlBuilder.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This should be pretty straightforward. Just note the way we coupled together
    the `username` and `password` parameters into a single `setAuthentication()` method.
    This clearly conveys the fact that if we want to specify any authentication information
    in the `Url`, we have to provide both `username` and `password`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to try our `UrlBuilder` and witness its benefits over using
    the `Url` class directly. We can do that in a file called `index.js`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the readability of the code has improved dramatically. Each setter
    method clearly gives us a hint of what parameter we are setting, and on top of
    that, they provide some guidance on how those parameters must be set (for example,
    `username` and `password` must be set together).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The Builder pattern can also be implemented directly into the target class.
    For example, we could have refactored the `Url` class by adding an empty constructor
    (and therefore no validation at the object's creation time) and the setter methods
    for the various components, rather than creating a separate `UrlBuilder` class.
    However, this approach has a major flaw. Using a builder that is separate from
    the target class has the advantage of always producing instances that are guaranteed
    to be in a consistent state. For example, every `Url` object returned by `UrlBuilder.build()`
    is guaranteed to be valid and in a consistent state; calling `toString()` on such
    objects will always return a valid URL. The same cannot be said if we implemented
    the Builder pattern on the `Url` class directly. In fact, in this case, if we
    invoke `toString()` while we are still setting the various URL components, its
    return value may not be valid. This can be mitigated by adding extra validations,
    but at the cost of adding more complexity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In the wild
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Builder pattern is a quite common pattern in Node.js and JavaScript as
    it provides a very elegant solution to the problem of creating complex objects
    or invoking complex functions. One perfect example is creating new HTTP(S) client
    requests with the `request()` API from the `http` and `https` built-in modules.
    If we look at its documentation (available at [nodejsdp.link/docs-http-request](http://nodejsdp.link/docs-http-request)),
    we can immediately see it accepts a large amount of options, which is the usual
    sign that the Builder pattern can potentially provide a better interface. In fact,
    one of the most popular HTTP(S) request wrappers, `superagent` ([nodejsdp.link/superagent](http://nodejsdp.link/superagent)),
    aims to simplify the creation of new requests by implementing the Builder pattern,
    thus providing a fluent interface to create new requests step by step. See the
    following code fragment for an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: From the previous code, we can note that this is an unusual builder; in fact,
    we don't have a `build()` or `invoke()` method (or any other method with a similar
    purpose), and have not used the `new` operator. What triggers the request instead
    is an invocation to the `then()` method. It's interesting to note that the `superagent`
    request object is not a promise but rather a custom *thenable* where the `then()`
    method triggers the execution of the request we have built with the builder object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We already discussed *thenables* in *Chapter 5*, *Asynchronous Control Flow
    Patterns with Promises and Async/Await*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the library's code, you will see the Builder pattern in
    action in the `Request` class ([nodejsdp.link/superagent-src-builder](http://nodejsdp.link/superagent-src-builder)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看库的代码，你将看到在`Request`类中构建者模式的应用实例（[nodejsdp.link/superagent-src-builder](http://nodejsdp.link/superagent-src-builder)）。
- en: This concludes our exploration of the Builder pattern. Next, we'll look at the
    Revealing Constructor pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对构建者模式的探索结束。接下来，我们将探讨揭示构造者模式。
- en: Revealing Constructor
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示构造者
- en: 'The Revealing Constructor pattern is one of those patterns that you won''t
    find in the "Gang of Four" book, since it originated directly from the JavaScript
    and the Node.js community. It solves a very tricky problem, which is: how can
    we "reveal" some private functionality of an object only at the moment of the
    object''s creation? This is particularly useful when we want to allow an object''s
    internals to be manipulated only during its creation phase. This allows for a
    few interesting scenarios, such as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示构造者模式是那些你不会在“四人帮”书中找到的模式之一，因为它直接源于JavaScript和Node.js社区。它解决了一个非常棘手的问题，即：我们如何在对象的创建时刻“揭示”对象的某些私有功能？这在当我们希望只允许在对象的创建阶段操作对象的内部时尤其有用。这允许一些有趣的场景，例如：
- en: Creating objects that can be modified only at creation time
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建在创建时只能修改的对象
- en: Creating objects whose custom behavior can be defined only at creation time
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建在创建时只能定义自定义行为的对象
- en: Creating objects that can be initialized only once at creation time
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建在创建时只能初始化一次的对象
- en: 'These are just a few possibilities enabled by the Revealing Constructor pattern.
    But to better understand all the possible use cases, let''s see what the pattern
    is about by looking at the following code fragment:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是揭示构造者模式所启用的可能性中的一小部分。但要更好地理解所有可能的用例，让我们通过查看以下代码片段来了解模式的内容：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see from the previous code, the Revealing Constructor pattern is made
    of three fundamental elements; a **constructor** (1) that takes a function as
    input (the **executor** (2)), which is invoked at creation time and receives a
    subset of the object's internals as input (**revealed members** (3)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从之前的代码中可以看到，揭示构造者模式由三个基本元素组成；一个**构造函数**（1），它接受一个函数作为输入（**执行器**（2）），在创建时被调用，并接收对象内部的一部分作为输入（**揭示成员**（3））。
- en: For the pattern to work, the revealed functionality must otherwise be not accessible
    by the users of the object once it is created. This can be achieved with one of
    the encapsulation techniques we've mentioned in the previous section regarding
    the Factory pattern.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使模式生效，揭示的功能必须在其他情况下不可由对象的用户访问。这可以通过我们在上一节中提到的有关工厂模式的封装技术之一来实现。
- en: Domenic Denicola was the first to identify and name the pattern in one of his
    blog posts, which can be found at [nodejsdp.link/domenic-revealing-constructor](http://nodejsdp.link/domenic-revealing-constructor).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Domenic Denicola是第一个在他的博客文章中识别并命名该模式的人，该文章可以在[nodejsdp.link/domenic-revealing-constructor](http://nodejsdp.link/domenic-revealing-constructor)找到。
- en: Now, let's look at a couple of examples to better understand how the Revealing
    Constructor pattern works.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过几个例子来更好地理解揭示构造者模式的工作原理。
- en: Building an immutable buffer
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建不可变缓冲区
- en: '**Immutable** objects and data structures have many excellent properties that
    make them ideal to use in countless situations in place of their mutable (or changeable)
    counterparts. Immutable refers to the property of an object by which its data
    or state becomes unmodifiable once it''s been created.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变**对象和数据结构具有许多优秀的属性，使它们在无数情况下成为使用它们的可变（或可更改）对应物的理想选择。不可变指的是对象的一个属性，一旦创建，其数据或状态就变得不可修改。'
- en: With immutable objects, we don't need to create **defensive copies** before
    passing them around to other libraries or functions. We simply have a strong guarantee,
    by definition, that they won't be modified, even when they are passed to code
    that we don't know or control.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变对象，我们不需要在将它们传递给其他库或函数之前创建**防御性副本**。我们简单地有一个强有力的保证，根据定义，它们不会被修改，即使它们被传递到我们不知道或无法控制的代码中。
- en: Modifying an immutable object can only be done by creating a new copy and can
    make the code more maintainable and easier to reason about. We do this to make
    it easier to keep track of state changes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 修改不可变对象只能通过创建一个新的副本来完成，这可以使代码更易于维护和推理。我们这样做是为了更容易地跟踪状态变化。
- en: Another common use case for immutable objects is efficient change detection.
    Since every change requires a copy and if we assume that every copy corresponds
    to a modification, then detecting a change is as simple as using the strict equality
    operator (or triple equal `===`). This technique is used extensively in frontend
    programming to efficiently detect if the UI needs refreshing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In this context, let's now create a simple immutable version of the Node.js
    `Buffer` component ([nodejsdp.link/docs-buffer](http://nodejsdp.link/docs-buffer))
    using the Revealing Constructor pattern. The pattern allows us to manipulate an
    immutable buffer only at creation time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement our immutable buffer in a new file called `immutableBuffer.js`,
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s now see how our new `ImmutableBuffer` class works:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: First, we allocate a new Node.js `Buffer` (`buffer`) of the size specified in
    the `size` constructor argument.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create an object literal (`modifiers`) to hold all the methods that
    can mutate the buffer.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we iterate over all the properties (own and inherited) of our internal
    `buffer`, making sure to skip all those that are not functions.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we try to identify if the current `prop` is a method that allows us to
    modify the `buffer`. We do that by trying to match its name with one of the strings
    in the `MODIFIER_NAMES` array. If we have such a method, we bind it to the `buffer`
    instance, and then we add it to the `modifiers` object.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If our method is not a modifier method, then we add it directly to the current
    instance (`this`).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we invoke the `executor` function received as input in the constructor
    and pass the `modifiers` object as an argument, which will allow `executor` to
    mutate our internal `buffer`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In practice, our `ImmutableBuffer` is acting as a **proxy** between its consumers
    and the internal `buffer` object. Some of the methods of the `buffer` instance
    are exposed directly through the `ImmutableBuffer` interface (mainly the read-only
    methods), while others are provided to the `executor` function (the modifier methods).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: We will analyze the Proxy pattern in more detail in *Chapter 8*, *Structural
    Design Patterns*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Please keep in mind that this is just a demonstration of the Revealing Constructor
    pattern, so the implementation of the immutable buffer is intentionally kept simple.
    For example, we are not exposing the size of the buffer or providing other means
    to initialize the buffer. We'll leave this to you as an exercise.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write some code to demonstrate how to use our new `ImmutableBuffer`
    class. Let''s create a new file, `index.js`, containing the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing we can note from the previous code is how the executor function
    uses the `write()` function (which is part of the modifier methods) to write a
    string into the buffer (1). In a similar way, the executor function could've used
    `fill()`, `writeInt8()`, `swap16()` or any other method exposed in the `modifiers`
    object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The code we've just seen also demonstrates how the new `ImmutableBuffer` instance
    exposes only the methods that don't mutate the buffer, such as `readInt8()` (2),
    while it doesn't provide any method to change the content of the buffer (3).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的代码也展示了新的 `ImmutableBuffer` 实例仅暴露不修改缓冲区的方法，例如 `readInt8()`（2），而它不提供任何更改缓冲区内容的方法（3）。
- en: In the wild
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: The Revealing Constructor pattern offers very strong guarantees and for this
    reason, it's mainly used in contexts where we need to provide foolproof encapsulation.
    A perfect application of the pattern would be in components used by hundreds of
    thousands of developers that have to provide unopinionated interfaces and strict
    encapsulation. However, we can also use the pattern in our projects to improve
    reliability and simplify code sharing with other people and teams (since it can
    make an object safer to use by third parties).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示构造函数模式提供了非常强的保证，因此，它主要用在需要提供无懈可击封装的上下文中。该模式的一个完美应用是在由数十万开发者使用的组件中，这些组件必须提供无偏见接口和严格的封装。然而，我们也可以在我们的项目中使用该模式来提高可靠性，并简化与其他人和团队之间的代码共享（因为它可以使对象对第三方更安全）。
- en: 'A popular application of the Revealing Constructor pattern is in the JavaScript
    `Promise` class. Some of you may have already noticed it. When we create a new
    `Promise` from scratch, its constructor accepts as input an `executor` function
    that will receive the `resolve()` and `reject()` functions used to mutate the
    internal state of the `Promise`. Let''s provide a reminder of what this looks
    like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示构造函数模式的一个流行应用是在 JavaScript 的 `Promise` 类中。有些人可能已经注意到了这一点。当我们从头创建一个新的 `Promise`
    时，其构造函数接受一个 `executor` 函数作为输入，该函数将接收用于修改 `Promise` 内部状态的 `resolve()` 和 `reject()`
    函数。让我们回顾一下它的样子：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once created, the `Promise` state cannot be altered by any other means. All
    we can do is receive its fulfilment value or rejection reason using the methods
    we already learned about in *Chapter 5*, *Asynchronous Control Flow Patterns with
    Promises and Async/Await*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，`Promise` 状态就不能通过其他方式更改。我们所能做的就是使用我们在 *第五章* 中学习的方法来接收其实现值或拒绝原因，即 *异步控制流模式与
    Promises 和 Async/Await*。
- en: Singleton
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: Now, we are going to spend a few words on a pattern that is among the most used
    in object-oriented programming, which is the **Singleton** pattern. As we will
    see, Singleton is one of those patterns that has a trivial implementation in Node.js
    that's almost not worth discussing. However, there are a few caveats and limitations
    that every good Node.js developer must know.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将花一些时间讨论在面向对象编程中最常用的模式之一，即 **单例** 模式。正如我们将看到的，单例是那些在 Node.js 中有简单实现且几乎不值得讨论的模式之一。然而，有一些注意事项和限制，每个优秀的
    Node.js 开发者都必须知道。
- en: 'The purpose of the Singleton pattern is to enforce the presence of only one
    instance of a class and centralize its access. There are a few reasons for using
    a single instance across all the components of an application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的目的在于确保一个类只有一个实例，并集中其访问。在应用程序的所有组件中使用单个实例有几个原因：
- en: For sharing stateful information
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了共享有状态信息
- en: For optimizing resource usage
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了优化资源使用
- en: To synchronize access to a resource
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了同步对资源的访问
- en: 'As you can imagine, those are quite common scenarios. Take, for example, a
    typical `Database` class, which provides access to a database:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，这些场景相当常见。以一个典型的 `数据库` 类为例，它提供了对数据库的访问：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Typical implementations of such a class usually keep a pool of database connections,
    so it doesn't make sense to create a new `Database` instance for each request.
    Plus, a `Database` instance may store some stateful information, such as the list
    of pending transactions. So, our `Database` class meets two criterions for justifying
    the Singleton pattern. Therefore, what we usually want is to configure and instantiate
    one single `Database` instance at the start of our application and let every component
    use that single shared `Database` instance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个类的典型实现通常保持一个数据库连接池，因此，为每个请求创建一个新的 `数据库` 实例是没有意义的。此外，一个 `数据库` 实例可能存储一些有状态信息，例如挂起的交易列表。因此，我们的
    `数据库` 类符合单例模式的两项标准。因此，我们通常希望在应用程序开始时配置和实例化一个单一的 `数据库` 实例，并让每个组件使用这个单一的共享 `数据库`
    实例。
- en: 'A lot of people new to Node.js get confused about how to implement the Singleton
    pattern correctly; however, the answer is easier than what we might think. Simply
    exporting an instance from a module is already enough to obtain something very
    similar to the Singleton pattern. Consider, for example, the following lines of
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Node.js的新手对如何正确实现单例模式感到困惑；然而，答案比我们想象的要简单。只需从一个模块中导出一个实例就足以获得非常类似单例模式的东西。例如，以下代码行：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By simply exporting a new instance of our `Database` class, we can already assume
    that within the current package (which can easily be the entire code of our application),
    we are going to have only one instance of the `dbInstance` module. This is possible
    because, as we know from *Chapter 2*, *The Module System*, Node.js will cache
    the module, making sure not to execute its code at every import.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地导出我们`Database`类的新实例，我们就可以假设在当前包内（这可以很容易地是整个应用程序的代码），我们只会有一个`dbInstance`模块的实例。这是因为，正如我们从*第二章*，*模块系统*中了解到的，Node.js会缓存模块，确保在每次导入时不会执行其代码。
- en: 'For example, we can easily obtain a shared instance of the `dbInstance` module,
    which we defined earlier, with the following line of code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以很容易地通过以下代码行获得我们之前定义的`dbInstance`模块的共享实例：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: But there is a caveat. The module is cached using its full path as the lookup
    key, so it is only guaranteed to be a singleton within the current package. In
    fact, each package may have its own set of private dependencies inside its `node_modules`
    directory, which might result in multiple instances of the same package and therefore
    of the same module, resulting in our singleton not really being unique anymore!
    This is, of course, a rare scenario, but it's important to understand what its
    consequences are.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个注意事项。模块是使用其完整路径作为查找键进行缓存的，因此它只保证在当前包内是单例。实际上，每个包在其`node_modules`目录内可能都有自己的私有依赖集，这可能导致同一包和同一模块的多个实例，从而使我们的单例不再真正是唯一的！当然，这是一个罕见的情况，但了解其后果是很重要的。
- en: 'Consider, for example, the case in which the `Database.js` and `dbInstance.js`
    files that we saw earlier are wrapped into a package named `mydb`. The following
    lines of code would be in its `package.json` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以例如，我们之前看到的`Database.js`和`dbInstance.js`文件被封装在一个名为`mydb`的包中的情况为例。以下代码行将位于其`package.json`文件中：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, consider two packages (`package-a` and `package-b`), both of which have
    a single file called `index.js` containing the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑两个包（`package-a`和`package-b`），它们各自都有一个名为`index.js`的单个文件，包含以下代码：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both `package-a` and `package-b` have a dependency on the `mydb` package. However,
    `package-a` depends on version `1.0.0` of the `mydb` package, while `package-b`
    depends on version `2.0.0` of the same package (which, for our example, has an
    identical implementation, but just a different version specified in its `package.json`
    file).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`package-a`和`package-b`都依赖于`mydb`包。然而，`package-a`依赖于`mydb`包的`1.0.0`版本，而`package-b`依赖于同一包的`2.0.0`版本（在我们的例子中，它有一个相同的实现，但在其`package.json`文件中指定了不同的版本）。'
- en: 'Given the structure we just described, we would end up with the following package
    dependency tree:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚才描述的结构，我们最终会得到以下包依赖树：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We end up with a directory structure like the one here because `package-a` and
    `package-b` require two different incompatible versions of the `mydb` module (for
    example, `1.0.0` versus `2.0.0`). In this case, a typical package manager such
    as `npm` or `yarn` would not "hoist" the dependency to the top `node_modules`
    directory, but it will instead install a private copy of each package in an attempt
    to fix the version incompatibility.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到一个像这里这样的目录结构，因为`package-a`和`package-b`需要`mydb`模块的两个不同不兼容版本（例如，`1.0.0`与`2.0.0`）。在这种情况下，一个典型的包管理器，如`npm`或`yarn`，不会将依赖项“提升”到顶层的`node_modules`目录，而是会安装每个包的私有副本，试图解决版本不兼容问题。
- en: With the directory structure we just saw, both `package-a` and `package-b` have
    a dependency on the `mydb` package; in turn, the `app` package, which is our root
    package, depends on both `package-a` and `package-b`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚才看到的目录结构，`package-a`和`package-b`都依赖于`mydb`包；反过来，我们的根包`app`依赖于`package-a`和`package-b`。
- en: 'The scenario we just described will break the assumption about the uniqueness
    of the database instance. In fact, consider the following file (`index.js`) located
    in the root folder of the `app` package:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you run the previous file, you will notice that the answer to *Is the db
    instance in package-a the same as package-b?* is `NO`. In fact, `package-a` and
    `package-b` will actually load two different instances of the `dbInstance` object
    because the `mydb` module will resolve to a different directory, depending on
    the package it is required from. This clearly break the assumptions of the Singleton
    pattern.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: If instead, both `package-a` and `package-b` required two versions of the `mydb`
    package compatible with each other, for example, `^2.0.1` and `^2.0.7`, then the
    package manager would install the `mydb` package into the top-level `node_modules`
    directory (a practice known as **dependency hoisting**), effectively sharing the
    same instance with `package-a`, `package-b`, and the root package.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can easily say that the Singleton pattern, as described in
    the literature, does not exist in Node.js, unless we use a real *global variable*
    to store it, such as the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This guarantees that the instance is the only one shared across the entire application
    and not just the same package. However, please consider that most of the time,
    we don't really need a *pure* singleton. In fact, we usually create and import
    singletons within the main package of an application or, at worst, in a subcomponent
    of the application that has been modularized into a dependency.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: If you are creating a package that is going to be used by third parties, try
    to keep it stateless to avoid the issues we've discussed in this section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, for simplicity, we will use the term singleton to describe
    a class instance or a stateful object exported by a module, even if this doesn't
    represent a real singleton in the strict definition of the term.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to see the two main approaches for dealing with dependencies
    between modules, one based on the Singleton pattern and the other leveraging the
    Dependency Injection pattern.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Wiring modules
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application is the result of the aggregation of several components and,
    as the application grows, the way we connect these components becomes a win or
    lose factor for the maintainability and success of the project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: When a component, A, needs component B to fulfill a given functionality, we
    say that "A is **dependent** on B" or, conversely, that "B is a **dependency**
    of A." To appreciate this concept, let's present an example.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want to write an API for a blogging system that uses a database
    to store its data. We can have a generic module implementing a database connection
    (`db.js`) and a blog module that exposes the main functionality to create and
    retrieve blog posts from the database (`blog.js`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the relationship between the database module
    and the blog module:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![../../../Downloads/Untitled%20Diagram%20(13).png](img/B15729_07_01.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Dependency graph between the blog module and the database module'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to see how we can model this dependency using
    two different approaches, one based on the Singleton pattern and the other using
    the Dependency Injection pattern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Singleton dependencies
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to wire two modules together is by leveraging Node.js' module
    system. Stateful dependencies wired in this way are de facto singletons, as we
    discussed in the previous section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works in practice, we are going to implement the simple blogging
    application that we described earlier using a singleton instance for the database
    connection. Let''s see a possible implementation of this approach (the file `db.js`):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the previous code, we are using SQLite ([nodejsdp.link/sqlite](http://nodejsdp.link/sqlite))
    as a database to store our posts. To interact with SQLite, we are using the module
    `sqlite3` ([nodejsdp.link/sqlite3](http://nodejsdp.link/sqlite3)) from npm. SQLite
    is a database system that keeps all the data in a single local file. In our database
    module, we decided to use a file called `data.sqlite` saved in the same folder
    as the module.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code creates a new instance of the database pointing to our data
    file and exports the database connection object as a singleton with the name `db`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can implement the `blog.js` module:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `blog.js` module exports a class called `Blog` containing three methods:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`initialize()`: Creates the `posts` table if it doesn''t exist. The table will
    be used to store the blog post''s data.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createPost()`: Takes all the necessary parameters needed to create a post.
    It will execute an `INSERT` statement to add the new post to the database.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAllPosts()`: Retrieves all the posts available in the database and returns
    them as an array.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s create a module to try out the functionality of the blog module
    we just created (the file `index.js`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This preceding module is very simple. We retrieve the array with all the posts
    using `blog.getAllPosts()` and then we loop over it and display the data for every
    single post, giving it a bit of formatting.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: You can use the provided `import-posts.js` module to load some sample posts
    into the database before running `index.js`. You can find `import-posts.js` in
    the code repository of this book, along with the rest of the files for this example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: As a fun exercise, you could try to modify the `index.js` module to generate
    HTML files; one for the blog index and then a dedicated file for each blog post.
    This way, you would build your own minimalistic static website generator!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding code, we can implement a very simple command-line
    blog management system by leveraging the Singleton pattern to pass the `db` instance
    around. Most of the time, this is how we manage stateful dependencies in our application;
    however, there are situations in which this may not be enough.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Using a singleton, as we have done in the previous example, is certainly the
    most simple, immediate, and readable solution to pass stateful dependencies around.
    However, what happens if we want to mock our database during our tests? What can
    we do if we want to let the user of the blogging CLI or the blogging API select
    another database backend, instead of the standard SQLite backend that we provide
    by default? For these use cases, a singleton can be an obstacle for implementing
    a properly structured solution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We could introduce `if` statements in our `db.js` module to pick different implementations
    based on some environment condition or some configuration. Alternatively, we could
    fiddle with the Node.js module system to intercept the import of the database
    file and replace it with something else. But, as you can image, these solutions
    are far from elegant.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about another strategy for wiring modules,
    which can be the ideal solution to some of the issues we discussed here.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js module system and the Singleton pattern can serve as great tools
    for organizing and wiring together the components of an application. However,
    these do not always guarantee success. If, on the one hand, they are simple to
    use and very practical, then on the other, they might introduce a tighter *coupling*
    between components.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we can see that the `blog.js` module is *tightly coupled*
    with the `db.js` module. In fact, our `blog.js` module cannot work without the
    `database.js` module by design, nor can it use a different database module if
    necessary. We can easily fix this tight coupling between the two modules by leveraging
    the **Dependency Injection pattern**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency Injection** (**DI**) is a very simple pattern in which the dependencies
    of a component are *provided as input* by an external entity, often referred to
    as the **injector**.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The injector initializes the different components and ties their dependencies
    together. It can be a simple initialization script or a more sophisticated *global
    container* that maps all the dependencies and centralizes the wiring of all the
    modules of the system. The main advantage of this approach is improved decoupling,
    especially for modules depending on stateful instances (for example, a database
    connection). Using DI, each dependency, instead of being hardcoded into the module,
    is received from the outside. This means that the dependent module can be configured
    to use any compatible dependency, and therefore the module itself can be reused
    in different contexts with minimal effort.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates this idea:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![../../../Downloads/Untitled%20Diagram%20(14).png](img/B15729_07_02.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Dependency injection schematic'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7.2*, we can see that a generic service expects a dependency with
    a predetermined interface. It's the responsibility of the **injector** to retrieve
    or create an actual concrete instance that implements such an interface and passes
    it (or "injects it") into the service. In other words, the injector has the goal
    of providing an instance that fulfills the dependency for the service.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this pattern in practice, let''s refactor the simple blogging
    system that we built in the previous section by using DI to wire its modules.
    Let''s start by refactoring the `blog.js` module:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you compare the new version with the previous one, they are almost identical.
    There are only two small but important differences:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We are not importing the database module anymore
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Blog` class constructor takes `db` as an argument
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new constructor argument `db` is the expected dependency that needs to be
    provided at runtime by the client component of the `Blog` class. This client component
    is going to be the injector of the dependency. Since JavaScript doesn't have any
    way to represent abstract interfaces, the provided dependency is expected to implement
    the `db.run()` and `db.all()` methods. This is called duck typing, as mentioned
    earlier in this book.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now rewrite our `db.js` module. The goal here is to get rid of the Singleton
    pattern and to come up with an implementation that is more reusable and configurable:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This new implementation of the `db` module provides a factory function called
    `createDb()`, which allows us to create new instances of the database at runtime.
    It also allows us to pass the path to the database file at creation time so that
    we can create independent instances that can write to different files if we have
    to.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have almost all the building blocks in place, we are only
    missing the injector. We will give an example of the injector by reimplementing
    the `index.js` module:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code is also quite similar to the previous implementation, except for
    two important changes (highlighted in the preceding code):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We create the database dependency (`db`) using the factory function `createDb()`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We explicitly "inject" the database instance when we instantiate the `Blog`
    class.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this implementation of our blogging system, the `blog.js` module is totally
    decoupled from the actual database implementation, making it more composable and
    easy to test in isolation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to inject dependencies as constructor arguments (**constructor injection**),
    but dependencies can also be passed when invoking a function or method (**function
    injection**) or injected explicitly by assigning the relevant properties of an
    object (**property injection**).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the advantages in terms of decoupling and reusability offered
    by the Dependency Injection pattern come with a price to pay. In general, the
    inability to resolve a dependency at *coding time* makes it more difficult to
    understand the relationship between the various components of a system. This is
    especially true in large applications where we might have a significant amount
    of services with a complex dependency graph.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，依赖注入模式在解耦和可重用性方面提供的优势是有代价的。一般来说，在编码时无法解决依赖关系使得理解系统各个组件之间的关系变得更加困难。这在大型应用中尤其如此，我们可能会有大量的服务，并且具有复杂的依赖图。
- en: Also, if we look at the way we instantiated our database dependency in our preceding
    example script, we can see that we had to make sure that the database instance
    was created before we could invoke any function from our `Blog` instance. This
    means that, when used in its raw form, Dependency Injection forces us to build
    the dependency graph of the entire application by hand, making sure that we do
    it in the right order. This can become unmanageable when the number of modules
    to wire becomes too high.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们回顾一下我们之前示例脚本中实例化数据库依赖的方式，我们可以看到我们必须确保在调用我们的`Blog`实例的任何函数之前创建了数据库实例。这意味着，当以原始形式使用时，依赖注入强制我们手动构建整个应用的依赖图，并确保我们以正确的顺序进行。当需要连接的模块数量变得过高时，这可能会变得难以管理。
- en: Another pattern, called **Inversion of Control**, allows us to shift the responsibility
    of wiring the modules of an application to a third-party entity. This entity can
    be a **service locator** (a simple component used to retrieve a dependency, for
    example, `serviceLocator.get('db')`) or a **dependency injection container** (a
    system that injects the dependencies into a component based on some metadata specified
    in the code itself or in a configuration file). You can find more about these
    components on Martin Fowler's blog at [nodejsdp.link/ioc-containers](http://nodejsdp.link/ioc-containers).
    Even though these techniques derail a bit from the Node.js way of doing things,
    some of them have recently gained some popularity. Check out `inversify` ([nodejsdp.link/inversify](http://nodejsdp.link/inversify))
    and `awilix` ([nodejsdp.link/awilix](http://nodejsdp.link/awilix)) to find out
    more.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个称为**控制反转**的模式允许我们将连接应用模块的责任转移到第三方实体。这个实体可以是一个**服务定位器**（一个用于检索依赖的简单组件，例如`serviceLocator.get('db')`）或一个**依赖注入容器**（一个根据代码本身或配置文件中指定的某些元数据将依赖注入到组件中的系统）。你可以在Martin
    Fowler的博客上找到更多关于这些组件的信息，网址为[nodejsdp.link/ioc-containers](http://nodejsdp.link/ioc-containers)。尽管这些技术有点偏离Node.js的做法，但其中一些最近已经获得了一些人气。查看`inversify`([nodejsdp.link/inversify](http://nodejsdp.link/inversify))和`awilix`([nodejsdp.link/awilix](http://nodejsdp.link/awilix))以了解更多信息。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were gently introduced to a set of traditional design patterns
    concerning the creation of objects. Some of those patterns are so basic, and yet
    essential at the same time, that you have probably already used them in one way
    or another.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你被温和地引入了一系列关于对象创建的传统设计模式。其中一些模式既基本又关键，你可能已经在某种方式或另一种方式中使用了它们。
- en: Patterns such as Factory and Singleton are, for example, two of the most ubiquitous
    in object-oriented programming in general. However, in JavaScript, their implementation
    and significance are very different from what was thought up by the *Gang of Four*
    book. For example, Factory becomes a very versatile pattern that works in perfect
    harmony with the hybrid nature of the JavaScript language, that is, half object-oriented
    and half functional. On the other hand, Singleton becomes so trivial to implement
    that it's almost a non-pattern, but it carries a set of caveats that you should
    have learned to take into account.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，工厂模式和单例模式是面向对象编程中最为普遍的两种模式。然而，在JavaScript中，它们的实现和意义与*四人帮*书中所设想的不同。例如，工厂模式变得非常灵活，与JavaScript语言的混合特性（即半面向对象和半函数式）完美地协同工作。另一方面，单例模式变得如此简单易实现，以至于它几乎不是一个模式，但它携带了一系列你应该注意的注意事项。
- en: Among the patterns you've learned in this chapter, the Builder pattern may seem
    the one that has retained most of its traditional object-oriented form. However,
    we've shown you that it can also be used to invoke complex functions and not just
    to build objects.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章你学到的模式中，建造者模式可能看起来是保留其传统面向对象形式最多的一种。然而，我们已经向你展示了它也可以用来调用复杂函数，而不仅仅是构建对象。
- en: The Revealing Constructor pattern, on the other hand, deserves a category of
    its own. Born from necessities arising from the JavaScript language itself, it
    provides an elegant solution to the problem of "revealing" certain private object
    properties at construction time only. It provides strong guarantees in a language
    that is relaxed by nature.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，揭示构造器模式值得一个单独的分类。它源于 JavaScript 语言本身的必要性，为在构造时仅“揭示”某些私有对象属性的问题提供了一个优雅的解决方案。在本质上较为宽松的语言中，它提供了强大的保证。
- en: 'Finally, you learned about the two main techniques for wiring components together:
    Singleton and Dependency Injection. We''ve seen how the first is the simplest
    and most practical approach, while the second is more powerful but also potentially
    more complex to implement.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了将组件连接起来的两种主要技术：单例和依赖注入。我们已经看到了第一种是最简单、最实用的方法，而第二种则更强大，但实施起来可能也更复杂。
- en: As we already mentioned, this was just the first of a series of three chapters
    entirely dedicated to traditional design patterns. In these chapters, we will
    try to teach the right balance between creativity and rigor. We want to show not
    only that there are patterns that can be reused to improve our code, but also
    that their implementation is not the most important detail; in fact, it can vary
    a lot, or even overlap with other patterns. What really matters, however, is the
    blueprint, the guidelines, and the idea at the base of each pattern. This is the
    real reusable piece of information that we can exploit to design better Node.js
    applications in a fun way.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，这仅仅是关于传统设计模式的一系列三个章节中的第一个。在这些章节中，我们将尝试在创造力和严谨性之间找到正确的平衡。我们不仅想展示可以重用来改进我们代码的模式，还想表明它们的实现并不是最重要的细节；实际上，它可以有很大的变化，甚至与其他模式重叠。然而，真正重要的是蓝图、指南和每个模式的基础思想。这是我们可以利用来以有趣的方式设计更好的
    Node.js 应用程序的真实可重用信息块。
- en: In the next chapter, you will learn about another category of traditional design
    patterns, called **structural** patterns. As the name suggests, these patterns
    are aimed at improving the way we combine objects together to build more complex,
    yet flexible and reusable structures.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习另一类传统设计模式，称为 **结构** 模式。正如其名所示，这些模式旨在改进我们组合对象的方式，以构建更复杂、更灵活且可重用的结构。
- en: Exercises
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**7.1 Console color factory**: Create a class called `ColorConsole` that has
    just one empty method called `log()`. Then, create three subclasses: `RedConsole`,
    `BlueConsole`, and `GreenConsole`. The `log()` method of every `ColorConsole`
    subclass will accept a string as input and will print that string to the console
    using the color that gives the name to the class. Then, create a factory function
    that takes color as input, such as `''red''`, and returns the related `ColorConsole`
    subclass. Finally, write a small command-line script to try the new console color
    factory. You can use this Stack Overflow answer as a reference for using colors
    in the console: [nodejsdp.link/console-colors](http://nodejsdp.link/console-colors).'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7.1 控制台颜色工厂**：创建一个名为 `ColorConsole` 的类，该类只有一个名为 `log()` 的空方法。然后，创建三个子类：`RedConsole`、`BlueConsole`
    和 `GreenConsole`。每个 `ColorConsole` 子类的 `log()` 方法将接受一个字符串作为输入，并将该字符串使用赋予类名的颜色打印到控制台。然后，创建一个工厂函数，该函数接受颜色作为输入，例如
    `''red''`，并返回相关的 `ColorConsole` 子类。最后，编写一个小型的命令行脚本以尝试新的控制台颜色工厂。您可以使用以下 Stack Overflow
    答案作为在控制台使用颜色的参考：[nodejsdp.link/console-colors](http://nodejsdp.link/console-colors)。'
- en: '**7.2 Request builder**: Create your own Builder class around the built-in
    `http.request()` function. The builder must be able to provide at least basic
    facilities to specify the HTTP method, the URL, the query component of the URL,
    the header parameters, and the eventual body data to be sent. To send the request,
    provide an `invoke()` method that returns a `Promise` for the invocation. You
    can find the docs for `http.request()` at the following URL: [nodejsdp.link/docs-http-request](http://nodejsdp.link/docs-http-request).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7.2 请求构建器**：围绕内置的 `http.request()` 函数创建自己的 Builder 类。该构建器必须能够提供至少基本的设施来指定
    HTTP 方法、URL、URL 的查询组件、头部参数以及最终要发送的正文数据。为了发送请求，提供一个返回调用 `Promise` 的 `invoke()`
    方法。您可以在以下网址找到 `http.request()` 的文档：[nodejsdp.link/docs-http-request](http://nodejsdp.link/docs-http-request)。'
- en: '**7.3 A tamper-free queue**: Create a `Queue` class that has only one publicly
    accessible method called `dequeue()`. Such a method returns a `Promise` that resolves
    with a new element extracted from an internal `queue` data structure. If the queue
    is empty, then the `Promise` will resolve when a new item is added. The `Queue`
    class must also have a revealing constructor that provides a function called `enqueue()`
    to the executor that pushes a new element to the end of the internal queue. The
    `enqueue()` function can be invoked asynchronously and it must also take care
    of "unblocking" any eventual `Promise` returned by the `dequeue()` method. To
    try out the `Queue` class, you could build a small HTTP server into the executor
    function. Such a server would receive messages or tasks from a client and would
    push them into the queue. A loop would then consume all those messages using the
    `dequeue()` method.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7.3 无篡改队列**：创建一个名为 `Queue` 的类，该类只有一个公开的方法，即 `dequeue()`。该方法返回一个 `Promise`，该
    `Promise` 在从内部 `queue` 数据结构中提取新元素时解析。如果队列为空，则 `Promise` 将在添加新项目时解析。`Queue` 类还必须有一个揭示性的构造函数，该构造函数向执行器提供一个名为
    `enqueue()` 的函数，该函数将新元素推送到内部队列的末尾。`enqueue()` 函数可以异步调用，并且还必须注意“解除”由 `dequeue()`
    方法返回的任何 `Promise`。为了尝试 `Queue` 类，你可以在执行器函数中构建一个小型 HTTP 服务器。这样的服务器将接收来自客户端的消息或任务，并将它们推入队列。然后，循环将使用
    `dequeue()` 方法消费所有这些消息。'
