<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Connecting Your Alexa Skills to External APIs</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will expand upon the basics we learned from the previous chapter, to improve the functionality and user experience of Alexa. We'll increase the functionality by learning to use external APIs to interact with services provided by other people. Then, we'll increase the user experience by giving our chatbot some memory of the existing conversation and also using a <strong>speech synthesis markup language</strong> (<strong>SSML</strong>) to control the way that Alexa talks to the user.</p>
<p>To enable us to learn this, we're going to build a weather skill for Alexa. You will be able to ask for the current or five-day forecast for 200,000 cities across the world.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Accessing and interacting with an external API</li>
<li><span>Storing session memory using session attributes</span></li>
<li><span>Using SSML to control the way that Alexa talks with the user</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will be creating a Lambda function for our skill, and we will deploy it using the local development setup that we discussed in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>.</p>
<p>We'll be using the <strong>Open Weather Map API</strong> to get weather data based on the user requests. We will go through the process of creating an account and getting an API key.</p>
<p class="mce-root"/>
<p>We'll use Postman to test the requests that we are going to make to the Open Weather Map API. It is a cross-platform app that can be installed at <a href="https://www.getpostman.com/">getpostman.com</a>.</p>
<p>All of the code required for this chapter can be found at <a href="http://bit.ly/chatbot-ch4">http://bit.ly/chatbot-ch4</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">External APIs</h1>
                </header>
            
            <article>
                
<p>An <strong>Application Programming Interface</strong> (<strong>API</strong>) is an interface that you can send requests to, and it will give you a response. These are used to let other people control parts of your software, whether that is getting information from the API database, changing a user's settings, or getting the API to send a text.</p>
<p>They are a very powerful tool for developers, giving you access to more data and services than you could ever gather or build on your own.</p>
<p>External APIs don't have to be built by someone else. If you have a system that you want to access from the chatbot, you can add API access, or you might already have an API built for it. Using an API to separate sections of your code or company can be a good way to allow and improve modularization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Open Weather Map API</h1>
                </header>
            
            <article>
                
<p>The Open Weather Map API is a very powerful API that lets you get the current weather as well as the weather forecast for 200,000 cities around the world. The best part is that there is a free tier that allows you to make 60 requests a minute about current weather and five-day forecasts. This allows us to develop an Alexa Skill that uses real-world data without subscribing to a monthly fee.</p>
<p>To access this API, we need to create an account to get an API key. Go to <a href="https://home.openweathermap.org">OpenWeatherMap.org</a> and go to <span class="packt_screen">Sign Up</span> in the upper-right corner of the page. Enter your details, read the terms and conditions, and sign up. You'll then be prompted to give the reason that you are using the API. There's no <em>Alexa</em> option, so you can choose <span class="packt_screen">Mobile apps development,</span> as that is the closest to our real usage.</p>
<p>Now that you're logged in, you can access your API key. This is used on any request you make to the API so that it can check that you have the right permissions for making the request. Navigate to <span class="packt_screen">API keys,</span> and find the <span class="packt_screen">Default</span> key for your account. We'll be using that key throughout this project to make sure that you can find it again:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5d8aea21-53b3-47ae-be0c-29d82ddbaf9d.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">OpenWeatherMap API key</div>
<p><span>With our API key, we can now look at the requests we can make. On the</span> <span class="packt_screen">API</span> page<span>, there is a list of different APIs, but the ones that we have access to are</span> <span class="packt_screen">Current weather data</span> <span>and</span> <span class="packt_screen">5 day /  3-hour forecast</span><span>. Underneath each of these sections is a button to go to the</span> <span class="packt_screen">API doc,</span> <span>and we're going to look at the API docs for</span> <span class="packt_screen">Current weather data</span>.</p>
<div>
<p>There are three ways to request the data on the <span class="packt_screen">Current weather data</span> API: <span class="packt_screen">Call current weather data for one location</span>, <span class="packt_screen">Call current weather data for several cities</span>, and <span class="packt_screen">Bulk downloading</span>. We're only going to be getting data for one location at a time.</p>
<p>Within the <span class="packt_screen">Call current weather data for one location</span> section, there are also a few different ways to select the area. You can provide the city name, city ID, geographic coordinates, or the ZIP code. The user is going to be telling us a city name, so it makes the most sense to use that data.</p>
<p>There are two ways to get the current weather data for a city by name:</p>
<pre>https://api.openweathermap.org/data/2.5/weather?q={city name}<br/>https://api.openweathermap.org/data/2.5/weather?q={city name},{country code}</pre>
<p>Whenever we call either of these endpoints, we will get a response in a predefined format. It is good to know how the data will be returned so we can deal with it properly inside our skill. The <span class="packt_screen">Weather parameters in API respond</span> section of the web page gives us examples of responses, as well as a list of the features, with a short description of each. This is an example of the response that can come back from a request:</p>
<pre>{<br/>    "city": {<br/>        "id":1851632,<br/>        "name":"Shuzenji",<br/>        "coord": { "lon":138.933334, "lat":34.966671 },<br/>        "country": "JP",<br/>        "cod":"200",<br/>        "message":0.0045,<br/>        "cnt":38,<br/>        "list":[{<br/>            "dt":1406106000,<br/>            "main":{<br/>                "temp":298.77,<br/>                "temp_min":298.77,<br/>                "temp_max":298.774,<br/>                "pressure":1005.93,<br/>                "sea_level":1018.18,<br/>                "grnd_level":1005.93,<br/>                "humidity":87,<br/>                "temp_kf":0.26},<br/>            "weather":[{"id":804,"main":"Clouds","description":"overcast clouds","icon":"04d"}],<br/>            "clouds":{"all":88},<br/>            "wind":{"speed":5.71,"deg":229.501},<br/>            "sys":{"pod":"d"},<br/>            "dt_txt":"2014-07-23 09:00:00"<br/>        }]<br/>    }<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our weather skill</h1>
                </header>
            
            <article>
                
<p>Creating the weather skill is going to follow the same steps as the previous skills that we have created. This is a great process to follow whenever you are creating any new Alexa skill. To recap the process, it is as follows:</p>
<ul>
<li>Create a conversational flow from perfect conversations</li>
<li>Create the skill on Alexa Skills Kit, including all intents, slots, and utterances</li>
<li>Create the Lambda to handle the requests</li>
<li>Test the skill</li>
<li>Improve the skill</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conversation flow design</h1>
                </header>
            
            <article>
                
<p>Most of the conversations that the users will have with this skill are quite simple. There are only really two things that the user can ask about: the location and the data for the forecast. Here is an example of a perfect conversation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/02458ac1-95bd-4e64-9bed-a0b0c17cd516.png" style=""/></div>
<div class="ImageCaption packt_figref CDPAlignCenter CDPAlign"><span><span>Weather conversation</span></span></div>
<div>
<p>The interesting thing about this conversation is that both the questions are similar. What is the weather in {location} {date}?</p>
<p>This means that we can handle them both with a single intent. That intent needs to check whether they have given a location and a date and then use those two things to call the API. The flow diagram for this intent will look as follows:</p>
</div>
<div class="CDPAlignCenter CDPAlign"><img src="assets/23161391-e49a-459b-ba12-5883e114a3cf.png" style=""/></div>
<div class="ImageCaption packt_figref CDPAlignCenter CDPAlign"><span><span>Weather flow diagram</span></span></div>
<div>
<p>The difference between this flow and the flows that we've worked with before is that the user can go through one intent multiple times in one conversation, usually with different slot values. We could build separate intents for <kbd>current weather</kbd>, <kbd>weather change Date</kbd>, and <kbd>weather change location</kbd>, but they would all do similar things.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the skill on Alexa Skills Kit</h1>
                </header>
            
            <article>
                
<p>We need to get started using the Alexa Skills Kit developer console. Click the <span class="packt_screen">Create Skill</span> button, name your skill, and select <span class="packt_screen">Custom</span> as the skill type.</p>
<p>The first thing that we do whenever we create a new skill adds an invocation phrase.</p>
<div class="packt_infobox">Doing it as soon as you create the skill means that you don't forget to fill it in later. You can change the phrase at any point before you publish your skill.</div>
<p>Next, we need to create our <kbd>getWeather</kbd> intent. Add a new custom intent called <kbd>getWeather</kbd> and then we can start filling the intent out.</p>
<p>Users are going to trigger this intent with lots of different utterances. We're also going to learn how to populate slots from the user utterance. Start by adding our two slots to the intent, <kbd>location</kbd> and <kbd>date</kbd>. The slot type for location can be <span class="packt_screen">AMAZON.US_CITY</span>, and data can be <span class="packt_screen">AMAZON.DATE</span>. You can select <kbd>GB_CITY</kbd>, <kbd>AT_CITY</kbd>, <kbd>DE_CITY</kbd>, or <kbd>EUROPE_CITY</kbd> if you want a better city recognition for your area:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0a23cab3-658d-41b0-8641-f950cd9bf8a2.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Intent slots</div>
<p>With the slots created, we can create our utterances. These utterances will be different than our normal utterances, as we need to fill the slots at the same time. This can be demonstrated with an utterance such as <kbd>what is the weather like in London</kbd>. The slot that we are trying to fill is a <kbd>location</kbd> with the value of <kbd>London</kbd>. To capture this slot, we can use a curly brace method where the intent becomes <kbd>what is the weather like in {location}</kbd>. This means that whatever value is typed instead of <kbd>{location}</kbd> will be captured and stored in the <span class="packt_screen">location</span> slot.</p>
<p>This can be done for other similar utterances. <kbd>What about tomorrow</kbd> becomes <kbd>what about {date}</kbd> and an utterance of <kbd>what is the weather like tomorrow in New York</kbd> becomes <kbd>what is the weather like {date} in {location}</kbd>. This capture of slots from the initial utterance is very powerful, as it means that we don't have to ask the user for the value of each slot. Asking a series of questions like that results in a very unnatural conversation. Here are a few examples of sample utterances:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/5fcc1505-d45c-44fb-adf4-9c19d671c8a6.png" style=""/></div>
<div class="ImageCaption packt_figref CDPAlignCenter CDPAlign"><span><span>Get weather utterances</span></span></div>
<div>
<p>With the intent slots and utterances completed, we can get the skill ID from the <span class="packt_screen">Endpoint</span> section before moving on to creating the Lambda to handle the requests.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building Lambda to handle the requests</h1>
                </header>
            
            <article>
                
<p>To create our Lambda, we can create a new folder within our <kbd>Lambdas</kbd> folder and call it <kbd>weatherGods</kbd>. Inside that folder, we can create an <kbd>index.js</kbd> file in which we will create our handler. To start, copy the text from the <kbd>boilerplate Lambda</kbd> folder in this chapter's code repository. We also need to run <kbd>npm init</kbd> so that we can install <kbd>npm</kbd> packages later on.</p>
<p>Before starting on the main code, we need to modify our <kbd>LaunchRequestHandler</kbd>. This can be done by changing the <kbd>speechText</kbd> variable. For this skill, we can enter a response message of <kbd>"You may ask the weather gods about the weather in your city or for a weather forecast"</kbd>. This prompts the user to say a phrase that will trigger the <kbd>getWeather</kbd> intent.</p>
<p>Now we can start on the logic to get the user the weather information that they want. We need to create another handler that will deal with the <kbd>getWeather</kbd> requests:</p>
<pre>const GetWeatherHandler = {<br/>    canHandle(handlerInput) {<br/>        return handlerInput.requestEnvelope.request.type === 'IntentRequest' &amp;&amp;<br/>            handlerInput.requestEnvelope.request.intent.name === 'getWeather';<br/>    },<br/>    handle(handlerInput) {}<br/>}</pre>
<p>Before we can get the weather, we need to check that we have values for the location and the date. If we don't have values for either of these, we need to get them:</p>
<pre>const { slots } = this.event.request.intent;<br/>let { location, date } = slots;<br/>location = location.value || null;<br/>date = date.value || null;<br/> <br/>if (!location) { <br/>    let slotToElicit = 'location';<br/>    let speechOutput = 'Where do you desire to know the weather';<br/>    return handlerInput.responseBuilder<br/>        .speak(speechOutput)<br/>        .addElicitSlotDirective(slotToElicit)<br/>        .getResponse();<br/>}<br/>if (!date){<br/>    date = Date.now()<br/>}</pre>
<p>You will probably notice that the missing location and date are handled differently. If the location is missing, then we ask the user for the location. If we are missing the date, we set the date to <kbd>Date.now()</kbd>. This is a design choice because it feels more natural to say <kbd>"What's the weather like in LA?"</kbd> than <kbd>"What's the weather like in LA now?"</kbd>. It is often the smaller details such as this that make talking with a good chatbot so much better.</p>
<p>We know that we have a location and a date so can proceed with the rest of the logic. With the location and the date, we can make the request to the Open Weather Maps API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making an API request</h1>
                </header>
            
            <article>
                
<p>Making a request to an API consists of using a <kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>POST</kbd>, or <kbd>DELETE</kbd> method on a URL with some optional data. A well-designed API will be designed to have most of the information about the request in the URL. This means that we will be changing the URL based on the user choices.</p>
<p>For the Open Weather Maps API, the URLs that we need to send our requests to are structured as follows:</p>
<ul>
<li>For current weather: <a href="https://api.openweathermap.org/data/2.5/weather?q=%7B%24city%7D,us">https://api.openweathermap.org/data/2.5/weather?q={$city},us</a></li>
<li>For a five-day forecast: <a href="https://api.openweathermap.org/data/2.5/forecast?q=%24%7Bcity%7D,us">https://api.openweathermap.org/data/2.5/forecast?q=${city},us</a></li>
</ul>
<p>Unfortunately, the API needs us to define a country code. In this example, we should use <em>US</em>, as we selected <span class="packt_screen">US_CITY</span> as our slot type. If you chose a different slot type, make sure to enter the <kbd>ISO 3166</kbd> code for your country.</p>
<p>To make a request to these URLs, we need to use a request library. There is an <kbd>HTTP</kbd> standard library built into a node that can make requests, but there are some other libraries that make our life much simpler. The one we will be using is called <kbd>axios</kbd>. There are two main reasons to use <kbd>axios</kbd> over the standard <kbd>HTTP</kbd> library:</p>
<ul>
<li>It is more user-friendly</li>
<li>It is <em>promise-based</em>, so you control the flow of the data</li>
</ul>
<p class="mce-root"/>
<p>To make a request using <kbd>axios</kbd>, we first need to install it and require it in. Navigate to your <kbd>weatherGods</kbd> Lambda folder and run <kbd>npm install --save axios</kbd> and add <kbd>const axios = require('axios');</kbd> to the top of the <kbd>index.js</kbd> file.</p>
<p>Making a request can now be as simple as adding this line of code wherever we want to make the request:</p>
<pre>axios.get(*URL*)</pre>
<p>For our requests, we will also need to pass in our API key. For the Open Weather Maps API, we need to add a query string of <kbd>appid=${process.env.API_KEY}</kbd> at the end of our URL.</p>
<p>We store our API key in environment variables so that it never gets committed to source control (GIT), where it could be accessed by someone else. They can be accessed and changed in your Lambda console. To store an environment variable, scroll down in your Lambda console to <em><span class="packt_screen">Environment variables</span></em> and enter the key and value you want to store:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ff9c3ffe-1b75-42fc-aa84-ae9d4a18722f.png"/></div>
<div class="ImageCaption packt_figref CDPAlignCenter CDPAlign"><span>Environment variables</span></div>
<p>While we make the request, we have no access to the result. There are a few different ways to get the result from a Promise, but we're going to use <kbd>async</kbd> and <kbd>await</kbd> to keep our code as clean and readable as possible. To get <kbd>async</kbd> and <kbd>await</kbd> working, we need to modify our handler function slightly. Where we have declared the input values, we need to declare that this function is an <kbd>async</kbd> function. We also need to check that our Lambda is running node 8.10 so it supports <kbd>async</kbd> functions. If you are using the build script that we created in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>, then all of our functions are automatically set up using node 8.10, but you can always check by looking at the runtime on your Lambda Console. We make our handle method asynchronous by adding <kbd>async</kbd> before the method name:</p>
<pre>async handle(handlerInput) {}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>To get the results from a promise using <kbd>async</kbd> and <kbd>await</kbd>, we need to put an <kbd>await</kbd> before the promise. This means that the rest of the code won't start running until the promise has returned:</p>
<pre>let result = await promise();</pre>
<p>Now that we've had a quick introduction to <kbd>axios</kbd> and <kbd>async</kbd>/<kbd>await</kbd>, we can start writing the requests that we are going to make. Because we have different URLs for <em>current weather</em> and <em>weather forecast</em>, we need to check whether the date selected is the current date or whether they are looking for a forecast.</p>
<p>Comparing dates is a surprisingly complicated task, so we are going to use an <kbd>npm</kbd> package to make it much easier. This package is called <kbd>moment</kbd>, and it is a package that is made to work with dates. Install it to our Lambda using <kbd>npm install --save moment</kbd> and then require it into Lambda by adding <kbd>const moment = require('moment'); moment().format();</kbd> to the top of our <kbd>index.js</kbd> file.</p>
<p>Back in <kbd><span><span>handler</span></span></kbd>, we can add the following check:</p>
<pre>let isToday = moment(date).isSame(Date.now(), 'day');<br/> <br/>if (isToday) {<br/>    // lookup todays weather<br/>} else {<br/>    // lookup forecast<br/>}</pre>
<p>Next, we need to add in the request that we are going to make to <kbd>openWeatherMaps</kbd>. The response that we get from <kbd>axios</kbd> is all of the information about the request. Because we only care about the data that is returned, we can destructure the response and rename the data. Destructuring allows us to select a key from an object and name it as something else:</p>
<pre>let { key: newKeyName } = { key: 'this is some data' };</pre>
<p>We can use this destructuring to rename the current weather data and forecast data differently, to avoid future confusion:</p>
<pre>if (isToday) {<br/>    let { data: weatherResponse } = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${location},us&amp;&amp;appid=${process.env.API_KEY}');<br/>} else {<br/>    let { data: forecastResponse } = await axios.get(`https://api.openweathermap.org/data/2.5/forecast?q=${location},us&amp;&amp;appid=${process.env.API_KEY}`);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>With the responses from these requests, we need to extract the information that we want to send to the user. For this, we need to know the data that we're going to receive and the data we want at the end.</p>
<p>One great way to check the exact data you will receive is to make test requests to the API. A great tool for making API requests is <a href="https://www.getpostman.com/">Postman</a>, as it allows you to make <kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd> requests and see the results. To test our API request, we can open Postman and put <kbd>https://api.openweathermap.org/data/2.5/weather?q={$location},us,&amp;APPID=${API_KEY}</kbd> into the request bar. Before making the request, just change <kbd>${location}</kbd> to be a test city and <kbd>${API_KEY}</kbd> to be the API key that we generated on the Open Weather Map website. It should look something like this: <kbd>https://api.openweathermap.org/data/2.5/weather?q=manchester,us,&amp;APPID=12345678</kbd>.</p>
<p>From this request, we will get a result similar to this:</p>
<pre>{<br/>    "coord": {<br/>        "lon": -71.45,<br/>        "lat": 43<br/>    },<br/>    "weather": [<br/>        {<br/>            "id": 500,<br/>            "main": "Rain",<br/>            "description": "light rain",<br/>            "icon": "10n"<br/>        },<br/>        {<br/>            "id": 701,<br/>            "main": "Mist",<br/>            "description": "mist",<br/>            "icon": "50n"<br/>        }<br/>    ],<br/>    "base": "stations",<br/>    "main": {<br/>        "temp": 283.98,<br/>        "pressure": 1016,<br/>        "humidity": 93,<br/>        "temp_min": 282.15,<br/>        "temp_max": 285.15<br/>    },<br/>    "visibility": 16093,<br/>    "wind": {<br/>        "speed": 1.21,<br/>        "deg": 197<br/>    },<br/>    "clouds": {<br/>        "all": 90<br/>    },<br/>    "dt": 1526794800,<br/>    "sys": {<br/>        "type": 1,<br/>        "id": 1944,<br/>        "message": 0.0032,<br/>        "country": "US",<br/>        "sunrise": 1526807853,<br/>        "sunset": 1526861265<br/>    },<br/>    "id": 5089178,<br/>    "name": "Manchester",<br/>    "cod": 200<br/>}</pre>
<p>From this data, the information that we are likely to want to tell the user will come from the weather and the main sections, with the rest of the data being less relevant for us. To remove this information, we can use destructuring again:</p>
<pre>let { weather, main: { temp, humidity } } = weatherResponse;</pre>
<p>We need to do the same for the forecast requests. The data is different, so we will need to do a bit more processing to extract the data we want:</p>
<pre>let { list } = forecastResponse;<br/>let usefulForecast = list.map(weatherPeriod =&gt; {<br/>    let { dt_txt, weather, main: { temp, humidity } } = weatherPeriod;<br/>    return  { dt_txt, weather, temp, humidity }<br/>});</pre>
<p>We now have forecast data for every three hours for the next five days. This is too much data to try to tell a user, even if they are only asking for a single day. To cut the data down, we can reduce the forecast to one at 9:00 and one at 18:00. We can use a filter on the <kbd>usefulForecast</kbd> array so that the <kbd>dt_txt</kbd> has to end at <kbd>09:00:00</kbd> or <kbd>18:00:00</kbd>:</p>
<pre>let reducedForecast = usefulForecast.filter(weatherPeriod =&gt; {<br/>    let time = weatherPeriod.dt_txt.slice(-8);<br/>    return time === '09:00:00' || time === '18:00:00';<br/>});</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We can now get the two forecasts for the day that the user requested. We can use <kbd>moment</kbd> again to compare the results and the date selected by the user:</p>
<pre>let dayForecast = reducedForecast.filter(forecast =&gt; {<br/>    return moment(date).isSame(forecast.dt_txt, 'day');<br/>});</pre>
<p>We should now have an array that contains two forecasts with the weather, temperature, and humidity for 9:00 and 18:00 on the day the user asked about.</p>
<p>With the data for the current weather and forecasts, we can start to create the user response. We'll start with a current weather request. We can use template strings to make the formatting easy. You can modify the phrasing or the structure all that you want, as long as you use the correct variables:</p>
<pre>let speechText = `The weather in ${location} has ${weatherString} with a temperature of ${formattedTemp} and a humidity of ${humidity} percent`;</pre>
<p>You have probably noticed that we used two variables that we haven't defined yet. Let's look into that.</p>
<p>The <kbd>weatherString</kbd> needs to be made from the array of weather types that are currently happening. To deal with these, we can create a new function that takes the <kbd>weather</kbd> array and returns a string that is more human-/Alexa-readable. This function should be placed outside of the handlers object as a new function declaration:</p>
<pre>const formatWeatherString = weather =&gt; {<br/>    if (weather.length === 1) return weather[0].description<br/>    return weather.slice( 0, -1 ).map( item =&gt; item.description ).join(', ') + ' and ' + weather.slice(-1)[0].description;<br/>}</pre>
<p>If there is only one weather type, this function returns the description. When there is more than one weather type, insert a comma between the types, apart from the last one, where it uses <kbd>and</kbd> to add it on. This would create strings such as <em>broken clouds, light rain and mist</em>.</p>
<p>Next, we need to convert the temperature into a scale that more people understand. The temperature we're given is in Kelvin, so we need to convert it to Celsius or Fahrenheit. I have provided the functions for both, but we only need to use one in our Lambda:</p>
<pre>const tempC = temp =&gt; Math.floor(temp - 273.15) + ' degrees Celsius ';<br/> <br/>const tempF = temp =&gt; Math.floor(9/5 *(temp - 273) + 32) + ' Fahrenheit';</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Back inside our <kbd>getWeather</kbd> handler, we can now add the calls to these functions to our <kbd>isToday</kbd> if block. You can comment out the temperature function you don't want to use:</p>
<pre>let weatherString = formatWeatherString(weather);<br/>let formattedTemp = tempC(temp);<br/>// let formattedTemp = tempF(temp);</pre>
<p>Now that we have everything that we need to create the <kbd>speechText</kbd> variable that will be passed to the user, we need to follow a similar set of steps for the forecast data. We can start with the phrase that we want to build, which is a bit longer and more complex than the first one:</p>
<pre>let speechText = ` The weather in ${location} ${date} will have ${weatherString[0]} with a temperature of ${formattedTemp[0]} and a humidity of ${humidity[0]} percent, whilst in the afternoon it will have ${weatherString[1]} with a temperature of ${formattedTemp[1]} and a humidity of ${humidity[1]} percent`</pre>
<p>To populate these variables, we need to use the <span>forma</span><span>t</span> <kbd>formatWeatherString()</kbd> and <kbd>tempC()</kbd> functions on both elements in the <kbd>dayForecast</kbd> array. You can switch <kbd>tempC()</kbd> for <kbd>tempC()</kbd> if you want to use Fahrenheit:</p>
<pre>let weatherString = dayForecast.map(forecast =&gt; formatWeatherString(forecast.weather));<br/>let formattedTemp = dayForecast.map(forecast =&gt; tempC(forecast.temp));<br/>let humidity = dayForecast.map(forecast =&gt; forecast.humidity);</pre>
<p>This will put the morning forecasts into the first index of the arrays as we required in our <kbd>speechText</kbd> string.</p>
<p>Now that we have the string responses for current weather and forecasts, we need to tell the user: </p>
<pre>return handlerInput.responseBuilder<br/>    .speak(speechText)<br/>    .getResponse();</pre>
<p>Once we save this function, we are ready to deploy this Lambda. With our build script, this is done by navigating into the main Lambda folder and running <kbd>./build.sh weatherGods</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Final setup and testing</h1>
                </header>
            
            <article>
                
<p>With the Lambda created and uploaded, we can finish the last steps of the setup and then test out our skill. There are two things that we need to do before the skill starts working:</p>
<ul>
<li>Add <span class="packt_screen">Alexa Skills Kit</span> as a trigger to the Lambda</li>
<li>Add the <span class="packt_screen">Lambda ARN</span> to the skill endpoint</li>
</ul>
<p>We've done this all twice before, so this will be a brief guide. Open the Lambda Console and navigate into the <kbd>weatherGods</kbd> Lambda. In the <span class="packt_screen">Designer</span> section, add the <span class="packt_screen">Alexa Skills Kit</span> as a trigger and then add the <span class="packt_screen">Skill ID</span> to the configuration window, and save the Lambda. Copy the<span class="packt_screen"><span> </span>ARN</span><span> of the Lambda and navigate</span> into the <span class="packt_screen">Alexa Skills Kit Developer Console</span>, where we can go into the <kbd>WeatherGods</kbd> skill and add the <span class="packt_screen">Lambda ARN</span> to the skill endpoint.</p>
<p>Now that the setup of the skill is done, we get to test it. In the Alexa Skill Kit console, make sure you are in the <kbd>WeatherGods</kbd> skill and that all of the items on the <span class="packt_screen">Skill builder checklist</span> are complete. If you have any missing, then go back and complete that section:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a5609c0f-1a0e-4122-87b2-4036c1253dff.png" style=""/></div>
<div class="ImageCaption packt_figref CDPAlignCenter CDPAlign"><span><span>Skill-building checklist</span></span></div>
<p>Now we can go into the <span class="packt_screen">Test</span> tab and try out this skill. We can start this skill and then ask for a forecast, and we should be told the forecast for a given city:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1223ec81-c4c3-4e51-8bdb-31d1d9a510cf.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">City forecast</div>
<div>
<p>This is a great place to try out different ways of asking the same thing and expanding the utterances for the intents.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving user experience</h1>
                </header>
            
            <article>
                
<p>While our first version of this skill works well, it can be improved in a few key sections.</p>
<ul>
<li>Error-handling</li>
<li>Session memory</li>
<li>SSML</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Error-handling our API calls</h1>
                </header>
            
            <article>
                
<p>When we first set up this function, we didn't include any error-handling for our API calls. There is a chance that something happens with the API or with our call that causes it to fail. This could be a huge list of things such as broken internet connection, incorrect request, unknown location, expired API key, or the API going down.</p>
<p>To deal with this, we need to modify the way that our skill makes that request to the Open Weather Maps API. One of the limitations of using pure <kbd>async</kbd> and <kbd>await</kbd> is that we can't tell whether the request has passed or failed. There are two ways to deal with this:</p>
<ol>
<li>You can use <span><kbd>try…catch</kbd></span> blocks to catch any errors that occur. The way that we would do this would be to wrap everything inside the <kbd>isToday</kbd> block in a <kbd>try</kbd> block and then have a <kbd>catch</kbd> that tells the user that we couldn't deal with the request.</li>
<li>You can pass the request to a function that returns an array of <kbd>[error, result]</kbd>. If no error occurs, then it will be <kbd>null</kbd> so we can do logic based on that fact.</li>
</ol>
<p>Both of these methods are suitable, but they are best used in different situations.</p>
<p>The first <kbd>try…catch</kbd> method is used to catch errors across the code. We can take advantage of this by wrapping most of our logic in a single <kbd>try…catch</kbd>:</p>
<pre>try {<br/>    if (isToday) {<br/>        ...<br/>    } else {<br/>        ...<br/>    }<br/>} catch (err) {<br/>    console.log('err', err);<br/>    return handlerInput.responseBuilder<br/>        .speak(`My powers are weak and I couldn't get the weather right now.`)<br/>        .getResponse();<br/>}</pre>
<p>Keeping error messages light-hearted is often a good idea, as the user is less likely to be annoyed.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The second method is often used when you want to catch when a specific promise errors. We need to create a new function that takes a promise and returns the error and result status. This function is usually called <kbd>to</kbd>:</p>
<pre>const to = promise =&gt; promise.then(res =&gt; [null, res]).catch(err =&gt; [err, null]);</pre>
<p>If this function gets a promise that resolves, it returns the error as <kbd>null</kbd> and the result. But if there is an error, it returns an error and a <kbd>null</kbd> result. The error always goes in the first position because of a standard design called <strong>error-first programming</strong>.</p>
<p>This method is good for catching errors at a very specific location, whether it is to handle it differently or just to log out more information at that point. We can use this on the current weather request to give a slightly different response:</p>
<pre>let [error, response] = await to(axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${location},us&amp;appid=${process.env.API_KEY}`));<br/>if (error) {<br/> console.log('error getting weather', error.response);<br/>    let errorSpeech = `We couldn't get the weather for ${location} but you can try again later`;<br/>    return handlerInput.responseBuilder<br/>        .speak(errorSpeech)<br/>        .getResponse();<br/>}<br/>let { data: weatherResponse } = response;</pre>
<p>The last tool that we can use to handle errors is providing an error handler to the whole Alexa skill. We can create another handler that is called whenever there is an uncaught error in our code. This could be us returning an incorrect response, having an undefined variable, or an uncaught promise rejection.</p>
<p>Because we want this to be called every time an error occurs, our <kbd>canHandle</kbd> function always returns true. Our handler then gets passed the <kbd>handlerInput</kbd> but also gets passed an <kbd>error</kbd> variable. We can <kbd>console.log</kbd> out the response from the error and then send the user an error message:</p>
<pre>const ErrorHandler = {<br/>    canHandle() {<br/>        return true;<br/>    },<br/>    handle(handlerInput, error) {<br/>        console.log(`Error handled: ${error.message}`);<br/><br/>        return handlerInput.responseBuilder<br/>            .speak(`Sorry, I can't understand the command. Please say again.`)<br/>            .getResponse();<br/>    },<br/>};</pre>
<p>To apply this handler to our skill, we can add <kbd>.addErrorHandlers(ErrorHandler)</kbd> after <span><kbd>.addRequestHandlers</kbd> in our <kbd>Alexa.SkillBuilders</kbd>.</span></p>
<p>With these measures in place, our skill will work much better if there is ever an error in our code or when making a request to the Open Weather Map API. You should always have some sort of error-handling process around API calls, as you never know when they might go wrong.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Session memory</h1>
                </header>
            
            <article>
                
<p>One thing that doesn't currently work is asking follow-up questions. From the initial perfect conversation, we had to follow up questions such as <em>What about tomorrow</em><em>?</em> and <em>What about in Miami?</em> that use knowledge about previous requests to populate either the date or the location. Having a skill that can remember certain bits of information between interactions means that it can interact in a much more human way. There are very few interactions that we make that never depend on previous information.</p>
<p>To maintain that information between interactions, we have the concept of <strong>session attributes</strong>. These are key value pairs that are attached to the session, not just the individual interaction. Once Alexa thinks she's completed a task, she closes the session. In Alexa, session attributes are also really easy to set and retrieve. Getting session attributes is as simple as calling the following:</p>
<pre>let sessionAttributes = handlerInput.attributesManager.getSessionAttributes();</pre>
<p>This means that we have access to the values that we have previously stored in session attributes. To store values in session attributes, we can pass an object into <kbd>.setSessionAttributes</kbd>:</p>
<pre>handlerInput.attributesManager.setSessionAttributes(sessionAttributes);</pre>
<p>The last thing that we need to do is to tell Alexa that the session hasn't finished yet. We do this by adding <kbd>.withShouldEndSession(false)</kbd> just before <kbd>.getResponse()</kbd> in our response builder when we want to keep the session attributes.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If the user doesn't respond within a set time, the session still gets closed:</p>
<pre>return handlerInput.responseBuilder<br/>   .speak(speechText)<br/>   .withShouldEndSession(false)<br/>   .getResponse();</pre>
<p>We can use this powerful tool to store the date and location of successful requests and then use them to fill location or date slots that aren't filled by the user.</p>
<p>The first thing that we need to do is to get the session attributes from storage. We can then use these values to populate the <kbd>date</kbd> and <kbd>location</kbd> variables. If we don't get a value from the slots, we try the session attributes; otherwise, we set them to <kbd>null</kbd>. We then set out the local <kbd>sessionAttributes</kbd> variable to equal our <kbd>date</kbd> and <kbd>location</kbd>.  This means that new values that come from slots override the existing session attribute values:</p>
<pre>let sessionAttributes = handlerInput.attributesManager.getSessionAttributes();<br/>location = location.value || sessionAttributes.location || null;<br/>date = date.value || sessionAttributes.date || null;<br/>sessionAttributes = { location, date };</pre>
<p>We have changed the local session attributes, but we haven't set them on the session yet. We leave this until just before we respond to the user. We choose not to save it straight away, as if the user provided an invalid slot, that would get stored. If we store it just before sending the message, then we know that the API calls have succeeded:</p>
<pre>let speechText = `The weather in ${location} has ${weatherString} with a temperature of ${formattedTemp} and a humidity of ${humidity} percent`;<br/>handlerInput.attributesManager.setSessionAttributes(sessionAttributes);<br/>return handlerInput.responseBuilder</pre>
<p>Similarly, we need to add <kbd>handlerInput.attributesManager.setSessionAttributes(sessionAttributes);</kbd> just before returning the forecast message.</p>
<p>This example makes good use of session attributes, but it can be used for so much more. It can be used to store information for certain intents, previous conversation topics, or information about the user. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>One thing to note is that session attributes only last as long as the conversation session with the user. If you want to maintain attributes from one session to another, you can use persistent attributes, but this involves configuring your skill with a <strong>Persistence Adapter</strong>. More details are available at the end of the chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SSML</h1>
                </header>
            
            <article>
                
<p>When you are sending a response to a user, you may not want Alexa to say it in her normal way. Alexa is already pretty smart and handles punctuation, increasing the tone at the end of a question and pausing after a period, but what if you want to have greater control? </p>
<p>SSML is a standard markup for speech synthesis, and Alexa supports a subset of SSML, allowing the use of 13 different tags. These tags allow you to specify the way that the text is spoken. This means you can add <kbd>&lt;break time="2s"&gt;</kbd> into your speech to add a two-second pause, emphasise a section of the speech using <kbd>&lt;emphasis level="moderate"&gt;text to emphasise&lt;/emphasis&gt;</kbd>, or <kbd>&lt;prosody rate="slow" pitch="-2st"&gt;</kbd>to change the tone and speed, <kbd> &lt;/prosody&gt;</kbd>, of the speech.</p>
<p>There are lots of ways to change the way that Alexa talks, and they can all be found in the Alexa SSML reference page (<a href="https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html#emphasis">https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html#emphasis</a>).</p>
<p>The speech that we are saying to the user is already handled very well because of Alexa's handling of punctuation and questions. This means there isn't much of our existing messages we could improve with SSML. To give us something that always needs extra speech control, we're going to add a new intent—<kbd>tellAJoke</kbd>. If you've ever heard someone ruin a good joke, then you know that jokes need proper tone, speed, and timing.</p>
<p>We need to add the <kbd>tellAJoke</kbd> intent in the Alexa Skills Kit console and then add a few utterances, but this time we don't need any slots.</p>
<p>Once we've saved and built the model, we can move back to our code to handle this new intent:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e25de44c-efb2-41e4-834f-18a11a3ff2ea.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Adding the tell-a-joke intent</div>
<p>The handler for this intent is very simple. All that it needs to do is to get a random joke from the array of jokes and tell that to the user. We use <kbd>Math.floor(Math.random() * 3);</kbd> to get a random integer that is less than 3. If you want to add more jokes, just change <kbd>3</kbd> to the number of jokes you have:</p>
<pre>const JokeHandler = {<br/>    canHandle(handlerInput) {<br/>        return handlerInput.requestEnvelope.request.type === 'IntentRequest' &amp;&amp;<br/>            handlerInput.requestEnvelope.request.intent.name === 'tellAJoke';<br/>    },<br/>    async handle(handlerInput) {<br/>        let random = Math.floor(Math.random() * 3);<br/>        let joke = jokes[random];<br/>        return handlerInput.responseBuilder<br/>            .speak(joke)<br/>            .getResponse();<br/>    }<br/>};</pre>
<p class="mce-root"/>
<p>The more interesting part is creating the jokes. We need to start by creating a variable called <kbd>jokes</kbd> that is an array. Inside this array, we can put a few weather-related jokes. I've added the first three, but feel free to add your own (and remove my less-funny ones):</p>
<pre>let jokes = [<br/>    `Where do snowmen keep their money? In a snow bank.`,<br/>    `As we waited for a bus in the frosty weather, the woman next to me mentioned that she makes a lot of mistakes when texting in the cold. I nodded knowingly. It’s the early signs of typothermia.`,<br/>    `Don’t knock the weather. If it didn’t change once in a while, nine tenths of the people couldn’t start a conversation.`<br/>];</pre>
<p>If we published the skill now, those jokes would be even worse than they're meant to be. The first thing that we will aim to fix will be the timing. Adding break tags before the punchline makes the jokes far better:</p>
<pre>let jokes = [<br/>    `Where do snowmen keep their money? &lt;break time="2s" /&gt; In a snow bank.`,<br/>    `As we waited for a bus in the frosty weather, the woman next to me mentioned that she makes a lot of mistakes when texting in the cold. I nodded knowingly. &lt;break time="1s" /&gt; It’s the early signs of typothermia.`,<br/>   `Don’t knock the weather. &lt;break time="1s" /&gt; If it didn’t change once in a while, nine tenths of the people couldn’t start a conversation.`<br/>];</pre>
<p>The exact timings may not be perfect, but they're already delivered much better than before. Another key to telling a joke well is the emphasis you place on certain words. Adding emphasis to sections of speech in Alexa is done by wrapping those words in <kbd>emphasis</kbd> tags:</p>
<pre>`This sentence uses both &lt;emphasis level="strong"&gt;increased&lt;/emphasis&gt; and &lt;emphasis level="reduced"&gt;decreased&lt;/emphasis&gt; emphasis`;</pre>
<p>Adding <kbd>emphasis</kbd> tags to our jokes, we get this:</p>
<pre>let jokes = [<br/>    `Where do snowmen keep their money? &lt;break time="2s" /&gt; In a &lt;emphasis&gt; snow bank &lt;/emphasis&gt;`,<br/>    `As we waited for a bus in the frosty weather, the woman next to me mentioned that she makes a lot of mistakes when texting in the cold. I nodded knowingly. &lt;break time="1s" /&gt; It’s the early signs of &lt;emphasis&gt; typothermia &lt;/emphasis&gt;`,</pre>
<p class="mce-root"/>
<pre>    `Don’t knock the weather. &lt;break time="1s" /&gt; If it didn’t change once in a while, nine tenths of the people &lt;emphasis&gt; couldn’t start a conversation&lt;/emphasis&gt;`<br/>];</pre>
<p>When the <kbd>emphasis</kbd> tags are used but a level is not provided, a level of <em>moderate</em> is used.</p>
<p>There are lots of other SSML tags that can be used to alter the way that Alexa says the response, and they can be found on the Alexa SSML page (<a href="https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html">https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>Now that we've added all of these changes to our Lambda, we can build it and test it out.</p>
<p>It's quite hard to test what happens when API errors occur, but we can test for session attributes and SSML.</p>
<p>Session attributes can be tested by asking to follow up questions, where we expect that some data has been stored from the last question. We can ask for a forecast in one location, and then ask for a new location. The date should have been saved in session attributes, so we should get a forecast for the new location instead of the current weather. We can then ask about today's weather, and the new location should have been saved, so we shouldn't get prompted for the location:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/90a19ab8-6d25-42d3-8fbf-2d99c267926c.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Session attributes testing</div>
<p>We can also test SSML by asking for a joke. The joke you get back should have the break that we added and possibly some emphasis. When you test this yourself, you will be able to hear these clearly:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f9762c3e-2641-4663-89ec-e75e11008e61.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Jokes</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we've covered how to use external APIs to increase the information that is available to the chatbot, allowing you to make much more powerful skills.</p>
<p>We then looked at how to make the experience more enjoyable for the user. The three ways we did this were as follows:</p>
<ul>
<li>We used error-handling to reduce the frustration when a user's request doesn't work.</li>
<li>We used session memory to remember details about the conversation so that we can use them later. This stopped us from repeating and prompting the user every time they didn't provide all of the information.</li>
<li>We used SSML to modify the way that Alexa says our responses, to make the sentence feel more human. We also used SSML to make jokes funnier, but it can be used to emphasize points or change the tone of the speech.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is an API?</li>
<li>How does Axios differ from the standard HTTP request library?</li>
<li>What are the two common ways of handling <kbd>async</kbd> and <kbd>await</kbd> errors?</li>
<li>How would we store <em>color</em> on the session attributes?</li>
<li>What types of data can be stored on the session attributes?</li>
<li>Why would you use SSML?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>If you want to learn about <em>persistentAttributes</em>,<em> </em>then you can read about them in the ASK SDK documents (<a href="https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Managing-Attributes.html">https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Managing-Attributes.html</a>).</p>
<p>For a full list of the supported SMML tags in Alexa, go to the Alexa SSML reference page (<a href="https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html">https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html</a>).</p>
<p>If you want to hear how different SSML tags change the way that text is spoken, check out the Google SSML reference page (<a href="https://developers.google.com/actions/reference/ssml">https://developers.google.com/actions/reference/ssml</a>). It has working examples of lots of SSMLs, but you can't edit them.</p>


            </article>

            
        </section>
    </body></html>