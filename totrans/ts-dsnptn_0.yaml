- en: Chapter 2. The Challenge of Increasing Complexity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 增加复杂性的挑战
- en: The essence of a program is the combination of possible branches and automated
    selections based on certain conditions. When we write a program, we define what's
    going on in a branch, and under what condition this branch will be executed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的本质是可能分支的组合以及基于某些条件的自动化选择。当我们编写程序时，我们定义了分支中的内容，以及这个分支将在什么条件下被执行。
- en: The number of branches usually grows quickly during the evolution of a project,
    as well as the number of conditions that determine whether a branch will be executed
    or not.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的演变过程中，分支的数量通常会迅速增长，以及确定分支是否将被执行的条件的数量。
- en: This is dangerous for human beings, who have limited brain capacities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这对人类来说很危险，因为人类的脑容量有限。
- en: In this chapter, we are going to implement a data synchronizing service. Starting
    by implementing some very basic features, we'll keep adding stuff and see how
    things go.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个数据同步服务。从实现一些非常基本的功能开始，我们将继续添加内容，看看事情会如何发展。
- en: 'The following topics will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容将涵盖：
- en: Designing a multi-device synchronizing strategy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计多设备同步策略
- en: Useful JavaScript and TypeScript techniques and hints that are related, including
    objects as maps and the string literal type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关的有用JavaScript和TypeScript技术和提示，包括对象作为映射和字符串字面量类型
- en: How the Strategy Pattern helps in a project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式如何帮助项目
- en: Implementing the basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本功能
- en: Before we start to write actual code, we need to define what this synchronizing
    strategy will be like. To keep the implementation from unnecessary distractions,
    the client will communicate with the server directly through function calls instead
    of using HTTP requests or Sockets. Also, we'll use **in-memory storage**, namely
    variables, to store data on both client and server sides.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写实际代码之前，我们需要定义这种同步策略将是什么样的。为了使实现免受不必要的干扰，客户端将通过函数调用直接与服务器通信，而不是使用HTTP请求或套接字。此外，我们将在客户端和服务器端使用**内存存储**，即变量，来存储数据。
- en: Because we are not separating the client and server into two actual applications,
    and we are not actually using backend technologies, it does not require much Node.js
    experience to follow this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有将客户端和服务器分开成两个实际的应用程序，并且我们没有真正使用后端技术，因此不需要太多的Node.js经验来理解本章。
- en: However, please keep in mind that even though we are omitting network and database
    requests, we hope the core logic of the final implementation could be applied
    to a real environment without being modified too much. So, when it comes to performance
    concerns, we still need to assume limited network resources, especially for data
    passing through the server and client, although the implementation is going to
    be synchronous instead of asynchronous. This is not supposed to happen in practice,
    but involving asynchronous operations will introduce much more code, as well as
    many more situations that need to be taken into consideration. But we will have
    some useful patterns on asynchronous programming in the coming chapters, and it
    would definitely help if you try to implement an asynchronous version of the synchronizing
    logic in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，尽管我们省略了网络和数据库请求，但我们希望最终实现的逻辑核心可以在不进行太多修改的情况下应用于实际环境。因此，当涉及到性能问题时，我们仍然需要假设有限的网络资源，特别是对于通过服务器和客户端传输的数据，尽管实现将是同步的而不是异步的。在实际情况中，这不应该发生，但涉及异步操作将引入更多的代码，以及许多需要考虑的情况。但在接下来的章节中，我们将介绍一些关于异步编程的有用模式，如果你尝试实现本章中同步逻辑的异步版本，这将非常有帮助。
- en: A client, if without modifying what's been synchronized, stores a copy of all
    the data available on the server, and what we need to do is to provide a set of
    APIs that enable the client to keep its copy of data synchronized.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端没有修改已同步的内容，它将存储服务器上所有可用数据的副本，而我们需要做的是提供一组API，使客户端能够保持其数据副本的同步。
- en: 'So, it is really simple at the beginning: comparing the last-modified timestamp.
    If the timestamp on the client is older than what''s on the server, then update
    the copy of data along with new timestamp.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一开始真的很简单：比较最后修改的时间戳。如果客户端的时间戳比服务器上的旧，那么就更新数据副本以及新的时间戳。
- en: Creating the code base
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建代码库
- en: 'Firstly, let''s create `server.ts` and `client.ts` files containing the `Server`
    class and `Client` class respectively:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建`server.ts`和`client.ts`文件，分别包含`Server`类和`Client`类：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I prefer to create an `index.ts` file as the package entry, which handles what
    to export internally. In this case, let''s export everything:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢创建一个`index.ts`文件作为包的入口，它内部处理要导出的内容。在这种情况下，让我们导出所有内容：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To import the `Server` and `Client` classes from a test file (assuming `src/test/test.ts`),
    we can use the following codeto s:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要从测试文件（假设`src/test/test.ts`）中导入`Server`和`Client`类，我们可以使用以下代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Defining the initial structure of the data to be synchronized
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义要同步的数据的初始结构
- en: 'Since we need to compare the timestamps from the client and server, we need
    to have a `timestamp` property on the data structure. I would like to have the
    data to synchronize as a string, so let''s add a `DataStore` interface with a
    `timestamp` property to the `server.ts` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要比较客户端和服务器的时间戳，我们需要在数据结构上有一个`timestamp`属性。我希望同步的数据是一个字符串，所以让我们在`server.ts`文件中添加一个带有`timestamp`属性的`DataStore`接口：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Getting data by comparing timestamps
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过比较时间戳来获取数据
- en: 'Currently, the synchronizing strategy is one-way, from the server to the client.
    So what we need to do is simple: we compare the timestamps; if the server has
    the newer one, it responds with data and the server-side timestamp; otherwise,
    it responds with `undefined`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，同步策略是单向的，从服务器到客户端。所以我们需要做的就是简单比较时间戳；如果服务器有更新的，它将响应数据和服务器端的时间戳；否则，它将响应`undefined`：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we have provided a simple API for the client, and it''s time to implement
    the client:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为客户端提供了一个简单的API，现在是时候实现客户端了：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Prefixing a `constructor` parameter with access modifiers (including `public`,
    `private`, and `protected`) will create a property with the same name and corresponding
    accessibility. It will also assign the value automatically when the constructor
    is called.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数参数前加上访问修饰符（包括`public`、`private`和`protected`）将创建一个具有相同名称和相应可访问性的属性。当调用构造函数时，它还会自动分配值。
- en: 'Now we need to add a `synchronize` method to the `Client` class that does the
    job:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在`Client`类中添加一个`synchronize`方法来完成这项工作：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's easily done. However, are you already feeling somewhat awkward with what
    we've written?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易做到。然而，你是否已经开始觉得我们写的东西有些尴尬？
- en: Two-way synchronizing
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向同步
- en: Usually, when we talk about synchronization, we get updates from the server
    and push changes to the server as well. Now we are going to do the second part,
    pushing the changes if the client has newer data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们谈论同步时，我们会从服务器获取更新，并将更改推送到服务器。现在我们将进行第二部分，如果客户端有更新的数据，则推送更改。
- en: 'But first, we need to give the client the ability to update its data by adding
    an `update` method to the `Client` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要给客户端添加更新其数据的能力，通过在`Client`类中添加一个`update`方法：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And we need the server to have the ability to receive data from the client
    as well. So we rename the `getData` method of the `Server` class as `synchronize`
    and make it satisfy the new job:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要服务器能够从客户端接收数据。因此，我们将`Server`类的`getData`方法重命名为`synchronize`，并使其满足新的任务：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we have the basic implementation of our synchronizing service. Later, we'll
    keep adding new things and make it capable of dealing with a variety of scenarios.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了同步服务的初步实现。以后，我们将继续添加新功能，使其能够处理各种场景。
- en: Things that went wrong while implementing the basics
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实现基本功能时出现的问题
- en: Currently, what we've written is just too simple to be wrong. But there are
    still some semantic issues.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们写的代码太简单了，以至于可能出错。但仍然存在一些语义问题。
- en: Passing a data store from the server to the client does not make sense
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从服务器传递数据存储给客户端是没有意义的
- en: We used `DataStore` as the return type of the `synchronize` method on `Server`.
    But what we were actually passing through is not a data store, but information
    that involves data and its timestamp. The information object just *happened to*
    have the same properties as a data store *at this point in time*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Server`类的`synchronize`方法上使用了`DataStore`作为返回类型。但实际上我们传递的不是数据存储，而是涉及数据和其时间戳的信息。这个信息对象恰好在这个时间点具有与数据存储相同的属性。
- en: 'Also, it will be misleading to people who will later read your code (including
    yourself in the future). Most of the time, we are trying to eliminate redundancies.
    But that does not have to mean everything that looks the same. So let''s make
    it two interfaces:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这也会误导后来阅读你代码的人（包括未来的你自己）。大多数时候，我们试图消除冗余。但这并不意味着所有看起来相同的东西。所以让我们将其定义为两个接口：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I would even prefer to create another instance, instead of directly returning
    `this.store`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至更愿意创建另一个实例，而不是直接返回 `this.store`：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, if two pieces of code with different semantic meanings are doing the
    same thing from the perspective of code itself, you may consider extracting that
    part as a utility.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果两段代码在代码本身的角度来看具有不同的语义意义，但执行相同的功能，你可能考虑将这部分提取为一个实用工具。
- en: Making the relationships clear
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使关系清晰
- en: Now we have two separated interfaces, `DataStore` and `DataSyncingInfo`, in
    `server.ts`. Obviously, `DataSyncingInfo` should be a shared interface between
    the server and the client, while `DataStore` happens to be the same on both sides,
    but it's not actually shared.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个分离的接口，`DataStore` 和 `DataSyncingInfo`，在 `server.ts` 中。显然，`DataSyncingInfo`
    应该是服务器和客户端之间的共享接口，而 `DataStore` 在两边都是相同的，但实际上并没有共享。
- en: So what we are going to do is to create a separate `shared.d.ts` (it could also
    be `shared.ts` if it contains more than `typings`) that exports `DataSyncingInfo`
    and add another `DataStore` to `client.ts`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个单独的 `shared.d.ts`（如果它包含的不仅仅是 `typings`，也可以是 `shared.ts`），导出 `DataSyncingInfo`
    并在 `client.ts` 中添加另一个 `DataStore`。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not follow this blindly. Sometimes it is designed for the server and the
    client to have exactly the same stores. If that's the situation, the interface
    should be shared.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不要盲目跟随。有时这是为了服务器和客户端具有完全相同的存储而设计的。如果是这种情况，接口应该是共享的。
- en: Growing features
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征增长
- en: What we've done so far is basically useless. But, from now on, we will start
    to add features and make it capable of fitting in practical needs, including the
    capability of synchronizing multiple data items with multiple clients, and merging
    conflicts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的一切基本上都是无用的。但是，从现在开始，我们将开始添加功能，使其能够满足实际需求，包括与多个客户端同步多个数据项的能力，以及合并冲突。
- en: Synchronizing multiple items
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步多个项目
- en: Ideally, the data we need to synchronize will have a lot of items contained.
    Directly changing the type of `data` to an array would work if there were only
    very limited number of these items.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们需要同步的数据将包含大量项目。如果这些项目数量非常有限，直接将 `data` 的类型更改为数组是可行的。
- en: Simply replacing data type with an array
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单地用数组替换数据类型
- en: Now let's change the type of the `data` property of `DataStore` and `DataSyncingInfo`
    interfaces to `string[]`. With the help of TypeScript, you will get errors for
    unmatched types this change would cause. Fix them by annotating the correct types.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将 `DataStore` 和 `DataSyncingInfo` 接口中的 `data` 属性类型更改为 `string[]`。借助 TypeScript，你会得到由于这种更改导致的类型不匹配的错误。通过注释正确的类型来修复它们。
- en: But obviously, this is far from an efficient solution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但显然，这远非一个高效的解决方案。
- en: Server-centered synchronization
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以服务器为中心的同步
- en: If the data store contains a lot of data, the ideal approach would be only updating
    items that are not up-to-date.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据存储包含大量数据，理想的方法是只更新那些未更新的项目。
- en: For example, we can create a timestamp for every single item and send these
    timestamps to the server, then let the server decide whether a specific data item
    is up-to-date. This is a viable approach for certain scenarios, such as checking
    updates for software extensions. It is okay to occasionally send even hundreds
    of timestamps with item IDs on a fast network, but we are going to use another
    approach for different scenarios, or I won't have much to write.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以为每个单独的项目创建一个时间戳，并将这些时间戳发送到服务器，然后让服务器决定特定的数据项是否是最新的。这在某些场景中是一个可行的方案，例如检查软件扩展的更新。在快速网络上偶尔发送带有项目
    ID 的数百个时间戳是可以的，但我们将为不同的场景使用另一种方法，否则我将没有太多可写的内容。
- en: User data synchronization of offline apps on a mobile phone is what we are going
    to deal with, which means we need to try our best to avoid wasting network resources.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在手机上处理离线应用的用户数据同步是我们将要处理的，这意味着我们需要尽力避免浪费网络资源。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here is an interesting question. What are the differences between user data
    synchronization and checking extension updates? Think about the size of data,
    issues with multiple devices, and more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的问题。用户数据同步和检查扩展更新之间有什么区别？考虑数据的大小、多设备的问题等等。
- en: The reason why we thought about sending timestamps of all items is for the server
    to determine whether certain items need to be updated. However, is it necessary
    to have the timestamps of all data items stored on the client side?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑发送所有项目的时间戳的原因是让服务器确定某些项目是否需要更新。然而，有必要在客户端存储所有数据项的时间戳吗？
- en: What if we choose not to store the timestamp of data changing, but of data being
    synchronized with the server? Then we can get everything up-to-date by only sending
    the timestamp of the last successful synchronization. The server will then compare
    this timestamp with the last modified timestamps of all data items and decide
    how to respond.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择不存储数据更改的时间戳，而是存储与服务器同步的数据的时间戳，那么我们只需发送最后一次成功同步的时间戳就可以获取所有最新的数据。然后，服务器将比较这个时间戳与所有数据项的最后修改时间戳，并决定如何响应。
- en: As the title of this part suggests, the process is server-centered and relies
    on the server to generate the timestamps (though it does not have to, and practically
    should not, be the stamp of the actual time).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如本部分标题所示，该过程以服务器为中心，依赖于服务器生成时间戳（尽管它不必这样做，实际上也不应该这样做）。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: If you are getting confused about how these timestamps work, let's try again.
    The server will store the timestamps of the last time items were synchronized,
    and the client will store the timestamp of the last successful synchronization
    with the server. Thus, if no item on the server has a later timestamp than the
    client, then there's no change to the server data store after that timestamp.
    But if there are some changes, by comparing the timestamp of the client with the
    timestamps of server items, we'll know which items are newer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些时间戳的工作方式感到困惑，让我们再试一次。服务器将存储上次同步项的时间戳，而客户端将存储与服务器最后一次成功同步的时间戳。因此，如果服务器上没有项的时间戳晚于客户端，那么在该时间戳之后，服务器数据存储没有变化。但如果有一些变化，通过比较客户端的时间戳与服务器项的时间戳，我们将知道哪些项是较新的。
- en: Synchronizing from the server to the client
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从服务器到客户端的同步
- en: Now there seems to be quite a lot to change. Firstly, let's handle synchronizing
    data from server to client.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在似乎有很多东西需要更改。首先，让我们处理从服务器到客户端的数据同步。
- en: 'This is what''s expected to happen on the server side:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务器端期望发生的情况：
- en: Add a timestamp and identity to every data item on the server
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为服务器上的每个数据项添加时间戳和标识
- en: Compare the client timestamp with every data item on the server
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将客户端时间戳与服务器上的每个数据项进行比较
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: We don't need to actually compare the client timestamp with every item on server
    if those items have a sorted index. The performance would be acceptable using
    a database with a sorted index.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些项具有排序索引，我们实际上不需要将客户端的时间戳与服务器上的每个项进行比较。使用具有排序索引的数据库，性能是可以接受的。
- en: Respond with items newer than what the client has as well as a new timestamp.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回比客户端拥有的更新的项以及一个新的时间戳。
- en: 'And here''s what''s expected to happen on the client side:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端期望发生的情况：
- en: Synchronize with the last timestamp sent to the server
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与服务器发送的最后一个时间戳同步
- en: Update the local store with new data responded by the server
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器响应的新数据更新本地存储
- en: Update the local timestamp of the last synchronization if it completes without
    error
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果同步完成且没有错误，则更新本地最后同步的时间戳
- en: '**Updating interfaces**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新接口**'
- en: 'First of all, we have now an updated data store on both sides. Starting with
    the server, the data store now contains an array of data items. So let''s define
    the `ServerDataItem` interface and update `ServerDataStore` as well:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们现在在双方都有更新的数据存储。从服务器开始，数据存储现在包含一个数据项数组。因此，让我们定义 `ServerDataItem` 接口并更新 `ServerDataStore`：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'The `{ [id: string]: ServerDataItem }` type describes an object with `id` of
    type `string` as a key and has the value of type `ServerDataItem`. Thus, an item
    of type `ServerDataItem` can be accessed by `items[''the-id'']`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ [id: string]: ServerDataItem }` 类型描述了一个对象，它以 `id` 类型为 `string` 的键，并具有 `ServerDataItem`
    类型的值。因此，可以通过 `items[''the-id'']` 访问 `ServerDataItem` 类型的项。'
- en: 'And for the client, we now have different data items and a different store.
    The response contains only a subset of all data items, so we need IDs and a map
    with ID as the index to store the data:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端，我们现在有不同的数据项和不同的存储。响应只包含所有数据项的一个子集，因此我们需要ID和一个以ID为索引的映射来存储数据：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Previously, the client and server were sharing the same `DataSyncingInfo`,
    but that''s going to change. As we''ll deal with server-to-client synchronizing
    first, we care only about the timestamp in a synchronizing request for now:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，客户端和服务器共享相同的 `DataSyncingInfo`，但这种情况将要改变。由于我们首先处理服务器到客户端的同步，所以我们现在只关心同步请求中的时间戳：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As for the response from the server, it is expected to have an updated timestamp
    with data items that have changed compared to the request timestamp:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 至于服务器的响应，它应该有一个更新的时间戳，与请求时间戳相比，数据项已发生变化：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I prefixed those interfaces with *Server* and *Client* for better differentiation.
    But it's not necessary if you are not exporting everything from `server.ts` and
    `client.ts` (in `index.ts`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我用*Server*和*Client*前缀那些接口，以便更好地区分。但如果你不是从`server.ts`和`client.ts`（在`index.ts`中）导出所有内容，这不是必要的。
- en: '**Updating the server side**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新服务器端**'
- en: 'With well-defined data structures, it should be pretty easy to achieve what
    we expected. To begin with, we have the `synchronize` method, which accepts a
    `SyncingRequest` and returns a `SyncingResponse`; and we need to have the updated
    timestamp as well:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定义良好的数据结构，应该很容易实现我们期望的结果。首先，我们有`synchronize`方法，它接受一个`SyncingRequest`并返回一个`SyncingResponse`；并且我们需要有更新的时间戳：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the `serverChanges` object, `{}` (an object literal) might be the first
    thing (if not an ES6 Map) that comes to mind. But it's not absolutely safe to
    do so, because it would refuse `__proto__` as a key. The better choice would be
    `Object.create(null)`, which accepts all strings as its key.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`serverChanges`对象，`{}`（一个对象字面量）可能是首先想到的（如果不是ES6 Map）。但这样做并不绝对安全，因为它会拒绝`__proto__`作为键。更好的选择是`Object.create(null)`，它接受所有字符串作为其键。
- en: 'Now we are going to add items that are newer than the client to `serverChanges`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加比客户端更新的项到`serverChanges`：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Updating the client side**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新客户端**'
- en: 'As we''ve changed the type of `items` under `ClientDataStore` to a map, we
    need to fix the initial value:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`ClientDataStore`下的`items`的类型更改为映射，我们需要修复初始值：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let''s update the `synchronize` method. Firstly, the client is going to
    send a request with a timestamp and get a response from the server:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新`synchronize`方法。首先，客户端将发送一个带有时间戳的请求并从服务器获取响应：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we''ll save the newer data items to the store:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将保存更新的数据项到存储中：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, update the timestamp of the last successful synchronization:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新最后一次成功同步的时间戳：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Updating the synchronization timestamp should be the last thing to do during
    a complete synchronization process. Make sure it's not stored earlier than data
    items, or you might have a broken offline copy if there's any errors or interruptions
    during synchronizing in the future.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更新同步时间戳应该是完整同步过程中最后要做的事情。确保它不早于数据项存储，否则如果在未来的同步过程中出现任何错误或中断，可能会有一个损坏的离线副本。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To ensure that this works as expected, an operation with the same change information
    should give the same results even if it's applied multiple times.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它按预期工作，具有相同更改信息的操作即使在多次应用时也应给出相同的结果。
- en: Synchronizing from client to server
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从客户端到服务器的同步
- en: For a server-centered synchronizing process, most of the changes are made through
    clients. Consequently, we need to figure out how to organize these changes before
    sending them to the server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以服务器为中心的同步过程，大多数更改都是通过客户端进行的。因此，我们需要在将它们发送到服务器之前组织这些更改。
- en: One single client only cares about its own copy of data. What difference would
    this make when comparing to the process of synchronizing data from the server
    to clients? Well, think about why we need the timestamp of every data item on
    the server in the first place. We need them because we want to know which items
    are new compared to a specific client.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单个客户端只关心它自己的数据副本。与从服务器同步数据到客户端的过程相比，这会有什么不同呢？好吧，想想我们最初为什么需要服务器上每个数据项的时间戳。我们需要它们是因为我们想知道与特定客户端相比哪些项是新的。
- en: 'Now, for changes on a client: if they ever happen, they need to be synchronized
    to the server without requiring specific timestamps for comparison.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于客户端的更改：如果它们发生，它们需要同步到服务器，而不需要比较特定的时间戳。
- en: However, we might have more than one client with changes that need to be synchronized,
    which means that changes made later in time might actually get synchronized earlier,
    and thus we'll have to resolve conflicts. To achieve that, we need to add the
    last modified time back to every data item on the server and the changed items
    on the client.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能有多个需要同步更改的客户，这意味着后来时间做出的更改实际上可能会更早地同步，因此我们需要解决冲突。为了实现这一点，我们需要将最后修改时间添加到服务器上的每个数据项和客户端的更改项上。
- en: I've mentioned that the timestamps stored on the server for finding out what
    needs to be synchronized to a client do not need to be (and better not be) an
    actual stamp of a physical time point. For example, it could be the count of synchronizations
    that happened between all clients and the server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到，服务器上存储的时间戳，用于确定需要同步到客户端的内容，不需要（而且最好不是）实际时间点的实际戳记。例如，它可以是所有客户端与服务器之间发生的同步次数。
- en: '**Updating the client side**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新客户端**'
- en: 'To handle this efficiently, we may create a separated map with the IDs of the
    data items that have changed as keys and the last modified time as the value in
    `ClientDataStore`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地处理这个问题，我们可以在 `ClientDataStore` 中创建一个单独的映射，以数据项的 ID 作为键，最后修改时间作为值：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may also want to initialize its value as `Object.create(null)`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想将其值初始化为 `Object.create(null)`。
- en: 'Now when we update an item in the client store, we add the last modified time
    to the `changed` map as well:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更新客户端存储中的项时，我们也将最后修改时间添加到 `changed` 映射中：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A single timestamp in `SyncingRequest` certainly won''t do the job any more;
    we need to add a place for the changed data, a map with data item ID as the index,
    and the changed information as the value:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyncingRequest` 中的单个时间戳肯定不能再胜任这项工作了；我们需要为更改的数据添加一个位置，一个以数据项 ID 作为索引，更改信息作为值的映射：'
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here comes another problem. What if a change made to a client data item is
    done offline, with the system clock being at the wrong time? Obviously, we need
    some time calibration mechanisms. However, there''s no way to make perfect calibration.
    We''ll make some assumptions so we don''t need to start another chapter for time
    calibration:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里又出现了一个问题。如果一个客户端数据项的更改是在离线状态下进行的，系统时钟时间不正确，怎么办？显然，我们需要一些时间校准机制。然而，没有方法可以做到完美的校准。我们将做一些假设，这样我们就不需要为时间校准开启另一个章节：
- en: The system clock of a client may be late or early compared to the server. But
    it ticks at a normal speed and won't jump between times.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端的系统时钟可能比服务器晚或早，但它以正常速度运行，不会在时间之间跳跃。
- en: The request sent from a client reaches the server in a relatively short time.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端发送的请求在相对较短的时间内到达服务器。
- en: 'With those assumptions, we can add those building blocks to the client-side
    `synchronize` method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些假设，我们可以将这些构建块添加到客户端的 `synchronize` 方法中：
- en: 'Add client-side changes to the synchronizing request (of course, before sending
    it to the server):'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将同步请求（当然，在发送到服务器之前）发送到服务器之前，添加客户端更改：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Synchronize changes to the server with the current time of the client''s clock:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将服务器上的更改与客户端时钟的当前时间同步：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Clean the changes after a successful synchronization:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功同步后清理更改：
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Updating the server side**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新服务器端**'
- en: If the client is working as expected, it should send synchronizing requests
    with changes. It's time to enable the server to handling those changes from the
    client.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端按预期工作，它应该发送包含更改的同步请求。现在是时候让服务器能够处理来自客户端的这些更改了。
- en: 'There are going to be two steps for the server-side synchronization process:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端同步过程将分为两个步骤：
- en: Apply the client changes to server data store.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将客户端更改应用到服务器数据存储。
- en: Prepare the changes that need to be synchronized to the client.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备需要同步到客户端的更改。
- en: 'First, we need to add `lastModifiedTime` to server-side data items, as we mentioned
    before:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要像之前提到的那样，将 `lastModifiedTime` 添加到服务器端数据项中：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And we need to update the `synchronize` method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新 `synchronize` 方法：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can actually use the `in` operator instead of `hasOwnProperty` here because
    the `items` object is created with `null` as its prototype. But a reference to
    `hasOwnProperty` will be your friend if you are using objects created by object
    literals, or in other ways, such as maps.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以在这里使用 `in` 操作符而不是 `hasOwnProperty`，因为 `items` 对象是以 `null` 作为其原型的。但是，如果你使用的是通过对象字面量创建的对象，或者以其他方式，如
    maps，那么对 `hasOwnProperty` 的引用将是你的朋友。
- en: We already talked about resolving conflicts by comparing the last modified times.
    At the same time, we've made assumptions so we can calibrate the last modified
    times from the client easily by passing the client time to the server while synchronizing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了通过比较最后修改时间来解决冲突。同时，我们已经做出了假设，这样我们就可以通过在同步时传递客户端时间到服务器，轻松地校准客户端的最后修改时间。
- en: 'What we are going to do for calibration is to calculate the offset of the client
    time compared to the server time. And that''s why we made the second assumption:
    the request needs to easily reach the server in a relatively short time. To calculate
    the offset, we can simply subtract the client time from the server time:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的校准是计算客户端时间与服务器时间的偏移量。这就是为什么我们做出了第二个假设：请求需要相对较短时间内轻松到达服务器。为了计算偏移量，我们可以简单地从服务器时间中减去客户端时间：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To make the time calibration more accurate, we would want the earliest timestamp
    after the request hits the server to be recorded as "now". So in practice, you
    might want to record the timestamp of the request hitting the server before start
    processing everything. For example, for HTTP request, you may record the timestamp
    once the TCP connection gets established.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使时间校准更准确，我们希望记录最早的时间戳，即请求击中服务器后的时间戳。在实践中，你可能会在开始处理一切之前记录请求击中服务器的时间戳。例如，对于
    HTTP 请求，你可以在 TCP 连接建立后记录时间戳。
- en: 'And now, the calibrated time of a client change is the sum of the original
    time and the offset. We can now decide whether to keep or ignore a change from
    the client by comparing the calibrated last modified time. It is possible for
    the calibrated time to be greater than the server time; you can choose either
    to use the server time as the maximum value or accept a small inaccuracy. Here,
    we will go the simple way:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端更改的校准时间是原始时间和偏移量的总和。我们可以通过比较校准的最后修改时间来决定是否保留或忽略客户端的更改。校准时间可能大于服务器时间；你可以选择使用服务器时间作为最大值或接受一点小误差。在这里，我们将采取简单的方法：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To make this actually work, we need to also exclude changes from the server
    that conflict with client changes in `SyncingResponse`. To do so, we need to know
    what the changes are that survive the conflict resolving process. A simple way
    is to exclude items with timestamp that equals `now`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这真正工作，我们还需要排除与客户端更改冲突的服务器更改。为此，我们需要知道在冲突解决过程中幸存下来的更改是什么。一种简单的方法是排除时间戳等于 `now`
    的项：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So now we have implemented a complete synchronization logic with the ability
    to handle simple conflicts in practice.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经实现了一个完整的同步逻辑，能够处理实践中简单的冲突。
- en: Synchronizing multiple types of data
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步多种类型的数据
- en: At this point, we've hard coded the data with the `string` type. But usually
    we will need to store varieties of data, such as numbers, booleans, objects, and
    so on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已将数据硬编码为 `string` 类型。但通常我们还需要存储各种数据，例如数字、布尔值、对象等。
- en: 'If we were writing JavaScript, we would not actually need to change anything,
    as the implementation does not have anything to do with certain data types. In
    TypeScript, we don''t need to do much either: just change the type of every related
    `value` to `any`. But that means you are losing type safety, which would definitely
    be okay if you are happy with that.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写 JavaScript，实际上我们不需要做任何改变，因为实现与某些数据类型无关。在 TypeScript 中，我们也不需要做太多：只需将每个相关
    `value` 的类型更改为 `any`。但这意味着你正在失去类型安全，如果你对此感到满意，那当然是可以接受的。
- en: 'But taking my own preferences, I would like every variable, parameter, and
    property to be typed if it''s possible. So we may still have a data item with
    `value` of type `any`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但根据我的个人偏好，我希望如果可能的话，每个变量、参数和属性都应该有类型。因此，我们可能仍然有一个 `value` 类型为 `any` 的数据项：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can also have derived interfaces for specific data types:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为特定数据类型有派生接口：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But this does not seem to be good enough. Fortunately, TypeScript provides
    *generics*, so we can rewrite the preceding code as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但这似乎还不够好。幸运的是，TypeScript 提供了 *泛型*，因此我们可以将前面的代码重写如下：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Assuming we have a store that accepts multiple types of data items - for example,
    number and string - we can declare it as follows with the help of the `union`
    type:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个接受多种类型数据项的存储 - 例如，数字和字符串 - 我们可以使用 `union` 类型声明如下：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you remember that we are doing something for offline mobile apps, you might
    be questioning the long property names in changes such as `lastModifiedTime`.
    This is a fair question, and an easy fix is to use `tuple` types, maybe along
    with `enums`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们正在为离线移动应用做些事情，你可能会对更改中长属性名，如 `lastModifiedTime` 提出疑问。这是一个合理的问题，一个简单的解决方案是使用
    `tuple` 类型，也许还可以与 `enums` 一起使用：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can apply less or more of the typing things we are talking about depending
    on your preferences. If you are not familiar with them yet, you can read more
    here: [http://www.typescriptlang.org/handbook](http://www.typescriptlang.org/handbook).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据自己的喜好应用更多或更少的类型化内容。如果您还不熟悉它们，可以在此处了解更多信息：[http://www.typescriptlang.org/handbook](http://www.typescriptlang.org/handbook)。
- en: Supporting multiple clients with incremental data
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持具有增量数据的多个客户端
- en: Making the typing system happy with multiple data types is easy. But in the
    real world, we don't resolve conflicts of all data types by simply comparing the
    last modified times. An example is counting the daily active time of a user cross
    devices.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使类型系统满足多种数据类型很容易。但在现实世界中，我们不会通过简单地比较最后修改时间来解决所有数据类型的冲突。一个例子是跨设备计算用户的每日活跃时间。
- en: 'It''s quite clear that we need to have every piece of active time in a day
    on multiple devices summed up. And this is how we are going to achieve that:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们需要将多台设备上每天的所有活跃时间加起来。这就是我们将如何实现这一点：
- en: Accumulate active durations between synchronizations on the client.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端同步之间累积活跃时长。
- en: Add a UID (unique identifier) to every piece of time before synchronizing with
    the server.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与服务器同步之前，为每一段时间添加一个UID（唯一标识符）。
- en: Increase the server-side value if the UID does not exist yet, and then add the
    UID to that data item.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果UID尚不存在，则增加服务器端值，然后将UID添加到该数据项中。
- en: But before we actually get our hands on those steps, we need a way to distinguish
    incremental data items from normal ones, for example, by adding a `type` property.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们实际着手这些步骤之前，我们需要一种方法来区分增量数据项和普通数据项，例如，通过添加一个`type`属性。
- en: As our synchronizing strategy is server-centered, related information is only
    required for synchronizing requests and conflict merging. Synchronizing responses
    does not need to include the details of changes, but just merged values.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的同步策略是服务器中心的，因此只需要为同步请求和冲突合并提供相关信息。同步响应不需要包括变化的细节，只需合并后的值即可。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I will stop telling how to update every interface step by step as we are approaching
    the final structure. But if you have any problems with that, you can check out
    the complete code bundle for inspiration.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我将停止逐步说明如何更新每个接口，因为我们正在接近最终结构。但如果您在这方面有任何问题，您可以查看完整的代码包以获取灵感。
- en: Updating the client side
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新客户端
- en: First of all, we need the client to support incremental changes. And if you've
    thought about this, you might already be confused about where to put the extra
    information, such as UIDs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要客户端支持增量变化。如果您已经考虑过这个问题，您可能已经对放置额外信息的位置，例如UID，感到困惑。
- en: This is because we were mixing up the concept *change* (noun) with *value*.
    It was not a problem before because, besides the last modified time, the value
    is what a change is about. We used a simple map to store the last modified times
    and kept the store clean from redundancy, which balanced well under that scenario.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们将概念*变化*（名词）与*值*混淆了。在此之前这并不是问题，因为除了最后修改时间外，值就是变化的内容。我们使用一个简单的映射来存储最后修改时间，并保持存储的清洁，这在那种情况下平衡得很好。
- en: 'But now we need to distinguish between these two concepts:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们需要区分这两个概念：
- en: '**Value**: a value describes what a data item is in a static way'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：值以静态方式描述数据项是什么'
- en: '**Change**: a change describes the information that may transform the value
    of a data item from one to another'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变化**：变化描述了可能将数据项的值从一种转换为另一种的信息'
- en: 'We need to have a general type of changes as well as a new data structure for
    incremental changes with a numeric value:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要有一种通用的变化类型，以及一种新的数据结构来处理带有数值的增量变化：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the `string literal` type here, which was introduced in TypeScript
    1.8\. To learn more, please refer to the TypeScript handbook as we mentioned before.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的是`string literal`类型，这是在TypeScript 1.8中引入的。要了解更多信息，请参阅我们之前提到的TypeScript手册。
- en: 'Similar changes to the data store structure should be made. And when we update
    an item on the client side, we need to apply the correct operations based on different
    data types:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 应对数据存储结构进行类似的变化。并且当我们在客户端更新一个项目时，我们需要根据不同的数据类型应用正确的操作：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use the following code for normal changes (while `type` equals `''value''`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码进行常规变化（当`type`等于`'value'`时）：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For incremental changes, it takes a few more lines:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于增量变化，需要更多几行代码：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's my personal preference to use `<T>` for `any` casting and `as T` for non-`any`
    castings. Though it has been used in languages like C#, the `as` operator in TypeScript
    was originally introduced for compatibilities with XML tags in JSX. You can also
    write `<number><any>value` or `value as any as number` here if you like.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人偏好使用`<T>`进行`any`类型转换，以及使用`as T`进行非`any`类型转换。尽管它已在像C#这样的语言中使用，但TypeScript中的`as`操作符最初是为了与JSX中的XML标签兼容而引入的。如果你愿意，你也可以在这里写`<number><any>value`或`value
    as any as number`。
- en: 'Don''t forget to update the stored value. Just change `=` to `+=` comparing
    to updating normal data items:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新存储的值。只需将比较更新正常数据项时的`=`改为`+=`即可：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That's not hard at all. But hey, we see branches.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点也不难。但嘿，我们看到了分支。
- en: We are writing branches all the time, but what are the differences between branches
    such as `if (type === 'foo') { ... }` and branches such as `if (item.timestamp
    > lastTimestamp) { ... }`? Let's keep this question in mind and move on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在编写分支，但`if (type === 'foo') { ... }`和`if (item.timestamp > lastTimestamp)
    { ... }`这样的分支之间有什么区别呢？让我们记住这个问题，然后继续前进。
- en: 'With necessary information added by the `update` method, we can now update
    the `synchronize` method of the client. But there is a flaw in practical scenarios:
    a synchronizing request is sent to the server successfully, but the client failed
    to receive the response from the server. In this situation, when `update` is called
    after a failed synchronization, the increment is added to the might-be-synchronized
    change (identified by its UID), which will be ignored by the server in future
    synchronizations. To fix this, we''ll need to add a mark to all incremental changes
    that have started a synchronizing process, and avoid accumulating these changes.
    Thus, we need to create another change for the same data item.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`update`方法添加必要的信息后，我们现在可以更新客户端的`synchronize`方法。但在实际场景中存在一个缺陷：同步请求成功发送到服务器，但客户端未能接收到服务器的响应。在这种情况下，当在失败的同步之后调用`update`时，增量会被添加到可能已同步的变更（通过其UID识别），在未来的同步中将被服务器忽略。为了解决这个问题，我们需要为所有已经开始同步过程的增量变更添加标记，并避免累积这些变更。因此，我们需要为相同的数据项创建另一个变更。
- en: 'This is actually a nice hint: as a change is about information that transforms
    a value from one to another, several changes pending synchronization might eventually
    be applied to one single data item:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个很好的提示：因为变更涉及的信息是将一个值从一种形式转换为另一种形式，所以几个待同步的变更最终可能会应用到单个数据项上：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now when we are trying to update an incremental data item, we need to get its
    last change from the change list (if any) and see whether it has ever been synchronized.
    If it has ever been involved in a synchronization, we create a new change instance.
    Otherwise, we''ll just accumulate the `increment` property value of the last change
    on the client side:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试更新一个增量数据项时，我们需要从变更列表（如果有）中获取其最后变更，并查看它是否曾经参与过同步。如果它曾经参与过同步，我们将创建一个新的变更实例。否则，我们只需在客户端累积最后变更的`increment`属性值：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or, if the change list does not exist yet, we''ll need to set it up:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果变更列表尚不存在，我们需要将其设置起来：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We also need to update `synchronize` method to mark an incremental change as
    `synced` before starting the synchronization with the server. But the implementation
    is for you to do on your own.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`synchronize`方法，在开始与服务器同步之前将增量变更标记为`synced`。但具体的实现需要你自己来完成。
- en: Updating server side
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新服务器端
- en: 'Before we add the logic for handling incremental changes, we need to make server-side
    code adapt to the new data structure:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加处理增量变更的逻辑之前，我们需要让服务器端代码适应新的数据结构：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The change list of a normal data item will always contain one and only one
    change. Thus we can easily migrate what we''ve written:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正常数据项的变更列表将始终只包含一个变更。因此我们可以轻松迁移我们已编写的代码：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now for incremental changes, we need to cumulatively apply possibly multiple
    changes in a single change list to a data item:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于增量变更，我们需要将可能多个变更累积应用到单个变更列表中的数据项上：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But remember to take care of the timestamp or cases in which no item with a
    specified ID exists:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住要处理时间戳或不存在指定ID的项目的情况：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Without knowing the current value of an incremental data item on the client,
    we cannot assure that the value is up to date. Previously, we decided whether
    to respond with a new value by comparing the timestamp with the timestamp of the
    current synchronization, but that does not work anymore for incremental changes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不知道客户端增量数据项的当前值，我们无法保证该值是最新的。之前，我们通过比较时间戳与当前同步的时间戳来决定是否响应新值，但这种方法对于增量更改不再适用。
- en: 'A simple way to make this work is by deleting keys from `clientChangeLists`
    that still need to be synchronized to the client. And when preparing responses,
    it can skip IDs that are still in `clientChangeLists`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除`clientChangeLists`中仍需要同步到客户端的键，可以简单地使这一过程工作。在准备响应时，它可以跳过`clientChangeLists`中仍存在的ID：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Remember to add `delete clientChangeLists[id];` for normal data items that did
    not survive conflicts resolving as well.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 记得为在解决冲突中未存活的普通数据项添加`delete clientChangeLists[id];`。
- en: Now we have implemented a synchronizing logic that can do quite a lot jobs for
    offline applications. Earlier, I raised a question about increasing branches that
    do not look good. But if you know your features are going to end there, or at
    least with limited changes, it's not a bad implementation, although we'll soon
    cross the balance point, as meeting 80% of the needs won't make us happy enough.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一种同步逻辑，可以为离线应用程序完成很多工作。早些时候，我提出了关于增加分支的问题，这些分支看起来并不好。但如果你知道你的功能将在这里结束，或者至少有有限的变化，这并不是一个糟糕的实现，尽管我们很快就会越过平衡点，因为满足80%的需求不会让我们感到足够满意。
- en: Supporting more conflict merging
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持更多冲突合并
- en: Though we have met the needs of 80%, there is still a big chance that we might
    want some extra features. For example, we want the ratio of the days marked as
    available by the user in the current month, and the user should be able to add
    or remove days from the list. We can achieve that in different ways, and we'll
    choose a simple way, as usual.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经满足了80%的需求，但我们仍然有很大可能想要一些额外的功能。例如，我们想要用户标记为当前月份可用的天数比例，并且用户应该能够从列表中添加或删除天数。我们可以用不同的方式实现这一点，但我们将选择一种简单的方式，就像往常一样。
- en: We are going to support synchronizing a set with operations such as add and
    remove, and calculate the ratio on the client.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将支持通过添加和删除等操作同步集合，并在客户端计算比率。
- en: New data structures
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的数据结构
- en: 'To describe set changes, we need a new `ClientChange` type. When we are adding
    or removing an element from a set, we only care about the last operation to the
    same element. This means that the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述集合更改，我们需要一个新的`ClientChange`类型。当我们向集合中添加或删除一个元素时，我们只关心对同一元素的最后操作。这意味着以下内容：
- en: If multiple operations are made to the same element, we only need to keep the
    last one.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对同一元素进行了多个操作，我们只需要保留最后一个。
- en: A `time` property is required for resolving conflicts.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一个`time`属性来解决问题。
- en: 'So here are the new types:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有新的类型：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The set data stored on the server side is going to be a little different. We''ll
    have a map with the element (in the form of a `string`) as key, and a structure
    with `operation` and `time` properties as the values:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端存储的集合数据将略有不同。我们将有一个以元素（以`string`形式）为键的映射，以及具有`operation`和`time`属性的结构作为值：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now we have enough information to resolve conflicts from multiple clients. And
    we can generate the set by keys with a little help from the last operations done
    to the elements.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的信息来从多个客户端解决冲突。并且我们可以通过键生成集合，这需要借助对元素进行的最后操作：
- en: Updating client side
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新客户端
- en: 'And now, the client-side `update` method gets a new part-time job: saving set
    changes just like value and incremental changes. We need to update the method
    signature for this new job (do not forget to add `''set''` to `DataType`):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端的`update`方法得到了一份兼职工作：保存集合更改，就像值和增量更改一样。我们需要为此新工作更新方法签名（不要忘记将`'set'`添加到`DataType`）：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We also need to add another `else if`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加另一个`else if`：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If there are already operations made to this set, we need to find and remove
    that last operation to the target element (if any). Then append a new change with
    the latest operation:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经对这个集合进行了操作，我们需要找到并删除对目标元素的最后操作（如果有）。然后附加一个包含最新操作的新更改：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If no change has been made since last successful synchronization, we''ll need
    to create a new change list for the latest operation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自上次成功同步以来没有进行任何更改，我们需要为最新的操作创建一个新的更改列表：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: And again, do not forget to update the stored value. This is a little bit more
    than just assigning or accumulating the value, but it should still be quite easy
    to implement.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，不要忘记更新存储的值。这不仅仅是分配或累积值，但它仍然应该相当容易实现。
- en: Updating the server side
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新服务器端
- en: 'Just like we''ve done with the client, we need to add a corresponding `else
    if` branch to merge changes of type `''set''`. We are also deleting the ID from
    `clientChangeLists` regardless of whether there are newer changes for a simpler
    implementation:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对客户端所做的那样，我们需要添加一个相应的`else if`分支来合并类型为`'set'`的更改。我们还在`clientChangeLists`中删除ID，无论是否有更新的更改，以实现更简单的实现：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The conflict resolving logic is quite similar to what we do to the conflicts
    of normal values. We just need to make comparisons to each element, and only keep
    the last operation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突解决逻辑与我们对正常值冲突的处理相当相似。我们只需要对每个元素进行比较，并只保留最后一个操作。
- en: 'And when preparing the response that will be synchronized to the client, we
    can generate the set by putting together elements with `add` as their last operations:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当准备同步到客户端的响应时，我们可以通过将具有`add`作为最后操作的元素组合起来来生成集合：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, we have a working mess (if it actually works). Cheers!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个正在工作的混乱（如果它实际上能工作的话）。干杯！
- en: Things that go wrong while implementing everything
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实现一切时出现的问题
- en: When we started to add features, things were actually fine, if you are not obsessive
    about pursuing the feeling of design. Then we sensed the code being a little awkward
    as we saw more and more nested branches.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始添加功能时，事情实际上很好，如果你不是对设计感追求得过于执着。然后我们感觉到代码有点尴尬，因为我们看到了越来越多的嵌套分支。
- en: So now it's time to answer the question, what are the differences between the
    two kinds of branch we wrote? My understanding of why I am feeling awkward about
    the `if (type === 'foo') { ... }` branch is that it's not strongly related to
    the context. Comparing timestamps, on the other hand, is a more natural part of
    a certain synchronizing process.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候回答问题了，我们编写的两种分支之间有什么区别？我对为什么我对`if (type === 'foo') { ... }`分支感到尴尬的理解是，它与上下文没有很强的关联。另一方面，比较时间戳是同步过程的一个更自然的部分。
- en: Again, I am not saying this is bad. But this gives us a hint about where we
    might start our surgery from when we start to lose control (due to our limited
    brain capacity, it's just a matter of complexity).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我并不是说这是不好的。但这给我们一个提示，当我们开始失去控制（由于我们有限的脑容量，这只是复杂性的问题）时，我们可能从哪里开始我们的手术。
- en: Piling up similar yet parallel processes
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆积类似但平行的过程
- en: Most of the code in this chapter is to handle the process of synchronizing data
    between a client and a server. To get adapted to new features, we just kept adding
    new things into methods, such as `update` and `synchronize`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分代码是用来处理客户端和服务器之间同步数据的过程。为了适应新功能，我们只是不断地在方法中添加新内容，例如`update`和`synchronize`。
- en: You might have already found that most outlines of the logic can be, and should
    be, shared across multiple data types. But we didn't do that.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经发现，大多数逻辑的轮廓都可以，并且应该，在多个数据类型之间共享。但我们没有这样做。
- en: If we look into what's written, the duplication is actually minor judging from
    the aspect of code texts. Taking the `update` method of the client, for example,
    the logic of every branch seems to differ. If finding abstractions has not become
    your built-in reaction, you might just stop there. Or if you are not a fan of
    long functions, you might refactor the code by splitting it into small ones of
    the same class. That could make things a little better, but far from enough.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察，从代码文本的角度来看，重复实际上是很小的。以客户端的`update`方法为例，每个分支的逻辑似乎都不同。如果你还没有形成内置的抽象反应，你可能会就此停止。或者如果你不喜欢长函数，你可能会通过将其拆分为相同类的小函数来重构代码。这可能会让事情变得更好，但远远不够。
- en: Data stores that are tremendously simplified
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据存储被极大地简化了
- en: In the implementation, we were playing heavily and directly with ideal *in-memory*
    stores. It would be nice if we could have a wrapper for it, and make the real
    store interchangeable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中，我们与理想的*内存*存储进行了大量的直接操作。如果能有一个包装器，并使其真正的存储可互换，那会很好。
- en: This might not be the case for this implementation as it is based on extremely
    ideal and simplified assumptions and requirements. But adding a wrapper could
    be a way to provide useful helpers.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实现来说，这可能不是情况，因为它基于极其理想和简化的假设和要求。但添加一个包装器可能是一种提供有用辅助工具的方法。
- en: Getting things right
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保正确
- en: 'So let''s get out of the illusion of comparing code one character at a time
    and try to find an abstraction that can be applied to updating all of these data
    types. There are two key points of this abstraction that have already been mentioned
    in the previous section:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们摆脱逐字符比较代码的错觉，并尝试找到一个可以应用于更新所有这些数据类型的抽象。这个抽象的两个关键点已经在上一节中提到：
- en: A `change` contains the information that can transform the value of an item
    from one to another
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`change`包含将一个项目的值从一种转换为另一种所需的信息
- en: Multiple changes could be generated or applied to one data item during a single
    synchronization
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单次同步过程中，可能对单个数据项生成或应用多个变化
- en: Now, starting from changes, let's think about what happens when an `update`
    method of a client is called.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从变化开始，让我们思考当客户端的`update`方法被调用时会发生什么。
- en: Finding abstraction
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找抽象
- en: 'Take a closer look to the method `update` of client:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看客户端的`update`方法：
- en: For data of the `'value'` type, first we create the change, including a new
    value, and then update the change list to make the newly created change the only
    one. After that, we update the value of data item.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`'value'`类型的数据，首先我们创建变化，包括一个新值，然后更新变化列表，使新创建的变化成为唯一的变化。之后，我们更新数据项的值。
- en: For data of the `'increment'` type, we add a change including the increment
    in the change list; or if a change that has not be synchronized already exists,
    update the increment of the existing change. And then, we update the value of
    the data item.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`'increment'`类型的数据，我们在变化列表中添加一个包含增量变化的变化；或者如果已经存在尚未同步的变化，则更新现有变化中的增量。然后，我们更新数据项的值。
- en: Finally, for data of the `'set'` type, we create a change reflecting the latest
    operation. After adding the new change to the change list, we also remove changes
    that are no longer necessary. Then we update the value of the data item.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，对于`'set'`类型的数据，我们创建一个反映最新操作的变化。在将新的变化添加到变化列表后，我们也移除不再必要的变化。然后我们更新数据项的值。
- en: 'Things are getting clear. Here is what''s happening to these data types when
    `update` is called:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 事情越来越清晰。以下是当调用`update`时这些数据类型所发生的情况：
- en: Create new change.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的变化。
- en: Merge the new change to the change list.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的变化合并到变化列表中。
- en: Apply the new change to the data item.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的变化应用于数据项。
- en: Now it's even better. Every step is different for different data types, but
    different steps share the same outline; what we need to do is to implement different
    strategies for different data types.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在甚至更好。对于不同的数据类型，每一步都是不同的，但不同的步骤具有相同的轮廓；我们需要做的是为不同的数据类型实现不同的策略。
- en: Implementing strategies
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施策略
- en: 'Doing all kind of changes with a single `update` function could be confusing.
    And before we move on, let''s split it into three different methods: `update`
    for normal values, `increase` for incremental values, and `addTo`/`removeFrom`
    for sets.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个`update`函数执行所有类型的更改可能会令人困惑。在我们继续之前，让我们将其拆分为三个不同的方法：`update`用于普通值，`increase`用于增量值，以及`addTo`/`removeFrom`用于集合。
- en: 'Then we are going to create a new private method called `applyChange`, which
    will take the change created by other methods and continue with step 2 and step
    3\. It accepts a strategy object with two methods: `append` and `apply`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个新的私有方法`applyChange`，它将接受由其他方法创建的变化，并继续执行步骤2和步骤3。它接受一个具有两个方法`append`和`apply`的策略对象：
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For a normal data item, the strategy object could be as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个普通的数据项，策略对象可能如下所示：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And for incremental data item, it takes a few more lines. First, the `append`
    method:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于增量数据项，需要更多几行代码。首先，`append`方法：
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `append` method is followed by the `apply` method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`方法之后跟随`apply`方法：'
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now in the `applyChange` method, we need to take care of the creation of non-existing
    items and change lists, and invoke different `append` and `apply` methods based
    on different data types.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`applyChange`方法中，我们需要注意非现有项目和变化列表的创建，并根据不同的数据类型调用不同的`append`和`apply`方法。
- en: The same technique can be applied to other processes. Though detailed processes
    that apply to the client and the server differ, we can still write them together
    as modules.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术可以应用于其他过程。尽管适用于客户端和服务器端的详细过程不同，但我们仍然可以将它们一起作为模块编写。
- en: Wrapping stores
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装存储
- en: 'We are going to make a lightweight wrapper around plain in-memory store objects
    with the ability to read and write, taking the server-side store as an example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在具有读写能力的普通内存存储对象周围创建一个轻量级包装器，以服务器端存储为例：
- en: '[PRE62]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To fit our requirements, we need to implement `get`, `set`, and `getAll` methods
    (or even better, a `find` method with conditions) for `ServerStore`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足我们的需求，我们需要为`ServerStore`实现`get`、`set`和`getAll`方法（或者更好的是，一个带有条件的`find`方法）：
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You may have noticed from the interfaces and generics that I've also torn down
    `ServerDataItem` into intersection types of the common part and extras.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，从接口和泛型中，我还将`ServerDataItem`拆分成了公共部分和额外部分的交叉类型。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've been part of the evolution of a simplified yet reality-related
    project. Starting with a simple code base that couldn't be wrong, we added a lot
    of features and experienced the process of putting acceptable changes together
    and making the whole thing a mess.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们参与了这样一个简化但与现实相关的项目的演变过程。从一个简单的代码库开始，这个代码库不可能出错，我们添加了许多功能，并经历了将可接受的变化组合起来并使整个项目变得混乱的过程。
- en: We were always trying to write readable code by either naming things nicely
    or adding semantically necessary redundancies, but that won't help much as the
    complexity grows.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是试图通过优雅的命名或添加必要的语义冗余来编写可读的代码，但随着复杂性的增加，这并不会有多大帮助。
- en: During the process, we've learned how offline synchronizing works. And with
    the help of the most common design patterns, such as the Strategy Pattern, we
    managed to split the project into small and controllable parts.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们学习了离线同步的工作原理。借助最常见的设计模式，例如策略模式（Strategy Pattern），我们成功地将项目拆分为小而可控的部分。
- en: In the upcoming chapters, we'll catalog more useful design patterns with code
    examples in TypeScript, and try to apply those design patterns to specific issues.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用TypeScript中的代码示例来列出更多有用的设计模式，并尝试将这些设计模式应用到具体问题上。
