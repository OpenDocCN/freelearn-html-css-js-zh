- en: Chapter 2. The Challenge of Increasing Complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The essence of a program is the combination of possible branches and automated
    selections based on certain conditions. When we write a program, we define what's
    going on in a branch, and under what condition this branch will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The number of branches usually grows quickly during the evolution of a project,
    as well as the number of conditions that determine whether a branch will be executed
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: This is dangerous for human beings, who have limited brain capacities.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to implement a data synchronizing service. Starting
    by implementing some very basic features, we'll keep adding stuff and see how
    things go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a multi-device synchronizing strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful JavaScript and TypeScript techniques and hints that are related, including
    objects as maps and the string literal type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Strategy Pattern helps in a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to write actual code, we need to define what this synchronizing
    strategy will be like. To keep the implementation from unnecessary distractions,
    the client will communicate with the server directly through function calls instead
    of using HTTP requests or Sockets. Also, we'll use **in-memory storage**, namely
    variables, to store data on both client and server sides.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are not separating the client and server into two actual applications,
    and we are not actually using backend technologies, it does not require much Node.js
    experience to follow this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, please keep in mind that even though we are omitting network and database
    requests, we hope the core logic of the final implementation could be applied
    to a real environment without being modified too much. So, when it comes to performance
    concerns, we still need to assume limited network resources, especially for data
    passing through the server and client, although the implementation is going to
    be synchronous instead of asynchronous. This is not supposed to happen in practice,
    but involving asynchronous operations will introduce much more code, as well as
    many more situations that need to be taken into consideration. But we will have
    some useful patterns on asynchronous programming in the coming chapters, and it
    would definitely help if you try to implement an asynchronous version of the synchronizing
    logic in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A client, if without modifying what's been synchronized, stores a copy of all
    the data available on the server, and what we need to do is to provide a set of
    APIs that enable the client to keep its copy of data synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, it is really simple at the beginning: comparing the last-modified timestamp.
    If the timestamp on the client is older than what''s on the server, then update
    the copy of data along with new timestamp.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the code base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, let''s create `server.ts` and `client.ts` files containing the `Server`
    class and `Client` class respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I prefer to create an `index.ts` file as the package entry, which handles what
    to export internally. In this case, let''s export everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To import the `Server` and `Client` classes from a test file (assuming `src/test/test.ts`),
    we can use the following codeto s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Defining the initial structure of the data to be synchronized
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we need to compare the timestamps from the client and server, we need
    to have a `timestamp` property on the data structure. I would like to have the
    data to synchronize as a string, so let''s add a `DataStore` interface with a
    `timestamp` property to the `server.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Getting data by comparing timestamps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the synchronizing strategy is one-way, from the server to the client.
    So what we need to do is simple: we compare the timestamps; if the server has
    the newer one, it responds with data and the server-side timestamp; otherwise,
    it responds with `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have provided a simple API for the client, and it''s time to implement
    the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prefixing a `constructor` parameter with access modifiers (including `public`,
    `private`, and `protected`) will create a property with the same name and corresponding
    accessibility. It will also assign the value automatically when the constructor
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add a `synchronize` method to the `Client` class that does the
    job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's easily done. However, are you already feeling somewhat awkward with what
    we've written?
  prefs: []
  type: TYPE_NORMAL
- en: Two-way synchronizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, when we talk about synchronization, we get updates from the server
    and push changes to the server as well. Now we are going to do the second part,
    pushing the changes if the client has newer data.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, we need to give the client the ability to update its data by adding
    an `update` method to the `Client` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need the server to have the ability to receive data from the client
    as well. So we rename the `getData` method of the `Server` class as `synchronize`
    and make it satisfy the new job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the basic implementation of our synchronizing service. Later, we'll
    keep adding new things and make it capable of dealing with a variety of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Things that went wrong while implementing the basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, what we've written is just too simple to be wrong. But there are
    still some semantic issues.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a data store from the server to the client does not make sense
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used `DataStore` as the return type of the `synchronize` method on `Server`.
    But what we were actually passing through is not a data store, but information
    that involves data and its timestamp. The information object just *happened to*
    have the same properties as a data store *at this point in time*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it will be misleading to people who will later read your code (including
    yourself in the future). Most of the time, we are trying to eliminate redundancies.
    But that does not have to mean everything that looks the same. So let''s make
    it two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I would even prefer to create another instance, instead of directly returning
    `this.store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, if two pieces of code with different semantic meanings are doing the
    same thing from the perspective of code itself, you may consider extracting that
    part as a utility.
  prefs: []
  type: TYPE_NORMAL
- en: Making the relationships clear
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we have two separated interfaces, `DataStore` and `DataSyncingInfo`, in
    `server.ts`. Obviously, `DataSyncingInfo` should be a shared interface between
    the server and the client, while `DataStore` happens to be the same on both sides,
    but it's not actually shared.
  prefs: []
  type: TYPE_NORMAL
- en: So what we are going to do is to create a separate `shared.d.ts` (it could also
    be `shared.ts` if it contains more than `typings`) that exports `DataSyncingInfo`
    and add another `DataStore` to `client.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not follow this blindly. Sometimes it is designed for the server and the
    client to have exactly the same stores. If that's the situation, the interface
    should be shared.
  prefs: []
  type: TYPE_NORMAL
- en: Growing features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we've done so far is basically useless. But, from now on, we will start
    to add features and make it capable of fitting in practical needs, including the
    capability of synchronizing multiple data items with multiple clients, and merging
    conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing multiple items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ideally, the data we need to synchronize will have a lot of items contained.
    Directly changing the type of `data` to an array would work if there were only
    very limited number of these items.
  prefs: []
  type: TYPE_NORMAL
- en: Simply replacing data type with an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's change the type of the `data` property of `DataStore` and `DataSyncingInfo`
    interfaces to `string[]`. With the help of TypeScript, you will get errors for
    unmatched types this change would cause. Fix them by annotating the correct types.
  prefs: []
  type: TYPE_NORMAL
- en: But obviously, this is far from an efficient solution.
  prefs: []
  type: TYPE_NORMAL
- en: Server-centered synchronization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the data store contains a lot of data, the ideal approach would be only updating
    items that are not up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can create a timestamp for every single item and send these
    timestamps to the server, then let the server decide whether a specific data item
    is up-to-date. This is a viable approach for certain scenarios, such as checking
    updates for software extensions. It is okay to occasionally send even hundreds
    of timestamps with item IDs on a fast network, but we are going to use another
    approach for different scenarios, or I won't have much to write.
  prefs: []
  type: TYPE_NORMAL
- en: User data synchronization of offline apps on a mobile phone is what we are going
    to deal with, which means we need to try our best to avoid wasting network resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is an interesting question. What are the differences between user data
    synchronization and checking extension updates? Think about the size of data,
    issues with multiple devices, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we thought about sending timestamps of all items is for the server
    to determine whether certain items need to be updated. However, is it necessary
    to have the timestamps of all data items stored on the client side?
  prefs: []
  type: TYPE_NORMAL
- en: What if we choose not to store the timestamp of data changing, but of data being
    synchronized with the server? Then we can get everything up-to-date by only sending
    the timestamp of the last successful synchronization. The server will then compare
    this timestamp with the last modified timestamps of all data items and decide
    how to respond.
  prefs: []
  type: TYPE_NORMAL
- en: As the title of this part suggests, the process is server-centered and relies
    on the server to generate the timestamps (though it does not have to, and practically
    should not, be the stamp of the actual time).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are getting confused about how these timestamps work, let's try again.
    The server will store the timestamps of the last time items were synchronized,
    and the client will store the timestamp of the last successful synchronization
    with the server. Thus, if no item on the server has a later timestamp than the
    client, then there's no change to the server data store after that timestamp.
    But if there are some changes, by comparing the timestamp of the client with the
    timestamps of server items, we'll know which items are newer.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing from the server to the client
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now there seems to be quite a lot to change. Firstly, let's handle synchronizing
    data from server to client.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what''s expected to happen on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a timestamp and identity to every data item on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare the client timestamp with every data item on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don't need to actually compare the client timestamp with every item on server
    if those items have a sorted index. The performance would be acceptable using
    a database with a sorted index.
  prefs: []
  type: TYPE_NORMAL
- en: Respond with items newer than what the client has as well as a new timestamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here''s what''s expected to happen on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronize with the last timestamp sent to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the local store with new data responded by the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the local timestamp of the last synchronization if it completes without
    error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updating interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have now an updated data store on both sides. Starting with
    the server, the data store now contains an array of data items. So let''s define
    the `ServerDataItem` interface and update `ServerDataStore` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `{ [id: string]: ServerDataItem }` type describes an object with `id` of
    type `string` as a key and has the value of type `ServerDataItem`. Thus, an item
    of type `ServerDataItem` can be accessed by `items[''the-id'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And for the client, we now have different data items and a different store.
    The response contains only a subset of all data items, so we need IDs and a map
    with ID as the index to store the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, the client and server were sharing the same `DataSyncingInfo`,
    but that''s going to change. As we''ll deal with server-to-client synchronizing
    first, we care only about the timestamp in a synchronizing request for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the response from the server, it is expected to have an updated timestamp
    with data items that have changed compared to the request timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I prefixed those interfaces with *Server* and *Client* for better differentiation.
    But it's not necessary if you are not exporting everything from `server.ts` and
    `client.ts` (in `index.ts`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating the server side**'
  prefs: []
  type: TYPE_NORMAL
- en: 'With well-defined data structures, it should be pretty easy to achieve what
    we expected. To begin with, we have the `synchronize` method, which accepts a
    `SyncingRequest` and returns a `SyncingResponse`; and we need to have the updated
    timestamp as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the `serverChanges` object, `{}` (an object literal) might be the first
    thing (if not an ES6 Map) that comes to mind. But it's not absolutely safe to
    do so, because it would refuse `__proto__` as a key. The better choice would be
    `Object.create(null)`, which accepts all strings as its key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to add items that are newer than the client to `serverChanges`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Updating the client side**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve changed the type of `items` under `ClientDataStore` to a map, we
    need to fix the initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s update the `synchronize` method. Firstly, the client is going to
    send a request with a timestamp and get a response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll save the newer data items to the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update the timestamp of the last successful synchronization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Updating the synchronization timestamp should be the last thing to do during
    a complete synchronization process. Make sure it's not stored earlier than data
    items, or you might have a broken offline copy if there's any errors or interruptions
    during synchronizing in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ensure that this works as expected, an operation with the same change information
    should give the same results even if it's applied multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing from client to server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a server-centered synchronizing process, most of the changes are made through
    clients. Consequently, we need to figure out how to organize these changes before
    sending them to the server.
  prefs: []
  type: TYPE_NORMAL
- en: One single client only cares about its own copy of data. What difference would
    this make when comparing to the process of synchronizing data from the server
    to clients? Well, think about why we need the timestamp of every data item on
    the server in the first place. We need them because we want to know which items
    are new compared to a specific client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for changes on a client: if they ever happen, they need to be synchronized
    to the server without requiring specific timestamps for comparison.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we might have more than one client with changes that need to be synchronized,
    which means that changes made later in time might actually get synchronized earlier,
    and thus we'll have to resolve conflicts. To achieve that, we need to add the
    last modified time back to every data item on the server and the changed items
    on the client.
  prefs: []
  type: TYPE_NORMAL
- en: I've mentioned that the timestamps stored on the server for finding out what
    needs to be synchronized to a client do not need to be (and better not be) an
    actual stamp of a physical time point. For example, it could be the count of synchronizations
    that happened between all clients and the server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating the client side**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this efficiently, we may create a separated map with the IDs of the
    data items that have changed as keys and the last modified time as the value in
    `ClientDataStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You may also want to initialize its value as `Object.create(null)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we update an item in the client store, we add the last modified time
    to the `changed` map as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A single timestamp in `SyncingRequest` certainly won''t do the job any more;
    we need to add a place for the changed data, a map with data item ID as the index,
    and the changed information as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here comes another problem. What if a change made to a client data item is
    done offline, with the system clock being at the wrong time? Obviously, we need
    some time calibration mechanisms. However, there''s no way to make perfect calibration.
    We''ll make some assumptions so we don''t need to start another chapter for time
    calibration:'
  prefs: []
  type: TYPE_NORMAL
- en: The system clock of a client may be late or early compared to the server. But
    it ticks at a normal speed and won't jump between times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request sent from a client reaches the server in a relatively short time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With those assumptions, we can add those building blocks to the client-side
    `synchronize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add client-side changes to the synchronizing request (of course, before sending
    it to the server):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Synchronize changes to the server with the current time of the client''s clock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clean the changes after a successful synchronization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Updating the server side**'
  prefs: []
  type: TYPE_NORMAL
- en: If the client is working as expected, it should send synchronizing requests
    with changes. It's time to enable the server to handling those changes from the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are going to be two steps for the server-side synchronization process:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the client changes to server data store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the changes that need to be synchronized to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to add `lastModifiedTime` to server-side data items, as we mentioned
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to update the `synchronize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can actually use the `in` operator instead of `hasOwnProperty` here because
    the `items` object is created with `null` as its prototype. But a reference to
    `hasOwnProperty` will be your friend if you are using objects created by object
    literals, or in other ways, such as maps.
  prefs: []
  type: TYPE_NORMAL
- en: We already talked about resolving conflicts by comparing the last modified times.
    At the same time, we've made assumptions so we can calibrate the last modified
    times from the client easily by passing the client time to the server while synchronizing.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are going to do for calibration is to calculate the offset of the client
    time compared to the server time. And that''s why we made the second assumption:
    the request needs to easily reach the server in a relatively short time. To calculate
    the offset, we can simply subtract the client time from the server time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make the time calibration more accurate, we would want the earliest timestamp
    after the request hits the server to be recorded as "now". So in practice, you
    might want to record the timestamp of the request hitting the server before start
    processing everything. For example, for HTTP request, you may record the timestamp
    once the TCP connection gets established.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, the calibrated time of a client change is the sum of the original
    time and the offset. We can now decide whether to keep or ignore a change from
    the client by comparing the calibrated last modified time. It is possible for
    the calibrated time to be greater than the server time; you can choose either
    to use the server time as the maximum value or accept a small inaccuracy. Here,
    we will go the simple way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this actually work, we need to also exclude changes from the server
    that conflict with client changes in `SyncingResponse`. To do so, we need to know
    what the changes are that survive the conflict resolving process. A simple way
    is to exclude items with timestamp that equals `now`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So now we have implemented a complete synchronization logic with the ability
    to handle simple conflicts in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing multiple types of data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we've hard coded the data with the `string` type. But usually
    we will need to store varieties of data, such as numbers, booleans, objects, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were writing JavaScript, we would not actually need to change anything,
    as the implementation does not have anything to do with certain data types. In
    TypeScript, we don''t need to do much either: just change the type of every related
    `value` to `any`. But that means you are losing type safety, which would definitely
    be okay if you are happy with that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But taking my own preferences, I would like every variable, parameter, and
    property to be typed if it''s possible. So we may still have a data item with
    `value` of type `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also have derived interfaces for specific data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'But this does not seem to be good enough. Fortunately, TypeScript provides
    *generics*, so we can rewrite the preceding code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming we have a store that accepts multiple types of data items - for example,
    number and string - we can declare it as follows with the help of the `union`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember that we are doing something for offline mobile apps, you might
    be questioning the long property names in changes such as `lastModifiedTime`.
    This is a fair question, and an easy fix is to use `tuple` types, maybe along
    with `enums`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can apply less or more of the typing things we are talking about depending
    on your preferences. If you are not familiar with them yet, you can read more
    here: [http://www.typescriptlang.org/handbook](http://www.typescriptlang.org/handbook).'
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple clients with incremental data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making the typing system happy with multiple data types is easy. But in the
    real world, we don't resolve conflicts of all data types by simply comparing the
    last modified times. An example is counting the daily active time of a user cross
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s quite clear that we need to have every piece of active time in a day
    on multiple devices summed up. And this is how we are going to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: Accumulate active durations between synchronizations on the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UID (unique identifier) to every piece of time before synchronizing with
    the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the server-side value if the UID does not exist yet, and then add the
    UID to that data item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But before we actually get our hands on those steps, we need a way to distinguish
    incremental data items from normal ones, for example, by adding a `type` property.
  prefs: []
  type: TYPE_NORMAL
- en: As our synchronizing strategy is server-centered, related information is only
    required for synchronizing requests and conflict merging. Synchronizing responses
    does not need to include the details of changes, but just merged values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I will stop telling how to update every interface step by step as we are approaching
    the final structure. But if you have any problems with that, you can check out
    the complete code bundle for inspiration.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the client side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all, we need the client to support incremental changes. And if you've
    thought about this, you might already be confused about where to put the extra
    information, such as UIDs.
  prefs: []
  type: TYPE_NORMAL
- en: This is because we were mixing up the concept *change* (noun) with *value*.
    It was not a problem before because, besides the last modified time, the value
    is what a change is about. We used a simple map to store the last modified times
    and kept the store clean from redundancy, which balanced well under that scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now we need to distinguish between these two concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value**: a value describes what a data item is in a static way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change**: a change describes the information that may transform the value
    of a data item from one to another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to have a general type of changes as well as a new data structure for
    incremental changes with a numeric value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using the `string literal` type here, which was introduced in TypeScript
    1.8\. To learn more, please refer to the TypeScript handbook as we mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar changes to the data store structure should be made. And when we update
    an item on the client side, we need to apply the correct operations based on different
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code for normal changes (while `type` equals `''value''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For incremental changes, it takes a few more lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's my personal preference to use `<T>` for `any` casting and `as T` for non-`any`
    castings. Though it has been used in languages like C#, the `as` operator in TypeScript
    was originally introduced for compatibilities with XML tags in JSX. You can also
    write `<number><any>value` or `value as any as number` here if you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to update the stored value. Just change `=` to `+=` comparing
    to updating normal data items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That's not hard at all. But hey, we see branches.
  prefs: []
  type: TYPE_NORMAL
- en: We are writing branches all the time, but what are the differences between branches
    such as `if (type === 'foo') { ... }` and branches such as `if (item.timestamp
    > lastTimestamp) { ... }`? Let's keep this question in mind and move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'With necessary information added by the `update` method, we can now update
    the `synchronize` method of the client. But there is a flaw in practical scenarios:
    a synchronizing request is sent to the server successfully, but the client failed
    to receive the response from the server. In this situation, when `update` is called
    after a failed synchronization, the increment is added to the might-be-synchronized
    change (identified by its UID), which will be ignored by the server in future
    synchronizations. To fix this, we''ll need to add a mark to all incremental changes
    that have started a synchronizing process, and avoid accumulating these changes.
    Thus, we need to create another change for the same data item.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is actually a nice hint: as a change is about information that transforms
    a value from one to another, several changes pending synchronization might eventually
    be applied to one single data item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we are trying to update an incremental data item, we need to get its
    last change from the change list (if any) and see whether it has ever been synchronized.
    If it has ever been involved in a synchronization, we create a new change instance.
    Otherwise, we''ll just accumulate the `increment` property value of the last change
    on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if the change list does not exist yet, we''ll need to set it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We also need to update `synchronize` method to mark an incremental change as
    `synced` before starting the synchronization with the server. But the implementation
    is for you to do on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Updating server side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we add the logic for handling incremental changes, we need to make server-side
    code adapt to the new data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The change list of a normal data item will always contain one and only one
    change. Thus we can easily migrate what we''ve written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for incremental changes, we need to cumulatively apply possibly multiple
    changes in a single change list to a data item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'But remember to take care of the timestamp or cases in which no item with a
    specified ID exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Without knowing the current value of an incremental data item on the client,
    we cannot assure that the value is up to date. Previously, we decided whether
    to respond with a new value by comparing the timestamp with the timestamp of the
    current synchronization, but that does not work anymore for incremental changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way to make this work is by deleting keys from `clientChangeLists`
    that still need to be synchronized to the client. And when preparing responses,
    it can skip IDs that are still in `clientChangeLists`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Remember to add `delete clientChangeLists[id];` for normal data items that did
    not survive conflicts resolving as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have implemented a synchronizing logic that can do quite a lot jobs for
    offline applications. Earlier, I raised a question about increasing branches that
    do not look good. But if you know your features are going to end there, or at
    least with limited changes, it's not a bad implementation, although we'll soon
    cross the balance point, as meeting 80% of the needs won't make us happy enough.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting more conflict merging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though we have met the needs of 80%, there is still a big chance that we might
    want some extra features. For example, we want the ratio of the days marked as
    available by the user in the current month, and the user should be able to add
    or remove days from the list. We can achieve that in different ways, and we'll
    choose a simple way, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to support synchronizing a set with operations such as add and
    remove, and calculate the ratio on the client.
  prefs: []
  type: TYPE_NORMAL
- en: New data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To describe set changes, we need a new `ClientChange` type. When we are adding
    or removing an element from a set, we only care about the last operation to the
    same element. This means that the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If multiple operations are made to the same element, we only need to keep the
    last one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `time` property is required for resolving conflicts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So here are the new types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The set data stored on the server side is going to be a little different. We''ll
    have a map with the element (in the form of a `string`) as key, and a structure
    with `operation` and `time` properties as the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now we have enough information to resolve conflicts from multiple clients. And
    we can generate the set by keys with a little help from the last operations done
    to the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Updating client side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'And now, the client-side `update` method gets a new part-time job: saving set
    changes just like value and incremental changes. We need to update the method
    signature for this new job (do not forget to add `''set''` to `DataType`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add another `else if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are already operations made to this set, we need to find and remove
    that last operation to the target element (if any). Then append a new change with
    the latest operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If no change has been made since last successful synchronization, we''ll need
    to create a new change list for the latest operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: And again, do not forget to update the stored value. This is a little bit more
    than just assigning or accumulating the value, but it should still be quite easy
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the server side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like we''ve done with the client, we need to add a corresponding `else
    if` branch to merge changes of type `''set''`. We are also deleting the ID from
    `clientChangeLists` regardless of whether there are newer changes for a simpler
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The conflict resolving logic is quite similar to what we do to the conflicts
    of normal values. We just need to make comparisons to each element, and only keep
    the last operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'And when preparing the response that will be synchronized to the client, we
    can generate the set by putting together elements with `add` as their last operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have a working mess (if it actually works). Cheers!
  prefs: []
  type: TYPE_NORMAL
- en: Things that go wrong while implementing everything
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we started to add features, things were actually fine, if you are not obsessive
    about pursuing the feeling of design. Then we sensed the code being a little awkward
    as we saw more and more nested branches.
  prefs: []
  type: TYPE_NORMAL
- en: So now it's time to answer the question, what are the differences between the
    two kinds of branch we wrote? My understanding of why I am feeling awkward about
    the `if (type === 'foo') { ... }` branch is that it's not strongly related to
    the context. Comparing timestamps, on the other hand, is a more natural part of
    a certain synchronizing process.
  prefs: []
  type: TYPE_NORMAL
- en: Again, I am not saying this is bad. But this gives us a hint about where we
    might start our surgery from when we start to lose control (due to our limited
    brain capacity, it's just a matter of complexity).
  prefs: []
  type: TYPE_NORMAL
- en: Piling up similar yet parallel processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the code in this chapter is to handle the process of synchronizing data
    between a client and a server. To get adapted to new features, we just kept adding
    new things into methods, such as `update` and `synchronize`.
  prefs: []
  type: TYPE_NORMAL
- en: You might have already found that most outlines of the logic can be, and should
    be, shared across multiple data types. But we didn't do that.
  prefs: []
  type: TYPE_NORMAL
- en: If we look into what's written, the duplication is actually minor judging from
    the aspect of code texts. Taking the `update` method of the client, for example,
    the logic of every branch seems to differ. If finding abstractions has not become
    your built-in reaction, you might just stop there. Or if you are not a fan of
    long functions, you might refactor the code by splitting it into small ones of
    the same class. That could make things a little better, but far from enough.
  prefs: []
  type: TYPE_NORMAL
- en: Data stores that are tremendously simplified
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the implementation, we were playing heavily and directly with ideal *in-memory*
    stores. It would be nice if we could have a wrapper for it, and make the real
    store interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: This might not be the case for this implementation as it is based on extremely
    ideal and simplified assumptions and requirements. But adding a wrapper could
    be a way to provide useful helpers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting things right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So let''s get out of the illusion of comparing code one character at a time
    and try to find an abstraction that can be applied to updating all of these data
    types. There are two key points of this abstraction that have already been mentioned
    in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: A `change` contains the information that can transform the value of an item
    from one to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple changes could be generated or applied to one data item during a single
    synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, starting from changes, let's think about what happens when an `update`
    method of a client is called.
  prefs: []
  type: TYPE_NORMAL
- en: Finding abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a closer look to the method `update` of client:'
  prefs: []
  type: TYPE_NORMAL
- en: For data of the `'value'` type, first we create the change, including a new
    value, and then update the change list to make the newly created change the only
    one. After that, we update the value of data item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For data of the `'increment'` type, we add a change including the increment
    in the change list; or if a change that has not be synchronized already exists,
    update the increment of the existing change. And then, we update the value of
    the data item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, for data of the `'set'` type, we create a change reflecting the latest
    operation. After adding the new change to the change list, we also remove changes
    that are no longer necessary. Then we update the value of the data item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Things are getting clear. Here is what''s happening to these data types when
    `update` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Merge the new change to the change list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the new change to the data item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it's even better. Every step is different for different data types, but
    different steps share the same outline; what we need to do is to implement different
    strategies for different data types.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Doing all kind of changes with a single `update` function could be confusing.
    And before we move on, let''s split it into three different methods: `update`
    for normal values, `increase` for incremental values, and `addTo`/`removeFrom`
    for sets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we are going to create a new private method called `applyChange`, which
    will take the change created by other methods and continue with step 2 and step
    3\. It accepts a strategy object with two methods: `append` and `apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For a normal data item, the strategy object could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And for incremental data item, it takes a few more lines. First, the `append`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `append` method is followed by the `apply` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now in the `applyChange` method, we need to take care of the creation of non-existing
    items and change lists, and invoke different `append` and `apply` methods based
    on different data types.
  prefs: []
  type: TYPE_NORMAL
- en: The same technique can be applied to other processes. Though detailed processes
    that apply to the client and the server differ, we can still write them together
    as modules.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to make a lightweight wrapper around plain in-memory store objects
    with the ability to read and write, taking the server-side store as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To fit our requirements, we need to implement `get`, `set`, and `getAll` methods
    (or even better, a `find` method with conditions) for `ServerStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed from the interfaces and generics that I've also torn down
    `ServerDataItem` into intersection types of the common part and extras.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've been part of the evolution of a simplified yet reality-related
    project. Starting with a simple code base that couldn't be wrong, we added a lot
    of features and experienced the process of putting acceptable changes together
    and making the whole thing a mess.
  prefs: []
  type: TYPE_NORMAL
- en: We were always trying to write readable code by either naming things nicely
    or adding semantically necessary redundancies, but that won't help much as the
    complexity grows.
  prefs: []
  type: TYPE_NORMAL
- en: During the process, we've learned how offline synchronizing works. And with
    the help of the most common design patterns, such as the Strategy Pattern, we
    managed to split the project into small and controllable parts.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we'll catalog more useful design patterns with code
    examples in TypeScript, and try to apply those design patterns to specific issues.
  prefs: []
  type: TYPE_NORMAL
