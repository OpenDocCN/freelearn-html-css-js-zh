<html><head></head><body>
		<div><h1 id="_idParaDest-105"><em class="italic"><a id="_idTextAnchor104"/>Chapter 6</em>: Executing and Injecting JavaScript</h1>
			<p>In the past few chapters, we learned about most of the basic Puppeteer features, from creating a browser and a page correctly, to finding elements and interacting with them.</p>
			<p>Now it's time to get into more powerful tools. In this chapter, we will see how Puppeteer gives us the ability to execute JavaScript code in the browser.</p>
			<p>It might sound like a hack or a last resort tool. Sometimes it is. But it is also a tool that will help us perform actions that are not provided by the Puppeteer API.</p>
			<p>The communication between the code being executed on the Node side and the code being executed in the browser can sometimes be tricky. We will learn how to communicate with both sides efficiently.</p>
			<p>As we did in the previous chapter, we will add another tool to our toolbox. We are going to run our code on <em class="italic">Checkly</em>. </p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Executing JavaScript code</li>
				<li>Manipulating handles with JavaScript code</li>
				<li>Waiting for functions</li>
				<li>Exposing local functions</li>
				<li><a id="_idTextAnchor105"/><a id="_idTextAnchor106"/>Running our checks with Checkly</li>
			</ul>
			<p>By the end of this chapter, you will be able to get more out of the page you are automating by executing JavaScript code.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Technical requirements</h1>
			<p>You will find all the code of this chapter in the GitHub repository (<a href="https://github.com/PacktPublishing/UI-Testing-with-Puppeteer">https://github.com/PacktPublishing/UI-Testing-with-Puppeteer</a>) under the <code>Chapter6</code> directory. Remember to run <code>npm install</code> on that directory and then go to the <code>Chapter6/vuejs-firebase-shopping-cart</code> directory and run <code>npm install</code> again.</p>
			<p>If you want to implement the code while following this chapter, you can start from the code you left in the <code>Chapter5</code> directory.</p>
			<p>Let's get started.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>Executing JavaScript code</h1>
			<p>The<a id="_idIndexMarker304"/> first question you might ask is: "Why would I need to run JavaScript code? Shouldn't Puppeteer give me all the APIs I need?" Well, yes and no.</p>
			<p>Before getting into the different possible use cases, let's see how this feature works.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/>Variable scopes in JavaScript</h2>
			<p>One thing <a id="_idIndexMarker305"/>that makes JavaScript so flexible is that functions are<a id="_idIndexMarker306"/> first-class citizens. You can declare functions, assign them to variables, and pass them as an argument. You could even return functions from other functions, like in this example:</p>
			<pre>function getFunc() {
    let word = 'world'; 
    return function() {
        console.log('Hello ' + word);
    }
}
getFunc()();</pre>
			<p>That code is pretty fun. <code>getFunc</code> returns another function. When we do <code>getFunc()()</code>, we are calling the function returned by <code>getFunc</code>.</p>
			<p>This piece of code will print <code>'Hello world'</code> in the console. The interesting part is that the function returned by <code>getFunc</code> is able to keep the variable <code>word</code> in its scope. </p>
			<p>You could even do<a id="_idIndexMarker307"/> more complex things, for instance, passing an argument to <code>getFunc</code>, and then using <a id="_idIndexMarker308"/>that argument inside the function that <code>getFunc</code> will return:</p>
			<pre>function getFunc(name) {
    return function() {
        console.log('Hello ' + name);
    }
}
getFunc('world')();
getFunc('mars')();</pre>
			<p>That piece of code will print '<code>Hello world</code>' and '<code>Hello mars</code>'. This is called a <code>getFunc</code>, the returned function will be bundled together with the string <code>'world'</code> in the first case, or <code>'mars'</code> in the second case.</p>
			<p>We won't get into the internals of this feature. But you need to know that <strong class="bold">this is not how functions work in Puppeteer</strong>.</p>
			<p>Let's try to use closures in Puppeteer:</p>
			<pre>const browser = await puppeteer.launch({headless: false, defaultViewport: null});
const page = await browser.newPage();
const name = 'world';
await page.evaluate(() =&gt; alert('Hello ' + name));
browser.close();</pre>
			<p>In this case, we have a function that we are passing to the <code>evaluate</code> function, and that function is using the variable <code>name</code>, which is in the scope of the function we just created. But this is what we get:</p>
			<div><div><img src="img/Figure_6.01_B16113.jpg" alt="Variable scopes in Puppeteer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Variable scopes in Puppeteer</p>
			<p>As you can see, the<a id="_idIndexMarker310"/> name didn't get to the alert. For us as developers, the big<a id="_idIndexMarker311"/> issue is that the code looks good. If you look at the code, the code is perfect. It's not very different from our previous examples. But something works differently there. Once you understand this, you will be able to answer lots of questions on Stack Overflow.</p>
			<p>First, the signature of <code>page.evaluate</code> is <code>page.evaluate(pageFunction[, ...args])</code>, where <code>pageFunction</code> can be a string or a function. The second argument is an optional list of values to pass to <code>pageFunction</code>.</p>
			<p>You can pass <code>evaluate</code> function. An expression is a statement like the ones you can write <a id="_idIndexMarker312"/>inside the DevTools console. For instance, a simple string returning the <code>URL</code> property of the <code>document</code> object:</p>
			<pre>console.log(await page.evaluate('document.URL'));</pre>
			<p><code>page.evaluate</code> will send the expression <code>document.URL</code> to the browser and the browser will evaluate it. Once the browser evaluates the expression, it will send that back to Puppeteer, and <code>page.evaluate</code> will return the result. In this case, <code>about:blank</code>.</p>
			<p>Expressions are perfect when you want to evaluate simple expressions. But you could accomplish the same result using a JavaScript function:</p>
			<pre>console.log(await page.evaluate(() =&gt; document.URL));</pre>
			<p>As you can see, passing an expression is more straightforward, but you will be able to write more complex code using functions, and, no less important, you will get the autocomplete features of your code editor.</p>
			<p>The key concept here is that <code>page.evaluate</code> <code>toString()</code> to function inside a variable. Let's try that out:</p>
			<pre>console.log((() =&gt; alert('Hello ' + name)).toString());</pre>
			<p>This will print the function as a string value in the console:</p>
			<pre>() =&gt; alert('Hello ' + name)</pre>
			<p>If Puppeteer takes that function, converts it to a string using <code>toString</code>, and sends it to the browser, the value of the <code>name</code> variable will be lost in the process.</p>
			<p>When you send a function to be evaluated inside the browser context, you need to make sure that all the values the function uses are already in the browser or are being passed as an argument. This is how we can fix our code:</p>
			<pre>const browser = await puppeteer.launch({headless: false, defaultViewport: null});
const page = await browser.newPage();
const name = 'world';
await page.evaluate((n) =&gt; alert('Hello ' + n), name);
browser.close();</pre>
			<p>As we can see, we are passing the <code>name</code> variable as part of the <code>args</code> argument of <code>evaluate</code>. Now Puppeteer knows that it has to serialize that function and also send <code>args</code>. The browser will now be able to execute that function, passing those arguments.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Notice that I renamed the variable name to <code>n</code>. It's not required, but this practice will help you avoid these kinds of scope mistakes. Now you, and your IDE, know that the <code>n</code> variable being used in the <code>alert</code> function is an argument being passed to that function.</p>
			<p>This <code>evaluate</code> function is available not only in the <code>page</code> and <code>frame</code> classes but also in the <code>JSHandle</code> and <code>ElementHandle</code> classes. Let's explore how we can execute JavaScript code once we've got an <code>ElementHandle</code> or a <code>JSHandle</code> in Puppeteer.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor110"/>Manipulating handles with JavaScript code</h1>
			<p>We <a id="_idIndexMarker313"/>talked about <code>ElementHandle</code> in <a href="B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, <em class="italic">Interacting with a Page</em>. Let's <a id="_idIndexMarker314"/>recap this concept. <code>ElementHandle</code> is a variable in our code pointing to a <code>DOM</code> element inside the page we are automating. Now it's time to know that an <code>ElementHandle</code> is, in <a id="_idIndexMarker315"/>fact, a <strong class="bold">JSHandle</strong>.</p>
			<p>In the same way that <code>ElementHandle</code> is a variable pointing to an element in the browser, <code>document.URL</code>, and a DOM element, like <code>document.activeElement</code>, is that a DOM element has a visual representation, that's all. So, we can say that an <code>ElementHandle</code> (a DOM element) is also a <code>JSHandle</code> (a JavaScript variable). Inheritance 101.</p>
			<p>We were using functions like <code>$</code> or <code>$x</code> to get <code>ElementHandles</code>. Now we can also use <code>evaluateHandle</code>, which works like <code>evaluate</code>, but as Puppeteer knows that we want a pointer to a variable in the browser, a handle, it will return an object that will represent that variable in the browser.</p>
			<p>Let's go back to our login test. The way we were getting the password input was straightforward:</p>
			<pre>const passwordInput = await this.page.$('#password');</pre>
			<p>But, let's <a id="_idIndexMarker316"/>imagine that the developers want to create <a id="_idIndexMarker317"/>a super-secure login creating elements dynamically. But, they tell us that they are storing the password input in the <code>window.passwordInput</code> variable. We could get that input using an <code>evaluateHandle</code>:</p>
			<pre>const passwordInput = (await page.evaluateHandle(() =&gt; window.passwordInput)).asElement();</pre>
			<p>There, <code>evaluateHandle</code> will return a <code>JSHandle</code>, which we can convert to an <code>ElementHandle</code> using the <code>asElement</code> function. If you have to find an element that you cannot find using a CSS selector or an XPath selector, you now have a third tool: you can use a JavaScript function.</p>
			<p>The <code>evaluateHandle</code> function is not limited to DOM elements or simple variables. You can also return, and even create, objects for later access. You will find this code in the <code>Chapter6/demos.js</code> file:</p>
			<pre>const counter = await page.evaluateHandle(() =&gt; {
    window.counter = { count: 2}; 
    return window.counter;
});
await counter.evaluate((c, inc) =&gt; c.count += inc, 3);
await page.evaluate(() =&gt; alert(window.counter.count));</pre>
			<p>If you run this, you will see this result:</p>
			<div><div><img src="img/Figure_6.02_B16113.jpg" alt="Evaluate result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Evaluate result</p>
			<p>In the<a id="_idIndexMarker318"/> first <code>evaluateHandle</code>, we create an object <a id="_idIndexMarker319"/>with a property <code>count</code>, assign it to a property <code>counter</code> in the <code>window</code> object, and then return that object.</p>
			<p>By using the <code>window</code> object, we make it clear that we are using a global variable. If we declare a variable inside that function, we will lose it after executing the function. Although it is not considered a good practice, we could declare <code>counter</code> as a global variable by changing <code>window.counter</code> with just <code>counter</code>:</p>
			<pre>const counter = await page.evaluateHandle(() =&gt; {
    counter = { count: 2}; 
    return counter;
});</pre>
			<p>In the second step, we are learning how to use the <code>evaluate</code> function, but in the context of a <code>JSHandle</code>. The function works in the same way as the <code>evaluate</code> function in the <code>page</code> class. But here, it will pass the <code>JSHandle</code> as the first argument:</p>
			<pre>await counter.evaluate((c, inc) =&gt; c.count += inc, 3);</pre>
			<p>As you can see there, the function expects two arguments: <code>c</code> and <code>inc</code>. But we are only passing <code>3</code>, which is the second argument, <code>inc</code>, because the first argument, <code>c</code>, is our <code>JSHandle</code>.</p>
			<p>We could also <a id="_idIndexMarker320"/>have a function with no extra arguments. For instance, we<a id="_idIndexMarker321"/> could hardcode that <code>3</code> inside the function:</p>
			<pre>await counter.evaluate(c =&gt; c.count += 3);</pre>
			<p>You can also pass <code>JSHandle</code> objects as arguments to the <code>evaluate</code> function of the <code>page</code> class. So, this would be the equivalent of the previous example:</p>
			<pre>await page.evaluate(c =&gt; c.count += 3, counter);</pre>
			<p>This opens the door to many new things we can do with Puppeteer. Let's see some examples.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor111"/>Getting information from the elements</h2>
			<p>Checking how the page<a id="_idIndexMarker322"/> reacts to an action is quite essential. For instance, if you add an item to the cart, you would like to check whether the number of items count was increased.</p>
			<p>If we take a look at our <code>HomePageModel</code> class, this is how we solved the <code>getStock</code> function, which helped us check the stock prices:</p>
			<pre>async getStock(productName) {
    const productDiv = (await this.page.$x(`//a[text()="${productName}"]/../..`))[0];
    const stockElement = (await productDiv.$x('./h6'))[0];
    return await stockElement.evaluate(e =&gt; e.innerText);
}</pre>
			<p>We used that code to learn the XPath expression. In the first two lines, we were getting the product <code>div</code>, and from there, the <code>stock</code> element. After that, we used the <code>evaluate</code> function to get the text of that element.</p>
			<p>I believe these kinds of functionalities should be part of the Puppeteer API. But in the meantime, you can start building your utility functions. We can start with a generic function to return the <code>innerText</code> value:</p>
			<pre>async getInnerText(el) { 
    return await el.evaluate(el =&gt; el.innerText);
}</pre>
			<p>This function will expect an <a id="_idIndexMarker323"/>element as an argument and return the <code>innerText</code> property. The <code>innerText</code> property returns the text content of a <code>DOM</code> element, including all its descendants. But you could also create new utility functions for other common properties:</p>
			<ul>
				<li><code>innerHtml</code> returns the HTML content inside an element. </li>
				<li><code>outerHTML</code> returns the HTML content, including the HTML of the element itself.</li>
				<li>If you want to get the <code>value</code> of an input element, you will need to use <code>value</code><code>innerText</code>.</li>
			</ul>
			<p>You can check the MDN site for a complete list of element properties (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/element">https://www.hardkoded.com/ui-testing-with-puppeteer/element</a>). You will also find that some elements have specific properties. For instance, an input box has properties such as <code>disabled</code> or <code>checked</code> when the type is a checkbox.</p>
			<p>If you don't want to mess with <code>ElementHandles</code>, you can also use <code>page.$eval</code>. The signature of this function is <code>page.$eval(selector, pageFunction[, ...args])</code>. The page will get the <code>ElementHandle</code> using the selector, and then execute <code>evaluate</code>, passing the <code>pageFunction</code> and the <code>args</code>.</p>
			<p>With this in mind, we can replace this line we can find in the <code>logState</code> function inside the <code>LoginPageModel.js</code> file:</p>
			<pre>return await this.page.evaluate(() =&gt; document.querySelector('#navbarTop .nav-link').innerText);</pre>
			<p>With this simpler line of code:</p>
			<pre>return await this.page.$eval('#navbarTop .nav-link', el =&gt; el.innerText);</pre>
			<p>This line of code is <a id="_idIndexMarker324"/>easier to read because you have the selector on one side and the function to execute on the other side. Notice that the <code>pageFunction</code> must always have the element as the first argument.</p>
			<p>But using the <code>evaluate</code> function is not only about getting information. We can change the page behavior, acting on elements.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/>Acting on elements</h2>
			<p>You can<a id="_idIndexMarker325"/> use the <code>evaluate</code> function to get values from elements and act on those elements so that you can <strong class="bold">force</strong> specific scenarios.</p>
			<p>This might sound hacky, but sometimes all the steps required to get to a particular scenario aren't worth the effort. It's like those cooking TV shows, where they are baking a cake, and suddenly, they come up with an already baked cake, and they show you how to add the cream.</p>
			<p>These kinds of shortcuts not only save you time, but reduce potential flakiness that could come up during a long process, where you need to wait for many things to happen before you can act.</p>
			<p>The first action we will learn about is forcing a <code>click</code> action. Wait, don't we have a <code>click</code> function in Puppeteer? We do have a <code>click</code> function. The good thing about the <code>click</code> function is that it emulates a user click. But to be a real emulation, the element being clicked needs to be visible and actionable (clickable). Sometimes we don't want to run the risk of getting a fail because the element was hidden. We can take a shortcut and force a click using the <code>click</code> function:</p>
			<pre>await el.evaluate(el =&gt; el.click());</pre>
			<p>Here, instead of calling <code>el.click()</code>, we call the <code>click</code> function inside the browser.</p>
			<p>In the same way as with properties, this method is not only for the <code>click</code> function. You can use it to force the <code>blur</code> event or select a text in an input with the <code>setSelectionRange</code> function.</p>
			<p>You can act on elements not only through functions. You can also set properties. For instance, you could disable the email input on the login page programmatically. Let's see that in action: </p>
			<pre>const emailInput = await page.$('#email');
await emailInput.evaluate(e =&gt; e.disabled = true);</pre>
			<p>Here, we get the <a id="_idIndexMarker326"/>element, and then we set the disabled property. With this recipe, you could also set the <code>innerText</code> of an element. For instance, you could change a product description with a very long text to see how the page reacts to long product titles.</p>
			<p>Sometimes, being "hacky" is what we want to test. Is our site ready for clever users?</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/>Enforcing server rules</h2>
			<p>With the rise of rich web applications, a new type of bad practice emerged: <strong class="bold">writing business rules only on the client side</strong>.</p>
			<p>We need important business rules <a id="_idIndexMarker327"/>on the server first, and then on the client. Let's say that in our cart application, we need to validate that the user has been authorized to make purchases. We wrote that business rule, but the only thing we did was add an "<code>is-disabled</code>" CSS class in the checkout button. If I'm a clever user, I could open the developer tools, remove that class, and then click on the button. If we don't have the same rule on the server, the user might have easily bypassed our business rule.</p>
			<p>We can write our own "should validate on the server" test. Let's grab the checkbox, remove the CSS class, and try to click on it:</p>
			<pre>const checkoutBtn = (await page.$x('//button[contains(text(),"Checkout")]'))[0];
checkoutBtn.evaluate(el =&gt; el.classList.remove('is-disabled'));
await checkoutBtn.click();</pre>
			<p>Here, we are getting the checkout button, and then we remove the <code>is-disabled</code> CSS class programmatically. That would enable the button, so then we can click it. After that, we should do some validation to check that the business rule was enforced on the server side.</p>
			<p>The <code>evaluate</code> function <a id="_idIndexMarker328"/>can also help us when we can't find elements using CSS selectors or XPath expressions.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/>Finding elements using JavaScript</h2>
			<p>We can find <code>DOM</code> elements using<a id="_idIndexMarker329"/> CSS selectors in over 90% of cases, even <a id="_idIndexMarker330"/>more if we use attribute selectors. XPath expressions help us cover another 9% of the cases. But there is that 1% where we need something more elaborated. For instance, there are properties that are not exposed in a way for a CSS selector to work. Let's take the case of input text.</p>
			<div><div><img src="img/Figure_6.03_B16113.jpg" alt="An input box in Amazon&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">An input box in Amazon</p>
			<p>If the input box is rendered with the word puppeteer (by rendered, I mean that it has the value in the HTML content),<a id="_idTextAnchor115"/><a id="_idTextAnchor116"/><a id="_idTextAnchor117"/> the attribute selector <code>[value=puppeteer]</code> will work. But if the value changes to, for example, <em class="italic">node</em>, the <code>[value=node]</code> selector won't work, and the first selector, <code>[value=puppeteer]</code>, would still return a <code>DOM</code> element. </p>
			<p>Some <a id="_idIndexMarker331"/>properties are not exposed as HTML attributes, so<a id="_idIndexMarker332"/> we won't be able to use them on CSS selectors or XPath expressions. For instance, the <code>IMG</code> element has a property called <code>naturalWidth</code>. This property will return the original size of the image. With this property, we could write a test to check that all the images on our home page are being loaded. If the <code>naturalWidth</code> of an image is 0, it means that the image was not loaded. You can find this code in the test called <code>'Should load all images'</code> inside the <code>Chapter6/test/homepage.tests.js</code> file:</p>
			<pre>const images = await page.evaluateHandle(() =&gt; 
  Array.from(document.querySelectorAll('IMG')).filter(e =&gt; !e.naturalWidth));
(await images.evaluate(e =&gt; e.length)).should.equal(0);</pre>
			<p>In this test, we are getting all the IMG elements with <code>document.querySelectorAll('IMG')</code>. Then we need to wrap it inside an <code>Array.from</code>, so we can filter those elements. And then, we call the <code>filter</code> function, asking for elements with a <code>naturalWidth</code> value: <code>!e.naturalWidth</code>.</p>
			<p>Here is something important for you to notice. The function we are executing using <code>evaluateHandle</code> returns a list of elements. But <code>evaluateHandle</code> will return one element handle. It will return a pointer to that array in the browser. So, if we need to get the <code>length</code> of that array, we need to call <code>evaluate</code> and request the <code>length</code> property.</p>
			<p>Situations like these are when you need to find a balance. Sometimes it's simpler to have a big <code>evaluate</code> function but evaluate everything in one trip. In this case, this could have been solved in only one async call:</p>
			<pre>(await page.evaluateHandle(() =&gt; 
  Array.from(document.querySelectorAll('IMG')).filter(
    e =&gt; !e.naturalWidth).length)).should.equal(0);</pre>
			<p>Now we are doing everything in one hit. We query the images, we filter them, and check for the length.</p>
			<p>We've learned how to execute JavaScript code and how to manipulate elements, but there is more. We can also use JavaScript code as wait functions.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor118"/>Waiting for functions</h1>
			<p>We learned about many wait functions<a id="_idIndexMarker333"/> in <a href="B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087"><em class="italic">Chapter 5</em></a>, <em class="italic">Waiting for elements and network calls</em>. We learned to wait for network events, for <code>DOM</code> elements to be visible or hidden. We also covered many page events we can wait for. But in the same way that a CSS selector<a id="_idIndexMarker334"/> won't cover 100% of cases, and an XPath expression cannot cover all other scenarios, the same happens with wait functions.</p>
			<p>There are some scenarios where we need something more. Now we have the <code>waitForFunction</code>.</p>
			<p>This is the signature of the <code>waitForFunction</code> function: <code>page.waitForFunction(pageFunction, options, ...args)</code>.</p>
			<p>The first argument is the <code>pageFunction</code>. It works in the same way as in the <code>evaluate</code> function. It can be a JavaScript function; it could also be a string; it can expect arguments, and so on.</p>
			<p>The third argument, <code>args</code>, is the arguments that can be sent to the function. This is an optional list of values.</p>
			<p>I didn't forget about the second argument. The second argument is the <code>options</code> argument. The <code>options</code> object has two settings:</p>
			<ul>
				<li>The first property is, you guessed it, <code>timeout</code>. It has the same defaults as we saw in the different wait functions in <a href="B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087"><em class="italic">Chapter 5</em></a>, <em class="italic">Waiting for elements and network calls</em>: defaults to 30 seconds, and then you change or overwrite the value with <code>page.setDefaultTimeout(timeout)</code>.</li>
				<li>The second property is the interesting one: the <code>polling</code> option. This option determines the frequency at which Puppeteer will execute our function. We have three possible options:<p>a) The default option is <code>raf</code>. <code>requestAnimationFrame</code>. According to Mozilla, the <em class="italic">requestAnimationFrame method tells the browser that you wish to perform an animation and requests that the browser calls a specified function to update an animation before the next repaint. The method takes a callback as an argument to be invoked before the repaint</em> (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/raf">https://www.hardkoded.com/ui-testing-with-puppeteer/raf</a>). It is the most frequent polling you can use.</p><p>b) The second option <a id="_idIndexMarker336"/>available is <code>mutation</code>. This option will use a <code>MutationObserver</code>. According to Mozilla, <em class="italic">The MutationObserver interface provides the ability to watch for changes being made to the DOM tree</em> (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver">https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver</a>).</p><p>c) The last option is a <code>number</code>. This number will be an interval in milliseconds at which the function will be executed.</p></li>
			</ul>
			<p>When we talked about finding elements using JavaScript, we mentioned that there are many scenarios where CSS selectors or XPath expressions won't be enough. But I also think that sometimes an <code>evaluateHandle</code> or a <code>waitForFunction</code> call will be easier to read than a complex XPath expression.</p>
			<p>Let's take, for instance, the Packt cart:</p>
			<div><div><img src="img/Figure_6.04_B16113.jpg" alt="Packt cart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Packt cart</p>
			<p>When we add a new book to the cart, the cart number is not updated immediately. If we look at the <strong class="bold">Network</strong> tab, there is a network call to an "<strong class="bold">add</strong>" endpoint, and after that, the cart is updated.</p>
			<p>We can wait for that item number<a id="_idIndexMarker337"/> to be updated in many ways. We could wait for the items list to be updated using a CSS selector. We could also wait for a network response with the URL "<strong class="bold">add</strong>". But we could also do something as simple as wait for the number to change.</p>
			<p>There is one more challenge there. When we add an item to the cart, we need to dismiss it. But the popup is moving. The good news is that <code>waitForFunction</code> <strong class="bold">to wait for animations to finish</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">I thought this would be a simple example, and it turned out to be quite complicated. But I think it's great. You will find these kinds of issues in real life, and you need to resolve them.</p>
			<p>I'm going to explain the test piece by piece. You will be able to see the entire test in the <code>packpub.tests.js</code> file.</p>
			<p>The first thing we need to<a id="_idIndexMarker338"/> solve, and it's something that we, unfortunately, see a lot these days, is the cookies notification. Let's see how we can wait for a notification banner using Puppeteer:</p>
			<pre>await page.goto('https://www.packtpub.com/tech/javascript/');
const cookieLink = await page.waitForSelector('.accept_all', { timeout : 1000}).catch(e =&gt; e);
if (cookieLink) {
    await cookieLink.click();
}</pre>
			<p>The first thing we do is go to the page we want to test. Then we might, or might not, get the cookies banner. The problem is that the cookies banner might take a little while to be shown. So, we wait for the <code>'.accept_all'</code> selector, which is the <code>.catch(e =&gt; e)</code>. If we finally get that cookie button, we click on it.</p>
			<p>Once the cookies banner is dismissed, we need to wait for the page to be ready to act. We don't care which client library the page is using, but it seems that it takes a little bit to be ready to act. One of the things I found is that it will set the class <code>empty</code> to the cart button when the cart is ready. Another thing we know is that the <code>add-to-cart</code> class. We can add a <code>Promise.all</code> and wait for those two conditions:</p>
			<pre>await Promise.a<a id="_idTextAnchor119"/><a id="_idTextAnchor120"/>ll([
    page.waitForSelector('.counter.qty.empty'),
    page.waitForSelector('.add-to-cart')
]);</pre>
			<p>This step was easy. We need to wait for the selectors, <code>.counter.qty.empty</code>, which is the empty cart button, and <code>.add-to-cart,</code> which is the <strong class="bold">Add to cart</strong> button.</p>
			<p>Next up, we need to set up our wait promises:</p>
			<pre>const cartIsOnePromise = page.waitForFunctio<a id="_idTextAnchor121"/><a id="_idTextAnchor122"/>n(() =&gt; document.querySelector('.counter.qty .counter-number').innerText.trim() === '1');
const cartIsTwoPromise = page.waitForFunction(() =&gt; document.querySelector('.counter.qty .counter-number').innerText.trim() === '2');</pre>
			<p>This looks complex, but it's <a id="_idIndexMarker339"/>not that complex. We are setting up two promises. The first promise will resolve when the text (using the <code>innerText</code> property) of the cart counter, which has the selector <code>.counter.qty .counter-number</code>, is equal to 1. We hope it will be resolved at one point in time after we click on the first product. There, I added a <code>trim</code> function, so we remove any extra spaces.</p>
			<p>The second promise is the same as the first one. But it will resolve when the cart number is equal to 2.</p>
			<p>Now that we have our wait promises, it's time to click on the first product:</p>
			<pre>const addToCartButtons = await page.$$('.add-to-cart');
await addToCartButtons[0].click();</pre>
			<p>Here, we are grabbing all the <strong class="bold">Add to cart</strong> buttons and clicking on the first one. </p>
			<p>Now we get to the fun part. We need to wait for the checkout popup to show up and finish its fancy animation: </p>
			<pre>await page.waitForFunction(async () =&gt; {
    const element = document.querySelector('.block-minicart');
    let currentHeight = element.getBoundingClientRect().height;
    let stopMovingCounter = 0;
    await new Promise((resolve) =&gt; {
        const stoppedMoving = function() {
            if (element.getAttribute('style') !== 'display: block;') {
                setTimeout(stoppedMoving, 20);
            }
            if(element.getBoundingClientRect().height &gt; 0 &amp;&amp; currentHeight === element.getBoundingClientRect().height) {
                stopMovingCounter++;
            } else {
                stopMovingCounter = 0;
                currentHeight = element.getBoundingClientRect().height;
            }       
            if(stopMovingCounter === 10) {
              resolve();
            }
            setTimeout(stoppedMoving, 20);
        };
        stoppedMoving();
    });
    return true;
});</pre>
			<p>Pretty scary, right? Let's analyze this<a id="_idIndexMarker340"/> function because it's a handy method.</p>
			<p>Our <code>wait for</code> function needs to be resolved when the checkout popup is visible and has stopped moving. How do we know that it stopped moving? Well, we could check the element height every 20 milliseconds, and if the height is the same after 10 checks, we can assume it stopped moving.</p>
			<p>The first thing we do is get the element, grabbing the initial height using <code>getBoundingClientRect</code>, and set a counter to <code>0</code>.</p>
			<p>Once we have that, we will <code>await</code> a <code>promise</code>, but it will be resolved inside the browser. Inside that <code>promise</code>, we will create a function called <code>stoppedMoving</code>, and we will call it. </p>
			<p>The first thing we will check <a id="_idIndexMarker341"/>inside that function is whether the element is visible. If it's not, we will call the function again after 20 milliseconds.</p>
			<p>Then we check the current height. If the height has changed, we reset the counter, and we start over. If it didn't change for the past 10 times, we resolve the promise by calling <code>resolve()</code>.</p>
			<p>The last thing we do there is to call the same function after 20 milliseconds. Eventually, that function will be resolved, or it will fail due to the <code>waitForFunction</code> timeout.</p>
			<p><strong class="bold">The numbers here are relative. You don't need to wait 20 milliseconds or wait 10 times. You can pick the numbers that will suit you in your example.</strong></p>
			<p>Once we know that the popup is opened and is not moving, we can close it using the following code:</p>
			<pre>await page.click('#btn-minicart-close');</pre>
			<p>As simple as calling <code>click</code>, we are passing the close button selector.</p>
			<p>Now we can wait for the cart number to be updated to 1:</p>
			<pre>await cartIsOnePromise;</pre>
			<p>Here, we are awaiting the promise we built before. The promise might have already been resolved by the time we get here; we don't care. If the promise is resolved, the <code>await</code> will resolve immediately. If not, we will wait.</p>
			<p>Lastly, we click on a second product and await the second promise:</p>
			<pre>await addToCartButtons[1].click();
await cartIsTwoPromise;</pre>
			<p>Here, we grabbed the second product on the list, clicked on it, and waited for the cart number to change to 2. Again, we don't care if that promise was already resolved or not.</p>
			<p>If all promises were resolved, there is nothing to assert. We know that everything worked as expected.</p>
			<p>I bet you will need a break<a id="_idIndexMarker342"/> after this section. Once you are ready, we will see one more thing we can do with functions. We are going to make the browser call functions on the Node side.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor123"/>Exposing local functions</h1>
			<p>With Puppeteer, you can not only <a id="_idIndexMarker343"/>execute code inside the browser but also make calls from the browser back to your Node app. The <code>exposeFunction</code> function allows us to register Node functions inside the browser.</p>
			<p>This is the <code>exposeFunction</code> signature: <code>page.exposeFunction(name, puppeteerFunction)</code>:</p>
			<ul>
				<li>The first argument is <code>name</code>. This will be the function name inside the browser.</li>
				<li><code>puppeteerFunction</code> is a function that follows the same style and functionality as all the functions we have learned about in this chapter.</li>
			</ul>
			<p>This feature is perfect when it is called from a <code>MutationObserver</code>.</p>
			<p>For instance, instead of executing a function over and over, waiting for the checkout counter to change, we could create a <code>MutationObserver</code> to let us know when the value has changed in the HTML Node. Let's see how the code would look:</p>
			<pre>let observer = new MutationObserver(list =&gt; console.log(list[0].target.nodeValue));
observer.observe(
  document.querySelector('.counter.qty .counter-number'), 
  {
    characterData: true, 
    attributes: false, 
    childList: false, 
    subtree: true
  });</pre>
			<p>In this piece of code, we are declaring an observer, which expects a <code>callback</code> function. The first argument of that <code>callback</code> function will be a list of mutations. That mutation has the <code>target</code> object, and we can get the <code>nodeValue</code> from there. You can go to the Mozilla documentation (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord">https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord</a>) if you want to know the full list of properties of the mutation records.</p>
			<p>That observer won't do much. We <a id="_idIndexMarker344"/>need to tell it to observe changes in a particular element, in our case, an element with the selector <code>.counter.qty .counter-number</code>. So, we call <code>observe</code>, passing the <code>counter</code> element, and, as a second argument, we will tell the <code>observe</code> function what changes we want to listen to. In this case, we only care about <code>characterData</code> changes, and we also want to listen to changes in the <code>subtree</code> (child elements). That means text changes.</p>
			<p>So now, we could make a copy of our previous test and replace <code>cartIsOnePromise</code> and <code>cartIsTwoPromise</code> with something like this:</p>
			<pre>const reachedToTwo = new Promise((r<a id="_idTextAnchor124"/><a id="_idTextAnchor125"/>esolve) =&gt; {
    page.exposeFunction('notif<a id="_idTextAnchor126"/><a id="_idTextAnchor127"/>yCartChange', i =&gt; {
        if(i ==='2') 
            resolve();
    })
});
await page.evaluate(() =&gt; {
    let observer = new MutationObserver(list =&gt; notifiyCartChange(list[0].target.nodeValue));
    observer.observe(
        document.querySelector('.counter.qty .counter-number'), 
        {
            characterData: true, 
            attributes: false, 
            childList: false, 
            subtree: true
        });
});</pre>
			<p>We create a promise, <code>reachedToTwo</code>. Inside the promise constructor, we will expose a function named <code>'notifyCartChange'</code>. The function we will expose there will expect one argument, and we will resolve the promise if the argument is equal to <code>'2'</code>.</p>
			<p>That <code>exposeFunction</code> function will allow us to call a <code>notifiyCartChange</code> inside the <code>MutationObserver</code> we declared using an <code>evaluate</code> call.</p>
			<p>For the last step, we replace our old awaits with the new promise:</p>
			<pre>await reachedToTwo;</pre>
			<p>If everything goes as expected, <code>notifyCartChange</code> will be called twice, once with the value <code>'1'</code> and then with<a id="_idIndexMarker345"/> the value <code>'2'</code>, and the second call will resolve the <code>reachedToTwo</code> promise we added at the end of the test.</p>
			<p>This might sound like silly, overcomplicated code, but picture all you could do with <code>exposeFunction</code> and <code>MutationObserver</code>. You could test chat apps by listening to incoming changes and many other complex scenarios.</p>
			<p>Before wrapping up this chapter, it is time to add another tool to our toolbox.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor128"/>Running our checks with Checkly</h1>
			<p>This is an extra tool that I want to show you, and you shouldn't miss the chance of trying it out. <em class="italic">Checkly</em> (<a href="https://www.checklyhq.com/">https://www.checklyhq.com/</a>) is a platform that will help you monitor your website. The <a id="_idIndexMarker346"/>following screenshot shows the <em class="italic">Checkly</em> website:</p>
			<div><div><img src="img/Figure_6.06_B16113.jpg" alt="Checkly website&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Checkly website</p>
			<p>Once you create an account in <em class="italic">Checkly</em>, you will be able to upload your tests (or checks), and <em class="italic">Checkly</em> will run those checks every certain number of minutes, reporting back. Firstly, it will report whether the check is passing, and secondly, it will report the time it took to run.</p>
			<p>You will also be able to<a id="_idIndexMarker347"/> test your website's API without running a browser. This is huge. It's like having your own, personal quality guard.</p>
			<p>Let's go to <a href="https://www.checklyhq.com/">https://www.checklyhq.com/</a> and start our trial. Follow these steps to start using <em class="italic">Checkly</em>:</p>
			<ol>
				<li>Once you enter your email, phone number, and account name, you will get the first dashboard with a few examples, as shown here:<div><img src="img/Figure_6.07_B16113.jpg" alt="Checkly dashboard&#13;&#10;"/></div><p class="figure-caption">Checkly dashboard</p></li>
				<li>You can now<a id="_idIndexMarker348"/> delete those two examples and create your own cart test. We can create a browser test:<div><img src="img/Figure_6.08_B16113.jpg" alt="New test dialog&#13;&#10;"/></div><p class="figure-caption">New test dialog</p></li>
				<li>Now, name your check <code>Cart number check</code>. You can copy the code from the <code>Chapter6/checkly.js</code> file:</li>
			</ol>
			<div><div><img src="img/Figure_6.09_B16113.jpg" alt="First check&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">First check</p>
			<p>Notice that we<a id="_idIndexMarker349"/> have left the browser and the page creation there. Once we have copied the code, we can click on the <strong class="bold">Run Script</strong> button to check that the code is correct. Finally, we will need to pick our data center locations, hit <strong class="bold">Save Check</strong>, and we will have a platform checking our website's health automatically.</p>
			<p>If your team can afford it, <em class="italic">Checkly</em> will take you to the next level. Now it's time to wrap up. </p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor129"/>Summary</h1>
			<p>We covered one of the most powerful features of Puppeteer in this chapter. Most web automation tools let you run JavaScript code somehow, but Puppeteer makes it super easy to implement.</p>
			<p>We started this chapter by talking about some basic JavaScript concepts. We learned about variable scopes and closures. That helped us understand how variables and closures work (or don't work) in Puppeteer. If you learned those differences, you will be able to answer 20% of the Puppeteer questions on Stack Overflow.</p>
			<p>Then, we learned about <code>JSHandles</code> and <code>ElementHandles</code>. You don't see these classes being used a lot by the community, but they are very helpful if you know how to use them, and now you know.</p>
			<p>The <code>waitForFunction</code> completed our "wait" toolbox. You will use that wait function a lot. We also learned how to expose functions and listen to HTML changes using <code>MutationObserver</code>. Exposing functions and listening to HTML changes is not used much in UI testing, but it is an excellent tool for web scraping, a great topic we will cover in <a href="B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 9</em></a>, <em class="italic">Scraping tools</em>.</p>
			<p>With this chapter, we have completed the basics of Puppeteer. You now have most of the tools you need to start doing end-to-end testing.</p>
			<p>I hope you are as excited with <em class="italic">Checkly</em> as I was when I saw this platform for the very first time. <em class="italic">Checkly</em> is a dashboard that will help not only the QA team but also the development team. It will help your team find issues and even find new opportunities to improve your site's performance.</p>
			<p>In the next chapter, we will see some features you wouldn't expect from an automation tool. We are going to see how to generate content using Puppeteer.</p>
		</div>
	</body></html>