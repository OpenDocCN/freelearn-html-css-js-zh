<html><head></head><body>
		<div id="_idContainer088">
			<h1 id="_idParaDest-105"><em class="italic"><a id="_idTextAnchor104"/>Chapter 6</em>: Executing and Injecting JavaScript</h1>
			<p>In the past few chapters, we learned about most of the basic Puppeteer features, from creating a browser and a page correctly, to finding elements and interacting with them.</p>
			<p>Now it's time to get into more powerful tools. In this chapter, we will see how Puppeteer gives us the ability to execute JavaScript code in the browser.</p>
			<p>It might sound like a hack or a last resort tool. Sometimes it is. But it is also a tool that will help us perform actions that are not provided by the Puppeteer API.</p>
			<p>The communication between the code being executed on the Node side and the code being executed in the browser can sometimes be tricky. We will learn how to communicate with both sides efficiently.</p>
			<p>As we did in the previous chapter, we will add another tool to our toolbox. We are going to run our code on <em class="italic">Checkly</em>. </p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Executing JavaScript code</li>
				<li>Manipulating handles with JavaScript code</li>
				<li>Waiting for functions</li>
				<li>Exposing local functions</li>
				<li><a id="_idTextAnchor105"/><a id="_idTextAnchor106"/>Running our checks with Checkly</li>
			</ul>
			<p>By the end of this chapter, you will be able to get more out of the page you are automating by executing JavaScript code.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Technical requirements</h1>
			<p>You will find all the code of this chapter in the GitHub repository (<a href="https://github.com/PacktPublishing/UI-Testing-with-Puppeteer">https://github.com/PacktPublishing/UI-Testing-with-Puppeteer</a>) under the <strong class="source-inline">Chapter6</strong> directory. Remember to run <strong class="source-inline">npm install</strong> on that directory and then go to the <strong class="source-inline">Chapter6/vuejs-firebase-shopping-cart</strong> directory and run <strong class="source-inline">npm install</strong> again.</p>
			<p>If you want to implement the code while following this chapter, you can start from the code you left in the <strong class="source-inline">Chapter5</strong> directory.</p>
			<p>Let's get started.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>Executing JavaScript code</h1>
			<p>The<a id="_idIndexMarker304"/> first question you might ask is: "Why would I need to run JavaScript code? Shouldn't Puppeteer give me all the APIs I need?" Well, yes and no.</p>
			<p>Before getting into the different possible use cases, let's see how this feature works.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/>Variable scopes in JavaScript</h2>
			<p>One thing <a id="_idIndexMarker305"/>that makes JavaScript so flexible is that functions are<a id="_idIndexMarker306"/> first-class citizens. You can declare functions, assign them to variables, and pass them as an argument. You could even return functions from other functions, like in this example:</p>
			<p class="source-code">function getFunc() {</p>
			<p class="source-code">    let word = 'world'; </p>
			<p class="source-code">    return function() {</p>
			<p class="source-code">        console.log('Hello ' + word);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">getFunc()();</p>
			<p>That code is pretty fun. <strong class="source-inline">getFunc</strong> returns another function. When we do <strong class="source-inline">getFunc()()</strong>, we are calling the function returned by <strong class="source-inline">getFunc</strong>.</p>
			<p>This piece of code will print <strong class="source-inline">'Hello world'</strong> in the console. The interesting part is that the function returned by <strong class="source-inline">getFunc</strong> is able to keep the variable <strong class="source-inline">word</strong> in its scope. </p>
			<p>You could even do<a id="_idIndexMarker307"/> more complex things, for instance, passing an argument to <strong class="source-inline">getFunc</strong>, and then using <a id="_idIndexMarker308"/>that argument inside the function that <strong class="source-inline">getFunc</strong> will return:</p>
			<p class="source-code">function getFunc(name) {</p>
			<p class="source-code">    return function() {</p>
			<p class="source-code">        console.log('Hello ' + name);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">getFunc('world')();</p>
			<p class="source-code">getFunc('mars')();</p>
			<p>That piece of code will print '<strong class="source-inline">Hello world</strong>' and '<strong class="source-inline">Hello mars</strong>'. This is called a <strong class="bold">closure</strong>. According to <a id="_idIndexMarker309"/>MDN (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/closures">https://www.hardkoded.com/ui-testing-with-puppeteer/closures</a>), <em class="italic">A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function</em>. When we call <strong class="source-inline">getFunc</strong>, the returned function will be bundled together with the string <strong class="source-inline">'world'</strong> in the first case, or <strong class="source-inline">'mars'</strong> in the second case.</p>
			<p>We won't get into the internals of this feature. But you need to know that <strong class="bold">this is not how functions work in Puppeteer</strong>.</p>
			<p>Let's try to use closures in Puppeteer:</p>
			<p class="source-code">const browser = await puppeteer.launch({headless: false, defaultViewport: null});</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">const name = 'world';</p>
			<p class="source-code">await page.evaluate(() =&gt; alert('Hello ' + name));</p>
			<p class="source-code">browser.close();</p>
			<p>In this case, we have a function that we are passing to the <strong class="source-inline">evaluate</strong> function, and that function is using the variable <strong class="source-inline">name</strong>, which is in the scope of the function we just created. But this is what we get:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_6.01_B16113.jpg" alt="Variable scopes in Puppeteer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Variable scopes in Puppeteer</p>
			<p>As you can see, the<a id="_idIndexMarker310"/> name didn't get to the alert. For us as developers, the big<a id="_idIndexMarker311"/> issue is that the code looks good. If you look at the code, the code is perfect. It's not very different from our previous examples. But something works differently there. Once you understand this, you will be able to answer lots of questions on Stack Overflow.</p>
			<p>First, the signature of <strong class="source-inline">page.evaluate</strong> is <strong class="source-inline">page.evaluate(pageFunction[, ...args])</strong>, where <strong class="source-inline">pageFunction</strong> can be a string or a function. The second argument is an optional list of values to pass to <strong class="source-inline">pageFunction</strong>.</p>
			<p>You can pass <strong class="bold">expressions</strong> as strings to the <strong class="source-inline">evaluate</strong> function. An expression is a statement like the ones you can write <a id="_idIndexMarker312"/>inside the DevTools console. For instance, a simple string returning the <strong class="source-inline">URL</strong> property of the <strong class="source-inline">document</strong> object:</p>
			<p class="source-code">console.log(await page.evaluate('document.URL'));</p>
			<p><strong class="source-inline">page.evaluate</strong> will send the expression <strong class="source-inline">document.URL</strong> to the browser and the browser will evaluate it. Once the browser evaluates the expression, it will send that back to Puppeteer, and <strong class="source-inline">page.evaluate</strong> will return the result. In this case, <strong class="source-inline">about:blank</strong>.</p>
			<p>Expressions are perfect when you want to evaluate simple expressions. But you could accomplish the same result using a JavaScript function:</p>
			<p class="source-code">console.log(await page.evaluate(() =&gt; document.URL));</p>
			<p>As you can see, passing an expression is more straightforward, but you will be able to write more complex code using functions, and, no less important, you will get the autocomplete features of your code editor.</p>
			<p>The key concept here is that <strong class="source-inline">page.evaluate</strong> <strong class="bold">will send the expression to the browser</strong>. How can Puppeteer send a function to the browser? It will serialize it. As I mentioned before, functions are first-class citizens in JavaScript, which means that you can call <strong class="source-inline">toString()</strong> to function inside a variable. Let's try that out:</p>
			<p class="source-code">console.log((() =&gt; alert('Hello ' + name)).toString());</p>
			<p>This will print the function as a string value in the console:</p>
			<p class="source-code">() =&gt; alert('Hello ' + name)</p>
			<p>If Puppeteer takes that function, converts it to a string using <strong class="source-inline">toString</strong>, and sends it to the browser, the value of the <strong class="source-inline">name</strong> variable will be lost in the process.</p>
			<p>When you send a function to be evaluated inside the browser context, you need to make sure that all the values the function uses are already in the browser or are being passed as an argument. This is how we can fix our code:</p>
			<p class="source-code">const browser = await puppeteer.launch({headless: false, defaultViewport: null});</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">const name = 'world';</p>
			<p class="source-code">await page.evaluate((n) =&gt; alert('Hello ' + n), name);</p>
			<p class="source-code">browser.close();</p>
			<p>As we can see, we are passing the <strong class="source-inline">name</strong> variable as part of the <strong class="source-inline">args</strong> argument of <strong class="source-inline">evaluate</strong>. Now Puppeteer knows that it has to serialize that function and also send <strong class="source-inline">args</strong>. The browser will now be able to execute that function, passing those arguments.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Notice that I renamed the variable name to <strong class="source-inline">n</strong>. It's not required, but this practice will help you avoid these kinds of scope mistakes. Now you, and your IDE, know that the <strong class="source-inline">n</strong> variable being used in the <strong class="source-inline">alert</strong> function is an argument being passed to that function.</p>
			<p>This <strong class="source-inline">evaluate</strong> function is available not only in the <strong class="source-inline">page</strong> and <strong class="source-inline">frame</strong> classes but also in the <strong class="source-inline">JSHandle</strong> and <strong class="source-inline">ElementHandle</strong> classes. Let's explore how we can execute JavaScript code once we've got an <strong class="source-inline">ElementHandle</strong> or a <strong class="source-inline">JSHandle</strong> in Puppeteer.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor110"/>Manipulating handles with JavaScript code</h1>
			<p>We <a id="_idIndexMarker313"/>talked about <strong class="source-inline">ElementHandle</strong> in <a href="B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, <em class="italic">Interacting with a Page</em>. Let's <a id="_idIndexMarker314"/>recap this concept. <strong class="source-inline">ElementHandle</strong> is a variable in our code pointing to a <strong class="source-inline">DOM</strong> element inside the page we are automating. Now it's time to know that an <strong class="source-inline">ElementHandle</strong> is, in <a id="_idIndexMarker315"/>fact, a <strong class="bold">JSHandle</strong>.</p>
			<p>In the same way that <strong class="source-inline">ElementHandle</strong> is a variable pointing to an element in the browser, <strong class="bold">a JSHandle is a variable pointing to a variable on the page we are automating</strong>. If we think about that, the only difference between a JavaScript variable like, for instance, <strong class="source-inline">document.URL</strong>, and a DOM element, like <strong class="source-inline">document.activeElement</strong>, is that a DOM element has a visual representation, that's all. So, we can say that an <strong class="source-inline">ElementHandle</strong> (a DOM element) is also a <strong class="source-inline">JSHandle</strong> (a JavaScript variable). Inheritance 101.</p>
			<p>We were using functions like <strong class="source-inline">$</strong> or <strong class="source-inline">$x</strong> to get <strong class="source-inline">ElementHandles</strong>. Now we can also use <strong class="source-inline">evaluateHandle</strong>, which works like <strong class="source-inline">evaluate</strong>, but as Puppeteer knows that we want a pointer to a variable in the browser, a handle, it will return an object that will represent that variable in the browser.</p>
			<p>Let's go back to our login test. The way we were getting the password input was straightforward:</p>
			<p class="source-code">const passwordInput = await this.page.$('#password');</p>
			<p>But, let's <a id="_idIndexMarker316"/>imagine that the developers want to create <a id="_idIndexMarker317"/>a super-secure login creating elements dynamically. But, they tell us that they are storing the password input in the <strong class="source-inline">window.passwordInput</strong> variable. We could get that input using an <strong class="source-inline">evaluateHandle</strong>:</p>
			<p class="source-code">const passwordInput = (await page.evaluateHandle(() =&gt; window.passwordInput)).asElement();</p>
			<p>There, <strong class="source-inline">evaluateHandle</strong> will return a <strong class="source-inline">JSHandle</strong>, which we can convert to an <strong class="source-inline">ElementHandle</strong> using the <strong class="source-inline">asElement</strong> function. If you have to find an element that you cannot find using a CSS selector or an XPath selector, you now have a third tool: you can use a JavaScript function.</p>
			<p>The <strong class="source-inline">evaluateHandle</strong> function is not limited to DOM elements or simple variables. You can also return, and even create, objects for later access. You will find this code in the <strong class="source-inline">Chapter6/demos.js</strong> file:</p>
			<p class="source-code">const counter = await page.evaluateHandle(() =&gt; {</p>
			<p class="source-code">    window.counter = { count: 2}; </p>
			<p class="source-code">    return window.counter;</p>
			<p class="source-code">});</p>
			<p class="source-code">await counter.evaluate((c, inc) =&gt; c.count += inc, 3);</p>
			<p class="source-code">await page.evaluate(() =&gt; alert(window.counter.count));</p>
			<p>If you run this, you will see this result:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_6.02_B16113.jpg" alt="Evaluate result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Evaluate result</p>
			<p>In the<a id="_idIndexMarker318"/> first <strong class="source-inline">evaluateHandle</strong>, we create an object <a id="_idIndexMarker319"/>with a property <strong class="source-inline">count</strong>, assign it to a property <strong class="source-inline">counter</strong> in the <strong class="source-inline">window</strong> object, and then return that object.</p>
			<p>By using the <strong class="source-inline">window</strong> object, we make it clear that we are using a global variable. If we declare a variable inside that function, we will lose it after executing the function. Although it is not considered a good practice, we could declare <strong class="source-inline">counter</strong> as a global variable by changing <strong class="source-inline">window.counter</strong> with just <strong class="source-inline">counter</strong>:</p>
			<p class="source-code">const counter = await page.evaluateHandle(() =&gt; {</p>
			<p class="source-code">    counter = { count: 2}; </p>
			<p class="source-code">    return counter;</p>
			<p class="source-code">});</p>
			<p>In the second step, we are learning how to use the <strong class="source-inline">evaluate</strong> function, but in the context of a <strong class="source-inline">JSHandle</strong>. The function works in the same way as the <strong class="source-inline">evaluate</strong> function in the <strong class="source-inline">page</strong> class. But here, it will pass the <strong class="source-inline">JSHandle</strong> as the first argument:</p>
			<p class="source-code">await counter.evaluate((c, inc) =&gt; c.count += inc, 3);</p>
			<p>As you can see there, the function expects two arguments: <strong class="source-inline">c</strong> and <strong class="source-inline">inc</strong>. But we are only passing <strong class="source-inline">3</strong>, which is the second argument, <strong class="source-inline">inc</strong>, because the first argument, <strong class="source-inline">c</strong>, is our <strong class="source-inline">JSHandle</strong>.</p>
			<p>We could also <a id="_idIndexMarker320"/>have a function with no extra arguments. For instance, we<a id="_idIndexMarker321"/> could hardcode that <strong class="source-inline">3</strong> inside the function:</p>
			<p class="source-code">await counter.evaluate(c =&gt; c.count += 3);</p>
			<p>You can also pass <strong class="source-inline">JSHandle</strong> objects as arguments to the <strong class="source-inline">evaluate</strong> function of the <strong class="source-inline">page</strong> class. So, this would be the equivalent of the previous example:</p>
			<p class="source-code">await page.evaluate(c =&gt; c.count += 3, counter);</p>
			<p>This opens the door to many new things we can do with Puppeteer. Let's see some examples.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor111"/>Getting information from the elements</h2>
			<p>Checking how the page<a id="_idIndexMarker322"/> reacts to an action is quite essential. For instance, if you add an item to the cart, you would like to check whether the number of items count was increased.</p>
			<p>If we take a look at our <strong class="source-inline">HomePageModel</strong> class, this is how we solved the <strong class="source-inline">getStock</strong> function, which helped us check the stock prices:</p>
			<p class="source-code">async getStock(productName) {</p>
			<p class="source-code">    const productDiv = (await this.page.$x(`//a[text()="${productName}"]/../..`))[0];</p>
			<p class="source-code">    const stockElement = (await productDiv.$x('./h6'))[0];</p>
			<p class="source-code">    return await stockElement.evaluate(e =&gt; e.innerText);</p>
			<p class="source-code">}</p>
			<p>We used that code to learn the XPath expression. In the first two lines, we were getting the product <strong class="source-inline">div</strong>, and from there, the <strong class="source-inline">stock</strong> element. After that, we used the <strong class="source-inline">evaluate</strong> function to get the text of that element.</p>
			<p>I believe these kinds of functionalities should be part of the Puppeteer API. But in the meantime, you can start building your utility functions. We can start with a generic function to return the <strong class="source-inline">innerText</strong> value:</p>
			<p class="source-code">async getInnerText(el) { </p>
			<p class="source-code">    return await el.evaluate(el =&gt; el.innerText);</p>
			<p class="source-code">}</p>
			<p>This function will expect an <a id="_idIndexMarker323"/>element as an argument and return the <strong class="source-inline">innerText</strong> property. The <strong class="source-inline">innerText</strong> property returns the text content of a <strong class="source-inline">DOM</strong> element, including all its descendants. But you could also create new utility functions for other common properties:</p>
			<ul>
				<li><strong class="source-inline">innerHtml</strong> returns the HTML content inside an element. </li>
				<li><strong class="source-inline">outerHTML</strong> returns the HTML content, including the HTML of the element itself.</li>
				<li>If you want to get the <strong class="source-inline">value</strong> of an input element, you will need to use <strong class="source-inline">value</strong><strong class="bold"> </strong>instead of <strong class="source-inline">innerText</strong>.</li>
			</ul>
			<p>You can check the MDN site for a complete list of element properties (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/element">https://www.hardkoded.com/ui-testing-with-puppeteer/element</a>). You will also find that some elements have specific properties. For instance, an input box has properties such as <strong class="source-inline">disabled</strong> or <strong class="source-inline">checked</strong> when the type is a checkbox.</p>
			<p>If you don't want to mess with <strong class="source-inline">ElementHandles</strong>, you can also use <strong class="source-inline">page.$eval</strong>. The signature of this function is <strong class="source-inline">page.$eval(selector, pageFunction[, ...args])</strong>. The page will get the <strong class="source-inline">ElementHandle</strong> using the selector, and then execute <strong class="source-inline">evaluate</strong>, passing the <strong class="source-inline">pageFunction</strong> and the <strong class="source-inline">args</strong>.</p>
			<p>With this in mind, we can replace this line we can find in the <strong class="source-inline">logState</strong> function inside the <strong class="source-inline">LoginPageModel.js</strong> file:</p>
			<p class="source-code">return await this.page.evaluate(() =&gt; document.querySelector('#navbarTop .nav-link').innerText);</p>
			<p>With this simpler line of code:</p>
			<p class="source-code">return await this.page.$eval('#navbarTop .nav-link', el =&gt; el.innerText);</p>
			<p>This line of code is <a id="_idIndexMarker324"/>easier to read because you have the selector on one side and the function to execute on the other side. Notice that the <strong class="source-inline">pageFunction</strong> must always have the element as the first argument.</p>
			<p>But using the <strong class="source-inline">evaluate</strong> function is not only about getting information. We can change the page behavior, acting on elements.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/>Acting on elements</h2>
			<p>You can<a id="_idIndexMarker325"/> use the <strong class="source-inline">evaluate</strong> function to get values from elements and act on those elements so that you can <strong class="bold">force</strong> specific scenarios.</p>
			<p>This might sound hacky, but sometimes all the steps required to get to a particular scenario aren't worth the effort. It's like those cooking TV shows, where they are baking a cake, and suddenly, they come up with an already baked cake, and they show you how to add the cream.</p>
			<p>These kinds of shortcuts not only save you time, but reduce potential flakiness that could come up during a long process, where you need to wait for many things to happen before you can act.</p>
			<p>The first action we will learn about is forcing a <strong class="source-inline">click</strong> action. Wait, don't we have a <strong class="source-inline">click</strong> function in Puppeteer? We do have a <strong class="source-inline">click</strong> function. The good thing about the <strong class="source-inline">click</strong> function is that it emulates a user click. But to be a real emulation, the element being clicked needs to be visible and actionable (clickable). Sometimes we don't want to run the risk of getting a fail because the element was hidden. We can take a shortcut and force a click using the <strong class="source-inline">click</strong> function:</p>
			<p class="source-code">await el.evaluate(el =&gt; el.click());</p>
			<p>Here, instead of calling <strong class="source-inline">el.click()</strong>, we call the <strong class="source-inline">click</strong> function inside the browser.</p>
			<p>In the same way as with properties, this method is not only for the <strong class="source-inline">click</strong> function. You can use it to force the <strong class="source-inline">blur</strong> event or select a text in an input with the <strong class="source-inline">setSelectionRange</strong> function.</p>
			<p>You can act on elements not only through functions. You can also set properties. For instance, you could disable the email input on the login page programmatically. Let's see that in action: </p>
			<p class="source-code">const emailInput = await page.$('#email');</p>
			<p class="source-code">await emailInput.evaluate(e =&gt; e.disabled = true);</p>
			<p>Here, we get the <a id="_idIndexMarker326"/>element, and then we set the disabled property. With this recipe, you could also set the <strong class="source-inline">innerText</strong> of an element. For instance, you could change a product description with a very long text to see how the page reacts to long product titles.</p>
			<p>Sometimes, being "hacky" is what we want to test. Is our site ready for clever users?</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/>Enforcing server rules</h2>
			<p>With the rise of rich web applications, a new type of bad practice emerged: <strong class="bold">writing business rules only on the client side</strong>.</p>
			<p>We need important business rules <a id="_idIndexMarker327"/>on the server first, and then on the client. Let's say that in our cart application, we need to validate that the user has been authorized to make purchases. We wrote that business rule, but the only thing we did was add an "<strong class="source-inline">is-disabled</strong>" CSS class in the checkout button. If I'm a clever user, I could open the developer tools, remove that class, and then click on the button. If we don't have the same rule on the server, the user might have easily bypassed our business rule.</p>
			<p>We can write our own "should validate on the server" test. Let's grab the checkbox, remove the CSS class, and try to click on it:</p>
			<p class="source-code">const checkoutBtn = (await page.$x('//button[contains(text(),"Checkout")]'))[0];</p>
			<p class="source-code">checkoutBtn.evaluate(el =&gt; el.classList.remove('is-disabled'));</p>
			<p class="source-code">await checkoutBtn.click();</p>
			<p>Here, we are getting the checkout button, and then we remove the <strong class="source-inline">is-disabled</strong> CSS class programmatically. That would enable the button, so then we can click it. After that, we should do some validation to check that the business rule was enforced on the server side.</p>
			<p>The <strong class="source-inline">evaluate</strong> function <a id="_idIndexMarker328"/>can also help us when we can't find elements using CSS selectors or XPath expressions.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/>Finding elements using JavaScript</h2>
			<p>We can find <strong class="source-inline">DOM</strong> elements using<a id="_idIndexMarker329"/> CSS selectors in over 90% of cases, even <a id="_idIndexMarker330"/>more if we use attribute selectors. XPath expressions help us cover another 9% of the cases. But there is that 1% where we need something more elaborated. For instance, there are properties that are not exposed in a way for a CSS selector to work. Let's take the case of input text.</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_6.03_B16113.jpg" alt="An input box in Amazon&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">An input box in Amazon</p>
			<p>If the input box is rendered with the word puppeteer (by rendered, I mean that it has the value in the HTML content),<a id="_idTextAnchor115"/><a id="_idTextAnchor116"/><a id="_idTextAnchor117"/> the attribute selector <strong class="source-inline">[value=puppeteer]</strong> will work. But if the value changes to, for example, <em class="italic">node</em>, the <strong class="source-inline">[value=node]</strong> selector won't work, and the first selector, <strong class="source-inline">[value=puppeteer]</strong>, would still return a <strong class="source-inline">DOM</strong> element. </p>
			<p>Some <a id="_idIndexMarker331"/>properties are not exposed as HTML attributes, so<a id="_idIndexMarker332"/> we won't be able to use them on CSS selectors or XPath expressions. For instance, the <strong class="source-inline">IMG</strong> element has a property called <strong class="source-inline">naturalWidth</strong>. This property will return the original size of the image. With this property, we could write a test to check that all the images on our home page are being loaded. If the <strong class="source-inline">naturalWidth</strong> of an image is 0, it means that the image was not loaded. You can find this code in the test called <strong class="source-inline">'Should load all images'</strong> inside the <strong class="source-inline">Chapter6/test/homepage.tests.js</strong> file:</p>
			<p class="source-code">const images = await page.evaluateHandle(() =&gt; </p>
			<p class="source-code">  Array.from(document.querySelectorAll('IMG')).filter(e =&gt; !e.naturalWidth));</p>
			<p class="source-code">(await images.evaluate(e =&gt; e.length)).should.equal(0);</p>
			<p>In this test, we are getting all the IMG elements with <strong class="source-inline">document.querySelectorAll('IMG')</strong>. Then we need to wrap it inside an <strong class="source-inline">Array.from</strong>, so we can filter those elements. And then, we call the <strong class="source-inline">filter</strong> function, asking for elements with a <strong class="source-inline">naturalWidth</strong> value: <strong class="source-inline">!e.naturalWidth</strong>.</p>
			<p>Here is something important for you to notice. The function we are executing using <strong class="source-inline">evaluateHandle</strong> returns a list of elements. But <strong class="source-inline">evaluateHandle</strong> will return one element handle. It will return a pointer to that array in the browser. So, if we need to get the <strong class="source-inline">length</strong> of that array, we need to call <strong class="source-inline">evaluate</strong> and request the <strong class="source-inline">length</strong> property.</p>
			<p>Situations like these are when you need to find a balance. Sometimes it's simpler to have a big <strong class="source-inline">evaluate</strong> function but evaluate everything in one trip. In this case, this could have been solved in only one async call:</p>
			<p class="source-code">(await page.evaluateHandle(() =&gt; </p>
			<p class="source-code">  Array.from(document.querySelectorAll('IMG')).filter(</p>
			<p class="source-code">    e =&gt; !e.naturalWidth).length)).should.equal(0);</p>
			<p>Now we are doing everything in one hit. We query the images, we filter them, and check for the length.</p>
			<p>We've learned how to execute JavaScript code and how to manipulate elements, but there is more. We can also use JavaScript code as wait functions.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor118"/>Waiting for functions</h1>
			<p>We learned about many wait functions<a id="_idIndexMarker333"/> in <a href="B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087"><em class="italic">Chapter 5</em></a>, <em class="italic">Waiting for elements and network calls</em>. We learned to wait for network events, for <strong class="source-inline">DOM</strong> elements to be visible or hidden. We also covered many page events we can wait for. But in the same way that a CSS selector<a id="_idIndexMarker334"/> won't cover 100% of cases, and an XPath expression cannot cover all other scenarios, the same happens with wait functions.</p>
			<p>There are some scenarios where we need something more. Now we have the <strong class="source-inline">waitForFunction</strong>.</p>
			<p>This is the signature of the <strong class="source-inline">waitForFunction</strong> function: <strong class="source-inline">page.waitForFunction(pageFunction, options, ...args)</strong>.</p>
			<p>The first argument is the <strong class="source-inline">pageFunction</strong>. It works in the same way as in the <strong class="source-inline">evaluate</strong> function. It can be a JavaScript function; it could also be a string; it can expect arguments, and so on.</p>
			<p>The third argument, <strong class="source-inline">args</strong>, is the arguments that can be sent to the function. This is an optional list of values.</p>
			<p>I didn't forget about the second argument. The second argument is the <strong class="source-inline">options</strong> argument. The <strong class="source-inline">options</strong> object has two settings:</p>
			<ul>
				<li>The first property is, you guessed it, <strong class="source-inline">timeout</strong>. It has the same defaults as we saw in the different wait functions in <a href="B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087"><em class="italic">Chapter 5</em></a>, <em class="italic">Waiting for elements and network calls</em>: defaults to 30 seconds, and then you change or overwrite the value with <strong class="source-inline">page.setDefaultTimeout(timeout)</strong>.</li>
				<li>The second property is the interesting one: the <strong class="source-inline">polling</strong> option. This option determines the frequency at which Puppeteer will execute our function. We have three possible options:<p>a) The default option is <strong class="source-inline">raf</strong>. <strong class="bold">Raf</strong> is short <a id="_idIndexMarker335"/>for <strong class="source-inline">requestAnimationFrame</strong>. According to Mozilla, the <em class="italic">requestAnimationFrame method tells the browser that you wish to perform an animation and requests that the browser calls a specified function to update an animation before the next repaint. The method takes a callback as an argument to be invoked before the repaint</em> (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/raf">https://www.hardkoded.com/ui-testing-with-puppeteer/raf</a>). It is the most frequent polling you can use.</p><p>b) The second option <a id="_idIndexMarker336"/>available is <strong class="source-inline">mutation</strong>. This option will use a <strong class="source-inline">MutationObserver</strong>. According to Mozilla, <em class="italic">The MutationObserver interface provides the ability to watch for changes being made to the DOM tree</em> (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver">https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver</a>).</p><p>c) The last option is a <strong class="source-inline">number</strong>. This number will be an interval in milliseconds at which the function will be executed.</p></li>
			</ul>
			<p>When we talked about finding elements using JavaScript, we mentioned that there are many scenarios where CSS selectors or XPath expressions won't be enough. But I also think that sometimes an <strong class="source-inline">evaluateHandle</strong> or a <strong class="source-inline">waitForFunction</strong> call will be easier to read than a complex XPath expression.</p>
			<p>Let's take, for instance, the Packt cart:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_6.04_B16113.jpg" alt="Packt cart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Packt cart</p>
			<p>When we add a new book to the cart, the cart number is not updated immediately. If we look at the <strong class="bold">Network</strong> tab, there is a network call to an "<strong class="bold">add</strong>" endpoint, and after that, the cart is updated.</p>
			<p>We can wait for that item number<a id="_idIndexMarker337"/> to be updated in many ways. We could wait for the items list to be updated using a CSS selector. We could also wait for a network response with the URL "<strong class="bold">add</strong>". But we could also do something as simple as wait for the number to change.</p>
			<p>There is one more challenge there. When we add an item to the cart, we need to dismiss it. But the popup is moving. The good news is that <strong class="bold">we can use a </strong><strong class="source-inline">waitForFunction</strong> <strong class="bold">to wait for animations to finish</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">I thought this would be a simple example, and it turned out to be quite complicated. But I think it's great. You will find these kinds of issues in real life, and you need to resolve them.</p>
			<p>I'm going to explain the test piece by piece. You will be able to see the entire test in the <strong class="source-inline">packpub.tests.js</strong> file.</p>
			<p>The first thing we need to<a id="_idIndexMarker338"/> solve, and it's something that we, unfortunately, see a lot these days, is the cookies notification. Let's see how we can wait for a notification banner using Puppeteer:</p>
			<p class="source-code">await page.goto('https://www.packtpub.com/tech/javascript/');</p>
			<p class="source-code">const cookieLink = await page.waitForSelector('.accept_all', { timeout : 1000}).catch(e =&gt; e);</p>
			<p class="source-code">if (cookieLink) {</p>
			<p class="source-code">    await cookieLink.click();</p>
			<p class="source-code">}</p>
			<p>The first thing we do is go to the page we want to test. Then we might, or might not, get the cookies banner. The problem is that the cookies banner might take a little while to be shown. So, we wait for the <strong class="source-inline">'.accept_all'</strong> selector, which is the <strong class="bold">Accept cookies</strong> button. We give it a second, 1000 ms. If we don't get that button, that's why we swallow the exception using <strong class="source-inline">.catch(e =&gt; e)</strong>. If we finally get that cookie button, we click on it.</p>
			<p>Once the cookies banner is dismissed, we need to wait for the page to be ready to act. We don't care which client library the page is using, but it seems that it takes a little bit to be ready to act. One of the things I found is that it will set the class <strong class="source-inline">empty</strong> to the cart button when the cart is ready. Another thing we know is that the <strong class="bold">Add to cart</strong> buttons have the <strong class="source-inline">add-to-cart</strong> class. We can add a <strong class="source-inline">Promise.all</strong> and wait for those two conditions:</p>
			<p class="source-code">await Promise.a<a id="_idTextAnchor119"/><a id="_idTextAnchor120"/>ll([</p>
			<p class="source-code">    page.waitForSelector('.counter.qty.empty'),</p>
			<p class="source-code">    page.waitForSelector('.add-to-cart')</p>
			<p class="source-code">]);</p>
			<p>This step was easy. We need to wait for the selectors, <strong class="source-inline">.counter.qty.empty</strong>, which is the empty cart button, and <strong class="source-inline">.add-to-cart,</strong> which is the <strong class="bold">Add to cart</strong> button.</p>
			<p>Next up, we need to set up our wait promises:</p>
			<p class="source-code">const cartIsOnePromise = page.waitForFunctio<a id="_idTextAnchor121"/><a id="_idTextAnchor122"/>n(() =&gt; document.querySelector('.counter.qty .counter-number').innerText.trim() === '1');</p>
			<p class="source-code">const cartIsTwoPromise = page.waitForFunction(() =&gt; document.querySelector('.counter.qty .counter-number').innerText.trim() === '2');</p>
			<p>This looks complex, but it's <a id="_idIndexMarker339"/>not that complex. We are setting up two promises. The first promise will resolve when the text (using the <strong class="source-inline">innerText</strong> property) of the cart counter, which has the selector <strong class="source-inline">.counter.qty .counter-number</strong>, is equal to 1. We hope it will be resolved at one point in time after we click on the first product. There, I added a <strong class="source-inline">trim</strong> function, so we remove any extra spaces.</p>
			<p>The second promise is the same as the first one. But it will resolve when the cart number is equal to 2.</p>
			<p>Now that we have our wait promises, it's time to click on the first product:</p>
			<p class="source-code">const addToCartButtons = await page.$$('.add-to-cart');</p>
			<p class="source-code">await addToCartButtons[0].click();</p>
			<p>Here, we are grabbing all the <strong class="bold">Add to cart</strong> buttons and clicking on the first one. </p>
			<p>Now we get to the fun part. We need to wait for the checkout popup to show up and finish its fancy animation: </p>
			<p class="source-code">await page.waitForFunction(async () =&gt; {</p>
			<p class="source-code">    const element = document.querySelector('.block-minicart');</p>
			<p class="source-code">    let currentHeight = element.getBoundingClientRect().height;</p>
			<p class="source-code">    let stopMovingCounter = 0;</p>
			<p class="source-code">    await new Promise((resolve) =&gt; {</p>
			<p class="source-code">        const stoppedMoving = function() {</p>
			<p class="source-code">            if (element.getAttribute('style') !== 'display: block;') {</p>
			<p class="source-code">                setTimeout(stoppedMoving, 20);</p>
			<p class="source-code">            }</p>
			<p class="source-code">            if(element.getBoundingClientRect().height &gt; 0 &amp;&amp; currentHeight === element.getBoundingClientRect().height) {</p>
			<p class="source-code">                stopMovingCounter++;</p>
			<p class="source-code">            } else {</p>
			<p class="source-code">                stopMovingCounter = 0;</p>
			<p class="source-code">                currentHeight = element.getBoundingClientRect().height;</p>
			<p class="source-code">            }       </p>
			<p class="source-code">            if(stopMovingCounter === 10) {</p>
			<p class="source-code">              resolve();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            setTimeout(stoppedMoving, 20);</p>
			<p class="source-code">        };</p>
			<p class="source-code">        stoppedMoving();</p>
			<p class="source-code">    });</p>
			<p class="source-code">    return true;</p>
			<p class="source-code">});</p>
			<p>Pretty scary, right? Let's analyze this<a id="_idIndexMarker340"/> function because it's a handy method.</p>
			<p>Our <strong class="source-inline">wait for</strong> function needs to be resolved when the checkout popup is visible and has stopped moving. How do we know that it stopped moving? Well, we could check the element height every 20 milliseconds, and if the height is the same after 10 checks, we can assume it stopped moving.</p>
			<p>The first thing we do is get the element, grabbing the initial height using <strong class="source-inline">getBoundingClientRect</strong>, and set a counter to <strong class="source-inline">0</strong>.</p>
			<p>Once we have that, we will <strong class="source-inline">await</strong> a <strong class="source-inline">promise</strong>, but it will be resolved inside the browser. Inside that <strong class="source-inline">promise</strong>, we will create a function called <strong class="source-inline">stoppedMoving</strong>, and we will call it. </p>
			<p>The first thing we will check <a id="_idIndexMarker341"/>inside that function is whether the element is visible. If it's not, we will call the function again after 20 milliseconds.</p>
			<p>Then we check the current height. If the height has changed, we reset the counter, and we start over. If it didn't change for the past 10 times, we resolve the promise by calling <strong class="source-inline">resolve()</strong>.</p>
			<p>The last thing we do there is to call the same function after 20 milliseconds. Eventually, that function will be resolved, or it will fail due to the <strong class="source-inline">waitForFunction</strong> timeout.</p>
			<p><strong class="bold">The numbers here are relative. You don't need to wait 20 milliseconds or wait 10 times. You can pick the numbers that will suit you in your example.</strong></p>
			<p>Once we know that the popup is opened and is not moving, we can close it using the following code:</p>
			<p class="source-code">await page.click('#btn-minicart-close');</p>
			<p>As simple as calling <strong class="source-inline">click</strong>, we are passing the close button selector.</p>
			<p>Now we can wait for the cart number to be updated to 1:</p>
			<p class="source-code">await cartIsOnePromise;</p>
			<p>Here, we are awaiting the promise we built before. The promise might have already been resolved by the time we get here; we don't care. If the promise is resolved, the <strong class="source-inline">await</strong> will resolve immediately. If not, we will wait.</p>
			<p>Lastly, we click on a second product and await the second promise:</p>
			<p class="source-code">await addToCartButtons[1].click();</p>
			<p class="source-code">await cartIsTwoPromise;</p>
			<p>Here, we grabbed the second product on the list, clicked on it, and waited for the cart number to change to 2. Again, we don't care if that promise was already resolved or not.</p>
			<p>If all promises were resolved, there is nothing to assert. We know that everything worked as expected.</p>
			<p>I bet you will need a break<a id="_idIndexMarker342"/> after this section. Once you are ready, we will see one more thing we can do with functions. We are going to make the browser call functions on the Node side.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor123"/>Exposing local functions</h1>
			<p>With Puppeteer, you can not only <a id="_idIndexMarker343"/>execute code inside the browser but also make calls from the browser back to your Node app. The <strong class="source-inline">exposeFunction</strong> function allows us to register Node functions inside the browser.</p>
			<p>This is the <strong class="source-inline">exposeFunction</strong> signature: <strong class="source-inline">page.exposeFunction(name, puppeteerFunction)</strong>:</p>
			<ul>
				<li>The first argument is <strong class="source-inline">name</strong>. This will be the function name inside the browser.</li>
				<li><strong class="source-inline">puppeteerFunction</strong> is a function that follows the same style and functionality as all the functions we have learned about in this chapter.</li>
			</ul>
			<p>This feature is perfect when it is called from a <strong class="source-inline">MutationObserver</strong>.</p>
			<p>For instance, instead of executing a function over and over, waiting for the checkout counter to change, we could create a <strong class="source-inline">MutationObserver</strong> to let us know when the value has changed in the HTML Node. Let's see how the code would look:</p>
			<p class="source-code">let observer = new MutationObserver(list =&gt; console.log(list[0].target.nodeValue));</p>
			<p class="source-code">observer.observe(</p>
			<p class="source-code">  document.querySelector('.counter.qty .counter-number'), </p>
			<p class="source-code">  {</p>
			<p class="source-code">    characterData: true, </p>
			<p class="source-code">    attributes: false, </p>
			<p class="source-code">    childList: false, </p>
			<p class="source-code">    subtree: true</p>
			<p class="source-code">  });</p>
			<p>In this piece of code, we are declaring an observer, which expects a <strong class="source-inline">callback</strong> function. The first argument of that <strong class="source-inline">callback</strong> function will be a list of mutations. That mutation has the <strong class="source-inline">target</strong> object, and we can get the <strong class="source-inline">nodeValue</strong> from there. You can go to the Mozilla documentation (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord">https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord</a>) if you want to know the full list of properties of the mutation records.</p>
			<p>That observer won't do much. We <a id="_idIndexMarker344"/>need to tell it to observe changes in a particular element, in our case, an element with the selector <strong class="source-inline">.counter.qty .counter-number</strong>. So, we call <strong class="source-inline">observe</strong>, passing the <strong class="source-inline">counter</strong> element, and, as a second argument, we will tell the <strong class="source-inline">observe</strong> function what changes we want to listen to. In this case, we only care about <strong class="source-inline">characterData</strong> changes, and we also want to listen to changes in the <strong class="source-inline">subtree</strong> (child elements). That means text changes.</p>
			<p>So now, we could make a copy of our previous test and replace <strong class="source-inline">cartIsOnePromise</strong> and <strong class="source-inline">cartIsTwoPromise</strong> with something like this:</p>
			<p class="source-code">const reachedToTwo = new Promise((r<a id="_idTextAnchor124"/><a id="_idTextAnchor125"/>esolve) =&gt; {</p>
			<p class="source-code">    page.exposeFunction('notif<a id="_idTextAnchor126"/><a id="_idTextAnchor127"/>yCartChange', i =&gt; {</p>
			<p class="source-code">        if(i ==='2') </p>
			<p class="source-code">            resolve();</p>
			<p class="source-code">    })</p>
			<p class="source-code">});</p>
			<p class="source-code">await page.evaluate(() =&gt; {</p>
			<p class="source-code">    let observer = new MutationObserver(list =&gt; notifiyCartChange(list[0].target.nodeValue));</p>
			<p class="source-code">    observer.observe(</p>
			<p class="source-code">        document.querySelector('.counter.qty .counter-number'), </p>
			<p class="source-code">        {</p>
			<p class="source-code">            characterData: true, </p>
			<p class="source-code">            attributes: false, </p>
			<p class="source-code">            childList: false, </p>
			<p class="source-code">            subtree: true</p>
			<p class="source-code">        });</p>
			<p class="source-code">});</p>
			<p>We create a promise, <strong class="source-inline">reachedToTwo</strong>. Inside the promise constructor, we will expose a function named <strong class="source-inline">'notifyCartChange'</strong>. The function we will expose there will expect one argument, and we will resolve the promise if the argument is equal to <strong class="source-inline">'2'</strong>.</p>
			<p>That <strong class="source-inline">exposeFunction</strong> function will allow us to call a <strong class="source-inline">notifiyCartChange</strong> inside the <strong class="source-inline">MutationObserver</strong> we declared using an <strong class="source-inline">evaluate</strong> call.</p>
			<p>For the last step, we replace our old awaits with the new promise:</p>
			<p class="source-code">await reachedToTwo;</p>
			<p>If everything goes as expected, <strong class="source-inline">notifyCartChange</strong> will be called twice, once with the value <strong class="source-inline">'1'</strong> and then with<a id="_idIndexMarker345"/> the value <strong class="source-inline">'2'</strong>, and the second call will resolve the <strong class="source-inline">reachedToTwo</strong> promise we added at the end of the test.</p>
			<p>This might sound like silly, overcomplicated code, but picture all you could do with <strong class="source-inline">exposeFunction</strong> and <strong class="source-inline">MutationObserver</strong>. You could test chat apps by listening to incoming changes and many other complex scenarios.</p>
			<p>Before wrapping up this chapter, it is time to add another tool to our toolbox.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor128"/>Running our checks with Checkly</h1>
			<p>This is an extra tool that I want to show you, and you shouldn't miss the chance of trying it out. <em class="italic">Checkly</em> (<a href="https://www.checklyhq.com/">https://www.checklyhq.com/</a>) is a platform that will help you monitor your website. The <a id="_idIndexMarker346"/>following screenshot shows the <em class="italic">Checkly</em> website:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_6.06_B16113.jpg" alt="Checkly website&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Checkly website</p>
			<p>Once you create an account in <em class="italic">Checkly</em>, you will be able to upload your tests (or checks), and <em class="italic">Checkly</em> will run those checks every certain number of minutes, reporting back. Firstly, it will report whether the check is passing, and secondly, it will report the time it took to run.</p>
			<p>You will also be able to<a id="_idIndexMarker347"/> test your website's API without running a browser. This is huge. It's like having your own, personal quality guard.</p>
			<p>Let's go to <a href="https://www.checklyhq.com/">https://www.checklyhq.com/</a> and start our trial. Follow these steps to start using <em class="italic">Checkly</em>:</p>
			<ol>
				<li>Once you enter your email, phone number, and account name, you will get the first dashboard with a few examples, as shown here:<div id="_idContainer085" class="IMG---Figure"><img src="image/Figure_6.07_B16113.jpg" alt="Checkly dashboard&#13;&#10;"/></div><p class="figure-caption">Checkly dashboard</p></li>
				<li>You can now<a id="_idIndexMarker348"/> delete those two examples and create your own cart test. We can create a browser test:<div id="_idContainer086" class="IMG---Figure"><img src="image/Figure_6.08_B16113.jpg" alt="New test dialog&#13;&#10;"/></div><p class="figure-caption">New test dialog</p></li>
				<li>Now, name your check <strong class="source-inline">Cart number check</strong>. You can copy the code from the <strong class="source-inline">Chapter6/checkly.js</strong> file:</li>
			</ol>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/Figure_6.09_B16113.jpg" alt="First check&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">First check</p>
			<p>Notice that we<a id="_idIndexMarker349"/> have left the browser and the page creation there. Once we have copied the code, we can click on the <strong class="bold">Run Script</strong> button to check that the code is correct. Finally, we will need to pick our data center locations, hit <strong class="bold">Save Check</strong>, and we will have a platform checking our website's health automatically.</p>
			<p>If your team can afford it, <em class="italic">Checkly</em> will take you to the next level. Now it's time to wrap up. </p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor129"/>Summary</h1>
			<p>We covered one of the most powerful features of Puppeteer in this chapter. Most web automation tools let you run JavaScript code somehow, but Puppeteer makes it super easy to implement.</p>
			<p>We started this chapter by talking about some basic JavaScript concepts. We learned about variable scopes and closures. That helped us understand how variables and closures work (or don't work) in Puppeteer. If you learned those differences, you will be able to answer 20% of the Puppeteer questions on Stack Overflow.</p>
			<p>Then, we learned about <strong class="source-inline">JSHandles</strong> and <strong class="source-inline">ElementHandles</strong>. You don't see these classes being used a lot by the community, but they are very helpful if you know how to use them, and now you know.</p>
			<p>The <strong class="source-inline">waitForFunction</strong> completed our "wait" toolbox. You will use that wait function a lot. We also learned how to expose functions and listen to HTML changes using <strong class="source-inline">MutationObserver</strong>. Exposing functions and listening to HTML changes is not used much in UI testing, but it is an excellent tool for web scraping, a great topic we will cover in <a href="B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 9</em></a>, <em class="italic">Scraping tools</em>.</p>
			<p>With this chapter, we have completed the basics of Puppeteer. You now have most of the tools you need to start doing end-to-end testing.</p>
			<p>I hope you are as excited with <em class="italic">Checkly</em> as I was when I saw this platform for the very first time. <em class="italic">Checkly</em> is a dashboard that will help not only the QA team but also the development team. It will help your team find issues and even find new opportunities to improve your site's performance.</p>
			<p>In the next chapter, we will see some features you wouldn't expect from an automation tool. We are going to see how to generate content using Puppeteer.</p>
		</div>
	</body></html>