<html><head></head><body><div><h1 class="header-title">Technology Fundamentals</h1>
                
            
            
                
<p>This book assumes that you have a working knowledge of HTML, CSS, and JavaScript, which are essential tools for creating visualizations with Chart.js. All examples in the book are written with JavaScript ES2015 or ES6. One of the goals of this chapter is to review the fundamental topics of these technologies. This includes JavaScript topics related to string, object, and array manipulation, the HTML document object model (DOM), basic JQuery, CSS selectors, and HTML canvas. You can, of course, skip these sections if you already feel comfortable with these technologies.</p>
<p>This chapter also describes popular data formats used in visualizations, such as CSV, XML, and JSON, and how to load, parse, and use external data files in these formats in your Web pages. You will also learn how to set up a small testing Web server to run files that load external resources.</p>
<p>The final section contains some tips on how to obtain and prepare data for your visualizations, how to convert HTML data into standard formats, and how to extract selected information from HTML pages.</p>
<p>In this chapter, you will learn about the following:</p>
<ul>
<li>Essential JavaScript for Chart.js</li>
<li>Other technologies: DOM, CSS, JQuery, and Canvas</li>
<li>Data formats</li>
<li>How to load and parse external data files</li>
<li>How to extract and transform data</li>
</ul>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Essential JavaScript for Chart.js</h1>
                
            
            
                
<p>Client-side applications, such as interactive Web graphics, depend on browser support. This book assumes that your audience uses browsers that support HTML5 Canvas and ES2015 (which include all modern browsers). All examples use ES2015 syntax, including <em>const</em> and <em>let</em> instead of <em>var</em>, arrow functions where appropriate, spread operators, maps, sets, and promises. External files are loaded using the Fetch API, which has only been supported more recently, but you can easily switch to JQuery if necessary.</p>
<p>Although the creation of visualizations with Chart.js is mostly a declarative process, it is still a JavaScript library and requires basic knowledge of JavaScript. To create a simple chart, you need to know how to declare constants and variables, perform basic mathematical Boolean string and attribution operations, call and create functions, manipulate objects and arrays, and instantiate the Chart.js object. A typical chart also requires enough knowledge to program control structures, write callbacks, sort and filter datasets, generate random numbers, and load external files. This section is a quick refresher on the main ES2015 topics you will need to use Chart.js.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Browser tools</h1>
                
            
            
                
<p>You don't need a full frontend modular Node development environment to create visualizations with Chart.js, but you still need a good debugger. Every browser comes with development tools that allow you to navigate a static page structure and generated DOM elements, and a console where you can interact in real time with the data used by the JavaScript engine.</p>
<p>The most important tool is the <strong>JavaScript console</strong>, where you will see any error messages. It's very common to get a blank page when you expected something else and not have a clue as to why your code doesn't work as expected. Sometimes, it's just a comma you forgot, or the internet is down and some file was not loaded. If you have the JavaScript console open while you run your page, it will instantly tell you what's going on. It's also a good idea to use an editor with line numbering, since most error messages inform us of the lines where the problem occurred:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b0d0a36f-9ca6-4578-bf2e-86e8895b12c4.png" width="1093" height="408"/></p>
<p>Debugging JavaScript with the JavaScript console</p>
<p>You can open the developer tools as a frame in your browser or as a separate window. The following are the menu paths for the JavaScript console in latest versions of the three most popular browsers:</p>
<ul>
<li>Chrome: View | Developer | JavaScript Console</li>
<li>Firefox: Tools | Web Developer | Web Console</li>
<li>Safari: Develop | Show Error Console</li>
</ul>
<p>Most of the code fragments and examples in this section can be tested by typing them in the JavaScript console. It's a great way to learn JavaScript. It will also access the functions of any JavaScript library file that was loaded with the <kbd>&lt;script&gt;</kbd> tag, and any global variables declared in the <kbd>&lt;script&gt;&lt;/script&gt;</kbd> blocks.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">JavaScript types and variables</h1>
                
            
            
                
<p>JavaScript is not a typed language, since types are not declared and variables can receive different types, but data values do have types. The main types are <em>Number</em>, <em>String</em>, <em>Boolean</em>, <em>Array</em>, <em>Object</em>, and <em>Function</em>. The first three are scalar types, and the last three are also objects. A value is treated differently in the same expression if it has one type or another. For example, in an expression such as <em>a = b</em> + <em>c</em>, the value of <em>a</em> will be different if <em>b</em> and <em>c</em> are numbers (they will be added) or if one of them is a string (they will be concatenated).</p>
<p>Values can be compared, and their types are important if the comparison is <em>strict</em> (for example, using <kbd>===</kbd> instead of <kbd>==</kbd>). But it can be confusing to rely on such conversions (<kbd>0</kbd>, <kbd>""</kbd>, <kbd>null</kbd>, <kbd>NaN</kbd> , and <kbd>undefined</kbd> are all considered <kbd>false</kbd>, but the  <kbd>false</kbd> string converts to <kbd>true</kbd>, since its not an empty string).</p>
<p>In ES5 JavaScript, <kbd>var</kbd> was the only keyword for declaring a variable. It ignores block scope and is hoisted to the top of the functions. Since ES6 (ES2015), two new keywords have been introduced: <kbd>const</kbd> and <kbd>let</kbd>. They both are block-scoped and need to be assigned a value before they are used (<kbd>var</kbd> defaults to <kbd>undefined</kbd>). Declarations with <kbd>const</kbd> are constants and can't be reassigned. It's usually considered good practice to use <kbd>const</kbd> whenever possible, and only use <kbd>let</kbd> if you actually need to redefine a variable.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Data structures used in charts</h1>
                
            
            
                
<p>Data used as sources for visualizations is usually organized in some kind of structure. The most common structures are probably <em>lists</em> (arrays) and <em>tables</em> (maps), stored in some standard data format. When using data from external sources, you usually need to clean it up, removing unnecessary values, simplifying its structure, applying bounds, and so on. After that, you can parse it and finally store it locally in a JavaScript array or JavaScript object that can be used by the chart.</p>
<p>Once your data is stored in a JavaScript data structure, you can transform it further by applying mathematical operations on the stored values. You can change the structure, create new fields, merge, and delete data. Typical operations include pushing new values into the dataset, splicing or splitting the array, creating a subset, transforming data, and so on. JavaScript provides many native operations that make it easier to modify arrays and objects. You can also use libraries such as JQuery.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Arrays</h1>
                
            
            
                
<p>The main data structure you will use to store one-dimensional data is the JavaScript array. It's used as the main dataset format in most chart types in Chart.js. An array of values is all you need to make a simple bar chart. You can create an array by declaring a list of items within brackets, or simply a pair of opening-closing brackets if you want to start with an empty array:</p>
<pre>const colors = ["red", "blue", "green"];<br/>const geocoords = [27.2345, 34.9937];<br/>const numbers = [1,2,3,4,5,6];<br/>const empty = [];</pre>
<p>You can then access the items of an array using an array index, which starts counting from zero:</p>
<pre>const blue = colors[1];<br/>const latitude = geocoords[0];</pre>
<p>Each array has a length property that returns the number of elements. It's very useful to iterate using the array index:</p>
<pre>for(let i = 0; i &lt; colors.length; i++) {<br/>    console.log(colors[i]);<br/>}</pre>
<p>You can also loop over the elements of an array using the <em>of</em> operator (introduced in ES2015) when you don't need the index:</p>
<pre>for(let color of colors) {<br/>    console.log(color);<br/>}</pre>
<p>And you can use the <kbd>forEach()</kbd> method, which runs a function for each element and also allows access to the index, item, and array inside the function:</p>
<pre>colors.forEach(function(i, color, colors) {<br/>    console.log((i+1) + ": " + color);<br/>}</pre>
<p>Multidimensional arrays are created in JavaScript as arrays of arrays:</p>
<pre>const points = [[200,300], [150,100], [100,300]];</pre>
<p>You can retrieve individual items like this:</p>
<pre>const firstPoint = points[0];<br/>const middleX = points[1][0];</pre>
<p>JavaScript provides many ways to extract and insert data into an array. It's usually recommended to use these methods whenever possible. The following table lists useful methods you can use on arrays. Some modify the array; others return new arrays and other types. The examples provided use the <kbd>colors</kbd> and <kbd>numbers</kbd> arrays as declared previously. Try them out using your browser's JavaScript console:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 16%">
<p><strong>Method</strong></p>
</td>
<td style="width: 35.0616%">
<p><strong>Description</strong></p>
</td>
<td style="width: 45.9384%">
<p><strong>Example</strong></p>
</td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>push(item)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Modifies the array, adding an item to the end.</p>
</td>
<td style="width: 45.9384%">
<pre>colors.push("yellow"); <br/>/*["red", "blue", "green", <br/>   "yellow"];*/</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>pop()</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Modifies the array, removing and returning the last item.</p>
</td>
<td style="width: 45.9384%">
<pre>const green = colors.pop(); <br/>// ["red", "blue"];</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>unshift(item)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Modifies the array, inserting an item at the beginning.</p>
</td>
<td style="width: 45.9384%">
<pre>colors.unshift("yellow");<br/>/*["yellow", "red", "blue", <br/>   "green"];*/</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>shift()</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Modifies the array, removing and returning the first item.</p>
</td>
<td style="width: 45.9384%">
<pre>const red = colors.shift();<br/>// ["blue", "green"];</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>splice(p,n,i)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Modifies the array, starting at position <kbd>p</kbd>. Can be used to delete, insert, or replace items.</p>
</td>
<td style="width: 45.9384%">
<pre>const s = numbers.splice(2,3);<br/> // s = [3,4,5]<br/> // numbers = [1,2,6]</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>reverse()</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Modifies the array, reversing its order.</p>
</td>
<td style="width: 45.9384%">
<pre>numbers.reverse(); <br/>// [6,5,4,3,2,1]</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>sort()</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Modifies the array, sorting by string order (if no args) or by a comparator function.</p>
</td>
<td style="width: 45.9384%">
<pre>numbers.sort((a,b) =&gt; b – a);<br/>// numbers = [6,5,4,3,2,1]</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>slice(b,e)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns a shallow copy of the array between <kbd>b</kbd> and <kbd>e</kbd>.</p>
</td>
<td style="width: 45.9384%">
<pre>const mid = numbers.slice(2,4)<br/> // mid = [3,4]</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>filter(callback)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns new array where the elements pass the test implemented by the function.</p>
</td>
<td style="width: 45.9384%">
<pre>const even = numbers.filter(n =&gt; n%2==0);<br/>// [2,4,6]</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>find(function)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns the first element that satisfies the test function.</p>
</td>
<td style="width: 45.9384%">
<pre>const two = numbers.find(n =&gt; n%2==0);<br/>// 2</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>indexOf(item)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns the index of the first occurrence of the item in the array.</p>
</td>
<td style="width: 45.9384%">
<pre>const n = numbers.indexOf(3); <br/>// 4</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>includes(item)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns <kbd>true</kbd> if an array contains the item among its entries.</p>
</td>
<td style="width: 45.9384%">
<pre>const n = numbers.includes(3); <br/>// true</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>lastIndexOf(item)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns the index of the last occurrence of the item in the array.</p>
</td>
<td style="width: 45.9384%">
<pre>const n = colors.lastIndexOf("blue"); <br/>// 1</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>concat(other)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns a new array that merges the current array with another.</p>
</td>
<td style="width: 45.9384%">
<pre>const eight = numbers.concat([7,8]);<br/>// [1,2,3,4,5,6,7,8]</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>join()</kbd></p>
<p><kbd>join(delim)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns a comma-separated string of the elements in the array (an optional delimiter may be used).</p>
</td>
<td style="width: 45.9384%">
<pre>const csv = numbers.join();<br/>// "1,2,3,4,5,6"<br/>const conc = numbers.join("");<br/>// "123456"</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>map(function)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns a new array with each element modified by the function.</p>
</td>
<td style="width: 45.9384%">
<pre>const squares = numbers.map(n =&gt; n*n);<br/>// [1,4,9,16,25,36]</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>reduce(function)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Returns the result of an accumulation operation using the values in the array.</p>
</td>
<td style="width: 45.9384%">
<pre>const sum =<br/>  numbers.reduce((a, n) =&gt; a + n);</pre></td>
</tr>
<tr>
<td style="width: 16%">
<p><kbd>forEach(function)</kbd></p>
</td>
<td style="width: 35.0616%">
<p>Executes the provided function once for each element in the array.</p>
</td>
<td style="width: 45.9384%">
<pre>const squares = [];<br/>numbers.forEach(n =&gt; squares.push(n*n)<br/>// squares = [1,4,9,16,26,36]</pre></td>
</tr>
</tbody>
</table>
<p>JavaScript functions for array manipulation</p>
<p>Besides arrays, ES2015 also introduced two new data structures: Map, an associative array with key-value pairs, easier to use than simple objects, and Set, which doesn't allow repeated values. Both can be transformed to and from arrays.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Strings</h1>
                
            
            
                
<p>Strings are primitive types in JavaScript that can be created with single quotes or double quotes. There is no difference. It's only a matter of style. ES2015 introduced two new string features: <em>template literals</em> and <em>multiline strings</em>.</p>
<p>Multiline strings can be created by adding a backslash at the end of each line:</p>
<pre>const line = "Multiline strings can be \<br/>reated adding a backslash \<br/>at the end of each line";</pre>
<p>Template literals are strings created with backticks. They allow the inclusion of JavaScript expressions inside the <kbd>${}</kbd> placeholders. The result is concatenated as a single string:</p>
<pre>const template = `The square root of 2 is ${Math.sqrt(2)}`;</pre>
<p>If you need to use a special character in a string, such as a double quote in a double-quoted string or a backslash, you need to precede it with a backslash:</p>
<pre>const s = "This is a backslash \\ and this is a double quote \"";</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There are several methods for string manipulation. They all return new strings or other types. No methods modify the original strings:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Example</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>startsWith(s)</kbd></p>
</td>
<td>
<p>Returns <kbd>true</kbd> if the string starts with the string passed as a parameter.</p>
</td>
<td>
<pre>const s = "This is a test string"<br/>const r = s.startsWith("This");    <br/>// true</pre></td>
</tr>
<tr>
<td>
<p><kbd>endsWith(s)</kbd></p>
</td>
<td>
<p>Returns <kbd>true</kbd> if string ends with the string passed as a parameter.</p>
</td>
<td>
<pre>const s = "This is a test string"<br/>const r = s.endsWith("This"); <br/>// false</pre></td>
</tr>
<tr>
<td>
<p><kbd>substring(s,e)</kbd></p>
</td>
<td>
<p>Returns a substring between <kbd>start</kbd> (incl.) and <em>end</em> indexes (not incl.).</p>
</td>
<td>
<pre>const k = "Aardvark"<br/>const ardva = k.substring(1,6);</pre></td>
</tr>
<tr>
<td>
<p><kbd>split(regx)</kbd></p>
<p><kbd>split(delim)</kbd></p>
</td>
<td>
<p>Splits a string by a delimiter character or  a regular expression and returns an array.</p>
</td>
<td>
<pre>const result = s.split(" ");<br/>// result =<br/>//["This","is","a","test","string"]</pre></td>
</tr>
<tr>
<td>
<p><kbd>indexOf()</kbd></p>
</td>
<td>
<p>Returns the index of the first occurrence of a substring.</p>
</td>
<td>
<pre>const k = "Aardvark"<br/>const i = k.indexOf("ar"); // i = 1</pre></td>
</tr>
<tr>
<td>
<p><kbd>lastIndexOf()</kbd></p>
</td>
<td>
<p>Returns the index of the last occurrence of a substring.</p>
</td>
<td>
<pre>const k = "Aardvark"<br/>const i = k.lastIndexOf("ar");<br/>// i = 5</pre></td>
</tr>
<tr>
<td>
<p><kbd>charAt(i)</kbd></p>
</td>
<td>
<p>Returns <kbd>char</kbd> at index <kbd><em>i</em></kbd>. Also supported as <kbd>‘string'[i]</kbd>.</p>
</td>
<td>
<pre>const k = "Aardvark"<br/>const v = k.charAt(4);</pre></td>
</tr>
<tr>
<td>
<p><kbd>trim()</kbd></p>
</td>
<td>
<p>Removes whitespace from both ends of a string.</p>
</td>
<td>
<pre>const text = "   data   "<br/>const r = data.trim(); <br/>// r = "data"</pre></td>
</tr>
<tr>
<td>
<p><kbd>match(regx)</kbd></p>
</td>
<td>
<p>Returns an array as the result of matching a regular expression against the string.</p>
</td>
<td>
<pre>const k = "Aardvark"<br/>const v = k.match(/[a-f]/g);<br/>// v = ["a", "d", "a"]</pre></td>
</tr>
<tr>
<td>
<p><kbd>replace(regx,r)</kbd></p>
<p><kbd>replace(s,t)</kbd></p>
</td>
<td>
<p>Returns a new string replacing the matching of regexp applied to the string with a replacement or all occurrences of the source string with a target string.</p>
</td>
<td>
<pre>const k = "Aardvark"<br/>const a = p.replace(/a/gi, 'u')<br/>// a = "uurdvurk"<br/>const b = p.replace('ardv', 'ntib')<br/>// b = "Antibark"</pre></td>
</tr>
</tbody>
</table>
<p>JavaScript functions for string manipulation</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Functions</h1>
                
            
            
                
<p>Functions are typically created in JavaScript using the <kbd>function</kbd> keyword, using one of the following forms:</p>
<pre>function f() {<br/>    console.log('function1', this);<br/>}<br/>const g = function(name) {<br/>    console.log('function ' + name, this);<br/>}<br/>f(); // calls f<br/>g('test'); // calls g() with a parameter</pre>
<p>The <kbd>this</kbd> keyword refers to the object that owns the function. If this code runs in a browser, and this is a top-level function created in the <kbd>&lt;script&gt;</kbd> block, the owner is the global <kbd>window</kbd> object. Any properties accessed via this refer to that object.</p>
<p>A function can be placed in the scope of an object, behaving as a method. The <kbd>this</kbd> reference in the following code refers to the <kbd>obj</kbd> object and can access <kbd>this.a</kbd> and <kbd>this.b</kbd>:</p>
<pre>const obj = {a: 5, b: 6}<br/>obj.method = function() {<br/>    console.log('method', this)<br/>}<br/>object.method()</pre>
<p>Arrow functions were introduced in ES2015. They are much more compact and can lead to cleaner code, but the scope of <kbd>this</kbd> is no longer retained by the object. In the following code, it refers to the global window object. Code that uses <kbd>this.a</kbd> and <kbd>this.b</kbd> will not find any data in the object and will return undefined:</p>
<pre>obj.arrow = () =&gt; console.log('arrow', this)<br/>object.arrow()</pre>
<p>You can use arrow functions in Chart.js callbacks, but you should use regular functions instead of arrow functions if you need to access the instance of the chart, usually available using <kbd>this</kbd>.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Objects</h1>
                
            
            
                
<p>An object is an unordered collection of data. Values in an object are stored as key-value pairs. You can create an object by declaring a comma-separated list of <em>key:value</em> pairs within curly braces, or simply a pair of opening-closing curly braces if you want to start with an empty object:</p>
<pre>const color = {name: "red", code: ff0000};<br/>const empty = {};</pre>
<p>Objects can contain other objects and arrays, which can also contain objects. They can also contain functions, which have access to local properties and behave as methods:</p>
<pre>const city = {name: "Sao Paulo",<br/>              location: {latitude: 23.555, longitude: 46.63},<br/>              airports: ["SAO","CGH","GRU","VCP"]};<br/>const circle = {<br/>    x: 200,<br/>    y: 100,<br/>    r: 50,<br/>    area: function() {<br/>        return this.r * this.r * 3.14;<br/>    }<br/>}</pre>
<p>A typical dataset used by a simple chart usually consists of an array of objects:</p>
<pre>var array2 = [<br/>    {continent: "Asia", areakm2: 43820000},<br/>    {continent: "Europe", areakm2: 10180000},<br/>    {continent: "Africa", areakm2: 30370000},<br/>    {continent: "South America", areakm2: 17840000},<br/>    {continent: "Oceania", areakm2: 9008500},<br/>    {continent: "North America", areakm2=24490000}<br/>];</pre>
<p>You can access the properties of an object using the dot operator or brackets containing the key as a string. You can run its methods using the dot operator:</p>
<pre>const latitude = city.location.latitude;<br/>const oceania = array2[4].continent;<br/>const code = color["code"];<br/>circle.r = 100;<br/>const area = circle.area();</pre>
<p class="mce-root"/>
<p>You can also loop over the properties of an object:</p>
<pre>for(let key in color) {<br/>     console.log(key + ": " + color[key]);<br/>}</pre>
<p>Properties and functions can be added to objects. It's common to write code that declares an empty object in a global context so that operations in other contexts add data to it:</p>
<pre>const map = {};<br/>function getCoords(coords) {<br/>    map.latitude = coords.lat;<br/>    map.longitude = coords.lng;<br/>}</pre>
<p>Objects can also be created with a constructor. You can create an object that contains the current date/time using:</p>
<pre>const now = new Date();</pre>
<p>A Chart.js instance is created using a constructor that receives at least two parameters. The second parameter is an object with two properties, a string and another object:</p>
<pre>const chart =<br/>    new Chart("bar-chart ",{type:"bar", data:{labels:[],datasets:[]}});</pre>
<p>JSON is a data format based on JavaScript objects. It has the same structure as a JavaScript object, but the property keys have to be placed within double quotes:</p>
<pre>{"name": "Sao Paulo",<br/>              "location": {"latitude": 23.555, "longitude": 46.63},<br/>              "airports": ["SAO","CGH","GRU","VCP"]};</pre>
<p>To use a JSON string in JavaScript you have to parse it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Other technologies</h1>
                
            
            
                
<p>This section presents a brief summary of other technologies you should know about, covering their fundamental concepts. They include HTML DOM, JQuery, CSS, and HTML Canvas. You can skim or skip this section if you already know about and use these technologies. The next sections also provide code examples that can be downloaded from the GitHub repository for this chapter.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">HTML Document Object Model(DOM)</h1>
                
            
            
                
<p>The structure of an HTML document is normally described with tags, but it can also be specified using JavaScript commands with a <strong>Document Object Model (DOM)</strong>: a language-neutral API that represents an HTML or XML document as a <em>tree</em>. Consider the following HTML document (<kbd>Examples/example-1.html</kbd>):</p>
<pre>&lt;html&gt;<br/>&lt;body&gt;<br/>     &lt;h1&gt;Simple page&lt;/h1&gt;<br/>     &lt;p&gt;Simple paragraph&lt;/p&gt;<br/>     &lt;div&gt;<br/>         &lt;img src="img/pluto.jpg" width="100"/&gt;<br/>         &lt;p&gt;Click me!&lt;/p&gt;<br/>     &lt;/div&gt;<br/> &lt;/body&gt;<br/> &lt;/html&gt;</pre>
<p>This page builds a tree of interconnected <em>nodes</em> containing HTML elements and text. The exact same result can be obtained with the following JavaScript commands (<kbd>Examples/example-2.html</kbd>):</p>
<pre> const html = document.documentElement;<br/> <br/> const body = document.createElement("body");<br/> html.appendChild(body);<br/> <br/> const h1 = document.createElement("h1");<br/> const h1Text = document.createTextNode("Simple page");<br/> h1.appendChild(h1Text);<br/> body.appendChild(h1);<br/> <br/> const p = document.createElement("p");<br/> const pText = document.createTextNode("Simple paragraph");<br/> p.appendChild(pText);<br/> body.appendChild(p);<br/> <br/> const div = document.createElement("div");<br/> const divImg = document.createElement("img");<br/> divImg.setAttribute("src", "pluto.jpg");<br/> divImg.setAttribute("width", "100");<br/> div.appendChild(divImg);<br/> <br/> const divP = document.createElement("p");<br/> const divPText = document.createTextNode("Click me!");<br/> divP.appendChild(divPText);<br/> div.appendChild(divP);<br/> <br/> body.appendChild(div);</pre>
<p>Of course, it's much simpler to write tags, but JavaScript gives you the power to make the structure and content <em>dynamic</em>. Using DOM commands, you can add new elements, move them around, remove them, and change their attributes and text contents. You can also navigate the DOM tree, select or search for specific elements or data, and bind styles and event handlers to elements.</p>
<p>For example, if you add the following code, a new <kbd>&lt;p&gt;</kbd> containing the <kbd>“New line”</kbd> text will be created every time you click on the image (<kbd>Examples/example-3.html</kbd>):</p>
<pre>div.style.cursor = "pointer";<br/>div.addEventListener("click", function() {<br/>    const p = document.createElement("p");<br/>    p.innerHTML = "New line";<br/>    this.appendChild(p);<br/>});</pre>
<p>Normally, you wouldn't write your entire document using DOM, but only the parts you wish to control dynamically. Normally, you write the static parts as HTML and use scripting only when necessary (<kbd>Examples/example-4.html</kbd>):</p>
<pre> &lt;html&gt;<br/> &lt;body&gt;<br/> &lt;h1&gt;Simple page&lt;/h1&gt;<br/> &lt;p&gt;Simple paragraph&lt;/p&gt;<br/> &lt;div id="my-section"&gt;<br/>     &lt;img src="img/pluto.jpg" width="100"/&gt;<br/>     &lt;p&gt;Click me!&lt;/p&gt;<br/> &lt;/div&gt;<br/> &lt;/body&gt;<br/> <br/> &lt;script&gt;<br/>     const div = document.getElementById("my-section");<br/>     div.style.cursor = "pointer";<br/>     div.addEventListener("click", function() {<br/>         const p = document.createElement("p");<br/>         p.innerHTML = "New line";<br/>         this.appendChild(p);<br/>     });<br/> &lt;/script&gt;<br/> &lt;/html&gt;</pre>
<p>For data-driven documents, you can use DOM scripting to bind data stored in arrays and objects to attributes of the elements, changing the dimensions, colors, text contents, and position. Most data visualization libraries do exactly that by providing functions that are built over the DOM, and make this task much simpler.</p>
<p>The following table lists the most important DOM commands:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Method or property</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>createElement(tag)</kbd></p>
</td>
<td>
<p>Creates an element (not connected to the node tree) and returns its reference.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>createTextNode(text)</kbd></p>
</td>
<td>
<p>Creates a text node (not connected to the node tree) and returns its reference.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>appendChild(element)</kbd></p>
</td>
<td>
<p>Connects the element passed as a parameter as the child of the current element.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>removeChild(element)</kbd></p>
</td>
<td>
<p>Disconnects the child element from the current element.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>setAttribute(name, value)</kbd></p>
</td>
<td>
<p>Sets an attribute for this element with the name and value passed as parameters.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getElementById(id)</kbd></p>
</td>
<td>
<p>Returns an element identified by the <kbd>id</kbd> passed as a parameter.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getElementsByTagName(tag)</kbd></p>
</td>
<td>
<p>Returns a <kbd>nodelist</kbd> (array) containing all the elements that match the tag name passed as a parameter.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>addEventListener(e, func)</kbd></p>
</td>
<td>
<p>Attaches an event handler to this element. The first parameter is the event type (for example, <kbd>‘click'</kbd>, <kbd>‘key'</kbd>, and so on) and the second parameter is a handler function.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>documentElement</kbd></p>
</td>
<td>
<p>This property references the element at the root of the document. For HTML and XHTML, it is the <kbd>&lt;html&gt;</kbd> element.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>children</kbd></p>
</td>
<td>
<p>This property returns a node list containing the child elements of this element.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>innerText</kbd></p>
</td>
<td>
<p>In SVG or HTML documents, this read/write property is a shortcut for creating a text node and appending it to the element.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>innerHTML</kbd></p>
</td>
<td>
<p>In HTML documents, this read/write property is a shortcut for appending an entire HTML fragment as a child element.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>style</kbd></p>
</td>
<td>
<p>In SVG or HTML documents, this property allows access to the element's CSS styles. You can use it to read and modify styles dynamically.</p>
</td>
</tr>
</tbody>
</table>
<p>A selection of properties and methods supported by HTML DOM</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Cascading Style Sheets</h1>
                
            
            
                
<p><strong>Cascading Style Sheets</strong> (<strong>CSS</strong>) is a W3C standard that specifies how HTML and XML elements are displayed on the screen. It's a declarative language where visual properties are applied to tag selectors. You can use CSS to apply properties such as colors, fonts, margins, shadows, and gradients to one or more tags, perform coordinate transformations in two and three dimensions, and set rules for transitions and animations. CSS properties and selectors are also used in JavaScript libraries, such as JQuery and D3.js.</p>
<p>CSS selectors are expressions used to select elements by type, class, ID, wildcards, attributes, context, state, and position. The result of a selection expression may consist of none, one, or more elements. JavaScript libraries use selectors to obtain objects that can be manipulated programmatically via DOM. A result set can be formed from a list of comma-separated selection expressions. Elements may also be selected from context with combinator selectors. The following table lists some of the main selectors and some examples:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 13.8754%">
<p><strong>Selector</strong></p>
</td>
<td style="width: 14.0045%">
<p><strong>Syntax</strong></p>
</td>
<td style="width: 71.152%">
<p><strong>Description Example (in CSS)</strong></p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>Type selector</p>
</td>
<td style="width: 14.0045%">
<p><kbd>tagname</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects a set of elements of the specified type (tag name), for example <kbd>td, h1, prect { … } /* all &lt;rect&gt; tags */</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>Class selector</p>
</td>
<td style="width: 14.0045%">
<p><kbd>.classname</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects a set of elements that belongs to a specified class, for example <kbd>.selected</kbd> and <kbd>p.copy</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>ID selector</p>
</td>
<td style="width: 14.0045%">
<p><kbd>#idname</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects one element with the specified <kbd>id</kbd> attribute, for example <kbd>#main</kbd> and <kbd>#chart</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>Universal selector</p>
</td>
<td style="width: 14.0045%">
<p><kbd>*</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects all elements.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>Attribute selector</p>
</td>
<td style="width: 14.0045%">
<p><kbd>[attr]</kbd><br/>
<kbd>[attr=value]</kbd></p>
<p>(several other combinations)</p>
</td>
<td style="width: 71.152%">
<p>Selects elements that contain an attribute.</p>
<p>Selects elements that contain an attribute with a specified value.</p>
<p>Other combinations match a string in the attribute value.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>Descendant combinator</p>
</td>
<td style="width: 14.0045%">
<p><kbd>ancestor selectedtag</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects elements nested within a specified ancestor element (may have other elements in between), for example table <kbd>td</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>Child<br/>
combinator</p>
</td>
<td style="width: 14.0045%">
<p><kbd>parent &gt; selectedtag</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects elements nested <em>directly</em> below a specified parent element (<kbd>selectedTag</kbd> is a child of a parent), for example <kbd>table &gt;tbody &gt;tr &gt;td</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>General sibling combinator</p>
</td>
<td style="width: 14.0045%">
<p><kbd>preceding ~ selectedtag</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects elements that appear after a specified predecessor (both have the same parent), for example <kbd>h1 ~p.last</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>Adjacent sibling combinator</p>
</td>
<td style="width: 14.0045%">
<p><kbd>previous + selectedtag</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects elements that appear <em>directly</em> after a specified sibling (both have the same parent), for example <kbd>h1 +p.first</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>Pseudo-classes</p>
</td>
<td style="width: 14.0045%">
<p><kbd>tag:state</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects elements that are in a specified <em>state,</em> for example <kbd>a:hover, p:last-child, td:nth-of-type(2), :not(x)</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 13.8754%">
<p>Pseudo-elements</p>
</td>
<td style="width: 14.0045%">
<p><kbd>tag::property</kbd></p>
</td>
<td style="width: 71.152%">
<p>Selects elements with a specified <kbd>property</kbd>, and is rarely used.</p>
</td>
</tr>
</tbody>
</table>
<p>CSS selectors</p>
<p>Most of the time, you will use the simplest selectors. The ID, class, and type selectors are the most common. Eventually, you might use descendant combinators or attribute selectors.</p>
<p>The following code uses simple selectors to change the visual appearance of an unformatted page containing three sections. The sections are stacked one on top of the other. The CSS properties and other parts were omitted, but you can see them in the full code listing (<kbd>Examples/example-5-selectors.html</kbd>):</p>
<pre>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;style&gt;<br/>        h1 {…}<br/>        .tab h1 {…}<br/>        .tab p {…}<br/>        .illustration {…}<br/>        .tab {…}<br/>        .tab .contents {…}<br/>        .container {…}<br/>        .tab:nth-child(2) h1 {…}<br/>        .tab:nth-child(3) h1 {…}<br/>    &lt;/style&gt;<br/>&lt;/head&gt;<br/> <br/>&lt;body&gt;<br/>&lt;h1&gt;CSS and JQuery selectors&lt;/h1&gt;<br/> <br/>&lt;div id="container"&gt;<br/> <br/>    &lt;div class="tab first" id="section1"&gt;<br/>        &lt;div class="contents"&gt;<br/>            &lt;img class="illustration" src="img/jupiter.jpg" /&gt;<br/>            &lt;p&gt;…&lt;/p&gt;<br/>        &lt;/div&gt;<br/>        &lt;h1&gt;Tab 1: Jupiter&lt;/h1&gt;<br/>    &lt;/div&gt;<br/> <br/>    &lt;div class="tab" id="section2"&gt;<br/>        &lt;div class="contents"&gt;<br/>            &lt;img class="illustration" src="img/saturn.jpg" /&gt;<br/>            &lt;p&gt;…&lt;/p&gt;<br/>        &lt;/div&gt;<br/>        &lt;h1&gt;Tab 2: Saturn&lt;/h1&gt;<br/>    &lt;/div&gt;<br/> <br/>    &lt;div class="tab" id="section3"&gt;<br/>        &lt;div class="contents"&gt;<br/>            &lt;img class="illustration" src="img/pluto.jpg" /&gt;<br/>            &lt;p&gt;…&lt;/p&gt;<br/>        &lt;/div&gt;<br/>        &lt;h1&gt;Tab 3: Pluto&lt;/h1&gt;<br/>    &lt;/div&gt;<br/> <br/>&lt;/div&gt;<br/>&lt;/body&gt;<br/> <br/>&lt;/html&gt;</pre>
<p>The result is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bd5c5108-f516-4aca-b70f-c6563c648daf.png" style="width:31.25em;height:17.25em;" width="612" height="339"/></p>
<p>An HTML page with stacked information styled using only CSS</p>


            

            
        
    </div>



  
<div><h1 class="header-title">JQuery fundamentals</h1>
                
            
            
                
<p>JQuery is not a standard technology, but it's a de facto Web standard. It uses CSS selectors to locate elements in any HTML file, and provides the same power as the DOM but with a much cleaner syntax. To use <em>JQuery,</em> you first need to include its library in your HTML page using the <kbd>&lt;script&gt;</kbd> tag. This is easily done with a CDN URL:</p>
<pre>&lt;script src="img/jquery-3.3.1.min.js"&gt;&lt;/script&gt;</pre>
<p>The code fragment here is a page that uses <em>JQuery</em> to perform the exact same operations shown in the last DOM example. The result is much easier to understand (<kbd>Examples/example-6.html</kbd>):</p>
<pre>&lt;html&gt;<br/>&lt;body&gt;<br/>&lt;head&gt;<br/>    &lt;style&gt;<br/>        #my-section {<br/>            cursor: pointer;<br/>        }<br/>    &lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;h1&gt;Simple page&lt;/h1&gt;<br/>&lt;p&gt;Simple paragraph&lt;/p&gt;<br/>&lt;div id="my-section"&gt;<br/>    &lt;img src="img/pluto.jpg" width="100"/&gt;<br/>    &lt;p&gt;Click me!&lt;/p&gt;<br/>&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;script src="img/jquery-3.3.1.min.js"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>    $("#my-section").on("click", function() {<br/>        $(this).append("&lt;p&gt;New Line&lt;/p&gt;");<br/>    });<br/>&lt;/script&gt;<br/>&lt;/html&gt;</pre>
<p>CSS selectors are used in JavaScript libraries such as <em>JQuery</em> to apply dynamic styles and manipulate a document's structure and contents. The main JQuery(selector) function, normally used via its alias, the <kbd>$(selector)</kbd><em> </em>function, is an element selector that receives a CSS selector expression as its parameter:</p>
<pre>const divSet = $("div");<br/>const title1 = $("#section1 h1");</pre>
<p>A selection can return zero, one, or a list of elements. You can test the length of a selection using the <kbd>length</kbd> attribute:</p>
<pre>if($("table").length == 0) {<br/>     console.log("there are no tables in this document")<br/> }</pre>
<p>Using <em>JQuery</em> and the code shown in the CSS example, we can make the tabs fade in and fade out as they are clicked using selectors and <em>JQuery</em> functions (<kbd>Examples/example-7-selectors.html</kbd>):</p>
<pre>&lt;script src="img/jquery-3.3.1.min.js"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>    $(".tab").on("click", function() {<br/>        $(".tab h1").css("color", "gray");<br/>        $(".tab h1").css("background", "white");<br/>        $(".tab h1").css("font-weight", "normal");<br/>        $(".tab h1").css("z-index", "-1");<br/>        $("#" + $(this).attr("id") + " h1").css("color", "black");<br/>        $("#" + $(this).attr("id") + " h1").css("background", "whitesmoke");<br/>        $("#" + $(this).attr("id") + " h1").css("font-weight", "bold");<br/>        $("#" + $(this).attr("id") + " h1").css("z-index", "1");<br/>        $(".tab .contents").fadeOut();<br/>        $("#" + $(this).attr("id") + " .contents").fadeIn();<br/>    });<br/>    $("#section1").trigger("click");<br/>&lt;/script&gt;</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">HTML5 Canvas</h1>
                
            
            
                
<p>There is no way to draw circles or gradients using HTML tags, but you can use HTML Canvas: a full-featured JavaScript graphics API for 2D vector graphics. You can draw anything you wish with Canvas, and since it's JavaScript, you can make it animate and respond to events.</p>
<p>To draw using Canvas, you need to create a <kbd>&lt;canvas&gt;</kbd> element in your page. You can do that using plain HTML:</p>
<pre>&lt;body&gt;<br/>    &lt;canvas id="canvas" width="300" height="300"&gt;&lt;/canvas&gt;<br/>&lt;/body&gt;</pre>
<p>You can also create it dynamically, using HTML DOM:</p>
<pre>const canvas = document.createElement("canvas");<br/>canvas.setAttribute("width", 300);<br/>canvas.setAttribute("height", 300);<br/>document.body.appendChild(canvas);</pre>
<p>You can create it using <em>JQuery</em> too:</p>
<pre>const canvas = $("&lt;canvas/&gt;",{id: "canvas"}).prop({width:300,height:300});</pre>
<p>Then you can reference using the DOM:</p>
<pre>const canvas = document.getElementById("canvas");<br/>const canvas = $("#canvas");</pre>
<p>Or you can reference using JQuery:</p>
<pre>const canvas = document.getElementById("canvas");<br/>const canvas = $("#canvas");</pre>
<p>Once you have a canvas object, you obtain a 2D graphics context and can start drawing:</p>
<pre>const ctx    = canvas.getContext("2d");</pre>
<p>Practically, all the Canvas API consists of is methods and properties called from the graphics context. Before drawing, you set properties such as font, fill color, and stroke color:</p>
<pre>ctx.fillStyle = "red";<br/>ctx.strokeStyle = "rgba(255,127,0,0.7)";<br/>ctx.lineWidth = 10;</pre>
<p>And then <em>fill</em> or <em>stroke</em> rectangles and arbitrary paths containing lines and curves. These commands will draw a red 50 x 50 pixel square with a 10 pixel wide yellow semi-transparent border at position 50,50:</p>
<pre>ctx.fillRect(50,50,50,50);<br/>ctx.strokeRect(50,50,50,50);</pre>
<p>You can draw other shapes, texts, and images on the same canvas. The context properties will not change unless they are redefined.</p>
<p>You can also draw using path commands. You need to start the path with <kbd>ctx.beginPath()</kbd>, and call a sequence of commands that moves to points and draws lines and curves, and when you are done you can close the path (if it's a closed path) and call <kbd>fill()</kbd> and/or <kbd>stroke()</kbd> to draw it using the current styles.</p>
<p>The following code draws some shapes, paths, shadows, gradients, and text:</p>
<pre> ctx.strokeStyle = "blue";<br/> ctx.lineWidth = 2;<br/> ctx.shadowBlur = 10;<br/> ctx.shadowColor = "green";<br/> ctx.shadowOffsetX = ctx.shadowOffsetY = 5;<br/> ctx.setLineDash([5,2,1,2]);<br/> ctx.beginPath();<br/> ctx.moveTo(150,200);<br/> ctx.lineTo(150,150);<br/> ctx.lineTo(100,150);<br/> ctx.bezierCurveTo(100,200,150,250,200,250);<br/> ctx.lineTo(200,200);<br/> ctx.closePath();<br/> ctx.stroke();<br/> const text = "Canvas";<br/> ctx.font = "24px monospace";<br/> const textWidth = ctx.measureText(text).width;<br/> const gradient = ctx.createLinearGradient(200,100,200 + textWidth,100);<br/> gradient.addColorStop(0,"magenta");<br/> gradient.addColorStop(1, "yellow");<br/> ctx.fillStyle = gradient;<br/> ctx.shadowColor = "transparent";<br/> ctx.fillText("Canvas", 200, 100);<br/> ctx.setLineDash([0]);<br/> ctx.strokeStyle = "gray";<br/> ctx.beginPath();<br/> ctx.moveTo(50,200);<br/> ctx.lineTo(50,250);<br/> ctx.lineTo(100,250);<br/> ctx.arcTo(100,200,50,200,50);<br/> ctx.stroke();<br/> ctx.beginPath();<br/> ctx.arc(275,150,50,1.57,3.14,false);<br/> ctx.lineTo(275,150);<br/> ctx.fill();<br/> ctx.globalAlpha = 0.75;<br/> ctx.beginPath();<br/> ctx.arc(175,75,40,0,6.28,false);<br/> ctx.clip();<br/> const image = new Image(100,100);<br/> image.onload = function() {<br/>     ctx.drawImage(this, 125, 25, this.width, this.height);<br/> }<br/> image.src = "pluto.jpg";</pre>
<p class="mce-root"/>
<p>The following diagram shows the result. You can try and run the full code, which is available in <kbd>Examples/example-8-canvas.html</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/36859749-cdcb-4ec3-a68b-764d6d911393.png" style="width:17.92em;height:17.83em;" width="352" height="351"/></p>
<p>Some shapes drawn in an HTML Canvas context. Code: <em>Examples/example-8-canvas.html</em></p>
<p>Some essential Canvas commands are listed in the following table. All commands are methods of the current Canvas context:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Method or property</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>fillStyle</kbd></p>
</td>
<td>
<p>Sets the color to be used in the <kbd>fill()</kbd> commands.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>strokeStyle</kbd></p>
</td>
<td>
<p>Sets the color to be used in the <kbd>stroke()</kbd> commands.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>lineWidth</kbd></p>
</td>
<td>
<p>Sets the line width to be used in the <kbd>stroke()</kbd> commands.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>lineCap</kbd></p>
</td>
<td>
<p>Sets the style of the line caps, for example <kbd>butt</kbd> (default), <kbd>round</kbd>, or <kbd>square</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>lineJoin</kbd></p>
</td>
<td>
<p>Sets the style of the line joins, for example <kbd>‘round'</kbd>, <kbd>‘bevel'</kbd>, or <kbd>‘miter'</kbd> (default).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>font</kbd></p>
</td>
<td>
<p>Sets the font to be used in the <kbd>strokeText()</kbd> or <kbd>fillText()</kbd> commands.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>globalAlpha</kbd></p>
</td>
<td>
<p>Sets the global opacity (<kbd>0</kbd> = transparent, <kbd>1</kbd> = opaque) for the context.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>shadowBlur, shadowColor,</kbd><br/>
<kbd>shadowOffsetX, shadowOffsetY</kbd></p>
</td>
<td>
<p>Sets shadow properties. The default color is transparent black. The default numeric values are zero.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>fillRect(x,y,w,h)</kbd></p>
</td>
<td>
<p>Fills a rectangle.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>strokeRect(x,y,w,h)</kbd></p>
</td>
<td>
<p>Draws a border around a rectangle.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>setLineDash(dasharray)</kbd></p>
</td>
<td>
<p>Receives an array for the dash, alternating lines and spaces.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>fillText(text,x,y);</kbd></p>
</td>
<td>
<p>Fills text at the x and y positions (y is the baseline).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>strokeText(text,</kbd> x, y);</p>
</td>
<td>
<p>Draws a border around text at the x and y positions.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>createLinearGradient(x0, y0, x1, y1)</kbd></p>
</td>
<td>
<p>Creates a linear gradient perpendicular to the line. Radial gradients and patterns are also supported.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>drawImage(image, x, y, w, h)</kbd></p>
</td>
<td>
<p>Draws an image.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beginPath()</kbd></p>
</td>
<td>
<p>Starts a path.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>moveTo(x, y)</kbd></p>
</td>
<td>
<p>Moves the cursor to a position in the path.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>lineTo(x, y)</kbd></p>
</td>
<td>
<p>Moves the cursor to a position in the path, drawing a line along the way.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>bezierCurveTo(c1x, c1y, c2x, c2y, x, y), quadraticCurveTo(cx, cy, x, y)</kbd></p>
</td>
<td>
<p>Draws curves with one (<em>quadratic</em>) or two (<em>Bezier</em>) control points in a path.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>arc(x, y, r, sa, ea)</kbd></p>
</td>
<td>
<p>Draws an arc by specifying the center, radius, start, and end angles in a path.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>arcTo(sx, sy, r, ex, ey)</kbd></p>
</td>
<td>
<p>Draws an arc by specifying the coordinates of the starting point, the radius, and the coordinates of the end point.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>rect(x, y, w, h)</kbd></p>
</td>
<td>
<p>Draws a rectangle in a path with the coordinates of the top-left corner, width, and height.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>clip()</kbd></p>
</td>
<td>
<p>Creates a clipping region with the shapes drawn by the path that will affect objects that are drawn afterwards.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>fill()</kbd></p>
</td>
<td>
<p>Fills a path with the current color.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>stroke()</kbd></p>
</td>
<td>
<p>Strokes the path with the current color.</p>
</td>
</tr>
</tbody>
</table>
<p>Selected HTML Canvas commands</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Data formats</h1>
                
            
            
                
<p>Data used in visualizations is usually distributed in a standard format that can be shared. Even when the data is served from a database, the data is usually delivered in some standard format. Popular proprietary formats, such as Excel spreadsheets, are common, but most statistical data is stored or delivered in CSV, XML, or JSON formats.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">CSV</h1>
                
            
            
                
<p>CSV stands for comma-separated values. It's a very popular data format for public data. A CSV file is a text file that emulates a table. It usually contains one header row with the names of the columns, and one or more data rows containing value fields. Rows are separated by line breaks, and the comma-separated fields in each row form columns. It maps perfectly to an HTML table. This is a simple CSV file containing the population and land area of seven continents (<kbd>Data/sample.csv</kbd>):</p>
<pre> continent,population,areakm2<br/> "North America",579024000,24490000<br/> "Asia",4436224000,43820000<br/> "Europe",738849000,10180000<br/> "Africa",1216130000,30370000<br/> "South America",422535000,17840000<br/> "Oceania",39901000,9008500<br/> "Antarctica",1106,13720000</pre>
<p>There are no types in CVS. Quotes are used to contain text that might contain the delimiter. They are not necessary if the fields don't contain a comma.</p>
<p>CSV is also used to refer to similar files that don't use a comma as a delimiter. These files are more accurately called <strong>delimiter-separated value </strong>(<strong>DSV</strong>) files. The most common delimiters are tabs (TSV), vertical bars (|), and semicolons.</p>
<p>CSVs may become corrupt and unreadable, but it's text and you can fix it. Missing or unescaped commas are the most common problems.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">XML</h1>
                
            
            
                
<p><strong>eXtensible Markup Language</strong> (<strong>XML</strong>) is a very popular data format. Ajax responses from Web services are usually returned as text or XML. It has standard native support in JavaScript via the DOM APIs and doesn't require additional parsing. Although it is still common to find data in XML format, CSV and JSON alternatives, if available, are usually smaller and easier to work with.</p>
<p>This is an example of an XML file with the same data as the CSV file shown earlier (<kbd>Data/sample.xml</kbd>):</p>
<pre>&lt;continents&gt;<br/>     &lt;continent&gt;<br/>         &lt;name&gt;North America&lt;/name&gt;<br/>         &lt;population&gt;579024000&lt;/population&gt;<br/>         &lt;area unit="km"&gt;24490000&lt;/area&gt;<br/>     &lt;/continent&gt;<br/>     &lt;continent&gt;<br/>         &lt;name&gt;Asia&lt;/name&gt;<br/>         &lt;population&gt;4436224000&lt;/population&gt;<br/>         &lt;area unit="km"&gt;43820000&lt;/area&gt;<br/>     &lt;/continent&gt;<br/> ...<br/>     &lt;continent&gt;<br/>         &lt;name&gt;Antarctica&lt;/name&gt;<br/>         &lt;population&gt;1106&lt;/population&gt;<br/>         &lt;area&gt;13720000&lt;/area&gt;<br/>     &lt;/continent&gt;<br/> &lt;/continents&gt;</pre>
<p>XML files can be validated if an XML Schema is available. You can extract data from a well-formed XML file with DOM or with XPath (which is easier). There are many tools in all languages to manipulate XML. XML is also very easy to generate. Its main disadvantage is verbosity and size.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">JSON</h1>
                
            
            
                
<p>JSON stands for JavaScript Object Notation. It looks a lot like a JavaScript object, but it has stricter formation rules. It's probably the easiest format to work with. It's compact and easy to parse, and it's gradually replacing XML as a preferred data format in Web services.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following data file containing continent data is shown in JSON format (<kbd>Data/sample.json</kbd>):</p>
<pre>[<br/>     {<br/>         "continent": "North America",<br/>         "population": 579024000,<br/>         "areakm2": 24490000<br/>     },{<br/>         "continent": "Asia",<br/>         "population": 4436224000,<br/>         "areakm2": 43820000<br/>     },{<br/>         "continent": "Europe",<br/>         "population": 738849000,<br/>         "areakm2": 10180000<br/>     },{<br/>         "continent": "Africa",<br/>         "population": 1216130000,<br/>         "areakm2": 30370000<br/>     },{<br/>         "continent": "South America",<br/>         "population": 422535000,<br/>         "areakm2": 17840000<br/>     },{<br/>         "continent": "Oceania",<br/>         "population": 39901000,<br/>         "areakm2": 9008500<br/>     },{<br/>         "continent": "Antarctica",<br/>         "population": 1106,<br/>         "areakm2": 13720000<br/>     }<br/> ]</pre>
<p>JSON is the preferred format for data manipulation in JavaScript. There are many online tools you can use to transform CSV and XML files into JSON.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Loading and parsing external data files  </h1>
                
            
            
                
<p>Unless you have a very small or static dataset, it will usually not be embedded in your web page. You will probably use an asynchronous request to load it from a separate file after your HTML page is already loaded and then parse it. This section covers topics related to loading and parsing external files.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Using a Web server</h1>
                
            
            
                
<p>Most of the examples in this book consist of a single file (not considering the external libraries loaded using the <kbd>&lt;script&gt;</kbd> tags), and you can run them by simply opening them in a browser. You don't even need a Web server. Just click on the file and view it in your browser. But this won't work in examples that load external files via Ajax. For those files, you do need a Web server.</p>
<p>If you are using an HTML editor, such as PHPStorm or Brackets, it automatically starts a Web server for you and serves the page to your default browser. If you have Python installed in your system (it is native in macOS and Linux, and you can install it in Windows), you can run a simple server from the directory where your files are installed. The syntax depends on which Python version you have installed. You can check by opening a console and typing:</p>
<pre><strong>python -v</strong></pre>
<p>Now move to the directory where your HTML files are stored and run one of the following commands. If you have Python 3.x , run:</p>
<pre><strong>python3 -m http.server</strong></pre>
<p>If your version is 2.x, run:</p>
<pre><strong>python -m SimpleHTTPServer</strong></pre>
<p>Now you can open your files using <kbd>http://localhost:8080/your-file-name.html</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Loading files using standard JavaScript</h1>
                
            
            
                
<p>The standard way to load data into a Web page is using asynchronous JavaScript and XML, or Ajax. It uses the standard built-in <kbd>XMLHttpRequest</kbd> object, supported by all modern browsers.</p>
<p>To load a file using <kbd>XMLHttpRequest</kbd>, you need to create the <kbd>XMLHttpRequest</kbd> object, choose an HTTP method, use the object to open an HTTP connection to the file's URL, and send the request. You must also create a callback function that listens to the object's <kbd>'readystatechange'</kbd> event and test the object's <kbd>readystate</kbd> property.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When this property contains <kbd>XMLHttpRequest.DONE</kbd>, the request is done and you can extract the data. But it's not finished yet! If the request finished successfully (the object <em>status</em> property equals 200), you need to extract the data from the object. In a CSV file, the data will be in the <kbd>responseText</kbd> property (it's in a different place if it's XML). Only then can you finally parse its contents and create your data array. This is shown in the following code (<kbd>Examples/example-9-ajax.html</kbd>):</p>
<pre> const httpRequest = new XMLHttpRequest();<br/> httpRequest.open('GET', 'Data/sample.csv');<br/> httpRequest.send();<br/>  <br/>    httpRequest.onreadystatechange = function(){<br/>       if (httpRequest.readyState === XMLHttpRequest.DONE) {<br/>           if (httpRequest.status === 200) {<br/>               const text = httpRequest.responseText;<br/>               parse(text);<br/>           }<br/>       }<br/>    }<br/>function parse(text) {<br/>     // parse the CSV text and transform it into a JavaScript object<br/> }</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Loading files using JQuery</h1>
                
            
            
                
<p>You never have to use standard JavaScript to load files, but it's good to know how it works. It's much, much simpler to load files using the <em>JQuery</em> library (<kbd>Examples/example-10-ajax-jquery.html</kbd>):</p>
<pre>$.ajax({<br/>     url: 'Data/sample.csv',<br/>     success: function(text){<br/>         parse(text)<br/>     }<br/> });</pre>
<p>You can also load and parse JSON files in a single step using <em>JQuery</em>:</p>
<pre>$.getJSON('/Data/sample.json', function(object) {<br/>     // use the JavaScript object<br/> }</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Loading files using the standard Fetch API</h1>
                
            
            
                
<p>In all modern browsers, you can also load external files using the Fetch API. It's the new JavaScript standard for loading files asynchronously, and we will be using it in all examples that load external files in this book, but it may not work in some older browsers. In that case, you should revert to standard JavaScript or JQuery.</p>
<p>The <kbd>fetch()</kbd> command is a reactive method based on JavaScript promises. A basic fetch request is shown as follows (<kbd>Examples/example-12-fetch.html</kbd>):</p>
<pre>fetch('Data/sample.csv')<br/>  .then(response =&gt; response.text())<br/>  .then(function(text) {<br/>      parse(text);<br/>  });</pre>
<p>You can also parse JSON files using <kbd>fetch()</kbd>:</p>
<pre>fetch('Data/sample.json')<br/>   .then(response =&gt; response.json())<br/>   .then(function(object) {<br/>       // use the JavaScript object<br/>   });</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Parsing JSON</h1>
                
            
            
                
<p>Although JSON is based on JavaScript, a JSON file is not a JavaScript object. It's a string. To convert it into an object and access its properties with the dot operator, you can use <kbd>JSON.parse()</kbd>:</p>
<pre>const obj = JSON.parse(jsonString);</pre>
<p>Sometimes you need to convert a JavaScript object back into JSON format. You might also do this for debugging. You can do this with <kbd>JSON.stringify()</kbd>:</p>
<pre>const jsonString = JSON.stringify(obj);</pre>
<p>If you parsed the example JSON file at the beginning of this section, the JavaScript object will actually be an array of objects, and you can list its contents (in the JavaScript console) using the following code (<kbd>Examples/example-14.html</kbd>):</p>
<pre>obj.forEach(function(item) {<br/>     console.log(item.continent, +item.population, +item.areakm2);<br/> });</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Parsing CSV</h1>
                
            
            
                
<p>There is no native CSV parser in JavaScript, but if you have a very small and simple CSV file, you can parse it using JavaScript string manipulation tools or regular expressions, splitting by newlines (<kbd>\n</kbd>) to select each row, and then splitting by the delimiter to select each data cell within each row.</p>
<p>Larger data files are more complex, since the preceding code depends on a specific format and does not deal with commas inside quoted strings, missing data, and so on. In this case, you should use a CSV parser. Most examples in this book use the PapaParse CSV parser (<a href="http://papaparse.com" target="_blank">papaparse.com</a>) by Matt Holt, which is open source and free. The following code shows how to convert CSV into a JavaScript object using PapaParse:</p>
<pre>const csvData = Papa.parse(csvText, {header: true}).data;</pre>
<p>If you parsed the example CSV file at the beginning of this section, you will receive an array of objects, and you can list the contents (in the JavaScript console) using the following code (<kbd>Examples/example-15.html</kbd>):</p>
<pre>csvData.forEach(function(item) {<br/>     console.log(item.continent, +item.population, +item.areakm2);<br/> });</pre>
<p>The + before the last two properties converts them into numbers. If you don't do that they will be loaded as strings, even though they are numbers.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Loading multiple files</h1>
                
            
            
                
<p>Sometimes you need files from different sources that need to be loaded and then manipulated within a page. You load these using <kbd>Promise.all()</kbd>, as shown next. The code in the promise will only be executed when all the files are loaded (<kbd>Examples/example-16.html</kbd>):</p>
<pre> const files = ['/path/to/file.json', '/path/to/file.csv'];<br/> var promises = files.map(file =&gt; fetch(file).then(resp =&gt; resp.text()));<br/> Promise.all(promises).then(results =&gt; {<br/>     const jsonData = JSON.parse(results[0]);<br/>     const csvData = Papa.parse(results[1], {header: true}).data;<br/>     // use the two data objects<br/> });</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Displaying a map</h1>
                
            
            
                
<p>Without any charting library, using just standard JavaScript, you can load a JSON file and draw a world map using Canvas. The data is a special JSON format that stores geographical shapes: GeoJSON. Its general structure is as follows:</p>
<pre>{"type":"FeatureCollection",<br/>  "features":[<br/>     {"type":"Feature",id":"AFG","properties":{"name":"Afghanistan"},<br/>      "geometry":{"type":"Polygon","coordinates":[[[61.210817,35.650072],...]]<br/>     },{"type":"Feature", "id":"AGO", "properties":{"name":"Angola"},<br/>      "geometry":{"type":"MultiPolygon","coordinates":[[[[16.326528,-5.87747,...]]<br/>     },<br/>     // many other lines<br/>   ]<br/> }</pre>
<p>Using JavaScript, you can load this file, parse it, and access each longitude and latitude pair. Then you can scale the values so that they fit into the coordinate system of your Canvas, and draw each shape using Canvas path commands. This is done in the following code (<kbd>Examples/example-17.html</kbd>):</p>
<pre>&lt;canvas id="map" width="1000" height="500"&gt;&lt;/canvas&gt;<br/>&lt;script&gt;<br/>     var canvas = document.getElementById("map");<br/>     var ctx = canvas.getContext("2d");<br/> <br/>     // Map ocean background<br/>     ctx.fillStyle = 'white';<br/>     ctx.fillRect(0, 0, canvas.width, canvas.height);<br/> <br/>     // countries border and background<br/>     ctx.lineWidth = .25;<br/>     ctx.strokeStyle = 'white';<br/>     ctx.fillStyle = 'rgb(50,100,150)';<br/> <br/>     // load and draw map<br/>     fetch('Data/world.geojson')<br/>     .then(response =&gt; response.text())<br/>     .then((jsonData) =&gt; {<br/>         let object = JSON.parse(jsonData);<br/>         drawMap(object.features);<br/>     });<br/>     function scaleX(coord) {<br/>         return canvas.width * (180 + coord) / 360;<br/>     }<br/>     function scaleY(coord) {<br/>         return canvas.height * (90 - coord) / 180;<br/>     }<br/>     function drawPolygon(coords) {<br/>         ctx.beginPath();<br/>         for(let i = 0; i &lt; coords.length; i++ ) {<br/>             let latitude = coords[i][1];<br/>             let longitude = coords[i][0];<br/>             if(i == 0) {<br/>                 ctx.moveTo(scaleX(longitude), scaleY(latitude));<br/>             } else {<br/>                 ctx.lineTo(scaleX(longitude), scaleY(latitude));<br/>             }<br/>         }<br/>         ctx.stroke();<br/>         ctx.fill();<br/>     }<br/>     function drawMap(data) {<br/>         data.forEach(obj =&gt; {<br/>             if(obj.geometry.type == 'MultiPolygon') {<br/>                 obj.geometry.coordinates.forEach(poly =&gt; drawPolygon(poly[0]));<br/>             } else if(obj.geometry.type == 'Polygon') {<br/>                 obj.geometry.coordinates.forEach(poly =&gt; drawPolygon(poly));<br/>             }<br/>         });<br/>     }<br/> &lt;/script&gt;</pre>
<p>The result is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a15b5ae7-16a4-44ac-a0bb-31508fd50cc3.png" style="width:32.75em;height:15.67em;" width="1001" height="479"/></p>
<p>A world map created using GeoJSON, JavaScript, and Canvas code</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Extracting and transforming data</h1>
                
            
            
                
<p>If you are lucky enough to find your data in CSV, XML, or JSON, you can load it and start using it right away. But what if your data is only available as HTML tables, or worse, as a PDF file? In these cases, you need to extract your data and transform it into a usable format.</p>
<p>If it's a very simple HTML table, sometimes you can select it and copy and paste it into a spreadsheet and preserve the rows and columns. Then you can export it as a CSV. Sometimes you will need to do extra work, perhaps removing garbage characters, styles, and unnecessary columns. This is risky, since you may also lose data or introduce errors during the process.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Online tools</h1>
                
            
            
                
<p>You can also use online tools that try to convert HTML tables into XML, CSV, and JSON. Let's try an example. The NASA JPL site has a Web page containing data about the moon and the planets in our solar system (<a href="http://nssdc.gsfc.nasa.gov/planetary/factsheet" target="_blank">nssdc.gsfc.nasa.gov/planetary/factsheet</a>). To use that data, you will need to have it in a standard format such as JSON, CSV, or XML, but it's only available as an HTML table, shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/117a42aa-2a25-49c4-a2e5-adf0c11e2f03.png" style="width:38.92em;height:26.00em;" width="997" height="666"/></p>
<p>An HTML table containing data that can be used in a chart</p>
<p>Let's first try an online conversion service. Searching for HTML-to-CSV conversion, I found an online conversion service at at <kbd>www.convertcsv.com</kbd> with several CSV conversion tools. Open the HTML Table to CSV link and either paste the source code in the input box, or provide its URL. There are some options you can configure, such as choosing the delimiter. Click on the Convert HTML to CSV button, and the following text will appear in the output box:</p>
<pre>,MERCURY,VENUS,EARTH,MOON,MARS,JUPITER,SATURN,URANUS,NEPTUNE,PLUTO<br/> Mass (1024kg),0.330,4.87,5.97,0.073,0.642,1898,568,86.8,102,0.0146<br/> Diameter (km),4879,"12,104","12,756",3475,6792,"142,984","120,536",...,2370<br/> Density (kg/m3),5427,5243,5514,3340,3933,1326,687,1271,1638,2095<br/> Gravity (m/s2),3.7,8.9,9.8,1.6,3.7,23.1,9.0,8.7,11.0,0.7<br/> ... several rows not shown ...<br/> Number of Moons,0,0,1,0,2,79,62,27,14,5<br/> Ring System?,No,No,No,No,No,Yes,Yes,Yes,Yes,No<br/> Global Magnetic Field?,Yes,No,Yes,No,No,Yes,Yes,Yes,Yes,Unknown<br/> ,MERCURY,VENUS,EARTH,MOON,MARS,JUPITER,SATURN,URANUS,NEPTUNE,PLUTO</pre>
<p>This is valid CSV, but some fields were interpreted as strings, not numbers (some diameters, for example). You might also wish to remove some unnecessary rows, such as the last one, or data you don't need. You can edit the file later and write a script to fix the numbers using regular expressions. Download the result and save it in a file, and then try loading the file using JavaScript.</p>
<p>Since this is a third-party online service, I can't guarantee it will still exist when you read this book, but you should find similar services that perform the same conversion. If not, you can always write an extraction script yourself. A good tool for that is <em>XPath</em>, supported by many extraction libraries and browsers, described in the next section.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Extracting data with XPath</h1>
                
            
            
                
<p>Since HTML is a structure document, you can use a computer program to navigate that structure and extract selected text nodes, attributes, and elements. Most Web extraction tools are based on XPath: an XML standard that can be used to navigate in a XML structure and select elements, attributes, and text nodes using path notation. Although HTML is not as strict as XML, it has similar structures that can be represented as XPath paths and is supported by many Web scraping tools.</p>
<p>For example, the first lines of the previous web page have the following structure:</p>
<pre>&lt;html&gt;<br/>   &lt;head&gt;<br/>     &lt;title&gt;Planetary Fact Sheet&lt;/title&gt;<br/>   &lt;/head&gt;<br/>   &lt;body bgcolor=FFFFFF&gt;<br/>     &lt;p&gt;<br/>     &lt;hr&gt;<br/>     &lt;H1&gt;Planetary Fact Sheet - Metric&lt;/H1&gt;<br/>     &lt;hr&gt;<br/>     &lt;p&gt;<br/>     &lt;table&gt; ...</pre>
<p>It's not XML or XHTML, since attributes are not within quotes and tags don't close, but you can still use XPath to extract data from it. This path will give you the title:</p>
<pre>/html/head/title/text()</pre>
<p>Any one of these one will return the <kbd>bgcolor</kbd> attribute (its name and value) from the body tag:</p>
<pre>/html/body/@bgcolor<br/>/html/body/attribute::bgcolor</pre>
<p>This one will return the contents of the <kbd>&lt;H1&gt;</kbd> header:</p>
<pre>/html/head/h1/text()</pre>
<p>This one is tricky. If this was XML, it would be <kbd>/html/head/p/hr/H1</kbd>, because all XML tags must close, but HTML parsers automatically close the <kbd>&lt;p&gt;</kbd> and <kbd>&lt;hr&gt;</kbd> tags because there can't be an <kbd>&lt;h1&gt;</kbd> header inside them. HTML is also case insensitive, so using <kbd>H1</kbd> or <kbd>h1</kbd> doesn't make any difference with these parsers. Still, this may still confuse some parsers. You can play it safe by using:</p>
<pre>/html/head//H1/text()</pre>
<p>The <kbd>//</kbd> or double slash means that between <kbd>&lt;head&gt;</kbd> and <kbd>&lt;H1&gt;</kbd> there can be any number of levels. This is compatible with the XML or HTML absolute path.</p>
<p>You can experiment with XPath using your browser's JavaScript console, writing XPath expressions inside <kbd>$x(expression)</kbd>. Let's try it out using the <em>Planetary Fact Sheet</em> page. Open the page in your browser and then open a console window, and type the following:</p>
<pre>$x("//table")</pre>
<p>This will select all the tables in the document. In this case, there is only one. You can also view the source code or inspect the page to discover the absolute path:</p>
<pre>$x("/html/body/p/table")</pre>
<p>Enter this command and the console will reveal the HTML fragment corresponding to your selection. Now let's select the row that contains diameters. It's the third row in the table. You can ignore the existing <kbd>&lt;thead&gt;</kbd> or <kbd>&lt;tbody&gt;</kbd> tags using the <kbd>//</kbd>. XPath counts child nodes starting with 1, not 0 as in JavaScript. The command returns a single <kbd>&lt;tr&gt;</kbd> element in an array. We can extract it using <kbd>[0]</kbd>:</p>
<pre>$x("//table//tr[3]")[0]</pre>
<p>This will select the following fragment:</p>
<pre>&lt;tr&gt;<br/>   &lt;td align="left"&gt;&lt;b&gt;&lt;a href="planetfact_notes.html#diam"&gt;Diameter&lt;/a&gt; <br/>(km)&lt;/b&gt;&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="F5F5F5"&gt;4879&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="FFFFFF"&gt;12,104&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="F5F5F5"&gt;12,756&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="FFFFFF"&gt;3475&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="F5F5F5"&gt;6792&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="FFFFFF"&gt;142,984&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="F5F5F5"&gt;120,536&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="FFFFFF"&gt;51,118&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="F5F5F5"&gt;49,528&lt;/td&gt;<br/>   &lt;td align="center" bgcolor="FFFFFF"&gt;2370&lt;/td&gt;<br/> &lt;/tr&gt;</pre>
<p>To select the diameter of the earth, you need to add one more path step:</p>
<pre>$x("//table//tr[3]/td[4]")[0]</pre>
<p>The result is as follows:</p>
<pre>&lt;td align="center" bgcolor="F5F5F5"&gt;12,756&lt;/td&gt;</pre>
<p>To extract the text, you need to include the <kbd>text()</kbd> function at the end of the XPath expression. You also need to extract the data from the <kbd>$x()</kbd> function result, using the <kbd>data</kbd> property:</p>
<pre>const result = $x("/html/body/p/table/tbody/tr[3]/td[4]/text()")[0].data</pre>
<p>This will return the result as a string. You can then use regular expressions to remove the comma and then convert the result to a number:</p>
<pre>const value = +data.replace(/\,/g,''); <br/>// removes commas and converts to number</pre>
<p>You might want to automate that with a programming library if you need to extract lots of data, such as all the planetary diameters. The <kbd>$x()</kbd> command only works in the browser console, but many programming languages support XPath libraries and APIs. You can also use tools such as Scrapy (in Python) or testing tools such as Selenium (in several languages) that support XPath selectors for extracting data from HTML.</p>
<p>XPath is a very powerful data extraction language, and this was only a very brief introduction. But there are also alternatives, such as XQuery (another XML standard with a query syntax) and CSS selectors (used by <em>JQuery</em> and also supported by Scrapy and Selenium).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter provided a refresher on several fundamental technology concepts that will help you create visualizations with Chart.js. Even though Chart.js tries to hide all the underlying complexity from you, it is still a JavaScript library and basic knowledge of JavaScript, DOM, and CSS are important.</p>
<p>This chapter also described the main data formats used for statistical data: CSV, XML, and JSON. It also described how to load external files in these formats and how to parse them. Additionally, you learned some ways to obtain data not in these formats by extracting it from HTML pages.</p>
<p>In the next chapter, we will begin using Chart.js to create data visualizations.</p>


            

            
        
    </div>



  </body></html>