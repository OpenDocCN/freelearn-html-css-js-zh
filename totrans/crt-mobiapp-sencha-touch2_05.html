<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;On Deck: Using Sencha.io"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. On Deck: Using Sencha.io</h1></div></div></div><p>In our previous chapters we have typically used local storage for maintaining our data. This offers a number of advantages with its ease of use and simplicity. The store and the model do all of the heavy lifting for us.</p><p>However, there are a number of disadvantages to local storage as well. First and foremost, it is very much local to the device. This means that if your user has more than one device (a phone, desktop, and a tablet computer), then they will have a separate set of data for each device.</p><p>This can be confusing to the user and it negates the advantage of having a single application that is accessible from multiple devices. Additionally, the data can be deleted by the user when they clear the local browser data. This can make local storage a bit problematic for a robust application.</p><p>In this chapter we are going to look at solving this issue with an external API called Sench.io. Here's what we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the basic application</li><li class="listitem" style="list-style-type: disc">Getting started with Sencha.io</li><li class="listitem" style="list-style-type: disc">Updating the basic application to work with Sencha.io</li></ul></div><div class="section" title="The basic application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>The basic application</h1></div></div></div><p>Our basic application<a id="id514" class="indexterm"/> is designed to present a set of flash cards to the user in a random order. Each set of flash cards comprises a deck. The user can add new decks and new cards to each deck. The decks and the cards will reside in a remote storage service called <a id="id515" class="indexterm"/>
<span class="strong"><strong>Sencha.io</strong></span>. Using this service, the user will also be able to log in from any number of devices and access their cards and decks.</p><div class="mediaobject"><img src="graphics/8901OS_05_01.jpg" alt="The basic application"/></div><p>We will start off our application with the models and stores.</p><div class="section" title="Creating the models and stores"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec55"/>Creating the models and stores</h2></div></div></div><p>The model <a id="id516" class="indexterm"/>for our deck is very simple and only needs two pieces of information. We will use an ID to link cards to a specific deck and a name for display purposes:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.model.Deck', {
    extend: 'Ext.data.Model',
    config: {
        fields: [
            {
                name: 'id'
            },
            {
                name: 'name'
            }
        ]
    }
}); </pre></div><p>The card model<a id="id517" class="indexterm"/> needs an ID of its own so that we can uniquely identify it and a <code class="literal">deckID</code> value so that we know <a id="id518" class="indexterm"/>which deck it's a part of. We will also need the question and answer for each card:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.model.Card', {
    extend: 'Ext.data.Model',
    config: {
        fields: [
            {
                name: 'id'
            },
            {
                name: 'deckID'
            },
            {
                name: 'question'
            },
            {
                name: 'answer'
            }
        ]
    }
});</pre></div><p>For the two stores, we will <a id="id519" class="indexterm"/>initially use a local storage <code class="literal">proxy</code> as we have in previous chapters. This will let us test our application before we start using the Sencha.io service.</p><p>Our deck store looks like this:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.store.DeckStore', {
    extend: 'Ext.data.Store',
    requires: [
        'MyApp.model.Deck'
    ],
    config: {
        autoLoad: true,
        model: 'MyApp.model.Deck',
        storeId: 'DeckStore',
        proxy: {
            type: 'localstorage',
            id: 'Decks'
        },
        fields: [
            {
                name: 'id',
                type: 'int'
            },
            {
                name: 'name',
                type: 'string'
            }
        ]
    }
});</pre></div><p>If you have <a id="id520" class="indexterm"/>worked your way through the first chapter, this basic setup should look pretty familiar to you. We extend the basic store, require our <code class="literal">model</code> file, and then set up our configuration. The configuration sets the store to load when it is created, tells it which model to use, sets up our local storage <code class="literal">proxy</code>, and tells it which <code class="literal">fields</code> to expect.</p><p>Our card store is almost an exact duplicate:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.store.CardStore', {
    extend: 'Ext.data.Store',
    requires: [
        'MyApp.model.Card'
    ],
    config: {
        autoLoad: true,
        model: 'MyApp.model.Card',
        storeId: 'CardStore',
        proxy: {
            type: 'localstorage',
            id: 'Cards'
        },
        fields: [
            {
                name: 'id',
                type: 'int'
            },
            {
                name: 'deckID',
                type: 'int'
            },
            {
                name: 'question',
                type: 'string'
            },
            {
                name: 'question',
                type: 'string'
            }
        ]
    }
});</pre></div><p>Here we have just changed the name from <code class="literal">Deck</code> to <code class="literal">Card</code>, and specified our card fields in place of our deck fields.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>If you configure your store with a model, you don't actually have to specify the fields. We are doing so here just for the sake of completeness.</p></div></div><p>As mentioned before, we will be revisiting these stores once we get things set up with <code class="literal">Sencha.io</code>, but first we need to get our display together for our lists, cards, and editing.</p></div><div class="section" title="Creating the views"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec56"/>Creating the views</h2></div></div></div><p>For our main view, we will be <a id="id521" class="indexterm"/>using a tab panel with two containers, one for our decks and one for our cards. We will use sheets for editing and adding new decks and cards. Our initial <code class="literal">main.js</code> file looks like this:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.view.Main', {
    extend: 'Ext.tab.Panel',

    config: {
        id: 'mainView',
        items: [],
        tabBar: {
            docked: 'bottom'
        }
});</pre></div><p>Remember to add this file into your <code class="literal">app.js</code> file and set the launch function to create a copy of the component when the application starts (if you are using Sencha Architect, then this should happen automatically). Your <code class="literal">app.js</code> file should look like this:</p><div class="informalexample"><pre class="programlisting">Ext.Loader.setConfig({
    enabled: true
});

Ext.application({
    models: [
        'Deck',
        'Card'
    ],
    stores: [
        'DeckStore',
        'CardStore'
    ],
    views: [
        'Main'
    ],
    name: 'MyApp',

    launch: function() {

        Ext.create('MyApp.view.Main', {fullscreen: true});
    }

});</pre></div><p>Next we need <a id="id522" class="indexterm"/>to add the two containers to our <code class="literal">main.js</code> view. In the empty items section, add the following container:</p><div class="informalexample"><pre class="programlisting">{
    xtype: 'container',
    layout: {
        type: 'fit'
    },
    title: 'Decks',
    iconCls: 'info',
    items: [
        {
            xtype: 'list',
            itemTpl: [
                '&lt;div&gt;{name}&lt;/div&gt;'
            ],
            store: 'DeckStore'
        },
        {
            xtype: 'titlebar',
            docked: 'top',
            title: 'Decks',
            items: [
                {
                    xtype: 'button',
                    itemId: 'mybutton',
                    text: 'Add',
                    align: 'right'
                }
            ]
        }
    ]
}</pre></div><p>This will be the list for our decks. The overall container has a <code class="literal">fit</code> layout so the items will fill the entire width and height of the container. We have given the container a title and an <code class="literal">iconCls</code> value, which will be used to label the tab in our <code class="literal">Main</code> tab panel.</p><p>The container has a <code class="literal">list</code> view that uses our <code class="literal">DeckStore</code> store and a simple <code class="literal">itemTpl</code> template that displays the name of each deck in a separate <code class="literal">div</code> tag.</p><p>We have also <a id="id523" class="indexterm"/>added a title bar where we can display a button for adding new decks and a title to let the user know what they are looking at.</p><p>Our second container follows the same pattern as our first, but instead of a list, we have a separate container with a <code class="literal">carousel</code> layout, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">{
    xtype: 'container',
    title: 'Cards',
    iconCls: 'info',
    items: [
        {
            xtype: 'titlebar',
            docked: 'top',
            items: [
                {
                    xtype: 'button',
                    itemId: 'mybutton1',
                    text: 'Add',
                    align: 'right'
                },
                {
                    xtype: 'button',
                    text: 'Shuffle'
                }
            ]
        },
        {
            xtype: 'carousel'
        }
    ]
}</pre></div><p>This container has a <code class="literal">titlebar</code> control that will be set to display the name of the current deck at the top and pull the cards into our <code class="literal">carousel</code> layout. We also have a second button that will shuffle the current deck of cards.</p><p>Next we need to set up the two sheets for adding cards and decks. The deck sheet is a simple sheet with a <code class="literal">textfield</code> element for naming the deck, a <code class="literal">button</code> element for saving, and<a id="id524" class="indexterm"/> another <code class="literal">button</code> element for canceling:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.view.addDeckSheet', {
    extend: 'Ext.Sheet',
    alias: 'widget.addDeckSheet',

    config: {
        id: 'addDeckSheet',
        items: [
            {
                xtype: 'textfield',
                margin: '0 0 10 0',
                label: 'Name'
            },
            {
                xtype: 'button',
                ui: 'confirm',
                text: 'Save',
                itemID: 'saveDeckButton'
            },
            {
                xtype: 'button',
                itemId: 'cancelDeckButton',
                ui: 'decline',
                text: 'Cancel'
            }
        ],
        listeners: [
            {
                fn: 'hideDeckSheet',
                event: 'tap',
                delegate: '#cancelDeckButton'
            }
        ]
    },

    hideDeckSheet: function(button, e, options) {
        button.up('sheet').hide();
    }

});</pre></div><p>We also add a listener for the <code class="literal">Cancel</code> button that will hide the sheet without saving the values. The listener delegates the <code class="literal">tap</code> event to our <code class="literal">cancelDeckButton</code> delegate and calls the <code class="literal">hideDeckSheet</code> function when the <code class="literal">tap</code> event occurs.</p><p>The <code class="literal">hideDeckSheet</code> function<a id="id525" class="indexterm"/> receives the <code class="literal">button</code> element as part of its arguments. We can then travel up the DOM structure from the <a id="id526" class="indexterm"/>button, find the sheet, and hide it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>
<span class="strong"><strong>A note about using up and down</strong></span>
</p><p>The <code class="literal">up</code> and <code class="literal">down</code> functions in Sencha Touch are extremely useful when you have a component and you need to get to either a sub component or a parent component. However, it should be noted that both <code class="literal">up</code> and <code class="literal">down</code> only return the first component that matches. For example, if a <code class="literal">button</code> element is inside of a<a id="id527" class="indexterm"/> <code class="literal">container</code> element, which is itself inside another <code class="literal">container</code> element, then <code class="literal">button.up('container')</code> would return the first container and not the second, outer container.</p></div></div><p>Our card sheet is a duplicate of the deck sheet, but with text fields for <code class="literal">question</code> and <code class="literal">answer</code>:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.view.addCardSheet', {
    extend: 'Ext.Sheet', 
    config: {
        id: 'addCardSheet',
        items: [
            {
                xtype: 'container',
                html: 'Deck Name Here',
                style: 'color: #FFFFFF; text-align:center;'
            },
            {
                xtype: 'textareafield',
                id: 'cardQuestion',
                margin: '0 0 10 0',
                label: 'Question'
            },
            {
                xtype: 'textareafield',
                id: 'cardAnswer',
                margin: '0 0 10 0',
                label: 'Answer'
            },
            {
                xtype: 'button',
                ui: 'confirm',
                itemId: 'saveCardButton',
                text: 'Save'
            },
            {
                xtype: 'button',
                itemId: 'cancelCardButton',
                ui: 'decline',
                text: 'Cancel'
            }

        ],
        listeners: [
            {
                fn: 'hideCardSheet',
                event: 'tap',
                delegate: '#cancelCardButton'
            }
        ]
    },
    hideCardSheet: function(button, e, options) {
        button.up('sheet').hide();
    }
});</pre></div><p>As before, we have our<a id="id528" class="indexterm"/> <span class="strong"><strong>Save</strong></span> and <span class="strong"><strong>Cancel</strong></span> buttons, with the <span class="strong"><strong>Cancel</strong></span> button hiding the sheet when tapped.</p><p>You should now be able to start the application and test the different views as shown:</p><div class="mediaobject"><img src="graphics/8901OS_05_02.jpg" alt="Creating the views"/></div><p>Before we can get<a id="id529" class="indexterm"/> things working further in the application, we need to get set up with Sencha.io.</p></div></div></div>
<div class="section" title="Getting started with Sencha.io"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Getting started with Sencha.io</h1></div></div></div><p>The <a id="id530" class="indexterm"/>Sencha.io service will allow us to store our data using Sencha's cloud service. We will need to register a new account, add our application and user groups using the Sencha.io dashboard, and then configure our application to use the service.</p><div class="section" title="The sign-up process"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec57"/>The sign-up process</h2></div></div></div><p>To register a <a id="id531" class="indexterm"/>
<a id="id532" class="indexterm"/>new account, go to <a class="ulink" href="https://manage.sencha.io">https://manage.sencha.io</a> and click on the <span class="strong"><strong>Register</strong></span> link at the bottom of the page. Fill out the forms with your information and submit. Once your account is created, log in to the Sencha.io dashboard at the same address you used for registration, and you will see something similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/8901OS_05_03.jpg" alt="The sign-up process"/></div></div><div class="section" title="Downloading and installing the Sencha.io SDK"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Downloading and installing the Sencha.io SDK</h2></div></div></div><p>Now that you have an <a id="id533" class="indexterm"/>account you can download and install the <a id="id534" class="indexterm"/>Sencha.io SDK. There is a download link in the first part of the <span class="strong"><strong>Getting Started</strong></span> page (which should be where you first start when you log in).</p><p>Download the SDK to your computer and unzip the file. Move it into your web directory (someplace where you can easily reference it from your application). Next we need to add these files to our application. You can begin by opening your main <code class="literal">app.html</code> file and adding the following lines in the <code class="literal">head</code> section of the file (with your other script includes):</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="lib/io/lib/socket.io.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="lib/io/sencha-io-debug.js"&gt;&lt;/script&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>In this example, we have copied all of the Sencha.io files into a folder called <code class="literal">io</code> in the <code class="literal">lib</code> directory of our application. If your path is different, you will need to adjust the lines above to fit your setup.</p></div></div><p>Now that we have included the two main files we need for Sencha.io, we also need to set some options in <code class="literal">app.js</code> so that the autoloader picks up these files as well. At the top of the <code class="literal">app.js</code> file, add the following code:</p><div class="informalexample"><pre class="programlisting">Ext.Loader.setPath({
    'Ext.io': 'lib/io/src/io',
    'Ext.cf': 'lib/io/src/cf'
});</pre></div><p>Once we have this <a id="id535" class="indexterm"/>information set, our application should be able to pick up all the <a id="id536" class="indexterm"/>files it needs to work with Sencha.io, but we still need to register our application before we can continue building.</p></div><div class="section" title="Registering your application and Auth group"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Registering your application and Auth group</h2></div></div></div><p>Registering your application<a id="id537" class="indexterm"/> and <a id="id538" class="indexterm"/>Auth group with Sencha.io provisions the application with its own data storage and an authorized user base. As with most API services, your application needs a way to uniquely identify itself to the remote system so that it will know where to store your data.</p><p>With Sencha.io, we will get two pieces of information when we register our application: an <code class="literal">appID</code> value and an <code class="literal">appSecret</code> value. These two pieces of information will be added to <code class="literal">app.js</code> to identify our application to the Sencha.io system.</p><p>Let's start by adding an Auth group. The Auth group sets up a group where users can register to use your application. If you have multiple applications, you can set up one Auth group for each application or set up a single Auth group to be shared across multiple applications.</p><p>From the <span class="strong"><strong>Dashboard</strong></span> section of your Sencha.io account (<a class="ulink" href="http://manage.sencha.io">http://manage.sencha.io</a>), click on the <span class="strong"><strong>Auth Groups</strong></span> link at the top of the page and choose <span class="strong"><strong>Create Auth Group</strong></span>.</p><div class="mediaobject"><img src="graphics/8901OS_05_04.jpg" alt="Registering your application and Auth group"/></div><p>Enter a name for your Auth group and click on <span class="strong"><strong>Save</strong></span>. The name is arbitrary, but if you are using the group for a single application, it's probably best to name it something like <code class="literal">myAppNameUsers</code> so that you can keep track of which application this is for.</p><p>The <a id="id539" class="indexterm"/>Auth group also controls how the users authenticate in your <a id="id540" class="indexterm"/>application. Once you have saved the Auth group, you can edit it and change the way users log in to your application.</p><div class="mediaobject"><img src="graphics/8901OS_05_05.jpg" alt="Registering your application and Auth group"/></div><p>You can choose to have users authenticate before the application fully downloads or afterwards. You can also choose to let users log in with a valid Facebook, Twitter, or Sencha.io account.</p><p>If you choose the <span class="strong"><strong>Sencha.io</strong></span> login option, then the SDK will automatically handle both user registration and authentication within your application, no extra coding required.</p><p>If you choose the <span class="strong"><strong>Facebook</strong></span> or <span class="strong"><strong>Twitter</strong></span> login option, Sencha.io will handle the authentication automatically. Users will have to be registered with either service before they can access the application.</p><div class="mediaobject"><img src="graphics/8901OS_05_06.jpg" alt="Registering your application and Auth group"/></div><p>Now that <a id="id541" class="indexterm"/>we have a set of users for the application, we need to <a id="id542" class="indexterm"/>register the application itself. From the Sencha.io dashboard, click on <span class="strong"><strong>Apps</strong></span> and then click on <span class="strong"><strong>Create App</strong></span>. As before, we only need to enter a name for the application. For this application we chose the name <span class="strong"><strong>OnDeck</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8901OS_05_07.jpg" alt="Registering your application and Auth group"/></div><p>Next we need<a id="id543" class="indexterm"/> to select our <span class="strong"><strong>Authentication Group</strong></span> name from the<a id="id544" class="indexterm"/> drop-down menu. This tells Sencha.io to authenticate and assign users from this group to our application. There is an optional <span class="strong"><strong>CNAME</strong></span> field for setting the domain your application will reside on, as well as a field for the path to the <code class="literal">index.html</code> file. This should be set if you are using the <code class="literal">app.html</code> file instead of <code class="literal">index.html</code>, or if you have your application hosted inside a sub directory on your server.</p><p>We can also set an application icon here. This is the icon that will be used if the user saves our web application to their home screen. Click on <span class="strong"><strong>Save</strong></span> when you are finished.</p><div class="mediaobject"><img src="graphics/8901OS_05_08.jpg" alt="Registering your application and Auth group"/></div><p>On the page <a id="id545" class="indexterm"/>application <a id="id546" class="indexterm"/>page, you should now see a listing for your application's ID (mentioned in the <span class="strong"><strong>ID</strong></span> field) and secret (mentioned in the <span class="strong"><strong>Secret</strong></span> field). Make note of these, as we will need to add them into <code class="literal">app.js</code> once we are finished with registration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Please note that the <span class="strong"><strong>ID</strong></span> and <span class="strong"><strong>Secret</strong></span> values in the preceding example screenshot are example data only. You will need to generate your own information on the Sencha.io site to make your application work. You will also need to generate your own ID and secret to make the example code from the chapter work.</p></div></div><p>Once you have completed this part of the registration, you will need to add the ID and secret values into your <code class="literal">app.js</code> file. Open the file and add the following code at the top of the <code class="literal">Ext.application({</code> section:</p><div class="informalexample"><pre class="programlisting">config: {
    io: {
    appId: 'YouAppIDHere',
    appSecret: 'YouAppSecretHere'
  }
}</pre></div><p>Substitute your information for the <code class="literal">appId</code> and <code class="literal">appSecret</code> placeholders shown. Once you have added the information into <code class="literal">app.js</code>, we can get back to updating our stores and creating our controller.</p></div></div>
<div class="section" title="Updating the application for Sencha.io"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Updating the application for Sencha.io</h1></div></div></div><p>Now that our <a id="id547" class="indexterm"/>application<a id="id548" class="indexterm"/> is registered, we need to set up the stores to use Sencha.io. We will also set up our controller for the application and show you how to override the <code class="literal">Carousel</code> component to make it work with a data store.</p><div class="section" title="Updating the stores"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Updating the stores</h2></div></div></div><p>Our original <a id="id549" class="indexterm"/>stores were simple local storage for testing. We are going to edit these now to use Sencha.io to store our data. Most of these changes will be in the <code class="literal">proxy</code> section. For example, the <code class="literal">DeckStore</code> code should be updated to look like this:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.store.DeckStore', {
    extend: 'Ext.data.Store',
    requires: [
        'MyApp.model.Deck'
    ],

    config: {
        autoLoad: true,
        model: 'MyApp.model.Deck',
        storeId: 'DeckStore',
<span class="strong"><strong>        proxy: {</strong></span>
<span class="strong"><strong>            type: 'syncstorage',</strong></span>
<span class="strong"><strong>            id: 'decks',</strong></span>
<span class="strong"><strong>            owner: 'user',</strong></span>
<span class="strong"><strong>            access: 'private'</strong></span>
<span class="strong"><strong>        },</strong></span>
<span class="strong"><strong>         autoLoad: true, </strong></span>
<span class="strong"><strong>        autoSync: false</strong></span>
    }
});</pre></div><p>Notice that we now use a new type of proxy called <code class="literal">syncstorage</code>. This is the special Sencha.io proxy that works much the same as a local store, but it stores the data remotely on the Sencha.io servers.</p><p>We also have new configurations for <code class="literal">owner</code> and <code class="literal">access</code>. The <code class="literal">owner</code> and <code class="literal">access</code> field must both be set for <code class="literal">syncstorage</code> to work correctly. As of this writing, the only <code class="literal">owner</code> option is <code class="literal">user</code>. This is the currently authenticated user.</p><p>The <code class="literal">access</code> configuration determines if the store is <span class="strong"><strong>private</strong></span>, available only to the currently authenticated user, or <span class="strong"><strong>public</strong></span>, available to all members of the group of users. This is the user group we set up in the Sencha.io dashboard.</p><p>Next, we added a configuration of <code class="literal">autoLoad: true</code>. This will load any local data if the connection is lost while the user is still logged in. We then set <code class="literal">autosync: false</code> to prevent the store from automatically syncing when the application starts. We should to wait until the user logs into the application before we load the store. We will do this manually as part of the application controller.</p><p>You can make the<a id="id550" class="indexterm"/> exact same changes to the <code class="literal">CardStore.js</code> file to get it working with Sencha.io, but it requires one additional setting for <code class="literal">remoteFilter: false</code>. We will be loading all of the user's cards when they log in, and filtering them by deck once a deck is selected.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>The <code class="literal">remoteFilter</code> configuration is part of the store, not the proxy.</p></div></div><p>Now that we have our stores configured we can move on to the controller.</p></div><div class="section" title="Creating the controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Creating the controller</h2></div></div></div><p>Our controller has a few <a id="id551" class="indexterm"/>things it needs to handle for us:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up for Sencha.io</li><li class="listitem" style="list-style-type: disc">Handling anything that needs to happen at login and logout</li><li class="listitem" style="list-style-type: disc">Adding cards and decks</li><li class="listitem" style="list-style-type: disc">Selecting a deck for display</li><li class="listitem" style="list-style-type: disc">Syncing between the local application and Sencha.io</li></ul></div><p>We will start by setting up our basic controller with the models, views, stores, and references:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.controller.MyController', {
    extend: 'Ext.app.Controller',
    config: {
        selectedDeck: false,
        models: [
          'Deck',
          'Card'
        ],
        stores: [
          'DeckStore',
          'CardStore'
        ],
        views: [
          'Main',
          'addCardSheet',
          'addDeckSheet',
          'CardView'
        ],
   refs: {
       addCardSheet: '#addCardSheet',
       addCardSaveButton: '#addCardSheet button[text="Save"]',
       addDeckSheet: '#addDeckSheet',
       addDeckSaveButton: '#addDeckSheet button[text="Save"]',
       deckList: '#deckList',
       mainView: '#mainView',
       shuffle: 'button[text="Shuffle"]'
   }
  }
});</pre></div><p>The first section defines<a id="id552" class="indexterm"/> our controller and then lists the <code class="literal">models</code>, <code class="literal">stores</code>, and <code class="literal">views</code> values we previously created. We also add an empty configuration for <code class="literal">selectedDeck</code>. We will be using this as a placeholder for storing the record of the currently selected deck. This will allow us to easily get and set the value anywhere in our controller functions using <code class="literal">getSelectedDeck</code> and <code class="literal">setSelectedDeck</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>
<span class="strong"><strong>Getters and setters</strong></span>
</p><p>Sencha Touch automatically creates <code class="literal">get</code> and <code class="literal">set</code> functions for configuration settings as well as references (see the following section). These functions take the form of <code class="literal">getWhateverYouCalledIt</code> and <code class="literal">setWhateverYouCalledIt</code>. It is important to remember that even if you lowercase the first letter of the <code class="literal">config</code> option or reference, the <code class="literal">get</code> and <code class="literal">set</code> functions will uppercase the first letter.</p></div></div><p>The <code class="literal">refs</code> section allows us to create a reference to a component either by <code class="literal">id</code> (such as <code class="literal">#addCardSheet</code>) or a component query, such as (<code class="literal">#addCardSheet button[text="Save"]</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>The preceding component query will look for a component with an <code class="literal">id</code> value of <code class="literal">addCardSheet</code> and then find the button within the component that has a <code class="literal">text</code> configuration of <code class="literal">"Save"</code>.</p></div></div><p>We can now reference anything in our <code class="literal">refs</code> list with <code class="literal">this.getReferenceName</code>.</p><p>Immediately after the <code class="literal">refs</code> section we need to add a <code class="literal">control</code> section. This section uses our references and defines a set of listeners and functions for some of our components:</p><div class="informalexample"><pre class="programlisting">control: {
    addCardSaveButton: {
  tap: "addCard"
    },
    addDeckSaveButton: {
  tap: "addDeck"
    },
    deckList: {
  select: "onDeckSelected"
    },
    addCardSheet: {
  show: "updateCardSheetDeckInfo"
    },
    shuffle: {
  tap: 'shuffleDeck'
    }
}</pre></div><p>Each member<a id="id553" class="indexterm"/> of our <code class="literal">control</code> section has a reference, an event to listen for and a function to fire when the event occurs. We will create each of these functions later in the controller, but first we need to add our <code class="literal">init</code> function to set up Sencha.io and the other functions for authentication.</p><p>When our application first starts, it needs to listen to the Sencha.io controller for authentication and messaging. We handle this in our <code class="literal">init</code> function (this goes right after the <code class="literal">config</code> section):</p><div class="informalexample"><pre class="programlisting">init: function() {
  this.getApplication().sio.on({
    authorized: this.onAuth,
    logout: this.onLogout,
    usermessage: this.onUserMessage,
    scope: this
  });
}</pre></div><p>This code tells our controller three events from the Sencha.io controller:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">authorized</code>: The user has successfully logged in</li><li class="listitem" style="list-style-type: disc"><code class="literal">logout</code>: The user has logged out of the system</li><li class="listitem" style="list-style-type: disc"><code class="literal">usermessage</code>: The user has received a message</li></ul></div><p>We have assigned a function to each one of these events and now we need to add them below our <code class="literal">init</code> function.</p><p>The first is our <code class="literal">onAuth</code> function, which syncs all of the user's stores once they have logged in:</p><div class="informalexample"><pre class="programlisting">onAuth: function(user) {
 Ext.getStore('DeckStore').sync();
 Ext.getStore('CardStore').sync();
 return true;
}</pre></div><p>Our <code class="literal">onLogout</code> function<a id="id554" class="indexterm"/> does <a id="id555" class="indexterm"/>the reverse and clears out any locally stored data:</p><div class="informalexample"><pre class="programlisting">onLogout: function() {
  var deckStore = Ext.getStore('DeckStore');
  deckStore.getProxy().clear();
  deckStore.load();
  var cardStore = Ext.getStore('CardStore');
  cardStore.getProxy().clear();
  cardStore.load();
  return true;
}</pre></div><p>Our message function is a bit more interesting.</p><p>Sencha.io allows an application to send messages to the user. These can be system messages (for example, the data in a store has updated) or even direct messages between users.</p><p>We have set up the following function to simply sync our stores when a message has been received (we will set up the function to send the message a bit later). This means if the user has the program open on one device and makes a change to the data, any other device that user has logged in will update and receive the change:</p><div class="informalexample"><pre class="programlisting">    onUserMessage: function(sender, message) {
        var userId = sender.getUserId();
        console.log("user got a message!", arguments, userId);
        Ext.getStore('DeckStore').sync(function() {
            console.log("DeckStore sync callback", arguments);
        });
        Ext.getStore('CardStore').sync(function() {
            console.log("CardStore sync callback", arguments);
        });
        return true;
    }</pre></div><p>We have also added a number of console logs, which you can use to take a look at the messages being sent and the data that is potentially available to your application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Be sure to pull up your console when testing the application and examine the different message elements available to you. We will delve deeper into messaging in the final chapter, but you can also check out the <span class="emphasis"><em>Overview Guide</em></span> available at <a class="ulink" href="http://docs.sencha.io">http://docs.sencha.io</a> for more information about messaging.</p></div></div><p>Next we need to add<a id="id556" class="indexterm"/> the functions that will save our new cards and decks. Both functions are tied to their respective save buttons. They need to grab the data from the sheet, add it to the store, and then sync the store:</p><div class="informalexample"><pre class="programlisting">addCard: function() {
 var cards = Ext.getStore('CardStore'),
 sheet = this.getAddCardSheet();
 cards.add({
  deckID: this.getSelectedDeck().get('id'),
  question: sheet.down('#cardQuestion').getValue(),
  answer: sheet.down('#cardAnswer').getValue()
 });
 cards.sync(Ext.bind(this.syncCallback, this));
 sheet.down('#cardQuestion').setValue("");
 sheet.down('#cardAnswer').setValue("");
 sheet.hide();
}</pre></div><p>We use our references here to grab the <code class="literal">addCardSheet</code> value using <code class="literal">this.getAddCardSheet()</code> and then we add the data as a new record to our card store.</p><p>We then sync the store and <span class="emphasis"><em>bind</em></span> a function called <code class="literal">syncCallback</code>. This is the function that will send out our message telling the application that data has been updated. The <code class="literal">syncCallback</code> function can go right below our <code class="literal">addCards</code> function:</p><div class="informalexample"><pre class="programlisting">syncCallback: function() {
    console.log("broadcast update", arguments);
    this.getApplication().sio.getUser(function(user, error) {
        if (user) {
            console.log("user", user);
            user.send({
                message: "updated"
            },
            function() {
                console.log("send callback");
            }
            );

        }
    });
}</pre></div><p>The console logs have been left in to provide an inside view of the data being passed inside the function. The first part of the code, <code class="literal">this.getApplication().sio.getUser</code>, grabs the currently authenticated user and runs a function. The function checks to see if we got back a user and, if so, we send the user a message that simply says, <code class="literal">updated</code>.</p><p>This message <a id="id557" class="indexterm"/>gets processed by our<a id="id558" class="indexterm"/> <code class="literal">onUserMessage</code> function, which causes our stores to update their data. You can change this message and use the console logs to see how the data is passed between the two functions.</p><p>Our <code class="literal">addDeck</code> function<a id="id559" class="indexterm"/> is a virtual duplicate of <a id="id560" class="indexterm"/>our <code class="literal">addCard</code> function:</p><div class="informalexample"><pre class="programlisting">addDeck: function() {
 var decks = Ext.getStore('DeckStore'),
 sheet = this.getAddDeckSheet();
 decks.add({
  name: sheet.down('textfield').getValue()
 });
 decks.sync(Ext.bind(this.syncCallback, this));
 sheet.down('textfield').setValue("");
 sheet.hide();
}</pre></div><p>Here we only need to get one <code class="literal">textfield</code> value before we sync the store and do our<a id="id561" class="indexterm"/> <code class="literal">syncCallback</code> function. As before, we also clear the field values before hiding the sheet.</p><p>Next we will need to leave our controller for a bit and take a look at how our cards will be displayed.</p></div><div class="section" title="Overriding the Carousel component"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Overriding the Carousel component</h2></div></div></div><p>For a flash card <a id="id562" class="indexterm"/>application, <code class="literal">Carousel</code> seems like an ideal component to use because it allows the user to quickly flip from one card to the next. This would allow us to present a question and have the user swipe to get to the answer. The user can then swipe again to get to the next question and so on.</p><p>This problem is that <code class="literal">Carousel</code> is actually a collection of panels and what we really need is something that will pull records from our data store the way a list view does. In order to do this we need to override the <code class="literal">Carousel</code> component and add some additional behavior.</p><p>We will start with our basic component that extends <code class="literal">Carousel</code>:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.view.CardView', {
 extend: 'Ext.carousel.Carousel',
 alias: 'widget.flashcards',
 config: {
  store: null,
  indicator: false
 }
});</pre></div><p>We start out setting our <code class="literal">store</code> configuration to <code class="literal">null</code> by default. We will set this when we declare the component in the <code class="literal">Main.js</code> file. In our <code class="literal">Main.js</code> file, locate the section that says:</p><div class="informalexample"><pre class="programlisting">xtype: 'carousel'</pre></div><p>Replace that line with the following:</p><div class="informalexample"><pre class="programlisting">xtype: 'flashcards',
store: 'CardStore'</pre></div><p>This sets the container to our new <code class="literal">flashcards</code> carousel and sets the <code class="literal">store</code> configuration to <code class="literal">CardStore</code>.</p><p>If we <a id="id563" class="indexterm"/>had hardcoded the store for the component in our <code class="literal">CardView.js</code> file, it would be more difficult to re-use. When you override a component to extend functionality, it is always a good idea to write it with an eye towards re-using it somewhere else, later on.</p><p>Back in <code class="literal">CardView.js</code>, we need to add a pair of strings to use as xTemplates for our question and answer cards. These go in the <code class="literal">config</code> section of our component:</p><div class="informalexample"><pre class="programlisting">questionTpl: '&lt;div class="question qa"&gt;&lt;span class="count"&gt;{number} of {total}&lt;/span&gt;&lt;span class="question"&gt;{question}&lt;/span&gt;&lt;/div&gt;',
answerTpl: '&lt;div class="question qa"&gt;&lt;span class="count"&gt;{number} of {total}&lt;/span&gt;&lt;span class="question"&gt;{question}&lt;/span&gt;&lt;/div&gt;&lt;div class="answer qa"&gt;&lt;span class="answer"&gt;{answer}&lt;/span&gt;&lt;/div&gt;'</pre></div><p>These will control how to display the question and answer cards. Since we will be using these same templates multiple times, it's a good idea to compile them in our <code class="literal">constructor</code> function. Otherwise, the xTemplate will be compiled and recompiled each time a new flashcard is created:</p><div class="informalexample"><pre class="programlisting">constructor: function(config) {
   this.callParent(arguments);
   this.getQuestionTpl().compile();
   this.getAnswerTpl().compile();
   this.setStore(Ext.getStore(this.getStore()));
   this.getStore().on({
       load: this.createCards,
       refresh: this.createCards,
       addrecords: this.createCards,
       scope: this
   });

}</pre></div><p>Our <code class="literal">constructor</code> function also sets up the store we passed in <code class="literal">Main.js</code>. This one is a bit complex and requires a bit of explaining. Let's start from the inside and work our way out:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">this.getStore()</code>: This grabs the string value we passed in <code class="literal">Main.js</code> (<code class="literal">store: 'CardStore'</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">Ext.getStore()</code>: This grabs the store with a <code class="literal">storeId</code> value of <code class="literal">'CardStore'</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">this.setStore()</code>: This applies the store to our <code class="literal">CardView</code> component, replacing the original string value</li></ul></div><p>When we call <code class="literal">this.getStore()</code> on the next line to set <code class="literal">listeners</code>, it now returns an actual store instead of the string value from before.</p><p>Then we <a id="id564" class="indexterm"/>assign a single function to the store events for <code class="literal">load</code>, <code class="literal">refresh</code>, and <code class="literal">addrecords</code>. We need to add that function next.</p><p>We have broken this function into two parts. The first part is the <code class="literal">createCards</code> function, which gets our store and removes any existing panels from our custom carousel. It then checks to see if we have any cards in the store:</p><div class="informalexample"><pre class="programlisting">createCards: function() {
   var store = this.getStore();
   this.removeAll(); // removes all the old panels
   if (store.getCount() &gt; 0) {
     store.each(this.createFlashCard, this); 
   } else {
       this.add({xtype: 'panel', html: 'No Cards Available for this Deck.&lt;br /&gt;Please click Add to add a card to this deck.'});
   }
   this.setActiveItem(0);
}</pre></div><p>If not, we give the user a message that there are no cards in the deck and they can click on <span class="strong"><strong>Add</strong></span> to create new cards.</p><p>This is where the second part of our function comes into play. If we have records, we pass each one along to a second function called <code class="literal">createFlashCard</code>:</p><div class="informalexample"><pre class="programlisting">createFlashCard: function(record, index, total) {
  var data = Ext.apply({ total: total, number: (index + 1) }, record.data);
  this.add({ xtype: 'panel', html: this.getQuestionTpl().apply(data), scrollable: 'vertical' });
  this.add({ xtype: 'panel', html: this.getAnswerTpl().apply(data), scrollable: 'vertical' });
}</pre></div><p>This function is run on each record in <code class="literal">CardStore</code>. The first line creates our initial data array and sets values for the <code class="literal">total</code> (the number of cards in the deck), <code class="literal">number</code> (the sequential number of the current card), and <code class="literal">data</code> records from the store (which contains both our question and answer for the card).</p><p>We then create a new <code class="literal">panel</code> component and set <code class="literal">html</code> to our compiled question template with the applied data.</p><p>We do the<a id="id565" class="indexterm"/> same thing for our answer template, so we end up with two new panels for each record in the store; a question panel, followed by an answer panel.</p><p>Since <code class="literal">CardStore</code> contains all of the records for every deck, we need to filter these down by deck before our <code class="literal">CardsView</code> carousel loads. We'll handle that back in the controller.</p></div><div class="section" title="Back in the controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Back in the controller</h2></div></div></div><p>Once the user selects a deck from our list, we need to filter <code class="literal">CardStore</code> so that only the cards for that deck are available. We do this in our<a id="id566" class="indexterm"/> <code class="literal">onDeckSelected</code> function:</p><div class="informalexample"><pre class="programlisting">onDeckSelected: function(list, record) {
 var cards = Ext.getStore('CardStore');
 this.setSelectedDeck(record);
 cards.clearFilter();
 cards.sort('id', 'ASC');
 cards.filter('deckID', record.get('id'));
 this.getMainView().down('#cardsPanel').enable();
 this.getMainView().setActiveItem(1);
}</pre></div><p>This function is triggered by the select event in our <code class="literal">deckList</code> component<a id="id567" class="indexterm"/> and passes us the list and the record that was selected. Once we grab <code class="literal">CardStore</code>, we <a id="id568" class="indexterm"/>set the <code class="literal">selectedDeck</code> function<a id="id569" class="indexterm"/> to the record that was passed to us when the deck in the list was selected.</p><p>Next, we clear any existing filters on <code class="literal">CardStore</code> and sort it by its <code class="literal">id</code> value. We then filter the cards to only display the ones for the current deck. Finally, we enable <code class="literal">cardsPanel</code> and set it to be the active item.</p><p>We also have a <code class="literal">control</code> function that fires when <code class="literal">cardPanel</code> is shown. This function sets the title bar of the card panel to the name of the deck:</p><div class="informalexample"><pre class="programlisting">updateCardSheetDeckInfo: function(sheet) {
sheet.down('#deckName').setHtml(this.getSelectedDeck().get('name'));
}</pre></div><p>Since our initial load of the card store presents them in order by <code class="literal">id</code>, it might be a good idea to let the user shuffle the cards. We do this with our final controller function:</p><div class="informalexample"><pre class="programlisting">shuffleDeck: function() {
 Ext.getStore('CardStore').sort({
  sorterFn: function() {
   return (Math.round(Math.random())-0.5);
  }
 });
}</pre></div><p>This function grabs <code class="literal">CardStore</code> and sorts it using JavaScript's <code class="literal">Math.random</code> function to assign a random sort order to each card.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>For a more complete understanding of how sorting works in JavaScript (and Sencha Touch), consult the excellent Mozilla Developer Network's JavaScript Reference for sorting at <a class="ulink" href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort">https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort</a>.</p></div></div><p>You should now be able to add decks and cards to the application. When you select a deck, the card stack will appear. You can advance from one card to the next by swiping from right to left as shown:</p><div class="mediaobject"><img src="graphics/8901OS_05_09.jpg" alt="Back in the controller"/></div><p>You can use the CSS files to style the answer and question to fit your own personal tastes.</p><p>Remember, you will need to register with the application before you can start creating decks and cards. Once you are registered, you can log in from any Sencha Touch Compatible browser and access the same information across multiple devices. Fortunately, since we are using Sencha.io, all of this is taken care of automatically.</p><div class="mediaobject"><img src="graphics/8901OS_05_10.jpg" alt="Back in the controller"/></div><p>Sencha.io automatically creates these login and registration forms for our application. If the user clicks the <span class="strong"><strong>register</strong></span> button, they will be offered the opportunity to register and use your application. Sencha.io handles all of the forms, data storage, and interactions, which include password recovery without the need for any additional code.</p></div></div>
<div class="section" title="Deploying the application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Deploying the application</h1></div></div></div><p>Sencha.io also offers<a id="id570" class="indexterm"/> you the option of deploying your application to the Sencha.io cloud service.</p><p>From the Sencha.io dashboard, you can click on your application in the list on the right-hand side of the page. When the main page for the application appears, click on <span class="strong"><strong>New Version</strong></span> and you will be able to upload a zipped file containing all of your code to the Sencha.io website.</p><p>When the upload completes, you will be presented with a public URL you can use to access the application. You can also specify if the release is for development or production.</p><p>You can also choose to deploy your application to your own web server if you prefer.</p></div>
<div class="section" title="Homework"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Homework</h1></div></div></div><p>There are a few things that can be added to the application to make it more complete:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add the ability to edit/delete cards and decks</li><li class="listitem" style="list-style-type: disc">Update the deck list template to show the number of cards in the deck</li><li class="listitem" style="list-style-type: disc">Provide a more detailed layout and CSS styling for the questions and answers</li><li class="listitem" style="list-style-type: disc">Switch the login method in the Sencha dashboard to allow login with Facebook</li><li class="listitem" style="list-style-type: disc">Use the messaging system to present an alert to the user when new cards or decks are available</li></ul></div><p>The opportunities offered by Sencha.io are huge. With its integrated messaging system, you have the potential to communicate with a single user or every user of the application. This opens up possibilities such as publishing and sharing decks between users.</p><p>For more information, take a look at the documentation available at <a class="ulink" href="http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction">http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction</a>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter we used a simple Flash card application to explore some of the uses and possibilities of Sencha.io. We covered the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building the basic application including the stores, models, and views</li><li class="listitem" style="list-style-type: disc">Getting started with Sencha.io, signing up, downloading, installing, and configuring the basic application to communicating with the Sencha.io service</li><li class="listitem" style="list-style-type: disc">Creating a controller for the application and updating the stores to connect to the Sencha.io service</li><li class="listitem" style="list-style-type: disc">Overriding the carousel so that it can read from a data store</li><li class="listitem" style="list-style-type: disc">Deploying the application to Sencha.io</li></ul></div><p>In the next chapter we will explore creating your own API for use with Sencha Touch.</p></div></body></html>