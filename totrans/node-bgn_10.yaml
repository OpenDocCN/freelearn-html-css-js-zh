- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Building Web Applications with Express
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express 构建 Web 应用程序
- en: Express is the most popular web framework for JavaScript and has been the de-facto
    standard for many years. It is a very minimalistic framework, very easy to learn,
    and provides a lot of flexibility to build web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Express 是最流行的 JavaScript 网络框架，并且多年来一直是事实上的标准。它是一个非常简约的框架，非常容易学习，并且为构建网络应用提供了很多灵活性。
- en: In this chapter, we will start with the most basic “hello world” application
    to build a solid and well-tested REST API application. We will explore in detail
    all the critical components of Express, including request and response, middleware,
    and routing. We will also learn how to use the most common Express middleware
    and how to build our own middleware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从一个最基本的“Hello World”应用程序开始，构建一个坚实且经过良好测试的 REST API 应用程序。我们将详细探讨 Express
    的所有关键组件，包括请求和响应、中间件和路由。我们还将学习如何使用最常用的 Express 中间件以及如何构建自己的中间件。
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是本章我们将探讨的主要主题：
- en: Serving static files for your project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的项目提供静态文件服务
- en: Building a server-rendered landing page using template engines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板引擎构建服务器端渲染的着陆页
- en: Building a typical CRUD REST API application with Express
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Express 构建典型的 CRUD REST API 应用程序
- en: Using the most common Express middleware, including third-party libraries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最常用的 Express 中间件，包括第三方库
- en: Building your own middleware
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自己的中间件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)
    找到
- en: Check out the code in action video for this chapter on [https://youtu.be/8QyDZVa7CNg](https://youtu.be/8QyDZVa7CNg)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本章在 [https://youtu.be/8QyDZVa7CNg](https://youtu.be/8QyDZVa7CNg) 中的代码执行视频
- en: Getting familiar with the Express library
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 Express 库
- en: 'Express is defined on its own website ([https://expressjs.com/](https://expressjs.com/))
    as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Express 在其自己的网站上 ([https://expressjs.com/](https://expressjs.com/)) 如下定义：
- en: Fast, unopinionated, minimalist web framework for Node.js
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 快速、无偏见、简约的 Node.js 网络框架
- en: So, the good news is that we have a lot of freedom to build our application.
    The bad news is that we must make a lot of decisions, and we must be careful to
    not make mistakes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，好消息是我们有很多自由度来构建我们的应用程序。坏消息是我们必须做出很多决定，我们必须小心不要犯错误。
- en: Express is very minimalistic in comparison with other web frameworks, so we
    have to add third-party libraries or build our own abstractions when needed. Express
    has a very active community, so we can find a lot of libraries to solve common
    problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他网络框架相比，Express 非常简约，因此当需要时，我们必须添加第三方库或构建自己的抽象。Express 有一个非常活跃的社区，因此我们可以找到很多库来解决常见问题。
- en: Additionally, the official documentation is of great quality and there are plenty
    of resources to learn more about Express, which makes Express a great choice for
    beginners.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，官方文档质量很高，有很多资源可以学习更多关于 Express 的知识，这使得 Express 成为初学者的绝佳选择。
- en: As Express is an unopinionated framework, when you follow a tutorial or a course
    you will find that sometimes the code is not consistent and doesn’t follow the
    same patterns. This is because you have a lot of freedom in Express, and over
    time you will develop your own patterns and your own way of building applications
    that best fits you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Express 是一个无偏见的框架，当你遵循教程或课程时，你会发现代码有时并不一致，也不遵循相同的模式。这是因为你在 Express 中有很多自由度，随着时间的推移，你将发展出自己的模式，并找到最适合你的构建应用程序的方式。
- en: In this book, we will use Express version 4.18.3, but any Express 4.x version
    should be fine as well. We will use Node.js version 20.11.0\. Both are the latest
    versions available at the time of writing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 Express 版本 4.18.3，但任何 Express 4.x 版本都应该是可以的。我们将使用 Node.js 版本 20.11.0。这两个都是写作时的最新版本。
- en: Installing Express
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Express
- en: 'To install Express, we must run the following command in a new Node.js project:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Express，我们必须在新的 Node.js 项目中运行以下命令：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You don’t need any additional configuration; just install it and you are ready
    to go.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要任何额外的配置；只需安装它，你就可以开始了。
- en: Hello World
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello World
- en: 'Let’s start with a simple example, a Hello World application. Create a new
    file called `helloWorld.js` and add the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始，一个 Hello World 应用程序。创建一个名为 `helloWorld.js` 的新文件，并添加以下代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Very simple, right? Let’s break it down:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，对吧？让我们来分解一下：
- en: We import the Express library and create an instance of the Express application.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入Express库并创建Express应用程序的一个实例。
- en: We define a route for the `/` root path and we send a response with the text
    `Hello World` `from Express!`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为`/`根路径定义一个路由，并发送包含文本`Hello World` `from Express!`的响应。
- en: We start the server and listen on port `3000`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启动服务器并监听端口`3000`。
- en: 'To run the application, we use the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，我们使用以下命令：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If everything is OK, you should see the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该看到以下输出：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if you open your browser and go to `http://localhost:3000`, you should
    see the text **Hello World from Express!**, as shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你打开你的浏览器并转到`http://localhost:3000`，你应该看到文本**Hello World from Express!**，如下面的截图所示：
- en: '![Figure 10.1 – Web browser screenshot showing a simple Express project](img/B21678_10_1.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 显示简单Express项目的Web浏览器截图](img/B21678_10_1.jpg)'
- en: Figure 10.1 – Web browser screenshot showing a simple Express project
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 显示简单Express项目的Web浏览器截图
- en: Using the generator
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用生成器
- en: 'Express has a command-line tool to generate a basic application. To use it,
    we must run the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Express有一个命令行工具可以生成基本的应用程序。要使用它，我们必须运行以下命令：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will generate a new application with many files and folders. I recommend
    you create a new folder and run the command there, so you don’t mess up your current
    project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个包含许多文件和文件夹的新应用程序。我建议你创建一个新的文件夹并在那里运行命令，这样你就不会弄乱你的当前项目。
- en: 'The output on execution should be something like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时的输出应该类似于以下内容：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then the next step is to install the dependencies:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后下一步是安装依赖项：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we can start the application:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以启动应用程序：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If everything is OK, you should see the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该看到以下输出：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you access `http://localhost:3000` in the browser, you should see the following
    page:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过浏览器访问`http://localhost:3000`，你应该看到以下页面：
- en: '![Figure 10.2 – Web browser screenshot showing the Express app generated using
    the express-generator](img/B21678_10_2.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 显示使用express-generator生成的Express应用的Web浏览器截图](img/B21678_10_2.jpg)'
- en: Figure 10.2 – Web browser screenshot showing the Express app generated using
    the `express-generator`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 显示使用`express-generator`生成的Express应用的Web浏览器截图
- en: Feel free to explore the generated code, but don’t worry if you don’t understand
    everything as we will cover all the important parts in the following sections.
    Note that also the route [http://localhost:3000/users](http://localhost:3000/users)
    is working and if you try any other route, you will get a 404 error, as with [http://localhost:3000/invented](http://localhost:3000/invented)
    for example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随意探索生成的代码，但如果你对某些内容不理解也不要担心，因为接下来的章节中我们会涵盖所有重要的部分。请注意，路由[http://localhost:3000/users](http://localhost:3000/users)也是正常工作的，如果你尝试其他路由，你会得到一个404错误，例如[http://localhost:3000/invented](http://localhost:3000/invented)。
- en: Debugging
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: 'Now, let me show another cool thing that the Express generator includes and
    that we will use in our project later. If you start the application with the command
    `DEBUG=* npm start` or `set DEBUG=* && npm start` (if you use Windows) in the
    terminal output will be more verbose and you will see a lot of information about
    the requests and responses:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我展示Express生成器包含的另一个酷功能，我们将在我们的项目中稍后使用。如果你在终端输出中使用命令`DEBUG=* npm start`或`set
    DEBUG=* && npm start`（如果你使用Windows），输出将更加详细，你会看到关于请求和响应的很多信息：
- en: '![Figure 10.3 – Terminal screenshot](img/B21678_10_3.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 终端截图](img/B21678_10_3.jpg)'
- en: Figure 10.3 – Terminal screenshot
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 终端截图
- en: This is because Express and many other dependencies use the `debug` library
    ([https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug)) to
    log information. By using the `DEBUG=*` environment variable, we are telling to
    debug library to print the information related to all the namespaces. But we can
    be more selective and limit the scope for Express, for example, by using the `DEBUG=express:*
    npm start` environment variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Express和许多其他依赖项使用`debug`库([https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug))来记录信息。通过使用`DEBUG=*`环境变量，我们告诉调试库打印与所有命名空间相关的信息。但我们可以更加选择性地限制范围，例如，通过使用`DEBUG=express:*
    npm start`环境变量。
- en: Now, that we have a basic understanding of Express, it is time to explore how
    we can use template engines to render the HTML pages that will be sent to the
    browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经对Express有了基本的了解，是时候探索我们如何使用模板引擎来渲染发送到浏览器的HTML页面了。
- en: Understanding template engines
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板引擎
- en: In [*Chapter 9*](B21678_09.xhtml#_idTextAnchor244), we learned the difference
    between **single-page applications** (**SPAs**) and server-side rendering.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B21678_09.xhtml#_idTextAnchor244)中，我们学习了**单页应用程序**（**SPAs**）和服务器端渲染之间的区别。
- en: Express provides a way to render HTML pages using template engines. This is
    the key feature to build server-side rendered applications with Express.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Express提供了一种使用模板引擎渲染HTML页面的方法。这是使用Express构建服务器端渲染应用程序的关键特性。
- en: Choosing a template engine
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择模板引擎
- en: The first thing that we must do is to choose a template engine. There are many
    options available. The most popular option historically was Jade ([https://www.npmjs.com/package/jade](https://www.npmjs.com/package/jade)),
    but it was renamed to Pug ([https://www.npmjs.com/package/pug](https://www.npmjs.com/package/pug)).
    You can find many tutorials and examples by searching using both names.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是选择一个模板引擎。有许多选项可供选择。历史上最受欢迎的选项是Jade([https://www.npmjs.com/package/jade](https://www.npmjs.com/package/jade))，但它的名字已被改为Pug([https://www.npmjs.com/package/pug](https://www.npmjs.com/package/pug))。您可以通过搜索这两个名字来找到许多教程和示例。
- en: I personally prefer **Embedded JavaScript templating** (**ejs**) ([https://www.npmjs.com/package/ejs](https://www.npmjs.com/package/ejs))
    for its simplicity and because it is well documented. Over time, you will get
    more familiar with the template engines and will be able to choose the one that
    better fits your needs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人更喜欢**嵌入式JavaScript模板**（**ejs**）([https://www.npmjs.com/package/ejs](https://www.npmjs.com/package/ejs))，因为它简单且文档齐全。随着时间的推移，您将更加熟悉模板引擎，并能够选择最适合您需求的那个。
- en: Rendering a template
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染模板
- en: 'So, going back to our hello world example, let’s create a new file called `helloWorldTemplate.js`
    and add the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到我们的hello world示例，让我们创建一个名为`helloWorldTemplate.js`的新文件，并添加以下代码：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we have to create a new folder called `views`, inside of which we create
    a new file called `index.ejs` with the following content:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个名为`views`的新文件夹，在其中创建一个名为`index.ejs`的新文件，内容如下：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the template engine uses the `<%=` and `%>` tags to interpolate
    the values. In this case, we are passing the `title` variable to the template.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模板引擎使用`<%=`和`%>`标签来插入值。在这种情况下，我们将`title`变量传递给模板。
- en: 'Finally, we have to install the `ejs` dependency:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须安装`ejs`依赖项：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we start the application as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们按照以下方式启动应用程序：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you access `http://localhost:3000` in the browser, you should see the following
    displayed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中访问`http://localhost:3000`，您应该看到以下内容显示：
- en: '![Figure 10.4 – Web browser screenshot showing the templeate rendered for the
    end user.](img/B21678_10_4.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 显示为最终用户渲染的模板的Web浏览器截图。](img/B21678_10_4.jpg)'
- en: Figure 10.4 – Web browser screenshot showing the templeate rendered for the
    end user.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 显示为最终用户渲染的模板的Web浏览器截图。
- en: 'Additionally, if you access `view-source:http://localhost:3000/`, you will
    see the raw HTML that Express is sending to the browser:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您访问`view-source:http://localhost:3000/`，您将看到Express发送到浏览器的原始HTML：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see the template engine is interpolating the values and generating
    the HTML for us.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模板引擎正在为我们插入值并生成HTML。
- en: Understanding the process
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解这个过程
- en: 'Now, let’s understand what is actually happening in the code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解代码中实际发生的事情：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding line tells Express that we are going to use `ejs` as our template
    engine, so now we can use `res.render` to render the template.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行告诉Express我们将使用`ejs`作为我们的模板引擎，因此现在我们可以使用`res.render`来渲染模板。
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, the `res.render` method receives two parameters. The
    first one is the name of the template, in this case, `index` (`views/index.ejs`),
    and the second one is the data that we want to interpolate in the template.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`res.render`方法接收两个参数。第一个参数是模板的名称，在这种情况下，`index`（`views/index.ejs`），第二个参数是我们想要在模板中插入的数据。
- en: Then the template engine will replace the `<%= title %>` and `<%= subtitle %>`
    tags with the values that we are passing in the second parameter of the `res.render`
    method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后模板引擎将用我们在`res.render`方法的第二个参数中传递的值替换`<%= title %>`和`<%= subtitle %>`标签。
- en: In real-world applications, the data that we pass to the template will be dynamic;
    for example, the data that we get from a database or an external API. But for
    now, we are going to use static data to keep the example simple.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，我们传递给模板的数据将是动态的；例如，我们从数据库或外部API获取的数据。但就目前而言，我们将使用静态数据以使示例简单。
- en: In the next section, we will learn how we can take advantage of the request
    object to build more rich and powerful applications.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何利用请求对象构建更丰富和强大的应用程序。
- en: Mastering requests
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握请求
- en: In [*Chapter 9*](B21678_09.xhtml#_idTextAnchor244), we learned all the theory
    around HTTP requests and responses. Here, we will cover how to handle these with
    Express.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B21678_09.xhtml#_idTextAnchor244)中，我们学习了关于HTTP请求和响应的所有理论。在这里，我们将介绍如何使用Express来处理这些请求。
- en: 'In this section, we are going to focus on this snippet of pseudo-code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于以下伪代码片段：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have three elements here to understand:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个元素需要理解：
- en: '`method`, that is, the HTTP method that we want to handle, for example, `GET`,
    `POST`, `PUT`, `DELETE`, and so on'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`，即我们想要处理的HTTP方法，例如`GET`、`POST`、`PUT`、`DELETE`等等'
- en: '`route`, that is, the path that we want to handle, for example, `/`, `/users`,
    or `/users/:id`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route`，即我们想要处理的路径，例如`/`、`/users`或`/users/:id`'
- en: '`handler`, that is, the callback function that will be executed when `method`
    and `route` match'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`，即当`method`和`route`匹配时将被执行的回调函数'
- en: HTTP methods
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP方法
- en: Express provides a method for each HTTP method. There are many out there (`get`,
    `post`, `put`, `head`, `delete`, `options`, `trace`, `copy`, `lock`, `mkcol`,
    `move`, `purge`, `propfind`, `proppatch`, `unlock`, `report`, `mkactivity`, `checkout`,
    `merge`, `m-search`, `notify`, `subscribe`, `unsubscribe`, `patch`, `search`,
    and `connect`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Express为每种HTTP方法提供了一个方法。有很多种方法（`get`、`post`、`put`、`head`、`delete`、`options`、`trace`、`copy`、`lock`、`mkcol`、`move`、`purge`、`propfind`、`proppatch`、`unlock`、`report`、`mkactivity`、`checkout`、`merge`、`m-search`、`notify`、`subscribe`、`unsubscribe`、`patch`、`search`和`connect`）。
- en: 'The most common are `get`, `post`, `put`, and `delete`, so we are going to
    focus on them:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是`get`、`post`、`put`和`delete`，因此我们将重点关注它们：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to manage all the HTTP methods in the same route, you can use the
    `all` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在同一个路由中管理所有HTTP方法，你可以使用`all`方法：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Routes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: The routes are very flexible and can be dynamic. We can define them in different
    ways, including regular expressions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 路由非常灵活，可以是动态的。我们可以用不同的方式定义它们，包括正则表达式。
- en: Static paths
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态路径
- en: 'Static paths are the most common way of defining routes. They are used to handle
    requests to a specific path, for example, `/`, `/users`, or `/user/me`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 静态路径是定义路由最常见的方式。它们用于处理对特定路径的请求，例如`/`、`/users`或`/user/me`：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Dynamic parameters
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态参数
- en: 'Dynamic parameters are used to handle the requests to a specific path. We can
    use the `:` character to define a dynamic parameter, such as `/users/:id` or `/users/:id/profile`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 动态参数用于处理对特定路径的请求。我们可以使用`:`字符来定义一个动态参数，例如`/users/:id`或`/users/:id/profile`：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, `:id` is a dynamic parameter, so it will match with any value,
    including `/users/1`, `/users/peter`, `/users/jane-doe`, and so on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`:id`是一个动态参数，因此它可以与任何值匹配，包括`/users/1`、`/users/peter`、`/users/jane-doe`等等。
- en: 'You can even combine static and dynamic parameters, such as `/users/:id/profile`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将静态和动态参数结合起来，例如`/users/:id/profile`：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding example will resolve requests to `/users/1/profile`, `/users/peter/profile`,
    `/users/jane-doe/profile`, and so on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将解析对`/users/1/profile`、`/users/peter/profile`、`/users/jane-doe/profile`等路径的请求。
- en: 'This pattern is quite common in transportation apps, for example, where you
    can have a route such as `/users/:id/rides/:rideId` to get the details of a specific
    ride, or when you book tickets for a flight using a route such as `/flights/from/:originCity/to/:destinationCity`.
    Express will provide the values of the dynamic parameters in the `req.params`
    object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在交通应用中相当常见，例如，你可以有一个像`/users/:id/rides/:rideId`这样的路由来获取特定行程的详细信息，或者当你使用像`/flights/from/:originCity/to/:destinationCity`这样的路由预订航班时。Express将为`req.params`对象提供动态参数的值：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Optional parameters
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'The optional parameters are used to handle the requests to a specific path,
    but the parameter is optional. This can be done with the `?` character, such as
    `/invoice/:id?`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数用于处理对特定路径的请求，但该参数是可选的。这可以通过使用`?`字符来完成，例如`/invoice/:id?`：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case the `:id` parameter is optional, so it will match with `/invoice`,
    `/invoice/167`, `/invoice/G123S8123SD123MJ`, and so on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`:id`参数是可选的，因此它可以与`/invoice`、`/invoice/167`、`/invoice/G123S8123SD123MJ`等匹配。
- en: Regular expressions
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'We can use regular expressions to define routes. This is quite useful when
    we want to match the route using predictable patterns – for example, `/.*fly$/`
    will identify any text that ends with `fly`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用正则表达式来定义路由。当我们想要使用可预测的模式匹配路由时，这非常有用——例如，`/.*fly$/` 将识别以 `fly` 结尾的任何文本：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding route will match with `/butterfly`, `/dragonfly`, `/fly`, `/mcfly`,
    and so on. Let’s create a less exotic example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的路由将匹配 `/butterfly`、`/dragonfly`、`/fly`、`/mcfly` 等等。让我们创建一个不那么奇特示例：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, the route will match with `/msg/1/edit`, `/msg/1/delete`, and
    so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，路由将匹配 `/msg/1/edit`、`/msg/1/delete` 等等。
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you’re unfamiliar with regular expressions, don’t worry: you can use the
    other options to define your routes. But if you want to explore regular expressions
    more deeply, I recommend you to try *Regular Expressions* *101* ([https://regex101.com/](https://regex101.com/)).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉正则表达式，不要担心：你可以使用其他选项来定义你的路由。但如果你想更深入地探索正则表达式，我建议你尝试 *正则表达式 101* ([https://regex101.com/](https://regex101.com/))。
- en: Query params
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询参数
- en: In [*Chapter 9*](B21678_09.xhtml#_idTextAnchor244), we learned about the different
    parts of the URL and saw that the query params are those parts that start with
    `?`. These are used to send extra information to the server. For example, in the
    URL `/films?category=scifi&director=George+Lucas` we are sending two query params,
    `category` and the `director`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 9 章*](B21678_09.xhtml#_idTextAnchor244) 中，我们学习了 URL 的不同部分，并看到查询参数是以 `?`
    开头的部分。这些用于向服务器发送额外信息。例如，在 URL `/films?category=scifi&director=George+Lucas` 中，我们发送了两个查询参数，`category`
    和 `director`。
- en: 'We can capture the query params in the `req.query` object to use them in our
    routes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `req.query` 对象中捕获查询参数，并在我们的路由中使用它们：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is important to note that query params are optional, meaning that requests
    might not have any query param at all. In that case, the `req.query` object would
    be empty.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，查询参数是可选的，这意味着请求可能根本不包含任何查询参数。在这种情况下，`req.query` 对象将是空的。
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: URL fragments (i.e., `/mypath#fragment`) are not part of requests and will not
    be included as such by the browser, so we can’t capture them. See https://github.com/expressjs/express/issues/1083
    for more info.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: URL 片段（即 `/mypath#fragment`）不是请求的一部分，浏览器也不会将其作为此类包含，因此我们无法捕获它们。有关更多信息，请参阅 https://github.com/expressjs/express/issues/1083。
- en: The importance of order
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顺序的重要性
- en: 'The routes are registered in the order that you defined them, which allows
    Express to avoid conflicts between routes. Let’s see an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是按照你定义的顺序注册的，这允许 Express 避免路由之间的冲突。让我们看一个例子：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you try to access `/users/me`, you will get the message `You are looking
    for the user with id me` because the `/users/:id` route is registered first, so
    it will match with `/users/me` and the `me` value will be stored in the `req.params.id`
    property.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试访问 `/users/me`，你会得到消息 `You are looking for the user with id me`，因为 `/users/:id`
    路由是首先注册的，所以它会匹配 `/users/me`，而 `me` 的值将被存储在 `req.params.id` 属性中。
- en: 'You can solve this issue by shifting the order of the routes:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调整路由的顺序来解决这个问题：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In big projects, this can become a problem if you don’t have a good strategy
    to define the routes. This is also a good reason to include automated tests in
    your project to avoid accidental misconfigurations of routes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，如果你没有良好的策略来定义路由，这可能会成为一个问题。这也是在项目中包含自动化测试以避免意外配置路由错误的好理由。
- en: Handlers
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理器
- en: 'Handlers are the functions that are executed when a request matches with a
    route. While a handler is a simple function with three parameters (`req`, `res`,
    and `next`), it has the big responsibility of handling the response to the request
    or delegating the request to other handlers:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是在请求与路由匹配时执行的函数。虽然处理器是一个带有三个参数（`req`、`res` 和 `next`）的简单函数，但它承担着处理请求响应或委派请求给其他处理器的重大责任：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s see the parameters of the handler in more detail.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看处理器的参数。
- en: request
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求
- en: The request object (`req`) contains all the information about the request, including
    the parameters, IP, headers, body, and so on. If you use other libraries that
    extend the capabilities of Express, very often you will find more properties in
    this object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象（`req`）包含有关请求的所有信息，包括参数、IP、头部、主体等。如果你使用其他扩展 Express 功能的库，你经常会在这个对象中找到更多属性。
- en: You can find more information about the request object in the Express documentation
    ([https://expressjs.com/en/4x/api.html#req](https://expressjs.com/en/4x/api.html#req)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Express 文档中找到更多关于请求对象的信息（[https://expressjs.com/en/4x/api.html#req](https://expressjs.com/en/4x/api.html#req)）。
- en: response
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: response
- en: The response object (`res`) contains all the methods to handle the response
    of the request, including simple methods like `send` or `json` to more complex
    methods like download or redirect.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象 (`res`) 包含处理请求响应的所有方法，包括简单的 `send` 或 `json` 方法，以及更复杂的方法，如下载或重定向。
- en: In the following section, we will learn more about the response object capabilities.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习更多关于响应对象的功能。
- en: next
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: next
- en: The next function (`next`) is used to delegate the request to the next handler.
    This is useful when you want to split the logic of the handler into multiple functions
    or delegate error management.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数 (`next`) 用于将请求委派给下一个处理器。当你想要将处理器的逻辑拆分成多个函数或委派错误管理时，这很有用。
- en: We will learn both strategies in the next two sections, when we will discuss
    the middleware pattern and mastering responses.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的两个章节中学习这两种策略，届时我们将讨论中间件模式和掌握响应。
- en: In the next section, we will learn how we can take advantage of the response
    object and how to customize the responses based on many different scenarios, such
    as HTTP redirection, HTTP header customization, and more.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何利用响应对象，以及如何根据许多不同的场景自定义响应，例如 HTTP 重定向、HTTP 头部定制等。
- en: Mastering responses
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握响应
- en: Responses are the way by which the server communicates back to the client after
    a request, so it is crucial to understand how to manage them. In this section,
    we will learn about adding headers, status codes, redirects, sending data, and
    sending files.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是服务器在请求之后与客户端通信的方式，因此理解如何管理它们至关重要。在本节中，我们将学习如何添加头部、状态码、重定向、发送数据和发送文件。
- en: You will discover the available methods when you start to build more complex
    applications. You can find more information about the response object in the Express
    documentation ([https://expressjs.com/en/4x/api.html#res](https://expressjs.com/en/4x/api.html#res)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建更复杂的应用程序时，你将发现可用的方法。你可以在 Express 文档中找到更多关于响应对象的信息（[https://expressjs.com/en/4x/api.html#res](https://expressjs.com/en/4x/api.html#res)）。
- en: Header management
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部管理
- en: 'Headers are used to send extra information about the response. Express handles
    headers by using the `set` method, which receives two parameters, the name of
    the header and the value of the header:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 头部用于发送关于响应的额外信息。Express 通过 `set` 方法处理头部，它接受两个参数，即头部的名称和值：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, we are setting the `Content-Type` header to `text/html`
    so the browser will know that the response is an HTML document and will render
    it as HTML.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将 `Content-Type` 头部设置为 `text/html`，这样浏览器就会知道响应是一个 HTML 文档，并将其渲染为 HTML。
- en: Multiple headers
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个头部
- en: 'You can also use the `set` method to set multiple headers at the same time
    by passing an object as the first parameter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过传递一个对象作为第一个参数来使用 `set` 方法同时设置多个头部：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we are setting two headers, `Content-Type` and `x-powered-by`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们设置了两个头部，`Content-Type` 和 `x-powered-by`。
- en: Removing headers
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除头部
- en: 'You can remove a header by using the `removeHeader` method, which receives
    the name of the header as the first parameter:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `removeHeader` 方法来删除头部，它接受头部名称作为第一个参数：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, we are removing the `x-powered-by` header that we
    just added in the previous statement.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们正在移除之前语句中刚刚添加的 `x-powered-by` 头部。
- en: Status codes
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态码
- en: A status code is a number that represents the status of the response. It is
    used to communicate the status of the request to the client. It is important to
    use the correct status code, as it is part of the HTTP protocol that we discussed
    in [*Chapter 9*](B21678_09.xhtml#_idTextAnchor244).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码是一个表示响应状态的数字。它用于将请求的状态传达给客户端。使用正确的状态码非常重要，因为它是我们之前讨论的 HTTP 协议的一部分，见 [*第 9
    章*](B21678_09.xhtml#_idTextAnchor244)。
- en: 'You can manage status codes using the `status` method, which receives the status
    code as the first parameter:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `status` 方法来管理状态码，它接受状态码作为第一个参数：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, we are setting the status code to `200`, which means
    that the request was successful, By default, Express will set the status code
    to `200` if you don’t set it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将状态码设置为 `200`，这意味着请求成功。默认情况下，如果你没有设置状态码，Express 会将其设置为 `200`。
- en: Chaining methods
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法链式调用
- en: 'You can chain the `status` method with other methods, such as `set` or `send`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `status` 方法与其他方法链式调用，例如 `set` 或 `send`：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Sending status codes only
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅发送状态码
- en: 'If you want to send only the status code, you can use the `sendStatus` method,
    which receives the status code as the first parameter:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想发送状态码，可以使用 `sendStatus` 方法，它将状态码作为第一个参数接收：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, we are sending the `500` status code, which means
    that the request was not successful.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们发送了 `500` 状态码，这意味着请求没有成功。
- en: Redirects
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向
- en: 'You can redirect the request to another URL by using the `redirect` method,
    which receives the URL as the first parameter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `redirect` 方法将请求重定向到另一个 URL，它将 URL 作为第一个参数接收：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, we are redirecting the request to [https://ulisesgascon.com](https://ulisesgascon.com).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将请求重定向到 [https://ulisesgascon.com](https://ulisesgascon.com)。
- en: 'The default status code for redirects is `302`, but you can change this by
    specifying the status code as the first parameter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向的默认状态码是 `302`，但你可以通过指定状态码作为第一个参数来更改它：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `redirect` method also accepts relative URLs, so you can redirect to another
    route in your application:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect` 方法也接受相对 URL，因此你可以将请求重定向到应用程序中的另一个路由：'
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can even redirect to a higher level in the URL:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将 URL 重定向到更高的层级：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this case, the request will be redirected to `/about`, similar to when you
    do `cd..` in the terminal.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，请求将被重定向到 `/about`，类似于在终端中执行 `cd..`。
- en: 'It is also possible to redirect to the referrer URL using the `back` method.
    If the referrer header is not present in the request, then the request will be
    redirected to `/`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `back` 方法将请求重定向到引用 URL。如果请求中没有引用头，则请求将被重定向到 `/`：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Sending data
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送数据
- en: 'At the beginning of the chapter, we saw how to use `res.render` to render a
    template, but there are other ways to send data to the client. The most common
    way to send data is by using the `send` method, which receives the data as a parameter.
    This can be any type of data, including buffers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到了如何使用 `res.render` 来渲染模板，但还有其他方法可以将数据发送到客户端。最常见的方法是使用 `send` 方法，它将数据作为参数接收。这可以是任何类型的数据，包括缓冲区：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using res.send()
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 res.send()
- en: Under the hood, the `send` method will convert the data to a string and will
    set the `Content-Type` header to `text/html` unless you specify otherwise using
    `res.set()`. It will also include `Content-Length`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`send` 方法会将数据转换为字符串，并将 `Content-Type` 头设置为 `text/html`，除非你使用 `res.set()`
    指定其他内容。它还会包含 `Content-Length`。
- en: 'If you use buffers, the `Content-Type` will be set to `application/octet-stream`
    and `Content-Length` will be set to the length of the buffer, but you can change
    this by using `res.set()`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用缓冲区，`Content-Type` 将被设置为 `application/octet-stream`，`Content-Length` 将被设置为缓冲区的长度，但你可以通过使用
    `res.set()` 来更改这些设置：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using res.json()
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 res.json()
- en: 'If you want to send JSON data, you can use the `json` method directly, which
    receives the data as the first parameter. It will set the `Content-Type` header
    to `application/json` and perform the serialization of the data for you:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要发送 JSON 数据，可以直接使用 `json` 方法，它将数据作为第一个参数接收。它将设置 `Content-Type` 头为 `application/json`
    并为你进行数据的序列化：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is the most common way to send JSON data, but you can also use the `send`
    method and set the `Content-Type` header to `application/json`, performing the
    serialization of the data yourself:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的发送 JSON 数据的方式，但你也可以使用 `send` 方法并设置 `Content-Type` 头为 `application/json`，自行进行数据的序列化：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This can be very useful if you want to use a different stringification library,
    such as `fast-json-stringify` ([https://www.npmjs.com/package/fast-json-stringify](https://www.npmjs.com/package/fast-json-stringify)).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用不同的字符串化库，例如 `fast-json-stringify` ([https://www.npmjs.com/package/fast-json-stringify](https://www.npmjs.com/package/fast-json-stringify))，这将非常有用。
- en: Sending files
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送文件
- en: 'You can send files to the client by using the `sendFile` method, which receives
    the path to the file as the first parameter:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `sendFile` 方法将文件发送到客户端，它将文件路径作为第一个参数接收：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding example, we are sending the `/path/to/file.txt` file to the
    client. This method allows for huge flexibility including a callback to manage
    possible errors. Consult the documentation ([http://expressjs.com/en/4x/api.html#res.sendFile](http://expressjs.com/en/4x/api.html#res.sendFile))
    for more information.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将 `/path/to/file.txt` 文件发送到客户端。这种方法提供了巨大的灵活性，包括一个回调来管理可能出现的错误。请参阅文档
    ([http://expressjs.com/en/4x/api.html#res.sendFile](http://expressjs.com/en/4x/api.html#res.sendFile))
    获取更多信息。
- en: 'Another way to send files is by using the `res.download()` method, which receives
    the path to the file as the first parameter:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 发送文件的另一种方式是使用 `res.download()` 方法，它将文件路径作为第一个参数接收：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method will set the `Content-Disposition` header to `attachment` and the
    `Content-Type` header to `application/octet-stream` unless you specify otherwise
    using `res.set()`. This method allows huge flexibility, including a callback to
    manage possible errors. You can check the documentation ([http://expressjs.com/en/4x/api.html#res.download](http://expressjs.com/en/4x/api.html#res.download))
    for more information.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将设置 `Content-Disposition` 标头为 `attachment`，并将 `Content-Type` 标头设置为 `application/octet-stream`，除非您使用
    `res.set()` 指定其他内容。此方法提供了巨大的灵活性，包括一个回调来管理可能出现的错误。您可以查看文档 ([http://expressjs.com/en/4x/api.html#res.download](http://expressjs.com/en/4x/api.html#res.download))
    获取更多信息。
- en: In the next section, we will learn just how powerful the middleware pattern
    is and how we can use it to build more complex applications.Express is based on
    the middleware pattern, so it is important to understand it because it will allow
    us to extend the capabilities of Express easily.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解中间件模式有多么强大，以及我们如何利用它来构建更复杂的应用程序。Express 基于中间件模式，因此理解它非常重要，因为它将使我们能够轻松扩展
    Express 的功能。
- en: Using the middleware pattern
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件模式
- en: The heart of Express is the middleware pattern, which allows you to extend the
    functionality of the framework by adding functions that will be executed in the
    request-response cycle. The middleware functions are executed in the order that
    they are added to the application, and they can be added to the application or
    alternatively to a route.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Express 的核心是中间件模式，它允许您通过添加将在请求-响应周期中执行的功能来扩展框架的功能。中间件函数按照它们添加到应用程序中的顺序执行，并且可以将它们添加到应用程序或路由中。
- en: '![Figure 10.5 – Middleware pattern full process from application middleware
    to main function](img/B21678_10_5.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 从应用中间件到主函数的中间件模式完整流程](img/B21678_10_5.jpg)'
- en: Figure 10.5 – Middleware pattern full process from application middleware to
    main function
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 从应用中间件到主函数的中间件模式完整流程
- en: We can understand the middleware pattern as a pipeline, where the request is
    passed through the pipeline, and each middleware function can modify the request
    and the response, and pass the request to the next middleware function in the
    pipeline. The middleware functions can also end the request-response cycle by
    sending a response to the client.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将中间件模式理解为一条管道，其中请求通过管道传递，每个中间件函数都可以修改请求和响应，并将请求传递给管道中的下一个中间件函数。中间件函数还可以通过向客户端发送响应来结束请求-响应周期。
- en: '![Figure 10.6 – Middleware pattern limited to Application Middleware](img/B21678_10_6.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 仅限于应用中间件的中间件模式](img/B21678_10_6.jpg)'
- en: Figure 10.6 – Middleware pattern limited to Application Middleware
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 仅限于应用中间件的中间件模式
- en: We can add a global middleware to the application, which will validate whether
    the request is authenticated. When the user is properly authenticated, we can
    pass the request to the next middleware function in the pipeline, and if the user
    is not authenticated, we can end the request-response cycle by sending a response
    to the client with an error message.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向应用程序添加一个全局中间件，以验证请求是否经过认证。当用户正确认证后，我们可以将请求传递给管道中的下一个中间件函数，如果用户未认证，我们可以通过向客户端发送包含错误信息的响应来结束请求-响应周期。
- en: '![Figure 10.7 – Middleware pattern from Application Middleware to Route Middleware](img/B21678_10_7.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 从应用中间件到路由中间件的中间件模式](img/B21678_10_7.jpg)'
- en: Figure 10.7 – Middleware pattern from Application Middleware to Route Middleware
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 从应用中间件到路由中间件的中间件模式
- en: We can also add a middleware function to a route, to validate (for example)
    that the user has the proper permissions to access the route, and if so then we
    can pass the request to the next middleware function in the pipeline, and if the
    user doesn’t have the proper permissions we can end the request-response cycle
    by sending a response to the client with an error message.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向路由添加一个中间件函数，例如验证用户是否有适当的权限访问该路由，如果有，则可以将请求传递给管道中的下一个中间件函数；如果用户没有适当的权限，我们可以通过向客户端发送错误消息来结束请求-响应周期。
- en: '![Figure 10.8 – Middleware pattern  full process from application middleware
    to main function](img/B21678_10_8.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 中间件模式完整流程从应用程序中间件到主函数](img/B21678_10_8.jpg)'
- en: Figure 10.8 – Middleware pattern full process from application middleware to
    main function
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 从应用程序中间件到主函数的中间件模式完整流程
- en: When the main function of the middleware has any kind of problem, such as an
    exception, that doesn’t allow the middleware to continue with the request-response
    cycle, then the error middleware can take control and respond to the client with
    the error message.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当中间件的主要功能出现任何问题，如异常，导致中间件无法继续进行请求-响应周期时，错误中间件可以接管控制权，并向客户端发送错误消息。
- en: As you can see, the middleware pattern is quite complex to get familiar with,
    but at the same time is very powerful, because it allows us to abstract and reuse
    code easily. We can resolve the requests as sequence of functions where each function
    can take ownership when needed so we can isolate the proper business logic quite
    well.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，中间件模式相当复杂，但同时也非常强大，因为它使我们能够轻松地抽象和重用代码。我们可以将请求解析为一系列函数，其中每个函数在需要时可以接管控制权，这样我们就可以很好地隔离适当的业务逻辑。
- en: Understanding the scope
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解作用域
- en: 'So, we have three possible scopes for the middleware functions:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，中间件函数有三个可能的作用域：
- en: '**Global middleware**: This will be executed for all the requests that are
    received by the application.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局中间件**：这将针对应用程序接收到的所有请求执行。'
- en: '**Route middleware**: This will be executed for all the requests that are received
    by the route.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由中间件**：这将针对接收到的所有请求执行。'
- en: '**Error middleware**: This will be executed when an error is thrown by a middleware
    function.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误中间件**：当中间件函数抛出错误时将执行。'
- en: Middleware anatomy
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件结构
- en: 'So, let’s see the anatomy of a middleware function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看中间件函数的结构：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Basically, a middleware function receives three parameters: the request object,
    the response object, and the next function.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，中间件函数接收三个参数：请求对象、响应对象和下一个函数。
- en: Now let’s see what we can do with a middleware function in detail.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细看看我们可以用中间件函数做什么。
- en: Adding context to the request
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向请求添加上下文
- en: 'One very common use case for middleware functions is to add context to the
    request object. The idea is to extend the request object with additional properties
    that will be used by the next middleware functions in the pipeline. Let’s see
    an example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数的一个非常常见的用途是向请求对象添加上下文。想法是扩展请求对象，添加额外的属性，这些属性将被管道中的下一个中间件函数使用。让我们看一个例子：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding example, we are adding a new property to the request object
    called `lang`. This property can be consumed by the next middleware functions
    in the pipeline as `req.lang`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们正在向请求对象添加一个名为`lang`的新属性。该属性可以被管道中的下一个中间件函数作为`req.lang`使用。
- en: This is a very simple example but is quite commonly deployed to create simple
    and focused middleware functions that can be composed easily.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但相当常见，用于创建简单且易于组合的中间件函数。
- en: As you can see, `detectLangMiddleware` is using `next()` to let Express know
    that the middleware has finished and there were no errors. In this case, if we
    don’t call `next()`, the application will hang forever.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`detectLangMiddleware`正在使用`next()`来让Express知道中间件已完成且没有错误。在这种情况下，如果我们不调用`next()`，应用程序将永远挂起。
- en: Managing responses
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理响应
- en: 'Another common use case for middleware functions is to manage the response.
    For example, we can add a middleware function that will redirect the user to [https://updatemybrowser.org/](https://updatemybrowser.org/)
    if the user is using Internet Explorer:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数的另一个常见用途是管理响应。例如，我们可以添加一个中间件函数，如果用户正在使用Internet Explorer，则将用户重定向到[https://updatemybrowser.org/](https://updatemybrowser.org/)：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, if the user is using Internet Explorer, they will be redirected
    to [https://updatemybrowser.org/](https://updatemybrowser.org/). We do not call
    `next()` because we don’t want to continue with the request-response cycle as
    we have already sent a response to the client with `res.redirect()`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果用户正在使用 Internet Explorer，他们将被重定向到 [https://updatemybrowser.org/](https://updatemybrowser.org/)。我们不调用
    `next()`，因为我们不想继续进行请求-响应周期，因为我们已经使用 `res.redirect()` 向客户端发送了响应。
- en: If the user is not using Internet Explorer, we call `next()` to continue with
    the request-response cycle as usual.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有使用 Internet Explorer，我们将调用 `next()` 以继续进行常规的请求-响应周期。
- en: Additional configuration
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外配置
- en: 'In [*Chapter 3*](B21678_03.xhtml#_idTextAnchor056), we learned how closures
    work. It is quite common to use closures to add additional configuration to the
    middleware functions. Let’s see an example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B21678_03.xhtml#_idTextAnchor056) 中，我们学习了闭包的工作原理。使用闭包向中间件函数添加额外配置是很常见的。让我们看看一个例子：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, we have changed the middleware function from before to
    use a closure to receive the default language as a parameter, so we don’t need
    to use `en` by default.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将中间件函数从 `before` 改为使用闭包接收默认语言作为参数，因此我们不需要默认使用 `en`。
- en: 'So now this middleware function will be executed as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在这个中间件函数将按以下方式执行：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is a common pattern for middleware functions that require additional configuration,
    such as the default language in this case, or tokens, and so on.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的中间件函数模式，需要额外的配置，例如本例中的默认语言，或者令牌等。
- en: Testing
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: An additional advantage of this middleware pattern is that we can unit test
    the middleware functions easily because they are just functions that receive a
    request, a response, and a next function as parameters, and then execute them.
    We can mock the request and the response, and we can mock the next function to
    check that the middleware is working properly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这种中间件模式的另一个优点是，我们可以轻松地对中间件函数进行单元测试，因为它们只是接收请求、响应和下一个函数作为参数并执行它们的函数。我们可以模拟请求和响应，并模拟下一个函数以检查中间件是否正常工作。
- en: We will see this in more detail later this chapter, but in the meantime, you
    can check my library called `user-language-middleware` ([https://www.npmjs.com/package/user-language-middleware](https://www.npmjs.com/package/user-language-middleware)).
    The full test suite can be found at [https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js](https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js)
    to get more familiar with the testing of middleware functions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面部分更详细地介绍这一点，但在此期间，您可以检查我名为 `user-language-middleware` 的库 ([https://www.npmjs.com/package/user-language-middleware](https://www.npmjs.com/package/user-language-middleware))。完整的测试套件可以在
    [https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js](https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js)
    找到，以更熟悉中间件函数的测试。
- en: Adding middleware to the application
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向应用程序添加中间件
- en: 'You can add middleware to the application using the `app.use()` method. This
    method receives a middleware function as a parameter and will be executed for
    all the requests received by the application:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `app.use()` 方法向应用程序添加中间件。此方法接收一个中间件函数作为参数，并将为应用程序接收到的所有请求执行：
- en: '[PRE52]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the order of the middleware functions is important because they will
    be executed in the same order that they are added to the application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，中间件函数的顺序很重要，因为它们将以它们被添加到应用程序中的相同顺序执行。
- en: Adding middleware to a route
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向路由添加中间件
- en: 'You can add the middleware to a route the same way that you add it to an application,
    only using the `app.METHOD()` method instead of `app.use()`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `app.METHOD()` 方法而不是 `app.use()` 来以与向应用程序添加相同的方式向路由添加中间件：
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So, `legacyBrowsersMiddleware` will be executed only for the `GET /users` route,
    and if `legacyBrowsersMiddleware` calls `next()` the next middleware function
    in the pipeline will be executed, whichi in this case is `(req, res) => { res.send('Hello`
    `world') }`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`legacyBrowsersMiddleware` 只会在 `GET /users` 路由上执行，如果 `legacyBrowsersMiddleware`
    调用 `next()`，则管道中的下一个中间件函数将被执行，在这种情况下是 `(req, res) => { res.send('Hello world')
    }`。
- en: Yes, we have been using this pattern since the beginning of the chapter! It
    is indeed fair to say *all the routes are middleware functions* *in Express.*
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们自从本章开始就一直使用这种模式！确实可以说 *所有路由都是 Express 中的中间件函数*。
- en: Chaining middleware
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间件链式调用
- en: 'You can chain middleware functions in the same `app.METHOD()` method, simply
    by adding the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一个 `app.METHOD()` 方法中链式调用中间件函数，只需添加以下内容：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is very common in large applications where you have a lot of middleware
    functions that are executed in a specific order. It is a good practice to review
    the order of the middleware functions to avoid unexpected behaviors and to migrate
    them to the application level if they are used in multiple routes, adapting the
    business logic if needed.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这在大型应用中非常常见，其中有很多中间件函数按照特定顺序执行。审查中间件函数的顺序是一个好习惯，以避免意外的行为，如果它们在多个路由中使用，则需要将它们迁移到应用级别，并根据需要调整业务逻辑。
- en: Common middleware used in Express
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Express 中常用的中间件
- en: Historically, the Express team has included some middleware functions in the
    framework, but most of them have been moved to external packages since Express
    4\. However, there are still a few middleware functions included in the framework.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，Express 团队已经在框架中包含了一些中间件函数，但自从 Express 4 以来，大多数中间件函数已经移动到外部包中。然而，框架中仍然包含了一些中间件函数。
- en: Static files
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态文件
- en: 'Express includes a middleware function to serve static files from a directory.
    This is very useful to serve the static assets of a web application, such as images,
    CSS files, or JavaScript files:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Express 包含一个中间件函数，用于从目录中提供静态文件。这对于提供 Web 应用的静态资源，如图像、CSS 文件或 JavaScript 文件非常有用：
- en: '[PRE55]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also use multiple directories to serve static files:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用多个目录来提供静态文件：
- en: '[PRE56]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Error handling
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Express includes a middleware function to handle errors. This middleware function
    must be the last one in the pipeline, and it must receive four parameters instead
    of three. The first parameter is the error, the second is the request, third is
    the response, and the fourth one is the next function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Express 包含一个用于处理错误的中间件函数。这个中间件函数必须是管道中的最后一个，并且它必须接收四个参数而不是三个。第一个参数是错误，第二个是请求，第三个是响应，第四个是下一个函数：
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you have an error in any middleware function, you can call `next(err)` and
    this middleware function will be executed, as it also will if you throw an error
    in a route handler. Let’s see it in action:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在任何中间件函数中遇到错误，你可以调用 `next(err)`，这样这个中间件函数就会被执行，就像你在路由处理程序中抛出错误时一样。让我们看看它是如何工作的：
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you now go to [http://localhost:3000/next-error](http://localhost:3000/next-error)
    or [http://localhost:3000/throw-error](http://localhost:3000/throw-error), you
    will see that the error handler middleware function is taking control.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在访问 [http://localhost:3000/next-error](http://localhost:3000/next-error)
    或 [http://localhost:3000/throw-error](http://localhost:3000/throw-error)，你会看到错误处理中间件函数正在接管控制。
- en: In the next section, we will continue learning about the middleware pattern,
    but we will focus on the third-party middleware functions available in the ecosystem.
    Currently, there is huge amount of middleware functions that you can use in your
    Express applications, so it is important to know how to use them properly. While
    using third-party middleware functions you can save a lot of time and effort,
    you need to be careful because it means adding more dependencies to your project.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续学习中间件模式，但我们将关注生态系统中可用的第三方中间件函数。目前，有大量的中间件函数可以在你的 Express 应用程序中使用，因此了解如何正确使用它们非常重要。虽然使用第三方中间件函数可以节省大量时间和精力，但你必须小心，因为这意味着为你的项目添加更多的依赖项。
- en: Using third-party middleware
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方中间件
- en: There are a lot of third-party middleware functions that you can use in your
    Express applications. Let’s see how to install and use them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的 Express 应用程序中使用许多第三方中间件函数。让我们看看如何安装和使用它们。
- en: One of the most popular middleware functions is `body-parser` ([https://www.npmjs.com/package/body-parser](https://www.npmjs.com/package/body-parser)).
    Basically, it will parse the HTTP body of the incoming request and make it available
    under the `req.body` property.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的中间件函数之一是 `body-parser` ([https://www.npmjs.com/package/body-parser](https://www.npmjs.com/package/body-parser))。基本上，它将解析传入请求的
    HTTP 主体，并将其作为 `req.body` 属性提供。
- en: 'Install it using `npm` as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式使用 `npm` 安装它：
- en: '[PRE59]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then you can import it and use it in your application. Create a new file called
    `echo_payload.js` with the following content:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以导入它并在你的应用中使用它。创建一个名为 `echo_payload.js` 的新文件，并包含以下内容：
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now run the application with `node echo_payload.js` and then use `curl` or
    a similar tool to send a POST request to the `/``echo` route:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用 `node echo_payload.js` 运行应用，然后使用 `curl` 或类似的工具向 `/echo` 路由发送 POST 请求：
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You will see that the response is the same JSON that you sent in the request
    body.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到响应与你在请求体中发送的相同JSON。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the many uses of Express, including how to
    create a basic server, how to add routes, how to add static files, and how to
    use templates.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Express的多种用途，包括如何创建基本服务器、如何添加路由、如何添加静态文件以及如何使用模板。
- en: Additionally, we learned how the middleware pattern works and how we can create
    our own middleware and use it at different levels in our application. We also
    checked out some third-party middleware including `body-parser`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还学习了中间件模式的工作原理以及我们如何创建自己的中间件并在应用程序的不同级别使用它。我们还检查了一些第三方中间件，包括`body-parser`。
- en: In the next chapter, we will learn how to use a super test to test our first
    API in depth. We will cover how to test the routes and the stores and will create
    a solid API that we will develop in the coming chapters.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何深入测试我们的第一个API。我们将涵盖如何测试路由和存储，并创建一个我们将开发在接下来的章节中的稳固API。
- en: Further reading
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Express documentation: [https://expressjs.com/](https://expressjs.com/)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express文档：[https://expressjs.com/](https://expressjs.com/)
- en: '*Express, State of the Union* by Doug Wilson: [https://www.youtube.com/watch?v=HxGt_3F0ULg](https://www.youtube.com/watch?v=HxGt_3F0ULg)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Express，联合大会* 由道格·威尔逊撰写：[https://www.youtube.com/watch?v=HxGt_3F0ULg](https://www.youtube.com/watch?v=HxGt_3F0ULg)'
- en: '*Node.js Foundation to Add Express as an Incubator* *Project*: [https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70](https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Node.js基金会将Express添加为孵化器项目*：[https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70](https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70)'
- en: 'Part 4: Building Solid Web Applications with Node.js'
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：使用Node.js构建稳固的Web应用程序
- en: In *Part 4*, we will build a web application together using Express and MongoDB
    as the main stack. You will learn advanced topics such as error handling or security
    by implementing them in the project while learning all the theories and best practices
    to secure your web application.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第4部分*，我们将一起使用Express和MongoDB作为主要栈来构建一个Web应用程序。你将通过在项目中实现它们来学习高级主题，如错误处理或安全性，同时学习所有理论和最佳实践来确保你的Web应用程序安全。
- en: 'This part includes the following chapters:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 11*](B21678_11.xhtml#_idTextAnchor300), *Building a Web Application
    Project from Scratch*'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21678_11.xhtml#_idTextAnchor300), *从零开始构建Web应用程序项目*'
- en: '[*Chapter 12*](B21678_12.xhtml#_idTextAnchor320), *Data Persistence with MongoDB*'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21678_12.xhtml#_idTextAnchor320), *使用MongoDB进行数据持久化*'
- en: '[*Chapter 13*](B21678_13.xhtml#_idTextAnchor348), *User Authentication and
    Authorization with Passport.js*'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21678_13.xhtml#_idTextAnchor348), *使用Passport.js进行用户身份验证和授权*'
- en: '[*Chapter 14*](B21678_14.xhtml#_idTextAnchor376), *Error handling in Node.js*'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21678_14.xhtml#_idTextAnchor376), *Node.js中的错误处理*'
- en: '[*Chapter 15*](B21678_15.xhtml#_idTextAnchor394), *Securing Web Applications*'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B21678_15.xhtml#_idTextAnchor394), *保护Web应用程序*'
