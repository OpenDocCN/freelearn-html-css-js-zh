- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Web Applications with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express is the most popular web framework for JavaScript and has been the de-facto
    standard for many years. It is a very minimalistic framework, very easy to learn,
    and provides a lot of flexibility to build web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with the most basic “hello world” application
    to build a solid and well-tested REST API application. We will explore in detail
    all the critical components of Express, including request and response, middleware,
    and routing. We will also learn how to use the most common Express middleware
    and how to build our own middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files for your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a server-rendered landing page using template engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a typical CRUD REST API application with Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the most common Express middleware, including third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/8QyDZVa7CNg](https://youtu.be/8QyDZVa7CNg)
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with the Express library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Express is defined on its own website ([https://expressjs.com/](https://expressjs.com/))
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast, unopinionated, minimalist web framework for Node.js
  prefs: []
  type: TYPE_NORMAL
- en: So, the good news is that we have a lot of freedom to build our application.
    The bad news is that we must make a lot of decisions, and we must be careful to
    not make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Express is very minimalistic in comparison with other web frameworks, so we
    have to add third-party libraries or build our own abstractions when needed. Express
    has a very active community, so we can find a lot of libraries to solve common
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the official documentation is of great quality and there are plenty
    of resources to learn more about Express, which makes Express a great choice for
    beginners.
  prefs: []
  type: TYPE_NORMAL
- en: As Express is an unopinionated framework, when you follow a tutorial or a course
    you will find that sometimes the code is not consistent and doesn’t follow the
    same patterns. This is because you have a lot of freedom in Express, and over
    time you will develop your own patterns and your own way of building applications
    that best fits you.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use Express version 4.18.3, but any Express 4.x version
    should be fine as well. We will use Node.js version 20.11.0\. Both are the latest
    versions available at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Express, we must run the following command in a new Node.js project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need any additional configuration; just install it and you are ready
    to go.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a simple example, a Hello World application. Create a new
    file called `helloWorld.js` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Very simple, right? Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: We import the Express library and create an instance of the Express application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a route for the `/` root path and we send a response with the text
    `Hello World` `from Express!`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start the server and listen on port `3000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the application, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is OK, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you open your browser and go to `http://localhost:3000`, you should
    see the text **Hello World from Express!**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Web browser screenshot showing a simple Express project](img/B21678_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Web browser screenshot showing a simple Express project
  prefs: []
  type: TYPE_NORMAL
- en: Using the generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Express has a command-line tool to generate a basic application. To use it,
    we must run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a new application with many files and folders. I recommend
    you create a new folder and run the command there, so you don’t mess up your current
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output on execution should be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the next step is to install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is OK, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you access `http://localhost:3000` in the browser, you should see the following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Web browser screenshot showing the Express app generated using
    the express-generator](img/B21678_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Web browser screenshot showing the Express app generated using
    the `express-generator`
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to explore the generated code, but don’t worry if you don’t understand
    everything as we will cover all the important parts in the following sections.
    Note that also the route [http://localhost:3000/users](http://localhost:3000/users)
    is working and if you try any other route, you will get a 404 error, as with [http://localhost:3000/invented](http://localhost:3000/invented)
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let me show another cool thing that the Express generator includes and
    that we will use in our project later. If you start the application with the command
    `DEBUG=* npm start` or `set DEBUG=* && npm start` (if you use Windows) in the
    terminal output will be more verbose and you will see a lot of information about
    the requests and responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Terminal screenshot](img/B21678_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Terminal screenshot
  prefs: []
  type: TYPE_NORMAL
- en: This is because Express and many other dependencies use the `debug` library
    ([https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug)) to
    log information. By using the `DEBUG=*` environment variable, we are telling to
    debug library to print the information related to all the namespaces. But we can
    be more selective and limit the scope for Express, for example, by using the `DEBUG=express:*
    npm start` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we have a basic understanding of Express, it is time to explore how
    we can use template engines to render the HTML pages that will be sent to the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B21678_09.xhtml#_idTextAnchor244), we learned the difference
    between **single-page applications** (**SPAs**) and server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Express provides a way to render HTML pages using template engines. This is
    the key feature to build server-side rendered applications with Express.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a template engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that we must do is to choose a template engine. There are many
    options available. The most popular option historically was Jade ([https://www.npmjs.com/package/jade](https://www.npmjs.com/package/jade)),
    but it was renamed to Pug ([https://www.npmjs.com/package/pug](https://www.npmjs.com/package/pug)).
    You can find many tutorials and examples by searching using both names.
  prefs: []
  type: TYPE_NORMAL
- en: I personally prefer **Embedded JavaScript templating** (**ejs**) ([https://www.npmjs.com/package/ejs](https://www.npmjs.com/package/ejs))
    for its simplicity and because it is well documented. Over time, you will get
    more familiar with the template engines and will be able to choose the one that
    better fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, going back to our hello world example, let’s create a new file called `helloWorldTemplate.js`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to create a new folder called `views`, inside of which we create
    a new file called `index.ejs` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the template engine uses the `<%=` and `%>` tags to interpolate
    the values. In this case, we are passing the `title` variable to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to install the `ejs` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we start the application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you access `http://localhost:3000` in the browser, you should see the following
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Web browser screenshot showing the templeate rendered for the
    end user.](img/B21678_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Web browser screenshot showing the templeate rendered for the
    end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you access `view-source:http://localhost:3000/`, you will
    see the raw HTML that Express is sending to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the template engine is interpolating the values and generating
    the HTML for us.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s understand what is actually happening in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line tells Express that we are going to use `ejs` as our template
    engine, so now we can use `res.render` to render the template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `res.render` method receives two parameters. The
    first one is the name of the template, in this case, `index` (`views/index.ejs`),
    and the second one is the data that we want to interpolate in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Then the template engine will replace the `<%= title %>` and `<%= subtitle %>`
    tags with the values that we are passing in the second parameter of the `res.render`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, the data that we pass to the template will be dynamic;
    for example, the data that we get from a database or an external API. But for
    now, we are going to use static data to keep the example simple.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how we can take advantage of the request
    object to build more rich and powerful applications.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B21678_09.xhtml#_idTextAnchor244), we learned all the theory
    around HTTP requests and responses. Here, we will cover how to handle these with
    Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to focus on this snippet of pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three elements here to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method`, that is, the HTTP method that we want to handle, for example, `GET`,
    `POST`, `PUT`, `DELETE`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route`, that is, the path that we want to handle, for example, `/`, `/users`,
    or `/users/:id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler`, that is, the callback function that will be executed when `method`
    and `route` match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Express provides a method for each HTTP method. There are many out there (`get`,
    `post`, `put`, `head`, `delete`, `options`, `trace`, `copy`, `lock`, `mkcol`,
    `move`, `purge`, `propfind`, `proppatch`, `unlock`, `report`, `mkactivity`, `checkout`,
    `merge`, `m-search`, `notify`, `subscribe`, `unsubscribe`, `patch`, `search`,
    and `connect`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common are `get`, `post`, `put`, and `delete`, so we are going to
    focus on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to manage all the HTTP methods in the same route, you can use the
    `all` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The routes are very flexible and can be dynamic. We can define them in different
    ways, including regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Static paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Static paths are the most common way of defining routes. They are used to handle
    requests to a specific path, for example, `/`, `/users`, or `/user/me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dynamic parameters are used to handle the requests to a specific path. We can
    use the `:` character to define a dynamic parameter, such as `/users/:id` or `/users/:id/profile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `:id` is a dynamic parameter, so it will match with any value,
    including `/users/1`, `/users/peter`, `/users/jane-doe`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even combine static and dynamic parameters, such as `/users/:id/profile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will resolve requests to `/users/1/profile`, `/users/peter/profile`,
    `/users/jane-doe/profile`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is quite common in transportation apps, for example, where you
    can have a route such as `/users/:id/rides/:rideId` to get the details of a specific
    ride, or when you book tickets for a flight using a route such as `/flights/from/:originCity/to/:destinationCity`.
    Express will provide the values of the dynamic parameters in the `req.params`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Optional parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The optional parameters are used to handle the requests to a specific path,
    but the parameter is optional. This can be done with the `?` character, such as
    `/invoice/:id?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case the `:id` parameter is optional, so it will match with `/invoice`,
    `/invoice/167`, `/invoice/G123S8123SD123MJ`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use regular expressions to define routes. This is quite useful when
    we want to match the route using predictable patterns – for example, `/.*fly$/`
    will identify any text that ends with `fly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding route will match with `/butterfly`, `/dragonfly`, `/fly`, `/mcfly`,
    and so on. Let’s create a less exotic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the route will match with `/msg/1/edit`, `/msg/1/delete`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re unfamiliar with regular expressions, don’t worry: you can use the
    other options to define your routes. But if you want to explore regular expressions
    more deeply, I recommend you to try *Regular Expressions* *101* ([https://regex101.com/](https://regex101.com/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Query params
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B21678_09.xhtml#_idTextAnchor244), we learned about the different
    parts of the URL and saw that the query params are those parts that start with
    `?`. These are used to send extra information to the server. For example, in the
    URL `/films?category=scifi&director=George+Lucas` we are sending two query params,
    `category` and the `director`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can capture the query params in the `req.query` object to use them in our
    routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that query params are optional, meaning that requests
    might not have any query param at all. In that case, the `req.query` object would
    be empty.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: URL fragments (i.e., `/mypath#fragment`) are not part of requests and will not
    be included as such by the browser, so we can’t capture them. See https://github.com/expressjs/express/issues/1083
    for more info.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The routes are registered in the order that you defined them, which allows
    Express to avoid conflicts between routes. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you try to access `/users/me`, you will get the message `You are looking
    for the user with id me` because the `/users/:id` route is registered first, so
    it will match with `/users/me` and the `me` value will be stored in the `req.params.id`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can solve this issue by shifting the order of the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In big projects, this can become a problem if you don’t have a good strategy
    to define the routes. This is also a good reason to include automated tests in
    your project to avoid accidental misconfigurations of routes.
  prefs: []
  type: TYPE_NORMAL
- en: Handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Handlers are the functions that are executed when a request matches with a
    route. While a handler is a simple function with three parameters (`req`, `res`,
    and `next`), it has the big responsibility of handling the response to the request
    or delegating the request to other handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see the parameters of the handler in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The request object (`req`) contains all the information about the request, including
    the parameters, IP, headers, body, and so on. If you use other libraries that
    extend the capabilities of Express, very often you will find more properties in
    this object.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the request object in the Express documentation
    ([https://expressjs.com/en/4x/api.html#req](https://expressjs.com/en/4x/api.html#req)).
  prefs: []
  type: TYPE_NORMAL
- en: response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The response object (`res`) contains all the methods to handle the response
    of the request, including simple methods like `send` or `json` to more complex
    methods like download or redirect.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn more about the response object capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: next
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next function (`next`) is used to delegate the request to the next handler.
    This is useful when you want to split the logic of the handler into multiple functions
    or delegate error management.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn both strategies in the next two sections, when we will discuss
    the middleware pattern and mastering responses.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how we can take advantage of the response
    object and how to customize the responses based on many different scenarios, such
    as HTTP redirection, HTTP header customization, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Responses are the way by which the server communicates back to the client after
    a request, so it is crucial to understand how to manage them. In this section,
    we will learn about adding headers, status codes, redirects, sending data, and
    sending files.
  prefs: []
  type: TYPE_NORMAL
- en: You will discover the available methods when you start to build more complex
    applications. You can find more information about the response object in the Express
    documentation ([https://expressjs.com/en/4x/api.html#res](https://expressjs.com/en/4x/api.html#res)).
  prefs: []
  type: TYPE_NORMAL
- en: Header management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Headers are used to send extra information about the response. Express handles
    headers by using the `set` method, which receives two parameters, the name of
    the header and the value of the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are setting the `Content-Type` header to `text/html`
    so the browser will know that the response is an HTML document and will render
    it as HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the `set` method to set multiple headers at the same time
    by passing an object as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are setting two headers, `Content-Type` and `x-powered-by`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can remove a header by using the `removeHeader` method, which receives
    the name of the header as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are removing the `x-powered-by` header that we
    just added in the previous statement.
  prefs: []
  type: TYPE_NORMAL
- en: Status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A status code is a number that represents the status of the response. It is
    used to communicate the status of the request to the client. It is important to
    use the correct status code, as it is part of the HTTP protocol that we discussed
    in [*Chapter 9*](B21678_09.xhtml#_idTextAnchor244).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manage status codes using the `status` method, which receives the status
    code as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are setting the status code to `200`, which means
    that the request was successful, By default, Express will set the status code
    to `200` if you don’t set it.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can chain the `status` method with other methods, such as `set` or `send`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Sending status codes only
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to send only the status code, you can use the `sendStatus` method,
    which receives the status code as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are sending the `500` status code, which means
    that the request was not successful.
  prefs: []
  type: TYPE_NORMAL
- en: Redirects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can redirect the request to another URL by using the `redirect` method,
    which receives the URL as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are redirecting the request to [https://ulisesgascon.com](https://ulisesgascon.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The default status code for redirects is `302`, but you can change this by
    specifying the status code as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `redirect` method also accepts relative URLs, so you can redirect to another
    route in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even redirect to a higher level in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the request will be redirected to `/about`, similar to when you
    do `cd..` in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to redirect to the referrer URL using the `back` method.
    If the referrer header is not present in the request, then the request will be
    redirected to `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Sending data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning of the chapter, we saw how to use `res.render` to render a
    template, but there are other ways to send data to the client. The most common
    way to send data is by using the `send` method, which receives the data as a parameter.
    This can be any type of data, including buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Using res.send()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under the hood, the `send` method will convert the data to a string and will
    set the `Content-Type` header to `text/html` unless you specify otherwise using
    `res.set()`. It will also include `Content-Length`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use buffers, the `Content-Type` will be set to `application/octet-stream`
    and `Content-Length` will be set to the length of the buffer, but you can change
    this by using `res.set()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using res.json()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to send JSON data, you can use the `json` method directly, which
    receives the data as the first parameter. It will set the `Content-Type` header
    to `application/json` and perform the serialization of the data for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the most common way to send JSON data, but you can also use the `send`
    method and set the `Content-Type` header to `application/json`, performing the
    serialization of the data yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This can be very useful if you want to use a different stringification library,
    such as `fast-json-stringify` ([https://www.npmjs.com/package/fast-json-stringify](https://www.npmjs.com/package/fast-json-stringify)).
  prefs: []
  type: TYPE_NORMAL
- en: Sending files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can send files to the client by using the `sendFile` method, which receives
    the path to the file as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are sending the `/path/to/file.txt` file to the
    client. This method allows for huge flexibility including a callback to manage
    possible errors. Consult the documentation ([http://expressjs.com/en/4x/api.html#res.sendFile](http://expressjs.com/en/4x/api.html#res.sendFile))
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to send files is by using the `res.download()` method, which receives
    the path to the file as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This method will set the `Content-Disposition` header to `attachment` and the
    `Content-Type` header to `application/octet-stream` unless you specify otherwise
    using `res.set()`. This method allows huge flexibility, including a callback to
    manage possible errors. You can check the documentation ([http://expressjs.com/en/4x/api.html#res.download](http://expressjs.com/en/4x/api.html#res.download))
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn just how powerful the middleware pattern
    is and how we can use it to build more complex applications.Express is based on
    the middleware pattern, so it is important to understand it because it will allow
    us to extend the capabilities of Express easily.
  prefs: []
  type: TYPE_NORMAL
- en: Using the middleware pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of Express is the middleware pattern, which allows you to extend the
    functionality of the framework by adding functions that will be executed in the
    request-response cycle. The middleware functions are executed in the order that
    they are added to the application, and they can be added to the application or
    alternatively to a route.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Middleware pattern full process from application middleware
    to main function](img/B21678_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Middleware pattern full process from application middleware to
    main function
  prefs: []
  type: TYPE_NORMAL
- en: We can understand the middleware pattern as a pipeline, where the request is
    passed through the pipeline, and each middleware function can modify the request
    and the response, and pass the request to the next middleware function in the
    pipeline. The middleware functions can also end the request-response cycle by
    sending a response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Middleware pattern limited to Application Middleware](img/B21678_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Middleware pattern limited to Application Middleware
  prefs: []
  type: TYPE_NORMAL
- en: We can add a global middleware to the application, which will validate whether
    the request is authenticated. When the user is properly authenticated, we can
    pass the request to the next middleware function in the pipeline, and if the user
    is not authenticated, we can end the request-response cycle by sending a response
    to the client with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Middleware pattern from Application Middleware to Route Middleware](img/B21678_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Middleware pattern from Application Middleware to Route Middleware
  prefs: []
  type: TYPE_NORMAL
- en: We can also add a middleware function to a route, to validate (for example)
    that the user has the proper permissions to access the route, and if so then we
    can pass the request to the next middleware function in the pipeline, and if the
    user doesn’t have the proper permissions we can end the request-response cycle
    by sending a response to the client with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Middleware pattern  full process from application middleware
    to main function](img/B21678_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Middleware pattern full process from application middleware to
    main function
  prefs: []
  type: TYPE_NORMAL
- en: When the main function of the middleware has any kind of problem, such as an
    exception, that doesn’t allow the middleware to continue with the request-response
    cycle, then the error middleware can take control and respond to the client with
    the error message.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the middleware pattern is quite complex to get familiar with,
    but at the same time is very powerful, because it allows us to abstract and reuse
    code easily. We can resolve the requests as sequence of functions where each function
    can take ownership when needed so we can isolate the proper business logic quite
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, we have three possible scopes for the middleware functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global middleware**: This will be executed for all the requests that are
    received by the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Route middleware**: This will be executed for all the requests that are received
    by the route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error middleware**: This will be executed when an error is thrown by a middleware
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware anatomy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, let’s see the anatomy of a middleware function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, a middleware function receives three parameters: the request object,
    the response object, and the next function.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see what we can do with a middleware function in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Adding context to the request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One very common use case for middleware functions is to add context to the
    request object. The idea is to extend the request object with additional properties
    that will be used by the next middleware functions in the pipeline. Let’s see
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are adding a new property to the request object
    called `lang`. This property can be consumed by the next middleware functions
    in the pipeline as `req.lang`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple example but is quite commonly deployed to create simple
    and focused middleware functions that can be composed easily.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `detectLangMiddleware` is using `next()` to let Express know
    that the middleware has finished and there were no errors. In this case, if we
    don’t call `next()`, the application will hang forever.
  prefs: []
  type: TYPE_NORMAL
- en: Managing responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common use case for middleware functions is to manage the response.
    For example, we can add a middleware function that will redirect the user to [https://updatemybrowser.org/](https://updatemybrowser.org/)
    if the user is using Internet Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if the user is using Internet Explorer, they will be redirected
    to [https://updatemybrowser.org/](https://updatemybrowser.org/). We do not call
    `next()` because we don’t want to continue with the request-response cycle as
    we have already sent a response to the client with `res.redirect()`.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is not using Internet Explorer, we call `next()` to continue with
    the request-response cycle as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Additional configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B21678_03.xhtml#_idTextAnchor056), we learned how closures
    work. It is quite common to use closures to add additional configuration to the
    middleware functions. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have changed the middleware function from before to
    use a closure to receive the default language as a parameter, so we don’t need
    to use `en` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now this middleware function will be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is a common pattern for middleware functions that require additional configuration,
    such as the default language in this case, or tokens, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An additional advantage of this middleware pattern is that we can unit test
    the middleware functions easily because they are just functions that receive a
    request, a response, and a next function as parameters, and then execute them.
    We can mock the request and the response, and we can mock the next function to
    check that the middleware is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: We will see this in more detail later this chapter, but in the meantime, you
    can check my library called `user-language-middleware` ([https://www.npmjs.com/package/user-language-middleware](https://www.npmjs.com/package/user-language-middleware)).
    The full test suite can be found at [https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js](https://github.com/UlisesGascon/user-language-middleware/blob/main/__tests__/userLanguageMiddleware.test.js)
    to get more familiar with the testing of middleware functions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding middleware to the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add middleware to the application using the `app.use()` method. This
    method receives a middleware function as a parameter and will be executed for
    all the requests received by the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order of the middleware functions is important because they will
    be executed in the same order that they are added to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding middleware to a route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add the middleware to a route the same way that you add it to an application,
    only using the `app.METHOD()` method instead of `app.use()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So, `legacyBrowsersMiddleware` will be executed only for the `GET /users` route,
    and if `legacyBrowsersMiddleware` calls `next()` the next middleware function
    in the pipeline will be executed, whichi in this case is `(req, res) => { res.send('Hello`
    `world') }`.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we have been using this pattern since the beginning of the chapter! It
    is indeed fair to say *all the routes are middleware functions* *in Express.*
  prefs: []
  type: TYPE_NORMAL
- en: Chaining middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can chain middleware functions in the same `app.METHOD()` method, simply
    by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is very common in large applications where you have a lot of middleware
    functions that are executed in a specific order. It is a good practice to review
    the order of the middleware functions to avoid unexpected behaviors and to migrate
    them to the application level if they are used in multiple routes, adapting the
    business logic if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Common middleware used in Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, the Express team has included some middleware functions in the
    framework, but most of them have been moved to external packages since Express
    4\. However, there are still a few middleware functions included in the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Static files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Express includes a middleware function to serve static files from a directory.
    This is very useful to serve the static assets of a web application, such as images,
    CSS files, or JavaScript files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use multiple directories to serve static files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Express includes a middleware function to handle errors. This middleware function
    must be the last one in the pipeline, and it must receive four parameters instead
    of three. The first parameter is the error, the second is the request, third is
    the response, and the fourth one is the next function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an error in any middleware function, you can call `next(err)` and
    this middleware function will be executed, as it also will if you throw an error
    in a route handler. Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If you now go to [http://localhost:3000/next-error](http://localhost:3000/next-error)
    or [http://localhost:3000/throw-error](http://localhost:3000/throw-error), you
    will see that the error handler middleware function is taking control.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will continue learning about the middleware pattern,
    but we will focus on the third-party middleware functions available in the ecosystem.
    Currently, there is huge amount of middleware functions that you can use in your
    Express applications, so it is important to know how to use them properly. While
    using third-party middleware functions you can save a lot of time and effort,
    you need to be careful because it means adding more dependencies to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of third-party middleware functions that you can use in your
    Express applications. Let’s see how to install and use them.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular middleware functions is `body-parser` ([https://www.npmjs.com/package/body-parser](https://www.npmjs.com/package/body-parser)).
    Basically, it will parse the HTTP body of the incoming request and make it available
    under the `req.body` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it using `npm` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can import it and use it in your application. Create a new file called
    `echo_payload.js` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application with `node echo_payload.js` and then use `curl` or
    a similar tool to send a POST request to the `/``echo` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the response is the same JSON that you sent in the request
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the many uses of Express, including how to
    create a basic server, how to add routes, how to add static files, and how to
    use templates.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we learned how the middleware pattern works and how we can create
    our own middleware and use it at different levels in our application. We also
    checked out some third-party middleware including `body-parser`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use a super test to test our first
    API in depth. We will cover how to test the routes and the stores and will create
    a solid API that we will develop in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Express documentation: [https://expressjs.com/](https://expressjs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Express, State of the Union* by Doug Wilson: [https://www.youtube.com/watch?v=HxGt_3F0ULg](https://www.youtube.com/watch?v=HxGt_3F0ULg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Node.js Foundation to Add Express as an Incubator* *Project*: [https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70](https://nodejs.medium.com/node-js-foundation-to-add-express-as-an-incubator-project-225fa3008f70)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 4: Building Solid Web Applications with Node.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 4*, we will build a web application together using Express and MongoDB
    as the main stack. You will learn advanced topics such as error handling or security
    by implementing them in the project while learning all the theories and best practices
    to secure your web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21678_11.xhtml#_idTextAnchor300), *Building a Web Application
    Project from Scratch*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21678_12.xhtml#_idTextAnchor320), *Data Persistence with MongoDB*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B21678_13.xhtml#_idTextAnchor348), *User Authentication and
    Authorization with Passport.js*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B21678_14.xhtml#_idTextAnchor376), *Error handling in Node.js*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B21678_15.xhtml#_idTextAnchor394), *Securing Web Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
