- en: Storage APIs in JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的存储API
- en: Imagine you're on Facebook and have logged in to your account. You see your
    news feed; everything looks normal. Next, you click on a post, and you're made
    to log in again. That's strange. You continue and log in one more time, and the
    post opens. You click on a link in a comment, and you're made to log in yet again.
    What is happening?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在使用Facebook并登录到了你的账户。你看到了你的新闻动态；一切看起来都很正常。接下来，你点击了一个帖子，然后被要求再次登录。这很奇怪。你继续操作并再次登录，帖子才打开。你点击了一条评论中的链接，然后又被要求再次登录。这是怎么回事？
- en: That's what would happen if we lived in a world without storage APIs on the
    frontend.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们生活在一个前端没有存储API的世界里，会发生这样的事情。
- en: 'In this chapter, we''ll take a look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: How the internet works because of cookies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是如何因为cookies而工作的
- en: Different forms of data storage areas available in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中可用的不同数据存储区域形式
- en: Methods associated with `localStorage` and `sessionStorage` objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`localStorage`和`sessionStorage`对象相关的方法
- en: An introduction to `indexedDB`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexedDB`简介'
- en: How to use `indexedDB` to perform basic adding, deleting, and reading operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`indexedDB`执行基本的添加、删除和读取操作
- en: HyperText Transfer Protocol (HTTP)
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超文本传输协议（HTTP）
- en: 'HTTP is a stateless protocol. A stateless protocol means that there is no state
    being stored on the server, which, in turn, means that the server forgets everything
    once it has sent a response to the client. Consider the following situation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一个无状态协议。无状态协议意味着服务器上没有存储任何状态，这反过来意味着服务器在向客户端发送响应后就会忘记一切。考虑以下情况：
- en: You've typed `http://example.com` in your browser. When your request hits the
    server, the server is aware of your IP address, your requested page, and any other
    headers associated with your HTTP request. It fetches the content from the filesystem
    or database, sends the response to you, and then forgets about it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你在你的浏览器中输入了`http://example.com`。当你的请求到达服务器时，服务器知道你的IP地址、你请求的页面以及与你的HTTP请求相关的任何其他头信息。它从文件系统或数据库中获取内容，将响应发送给你，然后忘记这一切。
- en: Upon every new HTTP request, the client and server interact as if they're meeting
    for the first time. So, doesn't that mean our earlier Facebook example is true
    in the real world as well?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个新的HTTP请求中，客户端和服务器都会像第一次见面一样互动。那么，这难道不是意味着我们之前的Facebook例子在现实世界中也是正确的吗？
- en: Essentially, that is the case. All websites use **cookies** for authentication
    purposes, which is a way to fake the statefulness of a protocol. Remove cookies
    from every request and you will be able to see the raw, stateless HTTP protocol
    in front of you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，情况就是这样。所有网站都使用**cookies**进行身份验证，这是一种模拟协议状态性的方法。从每个请求中移除cookies，你将能够看到你面前的原始、无状态的HTTP协议。
- en: What is a TLS/SSL handshake?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是TLS/SSL握手？
- en: Let's take a minute to understand what the **Transport Layer Security** (**TLS**)/**Secure
    Sockets Layer **(**SSL**) is before actually diving into what the heck a handshake
    is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解握手是什么之前，让我们花一分钟来理解一下**传输层安全性**（**TLS**）/**安全套接字层**（**SSL**）是什么。
- en: First of all, we should note that TLS is just an upgraded, and more modern,
    version of SSL. So, what's SSL?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该注意，TLS只是SSL的一个升级版，一个更现代的版本。那么，SSL是什么呢？
- en: SSL is a standard within security protocols for setting up an encrypted and
    secure tunnel between your computer and the remote server. It prevents somebody
    who is eavesdropping on your internet connection, say your **Internet Service
    Provider** (**ISP**), from stealing data that is transferred over the network.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SSL是安全协议中的一个标准，用于在您的计算机和远程服务器之间建立一个加密和安全的隧道。它阻止了正在监听您互联网连接的人，比如您的**互联网服务提供商**（**ISP**），窃取通过网络传输的数据。
- en: On every major site these days, you will see a green lock to the left of the
    URL inside the browser. That is a symbol of security, and it means that your browser
    is using TLS/SSL encryption to communicate with the server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的每个主要网站上，你都会在浏览器中URL的左侧看到一个绿色的锁。这是安全的象征，这意味着你的浏览器正在使用TLS/SSL加密与服务器进行通信。
- en: Now, what is a handshake? Just like the literal meaning, a handshake is where
    your browser and server exchange the cryptographic keys they'll use in each communication
    to encrypt or decrypt the messages sent by one another.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，什么是握手？正如字面意义，握手是浏览器和服务器交换它们在每次通信中使用的加密密钥的地方，用于加密或解密彼此发送的消息。
- en: Why are we discussing TLS/SSL? It is because TLS/SSL handshakes are expensive
    on performance. They are not really expensive when there is just one handshake,
    but they start to become a problem if we introduce the concept of statelessness.
    This means that your browser and server forget that they already know each other's
    cryptographic keys with every request. This means that your browser and server
    need to perform a TLS handshake with every request, which will make everything
    quite slow. To avoid this, the TLS/SSL protocol is actually a stateful protocol.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要讨论TLS/SSL？这是因为TLS/SSL握手在性能上很昂贵。当只有一次握手时，它们并不真正昂贵，但如果我们引入无状态的概念，它们就会开始成为一个问题。这意味着你的浏览器和服务器会在每次请求时忘记他们已经知道彼此的加密密钥。这意味着你的浏览器和服务器需要为每次请求执行TLS握手，这将使一切变得相当缓慢。为了避免这种情况，TLS/SSL协议实际上是一个有状态的协议。
- en: The reason why HTTP is so scalable is that it is stateless. Stateful protocols
    such as TLS and SSL are heavy to implement logically. If you want to know more
    about how TLS/SSL works, read here: https://security.stackexchange.com/a/20833/44281
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP之所以如此可扩展，是因为它是无状态的。有状态的协议，如TLS和SSL，在逻辑实现上较为复杂。如果你想了解更多关于TLS/SSL的工作原理，请阅读以下内容：https://security.stackexchange.com/a/20833/44281
- en: Mimicking an HTTP state
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模仿HTTP状态
- en: Using a cookie is a way to store a small amount of data related to a user visiting
    your site. You'll learn more about cookies in the next section. Whatever you store
    in cookies on a particular website is attached to every HTTP request to that site.
    So, basically, your HTTP protocol transfers a string of cookies on every request
    that allows the server to store some sort of information related to each client
    connected to it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cookie是一种存储与访问你网站的用户相关的小量数据的方式。你将在下一节中了解更多关于cookie的内容。你在特定网站上存储在cookie中的任何内容都会附加到对该网站的每个HTTP请求上。所以，基本上，你的HTTP协议在每次请求中都会传输一个cookie字符串，这允许服务器存储与每个连接到它的客户端相关的一些信息。
- en: When we add custom headers to our `XMLHttpRequest` (remember T*he* *Fetch API
    customizations* section from the preceding chapter?), it makes it easy to fake
    our own state on the HTTP protocol. An authorization header is one more header
    that is sent by the browser on every request if it is set.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向我们的`XMLHttpRequest`添加自定义头（记得上一章中的“T*he* *Fetch API自定义”部分？），这使得在HTTP协议上伪造我们的状态变得容易。授权头是浏览器在每次请求中发送的另一个头，如果设置了的话。
- en: Let's now actually take a look at these storage areas, such as cookies, `localStorage`,
    `sessionStorage`, and `indexedDB`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们实际来看看这些存储区域，比如cookie、`localStorage`、`sessionStorage`和`indexedDB`。
- en: Storing data with cookies
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cookie存储数据
- en: Cookies are little strings, which, once set for a domain and path, are sent
    over and over to the server for every request. This is perfect for authentication,
    but not so good if you're using them to store some data that you need only once
    or that you need to access only on the frontend, such as a player's score in a
    game whose results you are not storing on the server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies是一些小字符串，一旦为某个域和路径设置，就会在每次请求中反复发送到服务器。这对于身份验证来说很完美，但如果你使用它们来存储你只需要一次或需要在前端访问的数据，比如你不在服务器上存储结果的某个游戏的玩家得分，那么就不是很理想。
- en: People usually use cookies to store heavy data to make it available on some
    other path on the domain. This is a bad practice because you're transferring that
    data to the server all the time, and, if that data is heavy, it'll make your communication
    slow.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常使用cookie来存储大量数据，以便在域的某些其他路径上可用。这是一种不良做法，因为你会不断地将数据传输到服务器，如果数据量很大，这会使你的通信变慢。
- en: Setting cookies
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置cookie
- en: 'Let''s take a look at how to access and set cookies using JavaScript:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用JavaScript访问和设置cookie：
- en: 'Information found within a cookie is in the `key=value;` format. Let us create
    some cookies in the browser using the code snippet below:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在cookie中的信息以`key=value;`格式存在。让我们使用下面的代码片段在浏览器中创建一些cookie：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Warning: Strange behavior ahead!**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：前方有奇怪的行为！**'
- en: 'What do you expect to be logged here? The answer is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望在这里记录什么？答案是如下：
- en: '![](img/dfc57c9d-6d9e-4bae-9703-6c6ae5c42f4c.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfc57c9d-6d9e-4bae-9703-6c6ae5c42f4c.png)'
- en: Why, and why wasn't the `document.cookie` object overwritten? All will be explained
    in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么没有覆盖`document.cookie`对象？所有这些内容将在下一节中解释。
- en: The document.cookie is a strange object
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: document.cookie是一个奇怪的对象
- en: As you saw earlier, `document.cookie` shows a special behavior. Instead of replacing
    all cookies, it updates the variable to the new cookie. This behavior is implemented
    by a document that is actually called a **host object** instead of a native object.
    Host objects have the power to do anything, as they don't need to follow the semantics
    for regular objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，`document.cookie`显示了一种特殊的行为。它不是替换所有cookie，而是将变量更新为新cookie。这种行为是通过一个实际上被称为**宿主对象**的文档实现的，而不是原生对象。宿主对象具有做任何事的能力，因为它们不需要遵循常规对象的语义。
- en: Host objects are actually the objects provided in a particular environment--in
    our case, the browser. When JavaScript runs on the server (Node.js), you do not
    have access to a document or window. That means they're host objects--that is,
    dependent on hosts and implemented by hosts (browsers).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 宿主对象实际上是在特定环境中提供的对象--在我们的案例中，是浏览器。当JavaScript在服务器（Node.js）上运行时，您无法访问document或window。这意味着它们是宿主对象--也就是说，依赖于宿主并由宿主实现（浏览器）。
- en: In this case, `document.cookie` overrides the assignment operator to actually
    append the value to the variable instead of modifying it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`document.cookie`覆盖了赋值运算符，实际上是将值附加到变量而不是修改它。
- en: More technical information about `[[PutValue]]` from the specs can be found
    at [http://es5.github.io/#x8.7.2](http://es5.github.io/#x8.7.2).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`[[PutValue]]`的更多技术信息可以在[http://es5.github.io/#x8.7.2](http://es5.github.io/#x8.7.2)找到。
- en: The question is now how do we remove the cookies we set? We'll take a look in
    the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何删除我们设置的cookie？我们将在下一节中查看。
- en: Deleting cookies
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除cookie
- en: To delete a cookie, you return to the cookie and then specify an expiry date
    for it. After which, the browser will delete the cookie and no longer send it
    to the server on every request.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除cookie，您需要回到cookie并为其指定一个过期日期。之后，浏览器将删除cookie，并且不再在每次请求时将其发送到服务器。
- en: 'Here''s how to implement that in code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在代码中实现它的示例：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`1 January 1970 00:00:00` is as far back in time as we can go, as JavaScript
    follows Unix''s timestamp. The output for the preceding code is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`1970年1月1日 00:00:00`是我们可以追溯的时间点，因为JavaScript遵循Unix的时间戳。前面代码的输出如下：'
- en: '![](img/f8928628-f65c-4d1e-9174-3a5a98dd70a0.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8928628-f65c-4d1e-9174-3a5a98dd70a0.png)'
- en: Getting a cookie value
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取cookie值
- en: 'JavaScript doesn''t provide any convenient way out of the box to actually get
    a cookie value. All we have is just a bunch of random cookies together in a string,
    which is accessible by `document.cookie`. We will need to do some work, as shown
    in the following snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有提供任何方便的方法来直接获取cookie值。我们只有一串随机cookie，可以通过`document.cookie`访问。我们需要做一些工作，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output will be, therefore, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输出将如下所示：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see in the highlighted part of the image below, when we reload the
    page, the set cookies are sent to the server at every request:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在下面图像的高亮部分中可以看到，当我们重新加载页面时，设置的cookie会在每次请求时发送到服务器：
- en: '![](img/f837637f-0e47-4107-9058-0015e37a2284.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f837637f-0e47-4107-9058-0015e37a2284.png)'
- en: These will later become accessible by the server, depending on the backend language
    you're using.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些cookie将随后由服务器访问，具体取决于您使用的后端语言。
- en: Working with localStorage
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与localStorage一起工作
- en: The `localStorage` object is available in all major browsers. It was introduced
    in HTML5\. Local storage allows you to store data persistently on a user's computer.
    Unless your script or user explicitly want to clear the data, the data will remain.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`对象在所有主要浏览器中都是可用的。它是在HTML5中引入的。本地存储允许您在用户的计算机上持久存储数据。除非您的脚本或用户明确想要清除数据，否则数据将保持不变。'
- en: Local storage follows the same origin policy. We will discuss origin policy
    in detail in the next chapter, but, for now, just understand that the same origin
    policies can restrict different websites and their access to a particular website's
    local storage.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储遵循相同的源策略。我们将在下一章中详细讨论源策略，但就目前而言，只需了解相同的源策略可以限制不同网站及其对特定网站本地存储的访问。
- en: In addition, keep in mind that key-value pairs in local storage can only be
    string values. To store objects, you'll have to `JSON.stringify` them first.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，localStorage中的键值对只能是字符串值。要存储对象，您必须首先使用`JSON.stringify`对其进行序列化。
- en: Creating a local storage entry
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地存储条目
- en: 'We can add entries to local storage in a more intuitive and convenient way
    than cookies. Here''s what the syntax looks like using `localStorage.setItem(key,
    value)`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以比cookie更直观和方便的方式向本地存储添加条目。以下是使用`localStorage.setItem(key, value)`的语法：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `localStorage` is a synchronous API. It'll block the thread execution until
    completed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`是一个同步API。它会在完成之前阻塞线程执行。'
- en: 'Let''s now quickly, and roughly, determine how much time on average `localStorage.setItem`
    takes, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们快速、粗略地确定`localStorage.setItem`平均需要多少时间，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result, as you can see, is not that bad:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果并不那么糟糕：
- en: '![](img/28972abb-1380-4ba0-b5ec-5293ac906dec.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28972abb-1380-4ba0-b5ec-5293ac906dec.png)'
- en: So, it roughly takes around `0.02` milliseconds for one operation. That's good
    going for a regular application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个操作大约需要`0.02`毫秒。这对于一个常规应用来说已经很不错了。
- en: Getting a stored item
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取存储的项目
- en: A stored item inside a session storage object can be accessed using the `localStorage.getItem`,  `localStorage.key`, or `localStorage['key']` methods.
    We'll take a look at this in more detail a little later, in the `localStorage.getItem('key')`
    versus `localStorage.key` section, where we'll see which method is the best and
    why not to use other methods; now, though, let's stick with the `localStorage.getItem`
    method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`localStorage.getItem`、`localStorage.key`或`localStorage['key']`方法访问session存储对象中的存储项目。我们将在稍后的`localStorage.getItem('key')`与`localStorage.key`部分更详细地探讨这个问题，我们将看到哪种方法是最好的，以及为什么不要使用其他方法；现在，尽管如此，让我们坚持使用`localStorage.getItem`方法。
- en: 'It''s easy to get stored items from local storage, as shown in the following
    snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地存储中获取存储的项目很容易，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Removing a stored item
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除存储的项目
- en: You can remove a single item from the `localStorage` object. For this, you will
    need to have the key of the key-value pair you want to remove. This could be anything
    you no longer need.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`localStorage`对象中删除单个项目。为此，你需要有你想删除的键值对的键。这可能是一切你不再需要的东西。
- en: 'Accessing it further in your code will result in `null`, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中进一步访问它将导致`null`，如下所示：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Clearing all the items
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除所有项目
- en: 'Sometimes, you might find while experimenting that you''ve put a lot of useless
    key-value pairs inside your storage. You can clear them all at once with the `clear` method
    in local storage. You can do that with the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在实验过程中，你可能会发现你在存储中放入了很多无用的键值对。你可以使用本地存储中的`clear`方法一次性清除它们。你可以用以下命令做到这一点：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: localStorage.getItem('key') versus localStorage.key versus localStorage['key']
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`localStorage.getItem(''key'')`与`localStorage.key`与`localStorage[''key'']`'
- en: 'All three, `localStorage.getItem(''key'')`, `localStorage.key`, and `localStorage[''key'']` methods,
    do the same thing. However, it is advisable to use the provided methods for the
    following reasons:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个方法，`localStorage.getItem('key')`、`localStorage.key`和`localStorage['key']`，都做同样的事情。然而，出于以下原因，建议使用提供的方法：
- en: '`localStorage.getItem(''key-does-not-exist'')` returns `null`, whereas `localStorage[''key-does-not-exist'']`
    will return `undefined`. In JavaScript, `null` is not equal to `undefined`.  For
    example, suppose that you want to set a key that is actually the property of an
    object as well, or as a function name, such as `getItem` and `setItem`. In this
    case, you''re better off with the `getItem` approach, as follows:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage.getItem(''key-does-not-exist'')`返回`null`，而`localStorage[''key-does-not-exist'']`将返回`undefined`。在JavaScript中，`null`不等于`undefined`。例如，假设你想要设置一个实际上是对象属性或函数名称的键，比如`getItem`和`setItem`。在这种情况下，你最好使用`getItem`方法，如下所示：'
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you accidentally used the notation `#2` instead of `#1` to store a number,
    `localStorage` will  overwrite the `getItem` function, and you will no longer
    be able to access it, as shown in the following snippet:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你意外地使用了`#2`而不是`#1`来存储一个数字，`localStorage`将覆盖`getItem`函数，你将无法再访问它，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The takeaway here is to use the `getItem`, `setItem`, and other methods on `localStorage`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的经验是使用`localStorage`上的`getItem`、`setItem`和其他方法。
- en: Working with SessionStorage
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与SessionStorage一起工作
- en: Session storage is just like local storage, with the exception that session
    storage is not persistent. That means whenever you close even the tab that sets
    the session storage, your data will be lost.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Session存储就像本地存储一样，只是session存储不是持久的。这意味着每次你关闭设置session存储的标签页时，你的数据都会丢失。
- en: A case where session storage could be useful could be when you have an Ajax-based
    website that loads everything dynamically. You want to create a state-like object,
    which you can use to store the state of the interface so that, when a user returns
    to a page they have already visited, you can easily restore the state of that
    page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 会话存储可能有用的情况之一是当你有一个基于Ajax的网站，该网站动态加载一切。你想要创建一个类似状态的对象，你可以使用它来存储界面的状态，这样当用户返回他们已经访问过的页面时，你可以轻松地恢复该页面的状态。
- en: Let's now quickly go over all the methods of session storage.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们快速浏览一下会话存储的所有方法。
- en: Creating a session storage entry
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建会话存储条目
- en: To create a key-value pair inside the `sessionStorage` object, you can use the
    `setItem` method, similar to the `localStorage` object. Just like `localStorage`,
    `sessionStorage` is also a synchronous API, so you can be sure that you'll immediately
    have access to whatever values you're storing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`sessionStorage`对象中创建键值对，你可以使用`setItem`方法，类似于`localStorage`对象。就像`localStorage`一样，`sessionStorage`也是一个同步API，所以你可以确信你将立即能够访问你存储的任何值。
- en: 'Adding an item to session storage is just like working with local storage,
    as shown in the following snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 向会话存储中添加项目就像处理本地存储一样，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Getting a stored item
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取存储项
- en: A stored item inside the `sessionStorage` object can be accessed using the `sessionStorage.getItem`,  `sessionStorage.key`,
    or `sessionStorage['key']` methods. However, as with `localStorage`,  it is advisable
    to make use of `getItem` to safely get the right storage value instead of a property
    of the `sessionStorage` object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`sessionStorage.getItem`、`sessionStorage.key`或`sessionStorage['key']`方法访问`sessionStorage`对象中的存储项。然而，与`localStorage`一样，建议使用`getItem`来安全地获取正确的存储值，而不是`sessionStorage`对象的属性。
- en: 'The following snippet demonstrates how to get a stored item from session storage:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何从会话存储中获取存储项：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Removing a stored item
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除存储的项目
- en: You can remove a single item from the `sessionStorage` object. For this, you
    will need to have the key of the key-value pair you want to remove. This could
    be anything you no longer need.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`sessionStorage`对象中移除单个项目。为此，你需要拥有你想要移除的键值对的键。这可以是任何你不再需要的东西。
- en: 'Accessing it further in your code will result in `null`, as shown in the following
    snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中进一步访问它将导致`null`，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Clearing all items
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除所有项目
- en: 'Sometimes, you might find while experimenting that you''ve put a lot of useless
    key-value pairs inside your storage. You can clear them all at once with the `clear`
    method in session storage, as shown in the following snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在实验过程中，你可能会发现你在存储中放入了大量的无用键值对。你可以使用会话存储中的`clear`方法一次性清除它们，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Handling storage changes across multiple tabs
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个标签页之间的存储更改
- en: Storage, when changed, emits certain events that can be captured by other opened
    tabs. You can set event listeners for them to listen and perform any appropriate
    modifications.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当存储发生变化时，会发出某些事件，其他打开的标签页可以捕获这些事件。你可以为它们设置事件监听器来监听并执行任何适当的修改。
- en: For example, let's say that you added something to `localStorage` in one tab
    of your website. A user has also opened another tab of your website. If you want
    to reflect the changes of `localStorage` in that tab, you can listen to the storage
    event and update the contents accordingly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你在网站的一个标签页中添加了`localStorage`。一个用户也打开了你的网站的另一个标签页。如果你想反映该标签页中`localStorage`的变化，你可以监听存储事件并相应地更新内容。
- en: 'Note that the update event will be fired on every other tab except the one
    that made the change:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，更新事件将在除了更改的那个标签页之外的所有其他标签页上触发：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code produces the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码产生以下输出：
- en: '![](img/9a1d606d-b132-464b-95cf-a355a338d1db.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a1d606d-b132-464b-95cf-a355a338d1db.png)'
- en: You can note that it contains a lot of useful information about the storage
    event.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到它包含有关存储事件的大量有用信息。
- en: The web workers (discussed in Chapter 11) do not have access to local storage
    or session storage.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工作者（在第11章中讨论）无法访问本地存储或会话存储。
- en: Cookies versus local storage
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与本地存储相比的Cookies
- en: 'By now, you may have observed that cookies and local storage serve almost completely
    different purposes. The only thing they have in common is that they store data.
    The following is a brief comparison of cookies and local storage:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经观察到cookies和本地存储几乎完全服务于不同的目的。它们唯一共同的地方是它们存储数据。以下是对cookies和本地存储的简要比较：
- en: '| **Cookies** | **Local** **storage** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **Cookies** | **Local** **storage** |'
- en: '| Cookies are transferred to a server on every request automatically by the
    browser | To transfer local storage data to a server, you need to manually send
    an Ajax request or send it through hidden form fields |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器会在每次请求时自动将cookies传输到服务器 | 要将本地存储数据传输到服务器，你需要手动发送Ajax请求或通过隐藏表单字段发送 |'
- en: '| If data needs to be accessed and read both by the client and server, use
    cookies | If the data needs to be accessed and read only by the client, use local
    storage |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 如果数据需要由客户端和服务器同时访问和读取，请使用cookies | 如果数据只需要由客户端访问和读取，请使用本地存储 |'
- en: '| Cookies can have an expiration date, after which they are automatically deleted
    | Local storage provides no such expiration date feature; it can only be cleared
    by JavaScript |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| Cookies可以设置过期日期，过期后它们将被自动删除 | 本地存储不提供此类过期日期功能；它只能通过JavaScript清除 |'
- en: '| The maximum size of a cookie is 4 KB | The maximum size of local storage
    depends on the browser and platform, but it is usually around 5 MB per domain
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 一个cookie的最大大小是4 KB | 本地存储的最大大小取决于浏览器和平台，但通常每个域大约是5 MB |'
- en: The indexedDB - storing large data
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`indexedDB` - 存储大量数据'
- en: The `indexedDB` is a relatively new and low-level API compared to the other
    storage mediums we've already discussed. It is used to store large amounts of
    data compared to local storage. However, the drawback of this is that it is difficult
    to be used and set up.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们已讨论的其他存储介质相比，`indexedDB`是一个相对较新且底层的API。它用于存储比本地存储更大的数据量。然而，这个缺点是它难以使用和设置。
- en: What you can do with local storage in a few lines may take a lot of lines and
    callbacks in `indexedDB`. Therefore, be careful when using it. If you're using
    it in your application, we recommend that you use popular wrappers instead of
    directly writing the endpoints, as that will make things easier.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用几行代码在本地存储中完成的事情，在`indexedDB`中可能需要很多行代码和回调。因此，在使用它时要小心。如果你在应用程序中使用它，我们建议你使用流行的包装器而不是直接编写端点，这样会使事情更容易。
- en: The `indexedDB` is so vast that it would be fair to say it deserves a whole
    chapter on its own. We can't cover each and every aspect in this chapter, but
    we'll try to convey the key information required.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexedDB`如此庞大，可以说它值得拥有自己的一整章。我们无法在本章中涵盖每个方面，但我们会尽力传达所需的关键信息。'
- en: Opening an indexedDB database
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开`indexedDB`数据库
- en: 'The `indexedDB` object is available on the `window` object. You will need to
    actually open a database in order to store data in `indexedDB`, shown as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexedDB`对象在`window`对象上可用。你需要实际打开一个数据库才能在`indexedDB`中存储数据，如下所示：'
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You have to first request to open the database from `indexedDB`. The first parameter
    here is the name of your database. If it doesn't exist, it'll be created automatically.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须首先从`indexedDB`请求打开数据库。这里的第一个参数是数据库的名称。如果它不存在，它将被自动创建。
- en: The second parameter is the version number of the database. What that means
    is that you can assign a version number to every database schema, which is useful
    in the following example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是数据库的版本号。这意味着你可以为每个数据库模式分配一个版本号，这在以下示例中很有用。
- en: Consider that you shipped your application that is using `indexedDB`. Now, `indexedDB`
    consists of a database schema, which lays down certain rules on how the data should
    look in the database, its data types, and so on. However, you soon realize that
    you need to update your database design. Now, you can ship your production code
    with  `indexedDB.open`, but with a higher version. This further enables you to
    know within your code that your older database schema may be incompatible with
    the new one.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你已发布了使用`indexedDB`的应用程序。现在，`indexedDB`由一个数据库模式组成，它规定了数据在数据库中应如何呈现，其数据类型等规则。然而，你很快就会意识到你需要更新你的数据库设计。现在，你可以通过`indexedDB.open`将生产代码与更高版本一起发布，这进一步使你能够在代码中知道你的旧数据库模式可能与新版本不兼容。
- en: If the database already existed and you opened it with a higher version number
    (say 2, in our case), then it'll fire the `upgradeneeded` event, which you can
    handle in the code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库已经存在，并且你用更高的版本号（比如我们案例中的2）打开它，那么它将触发`upgradeneeded`事件，你可以在代码中处理该事件。
- en: Version numbers only supports integers. Any floating number passed will be rounded
    off to the closest lower integer. For example, passing 2.3 as a version number
    is the same as passing 2.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号仅支持整数。任何传递的浮点数都将四舍五入到最接近的较低整数。例如，将2.3作为版本号与传递2相同。
- en: Handling the upgradeneeded event
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理`upgradeneeded`事件
- en: 'As discussed previously, we can now handle the `upgradeneeded` event. As we
    have just created the database for the first time, the following `upgradeneeded`
    event will be fired:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在可以处理`upgradeneeded`事件。由于我们刚刚第一次创建了数据库，下面的`upgradeneeded`事件将会被触发：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Okay, in the preceding code, we got the `IDBDatabase` object handler, which
    we call  `dbHandler`, by calling `open.result`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在上面的代码中，我们通过调用`open.result`得到了`IDBDatabase`对象处理器，我们称之为`dbHandler`。
- en: Then, we created something called an object store in `indexedDB`. Object stores
    are like tables in `indexedDB`, where the data is stored in the form of key-value
    pairs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`indexedDB`中创建了一个名为对象存储的东西。对象存储类似于`indexedDB`中的表，其中数据以键值对的形式存储。
- en: Adding data to object stores
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向对象存储中添加数据
- en: 'We can use  `storeHandler` to actually put data inside a table with the following
    code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`storeHandler`通过以下代码将数据实际放入一个表中：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's take a moment to understand what just happened. By calling `storeHandler.add()`,
    we were able to add data to our `frontend` table inside our `types` database (version
    1). The first argument--that is, our passed object--is the value, which can be
    an object in `indexedDB`. Values can only be strings in `localStorage`. The second
    argument--that is, `HTML5`--is the name of our key.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来理解刚刚发生了什么。通过调用`storeHandler.add()`，我们能够将数据添加到我们的`types`数据库（版本1）中的`frontend`表中。第一个参数——即我们传递的对象——是值，它可以是`indexedDB`中的对象。值只能是`localStorage`中的字符串。第二个参数——即`HTML5`——是我们键的名称。
- en: 'The result should look like the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像以下屏幕截图：
- en: '![](img/c64b446b-e55c-44a9-a186-b3c01f784f75.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c64b446b-e55c-44a9-a186-b3c01f784f75.png)'
- en: In the preceding screenshot, you should be able to see the `indexedDB`, `types`
    database, and then a table called `frontend` that stores the key as `HTML5` and
    the value as our supplied object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你应该能够看到`indexedDB`、`types`数据库，然后是一个名为`frontend`的表，该表将键存储为`HTML5`，将值存储为我们提供的对象。
- en: Reading data from object stores
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从对象存储中读取数据
- en: Whenever a connection is established, the `onsuccess` event is fired. Only read-write
    operations in the `onupgradeneeded` work because it won't be fired if the version
    number of the database is not increased.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每当建立连接时，`onsuccess`事件就会被触发。只有`onupgradeneeded`中的读写操作才会工作，因为如果数据库的版本号没有增加，它就不会被触发。
- en: As a matter of fact, we recommend changing the database schema from the `onupgradeneeded`
    event. When you're in `onsuccess`, perform only the CRUD operations (which are
    Create, Update, Retrieve, and Delete).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们建议从`onupgradeneeded`事件中更改数据库模式。当你处于`onsuccess`时，只执行CRUD操作（即创建、更新、检索和删除）。
- en: 'We can do our operations inside the `success` event with the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`success`事件内部使用以下代码执行我们的操作：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the program is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result is exactly the same as the data we stored earlier, but what are
    the transactions? They are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前存储的数据完全相同，但事务是什么呢？它们如下所示：
- en: The `indexedDB` uses transactions to perform reading and writing over the database
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexedDB`使用事务来在数据库上执行读取和写入操作。'
- en: We first open a transaction to our database `frontend` in the `readonly` mode;
    the other mode is the `readwrite` mode, which is used when you want to write to
    the database as well
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先以`readonly`模式打开数据库`frontend`的事务；另一种模式是`readwrite`模式，当你想向数据库写入时使用。
- en: From that transaction, we then get `storeHandler`, which is the same as the
    store handler we had in an earlier section when we created the store
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从那个事务中，我们得到了`storeHandler`，这与我们在早期部分创建存储时拥有的存储处理器相同。
- en: Now, we make use of the `get` method to get the value associated with the key
    we stored
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们使用`get`方法获取与我们存储的键关联的值。
- en: We then wait for `req` to call the `success` event, on which we console log
    the target result value, which is nothing but our stored object
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们等待`req`调用`success`事件，在事件中我们在控制台日志中记录目标结果值，这实际上就是我们的存储对象。
- en: Deleting data from object stores
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从对象存储中删除数据
- en: 'Similar to writing and reading, we can also delete data from the object store,
    as well, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与写入和读取类似，我们也可以从对象存储中删除数据，如下所示：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The only thing we did here was using the `delete` method. Note that we have
    to give the `readwrite` access to the transaction in order to delete the record.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们唯一做的事情是使用`delete`方法。请注意，我们必须给事务提供`readwrite`访问权限才能删除记录。
- en: It's recommended that you go through MDN documents to get a deeper insight on
    how to make `indexedDB` work in big projects; you can find them at [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您阅读 MDN 文档以深入了解如何在大型项目中使 `indexedDB` 正常工作；您可以在[https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB)找到它们。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Great! That's one more concept we've now equipped ourselves with. In this chapter,
    you learned how to store data on the client side effectively, and how cookies
    are sent automatically to the server by browsers. In the next two chapters, we
    will dive deep into web workers and shared memory, which can create some very
    powerful stuff when combined together. Let's go!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这又是一个我们已掌握的概念。在本章中，您学习了如何有效地在客户端存储数据，以及浏览器如何自动将 cookies 发送到服务器。在接下来的两个章节中，我们将深入探讨
    web workers 和共享内存，当它们结合在一起时可以创建一些非常强大的功能。让我们开始吧！
