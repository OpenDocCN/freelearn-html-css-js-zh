- en: Storage APIs in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you're on Facebook and have logged in to your account. You see your
    news feed; everything looks normal. Next, you click on a post, and you're made
    to log in again. That's strange. You continue and log in one more time, and the
    post opens. You click on a link in a comment, and you're made to log in yet again.
    What is happening?
  prefs: []
  type: TYPE_NORMAL
- en: That's what would happen if we lived in a world without storage APIs on the
    frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How the internet works because of cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different forms of data storage areas available in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods associated with `localStorage` and `sessionStorage` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to `indexedDB`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `indexedDB` to perform basic adding, deleting, and reading operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HyperText Transfer Protocol (HTTP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP is a stateless protocol. A stateless protocol means that there is no state
    being stored on the server, which, in turn, means that the server forgets everything
    once it has sent a response to the client. Consider the following situation:'
  prefs: []
  type: TYPE_NORMAL
- en: You've typed `http://example.com` in your browser. When your request hits the
    server, the server is aware of your IP address, your requested page, and any other
    headers associated with your HTTP request. It fetches the content from the filesystem
    or database, sends the response to you, and then forgets about it.
  prefs: []
  type: TYPE_NORMAL
- en: Upon every new HTTP request, the client and server interact as if they're meeting
    for the first time. So, doesn't that mean our earlier Facebook example is true
    in the real world as well?
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, that is the case. All websites use **cookies** for authentication
    purposes, which is a way to fake the statefulness of a protocol. Remove cookies
    from every request and you will be able to see the raw, stateless HTTP protocol
    in front of you.
  prefs: []
  type: TYPE_NORMAL
- en: What is a TLS/SSL handshake?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a minute to understand what the **Transport Layer Security** (**TLS**)/**Secure
    Sockets Layer **(**SSL**) is before actually diving into what the heck a handshake
    is.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we should note that TLS is just an upgraded, and more modern,
    version of SSL. So, what's SSL?
  prefs: []
  type: TYPE_NORMAL
- en: SSL is a standard within security protocols for setting up an encrypted and
    secure tunnel between your computer and the remote server. It prevents somebody
    who is eavesdropping on your internet connection, say your **Internet Service
    Provider** (**ISP**), from stealing data that is transferred over the network.
  prefs: []
  type: TYPE_NORMAL
- en: On every major site these days, you will see a green lock to the left of the
    URL inside the browser. That is a symbol of security, and it means that your browser
    is using TLS/SSL encryption to communicate with the server.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is a handshake? Just like the literal meaning, a handshake is where
    your browser and server exchange the cryptographic keys they'll use in each communication
    to encrypt or decrypt the messages sent by one another.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we discussing TLS/SSL? It is because TLS/SSL handshakes are expensive
    on performance. They are not really expensive when there is just one handshake,
    but they start to become a problem if we introduce the concept of statelessness.
    This means that your browser and server forget that they already know each other's
    cryptographic keys with every request. This means that your browser and server
    need to perform a TLS handshake with every request, which will make everything
    quite slow. To avoid this, the TLS/SSL protocol is actually a stateful protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why HTTP is so scalable is that it is stateless. Stateful protocols
    such as TLS and SSL are heavy to implement logically. If you want to know more
    about how TLS/SSL works, read here: https://security.stackexchange.com/a/20833/44281
  prefs: []
  type: TYPE_NORMAL
- en: Mimicking an HTTP state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a cookie is a way to store a small amount of data related to a user visiting
    your site. You'll learn more about cookies in the next section. Whatever you store
    in cookies on a particular website is attached to every HTTP request to that site.
    So, basically, your HTTP protocol transfers a string of cookies on every request
    that allows the server to store some sort of information related to each client
    connected to it.
  prefs: []
  type: TYPE_NORMAL
- en: When we add custom headers to our `XMLHttpRequest` (remember T*he* *Fetch API
    customizations* section from the preceding chapter?), it makes it easy to fake
    our own state on the HTTP protocol. An authorization header is one more header
    that is sent by the browser on every request if it is set.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now actually take a look at these storage areas, such as cookies, `localStorage`,
    `sessionStorage`, and `indexedDB`.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data with cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies are little strings, which, once set for a domain and path, are sent
    over and over to the server for every request. This is perfect for authentication,
    but not so good if you're using them to store some data that you need only once
    or that you need to access only on the frontend, such as a player's score in a
    game whose results you are not storing on the server.
  prefs: []
  type: TYPE_NORMAL
- en: People usually use cookies to store heavy data to make it available on some
    other path on the domain. This is a bad practice because you're transferring that
    data to the server all the time, and, if that data is heavy, it'll make your communication
    slow.
  prefs: []
  type: TYPE_NORMAL
- en: Setting cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to access and set cookies using JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Information found within a cookie is in the `key=value;` format. Let us create
    some cookies in the browser using the code snippet below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning: Strange behavior ahead!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you expect to be logged here? The answer is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfc57c9d-6d9e-4bae-9703-6c6ae5c42f4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Why, and why wasn't the `document.cookie` object overwritten? All will be explained
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The document.cookie is a strange object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw earlier, `document.cookie` shows a special behavior. Instead of replacing
    all cookies, it updates the variable to the new cookie. This behavior is implemented
    by a document that is actually called a **host object** instead of a native object.
    Host objects have the power to do anything, as they don't need to follow the semantics
    for regular objects.
  prefs: []
  type: TYPE_NORMAL
- en: Host objects are actually the objects provided in a particular environment--in
    our case, the browser. When JavaScript runs on the server (Node.js), you do not
    have access to a document or window. That means they're host objects--that is,
    dependent on hosts and implemented by hosts (browsers).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `document.cookie` overrides the assignment operator to actually
    append the value to the variable instead of modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: More technical information about `[[PutValue]]` from the specs can be found
    at [http://es5.github.io/#x8.7.2](http://es5.github.io/#x8.7.2).
  prefs: []
  type: TYPE_NORMAL
- en: The question is now how do we remove the cookies we set? We'll take a look in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To delete a cookie, you return to the cookie and then specify an expiry date
    for it. After which, the browser will delete the cookie and no longer send it
    to the server on every request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to implement that in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`1 January 1970 00:00:00` is as far back in time as we can go, as JavaScript
    follows Unix''s timestamp. The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8928628-f65c-4d1e-9174-3a5a98dd70a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting a cookie value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript doesn''t provide any convenient way out of the box to actually get
    a cookie value. All we have is just a bunch of random cookies together in a string,
    which is accessible by `document.cookie`. We will need to do some work, as shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be, therefore, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the highlighted part of the image below, when we reload the
    page, the set cookies are sent to the server at every request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f837637f-0e47-4107-9058-0015e37a2284.png)'
  prefs: []
  type: TYPE_IMG
- en: These will later become accessible by the server, depending on the backend language
    you're using.
  prefs: []
  type: TYPE_NORMAL
- en: Working with localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `localStorage` object is available in all major browsers. It was introduced
    in HTML5\. Local storage allows you to store data persistently on a user's computer.
    Unless your script or user explicitly want to clear the data, the data will remain.
  prefs: []
  type: TYPE_NORMAL
- en: Local storage follows the same origin policy. We will discuss origin policy
    in detail in the next chapter, but, for now, just understand that the same origin
    policies can restrict different websites and their access to a particular website's
    local storage.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, keep in mind that key-value pairs in local storage can only be
    string values. To store objects, you'll have to `JSON.stringify` them first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a local storage entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add entries to local storage in a more intuitive and convenient way
    than cookies. Here''s what the syntax looks like using `localStorage.setItem(key,
    value)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `localStorage` is a synchronous API. It'll block the thread execution until
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now quickly, and roughly, determine how much time on average `localStorage.setItem`
    takes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result, as you can see, is not that bad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28972abb-1380-4ba0-b5ec-5293ac906dec.png)'
  prefs: []
  type: TYPE_IMG
- en: So, it roughly takes around `0.02` milliseconds for one operation. That's good
    going for a regular application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a stored item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stored item inside a session storage object can be accessed using the `localStorage.getItem`,  `localStorage.key`, or `localStorage['key']` methods.
    We'll take a look at this in more detail a little later, in the `localStorage.getItem('key')`
    versus `localStorage.key` section, where we'll see which method is the best and
    why not to use other methods; now, though, let's stick with the `localStorage.getItem`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to get stored items from local storage, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Removing a stored item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can remove a single item from the `localStorage` object. For this, you will
    need to have the key of the key-value pair you want to remove. This could be anything
    you no longer need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing it further in your code will result in `null`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Clearing all the items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you might find while experimenting that you''ve put a lot of useless
    key-value pairs inside your storage. You can clear them all at once with the `clear` method
    in local storage. You can do that with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: localStorage.getItem('key') versus localStorage.key versus localStorage['key']
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All three, `localStorage.getItem(''key'')`, `localStorage.key`, and `localStorage[''key'']` methods,
    do the same thing. However, it is advisable to use the provided methods for the
    following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localStorage.getItem(''key-does-not-exist'')` returns `null`, whereas `localStorage[''key-does-not-exist'']`
    will return `undefined`. In JavaScript, `null` is not equal to `undefined`.  For
    example, suppose that you want to set a key that is actually the property of an
    object as well, or as a function name, such as `getItem` and `setItem`. In this
    case, you''re better off with the `getItem` approach, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you accidentally used the notation `#2` instead of `#1` to store a number,
    `localStorage` will  overwrite the `getItem` function, and you will no longer
    be able to access it, as shown in the following snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The takeaway here is to use the `getItem`, `setItem`, and other methods on `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SessionStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session storage is just like local storage, with the exception that session
    storage is not persistent. That means whenever you close even the tab that sets
    the session storage, your data will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: A case where session storage could be useful could be when you have an Ajax-based
    website that loads everything dynamically. You want to create a state-like object,
    which you can use to store the state of the interface so that, when a user returns
    to a page they have already visited, you can easily restore the state of that
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now quickly go over all the methods of session storage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a session storage entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a key-value pair inside the `sessionStorage` object, you can use the
    `setItem` method, similar to the `localStorage` object. Just like `localStorage`,
    `sessionStorage` is also a synchronous API, so you can be sure that you'll immediately
    have access to whatever values you're storing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding an item to session storage is just like working with local storage,
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Getting a stored item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stored item inside the `sessionStorage` object can be accessed using the `sessionStorage.getItem`,  `sessionStorage.key`,
    or `sessionStorage['key']` methods. However, as with `localStorage`,  it is advisable
    to make use of `getItem` to safely get the right storage value instead of a property
    of the `sessionStorage` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet demonstrates how to get a stored item from session storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Removing a stored item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can remove a single item from the `sessionStorage` object. For this, you
    will need to have the key of the key-value pair you want to remove. This could
    be anything you no longer need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing it further in your code will result in `null`, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Clearing all items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you might find while experimenting that you''ve put a lot of useless
    key-value pairs inside your storage. You can clear them all at once with the `clear`
    method in session storage, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Handling storage changes across multiple tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storage, when changed, emits certain events that can be captured by other opened
    tabs. You can set event listeners for them to listen and perform any appropriate
    modifications.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say that you added something to `localStorage` in one tab
    of your website. A user has also opened another tab of your website. If you want
    to reflect the changes of `localStorage` in that tab, you can listen to the storage
    event and update the contents accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the update event will be fired on every other tab except the one
    that made the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a1d606d-b132-464b-95cf-a355a338d1db.png)'
  prefs: []
  type: TYPE_IMG
- en: You can note that it contains a lot of useful information about the storage
    event.
  prefs: []
  type: TYPE_NORMAL
- en: The web workers (discussed in Chapter 11) do not have access to local storage
    or session storage.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies versus local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, you may have observed that cookies and local storage serve almost completely
    different purposes. The only thing they have in common is that they store data.
    The following is a brief comparison of cookies and local storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Cookies** | **Local** **storage** |'
  prefs: []
  type: TYPE_TB
- en: '| Cookies are transferred to a server on every request automatically by the
    browser | To transfer local storage data to a server, you need to manually send
    an Ajax request or send it through hidden form fields |'
  prefs: []
  type: TYPE_TB
- en: '| If data needs to be accessed and read both by the client and server, use
    cookies | If the data needs to be accessed and read only by the client, use local
    storage |'
  prefs: []
  type: TYPE_TB
- en: '| Cookies can have an expiration date, after which they are automatically deleted
    | Local storage provides no such expiration date feature; it can only be cleared
    by JavaScript |'
  prefs: []
  type: TYPE_TB
- en: '| The maximum size of a cookie is 4 KB | The maximum size of local storage
    depends on the browser and platform, but it is usually around 5 MB per domain
    |'
  prefs: []
  type: TYPE_TB
- en: The indexedDB - storing large data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `indexedDB` is a relatively new and low-level API compared to the other
    storage mediums we've already discussed. It is used to store large amounts of
    data compared to local storage. However, the drawback of this is that it is difficult
    to be used and set up.
  prefs: []
  type: TYPE_NORMAL
- en: What you can do with local storage in a few lines may take a lot of lines and
    callbacks in `indexedDB`. Therefore, be careful when using it. If you're using
    it in your application, we recommend that you use popular wrappers instead of
    directly writing the endpoints, as that will make things easier.
  prefs: []
  type: TYPE_NORMAL
- en: The `indexedDB` is so vast that it would be fair to say it deserves a whole
    chapter on its own. We can't cover each and every aspect in this chapter, but
    we'll try to convey the key information required.
  prefs: []
  type: TYPE_NORMAL
- en: Opening an indexedDB database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `indexedDB` object is available on the `window` object. You will need to
    actually open a database in order to store data in `indexedDB`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You have to first request to open the database from `indexedDB`. The first parameter
    here is the name of your database. If it doesn't exist, it'll be created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is the version number of the database. What that means
    is that you can assign a version number to every database schema, which is useful
    in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that you shipped your application that is using `indexedDB`. Now, `indexedDB`
    consists of a database schema, which lays down certain rules on how the data should
    look in the database, its data types, and so on. However, you soon realize that
    you need to update your database design. Now, you can ship your production code
    with  `indexedDB.open`, but with a higher version. This further enables you to
    know within your code that your older database schema may be incompatible with
    the new one.
  prefs: []
  type: TYPE_NORMAL
- en: If the database already existed and you opened it with a higher version number
    (say 2, in our case), then it'll fire the `upgradeneeded` event, which you can
    handle in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Version numbers only supports integers. Any floating number passed will be rounded
    off to the closest lower integer. For example, passing 2.3 as a version number
    is the same as passing 2.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the upgradeneeded event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed previously, we can now handle the `upgradeneeded` event. As we
    have just created the database for the first time, the following `upgradeneeded`
    event will be fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Okay, in the preceding code, we got the `IDBDatabase` object handler, which
    we call  `dbHandler`, by calling `open.result`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we created something called an object store in `indexedDB`. Object stores
    are like tables in `indexedDB`, where the data is stored in the form of key-value
    pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to object stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use  `storeHandler` to actually put data inside a table with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a moment to understand what just happened. By calling `storeHandler.add()`,
    we were able to add data to our `frontend` table inside our `types` database (version
    1). The first argument--that is, our passed object--is the value, which can be
    an object in `indexedDB`. Values can only be strings in `localStorage`. The second
    argument--that is, `HTML5`--is the name of our key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c64b446b-e55c-44a9-a186-b3c01f784f75.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you should be able to see the `indexedDB`, `types`
    database, and then a table called `frontend` that stores the key as `HTML5` and
    the value as our supplied object.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from object stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a connection is established, the `onsuccess` event is fired. Only read-write
    operations in the `onupgradeneeded` work because it won't be fired if the version
    number of the database is not increased.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, we recommend changing the database schema from the `onupgradeneeded`
    event. When you're in `onsuccess`, perform only the CRUD operations (which are
    Create, Update, Retrieve, and Delete).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do our operations inside the `success` event with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is exactly the same as the data we stored earlier, but what are
    the transactions? They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `indexedDB` uses transactions to perform reading and writing over the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We first open a transaction to our database `frontend` in the `readonly` mode;
    the other mode is the `readwrite` mode, which is used when you want to write to
    the database as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From that transaction, we then get `storeHandler`, which is the same as the
    store handler we had in an earlier section when we created the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we make use of the `get` method to get the value associated with the key
    we stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then wait for `req` to call the `success` event, on which we console log
    the target result value, which is nothing but our stored object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting data from object stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to writing and reading, we can also delete data from the object store,
    as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The only thing we did here was using the `delete` method. Note that we have
    to give the `readwrite` access to the transaction in order to delete the record.
  prefs: []
  type: TYPE_NORMAL
- en: It's recommended that you go through MDN documents to get a deeper insight on
    how to make `indexedDB` work in big projects; you can find them at [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great! That's one more concept we've now equipped ourselves with. In this chapter,
    you learned how to store data on the client side effectively, and how cookies
    are sent automatically to the server by browsers. In the next two chapters, we
    will dive deep into web workers and shared memory, which can create some very
    powerful stuff when combined together. Let's go!
  prefs: []
  type: TYPE_NORMAL
