<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Your First Spec</h1></div></div></div><p>This chapter is about the basics, and we are going to guide you through how to write your first spec, think in test-first terms for development, and also show you all the available global Jasmine functions. By the end of the chapter, you should know how Jasmine works and be ready to start doing your first tests by yourself.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>The Investment Tracker application</h1></div></div></div><p>To get you started, we <a id="id20" class="indexterm"/>need an example scenario: consider that you are developing an application to track investments in the stock market.</p><p>The following screenshot of the form illustrates how a user might create a new investment on this application:</p><div><img src="img/B04138_02_01.jpg" alt="The Investment Tracker application"/><div><p>This is a form to add investments</p></div></div><p>This form will allow the input of three values that define an investment:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we will input <strong>Symbol</strong>, which represents which company (stock) the user is investing in</li><li class="listitem" style="list-style-type: disc">Then, we will input how many <strong>Shares</strong> the user has bought (or invested in)</li><li class="listitem" style="list-style-type: disc">Finally, we will input how much the user has paid for each share (<strong>Share price</strong>)</li></ul></div><p>If you are unfamiliar with how the stock market works, imagine you are shopping for groceries. To make a purchase, you must specify what you are buying, how many items you are buying, and <a id="id21" class="indexterm"/>how much you are going to pay. These concepts translate to an investment as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A stock, which is defined by a symbol, such as <code class="literal">PETO</code>, can be understood to be a grocery type</li><li class="listitem" style="list-style-type: disc">The number of shares is the quantity of items you have purchased</li><li class="listitem" style="list-style-type: disc">The share price is the unit price of each item</li></ul></div><p>Once the user has added an investment, it must be listed along with their other investments, as shown in the following screenshot:</p><div><img src="img/B04138_02_02.jpg" alt="The Investment Tracker application"/><div><p>This is a form and list of investments</p></div></div><p>The idea is to display how well their investments are going. Since the prices of the stocks fluctuate over time, the difference between the price the user has paid and the current price indicates whether it is a good (profit) or a bad (loss) investment.</p><p>In the preceding screenshot, we can see that the user has two investments:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One is in the <code class="literal">AOUE</code> stock, which is scoring a profit of <code class="literal">101.80%</code></li><li class="listitem" style="list-style-type: disc">Another is in the <code class="literal">PETO</code> stock, which is scoring a loss of <code class="literal">-42.34%</code></li></ul></div><p>This is a very simple application, and we will get a deeper understanding of its functionality as we go on with its development.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Jasmine basics and thinking in BDD</h1></div></div></div><p>Based on the application<a id="id22" class="indexterm"/> presented previously, we can start writing acceptance criteria that define investment:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Given an investment, it should be of a stock</li><li class="listitem" style="list-style-type: disc">Given an investment, it should have the invested shares' quantity</li><li class="listitem" style="list-style-type: disc">Given an investment, it should have the share price paid</li><li class="listitem" style="list-style-type: disc">Given an investment, it should have a cost</li></ul></div><p>Using the standalone distribution downloaded in the previous chapter, the first thing we need to do is create a new spec file. This file can be created anywhere, but it is a good idea to stick to a convention, and Jasmine already has a good one: specs should be in the <code class="literal">/spec</code> folder. Create an <code class="literal">InvestmentSpec.js</code> file and add the following lines:</p><div><pre class="programlisting">describe("Investment", function() {

});</pre></div><p>The <code class="literal">describe</code> function<a id="id23" class="indexterm"/> is a global Jasmine function used to define test contexts. When used as the first call in a spec, it creates a new test suite (a collection of test cases). It accepts two parameters, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name of the test suite—in this case, <code class="literal">Investment</code></li><li class="listitem" style="list-style-type: disc">A <code class="literal">function</code> that will contain all its specs</li></ul></div><p>Then, to translate the first acceptance criterion (given an investment, it should be of a stock) into a Jasmine spec (or test case), we are going to use another global Jasmine function called <code class="literal">it</code>:</p><div><pre class="programlisting">describe("Investment", function() {
  <strong>it("should be of a stock", function() {</strong>

  <strong>});</strong>
});</pre></div><p>It also accepts two parameters, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The title of the spec—in this case, <code class="literal">should be of a stock</code></li><li class="listitem" style="list-style-type: disc">A function that will contain the spec code</li></ul></div><p>To run this spec, add it to the runner, as follows:</p><div><pre class="programlisting">&lt;!-- include spec files here... --&gt;
<strong>&lt;script type="text/javascript" src="img/InvestmentSpec.js"&gt;&lt;/script&gt;</strong>
</pre></div><p>Execute the spec by opening the runner on the browser. The following output can be seen:</p><div><img src="img/B04138_02_03.jpg" alt="Jasmine basics and thinking in BDD"/><div><p>This is the first spec's passing result on the browser</p></div></div><p>It might sound strange to <a id="id24" class="indexterm"/>have an empty spec passing, but in Jasmine, as with other test frameworks, a failed assertion is required to make the spec fail.</p><p>An <a id="id25" class="indexterm"/>
<strong>assertion</strong> (or expectation) is a comparison between two values that must result in a boolean value. The assertion is only considered a success if the result of the comparison is true.</p><p>In Jasmine, assertions are written using the global Jasmine function <code class="literal">expect</code>, along with a <strong>matcher</strong><a id="id26" class="indexterm"/> that indicates what comparison must be made with the values.</p><p>Regarding the current spec (it is expected that the investment is of a stock), in Jasmine this translates to the following code:</p><div><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    <strong>expect(investment.stock).toBe(stock);</strong>
  });
});</pre></div><p>Add the preceding highlighted code to the <code class="literal">InvestmentSpec.js</code> file. The <code class="literal">expect</code> function takes only one parameter, which defines the <strong>actual value</strong>, or in other words, what is going to be tested—<code class="literal">investment.stock</code>—and expects the chaining call to a matcher function, which in this case is <code class="literal">toBe</code>. That defines the <strong>expected value</strong>, <code class="literal">stock</code>, and the comparison method to be performed (to be the same).</p><p>Behind the scenes, Jasmine makes a comparison to check whether the actual value (<code class="literal">investment.stock</code>) and expected value (<code class="literal">stock</code>) are the same, and if they are not, the test fails.</p><p>With the assertion written, the spec that previously passed has now failed, as shown in the following screenshot:</p><div><img src="img/B04138_02_04.jpg" alt="Jasmine basics and thinking in BDD"/><div><p>This shows the first spec's failure results</p></div></div><p>This spec failed because, as<a id="id27" class="indexterm"/> the error message states, <code class="literal">investment is not defined</code>.</p><p>The idea here is to do only what the error is indicating us to do, so although you might feel the urge to write something else, for now let's just create this <code class="literal">investment</code> variable with an <code class="literal">Investment</code> instance in the <code class="literal">InvestmentSpec.js</code> file, as follows:</p><div><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    <strong>var investment = new Investment();</strong>
    expect(investment.stock).toBe(stock);
  });
});</pre></div><p>Don't worry that the <code class="literal">Investment()</code> function doesn't exist yet; the spec is about to ask for it on the next run, as follows:</p><div><img src="img/B04138_02_05.jpg" alt="Jasmine basics and thinking in BDD"/><div><p>Here the spec asks for an Investment class</p></div></div><p>You can see that the error has changed to <code class="literal">Investment is not defined</code>. It now asks for the <code class="literal">Investment</code> function. So, create a new <code class="literal">Investment.js</code> file in the <code class="literal">src</code> folder and add it to the runner, as shown in the following code:</p><div><pre class="programlisting">&lt;!-- include source files here... --&gt;
&lt;script type="text/javascript" src="img/Investment.js"&gt;&lt;/script&gt;</pre></div><p>To define <code class="literal">Investment</code>, write the<a id="id28" class="indexterm"/> following constructor function in the <code class="literal">Investment.js</code> file inside the <code class="literal">src</code> folder:</p><div><pre class="programlisting">function Investment () {};</pre></div><p>This makes the error change. It now complains about the missing <code class="literal">stock</code> variable, as shown in the following screenshot:</p><div><img src="img/B04138_02_06.jpg" alt="Jasmine basics and thinking in BDD"/><div><p>This shows a missing stock error</p></div></div><p>One more time, we feed the code it is asking for into the <code class="literal">InvestmentSpec.js</code> file, as shown in the following code:</p><div><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    <strong>var stock = new Stock();</strong>
    var investment = new Investment();
    expect(investment.stock).toBe(stock);
  });
});</pre></div><p>The error changes again; this time it is about the missing <code class="literal">Stock</code> function:</p><div><img src="img/B04138_02_07.jpg" alt="Jasmine basics and thinking in BDD"/><div><p>Here the spec asks for a Stock class</p></div></div><p>Create a new file in the <code class="literal">src</code> folder, name it <code class="literal">Stock.js</code>, and add it to the runner. Since the <code class="literal">Stock</code> function is going to be a <a id="id29" class="indexterm"/>dependency of <code class="literal">Investment</code>, we should add it just before <code class="literal">Investment.js</code>:</p><div><pre class="programlisting">&lt;!-- include source files here... --&gt;
<strong>&lt;script type="text/javascript" src="img/Stock.js"&gt;&lt;/script&gt;</strong>
&lt;script type="text/javascript" src="img/Investment.js"&gt;&lt;/script&gt;</pre></div><p>Write the <code class="literal">Stock</code> constructor function to the <code class="literal">Stock.js</code> file:</p><div><pre class="programlisting">function Stock () {};</pre></div><p>Finally, the error is about the expectation, as shown in the following screenshot:</p><div><img src="img/B04138_02_08.jpg" alt="Jasmine basics and thinking in BDD"/><div><p>The expectation is undefined to be Stock</p></div></div><p>To fix this and complete this exercise, open the <code class="literal">Investment.js</code> file inside the <code class="literal">src</code> folder, and add the reference to the <code class="literal">stock</code> parameter:</p><div><pre class="programlisting">function Investment (stock) {
  <strong>this.stock = stock;</strong>
};</pre></div><p>In the spec file, pass <code class="literal">stock</code> as a parameter to the <code class="literal">Investment</code> function:</p><div><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    var stock = new Stock();
    var investment = new Investment(<strong>stock</strong>);
    expect(investment.stock).toBe(stock);
  });
});</pre></div><p>Finally, you will have a passing spec:</p><div><img src="img/B04138_02_09.jpg" alt="Jasmine basics and thinking in BDD"/><div><p>This shows an Investment spec that passes</p></div></div><p>This exercise was <a id="id30" class="indexterm"/>meticulously conducted to show how a developer works by feeding the spec with what it wants when doing test-first development.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>The drive to write code must come from a spec that has failed. You must not write code unless its purpose is to fix a failed spec.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Setup and teardown</h1></div></div></div><p>There are three more<a id="id31" class="indexterm"/> acceptance criteria to be <a id="id32" class="indexterm"/>implemented. The next in the list is as follows:</p><p>"Given an investment, it should have the invested shares' quantity."</p><p>Writing it should be as simple as the previous spec was. In the <code class="literal">InvestmentSpec.js</code> file inside the <code class="literal">spec</code> folder, you can translate this new criterion into a new spec called <code class="literal">should have the invested shares' quantity</code>, as follows:</p><div><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    var stock = new Stock();
    var investment = new Investment(<strong>{</strong>
      <strong>stock: stock,</strong>
      <strong>shares: 100</strong>
    <strong>}</strong>);
    expect(investment.stock).toBe(stock);
  });

  <strong>it("should have the invested shares' quantity", function() {</strong>
<strong>    var stock = new Stock();</strong>
<strong>    var investment = new Investment({</strong>
<strong>      stock: stock,</strong>
<strong>      shares: 100</strong>
<strong>    });</strong>
<strong>    expect(investment.shares).toEqual(100);</strong>
<strong>  });</strong>
});</pre></div><p>You can see that <a id="id33" class="indexterm"/>apart from having written the new spec, we have also changed the call to the <code class="literal">Investment</code> constructor to <a id="id34" class="indexterm"/>support the new <code class="literal">shares</code> parameter.</p><p>To do so, we used an object as a single parameter in the constructor to simulate named parameters, a feature JavaScript doesn't have natively.</p><p>Implementing this in the <code class="literal">Investment</code> function is pretty simple—instead of having multiple parameters on the function declaration, it has only one, which is expected to be an object. Then, the function probes each of its expected parameters from this object, making the proper assignments, as shown here:</p><div><pre class="programlisting">function Investment (<strong>params</strong>) {
  <strong>this.stock = params.stock;</strong>
};</pre></div><p>The code is now refactored. We can run the tests to see that only the new spec fails, as shown here:</p><div><img src="img/B04138_02_10.jpg" alt="Setup and teardown"/><div><p>This shows the failing shares spec</p></div></div><p>To fix this, change the <code class="literal">Investment</code> constructor to make the assignment to the <code class="literal">shares</code> property, as follows:</p><div><pre class="programlisting">function Investment (params) {
  this.stock = params.stock;
  <strong>this.shares = params.shares;</strong>
};</pre></div><p>Finally, everything on your screen is green:</p><div><img src="img/B04138_02_11.jpg" alt="Setup and teardown"/><div><p>This shows the passing shares spec</p></div></div><p>But as you can see, the <a id="id35" class="indexterm"/>following<a id="id36" class="indexterm"/> code, which instantiates <code class="literal">Stock</code> and <code class="literal">Investment</code>, is duplicated on both specs:</p><div><pre class="programlisting">var stock = new Stock();
var investment = new Investment({
  stock: stock,
  shares: 100
});</pre></div><p>To eliminate this duplication, Jasmine provides another global function called <code class="literal">beforeEach</code> that, as the name states, is executed once before each spec. So, for these two specs, it will run twice—once before each spec.</p><p>Refactor the previous specs by extracting the setup code using the <code class="literal">beforeEach</code> function:</p><div><pre class="programlisting">describe("Investment", function() {
  <strong>var stock, investment;</strong>

  <strong>beforeEach(function() {</strong>
    <strong>stock = new Stock();</strong>
    <strong>investment = new Investment({</strong>
      <strong>stock: stock,</strong>
      <strong>shares: 100</strong>
    <strong>});</strong>
  <strong>});</strong>

  it("should be of a stock", function() {
    expect(investment.stock).toBe(stock);
  });

  it("should have the invested shares quantity", function() {
    expect(investment.shares).toEqual(100);
  });
});</pre></div><p>This looks much <a id="id37" class="indexterm"/>cleaner; we not only <a id="id38" class="indexterm"/>removed the code duplication, but also simplified the specs. They became much easier to read and maintain since their only responsibility now is to fulfill the expectation.</p><p>There is also a <strong>teardown</strong> function (<code class="literal">afterEach</code>) that sets the code to be executed after each spec. It is very useful in situations where a cleanup is required after each spec. We will see an example of its application in <a class="link" href="ch06.html" title="Chapter 6. Light Speed Unit Testing">Chapter 6</a>, <em>Light Speed Unit Testing</em>.</p><p>To finish the specification of <code class="literal">Investment</code>, add the remaining two specs to the <code class="literal">InvestmentSpec.js</code> file, inside the <code class="literal">spec</code> folder:</p><div><pre class="programlisting">describe("Investment", function() {
  var stock;
  var investment;

  beforeEach(function() {
    stock = new Stock();
    investment = new Investment({
      stock: stock,
      shares: 100,
      <strong>sharePrice: 20</strong>
    });
  });

  //... other specs

  <strong>it("should have the share paid price", function() {</strong>
    <strong>expect(investment.sharePrice).toEqual(20);</strong>
  <strong>});</strong>

  <strong>it("should have a cost", function() {</strong>
    <strong>expect(investment.cost).toEqual(2000);</strong>
  <strong>});</strong>
});</pre></div><p>Run the specs to see them fail, as shown in the following screenshot:</p><div><img src="img/B04138_02_12.jpg" alt="Setup and teardown"/><div><p>This shows the failing cost and price specs</p></div></div><p>Add the following <a id="id39" class="indexterm"/>code to fix them in<a id="id40" class="indexterm"/> the <code class="literal">Investment.js</code> file inside the <code class="literal">src</code> folder:</p><div><pre class="programlisting">function Investment (params) {
  this.stock = params.stock;
  this.shares = params.shares;
  <strong>this.sharePrice = params.sharePrice;</strong>
  <strong>this.cost = this.shares * this.sharePrice;</strong>
};</pre></div><p>Run the specs for the last time to see them pass:</p><div><img src="img/B04138_02_13.jpg" alt="Setup and teardown"/><div><p>This shows all four Investment specs passing</p></div></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>It is important to always see a spec fail before writing the code to fix it; otherwise, how would you know that you really need to fix it? Imagine this as a way to test the test.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Nested describes</h1></div></div></div><p><strong>Nested describes</strong><a id="id41" class="indexterm"/> are useful when you want to describe similar behavior between specs. Suppose we want the following two new acceptance criteria:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Given an investment, when its stock share price valorizes, it should have a positive<a id="id42" class="indexterm"/> <strong>return on investment</strong> (<strong>ROI</strong>)</li><li class="listitem" style="list-style-type: disc">Given an investment, when its stock share price valorizes, it should be a good investment</li></ul></div><p>Both these criteria share the same behavior when the investment's stock share price valorizes.</p><p>To translate this into Jasmine, you can nest a call to the <code class="literal">describe</code> function inside the existing one in the <code class="literal">InvestmentSpec.js</code> file (I removed the rest of the code for the purpose of demonstration; it is still there):</p><div><pre class="programlisting">describe("Investment", function()
  <strong>describe("when its stock share price valorizes", function() {</strong>
   
  <strong>});</strong>
});</pre></div><p>It should behave just like the outer one, so you can add specs (<code class="literal">it</code>) and use the setup and teardown functions (<code class="literal">beforeEach</code>, <code class="literal">afterEach</code>).</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Setup and teardown</h2></div></div></div><p>When using the <a id="id43" class="indexterm"/>setup and teardown <a id="id44" class="indexterm"/>functions, Jasmine respects the outer setup and teardown functions as well, so that they are run as expected. For each spec (<code class="literal">it</code>), the following actions are performed:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Jasmine runs all setup functions (<code class="literal">beforeEach</code>) from the outside in</li><li class="listitem" style="list-style-type: disc">Jasmine runs a spec code (<code class="literal">it</code>)</li><li class="listitem" style="list-style-type: disc">Jasmine runs all the teardown functions (<code class="literal">afterEach</code>) from the inside out</li></ul></div><p>So, we can <a id="id45" class="indexterm"/>add a setup function to this new <code class="literal">describe</code> function that changes the <a id="id46" class="indexterm"/>share price of the stock, so that it's greater than the share price of the investment:</p><div><pre class="programlisting">describe("Investment", function() {
  var stock;
  var investment;

  beforeEach(function() {
    stock = new Stock();
    investment = new Investment({
      stock: stock,
      shares: 100,
      sharePrice: 20
    });
  });

  describe("when its stock share price valorizes", function() {
    <strong>beforeEach(function() {</strong>
      <strong>stock.sharePrice = 40;</strong>
    <strong>});</strong>
  });
});</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Coding a spec with shared behavior</h2></div></div></div><p>Now that we have the <a id="id47" class="indexterm"/>shared behavior implemented, we can start<a id="id48" class="indexterm"/> coding the acceptance criteria described earlier. Each is, just as before, a call to the global Jasmine function <code class="literal">it</code>:</p><div><pre class="programlisting">describe("Investment", function() {
  describe("when its stock share price valorizes", function() {
    beforeEach(function() {
      stock.sharePrice = 40;
    });

    <strong>it("should have a positive return of investment", function() {</strong>
      <strong>expect(investment.roi()).toEqual(1);</strong>
    <strong>});</strong>

    <strong>it("should be a good investment", function() {</strong>
      <strong>expect(investment.isGood()).toEqual(true);</strong>
    <strong>});</strong>
  });
});</pre></div><p>After adding the missing functions to <code class="literal">Investment</code> in the <code class="literal">Investment.js</code> file:</p><div><pre class="programlisting">Investment.prototype.<strong>roi</strong> = function() {
  return (this.stock.sharePrice - this.sharePrice) / this.sharePrice;
};

Investment.prototype.<strong>isGood</strong> = function() {
  return this.roi() &gt; 0;
};</pre></div><p>You can run the <a id="id49" class="indexterm"/>specs and <a id="id50" class="indexterm"/>see that they pass:</p><div><img src="img/B04138_02_14.jpg" alt="Coding a spec with shared behavior"/><div><p>This shows the  nested describe specs pass</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Understanding matchers</h2></div></div></div><p>By now, you've already seen<a id="id51" class="indexterm"/> plenty of usage examples for matchers and probably can feel how they work.</p><p>You have seen how to use the <code class="literal">toBe</code> and <code class="literal">toEqual</code> matchers. These are the two base built-in matchers available in Jasmine, but we can extend Jasmine by writing matchers of our own.</p><p>So, to really understand how Jasmine matchers work, we need to create one ourselves.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Custom matchers</h3></div></div></div><p>Consider this <a id="id52" class="indexterm"/>expectation from the previous section:</p><div><pre class="programlisting">expect(investment.isGood()).toEqual(true);</pre></div><p>Although it works, it is not <a id="id53" class="indexterm"/>very expressive. Imagine if we could instead rewrite it as:</p><div><pre class="programlisting">expect(investment).toBeAGoodInvestment();</pre></div><p>This creates a much better relation with the acceptance criterion:</p><p>So, here "should be a good investment" becomes "expect investment to be a good investment".</p><p>Implementing it is quite simple. You do so by calling the <code class="literal">jasmine.addMatchers</code> function—ideally inside a setup step (<code class="literal">beforeEach</code>).</p><p>Although you can put this new matcher definition inside the <code class="literal">InvestmentSpec.js</code> file, Jasmine already has a default place to add custom matchers, the <code class="literal">SpecHelper.js</code> file, inside the <code class="literal">spec</code> folder. If you are using Standalone Distribution, it already comes with a sample custom matcher; delete it and let's start from scratch.</p><p>The <code class="literal">addMatchers</code> function accepts a single parameter—an object where each attribute corresponds to a new matcher. So, to add the following new matcher, change the contents of the <code class="literal">SpecHelper.js</code> file to the following:</p><div><pre class="programlisting">beforeEach(function() {
  jasmine.addMatchers({
    <strong>toBeAGoodInvestment: function() {}</strong>
  });
});</pre></div><p>The function being defined here is not the matcher itself but a factory function to build the matcher. Its purpose, once called is to return an object containing a compare function, as follows:</p><div><pre class="programlisting">jasmine.addMatchers({
  toBeAGoodInvestment: function () {
    <strong>return</strong> <strong>{</strong>
<strong>      compare: function (actual, expected) {</strong>
<strong>        // matcher definition</strong>
<strong>      }</strong>
    };
  }
});</pre></div><p>The <code class="literal">compare</code> function will contain the actual matcher implementation, and as can be observed by its signature, it receives both values being compared (the <code class="literal">actual</code> and <code class="literal">expected</code> values).</p><p>For the given example, the <code class="literal">investment</code> object will be available in the <code class="literal">actual</code> argument.</p><p>Then, Jasmine expects, as the result of this <code class="literal">compare</code> function, an object with a <code class="literal">pass</code> attribute with a boolean value <code class="literal">true</code> to indicate that the expectation passes and <code class="literal">false</code> if the expectation fails.</p><p>Let's have a<a id="id54" class="indexterm"/> look at the following valid implementation<a id="id55" class="indexterm"/> of the <code class="literal">toBeAGoodInvestment</code> matcher:</p><div><pre class="programlisting">toBeAGoodInvestment: function () {
  return {
    compare: function (actual, expected) {
      <strong>var result = {};</strong>
<strong>      result.pass = actual.isGood();</strong>
<strong>      return result;</strong>
    }
  };
}</pre></div><p>By now, this matcher is ready to be used by the specs:</p><div><pre class="programlisting">it("should be a good investment", function() {
  <strong>expect(investment).toBeAGoodInvestment();</strong>
});</pre></div><p>After the change, the specs should still pass. But what happens if a spec fails? What is the error message that Jasmine reports?</p><p>We can see it by deliberately breaking the <code class="literal">investment.isGood</code> implementation in the <code class="literal">Investment.js</code> file, in the <code class="literal">src</code> folder to always return <code class="literal">false</code>:</p><div><pre class="programlisting">Investment.prototype.isGood = function() {
  <strong>return false;</strong>
};</pre></div><p>When running the specs again, Jasmine generates an error message stating <code class="literal">Expected { stock: { sharePrice: 40 }, shares: 100, sharePrice: 20, cost: 2000 } to be a good investment</code>, as shown in the following screenshot:</p><div><img src="img/B04138_02_15.jpg" alt="Custom matchers"/><div><p>This is the custom matcher's message</p></div></div><p>Jasmine does a great job generating this error message, but it also allows its customization via the <code class="literal">result.message</code> property of the object returned as the result of the matcher. Jasmine expects this property to be a string with the following error message:</p><div><pre class="programlisting">toBeAGoodInvestment: function () {
  return {
    compare: function (actual, expected) {
      var result = {};
      result.pass = actual.isGood();
      <strong>result.message = 'Expected investment to be a good investment';</strong>
      return result;
    }
  };
}</pre></div><p>Run the specs<a id="id56" class="indexterm"/> again and the error message should <a id="id57" class="indexterm"/>change:</p><div><img src="img/B04138_02_16.jpg" alt="Custom matchers"/><div><p>This is the custom matcher's custom message</p></div></div><p>Now, let's consider another acceptance criterion:</p><p>"Given an investment, when its stock share price devalorizes, it should be a bad investment."</p><p>Although it is possible to create a new custom matcher (<code class="literal">toBeABadInvestment</code>), Jasmine allows the negation of any matcher by chaining <code class="literal">not</code> before the matcher call. So, we can write that "a bad investment" is "not a good investment"</p><div><pre class="programlisting">expect(investment).<strong>not</strong>.toBeAGoodInvestment();</pre></div><p>Implement this new acceptance criterion in the <code class="literal">InvestmentSpec.js</code> file inside the <code class="literal">spec</code> folder by adding new and nested <code class="literal">describe</code> and <code class="literal">spec</code>, as follows:</p><div><pre class="programlisting">describe("when its stock share price devalorizes", function() {
  beforeEach(function() {
    stock.sharePrice = 0;
  });

  it("should have a negative return of investment", function() {
    expect(investment.roi()).toEqual(-1);
  });

  it("should be a bad investment", function() {
    expect(investment).not.toBeAGoodInvestment();
  });
});</pre></div><p>But there is a catch! Let's break the <code class="literal">investment</code> implementation in the <code class="literal">Investment.js</code> file code so that it is always a good investment, as follows:</p><div><pre class="programlisting">Investment.prototype.isGood = function() {
  <strong>return true;</strong>
};</pre></div><p>After running the<a id="id58" class="indexterm"/> specs again, you can see that this new spec fails, but the <a id="id59" class="indexterm"/>error message, <code class="literal">Expected investment to be a good investment</code>, is wrong, as shown in the following screenshot:</p><div><img src="img/B04138_02_17.jpg" alt="Custom matchers"/><div><p>This is the custom matcher's wrong custom negated message</p></div></div><p>That is the message that was hardcoded inside the matcher. To fix this, you need to make the message dynamic.</p><p>Jasmine only shows the message if the matcher fails, so the proper way of making this message dynamic is to consider what message is supposed to be shown when the given comparison is invalid:</p><div><pre class="programlisting">compare: function (actual, expected) {
  var result = {};
  result.pass = actual.isGood();

<strong>  if (actual.isGood()) {</strong>
<strong>    result.message = 'Expected investment to be a bad investment';</strong>
<strong>  } else {</strong>
<strong>    result.message = 'Expected investment to be a good investment';</strong>
<strong>  }</strong>

  return result;
}</pre></div><p>This fixes the message, as shown in the following screenshot:</p><div><img src="img/B04138_02_18.jpg" alt="Custom matchers"/><div><p>This shows the custom matcher's custom dynamic message</p></div></div><p>Now this <a id="id60" class="indexterm"/>matcher can be used anywhere.</p><p>Before continuing in<a id="id61" class="indexterm"/> the chapter, change the <code class="literal">isGood</code> method back again to its correct implementation:</p><div><pre class="programlisting">Investment.prototype.isGood = function() {
  return this.roi() &gt; 0;
};</pre></div><p>What this example lacked was a way to show how to pass an expected value to a matcher like this:</p><div><pre class="programlisting">expect(investment.cost).toBe(2000)</pre></div><p>It turns out that a matcher can receive any number of expected values as parameters. So, for instance, the preceding matcher could be implemented in the <code class="literal">SpecHelper.js</code> file, inside the <code class="literal">spec</code> folder, as follows:</p><div><pre class="programlisting">beforeEach(function() {
  jasmine.addMatchers({
    toBe: function () {
      return {
        compare: function (actual, <strong>expected</strong>) {
          return actual === <strong>expected</strong>;
        }
      };
    }
  });
});</pre></div><p>By implementing any matcher, check first whether there is one available that already does what you want.</p><p>For more information, check the official <a id="id62" class="indexterm"/>documentation at the Jasmine website <a class="ulink" href="http://jasmine.github.io/2.1/custom_matcher.html">http://jasmine.github.io/2.1/custom_matcher.html</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Built-in matchers</h3></div></div></div><p>Jasmine comes <a id="id63" class="indexterm"/>with a bunch of default matchers covering the basis of value checking in the JavaScript language. To understand how they work and where to use them properly is a journey of how JavaScript handles type.</p><div><div><div><div><h4 class="title"><a id="ch02lvl4sec01"/>The toEqual built-in matcher</h4></div></div></div><p>The <code class="literal">toEqual</code> matcher is <a id="id64" class="indexterm"/>probably the most commonly used matcher, and you should <a id="id65" class="indexterm"/>use it whenever you want to check equality between two values.</p><p>It works for all primitive values (number, string, and boolean) as well as any object (including arrays), as shown in the following code:</p><div><pre class="programlisting">describe("toEqual", function() {
  it("should pass equal numbers", function() {
    expect(1).toEqual(1);
  });

  it("should pass equal strings", function() {
    expect("testing").toEqual("testing");
  });

  it("should pass equal booleans", function() {
    expect(true).toEqual(true);
  });

  it("should pass equal objects", function() {
    expect({a: "testing"}).toEqual({a: "testing"});
  });

  it("should pass equal arrays", function() {
    expect([1, 2, 3]).toEqual([1, 2, 3]);
  });
});</pre></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec02"/>The toBe built-in matcher</h4></div></div></div><p>The <code class="literal">toBe</code> matcher <a id="id66" class="indexterm"/>has a very similar behavior to the <code class="literal">toEqual</code> matcher; in fact, it<a id="id67" class="indexterm"/> gives the same result while comparing primitive values, but the similarities stop there.</p><p>While the <code class="literal">toEqual</code> matcher has a complex implementation (you should take a look at the Jasmine source code) that checks whether all attributes of an object and all elements of an array are the same, here it is a simple use of the <a id="id68" class="indexterm"/>
<strong>strict equals operator</strong> (<code class="literal">===</code>).</p><p>If you are unfamiliar with the strict equals operator, its main difference from the <strong>equals operator</strong> (<code class="literal">==</code>)<a id="id69" class="indexterm"/> is that the latter performs type coercion if the compared<a id="id70" class="indexterm"/> values <a id="id71" class="indexterm"/>aren't of the same type.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>The strict equals operator always considers false any comparison between values of distinct types.</p></div></div><p>Here are some examples of how this matcher (and the strict equals operator) works:</p><div><pre class="programlisting">describe("toBe", function() {
  it("should pass equal numbers", function() {
    expect(1).toBe(1);
  });

  it("should pass equal strings", function() {
    expect("testing").toBe("testing");
  });

  it("should pass equal booleans", function() {
    expect(true).toBe(true);
  });

  it("should pass same objects", function() {
    var object = {a: "testing"};
    expect(object).toBe(object);
  });

  it("should pass same arrays", function() {
    var array = [1, 2, 3];
    expect(array).toBe(array);
  });

  it("should not pass equal objects", function() {
    expect({a: "testing"}).not.toBe({a: "testing"});
  });

  it("should not pass equal arrays", function() {
    expect([1, 2, 3]).not.toBe([1, 2, 3]);
  });
});</pre></div><p>It is advised that you use the <code class="literal">toEqual</code> operator in most cases and resort to the <code class="literal">toBe</code> matcher only when you want to check whether two variables reference the same object.</p></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec03"/>The toBeTruthy and toBeFalsy matchers</h4></div></div></div><p>Besides its<a id="id72" class="indexterm"/> primitive boolean type, everything else in the JavaScript<a id="id73" class="indexterm"/> language also has an inherent boolean value, which is <a id="id74" class="indexterm"/>generally known to be either <strong>truthy</strong> or <strong>falsy</strong>.</p><p>Luckily in JavaScript, there are<a id="id75" class="indexterm"/> only a few values that are identified as falsy, as shown in the following examples for the <code class="literal">toBeFalsy</code> matcher:</p><div><pre class="programlisting">describe("toBeFalsy", function () {
  it("should pass undefined", function() {
    expect(undefined).toBeFalsy();
  });

  it("should pass null", function() {
    expect(null).toBeFalsy();
  });

  it("should pass NaN", function() {
    expect(NaN).toBeFalsy();
  });

  it("should pass the false boolean value", function() {
    expect(false).toBeFalsy();
  });

  it("should pass the number 0", function() {
    expect(0).toBeFalsy();
  });

  it("should pass an empty string", function() {
    expect("").toBeFalsy();
  });
});</pre></div><p>Everything else is considered truthy, as demonstrated by the following examples of the <code class="literal">toBeTruthy</code> matcher:</p><div><pre class="programlisting">describe("toBeTruthy", function() {
  it("should pass the true boolean value", function() {
    expect(true).toBeTruthy();
  });

  it("should pass any number different than 0", function() {
    expect(1).toBeTruthy();
  });
  it("should pass any non empty string", function() {
    expect("a").toBeTruthy();
  });

  it("should pass any object (including an array)", function() {
    expect([]).toBeTruthy();
    expect({}).toBeTruthy();
  });
});</pre></div><p>But, if you <a id="id76" class="indexterm"/>want to<a id="id77" class="indexterm"/> check whether something is equal to an actual <a id="id78" class="indexterm"/>boolean value, it might be a better idea to use the <code class="literal">toEqual</code> <a id="id79" class="indexterm"/>matcher.</p></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec04"/>The toBeUndefined, toBeNull, and toBeNaN built-in matchers</h4></div></div></div><p>These <a id="id80" class="indexterm"/>matchers<a id="id81" class="indexterm"/> are pretty <a id="id82" class="indexterm"/>straightforward and should be used to <a id="id83" class="indexterm"/>check for <code class="literal">undefined</code>, <code class="literal">null</code>, <a id="id84" class="indexterm"/>and <code class="literal">NaN</code> <a id="id85" class="indexterm"/>values:</p><div><pre class="programlisting">describe("toBeNull", function() {
  it("should pass null", function() {
    expect(null).toBeNull();
  });
});

describe("toBeUndefined", function() {
  it("should pass undefined", function() {
    expect(undefined).toBeUndefined();
  });
});

describe("toBeNaN", function() {
  it("should pass NaN", function() {
    expect(NaN).toBeNaN();
  });
});</pre></div><p>Both <code class="literal">toBeNull</code> and <code class="literal">toBeUndefined</code> can be written as <code class="literal">toBe(null)</code> and <code class="literal">toBe(undefined)</code> respectively, but that is not the case with <code class="literal">toBeNaN</code>.</p><p>In JavaScript, the <code class="literal">NaN</code> value is not equal to any value, not even <code class="literal">NaN</code>. So, trying to compare it to itself is always <code class="literal">false</code>, as shown in the following code:</p><div><pre class="programlisting">NaN === NaN // false</pre></div><p>As good practice, try to use these matchers instead of their <code class="literal">toBe</code> counterparts whenever possible.</p></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec05"/>The toBeDefined built-in matcher</h4></div></div></div><p>This matcher is useful if<a id="id86" class="indexterm"/> you want to check whether a variable is defined<a id="id87" class="indexterm"/> and you don't care about its value, as follows:</p><div><pre class="programlisting">describe("toBeDefined", function() {
  it("should pass any value other than undefined", function() {
    expect(null).toBeDefined();
  });
});</pre></div><p>Anything except <code class="literal">undefined</code> will pass under this matcher, even <code class="literal">null</code>.</p></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec06"/>The toContain built-in matcher</h4></div></div></div><p>Sometimes, it is <a id="id88" class="indexterm"/>desirable to check whether an array contains an element, or <a id="id89" class="indexterm"/>whether a string can be found inside another string. For these use cases, you can use the <code class="literal">toContain</code> matcher, as follows:</p><div><pre class="programlisting">describe("toContain", function() {
  it("should pass if a string contains another string", function()  {
    expect("My big string").toContain("big");
  });

  it("should pass if an array contains an element", function() {
    expect([1, 2, 3]).toContain(2);
  });
});</pre></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec07"/>The toMatch built-in matcher</h4></div></div></div><p>Although<a id="id90" class="indexterm"/> the <code class="literal">toContain</code> and <code class="literal">toEqual</code> matchers can be used in most string <a id="id91" class="indexterm"/>comparisons, sometimes the only way to assert whether a string value is correct is through a regular expression. For these cases, you can use the <code class="literal">toMatch</code> matcher along with a regular expression, as follows:</p><div><pre class="programlisting">describe("toMatch", function() {
  it("should pass a matching string", function() {
    expect("My big matched string").toMatch(/My(.+)string/);
  });
});</pre></div><p>The matcher works by testing the actual value (<code class="literal">"My big matched string"</code>) against the expected regular expression (<code class="literal">/My(.+)string/</code>).</p></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec08"/>The toBeLessThan and toBeGreaterThan built-in matchers</h4></div></div></div><p>The <code class="literal">toBeLessThan</code> <a id="id92" class="indexterm"/>and <code class="literal">toBeGreaterThan</code> matchers are simple and used <a id="id93" class="indexterm"/>to perform numeric comparisons—something <a id="id94" class="indexterm"/>that is best described by the following<a id="id95" class="indexterm"/> examples:</p><div><pre class="programlisting">  describe("toBeLessThan", function() {
    it("should pass when the actual is less than expected", function() {
      expect(1).toBeLessThan(2);
    });
  });

  describe("toBeGreaterThan", function() {
    it("should pass when the actual is greater than expected", function() {
      expect(2).toBeGreaterThan(1);
    });
  });</pre></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec09"/>The toBeCloseTo built-in matcher</h4></div></div></div><p>This is a special <a id="id96" class="indexterm"/>matcher used to compare floating-point numbers <a id="id97" class="indexterm"/>with a defined set of precision—something that is best explained by this example:</p><div><pre class="programlisting">describe("toBeCloseTo", function() {
    it("should pass when the actual is closer with a given precision", function() {
      expect(3.1415).toBeCloseTo(2.8, 0);
      expect(3.1415).not.toBeCloseTo(2.8, 1);
    });
  });</pre></div><p>The first parameter is the number being compared, and the second is the precision in the number of decimal cases.</p></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec10"/>The toThrow built-in matcher</h4></div></div></div><p>Exceptions are <a id="id98" class="indexterm"/>a language's way of demonstrating when something goes <a id="id99" class="indexterm"/>wrong.</p><p>So, for example, while coding an API, you might decide to throw an exception when a parameter is passed incorrectly. So, how do you test this code?</p><p>Jasmine has the built-in <code class="literal">toThrow</code> matcher that can be used to verify that an exception has been thrown.</p><p>The way it works is a little bit different from the other matchers. Since the matcher has to run a piece of code and check whether it throws an exception, the matcher's <strong>actual</strong> value must be a function.</p><p>Here is an example of how it works:</p><div><pre class="programlisting">describe("toThrow", function() {
  it("should pass when the exception is thrown", function() {
    expect(function () {
      throw "Some exception";
    }).toThrow("Some exception");
  });
});</pre></div><p>When the test is run, the anonymous function is executed, and if it throws the <code class="literal">Some exception</code> exception, the test passes.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, you learned how to think in BDD and drive your code from your specs. You also became acquainted with the basic Jasmine global functions (<code class="literal">describe</code>, <code class="literal">it</code>, <code class="literal">beforeEach</code>, and <code class="literal">afterEach</code>) and have a good understanding of what is required to create a spec in Jasmine.</p><p>You got familiar with Jasmine matchers and know how powerful they are in describing a spec intent. You even learned to create a matcher of your own.</p><p>By now, you should be familiar with creating new specs and driving the development of your new application.</p><p>In the next chapter, we are going to take a look at how we can use the concepts learned in this chapter to start testing web applications, which are most commonly jQuery and HTML forms.</p></div></body></html>