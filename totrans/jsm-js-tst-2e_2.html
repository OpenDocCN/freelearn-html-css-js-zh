<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Your First Spec"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Your First Spec</h1></div></div></div><p>This chapter is about the basics, and we are going to guide you through how to write your first spec, think in test-first terms for development, and also show you all the available global Jasmine functions. By the end of the chapter, you should know how Jasmine works and be ready to start doing your first tests by yourself.</p><div class="section" title="The Investment Tracker application"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>The Investment Tracker application</h1></div></div></div><p>To get you started, we <a id="id20" class="indexterm"/>need an example scenario: consider that you are developing an application to track investments in the stock market.</p><p>The following screenshot of the form illustrates how a user might create a new investment on this application:</p><div class="mediaobject"><img src="graphics/B04138_02_01.jpg" alt="The Investment Tracker application"/><div class="caption"><p>This is a form to add investments</p></div></div><p>This form will allow the input of three values that define an investment:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we will input <span class="strong"><strong>Symbol</strong></span>, which represents which company (stock) the user is investing in</li><li class="listitem" style="list-style-type: disc">Then, we will input how many <span class="strong"><strong>Shares</strong></span> the user has bought (or invested in)</li><li class="listitem" style="list-style-type: disc">Finally, we will input how much the user has paid for each share (<span class="strong"><strong>Share price</strong></span>)</li></ul></div><p>If you are unfamiliar with how the stock market works, imagine you are shopping for groceries. To make a purchase, you must specify what you are buying, how many items you are buying, and <a id="id21" class="indexterm"/>how much you are going to pay. These concepts translate to an investment as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A stock, which is defined by a symbol, such as <code class="literal">PETO</code>, can be understood to be a grocery type</li><li class="listitem" style="list-style-type: disc">The number of shares is the quantity of items you have purchased</li><li class="listitem" style="list-style-type: disc">The share price is the unit price of each item</li></ul></div><p>Once the user has added an investment, it must be listed along with their other investments, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04138_02_02.jpg" alt="The Investment Tracker application"/><div class="caption"><p>This is a form and list of investments</p></div></div><p>The idea is to display how well their investments are going. Since the prices of the stocks fluctuate over time, the difference between the price the user has paid and the current price indicates whether it is a good (profit) or a bad (loss) investment.</p><p>In the preceding screenshot, we can see that the user has two investments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One is in the <code class="literal">AOUE</code> stock, which is scoring a profit of <code class="literal">101.80%</code></li><li class="listitem" style="list-style-type: disc">Another is in the <code class="literal">PETO</code> stock, which is scoring a loss of <code class="literal">-42.34%</code></li></ul></div><p>This is a very simple application, and we will get a deeper understanding of its functionality as we go on with its development.</p></div></div>
<div class="section" title="Jasmine basics and thinking in BDD"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Jasmine basics and thinking in BDD</h1></div></div></div><p>Based on the application<a id="id22" class="indexterm"/> presented previously, we can start writing acceptance criteria that define investment:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Given an investment, it should be of a stock</li><li class="listitem" style="list-style-type: disc">Given an investment, it should have the invested shares' quantity</li><li class="listitem" style="list-style-type: disc">Given an investment, it should have the share price paid</li><li class="listitem" style="list-style-type: disc">Given an investment, it should have a cost</li></ul></div><p>Using the standalone distribution downloaded in the previous chapter, the first thing we need to do is create a new spec file. This file can be created anywhere, but it is a good idea to stick to a convention, and Jasmine already has a good one: specs should be in the <code class="literal">/spec</code> folder. Create an <code class="literal">InvestmentSpec.js</code> file and add the following lines:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {

});</pre></div><p>The <code class="literal">describe</code> function<a id="id23" class="indexterm"/> is a global Jasmine function used to define test contexts. When used as the first call in a spec, it creates a new test suite (a collection of test cases). It accepts two parameters, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name of the test suite—in this case, <code class="literal">Investment</code></li><li class="listitem" style="list-style-type: disc">A <code class="literal">function</code> that will contain all its specs</li></ul></div><p>Then, to translate the first acceptance criterion (given an investment, it should be of a stock) into a Jasmine spec (or test case), we are going to use another global Jasmine function called <code class="literal">it</code>:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  <span class="strong"><strong>it("should be of a stock", function() {</strong></span>

  <span class="strong"><strong>});</strong></span>
});</pre></div><p>It also accepts two parameters, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The title of the spec—in this case, <code class="literal">should be of a stock</code></li><li class="listitem" style="list-style-type: disc">A function that will contain the spec code</li></ul></div><p>To run this spec, add it to the runner, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!-- include spec files here... --&gt;
<span class="strong"><strong>&lt;script type="text/javascript" src="spec/InvestmentSpec.js"&gt;&lt;/script&gt;</strong></span>
</pre></div><p>Execute the spec by opening the runner on the browser. The following output can be seen:</p><div class="mediaobject"><img src="graphics/B04138_02_03.jpg" alt="Jasmine basics and thinking in BDD"/><div class="caption"><p>This is the first spec's passing result on the browser</p></div></div><p>It might sound strange to <a id="id24" class="indexterm"/>have an empty spec passing, but in Jasmine, as with other test frameworks, a failed assertion is required to make the spec fail.</p><p>An <a id="id25" class="indexterm"/>
<span class="strong"><strong>assertion</strong></span> (or expectation) is a comparison between two values that must result in a boolean value. The assertion is only considered a success if the result of the comparison is true.</p><p>In Jasmine, assertions are written using the global Jasmine function <code class="literal">expect</code>, along with a <span class="strong"><strong>matcher</strong></span><a id="id26" class="indexterm"/> that indicates what comparison must be made with the values.</p><p>Regarding the current spec (it is expected that the investment is of a stock), in Jasmine this translates to the following code:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    <span class="strong"><strong>expect(investment.stock).toBe(stock);</strong></span>
  });
});</pre></div><p>Add the preceding highlighted code to the <code class="literal">InvestmentSpec.js</code> file. The <code class="literal">expect</code> function takes only one parameter, which defines the <span class="strong"><strong>actual value</strong></span>, or in other words, what is going to be tested—<code class="literal">investment.stock</code>—and expects the chaining call to a matcher function, which in this case is <code class="literal">toBe</code>. That defines the <span class="strong"><strong>expected value</strong></span>, <code class="literal">stock</code>, and the comparison method to be performed (to be the same).</p><p>Behind the scenes, Jasmine makes a comparison to check whether the actual value (<code class="literal">investment.stock</code>) and expected value (<code class="literal">stock</code>) are the same, and if they are not, the test fails.</p><p>With the assertion written, the spec that previously passed has now failed, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04138_02_04.jpg" alt="Jasmine basics and thinking in BDD"/><div class="caption"><p>This shows the first spec's failure results</p></div></div><p>This spec failed because, as<a id="id27" class="indexterm"/> the error message states, <code class="literal">investment is not defined</code>.</p><p>The idea here is to do only what the error is indicating us to do, so although you might feel the urge to write something else, for now let's just create this <code class="literal">investment</code> variable with an <code class="literal">Investment</code> instance in the <code class="literal">InvestmentSpec.js</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    <span class="strong"><strong>var investment = new Investment();</strong></span>
    expect(investment.stock).toBe(stock);
  });
});</pre></div><p>Don't worry that the <code class="literal">Investment()</code> function doesn't exist yet; the spec is about to ask for it on the next run, as follows:</p><div class="mediaobject"><img src="graphics/B04138_02_05.jpg" alt="Jasmine basics and thinking in BDD"/><div class="caption"><p>Here the spec asks for an Investment class</p></div></div><p>You can see that the error has changed to <code class="literal">Investment is not defined</code>. It now asks for the <code class="literal">Investment</code> function. So, create a new <code class="literal">Investment.js</code> file in the <code class="literal">src</code> folder and add it to the runner, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- include source files here... --&gt;
&lt;script type="text/javascript" src="src/Investment.js"&gt;&lt;/script&gt;</pre></div><p>To define <code class="literal">Investment</code>, write the<a id="id28" class="indexterm"/> following constructor function in the <code class="literal">Investment.js</code> file inside the <code class="literal">src</code> folder:</p><div class="informalexample"><pre class="programlisting">function Investment () {};</pre></div><p>This makes the error change. It now complains about the missing <code class="literal">stock</code> variable, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04138_02_06.jpg" alt="Jasmine basics and thinking in BDD"/><div class="caption"><p>This shows a missing stock error</p></div></div><p>One more time, we feed the code it is asking for into the <code class="literal">InvestmentSpec.js</code> file, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    <span class="strong"><strong>var stock = new Stock();</strong></span>
    var investment = new Investment();
    expect(investment.stock).toBe(stock);
  });
});</pre></div><p>The error changes again; this time it is about the missing <code class="literal">Stock</code> function:</p><div class="mediaobject"><img src="graphics/B04138_02_07.jpg" alt="Jasmine basics and thinking in BDD"/><div class="caption"><p>Here the spec asks for a Stock class</p></div></div><p>Create a new file in the <code class="literal">src</code> folder, name it <code class="literal">Stock.js</code>, and add it to the runner. Since the <code class="literal">Stock</code> function is going to be a <a id="id29" class="indexterm"/>dependency of <code class="literal">Investment</code>, we should add it just before <code class="literal">Investment.js</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!-- include source files here... --&gt;
<span class="strong"><strong>&lt;script type="text/javascript" src="src/Stock.js"&gt;&lt;/script&gt;</strong></span>
&lt;script type="text/javascript" src="src/Investment.js"&gt;&lt;/script&gt;</pre></div><p>Write the <code class="literal">Stock</code> constructor function to the <code class="literal">Stock.js</code> file:</p><div class="informalexample"><pre class="programlisting">function Stock () {};</pre></div><p>Finally, the error is about the expectation, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04138_02_08.jpg" alt="Jasmine basics and thinking in BDD"/><div class="caption"><p>The expectation is undefined to be Stock</p></div></div><p>To fix this and complete this exercise, open the <code class="literal">Investment.js</code> file inside the <code class="literal">src</code> folder, and add the reference to the <code class="literal">stock</code> parameter:</p><div class="informalexample"><pre class="programlisting">function Investment (stock) {
  <span class="strong"><strong>this.stock = stock;</strong></span>
};</pre></div><p>In the spec file, pass <code class="literal">stock</code> as a parameter to the <code class="literal">Investment</code> function:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    var stock = new Stock();
    var investment = new Investment(<span class="strong"><strong>stock</strong></span>);
    expect(investment.stock).toBe(stock);
  });
});</pre></div><p>Finally, you will have a passing spec:</p><div class="mediaobject"><img src="graphics/B04138_02_09.jpg" alt="Jasmine basics and thinking in BDD"/><div class="caption"><p>This shows an Investment spec that passes</p></div></div><p>This exercise was <a id="id30" class="indexterm"/>meticulously conducted to show how a developer works by feeding the spec with what it wants when doing test-first development.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>The drive to write code must come from a spec that has failed. You must not write code unless its purpose is to fix a failed spec.</p></div></div></div>
<div class="section" title="Setup and teardown"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Setup and teardown</h1></div></div></div><p>There are three more<a id="id31" class="indexterm"/> acceptance criteria to be <a id="id32" class="indexterm"/>implemented. The next in the list is as follows:</p><p>"Given an investment, it should have the invested shares' quantity."</p><p>Writing it should be as simple as the previous spec was. In the <code class="literal">InvestmentSpec.js</code> file inside the <code class="literal">spec</code> folder, you can translate this new criterion into a new spec called <code class="literal">should have the invested shares' quantity</code>, as follows:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  it("should be of a stock", function() {
    var stock = new Stock();
    var investment = new Investment(<span class="strong"><strong>{</strong></span>
      <span class="strong"><strong>stock: stock,</strong></span>
      <span class="strong"><strong>shares: 100</strong></span>
    <span class="strong"><strong>}</strong></span>);
    expect(investment.stock).toBe(stock);
  });

  <span class="strong"><strong>it("should have the invested shares' quantity", function() {</strong></span>
<span class="strong"><strong>    var stock = new Stock();</strong></span>
<span class="strong"><strong>    var investment = new Investment({</strong></span>
<span class="strong"><strong>      stock: stock,</strong></span>
<span class="strong"><strong>      shares: 100</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>    expect(investment.shares).toEqual(100);</strong></span>
<span class="strong"><strong>  });</strong></span>
});</pre></div><p>You can see that <a id="id33" class="indexterm"/>apart from having written the new spec, we have also changed the call to the <code class="literal">Investment</code> constructor to <a id="id34" class="indexterm"/>support the new <code class="literal">shares</code> parameter.</p><p>To do so, we used an object as a single parameter in the constructor to simulate named parameters, a feature JavaScript doesn't have natively.</p><p>Implementing this in the <code class="literal">Investment</code> function is pretty simple—instead of having multiple parameters on the function declaration, it has only one, which is expected to be an object. Then, the function probes each of its expected parameters from this object, making the proper assignments, as shown here:</p><div class="informalexample"><pre class="programlisting">function Investment (<span class="strong"><strong>params</strong></span>) {
  <span class="strong"><strong>this.stock = params.stock;</strong></span>
};</pre></div><p>The code is now refactored. We can run the tests to see that only the new spec fails, as shown here:</p><div class="mediaobject"><img src="graphics/B04138_02_10.jpg" alt="Setup and teardown"/><div class="caption"><p>This shows the failing shares spec</p></div></div><p>To fix this, change the <code class="literal">Investment</code> constructor to make the assignment to the <code class="literal">shares</code> property, as follows:</p><div class="informalexample"><pre class="programlisting">function Investment (params) {
  this.stock = params.stock;
  <span class="strong"><strong>this.shares = params.shares;</strong></span>
};</pre></div><p>Finally, everything on your screen is green:</p><div class="mediaobject"><img src="graphics/B04138_02_11.jpg" alt="Setup and teardown"/><div class="caption"><p>This shows the passing shares spec</p></div></div><p>But as you can see, the <a id="id35" class="indexterm"/>following<a id="id36" class="indexterm"/> code, which instantiates <code class="literal">Stock</code> and <code class="literal">Investment</code>, is duplicated on both specs:</p><div class="informalexample"><pre class="programlisting">var stock = new Stock();
var investment = new Investment({
  stock: stock,
  shares: 100
});</pre></div><p>To eliminate this duplication, Jasmine provides another global function called <code class="literal">beforeEach</code> that, as the name states, is executed once before each spec. So, for these two specs, it will run twice—once before each spec.</p><p>Refactor the previous specs by extracting the setup code using the <code class="literal">beforeEach</code> function:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  <span class="strong"><strong>var stock, investment;</strong></span>

  <span class="strong"><strong>beforeEach(function() {</strong></span>
    <span class="strong"><strong>stock = new Stock();</strong></span>
    <span class="strong"><strong>investment = new Investment({</strong></span>
      <span class="strong"><strong>stock: stock,</strong></span>
      <span class="strong"><strong>shares: 100</strong></span>
    <span class="strong"><strong>});</strong></span>
  <span class="strong"><strong>});</strong></span>

  it("should be of a stock", function() {
    expect(investment.stock).toBe(stock);
  });

  it("should have the invested shares quantity", function() {
    expect(investment.shares).toEqual(100);
  });
});</pre></div><p>This looks much <a id="id37" class="indexterm"/>cleaner; we not only <a id="id38" class="indexterm"/>removed the code duplication, but also simplified the specs. They became much easier to read and maintain since their only responsibility now is to fulfill the expectation.</p><p>There is also a <span class="strong"><strong>teardown</strong></span> function (<code class="literal">afterEach</code>) that sets the code to be executed after each spec. It is very useful in situations where a cleanup is required after each spec. We will see an example of its application in <a class="link" href="ch06.html" title="Chapter 6. Light Speed Unit Testing">Chapter 6</a>, <span class="emphasis"><em>Light Speed Unit Testing</em></span>.</p><p>To finish the specification of <code class="literal">Investment</code>, add the remaining two specs to the <code class="literal">InvestmentSpec.js</code> file, inside the <code class="literal">spec</code> folder:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  var stock;
  var investment;

  beforeEach(function() {
    stock = new Stock();
    investment = new Investment({
      stock: stock,
      shares: 100,
      <span class="strong"><strong>sharePrice: 20</strong></span>
    });
  });

  //... other specs

  <span class="strong"><strong>it("should have the share paid price", function() {</strong></span>
    <span class="strong"><strong>expect(investment.sharePrice).toEqual(20);</strong></span>
  <span class="strong"><strong>});</strong></span>

  <span class="strong"><strong>it("should have a cost", function() {</strong></span>
    <span class="strong"><strong>expect(investment.cost).toEqual(2000);</strong></span>
  <span class="strong"><strong>});</strong></span>
});</pre></div><p>Run the specs to see them fail, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04138_02_12.jpg" alt="Setup and teardown"/><div class="caption"><p>This shows the failing cost and price specs</p></div></div><p>Add the following <a id="id39" class="indexterm"/>code to fix them in<a id="id40" class="indexterm"/> the <code class="literal">Investment.js</code> file inside the <code class="literal">src</code> folder:</p><div class="informalexample"><pre class="programlisting">function Investment (params) {
  this.stock = params.stock;
  this.shares = params.shares;
  <span class="strong"><strong>this.sharePrice = params.sharePrice;</strong></span>
  <span class="strong"><strong>this.cost = this.shares * this.sharePrice;</strong></span>
};</pre></div><p>Run the specs for the last time to see them pass:</p><div class="mediaobject"><img src="graphics/B04138_02_13.jpg" alt="Setup and teardown"/><div class="caption"><p>This shows all four Investment specs passing</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>It is important to always see a spec fail before writing the code to fix it; otherwise, how would you know that you really need to fix it? Imagine this as a way to test the test.</p></div></div></div>
<div class="section" title="Nested describes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Nested describes</h1></div></div></div><p><span class="strong"><strong>Nested describes</strong></span><a id="id41" class="indexterm"/> are useful when you want to describe similar behavior between specs. Suppose we want the following two new acceptance criteria:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Given an investment, when its stock share price valorizes, it should have a positive<a id="id42" class="indexterm"/> <span class="strong"><strong>return on investment</strong></span> (<span class="strong"><strong>ROI</strong></span>)</li><li class="listitem" style="list-style-type: disc">Given an investment, when its stock share price valorizes, it should be a good investment</li></ul></div><p>Both these criteria share the same behavior when the investment's stock share price valorizes.</p><p>To translate this into Jasmine, you can nest a call to the <code class="literal">describe</code> function inside the existing one in the <code class="literal">InvestmentSpec.js</code> file (I removed the rest of the code for the purpose of demonstration; it is still there):</p><div class="informalexample"><pre class="programlisting">describe("Investment", function()
  <span class="strong"><strong>describe("when its stock share price valorizes", function() {</strong></span>
   
  <span class="strong"><strong>});</strong></span>
});</pre></div><p>It should behave just like the outer one, so you can add specs (<code class="literal">it</code>) and use the setup and teardown functions (<code class="literal">beforeEach</code>, <code class="literal">afterEach</code>).</p><div class="section" title="Setup and teardown"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Setup and teardown</h2></div></div></div><p>When using the <a id="id43" class="indexterm"/>setup and teardown <a id="id44" class="indexterm"/>functions, Jasmine respects the outer setup and teardown functions as well, so that they are run as expected. For each spec (<code class="literal">it</code>), the following actions are performed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Jasmine runs all setup functions (<code class="literal">beforeEach</code>) from the outside in</li><li class="listitem" style="list-style-type: disc">Jasmine runs a spec code (<code class="literal">it</code>)</li><li class="listitem" style="list-style-type: disc">Jasmine runs all the teardown functions (<code class="literal">afterEach</code>) from the inside out</li></ul></div><p>So, we can <a id="id45" class="indexterm"/>add a setup function to this new <code class="literal">describe</code> function that changes the <a id="id46" class="indexterm"/>share price of the stock, so that it's greater than the share price of the investment:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  var stock;
  var investment;

  beforeEach(function() {
    stock = new Stock();
    investment = new Investment({
      stock: stock,
      shares: 100,
      sharePrice: 20
    });
  });

  describe("when its stock share price valorizes", function() {
    <span class="strong"><strong>beforeEach(function() {</strong></span>
      <span class="strong"><strong>stock.sharePrice = 40;</strong></span>
    <span class="strong"><strong>});</strong></span>
  });
});</pre></div></div><div class="section" title="Coding a spec with shared behavior"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Coding a spec with shared behavior</h2></div></div></div><p>Now that we have the <a id="id47" class="indexterm"/>shared behavior implemented, we can start<a id="id48" class="indexterm"/> coding the acceptance criteria described earlier. Each is, just as before, a call to the global Jasmine function <code class="literal">it</code>:</p><div class="informalexample"><pre class="programlisting">describe("Investment", function() {
  describe("when its stock share price valorizes", function() {
    beforeEach(function() {
      stock.sharePrice = 40;
    });

    <span class="strong"><strong>it("should have a positive return of investment", function() {</strong></span>
      <span class="strong"><strong>expect(investment.roi()).toEqual(1);</strong></span>
    <span class="strong"><strong>});</strong></span>

    <span class="strong"><strong>it("should be a good investment", function() {</strong></span>
      <span class="strong"><strong>expect(investment.isGood()).toEqual(true);</strong></span>
    <span class="strong"><strong>});</strong></span>
  });
});</pre></div><p>After adding the missing functions to <code class="literal">Investment</code> in the <code class="literal">Investment.js</code> file:</p><div class="informalexample"><pre class="programlisting">Investment.prototype.<span class="strong"><strong>roi</strong></span> = function() {
  return (this.stock.sharePrice - this.sharePrice) / this.sharePrice;
};

Investment.prototype.<span class="strong"><strong>isGood</strong></span> = function() {
  return this.roi() &gt; 0;
};</pre></div><p>You can run the <a id="id49" class="indexterm"/>specs and <a id="id50" class="indexterm"/>see that they pass:</p><div class="mediaobject"><img src="graphics/B04138_02_14.jpg" alt="Coding a spec with shared behavior"/><div class="caption"><p>This shows the  nested describe specs pass</p></div></div></div><div class="section" title="Understanding matchers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Understanding matchers</h2></div></div></div><p>By now, you've already seen<a id="id51" class="indexterm"/> plenty of usage examples for matchers and probably can feel how they work.</p><p>You have seen how to use the <code class="literal">toBe</code> and <code class="literal">toEqual</code> matchers. These are the two base built-in matchers available in Jasmine, but we can extend Jasmine by writing matchers of our own.</p><p>So, to really understand how Jasmine matchers work, we need to create one ourselves.</p><div class="section" title="Custom matchers"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Custom matchers</h3></div></div></div><p>Consider this <a id="id52" class="indexterm"/>expectation from the previous section:</p><div class="informalexample"><pre class="programlisting">expect(investment.isGood()).toEqual(true);</pre></div><p>Although it works, it is not <a id="id53" class="indexterm"/>very expressive. Imagine if we could instead rewrite it as:</p><div class="informalexample"><pre class="programlisting">expect(investment).toBeAGoodInvestment();</pre></div><p>This creates a much better relation with the acceptance criterion:</p><p>So, here "should be a good investment" becomes "expect investment to be a good investment".</p><p>Implementing it is quite simple. You do so by calling the <code class="literal">jasmine.addMatchers</code> function—ideally inside a setup step (<code class="literal">beforeEach</code>).</p><p>Although you can put this new matcher definition inside the <code class="literal">InvestmentSpec.js</code> file, Jasmine already has a default place to add custom matchers, the <code class="literal">SpecHelper.js</code> file, inside the <code class="literal">spec</code> folder. If you are using Standalone Distribution, it already comes with a sample custom matcher; delete it and let's start from scratch.</p><p>The <code class="literal">addMatchers</code> function accepts a single parameter—an object where each attribute corresponds to a new matcher. So, to add the following new matcher, change the contents of the <code class="literal">SpecHelper.js</code> file to the following:</p><div class="informalexample"><pre class="programlisting">beforeEach(function() {
  jasmine.addMatchers({
    <span class="strong"><strong>toBeAGoodInvestment: function() {}</strong></span>
  });
});</pre></div><p>The function being defined here is not the matcher itself but a factory function to build the matcher. Its purpose, once called is to return an object containing a compare function, as follows:</p><div class="informalexample"><pre class="programlisting">jasmine.addMatchers({
  toBeAGoodInvestment: function () {
    <span class="strong"><strong>return</strong></span> <span class="strong"><strong>{</strong></span>
<span class="strong"><strong>      compare: function (actual, expected) {</strong></span>
<span class="strong"><strong>        // matcher definition</strong></span>
<span class="strong"><strong>      }</strong></span>
    };
  }
});</pre></div><p>The <code class="literal">compare</code> function will contain the actual matcher implementation, and as can be observed by its signature, it receives both values being compared (the <code class="literal">actual</code> and <code class="literal">expected</code> values).</p><p>For the given example, the <code class="literal">investment</code> object will be available in the <code class="literal">actual</code> argument.</p><p>Then, Jasmine expects, as the result of this <code class="literal">compare</code> function, an object with a <code class="literal">pass</code> attribute with a boolean value <code class="literal">true</code> to indicate that the expectation passes and <code class="literal">false</code> if the expectation fails.</p><p>Let's have a<a id="id54" class="indexterm"/> look at the following valid implementation<a id="id55" class="indexterm"/> of the <code class="literal">toBeAGoodInvestment</code> matcher:</p><div class="informalexample"><pre class="programlisting">toBeAGoodInvestment: function () {
  return {
    compare: function (actual, expected) {
      <span class="strong"><strong>var result = {};</strong></span>
<span class="strong"><strong>      result.pass = actual.isGood();</strong></span>
<span class="strong"><strong>      return result;</strong></span>
    }
  };
}</pre></div><p>By now, this matcher is ready to be used by the specs:</p><div class="informalexample"><pre class="programlisting">it("should be a good investment", function() {
  <span class="strong"><strong>expect(investment).toBeAGoodInvestment();</strong></span>
});</pre></div><p>After the change, the specs should still pass. But what happens if a spec fails? What is the error message that Jasmine reports?</p><p>We can see it by deliberately breaking the <code class="literal">investment.isGood</code> implementation in the <code class="literal">Investment.js</code> file, in the <code class="literal">src</code> folder to always return <code class="literal">false</code>:</p><div class="informalexample"><pre class="programlisting">Investment.prototype.isGood = function() {
  <span class="strong"><strong>return false;</strong></span>
};</pre></div><p>When running the specs again, Jasmine generates an error message stating <code class="literal">Expected { stock: { sharePrice: 40 }, shares: 100, sharePrice: 20, cost: 2000 } to be a good investment</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04138_02_15.jpg" alt="Custom matchers"/><div class="caption"><p>This is the custom matcher's message</p></div></div><p>Jasmine does a great job generating this error message, but it also allows its customization via the <code class="literal">result.message</code> property of the object returned as the result of the matcher. Jasmine expects this property to be a string with the following error message:</p><div class="informalexample"><pre class="programlisting">toBeAGoodInvestment: function () {
  return {
    compare: function (actual, expected) {
      var result = {};
      result.pass = actual.isGood();
      <span class="strong"><strong>result.message = 'Expected investment to be a good investment';</strong></span>
      return result;
    }
  };
}</pre></div><p>Run the specs<a id="id56" class="indexterm"/> again and the error message should <a id="id57" class="indexterm"/>change:</p><div class="mediaobject"><img src="graphics/B04138_02_16.jpg" alt="Custom matchers"/><div class="caption"><p>This is the custom matcher's custom message</p></div></div><p>Now, let's consider another acceptance criterion:</p><p>"Given an investment, when its stock share price devalorizes, it should be a bad investment."</p><p>Although it is possible to create a new custom matcher (<code class="literal">toBeABadInvestment</code>), Jasmine allows the negation of any matcher by chaining <code class="literal">not</code> before the matcher call. So, we can write that "a bad investment" is "not a good investment"</p><div class="informalexample"><pre class="programlisting">expect(investment).<span class="strong"><strong>not</strong></span>.toBeAGoodInvestment();</pre></div><p>Implement this new acceptance criterion in the <code class="literal">InvestmentSpec.js</code> file inside the <code class="literal">spec</code> folder by adding new and nested <code class="literal">describe</code> and <code class="literal">spec</code>, as follows:</p><div class="informalexample"><pre class="programlisting">describe("when its stock share price devalorizes", function() {
  beforeEach(function() {
    stock.sharePrice = 0;
  });

  it("should have a negative return of investment", function() {
    expect(investment.roi()).toEqual(-1);
  });

  it("should be a bad investment", function() {
    expect(investment).not.toBeAGoodInvestment();
  });
});</pre></div><p>But there is a catch! Let's break the <code class="literal">investment</code> implementation in the <code class="literal">Investment.js</code> file code so that it is always a good investment, as follows:</p><div class="informalexample"><pre class="programlisting">Investment.prototype.isGood = function() {
  <span class="strong"><strong>return true;</strong></span>
};</pre></div><p>After running the<a id="id58" class="indexterm"/> specs again, you can see that this new spec fails, but the <a id="id59" class="indexterm"/>error message, <code class="literal">Expected investment to be a good investment</code>, is wrong, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04138_02_17.jpg" alt="Custom matchers"/><div class="caption"><p>This is the custom matcher's wrong custom negated message</p></div></div><p>That is the message that was hardcoded inside the matcher. To fix this, you need to make the message dynamic.</p><p>Jasmine only shows the message if the matcher fails, so the proper way of making this message dynamic is to consider what message is supposed to be shown when the given comparison is invalid:</p><div class="informalexample"><pre class="programlisting">compare: function (actual, expected) {
  var result = {};
  result.pass = actual.isGood();

<span class="strong"><strong>  if (actual.isGood()) {</strong></span>
<span class="strong"><strong>    result.message = 'Expected investment to be a bad investment';</strong></span>
<span class="strong"><strong>  } else {</strong></span>
<span class="strong"><strong>    result.message = 'Expected investment to be a good investment';</strong></span>
<span class="strong"><strong>  }</strong></span>

  return result;
}</pre></div><p>This fixes the message, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04138_02_18.jpg" alt="Custom matchers"/><div class="caption"><p>This shows the custom matcher's custom dynamic message</p></div></div><p>Now this <a id="id60" class="indexterm"/>matcher can be used anywhere.</p><p>Before continuing in<a id="id61" class="indexterm"/> the chapter, change the <code class="literal">isGood</code> method back again to its correct implementation:</p><div class="informalexample"><pre class="programlisting">Investment.prototype.isGood = function() {
  return this.roi() &gt; 0;
};</pre></div><p>What this example lacked was a way to show how to pass an expected value to a matcher like this:</p><div class="informalexample"><pre class="programlisting">expect(investment.cost).toBe(2000)</pre></div><p>It turns out that a matcher can receive any number of expected values as parameters. So, for instance, the preceding matcher could be implemented in the <code class="literal">SpecHelper.js</code> file, inside the <code class="literal">spec</code> folder, as follows:</p><div class="informalexample"><pre class="programlisting">beforeEach(function() {
  jasmine.addMatchers({
    toBe: function () {
      return {
        compare: function (actual, <span class="strong"><strong>expected</strong></span>) {
          return actual === <span class="strong"><strong>expected</strong></span>;
        }
      };
    }
  });
});</pre></div><p>By implementing any matcher, check first whether there is one available that already does what you want.</p><p>For more information, check the official <a id="id62" class="indexterm"/>documentation at the Jasmine website <a class="ulink" href="http://jasmine.github.io/2.1/custom_matcher.html">http://jasmine.github.io/2.1/custom_matcher.html</a>.</p></div><div class="section" title="Built-in matchers"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Built-in matchers</h3></div></div></div><p>Jasmine comes <a id="id63" class="indexterm"/>with a bunch of default matchers covering the basis of value checking in the JavaScript language. To understand how they work and where to use them properly is a journey of how JavaScript handles type.</p><div class="section" title="The toEqual built-in matcher"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec01"/>The toEqual built-in matcher</h4></div></div></div><p>The <code class="literal">toEqual</code> matcher is <a id="id64" class="indexterm"/>probably the most commonly used matcher, and you should <a id="id65" class="indexterm"/>use it whenever you want to check equality between two values.</p><p>It works for all primitive values (number, string, and boolean) as well as any object (including arrays), as shown in the following code:</p><div class="informalexample"><pre class="programlisting">describe("toEqual", function() {
  it("should pass equal numbers", function() {
    expect(1).toEqual(1);
  });

  it("should pass equal strings", function() {
    expect("testing").toEqual("testing");
  });

  it("should pass equal booleans", function() {
    expect(true).toEqual(true);
  });

  it("should pass equal objects", function() {
    expect({a: "testing"}).toEqual({a: "testing"});
  });

  it("should pass equal arrays", function() {
    expect([1, 2, 3]).toEqual([1, 2, 3]);
  });
});</pre></div></div><div class="section" title="The toBe built-in matcher"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec02"/>The toBe built-in matcher</h4></div></div></div><p>The <code class="literal">toBe</code> matcher <a id="id66" class="indexterm"/>has a very similar behavior to the <code class="literal">toEqual</code> matcher; in fact, it<a id="id67" class="indexterm"/> gives the same result while comparing primitive values, but the similarities stop there.</p><p>While the <code class="literal">toEqual</code> matcher has a complex implementation (you should take a look at the Jasmine source code) that checks whether all attributes of an object and all elements of an array are the same, here it is a simple use of the <a id="id68" class="indexterm"/>
<span class="strong"><strong>strict equals operator</strong></span> (<code class="literal">===</code>).</p><p>If you are unfamiliar with the strict equals operator, its main difference from the <span class="strong"><strong>equals operator</strong></span> (<code class="literal">==</code>)<a id="id69" class="indexterm"/> is that the latter performs type coercion if the compared<a id="id70" class="indexterm"/> values <a id="id71" class="indexterm"/>aren't of the same type.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>The strict equals operator always considers false any comparison between values of distinct types.</p></div></div><p>Here are some examples of how this matcher (and the strict equals operator) works:</p><div class="informalexample"><pre class="programlisting">describe("toBe", function() {
  it("should pass equal numbers", function() {
    expect(1).toBe(1);
  });

  it("should pass equal strings", function() {
    expect("testing").toBe("testing");
  });

  it("should pass equal booleans", function() {
    expect(true).toBe(true);
  });

  it("should pass same objects", function() {
    var object = {a: "testing"};
    expect(object).toBe(object);
  });

  it("should pass same arrays", function() {
    var array = [1, 2, 3];
    expect(array).toBe(array);
  });

  it("should not pass equal objects", function() {
    expect({a: "testing"}).not.toBe({a: "testing"});
  });

  it("should not pass equal arrays", function() {
    expect([1, 2, 3]).not.toBe([1, 2, 3]);
  });
});</pre></div><p>It is advised that you use the <code class="literal">toEqual</code> operator in most cases and resort to the <code class="literal">toBe</code> matcher only when you want to check whether two variables reference the same object.</p></div><div class="section" title="The toBeTruthy and toBeFalsy matchers"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec03"/>The toBeTruthy and toBeFalsy matchers</h4></div></div></div><p>Besides its<a id="id72" class="indexterm"/> primitive boolean type, everything else in the JavaScript<a id="id73" class="indexterm"/> language also has an inherent boolean value, which is <a id="id74" class="indexterm"/>generally known to be either <span class="strong"><strong>truthy</strong></span> or <span class="strong"><strong>falsy</strong></span>.</p><p>Luckily in JavaScript, there are<a id="id75" class="indexterm"/> only a few values that are identified as falsy, as shown in the following examples for the <code class="literal">toBeFalsy</code> matcher:</p><div class="informalexample"><pre class="programlisting">describe("toBeFalsy", function () {
  it("should pass undefined", function() {
    expect(undefined).toBeFalsy();
  });

  it("should pass null", function() {
    expect(null).toBeFalsy();
  });

  it("should pass NaN", function() {
    expect(NaN).toBeFalsy();
  });

  it("should pass the false boolean value", function() {
    expect(false).toBeFalsy();
  });

  it("should pass the number 0", function() {
    expect(0).toBeFalsy();
  });

  it("should pass an empty string", function() {
    expect("").toBeFalsy();
  });
});</pre></div><p>Everything else is considered truthy, as demonstrated by the following examples of the <code class="literal">toBeTruthy</code> matcher:</p><div class="informalexample"><pre class="programlisting">describe("toBeTruthy", function() {
  it("should pass the true boolean value", function() {
    expect(true).toBeTruthy();
  });

  it("should pass any number different than 0", function() {
    expect(1).toBeTruthy();
  });
  it("should pass any non empty string", function() {
    expect("a").toBeTruthy();
  });

  it("should pass any object (including an array)", function() {
    expect([]).toBeTruthy();
    expect({}).toBeTruthy();
  });
});</pre></div><p>But, if you <a id="id76" class="indexterm"/>want to<a id="id77" class="indexterm"/> check whether something is equal to an actual <a id="id78" class="indexterm"/>boolean value, it might be a better idea to use the <code class="literal">toEqual</code> <a id="id79" class="indexterm"/>matcher.</p></div><div class="section" title="The toBeUndefined, toBeNull, and toBeNaN built-in matchers"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec04"/>The toBeUndefined, toBeNull, and toBeNaN built-in matchers</h4></div></div></div><p>These <a id="id80" class="indexterm"/>matchers<a id="id81" class="indexterm"/> are pretty <a id="id82" class="indexterm"/>straightforward and should be used to <a id="id83" class="indexterm"/>check for <code class="literal">undefined</code>, <code class="literal">null</code>, <a id="id84" class="indexterm"/>and <code class="literal">NaN</code> <a id="id85" class="indexterm"/>values:</p><div class="informalexample"><pre class="programlisting">describe("toBeNull", function() {
  it("should pass null", function() {
    expect(null).toBeNull();
  });
});

describe("toBeUndefined", function() {
  it("should pass undefined", function() {
    expect(undefined).toBeUndefined();
  });
});

describe("toBeNaN", function() {
  it("should pass NaN", function() {
    expect(NaN).toBeNaN();
  });
});</pre></div><p>Both <code class="literal">toBeNull</code> and <code class="literal">toBeUndefined</code> can be written as <code class="literal">toBe(null)</code> and <code class="literal">toBe(undefined)</code> respectively, but that is not the case with <code class="literal">toBeNaN</code>.</p><p>In JavaScript, the <code class="literal">NaN</code> value is not equal to any value, not even <code class="literal">NaN</code>. So, trying to compare it to itself is always <code class="literal">false</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">NaN === NaN // false</pre></div><p>As good practice, try to use these matchers instead of their <code class="literal">toBe</code> counterparts whenever possible.</p></div><div class="section" title="The toBeDefined built-in matcher"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec05"/>The toBeDefined built-in matcher</h4></div></div></div><p>This matcher is useful if<a id="id86" class="indexterm"/> you want to check whether a variable is defined<a id="id87" class="indexterm"/> and you don't care about its value, as follows:</p><div class="informalexample"><pre class="programlisting">describe("toBeDefined", function() {
  it("should pass any value other than undefined", function() {
    expect(null).toBeDefined();
  });
});</pre></div><p>Anything except <code class="literal">undefined</code> will pass under this matcher, even <code class="literal">null</code>.</p></div><div class="section" title="The toContain built-in matcher"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec06"/>The toContain built-in matcher</h4></div></div></div><p>Sometimes, it is <a id="id88" class="indexterm"/>desirable to check whether an array contains an element, or <a id="id89" class="indexterm"/>whether a string can be found inside another string. For these use cases, you can use the <code class="literal">toContain</code> matcher, as follows:</p><div class="informalexample"><pre class="programlisting">describe("toContain", function() {
  it("should pass if a string contains another string", function()  {
    expect("My big string").toContain("big");
  });

  it("should pass if an array contains an element", function() {
    expect([1, 2, 3]).toContain(2);
  });
});</pre></div></div><div class="section" title="The toMatch built-in matcher"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec07"/>The toMatch built-in matcher</h4></div></div></div><p>Although<a id="id90" class="indexterm"/> the <code class="literal">toContain</code> and <code class="literal">toEqual</code> matchers can be used in most string <a id="id91" class="indexterm"/>comparisons, sometimes the only way to assert whether a string value is correct is through a regular expression. For these cases, you can use the <code class="literal">toMatch</code> matcher along with a regular expression, as follows:</p><div class="informalexample"><pre class="programlisting">describe("toMatch", function() {
  it("should pass a matching string", function() {
    expect("My big matched string").toMatch(/My(.+)string/);
  });
});</pre></div><p>The matcher works by testing the actual value (<code class="literal">"My big matched string"</code>) against the expected regular expression (<code class="literal">/My(.+)string/</code>).</p></div><div class="section" title="The toBeLessThan and toBeGreaterThan built-in matchers"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec08"/>The toBeLessThan and toBeGreaterThan built-in matchers</h4></div></div></div><p>The <code class="literal">toBeLessThan</code> <a id="id92" class="indexterm"/>and <code class="literal">toBeGreaterThan</code> matchers are simple and used <a id="id93" class="indexterm"/>to perform numeric comparisons—something <a id="id94" class="indexterm"/>that is best described by the following<a id="id95" class="indexterm"/> examples:</p><div class="informalexample"><pre class="programlisting">  describe("toBeLessThan", function() {
    it("should pass when the actual is less than expected", function() {
      expect(1).toBeLessThan(2);
    });
  });

  describe("toBeGreaterThan", function() {
    it("should pass when the actual is greater than expected", function() {
      expect(2).toBeGreaterThan(1);
    });
  });</pre></div></div><div class="section" title="The toBeCloseTo built-in matcher"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec09"/>The toBeCloseTo built-in matcher</h4></div></div></div><p>This is a special <a id="id96" class="indexterm"/>matcher used to compare floating-point numbers <a id="id97" class="indexterm"/>with a defined set of precision—something that is best explained by this example:</p><div class="informalexample"><pre class="programlisting">describe("toBeCloseTo", function() {
    it("should pass when the actual is closer with a given precision", function() {
      expect(3.1415).toBeCloseTo(2.8, 0);
      expect(3.1415).not.toBeCloseTo(2.8, 1);
    });
  });</pre></div><p>The first parameter is the number being compared, and the second is the precision in the number of decimal cases.</p></div><div class="section" title="The toThrow built-in matcher"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec10"/>The toThrow built-in matcher</h4></div></div></div><p>Exceptions are <a id="id98" class="indexterm"/>a language's way of demonstrating when something goes <a id="id99" class="indexterm"/>wrong.</p><p>So, for example, while coding an API, you might decide to throw an exception when a parameter is passed incorrectly. So, how do you test this code?</p><p>Jasmine has the built-in <code class="literal">toThrow</code> matcher that can be used to verify that an exception has been thrown.</p><p>The way it works is a little bit different from the other matchers. Since the matcher has to run a piece of code and check whether it throws an exception, the matcher's <span class="strong"><strong>actual</strong></span> value must be a function.</p><p>Here is an example of how it works:</p><div class="informalexample"><pre class="programlisting">describe("toThrow", function() {
  it("should pass when the exception is thrown", function() {
    expect(function () {
      throw "Some exception";
    }).toThrow("Some exception");
  });
});</pre></div><p>When the test is run, the anonymous function is executed, and if it throws the <code class="literal">Some exception</code> exception, the test passes.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, you learned how to think in BDD and drive your code from your specs. You also became acquainted with the basic Jasmine global functions (<code class="literal">describe</code>, <code class="literal">it</code>, <code class="literal">beforeEach</code>, and <code class="literal">afterEach</code>) and have a good understanding of what is required to create a spec in Jasmine.</p><p>You got familiar with Jasmine matchers and know how powerful they are in describing a spec intent. You even learned to create a matcher of your own.</p><p>By now, you should be familiar with creating new specs and driving the development of your new application.</p><p>In the next chapter, we are going to take a look at how we can use the concepts learned in this chapter to start testing web applications, which are most commonly jQuery and HTML forms.</p></div></body></html>