- en: Chapter 2. Working with Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone view works as the presentation layer of an application. In simple terms,
    you can define it as an abstract layer for your HTML element. It doesn't contain
    any HTML markup of its own, but it contains the logic to present your model's
    data with the help of JavaScript templates.
  prefs: []
  type: TYPE_NORMAL
- en: If you go through the annotated source of Backbone view, you will find that
    `Backbone.View` is a small class with very few methods, including an empty `initialize()`
    method and an almost empty `render()` method, which are in general meant to be
    overridden by any custom view class. In this chapter, we will investigate some
    common problems and the solutions to these problems with respect to the Backbone
    views that developers face mostly while developing real-world Backbone.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic issues with Backbone are associated with view rendering or updating
    and maintaining multiple views within an application. We will analyze the following
    topics based on complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic usage of views**: We will learn the basic concepts of Backbone view,
    its properties, functions, and event-handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updating a view partially**: We will learn how to update only a part of a
    view without the need for re-rendering the complete view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested views**: As the complexity of an application layout increases, we
    feel the need to maintain a hierarchy of multiple views. Nested views or subviews
    simplify event-handling and layout management to a great extent. We will explore
    the following topics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we need to use subviews
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to initialize and render nested views
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to avoid DOM reflow in the case of a large collection of nested views and
    a complex view DOM structure
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to clean up resources (child views, events) when you delete a parent view
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: Templates are an essential part of Backbone and are used in
    combination with views to create reusable copies of HTML markup. We will discuss
    the following topics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different options for storing and loading template files
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of template precompilation and storing precompiled templates
    on the client side
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The usage of template helper functions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marionette views**: We can reduce the view boilerplate code using the custom
    view extensions of the Marionette library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout manager**: We can simplify the complex layout architecture using the
    Backbone layout manager plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic usage of views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Backbone views are the tools that provide a logical structure to the HTML markup
    of your application. Views represent the data of Backbone models or collections
    via JavaScript templates. For any change in the associated model or collection,
    you do not need to redraw the complete page, only update the relevant view—that''s
    it. A basic view can be defined this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we created a simple HTML markup, placed it inside this view's element,
    and showed the view in the DOM. Let's understand the concept further by looking
    at all the steps.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the el property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What is the `this.$el` property? It is the property that points to the jQuery-wrapped
    version of `el`. Every view possesses an `el` property that either holds a DOM
    reference where the view is ultimately going to be rendered, or an HTML element
    that functions as the main element of the view. In the previous example, we didn''t
    specify the `el` property. So, as soon as we instantiated the view, the `el` element
    was available to us though it was not rendered in the DOM. We had to do this rendering
    explicitly by appending the view element to the `#container` element. However,
    if we had mentioned the `el` property pointing to the `#container` element in
    the view definition or while creating it''s instance, we wouldn''t need to append
    it specifically to the document. Like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This generates the same result as the first example. However, this methodology
    creates problems when you make multiple instances of the `UserView` class, as
    all of them point to the same element as given in `el`, and because the last instance
    will overwrite the previous ones. However, this can be minimized if you pass the
    `el` property each time you create the view instance, though it is not a very
    good practice. Also, another problem related to view destroy still persists—if
    you destroy this view, it removes the `#container` element too—so, if you create
    another `UserView` instance passing the same `#container` element as the `el`
    property later, it throws an error. It is good practice to let the view create
    its own element and make the parent views or the layout manager take care of rendering
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other properties that relate to the `el` property of the Backbone
    view; these are `tagName`, `id`, `className`, and `attributes`. The `tagName`
    property expects an HTML tag name as the value that the main element of the view
    will be created with. For example, if you specify `tagName` as `'ul'`, the `el`
    element that is created by Backbone will be an empty `UL` element. By default,
    `tagName` has the value `'div'`, that is, the view element will be a `DIV` element
    if nothing is specified as `tagName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `id` and `className` properties specify the element''s ID and CSS classes
    respectively. The `attributes` property holds all of the HTML attributes as an
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting view element will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Listening to view events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can attach DOM event listeners to the DOM elements using the `events` property
    of view. These events can only be registered on the view element along with its
    child elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We added a `click` event on the button and defined the handler to be called
    once the user clicks on that button.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone delegates all of the view events, so that the events are attached even
    if the element is not rendered in the DOM. So, if you add one event hash for an
    element that is not yet available inside the view DOM, the event will be attached
    to it as soon as the element is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying model data with templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most important part as the main purpose of a view is to display
    the data attached to it. In the simplest case, one Backbone view is attached to
    each model, and it keeps itself updated with the model change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is pretty simple to understand; here we pass a `model` instance
    to the view and set the model value to the template inside the `render()` function.
    Once rendered, the view will show the HTML markup with the model data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to ensure that the changes in any attribute of the model should
    be reflected in the view immediately. We can achieve this functionality by listening
    to the model''s `change` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `initialize()` method, we listen to the model's `change` event and re-render
    the view. We can use both `on()` and `listenTo()` for this functionality, but
    the advantage of the latter over the former is that it automatically unbinds all
    the events that were added with the `listenTo()` method if the view is destroyed.
    On the other hand, you have to unbind these events explicitly if you bind events
    using the `on()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, a model can have lots of attributes and you may not want to re-render
    the complete view every time an attribute changes. Rather, updating only that
    part of the view seems more practical. Let's see how we can partially update a
    view in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Partially updating a view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Partial view updating is a common feature request that many developers ask
    for. The requirement is to re-render part of a view without rendering the complete
    view. This is pretty significant, mostly when there is a complex view with lots
    of data and only a small portion needs to be altered. Re-rendering the complete
    view for every small change can be a performance hit. The solution to this, on
    the other hand, is quite simple. In the following example, if the `address` attribute
    changes, then only the address part of the view''s DOM will be updated, and the
    complete view will not be re-rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we populate the template with model data in the `render` function.
    Instead of listening to the `change` event of the model, we listen to the `change:address`
    event. Inside the `showChangedAddress()` method, we first create the HTML string
    with the template and latest model data. Then we extract the `address` DOM element
    from this HTML string. Finally, we just replace the view's present `address` DOM
    element with the latest one.
  prefs: []
  type: TYPE_NORMAL
- en: The same functionality can be achieved with a subview or child view as well,
    and this would be a better solution indeed. However, there can be situations when
    creating a new subview for such a small change is redundant and the previous solution
    might pay off. In the following section, we will understand the real scenarios
    in which (and how) we should use a subview.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding nested views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nested view or subview is basically a child view. The necessity of a subview
    arises when we have a complex view and we want to separate a part of it for the
    sake of simplicity, better event-handling, and a better model-view relationship.
  prefs: []
  type: TYPE_NORMAL
- en: To give you an example, assume that we have a collection of similar data and
    we need to display a list item for each type of data. In this case, it is always
    preferable to have separate views and models that give an option to control the
    behavior of the view attached to each model. When you click on an item, you may
    need to use the data for that item for further processing. If the item is a subview,
    we can get the data readily from the model attached to it. We will explain this
    concept in the example that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen `UserItemView` in [Chapter 1](ch01.html "Chapter 1. Reducing Boilerplate
    with Plugin Development"), *Reducing Boilerplate with Plugin Development*, which
    uses the `User` model. Now, let''s introduce a collection of user data that will
    be displayed as a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we will use only one view to render the complete collection by creating
    a `UsersView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `render()` method, we iterate over all of the collection data and create
    an HTML list item that gets appended to an element of the `UsersView` class. This
    works perfectly and shows you a list of names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding implementation is absolutely fine, unless you want to receive
    a user''s data by clicking on a user''s name. In that case, we have to add the
    user ID somewhere in the HTML markup of the list item so that you can access it
    from the browser''s `event` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On a `click` event, we call the `showUserName()` method that displays the name
    of the `user` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `data-id` attribute of the list element can be extracted from the `target`
    property of the `event` object and the model with the same `data-id` attribute
    can be obtained from `collection`. This methodology works fine unless there are
    lots of views in your application. Managing events in this way becomes tedious
    for large applications. So, how do we solve this problem? We use subviews!
  prefs: []
  type: TYPE_NORMAL
- en: Knowing when to use subviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous pattern is similar to what we normally use in the case of simple
    jQuery-based applications where all of the data and events are tightly coupled
    to the DOM. Continuing event binding in this manner will ultimately result in
    much complexity at a later stage. A subview can simplify this process to a great
    extent. We will separate each list item and introduce a `UserItemView` variable
    for each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s simple. We just define one view for one model. In the `render()` method
    of `UsersView`, we eliminate the ugly HTML strings because we just need to create
    an instance of each subview (`UserItemView`) and append its elements to the main
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We create new instances of `UserViewItem`, pass the model to it, and render
    it inside the main view. The event listeners are now subview-specific and the
    subview methods can directly access the model attached to it. This makes the application
    flow cleaner and also eliminates the extra time that, though small, is required
    to look up the collection for a particular model through its ID. If your view
    has multiple similar child items, and each child item needs its own set of events,
    subviews are the right approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of this chapter, we will look at an awesome library, MarionetteJS,
    which provides some useful readymade BackboneJS extensions. The `ItemView` and
    `CollectionView` extensions provide a functionality that is similar to the previous
    example but in a more robust and flexible way.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding multiple DOM reflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used jQuery's `$.append()` method to add the subview elements to the main
    view. It is found that if there is a large collection of data, appending view
    elements to the DOM one by one can create a severe performance issue; this will
    affect the UI responsiveness of the application. The performance hit can be noticed
    even in modern browsers, since every append causes a DOM reflow and forces the
    browser to recalculate the size and position of the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: This multiple DOM reflow can be avoided by using `DocumentFragment`, which is
    described at [http://ejohn.org/blog/dom-documentfragments](http://ejohn.org/blog/dom-documentfragments)
    by *John Resig* as *a lightweight container that can hold DOM nodes*. We can collect
    all of the view elements inside `DocumentFragment` and then append this fragment
    to the DOM. This will cause a single reflow for the complete collection, and hence
    a performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the `render()` method with a single reflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This process can enhance performance if there are many subviews and the view
    HTML structure is a complex one. In general, not many developers use it and you
    should go for it only when the HTML markup is a pretty complex one. For a simple
    HTML markup, the tests show almost no change in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Re-rendering parent views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine the following scenario where we need to show the company details along
    with a list of its employees. We will create two views here: a `Company` view
    that is the main view, and an `Employee` view that is a child view and represents
    each employee in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Re-rendering parent views](img/3576OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, there will be a `Company` model and an `Employees` collection. We render
    the complete view along with the child views in a way similar to what we discussed
    earlier. If there is a change in the `Company` model, we will re-render the `Company`
    view, but that means we have to re-render all the child views too. Do we really
    need to do that? We actually do not need to, and we should not because that will
    be an overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, as you re-render a parent view, it should not re-initialize
    its child views every time. So, it is preferable to initialize the child views
    in the `initialize()` method of the parent view, and add them in an array that
    can later be used in the `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This way, multiple calls to the parent `render()` method will maintain the state
    of the view and will only render the subviews again.
  prefs: []
  type: TYPE_NORMAL
- en: Removing parent views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous scenario, where the company details and its employee list are
    shown, we assume a situation where we need to destroy this complete view and show
    a new view instead. Now, how do we destroy a view? We simply call the `remove()`
    method on it and it unbinds all the events that were registered with the `listenTo()`
    method. It also removes the complete view along with its child view elements from
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Are we unbinding the events of the child views here? No. The child views are
    removed from the DOM for sure, but we are not calling the `remove()` method on
    them. So, the models still exist and the events attached to the model still hold
    a reference to the view (or the view's methods). As a result, even if the view's
    `el` property is removed from the DOM, those view objects will not be garbage
    collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to prevent these memory leaks, we should always keep track of the
    child views while removing parent views. For instance, in the previous section
    we saw how we can store the child views inside a `this.subViews` array. We can
    override the `remove()` method in the `Company` view class and destroy the subviews
    individually before removing the main view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that all your child views are removed before the parent view.
    So, in order to get rid of memory leak issues, keep a few points in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Always have a reference to the current top level view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep references of all the child views inside a parent view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure every event gets unbound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, if you are using any Backbone.js version older than V9.9.0, calling only
    the `remove()` method will not clean up the events, and you will have to unbind
    them explicitly. The same works for the events that you register using the `on()`
    method instead of the `listenTo()` method. For older versions of Backbone, you
    may need to use something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few tools that will help you check whether your application is leaking
    memory. You can track it with Chrome developer tools ([https://developers.google.com/chrome-developer-tools/docs/javascript-memory-profiling](https://developers.google.com/chrome-developer-tools/docs/javascript-memory-profiling)),
    or you can use Backbone-Debugger ([https://github.com/Maluen/Backbone-Debugger](https://github.com/Maluen/Backbone-Debugger)).
  prefs: []
  type: TYPE_NORMAL
- en: Working with templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are an integral part of Backbone application development. With Backbone,
    Underscore.js comes up with its inbuilt micro template engine, though we can use
    other popular template engines such as Handlebars, Mustache, or Jade too. In the
    following section, we will cover some interesting patterns with templates that
    will help you to manage the templates in large applications and enhance their
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Storing templates in an HTML file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the simplest of cases, we store templates in two ways; we either directly
    add them inline within the view as a view property or add them inside the `script`
    tag in the `index.html` file. We have already seen the former case in the previous
    example. Let''s see the second option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we just place the template string inside a `script` tag and give it a
    type `text/template` so that it doesn''t get evaluated as JavaScript. You can
    always retrieve the template using the script ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Default delimiters of the Underscore template are sometimes annoying and look
    ugly. A Mustache style `{{}}` looks cleaner and is preferred by most developers.
    You can easily transform your Underscore delimiters to the Mustache style with
    the `_.templateSettings property`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Both these cases of template storing work fine when the application is a small
    one. However, once the volume of the application starts to increase, it becomes
    quite difficult to manage the large chunks of template strings in the JavaScript
    file and the monster HTML file with all the templates of the application. There
    are a number of options to store the templates and use them. For example, we can
    create separate HTML files for our templates; this approach gives us benefits
    such as syntax highlighting, proper indentation, and options to manage the templates
    separately. However, this technique will lead to another severe issue—the templates
    will need to be loaded separately via AJAX requests. Such multiple XHR requests
    to load the templates in a large project is a bad idea and a huge performance
    hit; avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some other options that may help you organize your templates in
    a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Storing templates in a JavaScript file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many developers suggest that though a template is a chunk of HTML markup, it''s
    not completely HTML, and keeping the markup in a JavaScript file is a preferable
    option. We can create single or multiple `.js` files that include all the templates
    of the application. The templates will be stored in string format, but you can
    present them in a more human-readable way by using the `join()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can maintain separate template files for your modules, for example, `User.js`
    and `Dashboard.js`. You can also have application-specific template namespaces,
    for instance, `App.User` and `App.Dashboard`. The crucial point is you can combine
    and minify these files later to get a single file that greatly improves the application
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: For a large application, you may not want to store your templates in this way
    inside a JavaScript file, where you will not get any facility to format and highlight
    the HTML code. However, the usefulness of this pattern cannot be denied, more
    so when we get a single JavaScript file with a minified set of all the precompiled
    templates. In [Appendix B](apb.html "Appendix B. Precompiling Templates on the
    Server Side"), *Precompiling Templates on the Server Side*, we discuss this process
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: With the popularity of Require.js and **Asynchronous Module Definition** (**AMD**),
    most developers today prefer storing individual templates in a separate template
    or in HTML files. Later, when the complete project's source code is optimized,
    it creates a single minified file with all the templates merged in JavaScript.
    This technique is now a popular approach, and we explained the functionality in
    detail in [Appendix C](apc.html "Appendix C. Organizing Templates with AMD and
    Require.js"), *Organizing Templates with AMD and Require.js*.
  prefs: []
  type: TYPE_NORMAL
- en: Precompiling templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is template compilation? In general, we create templates as strings and
    include template expressions in them. Once we pass that string for compilation,
    the template library analyze the string to create a format which can be applied
    with the data. This compiled function then returns another function where we pass
    the data and get the data integrated HTML string in return. This process is called
    template compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to precompile a template? This is because when we use a template
    string, say `TplManager.templates.userProfile`, multiple times, the same compilation
    process gets repeated every time. This is clearly extra work that will affect
    the performance of the app significantly. You can compare the difference in this
    jsperf test ([http://jsperf.com/underscore-templates-classic-vs-precompiled](http://jsperf.com/underscore-templates-classic-vs-precompiled))
    performed by Igor Hlina ([https://twitter.com/srigi](https://twitter.com/srigi)).
    The test shows that the precompilation of a template yields a 99 percent faster
    result than the classic approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'By precompiling templates and caching them, you can reduce the overhead to
    a large extent. Let''s add a method to our template manager that will compile
    a template only once and return the cached version every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, we can access the compiled templates from the `getCachedTemplate` method.
    This is a non-optimized solution without much error handling, but the concept
    can be implemented for all your templates.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `_.template()` method accepts two arguments in general. If you pass both
    the template string and data, it will send you the complete HTML string with data.
    However, if you pass only the template string, it will return the function that
    takes the data as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding evaluation in templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I learned about many template best practices from the Sencha library. Sencha's
    `XTemplate` functionality doesn't let you add any JavaScript code evaluation inside
    the template string, but it provides a number of variables and options to add
    the custom functions that help keep the templates clean; I never found any issues
    while creating complex templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Underscore.js template and most other template engines provide a functionality
    to evaluate the JavaScript code inside the template. On one hand, this looks pretty
    ugly, and on the other hand, it adds to the complexity as the number of templates
    increase in the project. Placing some JavaScript logic inside your template makes
    it very difficult to manage your code. So it is advisable to separate the JavaScript
    code from your HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'While displaying a list of employees, we need to iterate through the list and
    display the employee names. Underscore.js doesn''t provide any inbuilt mechanism
    for this, but we can use a subtemplate here that excludes the evaluation part
    from this code. The subtemplate will be simple, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You will iterate through the list in your JavaScript code, use this subtemplate
    to render only this `li` element, and then append the element to the main element.
    Though it might take a little more effort this way, it will help you avoid JavaScript
    evaluation in your template.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are template engines such as HandleBars.js that provide
    inbuilt logic (for instance, looping, passing contexts, if-unless block helpers,
    and so on). So, if you feel that subtemplating involves more work, you can go
    for a better template library that may not be as lightweight as Underscore but
    provides more inbuilt helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: Another idea to avoid evaluation in your template is to use helper functions.
    Let's take a look at them in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Using template helper functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is quite easy to use template helper functions. Imagine a situation where
    you are displaying a user''s profile in your application. In the place of user''s
    avatar, either you need to show a photo of the user or you must show a default
    avatar image. This is how you will write that condition in your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an option, but we already decided not to evaluate JavaScript inside
    our templates. The helper function may come handy here. Try this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So, while you are passing the data into the `_.template()` method, you need
    to make sure the template methods reside there as properties or subproperties.
    The question is why do we need to add the helper function as a part of the data?
    The reason is that most template libraries, including Underscore's template, create
    the data object that is passed to it the context of the function. So, the helper
    function is called on the context of data and can only be available in that way.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of template engines that have some of the previous solutions
    inbuilt. If you are developing a small application, you may find Underscore's
    micro-templating solution enough for development. But if you are going to have
    complex templates in your application, we would recommend going for `Handlebars`,
    a popular and well accepted template engine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding automatic model-view data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever an attribute of the attached model changes, we refresh the view to
    display the updated data. A `change` event listener is attached to the model inside
    the `initialize()` method of the view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, there are options that can handle this data binding automatically and
    you do not need to take care of it for every model-view relationship. This principle
    is more aligned towards the MVVM design pattern than the Backbone's MV* pattern,
    and you will find it in frameworks such as `Knockout.js` and `Meteor.js`.
  prefs: []
  type: TYPE_NORMAL
- en: For Backbone, there are multiple plugins such as `Backbone.Stickit` ([http://nytimes.github.io/backbone.stickit/](http://nytimes.github.io/backbone.stickit/)),
    `Backbone.ModelBinder` ([https://github.com/theironcook/Backbone.ModelBinder](https://github.com/theironcook/Backbone.ModelBinder)),
    and `Rivets.js` ([http://www.rivetsjs.com/](http://www.rivetsjs.com/)). These
    plugins provide a similar data binding feature. We are not going to discuss each
    plugin here; however, the implementation process is simple and similar for all
    of these plugins. If you wish to use such functionality, look into these plugins
    and use the one that fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Marionette's ItemView, CollectionView, and CompositeView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Marionette ([http://marionettejs.com/](http://marionettejs.com/)) is a composite
    application library for Backbone.js. Developed by Derick Bailey, it is a collection
    of common patterns and solutions to Backbone problems. It is a great library and
    lots of developers use it for their Backbone-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing about Marionette is that it offers several separate packages
    for views, regions, and so on, and allows you to use any of them freely without
    requiring the complete library. In this section, we will explore Marionette's
    `ItemView`, the `CollectionView`, and the `CompositeView` functionalities. These
    views solve a number of problems we discussed in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: ItemView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ItemView` represents a single view for an item, it can be a model view or
    a collection view. It extends the `Marionette.View` class, which is a core view
    with a number of reusable functions. `Marionette.View` takes care of triggering,
    delegating, and undelegating events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you plan to use Marionette, views with a model or a collection should extend
    the `ItemView` class. It provides a number of functionalities including:'
  prefs: []
  type: TYPE_NORMAL
- en: A `serializeData()` method that is a generic method to return data for the model
    or collection that is attached to the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `close()` method that takes care of removing views from DOM and cleanup resources.
    This is similar to the `close()` method of the `BaseView` class we learned in
    [Chapter 1](ch01.html "Chapter 1. Reducing Boilerplate with Plugin Development"),
    *Reducing Boilerplate with Plugin Development*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some custom events such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'render' / onRender` event
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'before:render' / onBeforerender` event
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'close' / onClose` event
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'before:close' / onBeforeClose` event
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look into a basic `ItemView` class definition as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create an instance of this and pass the model to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of a simple `ItemView` class, where we pass the model and
    use its methods to display the data. Have a look, we didn''t provide any `render()`
    method definition here. It is because `ItemView` provides a simple rendering functionality
    by default. `ItemView` has a `serializeData()` method that sends the model data
    or the collection data attached to this view, and the `render()` method applies
    this data to its template and populates the view automatically with generated
    HTML content. Here is how the `serializeData()` method looks in Marionette:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So, `ItemView` expects a template, a model, or a collection, and it reduces
    the initial boilerplate to render the view on its own. As you can see, a number
    of basic and reusable functionalities are handled in the `ItemView` class. It
    provides all the functions that we discussed in our `BaseView` class. Using it
    as a base class for your views can give a lot of flexibility while writing Backbone.js
    based applications.
  prefs: []
  type: TYPE_NORMAL
- en: CollectionView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `CollectionView` class, as the name suggests, shows a list of items for each
    model item in the specified collection. The functionality is similar to the previous
    example, but much more robust with subviews. A `CollectionView` class creates
    an instance of `ItemView` for each data item and appends its elements to the main
    view's `el`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common features of `CollectionView` are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating, adding, and removing child views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying an empty view when the collection is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic rendering and re-rendering for `'add'`, `'remove'`, and `'reset'`
    events of the collections, where the collection view automatically renders the
    changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provides a number of useful custom events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'render' / onRender` event
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'before:render' / beforeRender` event
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'closed' / 'collection:closed'` event
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'before:item:added' / 'after:item:added'` event
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'item:removed'` event
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'itemview:*'` event bubbling from child views
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes a `close()` method that removes the child views before closing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s use the previous `UserItemView` class as the child item and create
    a `CollectionView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Look how small the code is when compared to the code we developed earlier in
    this chapter to display a list of items. We just pass the class name `UserItemView`
    in the `CollectionView` instance as `itemView`, and it takes care of everything
    from rendering to destroying child items when the parent view gets removed.
  prefs: []
  type: TYPE_NORMAL
- en: Marionette's `CollectionView` reduces the boilerplate in your code to a great
    extent. If you are developing an application with multiple list type views, you
    can produce much cleaner code using Marionette's collection view, as it takes
    out most of the reusable functionality itself.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CompositeView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `CompositeView` extends from the `Marionette.CollectionView` class. In general,
    you can think of it as a combination of `ItemView` and `CollectionView`, where
    it accepts a model that represents a single dataset and a collection that displays
    multiple data. This is particularly useful when you have a hierarchical or a tree-like
    structure. You can relate it to the figure we mentioned in the *Re-rendering parent
    views* section. There we had to show data for the `Company` model and `Employees`
    collection together, and `CompositeView` would have been an excellent tool to
    provide a compact solution for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'A composite view provides some specific functionalities apart from the basic
    `CollectionView` functions, which can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Model data of `CompositeView` is applied to its template property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has an `itemViewContainer` property that specifies within which element the
    collection view will be rendered. The `itemViewContainer` property should either
    be a jQuery selector or a jQuery object, or it can be a function that returns
    a jQuery selector or jQuery object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When `itemViewContainer` is not sufficient for specifying the exact position
    of `ItemView`, overriding the `appendHtml()` method of `CollectionView` may provide
    the desired result, as shown in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s assume a scenario where we want to display company details along with
    a list of the employees. So, there will be a `Company` model, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, there must be an `Employee` model for each employee too, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define an `Employees` collection for the employee list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For the composite view, we want to present each employee as a separate `ItemView`
    instance so that event delegation becomes easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define the composite view that will display the model data and the
    collection data together, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we first defined a template where we kept a place for the employee list
    to go. Then we mentioned the `itemView` option as the `EmployeeView` class that
    will be used by the collection to create an instance and populate it with each
    employee data. These item views will be stacked in the element mentioned in the
    `itemViewContainer` property. Now, let''s create the composite view instance,
    add a company to it, and render it, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result we get is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with CompositeView](img/3576OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, you can see that a composite view provides a compact mechanism to display
    a model and a collection associated to it in a single view. You may have a tree
    structure data, and for that, multiple composite views need to be created. By
    default, the rendering mechanism of a composite view is hierarchical in nature
    and the `itemView` property is of the `CompositeView` type, if not overridden.
  prefs: []
  type: TYPE_NORMAL
- en: We hope we gave you a basic idea of all the Marionette views. Discussing all
    these views in an advanced level is beyond the scope of this book, but the Marionette
    docs will give you a complete description of the framework. We mention some resources
    and books about Marionette in [Appendix A](apa.html "Appendix A. Books, Tutorials,
    and References"), *Books, Tutorials, and References*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Layout Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you work with multiple views in an application, it often becomes difficult
    to manage activities such as multiple view rendering, adding animation to an element,
    or replacing a view with another view. Let's look into a great extension, `LayoutManager`
    ([https://github.com/tbranyen/backbone.layoutmanager](https://github.com/tbranyen/backbone.layoutmanager)),
    which provides a logical foundation to assemble layouts and views within the application.
  prefs: []
  type: TYPE_NORMAL
- en: Marionette too provides a similar functionality with its `RegionManager`, but
    we chose to discuss the `LayoutManager` plugin here because not everyone uses
    Marionette and this plugin can work independently with your Backbone app. If you
    are already using Marionette, I advise you to verify whether `RegionManager` solves
    your needs or not. Alternatively, you can use the `LayoutManager` plugin along
    with Marionette.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LayoutManager` extension provides solutions to a number of pain points
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: It handles asynchronous rendering of views if you are planning to dynamically
    load your templates from external files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines the layout as an HTML structure and assigns the views to proper elements
    as given in the layout configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It provides functionality to perform the following activities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert views, apply data to the given template, and auto render them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve or remove views depending on multiple selection criteria
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleans up views by unbinding all events from the view or from the model/collection
    that have this view as the context
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will look into these points by creating a simple layout as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Layout Manager](img/3576OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a list of users, and when you click on a user item, the user's details
    are displayed on the right-hand side of the layout. You will find the complete
    code example with all HTML, CSS, and other files in our sample code. Here we will
    describe the parts that are critical.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a user model and collection first as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have three views for this page: `UserList`, `UserItem`, and `UserDetails`
    views. The `UserItem` view will act as a subview of the `UserList` view. First,
    let''s write the templates for these three views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The view templates are pretty simple. The layout template, which defines the
    structure of the page, is the most important here. The task has three aspects:
    you have to divide the layout in a number of sections as you want, add proper
    styles to align them, and then define your views inside the `LayoutManager` configuration
    that will automatically render the views inside these sections.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will define the user list item that will display only the name of
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the two new properties here: manage and serialize. The `manage` property
    is a Boolean property that determines whether a view will be treated as a layout
    or not. The `manage` property must be set to `true` if you intend to use the view
    inside the layout manager and handle its rendering function. You can also set
    it to `true` globally for all the views and specify it as `FALSE` if required
    for a particular view.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LayoutManager` uses the `serialize()` method to apply the data to the view''s
    template. The default implementation of the `serialize()` method returns an empty
    object. You should override it to send the data you want to display. Here we are
    sending the model data associated with the view.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LayoutManager` provides two custom events, `beforeRender` and `afterRender`,
    to a view as it takes care of the render function itself. While using the `beforeRender()`
    method, the element of the view isn''t yet available, but if you insert a view
    into the layout, `LayoutManager` keeps track of it and renders it once the parent
    view is available in DOM. We can use this method where we will iterate through
    the users'' collection and insert the `UserItem` view to the list view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There are two similar methods `insertView`/`insertViews` and `setView`/`setViews`.
    Both these functions insert views into the layout according to the given selector
    name. The `setView()` method takes an extra `insert` parameter, which is a Boolean
    value, and determines whether the view will replace the complete content of the
    selector or will simply append to it. We create `UserItem` views, attach models
    to them, and insert them into the `UserList` view. The child views get automatically
    rendered inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are done with the basic list definition. Now, let''s define the layout manager
    functionality as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `LayoutManager` is also a type of `Backbone.View`, and you can render it
    as you do for any other Backbone view. In the `views` property, we can specify
    one or more view instances. In our case, we created the `UserList` instance, passed
    the collection to it, and let the `LayoutManager` take care of everything else
    to render it inside the `.user-list` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, up to this point, we have our layout rendered with the user list inside.
    The only action remaining is to display the user details once we click a user
    item. Let''s define the `UserDetails` view, which is a simple one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the same as our `UserItem` view definition with an extra `setModel()`
    method that sets the model to the selected one. Now we will insert this view into
    the layout when we click a list item. For that, we will add a click event handler
    to the `UserItem` view as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We use the `getView` method that can retrieve a view based on multiple criterion
    such as selector, model, or function. We check whether the details view is available
    or not. If not, we create a `DetailsView` instance, set the model, and render
    it. Otherwise, we reset the model and re-render the view.
  prefs: []
  type: TYPE_NORMAL
- en: So, we are done with the complete layout management. It is observed that most
    of the rendering functionalities are handled by the manager itself. This is just
    a basic example; `LayoutManager` can provide many more options and functionalities
    and eliminate 90 percent of your view management tasks. Do read their documentation
    thoroughly as you will be able to use most of it in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone through a number of important problems most Backbone
    developers come across, and learned multiple solutions to solve them. First, we
    discussed the partial view rendering and nested views. Any Backbone application
    needs to deal with nested views and if we can maintain their initialization, DOM
    reflow, and cleanup properly, it will greatly enhance the performance of the whole
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We spoke about different template-handling methods, saw a number of solutions
    to load precompiled templates from external files, organized templates within
    applications, and understood how helper functions can eliminate evaluation of
    JavaScript codes inside templates and help us to create cleaner templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we learned about some of the very important extensions: Marionette''s
    `ItemView`, `CollectionView`, `CompositeView`, and `LayoutManager`. All of these
    extensions provide great flexibility by taking out a lot of boilerplate code and
    managing your views by a great deal.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about Backbone models; we will look into model
    data validation, different plugins for validation, model serialization, and the
    relational data model.
  prefs: []
  type: TYPE_NORMAL
