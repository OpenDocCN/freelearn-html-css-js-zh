<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with Views</h1></div></div></div><p>Backbone view<a id="id37" class="indexterm"/> works as the presentation layer of an application. In simple terms, you can define it as an abstract layer for your HTML element. It doesn't contain any HTML markup of its own, but it contains the logic to present your model's data with the help of JavaScript templates.</p><p>If you go through the annotated source of Backbone view, you will find that <code class="literal">Backbone.View</code> is a small class with very few methods, including an empty <code class="literal">initialize()</code> method and an almost empty <code class="literal">render()</code> method, which are in general meant to be overridden by any custom view class. In this chapter, we will investigate some common problems and the solutions to these problems with respect to the Backbone views that developers face mostly while developing real-world Backbone.js applications.</p><p>The basic issues with Backbone are associated with view rendering or updating and maintaining multiple views within an application. We will analyze the following topics based on complexity:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Basic usage of views</strong>: We will learn the basic concepts of Backbone view, its properties, functions, and event-handling.</li><li class="listitem" style="list-style-type: disc"><strong>Updating a view partially</strong>: We will learn how to update only a part of a view without the need for re-rendering the complete view.</li><li class="listitem" style="list-style-type: disc"><strong>Nested views</strong>: As the complexity of an application layout increases, we feel the need to maintain a hierarchy of multiple views. Nested views or subviews simplify event-handling and layout management to a great extent. We will explore the following topics:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When we need to use subviews</li><li class="listitem" style="list-style-type: disc">How to initialize and render nested views</li><li class="listitem" style="list-style-type: disc">How to avoid DOM reflow in the case of a large collection of nested views and a complex view DOM structure</li><li class="listitem" style="list-style-type: disc">How to clean up resources (child views, events) when you delete a parent view</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Templates</strong>: Templates are an essential part of Backbone and are used in combination with views to create reusable copies of HTML markup. We will discuss the following topics:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The different options for storing and loading template files</li><li class="listitem" style="list-style-type: disc">The advantages of template precompilation and storing precompiled templates on the client side</li><li class="listitem" style="list-style-type: disc">The usage of template helper functions</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Marionette views</strong>: We can reduce the view boilerplate code using the custom view extensions of the Marionette library.</li><li class="listitem" style="list-style-type: disc"><strong>Layout manager</strong>: We can simplify the complex layout architecture using the Backbone layout manager plugin.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Basic usage of views</h1></div></div></div><p>Backbone <a id="id38" class="indexterm"/>views are the tools that provide a logical structure to the HTML markup of your application. Views represent the data of Backbone models or collections via JavaScript templates. For any change in the associated model or collection, you do not need to redraw the complete page, only update the relevant view—that's it. A basic view can be defined this way:</p><div><pre class="programlisting">var UserView = Backbone.View.extend({
  render: function () {
    var html = "Backbone.js rocks!";
    this.$el.html(html);
    return this;
  }
});

// create an instance
var userView = new UserView();
$('#container').append(userView.render().el);</pre></div><p>Here we created a simple HTML markup, placed it inside this view's element, and showed the view in the DOM. Let's understand the concept further by looking at all the steps.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Understanding the el property</h2></div></div></div><p>What is the <code class="literal">this.$el</code> property? It is<a id="id39" class="indexterm"/> the property that points to the jQuery-wrapped version of <code class="literal">el</code>. Every view possesses an <code class="literal">el</code> property that either holds a DOM reference <a id="id40" class="indexterm"/>where the view is ultimately going to be rendered, or an HTML element that functions as the main element of the view. In the previous example, we didn't specify the <code class="literal">el</code> property. So, as soon as we instantiated the view, the <code class="literal">el</code> element was available to us though it was not rendered in the DOM. We had to do this rendering explicitly by appending the view element to the <code class="literal">#container</code> element. However, if we had mentioned the <code class="literal">el</code> property pointing to the <code class="literal">#container</code> element in the view definition or while creating it's instance, we wouldn't need to append it specifically to the document. Like the following code snippet:</p><div><pre class="programlisting">var UserView = Backbone.View.extend({
  ...
  el: '#container'
});

// render it to document body
new UserView.render();</pre></div><p>This generates<a id="id41" class="indexterm"/> the same result as the first example. However, this<a id="id42" class="indexterm"/> methodology creates problems when you make multiple instances of the <code class="literal">UserView</code> class<a id="id43" class="indexterm"/>, as all of them point to the same element as given in <code class="literal">el</code>, and because the last instance will overwrite the previous ones. However, this can be minimized if you pass the <code class="literal">el</code> property each time you create the view instance, though it is not a very good practice. Also, another problem related to view destroy still persists—if you destroy this view, it removes the <code class="literal">#container</code> element too—so, if you create another <code class="literal">UserView</code> instance passing the same <code class="literal">#container</code> element as the <code class="literal">el</code> property later, it throws an error. It is good practice to let the view create its own element and make the parent views or the layout manager take care of rendering the view.</p><p>There are some other properties that relate to the <code class="literal">el</code> property of the Backbone view; these are <code class="literal">tagName</code>, <code class="literal">id</code>, <code class="literal">className</code>, and <code class="literal">attributes</code>. The <code class="literal">tagName</code> property expects an HTML tag name as the value that the main element of the view will be created with. For example, if you specify <code class="literal">tagName</code> as <code class="literal">'ul'</code>, the <code class="literal">el</code> element that is created by Backbone will be an empty <code class="literal">UL</code> element. By default, <code class="literal">tagName</code> has the value <code class="literal">'div'</code>, that is, the view element will be a <code class="literal">DIV</code> element if nothing is specified as <code class="literal">tagName</code>.</p><p>The <code class="literal">id</code> and <code class="literal">className</code> properties specify the element's ID and CSS classes respectively. The <code class="literal">attributes</code> property holds all of the HTML attributes as an object:</p><div><pre class="programlisting">var UserView = Backbone.View.extend({
    tagName : 'p',
    id : 'user_details',
    className : 'user-details',
    attributes : {
        'data-name' : 'User Details'
    }
});</pre></div><p>The resulting view element will look like this:</p><div><pre class="programlisting">&lt;p data-name="User Details" id="user_details" class="user-details"&gt;&lt;/p&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Listening to view events</h2></div></div></div><p>You <a id="id44" class="indexterm"/>can <a id="id45" class="indexterm"/>attach DOM event listeners to the DOM elements using the <code class="literal">events</code> property of view. These events can only be registered on the view element along with its child elements:</p><div><pre class="programlisting">var UserView = Backbone.View.extend({
  html: '&lt;button id="btn"&gt;Click me&lt;/button&gt;',
  events: {
    'click #btn': 'onButtonClick'
  },

  render: function () {
    this.$el.html(this.html);
    return this;
  },

  onButtonClick: function () {
    console.log('Button clicked');
  }
});</pre></div><p>We added a <code class="literal">click</code> event on the button and defined the handler to be called once the user clicks on that button.</p><p>Backbone <a id="id46" class="indexterm"/>delegates<a id="id47" class="indexterm"/> all of the view events, so that the events are attached even if the element is not rendered in the DOM. So, if you add one event hash for an element that is not yet available inside the view DOM, the event will be attached to it as soon as the element is rendered.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Displaying model data with templates</h2></div></div></div><p>This is the <a id="id48" class="indexterm"/>most important part as the<a id="id49" class="indexterm"/> main purpose of a view is to display the data attached to it. In the simplest case, one Backbone view is attached to each model, and it keeps itself updated with the model change:</p><div><pre class="programlisting">var User = Backbone.Model.extend({});

// UserView definition
var UserView = Backbone.View.extend({
// We will use Underscore template
  template: _.template('Hello &lt;%= firstName %&gt; &lt;%=lastName %&gt;!'),

  render: function () {
    if (!this.model) {
      throw "Model is not set for this view";
    }

    var html = this.template(this.model.toJSON());
    this.$el.html(html);
    return this;
  }
});

var userView = new UserView({
// Set a model for this view
  model: new User({
    firstName: 'Payel',
    lastName: 'Pal'
  })
});

$('#container').append(userView.render().el);</pre></div><p>The preceding code<a id="id50" class="indexterm"/> is pretty simple<a id="id51" class="indexterm"/> to understand; here we pass a <code class="literal">model</code> instance to the view and set the model value to the template inside the <code class="literal">render()</code> function<a id="id52" class="indexterm"/>. Once rendered, the view will show the HTML markup with the model data.</p><p>We also need to ensure that the changes in any attribute of the model should be reflected in the view immediately. We can achieve this functionality by listening to the model's <code class="literal">change</code> event:</p><div><pre class="programlisting">initialize: function () {
  this.listenTo(this.model, 'change', this.render);
  // Or, this.model.on('change', this.render, this);
}

...
// Change an attribute of the model
userView.model.set('lastName', 'Dey');</pre></div><p>In the <code class="literal">initialize()</code> method<a id="id53" class="indexterm"/>, we listen to the model's <code class="literal">change</code> event and re-render the view. We can use both <code class="literal">on()</code> and <code class="literal">listenTo()</code> for this functionality, but the advantage of the latter over the former is that it automatically unbinds all the events that were added with the <code class="literal">listenTo()</code> met<a id="id54" class="indexterm"/>hod if the view is destroyed. On the other hand, you have to unbind these events explicitly if you bind events using the<a id="id55" class="indexterm"/> <code class="literal">on()</code> method.</p><p>In some cases, a model can have lots of attributes and you may not want to re-render the complete view every time an attribute changes. Rather, updating only that part of the view seems more practical. Let's see how we can partially update a view in detail in the following section.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Partially updating a view</h1></div></div></div><p>Partial view updating<a id="id56" class="indexterm"/> is a common feature request that many developers ask for. The requirement is to re-render part of a view without rendering the complete view. This is pretty significant, mostly when there is a complex view with lots of data and only a small portion needs to be altered. Re-rendering the complete view for every small change can be a performance hit. The solution to this, on the other hand, is quite simple. In the following example, if the <code class="literal">address</code> attribute changes, then only the address part of the view's DOM will be updated, and the complete view will not be re-rendered:</p><div><pre class="programlisting">...

template : _.template('&lt;p&gt;&lt;% name %&gt;&lt;/p&gt;&lt;p&gt;&lt;%= address %&gt;&lt;/p&gt;'),

initialize: function() {
  this.listenTo(this.model, 'change:address', this.showChangedAddress);
},

showChangedAddress: function () {
  // we are using the same main view template here though 
  // another subtemplate for only the address part can 
  // anyway be used here
  var html = this.template(this.model.toJSON()),

    // Selector of the element whose value needs to be updated
    addressElSelector = ".address",

    // Get only the element with "address" class
    addressElement = $(addressElSelector, html);  

  // Replace only the contents of the .address element
  this.$(addressElSelector).replaceWith(addressElement);
}

...</pre></div><p>In this example, we populate the template with model data in the <code class="literal">render</code> function. Instead of listening to the <code class="literal">change</code> event of the model, we listen to the <code class="literal">change:address</code> event. Inside the <code class="literal">showChangedAddress()</code> method<a id="id57" class="indexterm"/>, we first create the HTML string with the template and latest model data. Then we extract the <code class="literal">address</code> DOM element from this HTML string. Finally, we just replace the view's present <code class="literal">address</code> DOM element with the latest one.</p><p>The same functionality can be achieved with a subview or child view as well, and this would be a better<a id="id58" class="indexterm"/> solution indeed. However, there can be situations when creating a new subview for such a small change is redundant and the previous solution might pay off. In the following section, we will understand the real scenarios in which (and how) we should use a subview.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Understanding nested views</h1></div></div></div><p>A<a id="id59" class="indexterm"/> nested view <a id="id60" class="indexterm"/>or subview is basically a child view. The necessity of a subview arises when we have a complex view and we want to separate a part of it for the sake of simplicity, better event-handling, and a better model-view relationship.</p><p>To give you an example, assume that we have a collection of similar data and we need to display a list item for each type of data. In this case, it is always preferable to have separate views and models that give an option to control the behavior of the view attached to each model. When you click on an item, you may need to use the data for that item for further processing. If the item is a subview, we can get the data readily from the model attached to it. We will explain this concept in the example that follows.</p><p>We have seen <code class="literal">UserItemView</code> in <a class="link" href="ch01.html" title="Chapter 1. Reducing Boilerplate with Plugin Development">Chapter 1</a>, <em>Reducing Boilerplate with Plugin Development</em>, which uses the <code class="literal">User</code> model. Now, let's introduce a collection of user data that will be displayed as a list:</p><div><pre class="programlisting">var User = Backbone.Model.extend();

// Users collection
var Users = Backbone.Collection.extend({
  model: User
});

// Add some data in the collection
var users = new Users([{
  id: 1,
  name: 'John Doe'
}, {
  id: 2,
  name: 'Dan Smith'
}]);</pre></div><p>Initially, we will use only one view to render the complete collection by creating a <code class="literal">UsersView</code>:</p><div><pre class="programlisting">var UsersView = Backbone.View.extend({
  tagName: 'ul',
  render: function () {
    var html = '';

    // Iterate over the collection and 
    // add each name as a list item
    this.collection.each(function (model) {
      html += '&lt;li&gt;' + model.get('name') + '&lt;/li&gt;';
    }, this);

    this.$el.html(html);
    return this;
  }
});

var usersView = new UsersView({
  // add the collection instance
  collection: users
});

// Display the view
$(document.body).append(usersView.render().el);</pre></div><p>In the <a id="id61" class="indexterm"/>
<code class="literal">render()</code> method, we iterate over all of the collection data and create an HTML list item that gets appended to an element of the <code class="literal">UsersView</code> class. This works perfectly and shows you a list of names.</p><p>The preceding implementation is absolutely fine, unless you want to receive a user's data by clicking on a user's name. In that case, we have to add the user ID somewhere in the HTML markup of the list item so that you can access it from the browser's <code class="literal">event</code> object:</p><div><pre class="programlisting">html += '&lt;li data-id="' + model.<code class="literal">get('id)</code> + '"&gt;' + model.get('name') + '&lt;/li&gt;';</pre></div><p>On a <code class="literal">click</code> event, we call the <code class="literal">showUserName()</code> method<a id="id62" class="indexterm"/> that displays the name of the <code class="literal">user</code> model:</p><div><pre class="programlisting">...
events: {
  'click li': 'showUserName'
},

showUserName: function (e) {
  var userId = $(e.target).attr('data-id'),
    user = this.collection.get(userId);

  if (!user) {
    return;
  }

  console.log('Clicked user\'s name =', user.get('name'));
}
...</pre></div><p>The <code class="literal">data-id</code> attribute of the list element can be extracted from the <code class="literal">target</code> property of the <code class="literal">event</code> object and<a id="id63" class="indexterm"/> the model with the same <code class="literal">data-id</code> attribute can be obtained from <code class="literal">collection</code>. This methodology works fine unless there are lots of views in your application. Managing events in this way becomes tedious for large applications. So, how do we solve this problem? We use subviews!</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Knowing when to use subviews</h2></div></div></div><p>The previous<a id="id64" class="indexterm"/> pattern is similar to what we normally use in<a id="id65" class="indexterm"/> the case of simple jQuery-based applications where all of the data and events are tightly coupled to the DOM. Continuing event binding in this manner will<a id="id66" class="indexterm"/> ultimately result in much complexity at a later stage. A subview can simplify this process to a great extent. We will separate each list item and introduce a <code class="literal">UserItemView</code> variable for each of them:</p><div><pre class="programlisting">var UserItemView = Backbone.View.extend({
  tagName: 'li',
  template: _.template( '&lt;%= name %&gt;'),
  events: {
    'click': 'showUserName'
  },
  render: function () {
    var html = this.template(this.model.toJSON());
    this.$el.html(html);
    return this;
  },

  showUserName: function () {
    console.log('Clicked user\'s name =', this.model.get('name'));
  }
});</pre></div><p>It's simple. We just define one view for one model. In the <code class="literal">render()</code> method of <code class="literal">UsersView</code>, we eliminate the ugly HTML strings because we just need to create an instance of each subview (<code class="literal">UserItemView</code>) and append its elements to the main view:</p><div><pre class="programlisting">render: function () {
  var userItemView;

  // clean up the view first 
  this.$el.empty();

  // iterate over the collection and add each name as a list item
  this.collection.each(function (model) {
    userItemView = new UserItemView({
      model: model
    });

    this.$el.append(userItemView.render().el);
  }, this);

  return this;
}</pre></div><p>We create new instances of <code class="literal">UserViewItem</code>, pass the model to it, and render it inside the main view. The<a id="id67" class="indexterm"/> event listeners are now subview-specific and the subview <a id="id68" class="indexterm"/>methods can directly access the model attached to it. This makes the application flow cleaner and also eliminates the extra time that, though small, is required to look up the collection for a particular model through its ID. If your view has multiple similar child items, and each child item needs its own set of events, subviews are the right approach.</p><p>In the final section of this chapter, we will look at an awesome library, MarionetteJS, which provides some useful readymade BackboneJS extensions. The <code class="literal">ItemView</code> and <code class="literal">CollectionView</code> extensions provide a functionality that is similar to the previous example but in a more robust and flexible way.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Avoiding multiple DOM reflow</h2></div></div></div><p>We used<a id="id69" class="indexterm"/> jQuery's <code class="literal">$.append()</code> method <a id="id70" class="indexterm"/>to add the subview elements to the main view. It is found that if there is a large collection of data, appending view elements to the DOM one by one can create a severe performance issue; this will affect the UI responsiveness of the application. The performance hit can be noticed even in modern browsers, since every append causes a DOM reflow and forces the browser to recalculate the size and position of the DOM tree.</p><p>This multiple DOM reflow can be avoided by using <code class="literal">DocumentFragment</code>, which is described at <a class="ulink" href="http://ejohn.org/blog/dom-documentfragments">http://ejohn.org/blog/dom-documentfragments</a> by <em>John Resig</em> as <em>a lightweight container that can hold DOM nodes</em>. We can collect all of the view elements inside <code class="literal">DocumentFragment</code> and then append this fragment to the DOM. This will cause a single reflow for the complete collection, and hence a performance improvement.</p><p>Let's see the <code class="literal">render()</code> method with a single reflow:</p><div><pre class="programlisting">render: function () {
  // create a document fragment
  var fragment = document.createDocumentFragment();

  this.collection.each(function (model) {
    // add each view element to the document fragment
    fragment.appendChild(new UserItemView({
      model: model
    }).render().el);
  }, this);

  // append the fragment to the DOM
  this.$el.html(fragment);
  return this;
}</pre></div><p>This process <a id="id71" class="indexterm"/>can enhance performance if there are many subviews and the view HTML structure is a complex one. In general, not many developers use it and you should go for it only when the HTML markup is a pretty complex one. For a simple HTML markup, the tests show almost no change in performance.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Re-rendering parent views</h2></div></div></div><p>Imagine<a id="id72" class="indexterm"/> the following scenario where we need to show the company details along with a list of its employees. We will create two views here: a <code class="literal">Company</code> view that is the main view, and an <code class="literal">Employee</code> view that is a child view and represents each employee in the list:</p><div><img src="img/3576OS_02_03.jpg" alt="Re-rendering parent views"/></div><p>So, there will be a <code class="literal">Company</code> model and an <code class="literal">Employees</code> collection. We render the complete view along with the child views in a way similar to what we discussed earlier. If there is a change in the <code class="literal">Company</code> model, <a id="id73" class="indexterm"/>we will re-render the <code class="literal">Company</code> view, but that means we have to re-render all the child views too. Do we really need to do that? We actually do not need to, and we should not because that will be an overhead.</p><p>In most cases, as you re-render a parent view, it should not re-initialize its child views every time. So, it is preferable to initialize the child views in the <code class="literal">initialize()</code> method<a id="id74" class="indexterm"/> of the parent view, and add them in an array that can later be used in the <code class="literal">render()</code> method:</p><div><pre class="programlisting">var ParentView = Backbone.View.extend({
  initialize: function () {
    this.subViews = []; 
   
   // Initializing the child views
    this.subViews.push(new ChildView(), new ChildView()];
  },

  render: function () {
    this.$el.html(this.template);

  // Render each child view
    _(this.subViews).each(function (view) {
      this.$el.append(view.render().el);
    }, this);

    return this;
  }
});</pre></div><p>This way, multiple calls to the parent <code class="literal">render()</code> method will maintain the state of the view and will only render the subviews again.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Removing parent views</h2></div></div></div><p>In the previous<a id="id75" class="indexterm"/> scenario, where the company details and its employee list are shown, we assume a situation where we need to destroy this complete view and show a new view instead. Now, how do we destroy a view? We simply call the <code class="literal">remove()</code> method on it and it unbinds all the events that were registered with the <code class="literal">listenTo()</code> method. It also removes the complete view along with its child view elements from the DOM.</p><p>Are we unbinding the events of the child views here? No. The child views are removed from the DOM for sure, but we are not calling the <code class="literal">remove()</code> method on them. So, the models still exist and<a id="id76" class="indexterm"/> the events attached to the model still hold a reference to the view (or the view's methods). As a result, even if the view's <code class="literal">el</code> property is removed from the DOM, those view objects will not be garbage collected.</p><p>In order to prevent these memory leaks, we should always keep track of the child views while removing parent views. For instance, in the previous section we saw how we can store the child views inside a <code class="literal">this.subViews</code> array. We can override the <code class="literal">remove()</code> method in the <code class="literal">Company</code> view class and destroy the subviews individually before removing the main view:</p><div><pre class="programlisting">var Company = Backbone.View.extend({
  ...
  remove: function () {
    _(this.subViews).each(function (view) {
      this.stopeListening(view);
      view.remove();
    }, this);

    Backbone.View.prototype.remove.call(this, arguments);
  }
});</pre></div><p>This will ensure that all your child views are removed before the parent view. So, in order to get rid of memory leak issues, keep a few points in mind:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Always have a reference to the current top level view</li><li class="listitem" style="list-style-type: disc">Keep references of all the child views inside a parent view</li><li class="listitem" style="list-style-type: disc">Ensure every event gets unbound</li></ul></div><p>Also, if you are using any Backbone.js version older than V9.9.0, calling only the <code class="literal">remove()</code> method will not clean up the events, and you will have to unbind them explicitly. The same works for the events that you register using the <code class="literal">on()</code> method instead of the <code class="literal">listenTo()</code> method. For older versions of Backbone, you may need to use something like the following code:</p><div><pre class="programlisting">remove: function () { 
  this.unbind(); // Unbind all local event bindings
  
  // Unbind reference all such items
  this.model.unbind('change', this.render, this);  

  // Remove this view
  Backbone.View.prototype.remove.call(this, arguments);

  // Delete the jQuery wrapped object variable
  delete this.$el;  
  
  // Delete the variable reference to this node
  delete this.el; 
}</pre></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>There are a few tools that will help you check whether your application is leaking memory. You can track it with Chrome developer tools (<a class="ulink" href="https://developers.google.com/chrome-developer-tools/docs/javascript-memory-profiling">https://developers.google.com/chrome-developer-tools/docs/javascript-memory-profiling</a>), or you can use Backbone-Debugger (<a class="ulink" href="https://github.com/Maluen/Backbone-Debugger">https://github.com/Maluen/Backbone-Debugger</a>).</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Working with templates</h1></div></div></div><p>Templates<a id="id77" class="indexterm"/> are an integral part <a id="id78" class="indexterm"/>of Backbone application development. With Backbone, Underscore.js comes up with its inbuilt micro template engine, though we can use other popular template engines such as Handlebars, Mustache, or Jade too. In the following section, we will cover some interesting patterns with templates that will help you to manage the templates in large applications and enhance their performance.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Storing templates in an HTML file</h2></div></div></div><p>In the<a id="id79" class="indexterm"/> simplest of cases, we store templates in two ways; we either directly add them inline within the view as a view property or add them inside the <code class="literal">script</code> tag in the <code class="literal">index.html</code> file. We have already seen the former case in the previous example. Let's see the second option:</p><div><pre class="programlisting">&lt;script type="text/template" id="tpl_user_details"&gt;
  &lt;h3&gt; &lt;%= name %&gt; &lt;/h3&gt;
  &lt;p&gt;&lt;%= about %&gt;&lt;/p&gt;
&lt;/script&gt;</pre></div><p>Here we just place the template string inside a <code class="literal">script</code> tag and give it a type <code class="literal">text/template</code> so that it doesn't get evaluated as JavaScript. You can always retrieve the template using the script ID:</p><div><pre class="programlisting">var userDetailsTpl = $('#tpl_user_details').html();</pre></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Default delimiters of the Underscore template are sometimes annoying and look ugly. A Mustache style <code class="literal">{{}}</code> looks cleaner and is preferred by most developers. You can easily transform your Underscore delimiters to the Mustache style with the <code class="literal">_.templateSettings property</code>:</p><div><pre class="programlisting">_.templateSettings = {
  interpolate: /\{\{(.+?)\}\}/g
};</pre></div></div></div><p>Both these<a id="id80" class="indexterm"/> cases of template storing work fine when the application is a small one. However, once the volume of the application starts to increase, it becomes quite difficult to manage the large chunks of template strings in the JavaScript file and the monster HTML file with all the templates of the application. There are a number of options to store the templates and use them. For example, we can create separate HTML files for our templates; this approach gives us benefits such as syntax highlighting, proper indentation, and options to manage the templates separately. However, this technique will lead to another severe issue—the templates will need to be loaded separately via AJAX requests. Such multiple XHR requests to load the templates in a large project is a bad idea and a huge performance hit; avoid it.</p><p>Let's look at some other options that may help you organize your templates in a better way.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Storing templates in a JavaScript file</h2></div></div></div><p>Many<a id="id81" class="indexterm"/> developers suggest that though a template is a chunk of HTML markup, it's not completely HTML, and keeping the markup in a JavaScript file is a preferable option. We can create single or multiple <code class="literal">.js</code> files that include all the templates of the application. The templates will be stored in string format, but you can present them in a more human-readable way by using the <a id="id82" class="indexterm"/>
<code class="literal">join()</code> method:</p><div><pre class="programlisting">var TplManager = {
  templates: {}
};

TplManager.templates.userProfile = [
  '&lt;h3&gt; &lt;%= name %&gt; &lt;/h3&gt;',
  '&lt;img src="img/&gt;"',
  '&lt;p&gt;Address : &lt;%= address %&gt;&lt;/p&gt;'
].join('\n');

TplManager.templates.userLogin = [
  '&lt;ul&gt;',
  '&lt;li&gt;Username: &lt;input type="text" /&gt;&lt;/li&gt;',
  '&lt;li&gt;Password: &lt;input type="password" /&gt;&lt;/li&gt;',
  '&lt;/ul&gt;'
].join('\n');</pre></div><p>You can maintain separate template files for your modules, for example, <code class="literal">User.js</code> and <code class="literal">Dashboard.js</code>. You can also have application-specific template namespaces, for instance, <code class="literal">App.User</code> and <code class="literal">App.Dashboard</code>. The crucial point is you can combine and minify these files later to get a single file that greatly improves the application performance.</p><p>For a large <a id="id83" class="indexterm"/>application, you may not want to store your templates in this way inside a JavaScript file, where you will not get any facility to format and highlight the HTML code. However, the usefulness of this pattern cannot be denied, more so when we get a single JavaScript file with a minified set of all the precompiled templates. In <a class="link" href="apb.html" title="Appendix B. Precompiling Templates on the Server Side">Appendix B</a>, <em>Precompiling Templates on the Server Side</em>, we discuss this process in detail.</p><p>With the popularity of Require.js and <strong>Asynchronous Module Definition</strong> (<strong>AMD</strong>), most developers today prefer storing individual templates in a separate template or in HTML files. Later, when the complete project's source code is optimized, it creates a single minified file with all the templates merged in JavaScript. This technique is now a popular approach, and we explained the functionality in detail in <a class="link" href="apc.html" title="Appendix C. Organizing Templates with AMD and Require.js">Appendix C</a>, <em>Organizing Templates with AMD and Require.js</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Precompiling templates</h2></div></div></div><p>What is<a id="id84" class="indexterm"/> template compilation? In general, we <a id="id85" class="indexterm"/>create templates as strings and include template expressions in them. Once we pass that string for compilation, the template library analyze the string to create a format which can be applied with the data. This compiled function then returns another function where we pass the data and get the data integrated HTML string in return. This process is called template compilation.</p><p>Why do we need to precompile a template? This is because when we use a template string, say <code class="literal">TplManager.templates.userProfile</code>, multiple times, the same compilation process gets repeated every time. This is clearly extra work that will affect the performance of the app significantly. You can compare the difference in this jsperf test (<a class="ulink" href="http://jsperf.com/underscore-templates-classic-vs-precompiled">http://jsperf.com/underscore-templates-classic-vs-precompiled</a>) performed by Igor Hlina (<a class="ulink" href="https://twitter.com/srigi">https://twitter.com/srigi</a>). The test shows that the precompilation of a template yields a 99 percent faster result than the classic approach.</p><p>By precompiling templates and caching them, you can reduce the overhead to a large extent. Let's add a method to our template manager that will compile a template only once and return the cached version every time:</p><div><pre class="programlisting">var TplManager = {
  templates: {},
  cachedTemplates: {},

  // Returns compiled template
  getCachedTemplate: function (tplName) {
    // If compiled template already exists, return that
    if (this.cachedTemplates.hasOwnProperty(tplName)) {
      return this.cachedTemplates[tplName];
    }

    if (this.templates.hasOwnProperty(tplName)) {
      // Compile and store the template functions 
      this.cachedTemplates[tplName] = _.template(this.templates[tplName]);
    }

    return this.cachedTemplates[tplName];
  }
};
TplManager.getCachedTemplate('userProfile'); </pre></div><p>So, we can access the compiled templates from the <code class="literal">getCachedTemplate</code> method. This is a non-optimized solution without much error handling, but the concept can be implemented for all your templates.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>The <code class="literal">_.template()</code> method accepts two arguments in general. If you pass both the template string and data, it will send you the complete HTML string with data. However, if you pass only the template string, it will return the function that takes the data as a parameter.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Avoiding evaluation in templates</h2></div></div></div><p>I learned about <a id="id86" class="indexterm"/>many template best practices from the Sencha library. Sencha's <code class="literal">XTemplate</code> functionality doesn't let you add any JavaScript code evaluation inside the template string, but it provides a number of variables and options to add the custom functions that help keep the templates clean; I never found any issues while creating complex templates.</p><p>The Underscore.js template and most other template engines provide a functionality to evaluate the JavaScript code inside the template. On one hand, this looks pretty ugly, and on the other hand, it adds to the complexity as the number of templates increase in the project. Placing some JavaScript logic inside your template makes it very difficult to manage your code. So it is advisable to separate the JavaScript code from your HTML markup:</p><div><pre class="programlisting">&lt;h3&gt;
  &lt;%= companyName %&gt;
&lt;/h3&gt;
&lt;ul&gt;
  &lt;% employees.forEach(function (employee) { %&gt;
    &lt;li&gt;
      &lt;%= employee.name %&gt;
    &lt;/li&gt;
  &lt;% }); %&gt;
&lt;/ul&gt;</pre></div><p>While displaying a list of employees, we need to iterate through the list and display the employee names. Underscore.js doesn't provide any inbuilt mechanism for this, but we can use a subtemplate here that excludes the evaluation part from this code. The subtemplate will be simple, such as this:</p><div><pre class="programlisting">&lt;li&gt; &lt;%= name %&gt; &lt;/li&gt;</pre></div><p>You will iterate <a id="id87" class="indexterm"/>through the list in your JavaScript code, use this subtemplate to render only this <code class="literal">li</code> element, and then append the element to the main element. Though it might take a little more effort this way, it will help you avoid JavaScript evaluation in your template.</p><p>On the other hand, there are template engines such as HandleBars.js that provide inbuilt logic (for instance, looping, passing contexts, if-unless block helpers, and so on). So, if you feel that subtemplating involves more work, you can go for a better template library that may not be as lightweight as Underscore but provides more inbuilt helper functions.</p><p>Another idea to avoid evaluation in your template is to use helper functions. Let's take a look at them in the following section.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Using template helper functions</h2></div></div></div><p>It is<a id="id88" class="indexterm"/> quite easy to use template helper functions. Imagine<a id="id89" class="indexterm"/> a situation where you are displaying a user's profile in your application. In the place of user's avatar, either you need to show a photo of the user or you must show a default avatar image. This is how you will write that condition in your template:</p><div><pre class="programlisting">&lt;% if(typeof(avatar) === 'undefined') %&gt;
  &lt;img src="img/&lt;%= avatar %&gt;" /&gt;
&lt;% } else { %&gt;
  &lt;img src="img/default_avatar.png" /&gt;
&lt;% } %&gt;</pre></div><p>This is an option, but we already decided not to evaluate JavaScript inside our templates. The helper function may come handy here. Try this function:</p><div><pre class="programlisting">// A cleaner template
var tplString = '&lt;img src="img/&lt;%= getAvatar(avatar) %&gt;" /&gt;'; 
var data = this.model.getJSON();
var html = _.template(tplString, _.extend(data, {
  // A template helper function to be merged with data
  getAvatar: function (avatar) {
    return avatar || "images/default_avatar.png";
  }
}));</pre></div><p>So, while <a id="id90" class="indexterm"/>you are passing the data into the <code class="literal">_.template()</code> method, you need to make sure the template <a id="id91" class="indexterm"/>methods reside there as properties or subproperties. The question is why do we need to add the helper function as a part of the data? The reason is that most template libraries, including Underscore's template, create the data object that is passed to it the context of the function. So, the helper function is called on the context of data and can only be available in that way.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>There are a number of template engines that have some of the previous solutions inbuilt. If you are developing a small application, you may find Underscore's micro-templating solution enough for development. But if you are going to have complex templates in your application, we would recommend going for <code class="literal">Handlebars</code>, a popular and well accepted template engine.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Understanding automatic model-view data binding</h1></div></div></div><p>Whenever <a id="id92" class="indexterm"/>an attribute of the attached<a id="id93" class="indexterm"/> model changes, we refresh the view to display the updated data. A <code class="literal">change</code> event listener is attached to the model inside the <code class="literal">initialize()</code> method of the view as follows:</p><div><pre class="programlisting">this.listenTo(this.model, 'change', this.render);</pre></div><p>However, there are options that can handle this data binding automatically and you do not need to take care of it for every model-view relationship. This principle is more aligned towards the MVVM design pattern than the Backbone's MV* pattern, and you will find it in frameworks such as <code class="literal">Knockout.js</code> and <code class="literal">Meteor.js</code>.</p><p>For Backbone, there are multiple plugins such as <code class="literal">Backbone.Stickit</code> (<a class="ulink" href="http://nytimes.github.io/backbone.stickit/">http://nytimes.github.io/backbone.stickit/</a>), <code class="literal">Backbone.ModelBinder</code> (<a class="ulink" href="https://github.com/theironcook/Backbone.ModelBinder">https://github.com/theironcook/Backbone.ModelBinder</a>), and <code class="literal">Rivets.js</code> (<a class="ulink" href="http://www.rivetsjs.com/">http://www.rivetsjs.com/</a>). These plugins provide a similar data binding feature. We are not going to discuss each plugin here; however, the implementation process is simple and similar for all of these plugins. If you wish to use such functionality, look into these plugins and use the one that fits your needs.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Using Marionette's ItemView, CollectionView, and CompositeView</h1></div></div></div><p>Marionette<a id="id94" class="indexterm"/> (<a class="ulink" href="http://marionettejs.com/">http://marionettejs.com/</a>) is a<a id="id95" class="indexterm"/> composite application library for Backbone.js. Developed by Derick Bailey, it is a collection of common patterns and solutions to Backbone problems. It is a great library and lots of developers use it for their Backbone-based applications.</p><p>One important thing about Marionette is that it offers several separate packages for views, regions, and so on, and allows you to use any of them freely without requiring the complete library. In this section, we will explore Marionette's <code class="literal">ItemView</code>, the <code class="literal">CollectionView</code>, and the <code class="literal">CompositeView</code> functionalities. These views solve a number of problems we discussed in the previous sections.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>ItemView</h2></div></div></div><p>
<code class="literal">ItemView</code><a id="id96" class="indexterm"/> represents<a id="id97" class="indexterm"/> a single view for an item, it can be a model view or a collection view. It extends the <code class="literal">Marionette.View</code> class, which is a core view with a number of reusable functions. <code class="literal">Marionette.View</code> takes care of triggering, delegating, and undelegating events.</p><p>If you plan to use Marionette, views with a model or a collection should extend the <code class="literal">ItemView</code> class. It provides a number of functionalities<a id="id98" class="indexterm"/> including:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">serializeData()</code> method<a id="id99" class="indexterm"/> that is a generic method to return data for the model or collection that is attached to the view.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">close()</code> method<a id="id100" class="indexterm"/> that takes care of removing views from DOM and cleanup resources. This is similar to the <code class="literal">close()</code> method of the <code class="literal">BaseView</code> class we learned in <a class="link" href="ch01.html" title="Chapter 1. Reducing Boilerplate with Plugin Development">Chapter 1</a>, <em>Reducing Boilerplate with Plugin Development</em>.</li><li class="listitem" style="list-style-type: disc">Some custom events such as:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">'render' / onRender</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">'before:render' / onBeforerender</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">'close' / onClose</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">'before:close' / onBeforeClose</code> event</li></ul></div></li></ul></div><p>Let's look into a basic <code class="literal">ItemView</code> class definition as shown in the following code:</p><div><pre class="programlisting">var UserItemView = Marionette.ItemView.extend({
  tagName: 'li',
  template: _.template('&lt;%= firstName %&gt; &lt;%= lastName %&gt;'),

  onRender: function () {
    // After render functionality here
  },

  onClose: function () {
    // Do some cleanup here
  }
});</pre></div><p>We will create an instance of this and pass the model to it as follows:</p><div><pre class="programlisting">var userItemView = new UserItemView({
  model: new Backbone.Model({
    firstName: 'Sudipta',
    lastName: 'Kundu'
  })
});

$(document.body).append(userItemView.render().el);

// Close and destroy the view after 2 seconds
setTimeout(function () {
  // userItemView.close();
}, 2000); </pre></div><p>This is an <a id="id101" class="indexterm"/>example of a simple <code class="literal">ItemView</code> class, where we pass the model and use its methods to display the data. Have a look, we didn't provide any <code class="literal">render()</code> method definition here. It is because <code class="literal">ItemView</code> provides a simple rendering functionality by default. <code class="literal">ItemView</code> has a <code class="literal">serializeData()</code> method that sends the model data or the collection data attached to this view, and the <code class="literal">render()</code> method applies this data to its template and populates the view automatically with generated HTML content. Here is how the <code class="literal">serializeData()</code> method looks in Marionette:</p><div><pre class="programlisting">  // Serialize the model or collection for the view. If a model is
  // found, '.toJSON()' is called. If a collection is found,
 '// .toJSON()'is also called, but is used to populate an 'items'
  // array in the resulting data. If both are found, defaults to 
  // the model. You can override the 'serializeData' method in your 
  // own view definition, to provide custom serialization for your 
  // view's data.
  serializeData: function () {
    var data = {};

    if (this.model) {
      data = this.model.toJSON();
    } else if (this.collection) {
      data = {
        items: this.collection.toJSON()
      };
    }

    return data;
  }</pre></div><p>So, <code class="literal">ItemView</code> expects a template, a model, or a collection, and it reduces the initial boilerplate to render the view on its own. As you can see, a<a id="id102" class="indexterm"/> number of basic and reusable functionalities are handled in the <code class="literal">ItemView</code> class. It provides all the functions that we discussed in our <code class="literal">BaseView</code> class. Using it as a base class for your views can give a lot of flexibility while writing Backbone.js based applications.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>CollectionView</h2></div></div></div><p>A<a id="id103" class="indexterm"/> <code class="literal">CollectionView</code> class,<a id="id104" class="indexterm"/> as the name suggests, shows a list of items for each model item in the specified collection. The functionality is similar to the previous example, but much more robust with subviews. A <code class="literal">CollectionView</code> class creates an instance of <code class="literal">ItemView</code> for each data item and appends its elements to the main view's <code class="literal">el</code>.</p><p>Some of the common features<a id="id105" class="indexterm"/> of <code class="literal">CollectionView</code> are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating, adding, and removing child views.</li><li class="listitem" style="list-style-type: disc">Displaying an empty view when the collection is empty.</li><li class="listitem" style="list-style-type: disc">Automatic rendering and re-rendering for <code class="literal">'add'</code>, <code class="literal">'remove'</code>, and <code class="literal">'reset'</code> events of the collections, where the collection view automatically renders the changes.</li><li class="listitem" style="list-style-type: disc">Provides a number of useful custom events:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">'render' / onRender</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">'before:render' / beforeRender</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">'closed' / 'collection:closed'</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">'before:item:added' / 'after:item:added'</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">'item:removed'</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">'itemview:*'</code> event bubbling from child views</li></ul></div></li><li class="listitem" style="list-style-type: disc">Includes a <code class="literal">close()</code> method<a id="id106" class="indexterm"/> that removes the child views before closing.</li></ul></div><p>Now let's use the previous <code class="literal">UserItemView</code> class as the child item and create a <code class="literal">CollectionView</code> class:</p><div><pre class="programlisting">// Create a collection view and pass the item view class
var UsersView = Marionette.CollectionView.extend({
    tagName: 'ul',
    itemView: UserItemView
});

var usersView = new UsersView({
    collection: new Backbone.Collection([{
        firstName: 'Sandip',
        lastName: 'Maity'
    }, {
        firstName: 'Debopam',
        lastName: 'Biswas'
    }])
});

$(document.body).append(usersView.render().el); </pre></div><p>Look how small the code is when compared to the code we developed earlier in this chapter to display a <a id="id107" class="indexterm"/>list of items. We just pass the class name <code class="literal">UserItemView</code> in the <code class="literal">CollectionView</code> instance as <code class="literal">itemView</code>, and it takes care of everything from rendering to destroying child items when the parent view gets removed.</p><p>Marionette's <code class="literal">CollectionView</code> reduces the boilerplate in your code to a great extent. If you are developing an application with multiple list type views, you can produce much cleaner code using Marionette's collection view, as it takes out most of the reusable functionality itself.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Working with CompositeView</h2></div></div></div><p>A <code class="literal">CompositeView</code><a id="id108" class="indexterm"/> extends <a id="id109" class="indexterm"/>from the <code class="literal">Marionette.CollectionView</code> class. In general, you can think of it as a combination of <code class="literal">ItemView</code> and <code class="literal">CollectionView</code>, where it accepts a model that represents a single dataset and a collection that displays multiple data. This is particularly useful when you have a hierarchical or a tree-like structure. You can relate it to the figure we mentioned in the <em>Re-rendering parent views</em> section. There we had to show data for the <code class="literal">Company</code> model and <code class="literal">Employees</code> collection together, and <code class="literal">CompositeView</code> would have been an excellent tool to provide a compact solution for that.</p><p>A composite view provides some specific functionalities apart from the basic <code class="literal">CollectionView</code> functions<a id="id110" class="indexterm"/>, which can be explained as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Model data of <code class="literal">CompositeView</code> is applied to its template property.</li><li class="listitem" style="list-style-type: disc">It has an <code class="literal">itemViewContainer</code> property that specifies within which element the collection view will be rendered. The <code class="literal">itemViewContainer</code> property should <a id="id111" class="indexterm"/>either be a jQuery selector or a jQuery object, or it can be a function that returns a jQuery selector or jQuery object.</li><li class="listitem" style="list-style-type: disc">When <code class="literal">itemViewContainer</code> is not sufficient for specifying the exact position of <code class="literal">ItemView</code>, overriding the <code class="literal">appendHtml()</code> method<a id="id112" class="indexterm"/> of <code class="literal">CollectionView</code> may provide the desired result, as shown in the following code snippet:<div><pre class="programlisting">appendHtml: function (galleryView, imageView, index) {
  // Put the imageView i.e. ItemView instances 
  // inside element with class "box-result"
  galleryView.$(".box-result").append(imageView.el);
}</pre></div></li></ul></div><p>Let's assume a <a id="id113" class="indexterm"/>scenario where we want to display company details along with a list of the employees. So, there will be a <code class="literal">Company</code> model, as shown in the following code snippet:</p><div><pre class="programlisting">// Company model
var Company = Backbone.Model.extend({
  defaults: {
    name: '',
    specialty: ''
  }
});</pre></div><p>Similarly, there must be an <code class="literal">Employee</code> model for each employee too, as follows:</p><div><pre class="programlisting">// Employee model
var Employee = Backbone.Model.extend({
  defaults: {
    name: ''
  }
});</pre></div><p>Let's define an <code class="literal">Employees</code> collection for the employee list, as follows:</p><div><pre class="programlisting">// Employees collection
var Employees = Backbone.Collection.extend({
  model: Employee
});</pre></div><p>For the composite view, we want to present each employee as a separate <code class="literal">ItemView</code> instance so that event delegation becomes easy:</p><div><pre class="programlisting">// Create an ItemView instance for the child items
var EmployeeItemView = Marionette.ItemView.extend({
  tagName: 'li',
  template: _.template('&lt;%= name %&gt;')
});</pre></div><p>Now we can<a id="id114" class="indexterm"/> define the composite view that will display the model data and the collection data together, as shown in the following code:</p><div><pre class="programlisting">// Create a collection view and pass the item view class
var CompanyView = Marionette.CompositeView.extend({
  template: _.template(['&lt;h2&gt;&lt;%= name %&gt; &lt;/h2&gt;',
    '&lt;span&gt;&lt;%= specialty %&gt; &lt;/span&gt;',
    '&lt;ul class="employees"&gt;&lt;/ul&gt;'
  ].join('')),
  itemView: EmployeeItemView,
  itemViewContainer: '.employees',

  // Add a company details to this view's model and collection
  addCompany: function (data) {
    if (!data) return;

    if (data.employees) {
      this.collection = new Employees(data.employees);
    }

    delete data.employees;
    this.model = new Company(data);
  }
});</pre></div><p>Here, we first defined a template where we kept a place for the employee list to go. Then we mentioned the <code class="literal">itemView</code> option as the <code class="literal">EmployeeView</code> class that will be used by the collection to create an instance and populate it with each employee data. These item views will be stacked in the element mentioned in the <code class="literal">itemViewContainer</code> property. Now, let's create the composite view instance, add a company to it, and render it, as shown in the following code snippet:</p><div><pre class="programlisting">var companyView = new CompanyView();

// Add a company details
companyView.addCompany({
  name: 'Innofied',
  specialty: 'Team of JavaScript specialists',
  employees: [{
    name: 'Swarnendu De'
  }, {
    name: 'Sandip Saha'
  }]
});

$(document.body).append(companyView.render().el);</pre></div><p>The result we get is as shown in the following screenshot:</p><div><img src="img/3576OS_02_02.jpg" alt="Working with CompositeView"/></div><p>So, you can see that a composite view provides a compact mechanism to display a model and a collection <a id="id115" class="indexterm"/>associated to it in a single view. You may have a tree structure data, and for that, multiple composite views need to be created. By default, the rendering mechanism of a composite view is hierarchical in nature and the <code class="literal">itemView</code> property is of the <code class="literal">CompositeView</code> type, if not overridden.</p><p>We hope we gave you a basic idea of all the Marionette views. Discussing all these views in an advanced level is beyond the scope of this book, but the Marionette docs will give you a complete description of the framework. We mention some resources and books about Marionette in <a class="link" href="apa.html" title="Appendix A. Books, Tutorials, and References">Appendix A</a>, <em>Books, Tutorials, and References</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Using Layout Manager</h1></div></div></div><p>When you<a id="id116" class="indexterm"/> work with multiple views in an application, it often becomes difficult to <a id="id117" class="indexterm"/>manage activities such as multiple view rendering, adding animation to an element, or replacing a view with another view. Let's look into a great extension, <code class="literal">LayoutManager</code> (<a class="ulink" href="https://github.com/tbranyen/backbone.layoutmanager">https://github.com/tbranyen/backbone.layoutmanager</a>), which provides a logical foundation to assemble layouts and views within the application.</p><p>Marionette too provides a similar functionality with its <code class="literal">RegionManager</code>, but we chose to discuss the <code class="literal">LayoutManager</code> plugin here because not everyone uses Marionette and this plugin can work independently with your Backbone app. If you are already using Marionette, I advise you to verify whether <code class="literal">RegionManager</code> solves your needs or not. Alternatively, you can use the <code class="literal">LayoutManager</code> plugin along with Marionette.</p><p>The <code class="literal">LayoutManager</code> extension provides solutions to a number of pain points such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It handles asynchronous rendering of views if you are planning to dynamically load your templates from external files</li><li class="listitem" style="list-style-type: disc">It defines the layout as an HTML structure and assigns the views to proper elements as given in the layout configuration</li><li class="listitem" style="list-style-type: disc">It provides functionality to perform the following activities:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Insert views, apply data to the given template, and auto render them</li><li class="listitem" style="list-style-type: disc">Retrieve or remove views depending on multiple selection criteria</li><li class="listitem" style="list-style-type: disc">Cleans up views by unbinding all events from the view or from the model/collection that have this view as the context</li></ul></div></li></ul></div><p>We will look<a id="id118" class="indexterm"/> into these points by creating a simple layout as shown in the following screenshot:</p><div><img src="img/3576OS_02_01.jpg" alt="Using Layout Manager"/></div><p>There is a list of users, and when you click on a user item, the user's details are displayed on the right-hand side of the layout. You will find the complete code example with all HTML, CSS, and other files in our sample code. Here we will describe the parts that are critical.</p><p>We create a user model and collection first as shown in the following code snippet:</p><div><pre class="programlisting">// Change template delimiter to Mustache type
_.templateSettings = {
  interpolate: /\{\{(.+?)\}\}/g
};

// User Model
var User = Backbone.Model.extend({
  defaults: {
    avatar: '',
    name: '',
    email: '',
    phone: '',
    twitter: ''
  }
});

// Users collection
var Users = Backbone.Collection.extend({
  model: User
});</pre></div><p>We will have three <a id="id119" class="indexterm"/>views for this page: <code class="literal">UserList</code>, <code class="literal">UserItem</code>, and <code class="literal">UserDetails</code> views<a id="id120" class="indexterm"/>. The <code class="literal">UserItem</code> view<a id="id121" class="indexterm"/> will act as a subview of the <code class="literal">UserList</code> view<a id="id122" class="indexterm"/>. First, let's write the templates for these three views:</p><div><pre class="programlisting">&lt;!—- Layout manager template --&gt;
&lt;script type="text/template" id="tpl_main_content"&gt;
  &lt;div id="main_content"&gt;
    &lt;div class="user-list"&gt;&lt;/div&gt;
    &lt;div class="user-details"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;

&lt;!—- User item template --&gt;
&lt;script type="text/template" id="tpl_user_item"&gt;
  &lt;a class="name" href="#"&gt;{{name}}&lt;/a&gt;
&lt;/script&gt;

&lt;!—- User details template --&gt;
&lt;script type="text/template" id="tpl_user_details"&gt;
  &lt;div class="avatar"&gt;&lt;img src="img/{{avatar}}" /&gt;&lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Name:&lt;/strong&gt;  {{name}}&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Email:&lt;/strong&gt;  {{email}}&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Phone:&lt;/strong&gt;  {{phone}}&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Twitter:&lt;/strong&gt;  {{twitter}}&lt;/li&gt;
    &lt;/ul&gt;
&lt;/script&gt;</pre></div><p>The view templates are pretty simple. The layout template, which defines the structure of the page, is the most important here. <a id="id123" class="indexterm"/>The task has three aspects: you have to divide the layout in a number of sections as you want, add proper styles to align them, and then define your views inside the <code class="literal">LayoutManager</code> configuration that will automatically render the views inside these sections.</p><p>First, we will define the user list item that will display only the name of the user.</p><div><pre class="programlisting">// UserItem sub view
var UserItem = Backbone.View.extend({
  tagName: 'li',
  template: '#tpl_user_item',
  manage: true,

  // LayoutManager uses serialize method to apply the data into template
  serialize: function () {
    return this.model.toJSON();
  }
});</pre></div><p>Notice the two new properties here: manage and serialize. The <code class="literal">manage</code> property is a Boolean property that determines whether a view will be treated as a layout or not. The <code class="literal">manage</code> property must be set to <code class="literal">true</code> if you intend to use the view inside the layout manager and handle its rendering function. You can also set it to <code class="literal">true</code> globally for all the views and specify it as <code class="literal">FALSE</code> if required for a particular view.</p><p>
<code class="literal">LayoutManager</code> uses the <a id="id124" class="indexterm"/>
<code class="literal">serialize()</code> method<a id="id125" class="indexterm"/> to apply the data to the view's template. The default implementation of the <code class="literal">serialize()</code> method returns an empty object. You should override it to send the data you want to display. Here we are sending the model data associated with the view.</p><p>
<code class="literal">LayoutManager</code> provides two custom events, <code class="literal">beforeRender</code> and <code class="literal">afterRender</code>, to a view as it takes care of the render function itself. While using the <code class="literal">beforeRender()</code> method<a id="id126" class="indexterm"/>, the element of the view isn't yet available, but if you insert a view into the layout, <code class="literal">LayoutManager</code> keeps track of it and renders it once the parent view is available in DOM. We can use this method where we will iterate through the users' collection and insert the <code class="literal">UserItem</code> view to the list view:</p><div><pre class="programlisting">// User List view
var UserList = Backbone.View.extend({
  tagName: 'ul',
  className: 'nav nav-tabs nav-stacked',
  manage: true,

  // Before rendering the list, 
  //insert all the child list items into it
  beforeRender: function () {
    this.collection.each(function (model) {
      // insertview method inserts the views 
      // directly inside the parent view
      this.insertView(new UserItem({
        model: model
      }));
    }, this);
  }
});  </pre></div><p>There are two <a id="id127" class="indexterm"/>similar methods <code class="literal">insertView</code>/<code class="literal">insertViews</code> and <code class="literal">setView</code>/<code class="literal">setViews</code>. Both these functions insert views into the layout according to the given selector name. The <code class="literal">setView()</code> method<a id="id128" class="indexterm"/> takes an extra <code class="literal">insert</code> parameter, which is a Boolean value, and determines whether the view will replace the complete content of the selector or will simply append to it. We create <code class="literal">UserItem</code> views, attach models to them, and insert them into the <code class="literal">UserList</code> view. The child views get automatically rendered inside.</p><p>We are done with the basic list definition. Now, let's define the layout manager functionality as follows:</p><div><pre class="programlisting">// Create a collection with some data
var users = new Users([{
  name: 'John Doe',
  avatar: 'avatar.png',
  phone: '+88-888-8888',
  twitter: 'johndoe',
  email: 'johndoe@example.com'
}, {
  name: 'Swarnendu De',
  avatar: 'avatar.png',
  phone: '+99-999-9999',
  twitter: 'swarnendude',
  email: 'swarnendude@example.com'
}]);

// Define the main layout
var MainLayout = Backbone.Layout.extend({
  template: "#tpl_main_content",

  // Assign the view to specific selectors
  views: {
    '.user-list': new UserList({
      collection: users
    })
  }
});</pre></div><p>The <code class="literal">LayoutManager</code> is also a type of <code class="literal">Backbone.View</code>, and you can render it as you do for any other Backbone view. In the <code class="literal">views</code> property, we can specify one or more view instances. In our case, we created the <code class="literal">UserList</code> instance, passed the collection to it, and let the <code class="literal">LayoutManager</code> take care of everything else to render it inside the <code class="literal">.user-list</code> element.</p><p>So, up to this <a id="id129" class="indexterm"/>point, we have our layout rendered with the user list inside. The only action remaining is to display the user details once we click a user item. Let's define the <code class="literal">UserDetails</code> view, which is a simple one:</p><div><pre class="programlisting">// User Details view
var UserDetails = Backbone.View.extend({
  manage: true,
  template: '#tpl_user_details',

  serialize: function () {
    return this.model.toJSON();
  },

  // Set the selected model 
  setModel: function (model) {
    if (model) {
      this.model = model;
    }

    return this;
  }
}); </pre></div><p>This is exactly the same as our <code class="literal">UserItem</code> view definition with an extra <code class="literal">setModel()</code> method<a id="id130" class="indexterm"/> that sets the model to the selected one. Now we will insert this view into the layout when we click a list item. For that, we will add a click event handler to the <code class="literal">UserItem</code> view as shown in the following code:</p><div><pre class="programlisting">var UserItem = Backbone.View.extend({
  ...
  events: {
    'click a': 'showDetails'
  },

  showDetails: function () {
    // Check Whether details view exists
    var detailsView = mainLayout.getView('.user-details');

    // If details view doesn't exist, create one, 
    // set the new model and render it
    if (!detailsView) {
      mainLayout.setView('.user-details', new UserDetails().setModel(this.model).render());
    } else {
      // Set the latest clicked model and re-render
      detailsView.setModel(this.model).render();
    }
  }
});</pre></div><p>We use<a id="id131" class="indexterm"/> the <code class="literal">getView</code> method<a id="id132" class="indexterm"/> that can retrieve a view based on multiple criterion such as selector, model, or function. We check whether the details view is available or not. If not, we create a <code class="literal">DetailsView</code> instance, set the model, and render it. Otherwise, we reset the model and re-render the view.</p><p>So, we are done with the complete layout management. It is observed that most of the rendering functionalities are handled by the manager itself. This is just a basic example; <code class="literal">LayoutManager</code> can provide many more options and functionalities and eliminate 90 percent of your view management tasks. Do read their documentation thoroughly as you will be able to use most of it in your application.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, we have gone through a number of important problems most Backbone developers come across, and learned multiple solutions to solve them. First, we discussed the partial view rendering and nested views. Any Backbone application needs to deal with nested views and if we can maintain their initialization, DOM reflow, and cleanup properly, it will greatly enhance the performance of the whole application.</p><p>We spoke about different template-handling methods, saw a number of solutions to load precompiled templates from external files, organized templates within applications, and understood how helper functions can eliminate evaluation of JavaScript codes inside templates and help us to create cleaner templates.</p><p>Finally, we learned about some of the very important extensions: Marionette's <code class="literal">ItemView</code>, <code class="literal">CollectionView</code>, <code class="literal">CompositeView</code>, and <code class="literal">LayoutManager</code>. All of these extensions provide great flexibility by taking out a lot of boilerplate code and managing your views by a great deal.</p><p>In the next chapter, we will talk about Backbone models; we will look into model data validation, different plugins for validation, model serialization, and the relational data model.</p></div></body></html>