<html><head></head><body>
		<div id="_idContainer322">
			<h1 id="_idParaDest-228" class="chapter-number"><a id="_idTextAnchor227"/>13</h1>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/>Working with Blender and Three.js</h1>
			<p>In this chapter, we’ll dive a bit deeper into how you can use Blender and Three.js together. We’ll explain the following concepts in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><em class="italic">Exporting from Three.js and importing into Blender</em>: We’ll create a simple scene, export it from Three.js, and load and render it <span class="No-Break">in Blender.</span></li>
				<li><em class="italic">Exporting a static scene from Blender and importing it into Three.js</em>: Here, we will create a scene in Blender, export it into Three.js, and render it <span class="No-Break">in Three.js.</span></li>
				<li><em class="italic">Exporting an animation from Blender and importing it into Three.js</em>: Blender allows us to create animations, we’ll create a simple animation, and load and show it <span class="No-Break">in Three.js.</span></li>
				<li><em class="italic">Baking lightmaps and ambient occlusion maps in Blender</em>: Blender allows us to bake different types of maps that we can use <span class="No-Break">in Three.js.</span></li>
				<li><em class="italic">Custom UV modeling in Blender</em>: With UV modeling, we determine how a texture is applied to a geometry. Blender provides a lot of tools to make that easy. We’ll explore how you can use the UV modeling capabilities of Blender and use the results <span class="No-Break">in Three.js.</span></li>
			</ul>
			<p>Before we get started with this chapter, make sure to install Blender so that you can follow along. You can install Blender by downloading the installer for your OS from here: <a href="https://www.blender.org/download/">https://www.blender.org/download/</a>. The screenshots shown of Blender in this chapter were taken using the macOS version of Blender, but the versions for Windows and Linux look <span class="No-Break">the same.</span></p>
			<p>Let’s get started with our first topic, where we create a scene in Three.js, export it to an intermediate format, and finally import it <span class="No-Break">into Blender.</span></p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor229"/>Exporting from Three.js and importing into Blender</h1>
			<p>For this <a id="_idIndexMarker1203"/>example, we’ll just take a simple sample reusing the <a id="_idIndexMarker1204"/>parametric geometry we saw in <a href="B18726_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Exploring Advanced Geometries</em>. If <a id="_idIndexMarker1205"/>you open <strong class="source-inline">export-to-blender.html</strong> in <a id="_idIndexMarker1206"/>the browser, you can create some parametric geometries. At the bottom of the menu on the right, we’ve added an <span class="No-Break"><strong class="bold">exportScene</strong></span><span class="No-Break"> button:</span></p>
			<div>
				<div id="_idContainer281" class="IMG---Figure">
					<img src="image/Figure_13.1_B18726.jpg" alt="Figure 13.1 – A simple scene that we’ll export"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – A simple scene that we’ll export</p>
			<p>When you click on that button, the model will be saved in the GLTF format and downloaded onto your computer. To export a model with Three.js, we can use <strong class="source-inline">GLTFexporter</strong> <span class="No-Break">like so:</span></p>
			<pre class="source-code">
const exporter = new GLTFExporter()
const options = {
  trs: false,
  onlyVisible: true,
  binary: false
}
exporter.parse(
  scene,
  (result) =&gt; {
    const output = JSON.stringify(result, null, 2)
    save(new Blob([output], { type: 'text/plain' }),
      'out.gltf')
  },
  (error) =&gt; {
    console.log('An error happened during parsing of the
      scene', error)
  },
  options
)</pre>
			<p>Here, you can see <a id="_idIndexMarker1207"/>that we have created a <strong class="source-inline">GLTFExporter</strong> that <a id="_idIndexMarker1208"/>we can use to export a <strong class="source-inline">THREE.Scene</strong>. We <a id="_idIndexMarker1209"/>can export a scene in the glTF binary format <a id="_idIndexMarker1210"/>or the JSON format. For this example, we export in JSON. The glTF format is a complex format, and while <strong class="source-inline">GLTFExporter</strong> supports many of the objects that make up a Three.js scene, you can still run into issues where the export fails. Updating to the latest version of Three.js is often the best solution since work is being constantly done on <span class="No-Break">this component.</span></p>
			<p>Once we’ve got our <strong class="source-inline">output</strong>, we can trigger the browser’s <strong class="source-inline">download</strong> functionality, which will save it to your <span class="No-Break">local machine:</span></p>
			<pre class="source-code">
const save = (blob, filename) =&gt; {
  const link = document.createElement('a')
  link.style.display = 'none'
  document.body.appendChild(link)
  link.href = URL.createObjectURL(blob)
  link.download = filename
  link.click()
}</pre>
			<p>The <a id="_idIndexMarker1211"/>result is a glTF file, <a id="_idIndexMarker1212"/>and its first <a id="_idIndexMarker1213"/>couple of lines look <a id="_idIndexMarker1214"/><span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
  "asset": {
    "version": "2.0",
    "generator": "THREE.GLTFExporter"
  },
  "scenes": [
    {
      "nodes": [
        0,
        1,
        2,
        3
      ]
    }
  ],
  "scene": 0,
  "nodes": [
    {},
...</pre>
			<p>Now that <a id="_idIndexMarker1215"/>we’ve got a glTF file containing our scene, we can <a id="_idIndexMarker1216"/>import this into Blender. So, open up Blender <a id="_idIndexMarker1217"/>and you’ll be presented with the default scene with a single <a id="_idIndexMarker1218"/>cube. Remove the cube by selecting it and pressing <strong class="bold">x</strong>. Once removed, we have an empty scene in which we’ll load our <span class="No-Break">exported scene.</span></p>
			<p>From the <strong class="bold">File</strong> menu at the top, select <strong class="bold">Import | glTF 2.0</strong>, and you’ll be presented with a file browser. Navigate to where you’ve downloaded the model, select the file, and click on <strong class="bold">Import glTF 2.0</strong>. This will open the file, and show you something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer282" class="IMG---Figure">
					<img src="image/Figure_13.2_B18726.jpg" alt="Figure 13.2 – Three.js scene imported in Blender"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Three.js scene imported in Blender</p>
			<p>As you can <a id="_idIndexMarker1219"/>see, Blender has imported our complete <a id="_idIndexMarker1220"/>scene, and the <strong class="source-inline">THREE.Mesh</strong> we defined <a id="_idIndexMarker1221"/>in Three.js is now available in Blender. In Blender, we <a id="_idIndexMarker1222"/>can now use this just like any other mesh. For this example, however, let’s keep it simple and just render this scene with the <strong class="bold">Cycles</strong> Blender renderer. To do this, click on <strong class="bold">Render Properties</strong> in the menu on the right (the icon that looks like a camera) and for <strong class="bold">Render Engine</strong>, <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Cycles</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer283" class="IMG---Figure">
					<img src="image/Figure_13.03_B18726.jpg" alt="Figure 13.3 – Rendering with the Cycles render engine in Blender"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Rendering with the Cycles render engine in Blender</p>
			<p>Next, we need <a id="_idIndexMarker1223"/>to position the camera correctly, so use the <a id="_idIndexMarker1224"/>mouse to move around the scene until you’ve got <a id="_idIndexMarker1225"/>a view you’re happy with, and then press <em class="italic">Ctrl</em> + <em class="italic">Alt</em> + <em class="italic">numpad 0</em> to <a id="_idIndexMarker1226"/>align the camera. At this point, you’ll have something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer284" class="IMG---Figure">
					<img src="image/Figure_13.2_B18726.jpg" alt="Figure 13.4 – Showing the area the camera sees and what will be rendered"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Showing the area the camera sees and what will be rendered</p>
			<p>Now, we can render the scene by hitting <em class="italic">F12</em>. This will start the <strong class="bold">Cycles</strong> render engine, and you’ll see the model being rendered <span class="No-Break">in Blender:</span></p>
			<div>
				<div id="_idContainer285" class="IMG---Figure">
					<img src="image/Figure_13.5_B18726.jpg" alt="Figure 13.5 – Final image being rendered in Blender from our exported Three.js model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Final image being rendered in Blender from our exported Three.js model</p>
			<p>As you’ve seen, <a id="_idIndexMarker1227"/>using the glTF as a format for exchanging <a id="_idIndexMarker1228"/>models and scenes between Three.js and Blender is <a id="_idIndexMarker1229"/>very straightforward. Just use <strong class="source-inline">GLTFExporter</strong>, import <a id="_idIndexMarker1230"/>the model in Blender, and you can use everything Blender has to offer on <span class="No-Break">your model.</span></p>
			<p>Of course, the other way around works just as easily, as we’ll show you in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor230"/>Exporting a static scene from Blender and importing it into Three.js</h1>
			<p>Exporting models <a id="_idIndexMarker1231"/>from Blender is just as easy as importing <a id="_idIndexMarker1232"/>them. In the older version of Three.js, there <a id="_idIndexMarker1233"/>was a specific Blender plugin you could use to <a id="_idIndexMarker1234"/>export in a Three.js-specific JSON format. In later versions though, glTF in Three.js has become the standard for exchanging models with other tools. So, to get this working with Blender, all we have to do <span class="No-Break">is this:</span></p>
			<ol>
				<li>Create a model <span class="No-Break">in Blender.</span></li>
				<li>Export the model to a <span class="No-Break">glTF file.</span></li>
				<li>Import the glTF file in Blender and add it to <span class="No-Break">the scene.</span></li>
			</ol>
			<p>Let’s create a simple model in Blender first. We’ll use the default model Blender uses, which can be added in <strong class="bold">Object Mode</strong> by selecting <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Monkey</strong> from the menu. Click on <strong class="bold">monkey</strong> to <span class="No-Break">select it:</span></p>
			<div>
				<div id="_idContainer286" class="IMG---Figure">
					<img src="image/Figure_13.6_B18726.jpg" alt="Figure 13.6 – Creating the model in Blender that you want to export"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Creating the model in Blender that you want to export</p>
			<p>Once the <a id="_idIndexMarker1235"/>model is <a id="_idIndexMarker1236"/>selected, in <a id="_idIndexMarker1237"/>the top <a id="_idIndexMarker1238"/>menu, select <span class="No-Break"><strong class="source-inline">File-&gt;Export-&gt;glTF 2.0</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer287" class="IMG---Figure">
					<img src="image/Figure_13.07_B18726.jpg" alt="Figure 13.7 – Selecting the glTF export"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Selecting the glTF export</p>
			<p>For this <a id="_idIndexMarker1239"/>example, we only export the mesh. Note that <a id="_idIndexMarker1240"/>when you’re exporting from Blender, always <a id="_idIndexMarker1241"/>check the <strong class="bold">Apply Modifiers</strong> checkbox. This <a id="_idIndexMarker1242"/>will make sure any advanced generators or modifiers used in Blender are applied before exporting <span class="No-Break">the mesh.</span></p>
			<div>
				<div id="_idContainer288" class="IMG---Figure">
					<img src="image/Figure_13.08_B18726.jpg" alt="Figure 13.8 – Exporting the model as a glTF file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Exporting the model as a glTF file</p>
			<p>Once <a id="_idIndexMarker1243"/>the file is exported, we can load it in Three.js <a id="_idIndexMarker1244"/><span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">GLTFImporter</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
  const loader = new GLTFLoader()
  return loader.loadAsync('/assets/gltf/
    blender-export/monkey.glb').then((structure) =&gt; {
    return structure.scene
  })</pre>
			<p>The final result is <a id="_idIndexMarker1245"/>the exact model from Blender, but <a id="_idIndexMarker1246"/>visualized in Three.js (see the <span class="No-Break"><strong class="source-inline">import-from-blender.html</strong></span><span class="No-Break"> example):</span></p>
			<div>
				<div id="_idContainer289" class="IMG---Figure">
					<img src="image/Figure_13.9_B18726.jpg" alt="Figure 13.9 – The Blender model visualized in Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – The Blender model visualized in Three.js</p>
			<p>Note that <a id="_idIndexMarker1247"/>this isn’t just limited to the meshes – with glTF, we <a id="_idIndexMarker1248"/>can also export lights, cameras, and <a id="_idIndexMarker1249"/>textures in the <a id="_idIndexMarker1250"/><span class="No-Break">same manner.</span></p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/>Exporting an animation from Blender and importing it into Three.js</h1>
			<p>Exporting an <a id="_idIndexMarker1251"/>animation from Blender works in pretty much <a id="_idIndexMarker1252"/>the same way as exporting a static scene. Therefore, for <a id="_idIndexMarker1253"/>this example, we’ll create a simple <a id="_idIndexMarker1254"/>animation, export it in the glTF format again, and load it into a Three.js scene. For this, we’re going to create a simple scene where we render a cube falling and breaking into parts. The first thing we need for this is a floor and a cube. Therefore, create a plane and a cube that hangs a little bit above <span class="No-Break">this plane:</span></p>
			<div>
				<div id="_idContainer290" class="IMG---Figure">
					<img src="image/Figure_13.10_B18726.jpg" alt="Figure 13.10 – An empty Blender project"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – An empty Blender project</p>
			<p>Here, we just <a id="_idIndexMarker1255"/>moved the cube up a little bit (press <em class="italic">G</em> to grab the cube) and <a id="_idIndexMarker1256"/>added a plane (<strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Plane</strong>), and then we scaled this plane to make it bigger. Now, we can add physics to <a id="_idIndexMarker1257"/>the scene. In <a href="B18726_12.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Adding Physics and Sounds to Your Scene</em>, we introduced the concept of rigid bodies. Blender uses this <a id="_idIndexMarker1258"/>same approach. Select the cube and use <strong class="bold">Object</strong> | <strong class="bold">Rigid Body</strong> | <strong class="bold">Add Active</strong>, and select the plane and add its rigid body like this: <strong class="bold">Object</strong> | <strong class="bold">Rigid Body</strong> | <strong class="bold">Add Passive</strong>. At this point, when we play (by using the <em class="italic">spacebar</em>) the animation in Blender, you’ll see that the <span class="No-Break">cube falls:</span></p>
			<div>
				<div id="_idContainer291" class="IMG---Figure">
					<img src="image/Figure_13.11_B18726.jpg" alt="Figure 13.11 – A halfway animation of a cube falling"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11 – A halfway animation of a cube falling</p>
			<p>To create the <a id="_idIndexMarker1259"/>breaking block effect, we need to <a id="_idIndexMarker1260"/>enable the <strong class="bold">Cell Fracture</strong> plugin. For this, go to <a id="_idIndexMarker1261"/>the <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong> screen, select <strong class="bold">Add-ons</strong>, use the <a id="_idIndexMarker1262"/>search option to search for the <strong class="source-inline">Cell Fracture</strong> plugin, and check the checkbox to enable <span class="No-Break">the plugin:</span></p>
			<div>
				<div id="_idContainer292" class="IMG---Figure">
					<img src="image/Figure_13.12_B18726.jpg" alt="Figure 13.12 – Enabling the Cell Fracture plugin"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12 – Enabling the Cell Fracture plugin</p>
			<p>Before we split <a id="_idIndexMarker1263"/>up the cube into smaller parts, let’s <a id="_idIndexMarker1264"/>add some vertices to the model so that Blender <a id="_idIndexMarker1265"/>has a good number of vertices, which it can use to <a id="_idIndexMarker1266"/>split up the model. For this, select the cube in <strong class="bold">Edit Mode</strong> (by using the <em class="italic">Tab</em> key) and from the menu at the top, select <strong class="bold">Edge</strong> | <strong class="bold">Subdivide</strong>. Do this twice, and you’ll have something looking <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer293" class="IMG---Figure">
					<img src="image/Figure_13.13_B18726.jpg" alt="Figure 13.13 – Showing the cube with a number of sub-divisions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13 – Showing the cube with a number of sub-divisions</p>
			<p>Hit <em class="italic">Tab</em> to go <a id="_idIndexMarker1267"/>back to <strong class="bold">Object Mode</strong> and with the cube <a id="_idIndexMarker1268"/>selected, open the <strong class="bold">Cell Fracture</strong> window, and go to <strong class="bold">Object</strong> | <strong class="bold">Quick Effects</strong> | <span class="No-Break"><strong class="bold">Cell Fracture</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer294" class="IMG---Figure">
					<img src="image/Figure_13.14_B18726.jpg" alt="Figure 13.14 – Configuring fractures"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14 – Configuring fractures</p>
			<p>You can play <a id="_idIndexMarker1269"/>around with these settings to get different <a id="_idIndexMarker1270"/>kinds of fractures. With the settings <a id="_idIndexMarker1271"/>configured in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em>, you’ll get something <a id="_idIndexMarker1272"/><span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer295" class="IMG---Figure">
					<img src="image/Figure_13.15_B18726.jpg" alt="Figure 13.15 – Cube showing fractures"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.15 – Cube showing fractures</p>
			<p>Next, select the <a id="_idIndexMarker1273"/>original cube and hit <strong class="bold">x</strong> to delete it. This <a id="_idIndexMarker1274"/>will only leave the fractured parts, which we’ll <a id="_idIndexMarker1275"/>animate. To do this, select all the cells from the cube <a id="_idIndexMarker1276"/>and use <strong class="bold">Object</strong> | <strong class="bold">Rigid Body</strong> | <strong class="bold">Add Active</strong> again. Once done, hit the <em class="italic">spacebar</em> and you’ll see the cube falling and breaking down <span class="No-Break">on impact.</span></p>
			<div>
				<div id="_idContainer296" class="IMG---Figure">
					<img src="image/Figure_13.16_B18726.jpg" alt="Figure 13.16 – The cube after being dropped"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.16 – The cube after being dropped</p>
			<p>At this point, we’ve pretty much got our animation ready. Now, we need to export this animation so that <a id="_idIndexMarker1277"/>we can load it into Three.js and replay it <a id="_idIndexMarker1278"/>from there. Before we do this, make sure to set the <a id="_idIndexMarker1279"/>end of the animation (the lower-right corner <a id="_idIndexMarker1280"/>of the screen) at frame 80, since it isn’t that useful to export the full 250 frames. Besides this, we need to tell Blender to convert the information from the physics engine into a set of keyframes. This needs to be done since we can’t export the physics engine itself, so we have to bake the position and rotation of all the meshes so that we can export them. To do this, select all the cells again, and use <strong class="bold">Object</strong> | <strong class="bold">Rigid Body</strong> | <strong class="bold">Bake to Keyframes</strong>. You can select the defaults and click on the <strong class="bold">Export glTF2.0</strong> button to get the <span class="No-Break">following screen:</span></p>
			<div>
				<div id="_idContainer297" class="IMG---Figure">
					<img src="image/Figure_13.17_B18726.jpg" alt="Figure 13.17 – Animation export settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.17 – Animation export settings</p>
			<p>At this point, we’ll <a id="_idIndexMarker1281"/>have an animation for each of the <a id="_idIndexMarker1282"/>cells, which keeps track of the rotation and <a id="_idIndexMarker1283"/>position of the individual meshes. With this <a id="_idIndexMarker1284"/>information, we can load the scene in Three.js and set up the animation mixer <span class="No-Break">for playback:</span></p>
			<pre class="source-code">
const mixers = []
const modelAsync = () =&gt; {
  const loader = new GLTFLoader()
  return loader.loadAsync('/assets/models/
     blender-cells/fracture.glb').then((structure) =&gt; {
    console.log(structure)
    // setup the ground plane
    const planeMesh = structure.scene.
      getObjectByName('Plane')
    planeMesh.material.side = THREE.DoubleSide
    planeMesh.material.color = new THREE.Color(0xff5555)
    // setup the material for the pieces
    const materialPieces = new THREE.MeshStandardMaterial({ color: 0xffcc33 })
    structure.animations.forEach((animation) =&gt; {
      const meshName = animation.name.substring
     (0, animation.name.indexOf('Action')).replace('.', '')
      const mesh = structure.scene.
        getObjectByName(meshName)
      mesh.material = materialPieces
      const mixer = new THREE.AnimationMixer(mesh)
      const action = mixer.clipAction(animation)
      action.play()
      mixers.push(mixer)
    })
    applyShadowsAndDepthWrite(structure.scene)
    return structure.scene
  })
}</pre>
			<p>In the render <a id="_idIndexMarker1285"/>loop, we need to update the mixer for <a id="_idIndexMarker1286"/><span class="No-Break">each animation:</span></p>
			<pre class="source-code">
const clock = new THREE.Clock()
const onRender = () =&gt; {
  const delta = clock.getDelta()
  mixers.forEach((mixer) =&gt; {
    mixer.update(delta)
  })
}</pre>
			<p>The <a id="_idIndexMarker1287"/>result looks <a id="_idIndexMarker1288"/><span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer298" class="IMG---Figure">
					<img src="image/Figure_13.18_B18726.jpg" alt="Figure 13.18 – An exploded cube in Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.18 – An exploded cube in Three.js</p>
			<p>The same principle <a id="_idIndexMarker1289"/>we’ve shown you here can be applied <a id="_idIndexMarker1290"/>to different kinds of animations <a id="_idIndexMarker1291"/>supported by Blender. The main thing to keep in mind is <a id="_idIndexMarker1292"/>that Three.js won’t understand physics engines used by Blender, or other advanced animation models. Therefore, when you export an animation, make sure you bake the animation so that you can use the standard Three.js tools to play back these <span class="No-Break">keyframe-based animations.</span></p>
			<p>For the next section, we’re going to look a bit closer at how you can use Blender to bake different kinds of textures (maps) that you can then load into Three.js. We’ve already seen the results in action in <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Loading and Working with Textures</em>, but in this section, we’ll show you how to use Blender to bake <span class="No-Break">these maps.</span></p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/>Baking lightmaps and ambient occlusion maps in Blender</h1>
			<p>For this <a id="_idIndexMarker1293"/>scenario, we’re going to revisit the example from <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, where <a id="_idIndexMarker1294"/>we used a lightmap <a id="_idIndexMarker1295"/>from Blender. This lightmap provides good-looking lighting <a id="_idIndexMarker1296"/>without having to calculate it in real time in Three.js. To do this with Blender, we’re going to take the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Set up a simple scene in Blender with a couple <span class="No-Break">of models.</span></li>
				<li>Set up the lighting and the models <span class="No-Break">in Blender.</span></li>
				<li>Bake the lighting to textures <span class="No-Break">in Blender.</span></li>
				<li>Export <span class="No-Break">the scene.</span></li>
				<li>Render everything <span class="No-Break">in Three.js.</span></li>
			</ol>
			<p>In the following sections, we will discuss each step <span class="No-Break">in detail.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor233"/>Setting up a scene in Blender</h2>
			<p>For this <a id="_idIndexMarker1297"/>example, we’ll create a simple scene in which we’ll bake in <a id="_idIndexMarker1298"/>some lighting. Start a new project, delete the default cube by selecting it and hitting <strong class="bold">x</strong>, and do the same for the default light. Use <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Plane</strong> to add a simple 2D plane to the scene. Press <em class="italic">Tab</em> to go to <strong class="bold">Edit Mode</strong>, select three vertices, and extrude <strong class="source-inline">e</strong> and then <strong class="source-inline">z</strong> to extrude along the <em class="italic">z</em>-axis to get a simple shape <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer299" class="IMG---Figure">
					<img src="image/Figure_13.19_B18726.jpg" alt="Figure 13.19 – Creating a simple room structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.19 – Creating a simple room structure</p>
			<p>Once you’ve got this model, go back to <strong class="bold">Object Mode</strong> (using <em class="italic">Tab</em>), and place a couple of meshes in the room to get something looking similar to what is <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer300" class="IMG---Figure">
					<img src="image/Figure_13.20_B18726.jpg" alt="Figure 13.20 – A full room with some meshes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.20 – A full room with some meshes</p>
			<p>Nothing special <a id="_idIndexMarker1299"/>at this point – just a simple room without any lighting. Before <a id="_idIndexMarker1300"/>we move on to adding some lighting, change the colors of the objects a bit. Therefore, in Blender, go to <strong class="bold">Material Properties</strong>, create a new material for each mesh, and set a color. The result will look something similar <span class="No-Break">to this:</span></p>
			<div>
				<div id="_idContainer301" class="IMG---Figure">
					<img src="image/Figure_13.21_B18726.jpg" alt="Figure 13.21 – Adding colors to the different objects in the scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.21 – Adding colors to the different objects in the scene</p>
			<p>Next, we’ll <a id="_idIndexMarker1301"/>add some <a id="_idIndexMarker1302"/><span class="No-Break">nice lighting.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/>Adding lighting to the scene</h2>
			<p>For the lighting in <a id="_idIndexMarker1303"/>this scene, we’ll add nice HDRI-based lighting. With <a id="_idIndexMarker1304"/>HDRI lighting, we don’t have a single source of light but provide an image that’ll be used as the source of light for the scene. For this example, we’ve downloaded an HDRI image from <span class="No-Break">here: </span><a href="https://polyhaven.com/a/thatch_chapel"><span class="No-Break">https://polyhaven.com/a/thatch_chapel</span></a><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer302" class="IMG---Figure">
					<img src="image/Figure_13.22_B18726.jpg" alt="Figure 13.22 – Downloading an HDRI from Poly Haven"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.22 – Downloading an HDRI from Poly Haven</p>
			<p>After downloading, we <a id="_idIndexMarker1305"/>have a large image file that we can use in Blender. For <a id="_idIndexMarker1306"/>this, open up the <strong class="bold">World</strong> tab from the <strong class="bold">Properties Editor</strong> panel, select the <strong class="bold">Surface</strong> dropdown, and select <strong class="bold">Background</strong>. Below this, you’ll find the <strong class="bold">Color</strong> option, click this, and select <span class="No-Break"><strong class="bold">Environment Texture</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer303" class="IMG---Figure">
					<img src="image/Figure_13.23_B18726.jpg" alt="Figure 13.23 – Adding an environment texture to the world"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.23 – Adding an environment texture to the world</p>
			<p>Next, click on <strong class="bold">Open</strong>, browse <a id="_idIndexMarker1307"/>to where you downloaded the image, and select <a id="_idIndexMarker1308"/>that location. At this point, we can just render the scene and see what the HDRI map provides <span class="No-Break">as lighting:</span></p>
			<div>
				<div id="_idContainer304" class="IMG---Figure">
					<img src="image/Figure_13.24_B18726.jpg" alt="Figure 13.24 – Rendering the scene to check out the HDRI lighting"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.24 – Rendering the scene to check out the HDRI lighting</p>
			<p>As you can see here, the scene already looks quite nice without us having to position separate lights. We <a id="_idIndexMarker1309"/>now have some nice soft shadows on the walls, the objects <a id="_idIndexMarker1310"/>seem to be lit from multiple angles, and the objects look nice. To use the information from the lights as a static lightmap, we need to bake the lighting onto a texture and map that texture to the objects <span class="No-Break">in Three.js.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/>Baking the light textures</h2>
			<p>To bake the <a id="_idIndexMarker1311"/>lights, first, we have to create a texture to hold this information. Select the cube (or any of the other objects you want to bake the lighting for). Go to the <strong class="bold">Shading</strong> view, and in <strong class="bold">Node Editor</strong> at the bottom of the screen, add a new <strong class="bold">Image Texture</strong> item: <strong class="bold">Add</strong> |<strong class="bold"> Texture</strong> | <strong class="bold">Image Texture</strong>. The default values should be good <span class="No-Break">to use:</span></p>
			<div>
				<div id="_idContainer305" class="IMG---Figure">
					<img src="image/Figure_13.25_B18726.jpg" alt="Figure 13.25 – Adding a texture image to hold the baked lightmap"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.25 – Adding a texture image to hold the baked lightmap</p>
			<p>Next, click on the <strong class="bold">New</strong> button <a id="_idIndexMarker1312"/>of the node you just added, and select the size and name of <span class="No-Break">the texture:</span></p>
			<div>
				<div id="_idContainer306" class="IMG---Figure">
					<img src="image/Figure_13.26_B18726.jpg" alt="Figure 13.26 – Adding a new image to be used with the texture image"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.26 – Adding a new image to be used with the texture image</p>
			<p>Now, go to the <strong class="bold">Render</strong> tab <a id="_idIndexMarker1313"/>of the <strong class="bold">Properties Editor</strong> panel and set the <span class="No-Break">following properties:</span></p>
			<ul>
				<li><strong class="bold">Render </strong><span class="No-Break"><strong class="bold">Engine</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="bold">Cycles</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Sampling</strong> | <strong class="bold">Render</strong>: Set <strong class="bold">Max Samples</strong> to <strong class="source-inline">512</strong> or rendering the lightmap will take a very <span class="No-Break">long time.</span></li>
				<li>In the <strong class="bold">Bake</strong> menu, select <strong class="bold">Diffuse</strong> from the <strong class="bold">Bake Type</strong> menu, and in the <strong class="bold">Influence</strong> section, select <strong class="bold">Direct</strong> and <strong class="bold">Indirect</strong>. This will just render the influence of our <span class="No-Break">environment lighting.</span></li>
			</ul>
			<p>Now, you can <a id="_idIndexMarker1314"/>click <strong class="bold">Bake</strong> and Blender will render the lightmap for the selected object to <span class="No-Break">the texture:</span></p>
			<div>
				<div id="_idContainer307" class="IMG---Figure">
					<img src="image/Figure_13.27_B18726.jpg" alt="Figure 13.27 – Rendered lightmap for the cube"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.27 – Rendered lightmap for the cube</p>
			<p>And that’s it. As you can see in the image viewer on the bottom left, we’ve now got a nice-looking rendered lightmap for our cube. You can export this image as a standalone texture by clicking on the hamburger menu in the <span class="No-Break">image viewer:</span></p>
			<div>
				<div id="_idContainer308" class="IMG---Figure">
					<img src="image/Figure_13.28_B18726.jpg" alt="Figure 13.28 – Exporting the lightmap to an external file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.28 – Exporting the lightmap to an external file</p>
			<p>You can now repeat this for the other meshes. Before doing this for the box though, we quickly need to <a id="_idIndexMarker1315"/>fix the UV mapping. We need to do this since we extruded a couple of vertices to make the room-like structure, and Blender needs to know how to map them correctly. Without going into too much detail here, we can have Blender make a proposal on how to create the UV mapping. Click on the <strong class="bold">UV Editing</strong> menu at the top, select <strong class="bold">Plane</strong>, go to <strong class="bold">Edit Mode</strong>, and from the <strong class="bold">UV</strong> menu, select <strong class="bold">UV</strong> | <strong class="bold">Unwrap</strong> | <span class="No-Break"><strong class="bold">Smart Unwrap</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer309" class="IMG---Figure">
					<img src="image/Figure_13.29_B18726.jpg" alt="Figure 13.29 – Fixing the UVs for the room mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.29 – Fixing the UVs for the room mesh</p>
			<p>This will make <a id="_idIndexMarker1316"/>sure that a lightmap will be generated for all sides of the room. Now, repeat this for all the meshes, and you will have the lightmaps for this specific scene. Once you’ve exported all the lightmaps, we can export the scene itself and after that, render it using these created lightmaps <span class="No-Break">in Three.js:</span></p>
			<div>
				<div id="_idContainer310" class="IMG---Figure">
					<img src="image/Figure_13.30_B18726.jpg" alt="Figure 13.30 – All the created lightmaps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.30 – All the created lightmaps</p>
			<p>Now that we’ve baked <a id="_idIndexMarker1317"/>all our maps, the next step is exporting everything from Blender and importing the scene and maps <span class="No-Break">in Three.js.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor236"/>Exporting the scene and importing it into Blender</h2>
			<p>We’ve already <a id="_idIndexMarker1318"/>seen in the <em class="italic">Exporting a static scene from Blender and importing it into Three.js</em> section how to export a scene from Blender to be <a id="_idIndexMarker1319"/>used in Three.js, so we’ll repeat these <a id="_idIndexMarker1320"/>same steps. Click on <strong class="bold">File</strong> | <strong class="bold">Export</strong> | <strong class="bold">glTF 2.0</strong>. We can <a id="_idIndexMarker1321"/>use the defaults and since we don’t have an animation, we can disable the animation checkbox. After exporting it, we can import the scene into Three.js. If we don’t apply the texture (and use our own default lights), the scene will look something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer311" class="IMG---Figure">
					<img src="image/Figure_13.31_B18726.jpg" alt="Figure 13.31 – The Three.js scene rendered with default lights without the lightmaps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.31 – The Three.js scene rendered with default lights without the lightmaps</p>
			<p>We’ve already <a id="_idIndexMarker1322"/>seen how to load and apply a lightmap in <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>. The <a id="_idIndexMarker1323"/>following code fragment <a id="_idIndexMarker1324"/>shows how to load the lightmap textures for all the <a id="_idIndexMarker1325"/>lightmaps we’ve exported <span class="No-Break">from Blender:</span></p>
			<pre class="source-code">
const cubeLightMap = new THREE.TextureLoader().load
  ('/assets/models/blender-lightmaps/cube-light-map.png')
const cylinderLightMap = new THREE.TextureLoader().load
('/assets/models/blender-lightmaps/cylinder-light-map.png')
const roomLightMap = new THREE.TextureLoader().load
  ('/assets/models/blender-lightmaps/room-light-map.png')
const torusLightMap = new THREE.TextureLoader().load
  ('/assets/models/blender-lightmaps/torus-light-map.png')
const addLightMap = (mesh, lightMap) =&gt; {
  const uv1 = mesh.geometry.getAttribute('uv')
  const uv2 = uv1.clone()
  mesh.geometry.setAttribute('uv2', uv2)
  mesh.material.lightMap = lightMap
  lightMap.flipY = false
}
const modelAsync = () =&gt; {
  const loader = new GLTFLoader()
  return loader.loadAsync('/assets/models/blender-
    lightmaps/light-map.glb').then((structure) =&gt; {
    const cubeMesh = structure.scene.
      getObjectByName('Cube')
    const cylinderMesh = structure.scene.
      getObjectByName('Cylinder')
    const torusMesh = structure.scene.
      getObjectByName('Torus')
    const roomMesh = structure.scene.
      getObjectByName('Plane')
    addLightMap(cubeMesh, cubeLightMap)
    addLightMap(cylinderMesh, cylinderLightMap)
    addLightMap(torusMesh, torusLightMap)
    addLightMap(roomMesh, roomLightMap)
    return structure.scene
  })
}</pre>
			<p>Now, when we look <a id="_idIndexMarker1326"/>at the same scene (<strong class="source-inline">import-from-blender-lightmap.html</strong>), we have <a id="_idIndexMarker1327"/>a scene with very nice lighting, even though we <a id="_idIndexMarker1328"/>didn’t provide <a id="_idIndexMarker1329"/>any light sources ourselves and used the baked lights from <span class="No-Break">Blender instead:</span></p>
			<div>
				<div id="_idContainer312" class="IMG---Figure">
					<img src="image/Figure_13.31_B18726.jpg" alt="Figure 13.32 – The same scene but with the baked lightmaps applied from Blender"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.32 – The same scene but with the baked lightmaps applied from Blender</p>
			<p>If we export the lightmaps, we already implicitly get information about the shadows as well since, at <a id="_idIndexMarker1330"/>those locations, there is, of course, less light. We <a id="_idIndexMarker1331"/>can also get more detailed shadow maps <a id="_idIndexMarker1332"/>from Blender. For instance, we can generate ambient <a id="_idIndexMarker1333"/>occlusion maps so we don’t have to create those <span class="No-Break">at runtime.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor237"/>Baking an ambient occlusion map in Blender</h2>
			<p>If we go back <a id="_idIndexMarker1334"/>to the scene we already have, we can <a id="_idIndexMarker1335"/>also bake an ambient occlusion map. The approach for this is the same as that used for baking <span class="No-Break">a lightmap:</span></p>
			<ol>
				<li value="1">Set up <span class="No-Break">a scene.</span></li>
				<li>Add all the lights and objects that <span class="No-Break">cast shadows.</span></li>
				<li>Make sure you’ve got an empty <strong class="bold">Image Texture</strong> in <strong class="bold">Shader Editor</strong>, to which we can bake <span class="No-Break">the shadows.</span></li>
				<li>Select the relevant baking options and render the shadows to <span class="No-Break">the image.</span></li>
			</ol>
			<p>Since the first three steps are the same as those for lightmaps, we’ll skip those and look at the render settings needed to render the <span class="No-Break">shadow maps:</span></p>
			<div>
				<div id="_idContainer313" class="IMG---Figure">
					<img src="image/Figure_13.33_B18726.jpg" alt="Figure 13.33 – Render settings to bake an ambient occlusion map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.33 – Render settings to bake an ambient occlusion map</p>
			<p>As you can see, you <a id="_idIndexMarker1336"/>only have to change the <a id="_idIndexMarker1337"/>dropdown for <strong class="bold">Bake Type</strong> to <strong class="bold">Ambient Occlusion</strong>. Now, you can select the mesh for which you want to bake these shadows and click on the <strong class="bold">Bake</strong> button. For the room mesh, the result looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer314" class="IMG---Figure">
					<img src="image/Figure_13.34_B18726.jpg" alt="Figure 13.34 – An ambient occlusion map as a texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.34 – An ambient occlusion map as a texture</p>
			<p>Blender provides a number of other bake types that you can use to get good-looking textures (especially for the static parts of your scene), which can greatly improve the <span class="No-Break">rendering performance.</span></p>
			<p>There is <a id="_idIndexMarker1338"/>one more subject we’re going to look <a id="_idIndexMarker1339"/>at for this section on Blender, and that is how to use Blender to change the UV mapping of <span class="No-Break">a texture.</span></p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor238"/>Custom UV modeling in Blender</h1>
			<p>In this section, we’re <a id="_idIndexMarker1340"/>going to start with a new empty Blender scene, and <a id="_idIndexMarker1341"/>we’ll use the default cube to experiment with. To get a good overview of how UV mapping works, you can use something called a UV grid, which looks something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer315" class="IMG---Figure">
					<img src="image/Figure_13.35_B18726.jpg" alt="Figure 13.35 – A sample UV texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.35 – A sample UV texture</p>
			<p>When you apply this as the texture of the default cube, you’ll see how the various vertices of a mesh <a id="_idIndexMarker1342"/>map to a specific location on the texture. To use this, the <a id="_idIndexMarker1343"/>first thing we need to do is define this texture. You can easily do this from <strong class="bold">Material Properties</strong> in the <strong class="bold">Properties</strong> view on the right of the screen. Click on the yellow dot before the <strong class="bold">Base Color</strong> property and select <strong class="bold">Image Texture</strong>. This allows you to browse for an image to use <span class="No-Break">as texture:</span></p>
			<div>
				<div id="_idContainer316" class="IMG---Figure">
					<img src="image/Figure_13.36_B18726.jpg" alt="Figure 13.36 – Adding a texture to a mesh in Blender"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.36 – Adding a texture to a mesh in Blender</p>
			<p>You can already see in the main viewport how this texture is applied to the cube. If we export this mesh <a id="_idIndexMarker1344"/>including the material into Three.js and render it, we will see <a id="_idIndexMarker1345"/>exactly the same mapping because Three.js will use the UV mapping defined by <span class="No-Break">Blender (</span><span class="No-Break"><strong class="source-inline">import-from-blender-uv-map-1.html</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer317" class="IMG---Figure">
					<img src="image/Figure_13.37_B18726.jpg" alt="Figure 13.37 – A box with a UV grid rendered in Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.37 – A box with a UV grid rendered in Three.js</p>
			<p>Now, let’s switch back to Blender, and open up the <strong class="bold">UV Editing</strong> tab. Go to <strong class="bold">Edit Mode</strong> (using the <em class="italic">Tab</em> key) on <a id="_idIndexMarker1346"/>the right-hand side of the screen and select the four <a id="_idIndexMarker1347"/>front-facing vertices. When you’ve selected these, you’ll see the position of these four vertices on the left-hand side of the screen <span class="No-Break">as well.</span></p>
			<div>
				<div id="_idContainer318" class="IMG---Figure">
					<img src="image/Figure_13.38_B18726.jpg" alt="Figure 13.38 – The UV editor showing the mapping of the four pixels that make up the front face of the cube"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.38 – The UV editor showing the mapping of the four pixels that make up the front face of the cube</p>
			<p>In the UV editor, you <a id="_idIndexMarker1348"/>can now grab (<em class="italic">g</em>) the vertices and move them to a different <a id="_idIndexMarker1349"/>position on the texture. For instance, you can move them to the edges of the texture <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer319" class="IMG---Figure">
					<img src="image/Figure_13.39_B18726.jpg" alt="Figure 13.39 – One side mapped to the complete texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.39 – One side mapped to the complete texture</p>
			<p>Moving the vertices <a id="_idIndexMarker1350"/>will result in a <a id="_idIndexMarker1351"/>cube that looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer320" class="IMG---Figure">
					<img src="image/Figure_13.40_B18726.jpg" alt="Figure 13.40 – The Blender render of the cube with custom UV mapping"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.40 – The Blender render of the cube with custom UV mapping</p>
			<p>And, of course, this is <a id="_idIndexMarker1352"/>also directly shown in Three.js as well when we <a id="_idIndexMarker1353"/>export and import this <span class="No-Break">minimal model:</span></p>
			<div>
				<div id="_idContainer321" class="IMG---Figure">
					<img src="image/Figure_13.41_B18726.jpg" alt="Figure 13.41 – The Three.js view of the cube with custom UV mapping"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.41 – The Three.js view of the cube with custom UV mapping</p>
			<p>Using this approach, it is <a id="_idIndexMarker1354"/>very easy to define exactly which parts of your <a id="_idIndexMarker1355"/>mesh should be mapped to which part of <span class="No-Break">a texture.</span></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor239"/>Summary</h1>
			<p>In this chapter, we explored how you can work together with Blender and Three.js. We showed how you can use the glTF format as the standard format to exchange data between Three.js and Blender. This works great for meshes, animations, and most textures. However, for advanced texture properties, you will probably need some fine-tuning in either Three.js or Blender. We also showed how you can bake specific textures such as lightmaps and ambient occlusion maps in Blender and use them in Three.js. This allows you to render this information once in Blender, import it into Three.js, and create great shadows, lights, and ambient occlusion without the heavy calculations that Three.js would have to do normally. Note that this, of course, will only work for scenes where the lighting is static, and the geometries and meshes don’t move around or change shape. Often, you can use this for the static parts of your scene. Finally, we looked a bit at how UV mapping works, where vertices are mapped to a position on a texture, and how you can use Blender to play around with this mapping. Once again, by using glTF as the exchange format, all the information from Blender can be easily used <span class="No-Break">in Three.js.</span></p>
			<p>We’re now reaching the end of this book. In the last chapter, we’re going to look at two additional subjects – how can you use Three.js together with React.js, and we’ll have a quick look at Three.js’s support for VR <span class="No-Break">and AR.</span></p>
		</div>
	</body></html>