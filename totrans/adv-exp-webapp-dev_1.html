<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Foundations"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Foundations</h1></div></div></div><p>
<span class="emphasis"><em>Advanced Express Web Application Development</em></span> will guide you through the process of building a nontrivial, single-page application using <span class="strong"><strong>Express</strong></span>.</p><p>Express<a id="id0" class="indexterm"/> is a fast, unopinionated, minimalist, and flexible web application framework for <span class="strong"><strong>Node.js</strong></span>
<a id="id1" class="indexterm"/> written by TJ. Holowaychuk. It was inspired by <span class="strong"><strong>Sinatra</strong></span>
<a id="id2" class="indexterm"/>, a web framework for Ruby. Express provides a robust set of features for building single, multi-page, and hybrid web applications and has quickly become the most popular web development framework for node. Express is built on top of an extensible HTTP server framework—also developed by TJ. Holowaychuk—called <span class="strong"><strong>Connect</strong></span>. Connect<a id="id3" class="indexterm"/> provides a set of high performance plugins known as middleware. Connect includes over 20 commonly used middleware, including a logger, session support, cookie parser, and more.</p><p>This book will guide you through the process of building a single-page application called Vision; a dashboard for software development projects that integrates with GitHub to give you a single-screen snapshot of your software development projects issues and commits. This project will allow us to demonstrate the advanced features Express has to offer and will give us the opportunity to explore the kind of issues encountered in a commercial development and production deployment of a node/Express application.</p><div class="section" title="Feature set"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Feature set</h1></div></div></div><p>We will now<a id="id4" class="indexterm"/> begin the process of building a Vision application. We will start from scratch with a test-first approach. Along the way, we will explore some best practices and offer tips for when developing web applications with node and Express.</p><p>The Vision application will include the following features:</p><div class="informalexample"><pre class="programlisting">Feature: Heartbeat
As an administrator
I want to visit an endpoint
So that I can confirm the server is responding

Feature: List projects
As a vision user
I want to see a list of projects
So that I can select a project I want to monitor

Feature: Create project
As a vision user
I want to create a new project
So that I can monitor the activity of multiple repositories

Feature: Get a project
As a vision user
I want to get a project
So that I can monitor the activity of selected repositories

Feature: Edit a project
As a vision user
I want to update a project
So that I can change the repositories I monitor

Feature: Delete a project
As a vision user
I want to delete a project
So that I can remove projects no longer in use

Feature: List repositories
As a vision user
I want to see a list of all repositories for a GitHub account
So that I can select and monitor repositories for my project

Feature: List issues
As a vision user
I want to see a list of multiple repository issues in real time
So that I can review and fix issues

Feature: List commits
As a vision user
I want to see a list of multiple repository commits in real time
So that I can review those commits

Feature: Master Page
As a vision user  
I want the vision application served as a single page
So that I can spend less time waiting for page loads

Feature: Authentication
As a vision user
I want to be able to authenticate via Github
So that I can view project activity</pre></div><p>The following screenshot is of our <a id="id5" class="indexterm"/>Vision application; it contains a list of projects, repositories, commits, and issues. The upper-right corner has a login link that we will use for authentication:</p><div class="mediaobject"><img src="graphics/2494OS_01_1.jpg" alt="Feature set"/></div></div></div>
<div class="section" title="Installation"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Installation</h1></div></div></div><p>If you do not have node installed, visit: <a class="ulink" href="http://nodejs.org/download/">http://nodejs.org/download/</a>.</p><p>There is also an installation guide on the node GitHub repository wiki if you prefer not to or cannot use an installer: <a class="ulink" href="https://github.com/joyent/node/wiki/Installation">https://github.com/joyent/node/wiki/Installation</a>.</p><p>Let's install <a id="id6" class="indexterm"/>Express globally:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install -g express</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>Download the source code for this book here: <a class="ulink" href="https://github.com/AndrewKeig/advanced-express-application-development.">https://github.com/AndrewKeig/advanced-express-application-development</a>.
</p></div></div><p>If you have downloaded the source code, install its dependencies by running this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install</strong></span>
</pre></div></div>
<div class="section" title="package.json"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>package.json</h1></div></div></div><p>Let's start by creating a root project <a id="id7" class="indexterm"/>folder called <code class="literal">vision</code> and add a <code class="literal">package.json</code> file to it: <code class="literal">./package.json</code>:</p><div class="informalexample"><pre class="programlisting">{
  "name": "chapter-1",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node app.js"
  }
  "dependencies": {
    "express": "3.x"
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div>
<div class="section" title="Testing Express with Mocha and SuperTest"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Testing Express with Mocha and SuperTest</h1></div></div></div><p>Now that we have<a id="id8" class="indexterm"/> Express <a id="id9" class="indexterm"/>installed and our <code class="literal">package.json</code> file in place, <a id="id10" class="indexterm"/>we can <a id="id11" class="indexterm"/>begin to drive out our application with a test-first approach. We will now install two modules to assist us: <code class="literal">mocha</code> and <code class="literal">supertest</code>.</p><p>Mocha is a <a id="id12" class="indexterm"/>testing framework for node; it's flexible, has good async <a id="id13" class="indexterm"/>support, and allows you to run tests in both a TDD and BDD style. It can also be used on both the client and server side. Let's install Mocha with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install -g mocha –-save-dev</strong></span>
</pre></div><p>SuperTest is an <a id="id14" class="indexterm"/>integration testing framework that will allow <a id="id15" class="indexterm"/>us to easily write tests against a RESTful HTTP server. Let's install SuperTest:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install supertest –-save-dev</strong></span>
</pre></div></div>
<div class="section" title="Feature: Heartbeat"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Feature: Heartbeat</h1></div></div></div><div class="informalexample"><pre class="programlisting">As an administrator
I want to visit an endpoint
So that I can confirm the server is responding</pre></div><p>Let's add a test to <code class="literal">./test/heartbeat.js</code> for our <code class="literal">Heartbeat</code> feature. This resource will get a<a id="id16" class="indexterm"/> status from the route <code class="literal">/heartbeat</code> and return a <code class="literal">200 Ok</code> status code. Let's write our first integration test using Mocha and SuperTest. First off, create a folder named <code class="literal">/test</code> inside your <code class="literal">vision</code> folder.</p><p>Our test describes <code class="literal">heartbeat</code>; it expects the response to have a <code class="literal">JSON</code> content type and a status code equal to <code class="literal">200 Ok</code>.</p><div class="informalexample"><pre class="programlisting">var app = require('../app')
, request = require('supertest');

describe('vision heartbeat api', function(){
  describe('when requesting resource /heartbeat', function(){
    it('should respond with 200', function(done){
      request(app)
      .get('/heartbeat')
      .expect('Content-Type', /json/)
      .expect(200, done);
    });
  });
});</pre></div><p>Let's implement the <code class="literal">Heartbeat</code> feature; we start by creating a simple Express server, <code class="literal">./lib/express/index.js</code>. We include the <code class="literal">express</code> and <code class="literal">http</code> modules and create an Express application. We then add an application setting via <code class="literal">app.set</code> called <code class="literal">port</code> and set it to <code class="literal">3000</code>. We define a <code class="literal">/heartbeat </code>route via <code class="literal">app.get </code>with<code class="literal"> </code>which we pass a request handler, <code class="literal">function</code>, that takes two parameters: <code class="literal">req</code> (request) and <code class="literal">res</code> (response). We use the response object to return a JSON response. We create an HTTP server with <code class="literal">http.createServer</code> by passing our Express application to it; we listen on port <code class="literal">3000</code> as defined in our application setting called <code class="literal">port</code>. We then export the application with <code class="literal">module.exports</code>; exporting the application allows us to test it.</p><div class="informalexample"><pre class="programlisting">var express = require('express')
  , http = require('http')
  , app = express();

app.set('port', 3000);

app.get('/heartbeat', function(req, res){
  res.json(200, 'OK')
});

http.createServer(app).listen(app.get('port'));
module.exports = app;</pre></div><p>We now create <code class="literal">./app.js</code> in the root of our project and export the <code class="literal">express</code> module:</p><div class="informalexample"><pre class="programlisting">module.exports = require('./lib/express');</pre></div><p>To run our test, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mocha</strong></span>
</pre></div><p>You should then receive the response:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>1 tests complete (14 ms)</strong></span>
</pre></div><p>If successful, try running the application by executing this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm start</strong></span>
</pre></div><p>With the app <a id="id17" class="indexterm"/>running, run the following <code class="literal">curl</code> command in a new terminal and you can see our <code class="literal">heartbeat</code> JSON response return a <code class="literal">200 Ok</code> status code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -i http://127.0.0.1:3000/heartbeat</strong></span>

<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>X-Powered-By: Express</strong></span>
<span class="strong"><strong>Content-Type: application/json; charset=utf-8</strong></span>
<span class="strong"><strong>Content-Length: 4</strong></span>
<span class="strong"><strong>Date: Fri, 14 Jun 2013 08:28:50 GMT</strong></span>
<span class="strong"><strong>Connection: keep-alive</strong></span>
</pre></div></div>
<div class="section" title="Continuous testing with Mocha"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Continuous testing with Mocha</h1></div></div></div><p>One of the great things about working<a id="id18" class="indexterm"/> with a dynamic language and one of the things that has drawn me to node is the ability to easily do <span class="strong"><strong>Test-Driven Development</strong></span>
<a id="id19" class="indexterm"/> and continuous testing. Simply run Mocha with the <code class="literal">-w</code> watch switch and Mocha will respond when changes to our codebase are made, and will automatically rerun the tests:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mocha -w</strong></span>
</pre></div></div>
<div class="section" title="Code coverage with Mocha and JSCoverage"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Code coverage with Mocha and JSCoverage</h1></div></div></div><p>Mocha is able to generate a code coverage report with a little help from <span class="strong"><strong>JSCoverage</strong></span>
<a id="id20" class="indexterm"/>. Install JSCoverage <a id="id21" class="indexterm"/>for your environment from <a class="ulink" href="http://siliconforks.com/jscoverage/">http://siliconforks.com/jscoverage/</a>. JSCoverage will parse source code and generate an<a id="id22" class="indexterm"/> instrumented version; this enables mocha to execute this generated code and <a id="id23" class="indexterm"/>create a report. We will need to update <code class="literal">./app.js</code>.</p><div class="informalexample"><pre class="programlisting">module.exports = <span class="strong"><strong>(process.env['NODE_ENV'] === "COVERAGE")</strong></span>
<span class="strong"><strong> ? require('./lib-cov/express')</strong></span>
 : require('./lib/express');</pre></div><p>JSCoverage <a id="id24" class="indexterm"/>takes as arguments an input directory, and an output <a id="id25" class="indexterm"/>directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jscoverage lib lib-cov</strong></span>
</pre></div><p>Depending on your version of JSCoverage, you may need to add the <code class="literal">–no-highlight</code> switch:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jscoverage lib lib-cov --no-highlight</strong></span>
</pre></div><p>The following command will generate the coverage report, as shown in the following screenshot:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>NODE_ENV=COVERAGE mocha -R html-cov &gt; coverage.html</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/2494OS_01_2.jpg" alt="Code coverage with Mocha and JSCoverage"/></div></div>
<div class="section" title="Configuring Express with Nconf"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Configuring Express with Nconf</h1></div></div></div><p>
<span class="strong"><strong>Nconf</strong></span>
<a id="id26" class="indexterm"/> is a configuration tool that we will use to create hierarchical/environment configuration files for our application. Let's install Nconf:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install nconf --save</strong></span>
</pre></div><p>The first thing we <a id="id27" class="indexterm"/>will do is to move the following hardcoded port number <a id="id28" class="indexterm"/>from our Express application into our configuration:</p><div class="informalexample"><pre class="programlisting">app.set('port', 3000);</pre></div><p>Let's create the module <code class="literal">./lib/configuration/index.js</code>, which will allow us to to read configuration data from JSON files. We import the <code class="literal">nconf</code> module and define a constructor function, <code class="literal">Config</code>. We then load a configuration file based on the current environment and load the default configuration that holds non-environmental configuration data. We also define a function <code class="literal">get(key)</code>, which accepts a key and returns a value. We will use this function to read configuration data:</p><div class="informalexample"><pre class="programlisting">var nconf = require('nconf');

function Config(){
  nconf.argv().env("_");
  var environment = nconf.get("NODE:ENV") || "development";
  nconf.file(environment, "config/" + environment + ".json");
  nconf.file("default", "config/default.json");
}

Config.prototype.get = function(key) {
  return nconf.get(key);
};

module.exports = new Config();</pre></div><p>Let's write some configuration for our application. Add the following default configuration to <code class="literal">./config/default.json</code>; this will be shared amongst all environments:</p><div class="informalexample"><pre class="programlisting">{
  "application": {
    "name": "vision"
  }
}</pre></div><p>Now add the following configuration to the development, test, and coverage config files<a id="id29" class="indexterm"/>: <code class="literal">./config/development.json</code>, <code class="literal">./config/test.json</code>, and <code class="literal">./config/coverage.json</code>.</p><div class="informalexample"><pre class="programlisting">{
  "express": {
    "port": 3000
  }
}</pre></div><p>Let's change our Express server <code class="literal">./lib/express/index.js</code> so that it reads <code class="literal">express:port</code> from configuration:</p><div class="informalexample"><pre class="programlisting">var express = require('express')
  , http = require('http')
<span class="strong"><strong>  , config = require('../configuration')</strong></span>
  , app = express();

app.set('port', <span class="strong"><strong>config.get("express:port")</strong></span>);

app.get('/hearbeat', function(req, res){
  res.json(200, 'OK');
});

http.createServer(app).listen(app.get('port'));

module.exports = app;</pre></div></div>
<div class="section" title="Extracting routes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Extracting routes</h1></div></div></div><p>Express supports multiple<a id="id30" class="indexterm"/> options for application structure. Extracting elements of an Express application into separate files is one option; a good candidate for this is routes.</p><p>Let's extract our route heartbeat into <code class="literal">./lib/routes/heartbeat.js</code>; the following listing simply exports the route as a function called <code class="literal">index</code>:</p><div class="informalexample"><pre class="programlisting">exports.index = function(req, res){
  res.json(200, 'OK');
};</pre></div><p>Let's make a change to our Express server and remove the anonymous function we pass to <code class="literal">app.get</code> for our route and replace it with a call to the function in the following listing. We import the route <code class="literal">heartbeat</code> and pass in a callback function, <code class="literal">heartbeat.index</code>:</p><div class="informalexample"><pre class="programlisting">var express = require('express')
  , http = require('http')
  , config = require('../configuration')
<span class="strong"><strong>  , heartbeat = require('../routes/heartbeat')</strong></span>
  , app = express();

app.set('port', config.get('express:port'));
app.get('/heartbeat', <span class="strong"><strong>heartbeat.index</strong></span>);

http.createServer(app).listen(app.get('port'));
module.exports = app;</pre></div></div>
<div class="section" title="404 handling middleware"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>404 handling middleware</h1></div></div></div><p>In order to <a id="id31" class="indexterm"/>handle a <code class="literal">404 Not Found</code> response, let's add a 404 not found middleware. Let's write a test, <code class="literal">./test/heartbeat.js</code>; the content type returned should be JSON and the status code expected should be <code class="literal">404 Not Found</code>:</p><div class="informalexample"><pre class="programlisting">describe('vision heartbeat api', function(){
  describe('when requesting resource /missing', function(){
    it('should respond with 404', function(done){
      request(app)
      .get('/missing')
      .expect('Content-Type', /json/)
      .expect(404, done);
    })
  });
});</pre></div><p>Now, add the following middleware to <code class="literal">./lib/middleware/notFound.js</code>. Here we export a function called <code class="literal">index</code> and call <code class="literal">res.json</code>, which returns a 404 status code and the message <code class="literal">Not Found</code>. The next parameter is not called as our 404 middleware ends the request by returning a response. Calling next would call the next middleware in our Express stack; we do not have any more middleware due to this, it's customary to add error middleware and 404 middleware as the last middleware in your server:</p><div class="informalexample"><pre class="programlisting">exports.index = function(req, res, next){
    res.json(404, 'Not Found.');
};</pre></div><p>Now add the 404 <a id="id32" class="indexterm"/>not found middleware to <code class="literal">./lib/express/index.js</code>:</p><div class="informalexample"><pre class="programlisting">var express = require('express')
  , http = require('http')
  , config = require('../configuration')
  , heartbeat = require('../routes/heartbeat')
<span class="strong"><strong>  , notFound = require('../middleware/notFound')</strong></span>
  , app = express();

app.set('port', config.get('express:port'));
app.get('/heartbeat', heartbeat.index);
<span class="strong"><strong>app.use(notFound.index);</strong></span>

http.createServer(app).listen(app.get('port'));
module.exports = app;</pre></div></div>
<div class="section" title="Logging middleware"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Logging middleware</h1></div></div></div><p>Express comes with a logger middleware<a id="id33" class="indexterm"/> via Connect; it's very useful for debugging an Express application. Let's add it to our Express server <code class="literal">./lib/express/index.js</code>:</p><div class="informalexample"><pre class="programlisting">var express = require('express')
  , http = require('http')
  , config = require('../configuration')
  , heartbeat = require('../routes/heartbeat')
  , notFound = require('../middleware/notFound')
  , app = express();

app.set('port', config.get('express:port'));
<span class="strong"><strong>app.use(express.logger({ immediate: true, format: 'dev' }));</strong></span>
app.get('/heartbeat', heartbeat.index);
app.use(notFound.index);

http.createServer(app).listen(app.get('port'));
module.exports = app;</pre></div><p>The <code class="literal">immediate</code> option will write a log line on request instead of on response. The <code class="literal">dev</code> option provides concise output colored by the response status. The logger middleware is placed high in the Express stack in order to log all requests.</p></div>
<div class="section" title="Logging with Winston"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Logging with Winston</h1></div></div></div><p>We will now add logging to our application using <a id="id34" class="indexterm"/>
<span class="strong"><strong>Winston</strong></span>; let's install Winston:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install winston --save</strong></span>
</pre></div><p>The 404 middleware <a id="id35" class="indexterm"/>will need to log 404 not found, so let's create a simple <a id="id36" class="indexterm"/>logger module, <code class="literal">./lib/logger/index.js</code>; the details of our logger will be configured with Nconf. We import Winston and the configuration modules. We define our <code class="literal">Logger</code> function, which constructs and returns a file logger—<code class="literal">winston.transports.File</code>—that we configure using values from our <code class="literal">config</code>. We default the loggers maximum size to 1 MB, with a maximum of three rotating files. We instantiate the <code class="literal">Logger</code> function, returning it as a singleton.</p><div class="informalexample"><pre class="programlisting">var winston = require('winston')
 , config = require('../configuration');

function Logger(){
  return winston.add(winston.transports.File, {
    filename: config.get('logger:filename'),
    maxsize: 1048576,
    maxFiles: 3,
    level: config.get('logger:level')
  });
}

module.exports = new Logger();</pre></div><p>Let's add the <code class="literal">Logger</code> configuration details to our config files <code class="literal">./config/development.json</code> and <code class="literal">./config/test.json</code>:</p><div class="informalexample"><pre class="programlisting">{
  "express": {
    "port": 3000
  },
<span class="strong"><strong>  "logger" : {</strong></span>
<span class="strong"><strong>    "filename": "logs/run.log",</strong></span>
<span class="strong"><strong>    "level": "silly",</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Let's alter the <code class="literal">./lib/middleware/notFound.js</code> middleware to log errors. We import our <code class="literal">logger</code> and<a id="id37" class="indexterm"/> log an error message via <code class="literal">logger</code> when a <code class="literal">404 Not Found</code> response <a id="id38" class="indexterm"/>is thrown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var logger = require("../logger");</strong></span>

exports.index = function(req, res, next){
<span class="strong"><strong>  logger.error('Not Found');</strong></span>
  res.json(404, 'Not Found');
};</pre></div></div>
<div class="section" title="Task automation with Grunt"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Task automation with Grunt</h1></div></div></div><p>Grunt <a id="id39" class="indexterm"/>is a task runner and a great way to automate your node projects. Let's add a simple grunt script to our project in order to automate running tests and code coverage. Let's install Grunt and Grunt CLI:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install -g grunt-cli</strong></span>
<span class="strong"><strong>npm install grunt –-save-dev</strong></span>
</pre></div><p>The <code class="literal">grunt-cafe-mocha</code> is a <a id="id40" class="indexterm"/>grunt module for running mocha; this module will <a id="id41" class="indexterm"/>also allow<a id="id42" class="indexterm"/> us to automate code coverage reports:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install grunt-cafe-mocha –-save-dev</strong></span>
</pre></div><p>The <code class="literal">grunt-jscoverage</code> simply <a id="id43" class="indexterm"/>generates an instrumented version of our source code and writes it to <code class="literal">./lib-cov</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install grunt-jscoverage –-save-dev </strong></span>
</pre></div><p>The <code class="literal">grunt-env</code> allows you to<a id="id44" class="indexterm"/> set the current node environment, <code class="literal">NODE_ENV</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install grunt-env  –-save-dev</strong></span>
</pre></div><p>Let's create a grunt file <code class="literal">./gruntfile.js</code>. We load the <code class="literal">grunt</code> modules we just installed, and <code class="literal">grunt.initConfig</code> contains a configuration for each grunt module:</p><div class="informalexample"><pre class="programlisting">module.exports = function(grunt) {
  grunt.loadNpmTasks('grunt-jscoverage');
  grunt.loadNpmTasks('grunt-cafe-mocha');
  grunt.loadNpmTasks('grunt-env');

  grunt.initConfig({
    env: {
      test: { NODE_ENV: 'TEST' },
      coverage: { NODE_ENV: 'COVERAGE' }
    },
    cafemocha: {
      test: {
        src: 'test/*.js',
        options: {
          ui: 'bdd',
          reporter: 'spec',
        },
    },
    coverage: {
      src: 'test/*.js',
      options: {
        ui: 'bdd',
        reporter: 'html-cov',
        coverage: {
          output: 'coverage.html'
        }
      }
    },
  },
  jscoverage: {
    options: {
      inputDirectory: 'lib',
      outputDirectory: 'lib-cov',
      highlight: false
    }
  }
  });
  grunt.registerTask('test', [ 'env:test', 'cafemocha:test' ]);
  grunt.registerTask('coverage', [ 'env:coverage', 'jscoverage', 'cafemocha:coverage' ]);
};</pre></div><p>The <a id="id45" class="indexterm"/>configuration for <code class="literal">cafemocha</code> contains two sections; one for running our tests and one for generating a code coverage report. In order to run our tests from grunt, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grunt test  </strong></span>
</pre></div><p>The following line registers<a id="id46" class="indexterm"/> a task that sets the environment using <code class="literal">env</code> and runs both the <code class="literal">jscoverage</code> and <code class="literal">cafemocha:coverage</code> tasks in sequence:</p><div class="informalexample"><pre class="programlisting">grunt.registerTask('coverage', [ 'env:coverage', 'jscoverage', 'cafemocha:coverage' ]);</pre></div><p>In order to run our coverage from grunt, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grunt coverage</strong></span>
</pre></div><p>This command will generate the coverage report as described earlier.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Summary</h1></div></div></div><p>We have put in place a fairly solid framework for developing our Vision project; we have implemented a simple feature, heartbeat, which when visited, simply informs us whether our Express server is up and running. We have automated various development tasks, such as running tests and creating code coverage reports. We also have in place some logging using Winston. In the next chapter, we will implement a web API.</p></div></body></html>