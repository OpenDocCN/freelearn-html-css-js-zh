["```js\n// An asynchronous \"fetch\" function. We use \"setTimeout()\"\n// to pass \"callback()\" some data after 1 second.\nfunction fetchAsync(callback) {\n    setTimeout(() => {\n        callback({ hello: 'world' });\n    }, 1000);\n}\n\n// The synchronous fetch simply returns the data.\nfunction fetchSync() {\n    return { hello: 'world' };\n}\n\n// A promise for the \"fetchAsync()\" call. We pass the\n// \"resolve\" function as the callback.\nvar asyncPromise = new Promise((resolve, reject) => {\n    fetchAsync(resolve);\n});\n\n// A promise for the \"fetchSync()\" call. This promise\n// is resolved immediately with the return value.\nvar syncPromise = new Promise((resolve, reject) => {\n    resolve(fetchSync());\n});\n\n// Creates a promise that'll wait for two promises\n// to complete before resolving. This allows us\n// to seamlessly mix synchronous and asynchronous\n// values.\nPromise.all([\n    asyncPromise, \n    syncPromise \n]).then((results) => {\n    var [ asyncResult, syncResult ] = results;\n\n    console.log('async', asyncResult);\n    // → async { hello: 'world' }\n\n    console.log('sync', syncResult);\n    // → sync { hello: 'world' }\n});\n```", "```js\n// Eat some CPU cycles...\n// Taken from http://adambom.github.io/parallel.js/\nfunction work(n) {\n    var i = 0;\n    while (++i < n * n) {}\n    return i;\n}\n\n// When we receive a message, we post a message with the\n// id, and the result of performing \"work()\" on \"number\".\naddEventListener('message', (e) => {\n    postMessage({\n        id: e.data.id,\n        result: work(e.data.number)\n    });\n});\n```", "```js\n// This will generate unique IDs. We need them to\n// map tasks executed by web workers to the larger\n// operation that created them.\nfunction* genID() {\n    var id = 0;\n\n    while (true) {\n        yield id++;\n    }\n}\n\n// Creates the global \"id\" generator.\nvar id = genID();\n\n// This object holds the resolver functions from promises,\n// as results comeback from workers, we look them up here,\n// based on ID.\nvar resolvers = {};\n\n// Starts our worker...\nvar worker = new Worker('worker.js');\n\nworker.addEventListener('message', (e) => {\n    // Finds the appropriate resolver function.\n    var resolver = resolvers[e.data.id];\n\n    // Deletes it from the \"resolvers\" object.\n    delete resolvers[e.data.id];\n\n    // Pass the worker data to the promise by calling\n    // the resolver function.\n    resolver(e.data.result);\n});\n\n// This is our helper function. It handles the posting of\n// messages to the worker, and tying the promise to the\n// worker responses.\nfunction square(number) {\n    return new Promise((resolve, reject) => {\n        // The ID that's used to tie together a web \n        // worker response, and a resolver function.\n        var msgId = id.next().value;\n\n        // Stores the resolver so in can be used later, in\n        // the web worker message callback.\n        resolvers[msgId] = resolve;\n\n        // Posts the message - the ID and the number\n        // argument.\n        worker.postMessage({\n            id: msgId,\n            number: number\n        });\n    });\n}\n\nsquare(10).then((result) => {\n    console.log('square(10)', result);\n    // → square(10) 100\n});\n\nsquare(100).then((result) => {\n    console.log('square(100)', result);\n    // → square(100) 10000\n});\n\nsquare(1000).then((result) => {\n    console.log('square(1000)', result);\n    // → square(1000) 1000000\n});\n```", "```js\naddEventListener('message', (e) => {\n\n    // The result we're posting back to the main\n    // thread - it should always contain the\n    // message ID.\n    var result = { id: e.data.id };\n\n    // Based on the \"action\", compute the response\n    // \"value\". The options are leave the text alone,\n    // convert it to upper case, or convert it to\n    // lower case.\n    if (e.data.action === 'echo') {\n        result.value = e.data.value\n    } else if (e.data.action === 'upper') {\n        result.value = e.data.value.toUpperCase();\n    } else if (e.data.action === 'lower') {\n        result.value = e.data.value.toLowerCase();\n    }\n\n    // Simulate a longer-running worker by waiting\n    // 1 second before posting the response back.\n    setTimeout(() => {\n        postMessage(result);\n    }, 1000);\n});\n```", "```js\n// This object holds the resolver functions from promises,\n// as results comeback from workers, we look them up here,\n// based on ID.\nvar resolvers = {};\n\n// Keep the original implementation of \"postMessage()\"\n// so we can call it later on, in our custom \"postMessage()\"\n// implementation.\nvar postMessage = Worker.prototype.postMessage;\n\n// Replace \"postMessage()\" with our custom implementation.\nWorker.prototype.postMessage = function(data) {\n    return new Promise((resolve, reject) => {\n\n        // The ID that's used to tie together a web worker\n        // response, and a resolver function.\n        var msgId = id.next().value;\n\n        // Stores the resolver so in can be used later, in\n        // the web worker message callback.\n        resolvers[msgId] = resolve;\n\n        // Run the original \"Worker.postMessage()\"\n        // implementation, which takes care of actually\n        // posting the message to the worker thread.\n        postMessage.call(this, Object.assign({\n            id: msgId\n        }, data));\n    });\n};\n\n// Starts our worker...\nvar worker = new Worker('worker.js');\n\nworker.addEventListener('message', (e) => {\n\n    // Finds the appropriate resolver function.\n    var resolver = resolvers[e.data.id];\n\n    // Deletes it from the \"resolvers\" object.\n    delete resolvers[e.data.id];\n\n    // Pass the worker data to the promise by calling\n    // the resolver function.\n    resolver(e.data.value);\n});\n\nworker.postMessage({\n    action: 'echo',\n    value: 'Hello World'\n}).then((value) => {\n    console.log('echo', `\"${value}\"`);\n    // → echo \"Hello World\"\n});\n\nworker.postMessage({\n    action: 'upper',\n    value: 'Hello World'\n}).then((value) => {\n    console.log('upper', `\"${value}\"`);\n    // → upper \"HELLO WORLD\"\n});\n\nworker.postMessage({\n    action: 'lower',\n    value: 'Hello World'\n}).then((value) => {\n    console.log('lower', `\"${value}\"`);\n    // → lower \"hello world\"\n});\n```", "```js\n// Returns a map of the input array, by squaring\n// each number in the array.\naddEventListener('message', (e) => {\n    postMessage({\n        id: e.data.id,\n        value: e.data.value.map(v => v * v)\n    });\n});\n```", "```js\nfunction onMessage(e) {\n\n    // Finds the appropriate resolver function.\n    var resolver = resolvers[e.data.id];\n\n    // Deletes it from the \"resolvers\" object.\n    delete resolvers[e.data.id];\n\n    // Pass the worker data to the promise by calling\n    // the resolver function.\n    resolver(e.data.value);\n}\n\n// Starts our workers...\nvar worker1 = new Worker('worker.js'),\n    worker2 = new Worker('worker.js');\n\n// Create some data to process.\nvar array = new Array(50000)\n    .fill(null)\n    .map((v, i) => i);\n\n// Finds the appropriate resolver function to call,\n// when the worker responds with data.\nworker1.addEventListener('message', onMessage);\nworker2.addEventListener('message', onMessage);\n\n// Splits our input data in 2, giving the first half\n// to the first worker, and the second half to the\n// second worker. At this point, we have two promises.\nvar promise1 = worker1.postMessage({\n    value: array.slice(0, Math.floor(array.length / 2))\n});\n\nvar promise2 = worker2.postMessage({\n    value: array.slice(Math.floor(array.length / 2))\n});\n\n// Using \"Promise.all()\" to synchronize workers is\n// much easier than manually trying to reconcile\n// through worker callback functions.\nPromise.all([ promise1, promise2 ]).then((values) => {\n    console.log('reduced', [].concat(...values)\n        .reduce((r, v) => r + v));\n    // → reduced 41665416675000\n});\n```", "```js\n// Eat some CPU cycles...\n// Taken from http://adambom.github.io/parallel.js/\nfunction work(n) {\n    var i = 0;\n    while (++i < n * n) {}\n    return i;\n}\n\n// Post the result of calling \"work()\" back to the\n// main thread.\naddEventListener('message', (e) => {\n    postMessage(work(e.data));\n});\n```", "```js\n// Creates an \"update()\" coroutine that continuously\n// updates the UI as results are generated from the\n// worker.\nvar update = coroutine(function* () {\n    var input;\n\n    while (true) {\n        input = yield;\n        console.log('result', input.data);\n    }\n});\n\n// Creates the worker, and assigns the \"update()\"\n// coroutine as the \"message\" callback handler.\nvar worker = new Worker('worker.js');\nworker.addEventListener('message', update);\n\n// An array of progressively larger numbers.\nvar array = new Array(10)\n    .fill(null)\n    .map((v, i) => i * 10000);\n\n// Iterate over the array, passing each number to the\n// worker as an individual message.\nfor (let item of array) {\n    worker.postMessage(item);\n}\n// → \n// result 1\n// result 100000000\n// result 400000000\n// result 900000000\n// result 1600000000\n// result 2500000000\n// result 3600000000\n// result 4900000000\n// result 6400000000\n// result 8100000000\n```", "```js\naddEventListener('message', (e) => {\n\n    // Get the ports used to send and receive messages.\n    var [ port1, port2 ] = e.ports;\n\n    // Listen for incoming messages of the first port.\n    port1.addEventListener('message', (e) => {\n\n        // Respond on the second port with the result of\n        // calling \"work()\".\n        port2.postMessage(work(e.data));\n    });\n\n    // Starts both ports.\n    port1.start();\n    port2.start();\n});\n```", "```js\n// Starts our workers...\nvar worker1 = new Worker('worker.js');\nvar worker2 = new Worker('worker.js');\n\n// Creates the message channels necessary to communicate\n// between the 2 workers.\nvar channel1 = new MessageChannel();\nvar channel2 = new MessageChannel();\nvar channel3 = new MessageChannel();\n\n// Our \"update()\" coroutine logs worker responses as they're\n// delivered.\nvar update = coroutine(function* () {\n    var input;\n\n    while (true) {\n        input = yield;\n        console.log('result', input.data);\n    }\n});\n\n// Connects \"channel1\" and \"channel2\" using \"worker1\".\nworker1.postMessage(null, [\n    channel1.port2,\n    channel2.port1\n]);\n\n// Connects \"channel2\" and \"channel3\" using \"worker2\".\nworker2.postMessage(null, [\n    channel2.port2,\n    channel3.port1\n]);\n\n// Connects our coroutine \"update()\" to any messages\n// received on \"channel3\".\nchannel3.port2.addEventListener('message', update);\nchannel3.port2.start();\n\n// Our input data - an array of numbers.\nvar array = new Array(25)\n    .fill(null)\n    .map((v, i) => i * 10);\n\n// Posts each array item to \"channel1\".\nfor (let item of array) {\n    channel1.port1.postMessage(item);\n}\n```", "```js\n// An input array of numbers.\nvar array = new Array(2500)\n    .fill(null)\n    .map((v, i) => i);\n\n// Creates a new parallel job. No workers have been\n// created at this point - we only pass the constructor\n// the data we're working with.\nvar job = new Parallel(array);\n\n// Start a timer for our \"spawn()\" job.\nconsole.time(`${array.length} items`);\n\n// Creates a new web worker, passing it our data and\n// this function. We're slowly mapping each number in\n// the array to it's square.\njob.spawn((coll) => {\n    return coll.map((n) => {\n        var i = 0;\n        while (++i < n * n) {}\n        return i;\n    });\n\n// The return value of \"spawn()\" is a thenable. Meaning\n// we can assign a \"then()\" callback function, just as\n// though a promise were returned.\n}).then((results) => {\n    console.timeEnd(`${array.length} items`);\n    // → 2500 items: 3408.078ms\n});\n```", "```js\n// An input array of numbers.\nvar array = new Array(2500)\n    .fill(null)\n    .map((v, i) => i);\n\n// Creates a new parallel job. No workers have been\n// created at this point - we only pass the constructor\n// the data we're working with.\nvar job1 = new Parallel(array);\n\n// Start a timer for our \"spawn()\" job.\nconsole.time('job1');\n\n// The problem here is that Parallel.js will\n// create a new worker for every array element, resulting\n// in parallel slowdown.\njob1.map((n) => {\n    var i = 0;\n    while (++i < n * n) {}\n    return i;\n}).reduce((pair) => {\n\n    // Reduces the array items to a sum.\n    return pair[0] + pair[1];\n}).then((data) => {\n    console.log('job1 reduced', data);\n    // → job1 reduced 5205208751\n\n    console.timeEnd('job1');\n    // → job1: 59443.863ms\n});\n```", "```js\n// A faster implementation.\nvar job2 = new Parallel(array);\n\nconsole.time('job2');\n\n// Before mapping the array, split the array into chunks\n// of smaller arrays. This way, each Parallel.js worker is\n// processing an array instead of an array item. This avoids\n// sending thousands of web worker messages.\njob2.spawn((data) => {\n    var index = 0,\n        size = 1000,\n        results = [];\n\n    while (true) {\n        let chunk = data.slice(index, index + size);\n\n        if (chunk.length) {\n            results.push(chunk);\n            index += size;\n        } else {\n            return results;\n        }\n    }\n}).map((array) => {\n\n    // Returns a mapping of the array chunk.\n    return array.map((n) => {\n        var i = 0;\n        while (++i < n * n) {}\n        return i;\n    });\n}).reduce((pair) => {\n\n    // Reduces array chunks, or numbers, to a sum.\n    return (Array.isArray(pair[0]) ?\n            pair[0].reduce((r, v) => r + v) : pair[0]) +\n        (Array.isArray(pair[1]) ?\n            pair[1].reduce((r, v) => r + v) : pair[1]);\n}).then((data) => {\n    console.log('job2 reduced', data);\n    // → job2 reduced 5205208751\n\n    console.timeEnd('job2');\n    // → job2: 2723.661ms\n});\n```", "```js\n// Represents a \"pool\" of web worker threads, hidden behind\n// the interface of a single web worker interface.\nfunction WorkerPool(script) {\n\n    // The level of concurrency, or, the number of web\n    // workers to create. This uses the \n    // \"hardwareConcurrency\" property if it exists.\n    // Otherwise, it defaults to 4, since this is\n    // a reasonable guess at the most common CPU topology.\n    var concurrency = navigator.hardwareConcurrency || 4;\n\n    // The worker instances themselves are stored in a Map,\n    // as keys. We'll see why in a moment.\n    var workers = this.workers = new Map();\n\n    // The queue exists for messages that are posted while,\n    // all workers are busy. So this may never actually be\n    // used.\n    var queue = this.queue = [];\n\n    // Used below for creating the worker instances, and \n    // adding event listeners.\n    var worker;\n\n    for (var i = 0; i < concurrency; i++) {\n        worker = new Worker(script);\n        worker.addEventListener('message', function(e) {\n\n            // We use the \"get()\" method to lookup the\n            // \"resolve()\" function of the promise. The\n            // worker is the key. We call the resolver with\n            // the data returned from the worker, and\n            // can now reset this to null. This is important\n            // because it signifies that the worker is free\n            // to take on more work.\n            workers.get(this)(e.data);\n            workers.set(this, null);\n\n            // If there's queued data, we get the first\n            // \"data\" and \"resolver\" from the queue. Before\n            // we call \"postMessage()\" with the data, we\n            // update the \"workers\" map with the new\n            // \"resolve()\" function.\n            if (queue.length) {\n                var [ data, resolver ] = queue.shift();\n                workers.set(this, resolver);\n                this.postMessage(data);\n            }\n        }.bind(worker));\n\n        // This is the initial setting of the worker, as a\n        // key, in the \"workers\" map. It's value is null,\n        // meaning there's no resolve function, and it can\n        // take on work.\n        this.workers.set(worker, null);\n    }\n}\n```", "```js\nWorkerPool.prototype.postMessage = function(data) {\n\n    // The \"workers\" Map instance, where all the web workers\n    // are stored.\n    var workers = this.workers;\n\n    // The \"queue\" where messages are placed when all the\n    // workers are busy.\n    var queue = this.queue;\n\n    // Try finding an available worker.\n    var worker = this.getWorker();\n\n    // The promise is immediately passed back to the caller,\n    // even if there's no worker available.\n    return new Promise(function(resolve) {\n\n        // If a worker is found, we can update the map,\n        // using the worker as the key, and the \"resolve()\"\n        // function as the value. If there's no worker, then\n        // the message data, along with the \"resolve()\"\n        // function get pushed to the \"queue\".\n        if (worker) {\n            workers.set(worker, resolve);\n            worker.postMessage(data);\n        } else {\n            queue.push([ data, resolve ]);\n        }\n    });\n};\n```", "```js\n// Create a new pool, and a workload counter.\nvar pool = new WorkerPool('worker.js');\nvar workload = 0;\n\ndocument.getElementById('work')\n    .addEventListener('click', function(e) {\n\n        // Get the data we're going to pass to the\n        // worker, and create a timer for this workload.\n        var amount = +document.getElementById('amount').value,\n            timer = 'Workload ' + (++workload);\n\n        console.time(timer);\n\n        // Pass the message to the pool, and when the promise\n        // resolves, stop the timer.\n        pool.postMessage(amount).then(function(result) {\n            console.timeEnd(timer);\n        });\n\n        // If messages are getting queued, our pool is \n        // overworked display a warning.\n        if (pool.queue.length) {\n            console.warn('Worker pool is getting busy...');\n        }\n    });\n```"]