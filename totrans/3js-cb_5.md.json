["```js\n      renderer.shadowMapEnabled = true;\n    ```", "```js\n    ..monkey.castShadow = true;\n      cubeMesh.castShadow = true;\n    ```", "```js\n      floorMesh.receiveShadow = true;\n    ```", "```js\n      var spotLight = new THREE.SpotLight();\n      spotLight.angle = Math.PI/8; // in radians\n      spotLight.exponent = 30;\n      spotLight.position = new THREE.Vector3(40,60,-50);\n    ```", "```js\n      spotLight.castShadow = true;\n      spotLight.shadowCameraNear = 50;\n      spotLight.shadowCameraFar = 200;\n      spotLight.shadowCameraFov = 35;\n    ```", "```js\n      spotLight.shadowMapHeight = 2048;\n      spotLight.shadowMapWidth = 2048;\n    ```", "```js\n      scene.add(spotLight);\n    ```", "```js\n      renderer.shadowMapEnabled = true;\n    ```", "```js\n      monkey.castShadow = true;\n      cubeMesh.castShadow = true;\n    ```", "```js\n      floorMesh.receiveShadow = true;\n    ```", "```js\n      var directionalLight = new THREE.DirectionalLight();\n      directionalLight.position = new THREE.Vector3(70,40,-50);\n      directionalLight.castShadow = true;\n    ```", "```js\n      directionalLight.shadowCameraNear = 25;\n      directionalLight.shadowCameraFar = 200;\n      directionalLight.shadowCameraLeft = -50;\n      directionalLight.shadowCameraRight = 50;\n      directionalLight.shadowCameraTop = 50;\n      directionalLight.shadowCameraBottom = -50;\n    ```", "```js\n      directionalLight.shadowMapWidth = 2048;\n      directionalLight.shadowMapHeight = 2048;\n    ```", "```js\n      scene.add(directionalLight);\n    ```", "```js\n      var ambientLight = new THREE.AmbientLight(0x332222);\n    ```", "```js\n      scene.add(ambientLight);\n    ```", "```js\n      var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6 );\n    ```", "```js\n      hemiLight.position.set( 0, 500, 0 );\n    ```", "```js\n      scene.add( hemiLight );\n    ```", "```js\n      var pointLight = new THREE.PointLight();\n      pointLight.color = new THREE.Color(0xff0000);\n      pointLight.intensity = 3;\n      pointLight.distance = 60;\n      pointLight.name = 'pointLight';\n    ```", "```js\n      pointLight.position = new THREE.Vector3(-30,0,0);\n      scene.add(pointLight);\n    ```", "```js\n      var light = scene.getObjectByName('pointLight');\n      light.position.y = 15 * Math.sin(count+=0.005);\n    ```", "```js\n      var count = 0;\n    ```", "```js\n      var spline = new THREE.SplineCurve3([\n        new THREE.Vector3(-100, 20, 100),\n        new THREE.Vector3(-40, 20, 20),\n        new THREE.Vector3(0, 20, -100),\n        new THREE.Vector3(20, 20, -100),\n        new THREE.Vector3(40, 20, 100),\n        new THREE.Vector3(70, 20, 10),\n        new THREE.Vector3(100, 20, 30),\n        new THREE.Vector3(-100, 20, 100)]);\n    ```", "```js\n      var pointLight = new THREE.PointLight();\n      pointLight.color = new THREE.Color(0xff0000);\n      pointLight.intensity = 3;\n      pointLight.distance = 60;\n      pointlight.name = 'pointLight';\n    ```", "```js\n      var pos = 0;\n      function positionLight() {\n        light = scene.getObjectByName('pointLight');\n        if (pos <= 1) {\n          light.position = spline.getPointAt(pos);\n          pos += 0.001\n        } else {\n          pos = 0;\n        }\n      }\n    ```", "```js\n      function render() {\n        renderer.render(scene, camera);\n        positionLight();\n        orbit.update();\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n  var geometry = new THREE.Geometry();\n  var splinePoints = spline.getPoints(50);\n  var material = new THREE.LineBasicMaterial({\n    color: 0xff00f0\n  });\n  geometry.vertices = splinePoints;\n  var line = new THREE.Line(geometry, material);\n  scene.add(line);\n```", "```js\n      var sphereGeometry = new THREE.SphereGeometry(1.5, 20,20);\n      var matProps = {\n        specular: 0xa9fcff,\n        color: 0x00abb1,\n        emissive: 0x006063,\n        shininess: 10\n      }\n      var sphereMaterial = new THREE.MeshPhongMaterial(matProps);\n      var sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);sphereMesh.name = 'sphere'; scene.add(sphereMesh);\n    ```", "```js\n      spotLight = new THREE.SpotLight();\n      spotLight.position.set(20, 80, 30);\n      spotLight.castShadow = true;\n      spotLight.angle = 0.15;\n      spotLight.distance = 160;\n      scene.add(spotLight);\n    ```", "```js\n      var step = 0;\n      function render() {\n        step += 0.02;\n        renderer.render(scene, camera);\n        var sphere = scene.getObjectByName('sphere');\n        sphere.position.x = 0 + (10 * (Math.cos(step)));\n        sphere.position.y = 0.75 * Math.PI / 2 + (6 * Math.abs(Math.sin(step)));\n        spotLight.target = sphere;\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n  var target = new THREE.Object3D();\n  target.position = new THREE.Vector3(20,10,-10);\n  scene.add(target);\n  spotLight.target = target;\n```", "```js\n      var basicShader = THREE.ShaderLib['basic'];\n    ```", "```js\n      Var uniforms = {}\n      uniforms = THREE.UniformsUtils.merge([basicShader.uniforms]);\n      var texture = THREE.ImageUtils.loadTexture('../assets/textures/debug.png');\n      uniforms['map'].value = texture;\n      uniforms.delta = {type: 'f', value: 0.0};\n      uniforms.scale = {type: 'f', value: 1.0};\n    ```", "```js\n      var defines = {};\n      defines[ \"USE_MAP\" ] = \"\";\n      var material = new THREE.ShaderMaterial({\n        defines: defines,\n        uniforms: uniforms,\n        vertexShader: document getElementById('sinusVertexShader').text,\n        fragmentShader: basicShader.fragmentShader\n      });\n    ```", "```js\n      <script id=\"sinusVertexShader\" type=\"x-shader/x-vertex\">\n        varying vec2 vUv;\n        uniform float delta;\n        uniform float scale;\n        void main() {\n          vUv = uv;\n          vec3 p = position;\n          p.z += sin(2.0 * p.y + delta) * 5.0;\n          p.z += cos(2.0 * p.z + delta / 2.0) * 5.0;\n          p.z += cos(2.0 * p.x + delta) * 5.0;\n          p.x += sin(p.y + delta / 2.0) * 10.0;\n          vec4 mvPosition = modelViewMatrix * vec4(scale * p, 1.0 );\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      </script>\n    ```", "```js\n      var cubeGeometry = new THREE.BoxGeometry(5, 5, 5);\n      var cube = new THREE.Mesh(cubeGeometry, material);\n      scene.add(cube);\n    ```", "```js\n      function render() {\n        renderer.render(scene, camera);\n        uniforms.delta.value += 0.01;\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n  varying vec2 vUv;\n  uniform float delta;\n  uniform float scale;\n```", "```js\n  void main() {\n    vUv = uv;\n    vec3 p = position;\n    p.z += sin(2.0 * p.y + delta) * 5.0;\n    p.z += cos(2.0 * p.z + delta / 2.0) * 5.0;\n    p.z += cos(2.0 * p.x + delta) * 5.0;\n    p.x += sin(p.y + delta / 2.0) * 10.0;\n    vec4 mvPosition = modelViewMatrix * vec4(scale * p, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n  }\n```", "```js\n      var basicShader = THREE.ShaderLib['normal'];\n    ```", "```js\n      var uniforms = {};\n      uniforms.delta = {type: 'f', value: 0.0};\n      uniforms.mNear = { type: \"f\", value: 1.0 };\n      uniforms.mFar = { type: \"f\", value: 60.0 };\n    ```", "```js\n      var material = new THREE.ShaderMaterial({\n        uniforms: uniforms,\n        vertexShader: basicShader.vertexShader,\n        fragmentShader: document getElementById('simple-fragment').text,\n      });\n    ```", "```js\n      var boxGeometry = new THREE.BoxGeometry(5, 15, 5);\n      var box = new THREE.Mesh(boxGeometry, material);\n      scene.add(box);\n    ```", "```js\n      <script id=\"simple-fragment\" type=\"x-shader/x-fragment\">\n        varying vec3 vNormal;\n        uniform float delta;\n        uniform float mNear;\n        uniform float mFar;\n        const float PI = 3.14159265358979323846264;\n        void main()\n        {\n          float depth = gl_FragCoord.z / gl_FragCoord.w;\n          float depthColor = smoothstep( mNear, mFar, depth );\n          gl_FragColor = vec4(abs(sin(delta + 0.7*PI) + cos(normalize(vNormal).x)/2.0) - depthColor,abs(sin(delta + 1.0*PI) + cos(normalize(vNormal).y)/2.0) - depthColor,abs(sin(delta + 1.2*PI) + cos(normalize(vNormal).z)/2.0) – depthColor, 1.0);\n        }\n      </script>\n    ```", "```js\n      function render() {\n        renderer.render(scene, camera);\n     uniforms.delta.value += 0.005;\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n  varying vec3 vNormal;\n  uniform float delta;\n  uniform float mNear;\n  uniform float mFar;\n  float PI = 3.14159265358979323846264;\n```", "```js\n    void main()\n    {\n      float depth = gl_FragCoord.z / gl_FragCoord.w;\n      float depthColor = smoothstep( mNear, mFar, depth );\n      gl_FragColor = vec4(\n        abs(sin(delta + 0.7*PI) + cos(normalize(vNormal).x)/2.0) – depthColor ,abs(sin(delta + 1.0*PI) + cos(normalize(vNormal).y)/2.0) – depthColor, abs(sin(delta + 1.2*PI) + cos(normalize(vNormal).z)/2.0) – depthColor, 1.0);\n    }\n```"]