["```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { NAME_CAPS } from '../actions/name-caps';\n\nclass First extends EventEmitter {\n  constructor() {\n    super();\n\n    // The default state is a \"name\" property\n    // with a lower-case string.\n    this.state = {\n      name: 'foo'\n    };\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        // Mutates the \"name\" property, keeping\n        // the \"state\" object intact.\n        case NAME_CAPS:\n          let { state } = this;\n          state.name = state.name.toUpperCase();\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new First();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { NAME_CAPS } from '../actions/name-caps';\n\nclass Second extends EventEmitter {\n  constructor() {\n    super();\n\n    // The defaul state is a name property\n    // with a lower-case string.\n    this.state = {\n      name: 'foo'\n    };\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        // Assigns a new \"state\" object, invalidating\n        // any references to any previous state.\n        case NAME_CAPS:\n          this.state = {\n            name: this.state.name.toUpperCase()\n          };\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new Second();\n```", "```js\nimport first from './stores/first';\nimport second from './stores/second';\nimport { nameCaps } from './actions/name-caps';\n\n// Setup references to the state of the\n// two stores.\nvar firstState = first.state;\nvar secondState = second.state;\n\nfirst.on('change', () => {\n  console.log('firstState', firstState.name);\n});\n// → firstState FOO\n\nsecond.on('change', () => {\n  console.log('secondState', secondState.name);\n});\n// → secondState foo\n\nsecond.on('change', (state) => {\n  console.log('state', state.name);\n});\n// → state FOO\n\nnameCaps();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { NAME_CAPS } from '../actions/name-caps';\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = {\n      name: 'foo'\n    };\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n        case NAME_CAPS:\n\n          // Convert to upper-case.\n          let name = this.state.name.toUpperCase();\n\n          // Only assign the new state object if\n          // the \"name\" isn't already in upper-case.\n          this.state = this.state.name === name ?\n            this.state : {\n              name: this.state.name.toUpperCase()\n            };\n\n          // Tell views about the state change, even\n          // if the state object is the same.\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new MyStore();\n```", "```js\nimport myStore from '../stores/my-store';\n\nclass MyView {\n  constructor() {\n\n    // The view keeps a copy of the previous\n    // store state.\n    this.previousState = null;\n\n    myStore.on('change', (state) => {\n\n      // Make sure we have a new state before\n      // rendering. If \"state\" is equal to\n      // \"previousState\", then we know there's\n      // nothing new to render.\n      if (state !== this.previousState) {\n        console.log('name', state.name);\n      }\n\n      // Keep a reference of the state, so that\n      // we can use it in the next \"change\"\n      // event.\n      this.previousState = state;\n    });\n  }\n}\n\nexport default new MyView();\n```", "```js\nimport myView from './views/my-view';\nimport { nameCaps } from './actions/name-caps';\n\n// Despite repeated calls to \"nameCaps()\",\n// \"myView\" is only rendered once.\nnameCaps();\nnameCaps();\nnameCaps();\n// → name FOO\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { ADD } from '../actions/add';\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    // The \"items\" state is an empty array\n    // by default...\n    this.state = {\n      items: []\n    };\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        // Push the \"payload\" to the \"items\"\n        // array when the \"ADD\" action is\n        // dispatched.\n        case ADD:\n          let { state } = this;\n\n          state.items.push(e.payload);\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new MyStore();\n```", "```js\nimport { default as React, Component } from 'react';\nimport myStore from '../stores/my-store';\n\n// A stateful React component that relies on\n// it's on state in order to render updates.\nexport default class Stateful extends Component {\n  constructor() {\n    super();\n\n    // When \"myStore\" changes, we set the state of\n    // this component by calling \"setState()\", causing\n    // a render to happen.\n    myStore.on('change', (state) => {\n      this.setState(state);\n    });\n\n    // The initial state of the component is\n    // taken from the initial state of the Flux store.\n    this.state = myStore.state;\n  }\n\n  // Renders a list of items.\n  render() {\n    return (\n      <ul>\n        {this.state.items.map(item =>\n          <li key={item}>{item}</li>)}\n      </ul>\n    );\n  }\n}\n```", "```js\nimport React from 'react';\n\n// The stateless version of the React\n// component is a much stripped-down\n// version of a class component. Since\n// it only relies on properttes passed\n// into it, it can be a basic arrow function\n// that returns a React element.\nexport default ({ items }) => (\n  <ul>\n    {items.map(item =>\n      <li key={item}>{item}</li>)}\n  </ul>\n);\n```", "```js\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport Stateful from './views/stateful';\nimport Stateless from './views/stateless';\nimport myStore from './stores/my-store';\nimport { add } from './actions/add';\n\n// These are the DOM element \"containers\" that\n// our React components are rendered into.\nvar statefulContainer =\n  document.getElementById('stateful');\nvar statelessContainer =\n  document.getElementById('stateless');\n\n// Sets up the store change listener for our\n// \"Stateless\" React component. This is simple\n// \"render()\" call, React efficiently handles\n// the DOM diffing semantics.\nmyStore.on('change', (state) => {\n  render(\n    <Stateless items={myStore.state.items}/>,\n    statelessContainer\n  );\n});\n\n// Initial rendering of our two components.\nrender(\n  <Stateful/>,\n  statefulContainer\n);\n\nrender(\n  <Stateless items={myStore.state.items}/>,\n  statelessContainer\n);\n\n// Dispatch some actions, causing our store to change,\n// and our React components to re-render.\nadd('first');\nadd('second');\nadd('third');\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { SORT_DESC } from '../actions/sort-desc';\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    // The default store state has an array of\n    // strings.\n    this.state = {\n      items: [\n        'First',\n        'Second',\n        'Third'\n      ]\n    };\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        // The \"SORT_DESC\" action sorts the\n        // \"items\" array in descending order.\n        case SORT_DESC:\n          let { state } = this;\n\n          state.items.sort().reverse();\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new MyStore();\n```", "```js\nimport React from 'react';\nimport Item from './item';\n\n// The application view. Renders a list of\n// \"Item\" components.\nexport default ({ items }) => (\n  <ul>\n    {items.map(item =>\n      <Item key={item}>{item}</Item>)}\n  </ul>\n);\n```", "```js\nimport React from 'react';\n\n// An \"li\" component with \"strong\" text.\nexport default (props) => (\n  <li>\n    <strong>{props.children}</strong>\n  </li>\n);\n```", "```js\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport myStore from './stores/my-store';\nimport App from './views/app';\nimport { sortDesc } from './actions/sort-desc';\n\n// The containiner element for our application.\nvar appContainer = document.getElementById('app');\n\n// Renders the \"App\" view component when\n// the store state changes.\nmyStore.on('change', (state) => {\n  render(\n    <App {...state}/>,\n    appContainer\n  );\n});\n\n// Initial rendering...\nrender(\n  <App {...myStore.state}/>,\n  appContainer\n);\n\n// Perform the descending sort...\nsortDesc();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { SORT } from '../actions/sort';\n\n// Constants for the direction label\n// of the sort button.\nconst ASC = 'sort ascending';\nconst DESC = 'sort descending';\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    // We have some \"items\", and a \"direction\"\n    // as the default state of this store.\n    this.state = {\n      direction: ASC,\n      items: [\n        'Second',\n        'First',\n        'Third'\n      ]\n    };\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n        case SORT:\n          let { state } = this;\n\n          // The \"items\" are always sorted.\n          state.items.sort()\n\n          // If the current \"direction\" is ascending,\n          // then update it to \"DESC\". Otherwise, it's\n          // updated to \"ASC\" and the order is reversed.\n          if (state.direction === ASC) {\n            state.direction = DESC;\n          } else {\n            state.direction = ASC;\n            state.items.reverse();\n          }\n\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new MyStore();\n```", "```js\nimport React from 'react';\nimport Sort from './sort';\nimport Item from './item';\n\n// The application view. Renders a sort\n// button and a list of \"Item\" components.\nexport default ({ items, direction }) => (\n  <div>\n    <Sort direction={direction}/>\n    <ul>\n      {items.map(item =>\n        <Item key={item}>{item}</Item>)}\n    </ul>\n  </div>\n);\n```", "```js\nimport React from 'react';\nimport { sort } from '../actions/sort';\n\n// Some inline styles for the React view...\nvar style = {\n  textTransform: 'capitalize'\n};\n\n// Renders a \"button\" element, with the\n// \"direction\" store state as the label\n// and the \"sort()\" action creator function\n// is called when the button is clicked.\nexport default ({ direction }) => (\n  <button\n    style={style}\n    onClick={sort}>{direction}\n  </button>\n);\n```", "```js\nimport React from 'react';\nimport { render } from 'react-dom';\nimport { Router, Route, IndexRoute } from 'react-router';\n\nimport App from './views/app';\nimport First from './views/first';\nimport Second from './views/second';\nimport { routeUpdate } from './actions/route-update';\n\n// The containiner element for our application.\nvar appContainer = document.getElementById('app');\n\n// Called by the \"Router\" whenever a route changes.\n// This is where we call the action creator\n// \"routeUpdate()\", passing it the path of the\n// new route.\nfunction onUpdate() {\n  routeUpdate(this.state.location.pathname);\n}\n\n// Renders the router components. Each route\n// has an associated React component that's\n// rendered when the route is activated.\nrender((\n  <Router onUpdate={onUpdate}>\n    <Route path=\"/\" component={App}>\n      <IndexRoute component={First}/>\n      <Route path=\"first\" components={First}/>\n      <Route path=\"second\" component={Second}/>\n    </Route>\n  </Router>\n), appContainer);\n```", "```js\nimport React from 'react';\nimport { Link } from 'react-router';\n\n// Renders some links to the routes in the app.\n// The \"props.children\" are any sub-components.\nexport default (props) => (\n  <div>\n    <ul>\n      <li><Link to=\"/first\">First</Link></li>\n      <li><Link to=\"/second\">Second</Link></li>\n    </ul>\n    {props.children}\n  </div>\n);\n```", "```js\nimport dispatcher from '../dispatcher';\n\n// The action identifiers...\nexport const ROUTE_UPDATE = 'ROUTE_UPDATE';\nexport const PRE_ROUTE_UPDATE = 'PRE_ROUTE_UPDATE';\n\nexport function routeUpdate(payload) {\n\n  // Immediately dispatch the \"PRE_ROUTE_UPDATE\"\n  // action, giving stores a chance to adjust\n  // their state while asynchronous activities happen.\n  dispatcher.dispatch({\n    type: PRE_ROUTE_UPDATE,\n    payload: payload\n  });\n\n  // Dispatches the \"ROUTE_UPDATE\" action\n  // after one second.\n  setTimeout(() => {\n    dispatcher.dispatch({\n      type: ROUTE_UPDATE,\n      payload: payload\n    });\n  }, 1000);\n}\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\n\n// We need a couple action constants from\n// the same action module.\nimport {\n  PRE_ROUTE_UPDATE,\n  ROUTE_UPDATE\n} from '../actions/route-update';\n\nclass First extends EventEmitter {\n  constructor() {\n    super();\n\n    // The \"content\" state is initially an\n    // empty string.\n    this.state = {\n      content: ''\n    };\n\n    this.id = dispatcher.register((e) => {\n      let { state } = this;\n\n      switch(e.type) {\n\n        // The \"PRE_ROUTE_UPDATE\" action means the\n        // route is about to change once the\n        // asynchronous code in the action creator\n        // resolves. We can update the \"content\"\n        // state here.\n        case PRE_ROUTE_UPDATE:\n          if (e.payload.endsWith('first')) {\n            state.content = 'Loading...';\n            this.emit('change', state);\n          }\n          break;\n\n        // When the \"ROUTE_UPDATE\" action is dispatched,\n        // we can change the content to show that it has\n        // loaded.\n        case ROUTE_UPDATE:\n          if (e.payload.endsWith('first')) {\n            state.content = 'First Loaded';\n            this.emit('change', state);\n          }\n          break;\n      }\n    });\n  }\n}\n\nexport default new First();\n```", "```js\nimport { default as React, Component } from 'react';\nimport first from '../stores/first';\n\nexport default class First extends Component {\n  constructor() {\n    super();\n\n    // The initial state comes from the store.\n    this.state = first.state;\n\n    // The store \"change\" callback function is\n    // defined here so that it can be bound to\n    // \"this\" and set the component state.\n    this.onChange = (state) => {\n      this.setState(state);\n    };\n  }\n\n  // Renders the HTML using \"content\".\n  render() {\n    return (\n      <p>{this.state.content}</p>\n    );\n  }\n\n  // Sets up the store \"change\" listener.\n  componentWillMount() {\n    first.on('change', this.onChange);\n  }\n\n  // Removes the store \"change\" listener.\n  componentWillUnmount() {\n    first.removeListener('change', this.onChange);\n  }\n}\n```"]