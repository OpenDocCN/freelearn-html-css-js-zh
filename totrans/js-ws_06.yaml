- en: 6\. Understanding Core Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to apply timeouts and intervals
    to include asynchronous functionality in applications; identify the different
    browser event types; capture and handle user interaction; intercept and prevent
    events; impersonate events to improve application user experience; summarize the
    different browser supported input controls; and work with forms, form submission,
    and form event handling.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you were introduced to the many data types supported
    by the JavaScript language and runtime, including functions, JavaScript''s most
    impressive first-class data type. Understanding the differences between data types
    is an important first step for building practical, efficient, and bug-free applications.
    Software applications have many forms and may have many uses. In its simplest
    form, an application may read parameters on execution, process the data, and return
    a response. It may not even interact with any other applications or outside services.
    Terminal commands are a good example of this. For instance, executing `dir` in
    a Windows command window or `ls` in a `Linux Terminal` would simply read the contents
    of a directory on the hard disk and display the details of those files and directories
    within the Terminal window. The Linux operating system is built on the premise
    of such very small and simple applications working together to create a much larger
    ecosystem. The converse of this may be modern multiplayer video games, which typically
    react to user interaction and receive streamed data from remote locations. The
    former of these concepts can be considered much like a function: input enters
    from the top and is output somewhere within the body, typically, the end of the
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript applications can facilitate both ends of this spectrum, and indeed,
    anything in between. Modern browsers are now fully capable of providing the foundations
    for immense and processor-intensive 3D multiplayer games, responding to data from
    numerous sources, but JavaScript is also frequently used for the simplest of tasks,
    such as formatting a `string` or rounding a `number`.
  prefs: []
  type: TYPE_NORMAL
- en: At the core of all of these applications are `events`. Events, conceptually
    speaking, are triggers that execute code. This might, for example, be the ready
    state when a page has finished loading or a mouse event when the user clicks an
    element within the page. Typically, without events, functions won't know when
    to execute and, therefore, nothing can happen.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will examine the options JavaScript provides for
    listening to and handling different types of events within the browser environment.
  prefs: []
  type: TYPE_NORMAL
- en: Event Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An event is simply a notification or a "`triggered`" alert within the JavaScript
    runtime. These notifications can represent practically anything but are a means
    to invoke one or more of your own functions when such an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: When a web page loads, the browser will typically display content as soon as
    it is available. This means some content will be presented to the user before
    the entire page has finished downloading. The browser does this to prevent long-loading
    assets from withholding other content from being available to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine you want to invoke a function immediately within a web page to
    rotate an image. JavaScript code embedded into a web page is able to run immediately
    once it has been parsed by the JavaScript engine, which could possibly be before
    the image in question is available. To overcome this conundrum, JavaScript provides
    an `onload` event, which is dispatched as soon as all the page's content has finished
    downloading. By refraining from invoking your function until this event has been
    dispatched, you can ensure that your image can be rotated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are many other such events. Arguably, there are four specific
    types of events within the JavaScript ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timer events** provide forced asynchronous functionality within your applications.
    They allow you to invoke a function after a period of time, either once or repeatedly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callbacks`, are dispatched when something has finished executing but has occurred
    in parallel to any other function execution in your application. This means the
    process has not stopped your application from doing other tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOM` or keyboard events, are events that are dispatched due to the user interacting
    with your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom events** are events that you create yourself. These can be almost
    anything but are usually created as a response to one of the JavaScript event
    types listed previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of event you will require is very specific to a given use case. In
    this chapter, we will examine both timer-based events and interaction events.
  prefs: []
  type: TYPE_NORMAL
- en: Timer Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some languages, such as C, the base application may be run using a continuous
    loop. In C, specifically, an application runs during the lifetime of its `main`
    function; when this function returns, the application exits. Typically, applications
    that need to run for some time and respond to events would utilize a simple loop.
    In fact, it''s not uncommon to see applications start with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the application simply enters an indefinite loop. If the application needs
    to quit, it would call a command similar to JavaScript's `break` keyword. Otherwise,
    the application would quite happily run and invoke functions as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Applications written in C are able to do this for several reasons. The first
    is that C is a multi-threaded platform. This means that several processes, known
    as threads, can be created within a C application and may run concurrently, providing
    the underlying hardware it supports. In the worst-case scenario, these threads
    are cycled, allowing each one to utilize a period of execution time within the
    CPU. Another reason this is possible is that C applications run very close to
    the hardware and, unlike JavaScript, are unencumbered by a lower-level engine
    that dictates execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: Since a program can exist with a loop at its core, it stands to reason that
    functions will, or can, be called with each iteration. However, if a function
    was called indefinitely with every iteration, such a process may be overly resource-intensive
    or simply run too fast. An alternative is to make the function conditional by
    requiring it to execute only when enough time has passed since its last execution.
    This is the essential basis of a timer event.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C, JavaScript is a `single-threaded` platform, meaning it can only execute
    a single thread throughout your entire application. A thread is an execution space
    in the CPU. If you have one thread, then only a single series of function executions
    can occur at once. In JavaScript, this does not mean the underlying engine doesn't
    use, or have access to, more than one thread; only that your application has programmatic
    access to one single thread.
  prefs: []
  type: TYPE_NORMAL
- en: Since JavaScript runs within an engine, known as a virtual machine, it is driven
    by a number of rules that determine how your code is run. The JavaScript virtual
    machine follows an architecture known as an event loop. This means that the loop
    in the preceding C example is already occurring within the JavaScript engine that
    your application runs within. However, within that loop, the JavaScript engine
    manages code execution for each of the function calls your application makes,
    among other things, regardless of whether those calls invoke your own functions
    or those native to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.01: Custom Timer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned previously, many developers coming from lower-level languages
    will consider a loop as a means to create timed function invocations. If a loop
    can occur indefinitely, then we only need to check the current system time and
    invoke functions when sufficient time has passed. For instance, when animating,
    in order to control the `speed` of the animation, you may want to ensure your
    frame update functions are executed with a sufficient period of time between each
    invocation. Without this control, your animation frames will update with every
    possible cycle of the JavaScript runtime, which may be very fast on some machines,
    while not so fast on weaker machines. In this exercise, you will implement one
    such loop. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, you''ll need three variables. The first will store the current time
    in milliseconds for each iteration, the second variable will contain the time
    in milliseconds of the last time the custom timer function executed, and the third
    variable will be the required minimal interval between timer function calls in
    milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we open the `main` function and the indefinite loop. Similar to the preceding
    example, we''ll simply use a `while` loop and pass it a decrementing value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the first thing that needs to happen with each iteration is that we need
    to get the current time in milliseconds and compare it to the last stored time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `lastTime` variable, if it is `null`, will be passed the value of `curTime`.
    This way, it will execute correctly from its first iteration since `null` cannot
    be deducted from an `integer`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the values are sufficiently different (greater than the `interval` amount),
    you can invoke your timed functions. You will then need to update the `lastTime`
    variable to equal the current time so that the function doesn''t execute again
    in succession and instead waits for the next duration to occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you close out the conditional, loop, and function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it. If you execute the function by calling `main()`, you will see the
    current time in milliseconds output to the console every `500` milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What you have just created is similar to an application loop. Many programming
    languages support the notion of an application loop. In fact, languages such as
    C++ require such a loop in order to prevent an application from exiting. In such
    circumstances, the loop is a simple "`keep-alive`" mechanism whereby checks for
    potential events occur manually within the loop. In JavaScript, such loops are
    unnecessary. This is because the JavaScript engine already enlists the help of
    such a loop under the hood, known as the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Event Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous exercise exhibits perfectly legitimate code and would facilitate
    a working function invocation timer. However, creating timers in this fashion
    has a number of drawbacks. The first issue here is that since JavaScript is single-threaded,
    the entire application will be contained within the loop. There is no way to continue
    processing data outside of the loop without breaking out of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second issue in the previous exercise is that since the JavaScript engine
    is already running its own event loop, the example code is actually performing
    two infinite loops, one nested within the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Nested infinite event loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: Nested infinite event loop'
  prefs: []
  type: TYPE_NORMAL
- en: Since delayed and repeated function invocation is a common programming requirement,
    the JavaScript language provides two functions that make timers simple without
    us having to construct our own loops. These are `setInterval` and `setTimeout`.
  prefs: []
  type: TYPE_NORMAL
- en: The setInterval Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`setInterval` is a native implementation of our previous infinite loop. The
    premise is that, given a function and an interval value in milliseconds, JavaScript
    will repeatedly execute the function whenever the interval time has passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The time-based execution in JavaScript is "as near to" the interval value as
    possible. JavaScript is unable to guarantee absolute accuracy when executing triggers
    due to various limitations with the underlying hardware, operating system, and
    resource availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reproduce our previous example with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The function expression in this example will be executed `500` milliseconds
    after we call `setInterval` and every `500` milliseconds thereafter. It is executed
    asynchronously, so the code that follows the `setInterval` call is executed without
    delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setInterval` function itself, when invoked, returns a reference to the
    resulting interval handler, that is, the execution stack that invokes the passed
    `callback` function. This reference may be used to terminate the interval loop
    at any time using the `clearInterval` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The setTimeout Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setTimeout` function works identically to the `setInterval` function,
    the difference being that its passed `callback` function is only ever called once.
    The `setTimeout` function is useful when animating elements within an HTML page,
    or when you wish to delay a process for a period of time, such as clearing a visible
    error message or dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `setInterval`, the `setTimeout` function also returns a reference to its
    execution handler so that the timer can be cleared with `clearTimeout`. Since
    the `setTimeout` callback is only executed once, calling `clearTimeout` after
    the `callback` has executed has no effect. It is, however, possible to cancel
    `setTimeout` before it executes, which is a perfectly reasonable requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setTimeout` function can be mimicked by the `setInterval` function by
    simply clearing its reference after its first timer iteration, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Timer Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In modern browsers (excluding `IE9` and below), the `setInterval` and `setTimeout`
    functions may receive additional parameters. If any are supplied proceeding the
    interval parameter, those additional parameters will be passed as parameters to
    the `callback` function when it is invoked. This provides a useful means to customize
    timer functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you anticipate older browsers running your scripts, the same effect may
    be attained by wrapping the passed `callback` within an anonymous function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 6.02: Real-Time Clock'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is now time to put your knowledge of timers to use. In this exercise, you
    will be creating a real-time in-page clock display that will count up in seconds
    and show the full time using a 24-hour digital clock format. This exercise will
    make use of an HTML file, albeit a simple one. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `script` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `script` tag will contain the JavaScript to be executed within the page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, you''ll need some placeholder variables for the `seconds`, `minutes`,
    `hours`, and the current `Date` object instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `handler` function you''ll use for the timer will also be assigned to a
    variable called `setTime`. In it, you will simply populate the preceding variables
    with the current time components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To output the time to the page, you''ll simply need to update the `body` content.
    There are better solutions to this that will be explained later in this module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, close the function and assign it to an interval. Set the interval
    to run every `500` milliseconds to ensure better accuracy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `script` complete, you should close out the `script` tag block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The page should end with a `body` tag block, which will contain the clock and
    the closing `html` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, save the page and load it (or drag it) into your browser. You should see
    the time displayed in the top left-hand corner of the page, and it should update
    every second. You have successfully built your first timer-based JavaScript application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Displaying a real-time clock on a web page is a practical application, particularly
    within corporate websites and intranets that may exhibit times for several time
    zones around the world. However, utilizing a timer to update page content is not
    limited to clocks. This same process could be utilized to update stock market
    prices, real-time chat forums, or just about any kind of real-time presentation.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript Events Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we noted previously, the JavaScript engine utilizes an event loop. In fact,
    events are at the center point of the JavaScript engine and its language. At its
    simplest definition, an event is a notification that something has occurred. This
    may be interaction by the user with a web page or the completion of some process
    that occurs within the browser.
  prefs: []
  type: TYPE_NORMAL
- en: To make use of events, a `callback` function must be assigned to the event type,
    much like with the timer-based function. However, typically, events are a little
    more complex and feature-rich than simple timers.
  prefs: []
  type: TYPE_NORMAL
- en: An event notification is known in programming as a dispatched event. When JavaScript
    events are dispatched, they are passed an event object. This is true of all JavaScript
    events. The event object contains useful details about the dispatched event, including
    the name of the event, a reference to the object that holds the context of the
    event, and a reference to the object that triggered the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the properties of the event object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2:  Event Object properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Event Object properties'
  prefs: []
  type: TYPE_NORMAL
- en: Event Bubbling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to understand event bubbling, it helps if we understand browser-based
    HTML. HTML is an abbreviation for HyperText Markup Language, which itself is a
    derivative of eXtensible Markup Language (XML). HTML is not really a language
    at all, but a declarative information markup that structures data, which, in the
    case of websites, is page content.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML is a hierarchical construct that can be best envisaged as a data tree.
    Imagine the following page content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: HTML mockup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: HTML mockup'
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the page consists of two columns. On the left is an image
    and on the right is a container with two rows; the first row contains three buttons
    and the second row contains a block of text. Like a tree, this layout may look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: HTML data tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: HTML data tree'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding tree outlines the visible content of the page, but the `body`
    node is not the actual top of the literal HTML tree. Instead, the page content
    tree starts with a node called the `document`. This then has a child called `html`,
    and that node contains the `body` node.
  prefs: []
  type: TYPE_NORMAL
- en: Each node within the HTML tree will raise events if interacted with, even if
    that node is not immediately visible. When clicking the page with your mouse,
    for instance, the visible node beneath the mouse arrow that is closest to the
    bottom of the tree will raise a `click` event. If one or more event handlers have
    been assigned to that node, then those handlers will be invoked and will be passed
    an `event` object.
  prefs: []
  type: TYPE_NORMAL
- en: Event bubbling occurs when event handlers are not assigned to the node for that
    event type or if the event is handled but the event is allowed to continue propagating.
    At this point, the handlers of the parent node for that specific event are called,
    and the same process occurs. If the event continues to not be explicitly halted,
    it will `bubble` through each parent node until it reaches the `document` node.
  prefs: []
  type: TYPE_NORMAL
- en: If multiple handlers exist on a given node for a specific event, any one of
    those handlers may halt the event, preventing it from bubbling. It is not required
    for all handlers to halt the event.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing the Node Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to handle an event, you first need to add an event type handler to
    a node. However, to do that, you need some way to acquire a reference to the node
    on which you wish to listen. JavaScript provides numerous functions for selecting
    and acquiring nodes based on many different factors, including direct named access,
    acquisition through node tree traversal, and acquisition by attribute value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of all the nodes within your HTML pages, the easiest to acquire are the `body`
    and `document` nodes. Both of these nodes have simple attribute accessors on the
    global `document` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a reference to the top of the tree, acquiring a node elsewhere
    within the tree is simply a matter of traversing it. JavaScript provides several
    properties for acquiring a node''s parent, siblings, or children, each of which
    uses the `familiar relationship` metaphor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Node properties and their description'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: Node properties and their description'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these properties can be read from the given node. If a corresponding
    node cannot be found, then the property will return `null` (or an empty array
    in the case of `childNodes`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Direct Node Acquisition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aside from node tree traversal, JavaScript also provides a means to specify
    the node reference you require by supplying a node property filter, which is a
    string value describing the node you require using a specific format.
  prefs: []
  type: TYPE_NORMAL
- en: 'All HTML nodes follow a certain pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: They are opened and closed, sometimes in a single tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a node name or type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may have an optional `id` property, which should be unique to the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may have one or more optional `class` names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may have other optional known properties, such as `name`, `styles`, `type`,
    `value`, or `src`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may have optional custom properties, named by the page creator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The node''s signature is known as its `tag`, which is defined within angle
    brackets, with a left-facing angle bracket at the start of the node and a right-facing
    bracket at the end of the node. Immediately after the left-facing bracket is the
    node''s name. Properties are appended to the node as `attribute="value"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: HTML node structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: HTML node structure'
  prefs: []
  type: TYPE_NORMAL
- en: The closing tag of a node contains the node's name and is also wrapped with
    a left-facing and right-facing angle bracket. However, to differentiate it from
    a new opening tag, its left-facing angle bracket is preceded by a forward-slash
    (`/`) character.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a node has no children, it is acceptable to immediately close the node without
    supplying a distinct closing tag. This is accomplished by providing the forward-slash
    character immediately before the right-facing angle bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties of a node are its description. Later, these values allow you
    to style the node''s look-and-feel, but they specifically facilitate the node''s
    data and identity. As such, it is perfectly legitimate to add attributes to nodes
    in order to make them easily acquirable. The `id` attribute is one such value
    that exists solely to differentiate tags and it is important that all the tags
    that are used within a page have a unique `id` attribute, if they have one at
    all. If an `id` attribute is present, the associated node can be acquired using
    the `getElementById` method of the `document` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since node IDs are deemed to be unique, the `getElementById` method returns
    a single node, or `null` if a matching node is not found. If, for some reason,
    a page contains multiple nodes with the same ID attribute value, then calling
    `getElementById` with that value will return the first element found within the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other similar functions exist in order to query using other tag descriptors,
    such as the `name` or `class`. The majority of these return an array since it
    is expected that many tags may share matching descriptors. The following table
    lists some of the common functions for acquiring tag references:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Common functions for tag references'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: Common functions for tag references'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning and Removing an Event Handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have a node reference, you are then able to assign listeners (or handlers)
    for specific event types. Listeners can be assigned to a node using the `addEventListener`
    function, which accepts two parameters, the type of the event as a string value
    and the handler of the event as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When an event is dispatched, the event handler is passed a single value, known
    as an event object. Event objects may have slightly different parameters depending
    on the event type being handled. The object is actually an instance of a specific
    event object type. For instance, mouse-based events, such as `click` or `mousedown`,
    generate `MouseEvent` objects. These differ from many other events in that they
    contain `x` and `y` values detailing the mouse coordinates within the web document
    at the time the event was dispatched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When attaching an event handler, it will not overwrite existing handlers attached
    to that node, even if the handler is assigned to the same event type. In fact,
    a node may have any number of event listeners attached at any one time. This way,
    multiple facets of your application can independently access the same event notifications
    for the same object, as needed. What is not possible, however, is for the same
    `function reference` to be assigned more than once to the same event type, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, since the `display` function is a single reference,
    the second listener assignment was simply ignored. JavaScript will not repeat
    the function invocation more than once. However, the previous assignments were
    both invoked because, although the functionality was the same, the functions themselves
    possessed different references.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to remove an event handler, you can do so with the `removeEventListener`
    method, which takes identical parameters to its counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `removeEventListener` method finds the handler association by reference.
    This means that any event listener assignments you make using anonymous functions
    cannot be removed using the `removeEventListener` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you dispose of a node that has event handlers attached to it, it will not
    be cleaned up by the JavaScript engine's `garbage Collector`. Removing nodes without
    cleaning up their event handlers is a common cause of memory leaks in JavaScript,
    which leads to poor application performance. If you know a node may be removed
    from the `DOM`, do not add event listeners to it, or its children, using anonymous
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Tabbed Content'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you''ll use what you have learned so far to create a tabbed
    display. The display will utilize three buttons at the top of the page, with a
    container `div` tag at the bottom. When a button is pressed, content associated
    with the button handler will be displayed within the container `div` tag. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new document called **tabs.html** and add the starting HTML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The three buttons will sit side by side in a single container `div`. Each one
    will have a unique ID so that we can easily reference them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the container `div`. We''ll add a descriptive body to inform the
    user of the page. However, once a button has been pressed, that content will disappear
    for good and will be replaced by dynamic content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the structure of the page in place, you can now close out the body and
    begin the `script` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we've created a variable for each element in the page we need to interact
    with. This makes the code neater and cleaner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, you''ll need some content to add when the buttons are pressed, one for
    each button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to wire up the content. To do this, simply add an event listener
    to each button, updating the container `div` content in each one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, simply close out the open tags and save the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it. If you now run the page in your browser and click each button, you
    should see that the content has been updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The interactive page is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.8: Tabbed control exercise'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: Tabbed control exercise'
  prefs: []
  type: TYPE_NORMAL
- en: This has been your first exploration of interactive content. Manipulating page
    content based on user interactivity is a common requirement for JavaScript and
    is something it excels at. Through careful planning and good coding practices,
    it is possible to create JavaScript applications that can mimic almost any kind
    of native software application.
  prefs: []
  type: TYPE_NORMAL
- en: Bubbling versus Capturing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you've seen that event bubbling is where an event bubbles up from the
    node that dispatched it to the top of the tree, but JavaScript also provides an
    alternative to bubbling called capturing.
  prefs: []
  type: TYPE_NORMAL
- en: '`Event capturing` is where events are handled in the reverse order to bubbling,
    capturing notifications from the node that dispatched it to the bottom of the
    tree. This means that, when a node is interacted with, its attached event handlers
    may not be the first to intercept the event. Instead, a parent (or ancestor) may
    receive the event first, instead. If one of those ancestral handlers halts the
    event, then the handlers on the node that gave rise to the event may never actually
    be invoked at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Bubbling versus capturing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Bubbling versus capturing'
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach an event handler to a capture event, you simply need to pass a third
    parameter to the `addEventListener` method. This third parameter is known as the
    `useCapture` parameter and is a Boolean. If set to `true`, the attached event
    will be assigned in `capture` mode. Thus, not supplying the `useCapture` parameter
    to the `addEventListener` method is the same as supplying `false` for that parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Event handlers that are attached to capture events sit in a different space
    to bubbling event listeners. When assigning capturing events, they will not conflict
    with bubbling events. Therefore, assigning a function reference as an event handler
    as both bubbling and capturing, using the same event type on the same node, will
    mean that function will be called twice when that event is dispatched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove an event that''s been added with `useCapture` set to `true`, you
    simply pass the same `useCapture` value to the `removeEventListener` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript Event Life Cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of which node has dispatched the event, all event notifications start
    at the `document` node. They then travel in capture mode through the tree branches
    toward the node that dispatched it (the `target` node). Once all the appropriate
    capture handlers along that path have been invoked, the event then travels back
    to the `document` node, invoking all the appropriate bubbling handlers.
  prefs: []
  type: TYPE_NORMAL
- en: When traveling down the tree, the event is said to be in its capture phase and
    is said to be in its bubbling phase when returning to the `document` node. It
    is in its target phase when the target nodes handlers are invoked, regardless
    of whether it is its capturing handler or bubbling handler.
  prefs: []
  type: TYPE_NORMAL
- en: At any point in an event's round-trip travels, it may be halted by a handler,
    preventing all further event handlers from being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Halting Event Propagation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, when handling events, you may need to stop an event in its tracks.
    Knowing an event may be acted upon elsewhere in your page, it may make sense to
    halt an event if the conditions within your app are not in a state to allow the
    event to continue.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if an event is dispatched when a user enters a new password within
    a `textfield` control, the event may be useless if the password does not meet
    certain requirements, such as consisting of too few characters or including characters
    that are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript provides two similar functions to halt events: `stopPropagation`
    and `stopImmediatePropagation`. Both functions are methods of the event object
    that are passed to event handlers as their sole parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `stopPropagation` method will prevent event handlers on further nodes along
    its journey from being invoked, regardless of whether the event is in its capturing
    phase or bubbling phase. However, it will still allow all remaining as-yet-uninvoked
    event handlers for the current event type to execute if they are on the same node
    as the event handler that called `stopPropagation`. The `stopImmediatePropagation`
    method will stop all further handlers, including those as-yet-uninvoked on the
    current node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Either method may be invoked anywhere within a handler and may be called in
    multiple handlers, though only the first instance will execute.
  prefs: []
  type: TYPE_NORMAL
- en: Halting Event Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some events within the JavaScript engine result in an action. An action is a
    browser-specific response to an event, outside of your own custom event handlers.
    Examples of this include the submission of a `form` or a page redirection when
    clicking a link.
  prefs: []
  type: TYPE_NORMAL
- en: Actions occur after the event bubbling phase, once the event has finished its
    journey through the node tree. If an event is stopped due to the invocation of
    either `stopPropagation` or `stopImmediatePropagation`, the action will still
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent an action, the event object''s `preventDefault` method must be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `preventDefault` does not halt the event passing through the capture
    or bubbling phases. Therefore, if you want to stop an event in its tracks and
    prevent its action, you must call both types of method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that not all events can be prevented from initiating an action. Each dispatched
    event contains a property called cancelable. If this property is `true`, then
    it can be canceled by calling its `preventDefault` method. If, however, the property
    is `false`, then calling `preventDefault` will do nothing to change its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `onload` event is one such event that can't be canceled, and with good reason,
    since it is imperative that the event completes its life cycle to ensure the proper
    functionality of the browser. Conversely, a form `onsubmit` event is cancelable
    since its success must be at the discretion of the page's business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.04: Conditional Event Prevention'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a group of links. Each link, when clicked,
    will raise a `click` event. Above these links, the containing `div` will listen
    for the event each one raises and will determine if it should stop the event propagation,
    stop its action, or stop both. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a document called **ev-prev.html** and adding some
    HTML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have a container with three links and a secondary container for output
    messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, open a `script` tag for the JavaScript and create variables to reference
    the `link` container, the links themselves, and the `message` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When each link is clicked, we want a message to display, showing which link
    was clicked. Therefore, we will attach an `event listener` to the `link` container
    so that when the events bubble up, the handler will be there to catch the event
    object and identify which link dispatched the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will add a behavior for each link. The first will prevent actions,
    the second will stop `propagation`, and the third will do both:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, close out the `script` tag and `html` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By running this page in a browser, you should see that the first link will print
    `Google` clicked in the message container, the second will redirect the user to
    the `Bing` website, and the third will do nothing at all. When clicking the second
    link, the message is never displayed because the event propagation is stopped
    in the handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have now successfully marshaled events and caught them as they bubbled
    up through the node tree:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.10: Event prevention'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Event prevention'
  prefs: []
  type: TYPE_NORMAL
- en: Event Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen that events are dispatched dynamically when interacting with a
    web page, but events can also be triggered manually, through your own code.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, events in JavaScript are typed objects. When a dynamic
    event is raised, the JavaScript engine creates such an object and dispatches it.
    The object contains a type value that stores the event type as a string, such
    as `click`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to instantiate your own event objects and dispatch them, rather
    than simply relying on events being created dynamically. There are many reasons
    why you might like to do this, such as to simulate user interaction or to easily
    invoke code already assigned as an event handler without duplicating code. To
    do so, you simply create an instance of an `Event` using the `new` keyword and
    pass it the type of event you wish to raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, you then simply dispatch it using the node''s `dispatchEvent`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The node that the `dispatchEvent` method is called from becomes the event object's
    target property. Once dispatched, the event enters the capture phase down through
    the `DOM` to this node, then the bubbling phase back up from it as normal, triggering
    event listeners as it goes.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Event` object is the simplest type of event provided by the JavaScript
    framework. In fact, all the other events provided by JavaScript extend the simple
    `Event` type. However, the `Event` object by itself is not very flexible and does
    not provide a means of easily attaching additional data for an event. To alleviate
    this, the JavaScript language supplies the `CustomEvent` type, that is, an event
    specifically designed for custom developer events.
  prefs: []
  type: TYPE_NORMAL
- en: 'When instantiated, the `CustomEvent` object accepts an additional named parameter
    called `detail`. By providing an object with a `detail` property as the second
    constructor parameter, the value of that property is then available to all event
    handlers that intercept it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, any event handlers that may intercept this event can retrieve the detail
    value by simply referencing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`CustomEvent` exists for more than just manually triggering native event types;
    it is also possible to create your own event types. The name that''s passed to
    an event object when it is created may be any string you choose. By listening
    for that event, you are able to handle it just like events built into the JavaScript
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Native Event Triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many native event types in the JavaScript language, some with actions
    and some without. So far, you have seen the `click` event being used, but there
    are far more than that. The mouse events group alone includes `15` different event
    types, and there are over `40` different groups of events, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element focus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS animations and transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard interactivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element drag and drop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Window and document events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are even events that occur through touch screen display interaction, virtual
    reality headsets, device battery changes, smartcard events, and many, many more.
  prefs: []
  type: TYPE_NORMAL
- en: Event Hander Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building out your HTML page, the HTML specification also caters to infix
    event handling notation. This is where event handlers are assigned within the
    HTML nodes themselves. Infix event notation is known in HTML as event attributes.
    There are numerous available event attribute types, though not as many as there
    are event types provided by JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event attributes typically have names that are identical to their native JavaScript
    event type counterparts but are prepended with the word `on`. For instance, the
    `click` event would be assigned to a node as the `onclick` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The value of the event attribute is an executable JavaScript statement, such
    as a function invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'DOM nodes can only support one event attribute of each type; it is not possible,
    for instance, to provide two `onclick` attributes in a single node. However, event
    attributes can execute multiple statements within a single attribute by ensuring
    the correct use of the semi-colon character to distinguish the separate statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions called as event attribute handlers are not passed an event object.
    However, unlike typical event handlers, they can be called with additional parameters.
    For instance, to pass a reference to the node containing the event attribute,
    the event attribute function statement can be passed the `this` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, `this` resolves as the first parameter, which is a reference
    to the `div` node.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers consider event attributes to be a last resort since their inclusion
    mixes the view (HTML) with the logic (JavaScript). The recommended option is to
    always assign event handlers dynamically using `addEventListener`.
  prefs: []
  type: TYPE_NORMAL
- en: Events and Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, the `delete` keyword was introduced and a chapter regarding
    memory management was touched upon. When working with event handlers, managing
    memory becomes very important. If an event handler is attached to a node but that
    node is then removed from the page `DOM`, it may not be cleaned up by the JavaScript
    engine's `garbage collector` (cleaned from memory) until the handler is removed
    from the node. This is particularly true if the event handler is not an anonymous
    function.
  prefs: []
  type: TYPE_NORMAL
- en: When using events against nodes that may be deleted from the `DOM`, ensure you
    perform a proper cleanup of your nodes and handlers. This may mean removing the
    event handlers and properly deleting a variable's contents prior to removal.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are an integral part of the HTML specification and exist separately to
    the JavaScript engine, though they are also fully interactive with JavaScript.
    HTML forms are declarative structures are defined using the `form` tag. This tag
    outlines a context that can be submitted, and its data is sent to a remote server
    location.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how the `form` tag works, it helps to understand HTTP requests,
    their type differentiation, and how data is sent within the request.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP is a specification, the long form of which is `HyperText Transfer Protocol`.
    It was originally released as `HTTP 1.0` in 1990 and detailed in the `RFC 1945`
    specification (where 1945 is the specification number, not a year). This transport
    format was designed for the transfer of HyperText documents across the internet,
    such as `HyperText Markup Language` (HTML) documents.
  prefs: []
  type: TYPE_NORMAL
- en: Within the HTTP specification, numerous metadata is identified that can be sent
    with an `HTTP request`. This metadata is known as **headers**, as it sits within
    the starting bytes of a request packet and is used to identify how the request
    is read.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP protocol provides an option to identify the purpose of the request
    packet, known as the `Method`. There are numerous `Method` options available,
    some of which are parsed and read differently by the HTTP servers that receive
    them, though their use may also be simply contextual. Two of the most common HTTP
    `Methods` are `GET` and `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` is a method that simply means "`get me information at this address`",
    where the address is the URL the request was sent from. When making a `GET` request,
    parameters may be appended to the address in the form of query variables or as
    part of the path itself, which the server could then make use of in some way.
    However, in early versions of the `HTTP protocol`, `Uniform Resource Locator`
    (`URL`) addresses were only supplied with up to `255` characters, including the
    protocol and domain address, which proved tricky for larger amounts of data, including
    file uploads. To alleviate this problem, the specification also provides a `Method`
    called `POST`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` is an extension of `GET` and allows us to include a request `body`.
    In an HTTP request, a `body` is the packet content that is included after the
    headers; thus, it is the literal packet body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: HTTP packet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: HTTP packet'
  prefs: []
  type: TYPE_NORMAL
- en: Since nothing follows the `body` in the request packet, the `body` is able to
    be much larger than the `GET` limitation of `255` characters.
  prefs: []
  type: TYPE_NORMAL
- en: When sending a `body` with a request, the sender is able to provide a `Content-Type`
    header, which describes the format (or MIME type) of the `body`. For instance,
    if the body is a `JavaScript Object Notation` (`JSON`) string, then the request's
    `Content-Type` may be `application/jpeg`.
  prefs: []
  type: TYPE_NORMAL
- en: The Form Tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `form` tag has existed in HTML since its public inception and is detailed
    in the `HTML RFC 1866` specification. The `form` tag typically encloses elements
    of a literal form, presented visibly to users of an HTML page. As with any HTML
    node, a `form` tag may be styled visually or left invisible as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The attributes of the form tag include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: Form Tag attributes and their description'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.12: Form Tag attributes and their description'
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to the HTTP packet specification, the `method` attribute is equivalent
    to the method of the HTTP packet itself, the `action` is the same as the URL parameter,
    and the `enctype` is the same as the **Content-Type** header value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `form` tag provides a logical request block around groups of input controls.
    Each `form` tag within a web page needs to be submitted for a request to be formulated
    and sent. Submission can occur dynamically with JavaScript or via user interaction
    through the use of a `submit` button control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When you prefer direct user interaction, forms may be submitted using either
    a `submit` or an `image` input control, where the latter provides a means to display
    a styled graphic as the submission button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Submitting a Form with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, it is not appropriate to send a `form` request via user interaction.
    Instead, forms may send data after an animation has completed or perhaps redirect
    a user once their browser capabilities have been discovered. At such times, it
    helps to be able to trigger a form's submission dynamically using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all DOM-based interaction, submitting a form first requires the acquisition
    of the form node. Once acquired, a form can be submitted by simply calling its
    `submit` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that more than one form tag may exist within a page. Form tags may include
    identification and style-based attributes, the same as any other tag, such as
    `name`, `id`, `class`, and `style`.
  prefs: []
  type: TYPE_NORMAL
- en: Form Submission Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `form` tag supports a number of useful events oriented around controls and
    form handling. The most useful of these events is the `submit` event.
  prefs: []
  type: TYPE_NORMAL
- en: The `submit` event is dispatched when the form is submitted, but prior to the
    request actually being sent to the designated endpoint. This event is typically
    used for validating the user-supplied values of the form to ensure that no obvious
    mistakes were made or to ensure that the required fields have been completed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since the `submit` event is dispatched before the request is sent, be sure not
    to redirect the user to another page using this event or to do anything that will
    prevent the form submission from completing. If you wish to halt the form's submission,
    see the Preventing Form Submission section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like many events, the `submit` event handler may be assigned to a form node
    using explicit HTML attribute syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `submit` event functions just like any other event, meaning that it captures
    from and bubbles to the `document` node.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Form Submission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stopping a `form` from submitting is a common requirement in HTML and JavaScript.
    Often, if the validation of the `form` fails, it is preferable to cancel the submission
    and display appropriate messages to the user. To cancel a `form` submission, we
    could call the `preventDefault` method of the event, which stops the eventual
    action of the event, just like it does with other event types. An alternative
    method is to return the `false` value from the function.
  prefs: []
  type: TYPE_NORMAL
- en: Returning `false` from an event handler has the same effect as calling the event's
    `preventDefault` function, but it doesn't halt the capturing/bubbling.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your function is handling a jQuery event, returning `false` is the same
    as performing both the `preventDefault` and `stopPropagation` method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Resetting a Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resetting a form means returning the form to its initial state. This feature
    is provided as a way to restore a form to a clean state, or if the form was loaded
    with default or original values, then it returns those values to each of the controls.
  prefs: []
  type: TYPE_NORMAL
- en: Website users may sometimes require a reset capability if they're working with
    complex values. Being able to reset a form saves the user from having to memorize
    the initial values present in the form, or at least to quickly return to the original
    state prior to repopulating the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like submitting, resetting a form may be carried out via user interaction through
    the use of a reset input control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Once the control has been clicked, the `form` will revert to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another means to reset a form is by using the `reset` method of the `form`
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A `form` `reset` cannot be reversed automatically. If such a feature is required,
    all the values of the form will need to be saved first and then individually reapplied
    to the controls.
  prefs: []
  type: TYPE_NORMAL
- en: Form Reset Event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When resetting a form, the browser will raise the `reset` event. The handler
    for the reset event may be applied explicitly within the HTML node''s declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, form reset events may be handled by simply assigning the event handler
    with JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 6.05: Simple Form Handling'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a simple form with `submit` and `reset` buttons.
    When submitting, the form action will be canceled, but the submitted values will
    still be handled and displayed on the screen. This is the first step to creating
    a form validation system. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the standard opening HTML boilerplate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the opening form tag. This will be given an ID, for ease of acquisition,
    and will provide a random action URL since it won''t be used in this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this more interesting, let''s introduce a simple `text` field control.
    It won''t be used, per se, but it will help demonstrate the reset functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Input controls will be discussed in the next section of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you will need the two buttons: one for `submit` and one for `reset`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s close out the `form` tag and open the `script` tag, ready for
    our JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `reset` button handler will be simple. Once clicked, display a message
    in the console. However, you won''t be attaching the handler to the button''s
    `click` event as doing that will not provide the power to stop the `reset`, should
    you wish to. Instead, the event will be assigned to the form''s `reset` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Likewise, with the `submit` handler, the form''s `submit` event will be listened
    to. In this instance, however, you will call `ev.preventDefault()` from the handler
    to prevent the form from actually submitting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, close out the `script` tag and the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.13: Form buttons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.13: Form buttons'
  prefs: []
  type: TYPE_NORMAL
- en: That's it. Now, if you run the page in the browser, you will see that clicking
    `submit` will display one message in the console, while the `reset` button will
    show another. Also, clicking `reset` will always revert the text in the text field
    to the words original text.
  prefs: []
  type: TYPE_NORMAL
- en: Form Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form tags are pretty useless without data to send. This data is typically provided
    using the various form controls or widgets that are available in the HTML specification.
    Where possible, and where the control has no child nodes, a form control typically
    utilizes the `input` node tag type. Other controls include `select`, `textarea`,
    `button`, and `datalist`. We will look at each of these control types throughout
    the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Input Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The majority of the controls that are available to HTML forms are provided
    using the `input` tag. The `input` tag requires a `type` parameter, which displays
    a relative control within the HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The following are the types that are available in modern browsers when using
    the `input` control.
  prefs: []
  type: TYPE_NORMAL
- en: The Button Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `button` control appears very much like the `submit` and `reset` form buttons.
    However, unlike `submit` and `reset`, the `button` control has no default action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `button` control also has an alternative tag format, which we can use by
    using the `button` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `input` format requires a label to be passed in the `value` attribute,
    while the `button` tag format requires the button text to be passed as content
    using a closing `button` tag, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: Button input control'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.14: Button input control'
  prefs: []
  type: TYPE_NORMAL
- en: The button control supports the `click` event, or the `onclick` attribute, as
    we explained earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Checkbox Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `checkbox` control represents a "true or false," "on or off," or "yes or
    no" control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The `checked` parameter in the preceding example is a valueless attribute. When
    supplied, the `checkbox` is presented checked by default and will be set to check
    whether the encompassing `form` is reset.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative implementation of this is to supply a value for `checked`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Any values supplied with valueless attributes are disregarded, and thus any
    value may be provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: Checkbox input control'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.15: Checkbox input control'
  prefs: []
  type: TYPE_NORMAL
- en: The `checkbox` control supports the `change` and `input` events. The `input`
    event will be dispatched whenever the `value` parameter of a control is changed,
    while the `change` event is raised only when the `value` of that control is committed,
    such as when losing focus or when the *Enter* key is pressed. Typically, there
    is very little difference between the two events when they're used with the `checkbox`
    control, though it is deemed preferable to always use the `change` event.
  prefs: []
  type: TYPE_NORMAL
- en: When a `checkbox` is present in a form, its value is only submitted if it is
    `checked`. When unchecked, no value is passed to the handling script at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the checked status of a checkbox using JavaScript, simply query its
    `checked` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The value of `checked` will be `true` if the control is checked, or `false`
    if it isn't.
  prefs: []
  type: TYPE_NORMAL
- en: To set the `checked` state of the control, simply pass a `Boolean` value to
    the `checked` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The Radio Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `radio` control is similar to the `checkbox` control, with the exception
    that it handles multiple-choice options. Unlike a `checkbox` control, a `radio`
    control cannot be deselected by clicking on it. Instead, a different option must
    be selected, thereby providing at least one result when submitting the `form`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` attribute of the `radio` control provides the grouping functionality.
    If a different `name` is provided from previous `radio` controls, then that new
    control belongs to a different group. Only by clicking the `radio` controls within
    the same group can the previously selected `radio` control be deselected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: Radio input control'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.16: Radio input control'
  prefs: []
  type: TYPE_NORMAL
- en: Like the `checkbox` controls, the `radio` control is selected using the `checked`
    attribute. If a `radio` control group is present within a page, but none of the
    controls have been set to `checked`, none of those `radio` controls will be selected.
    At such times, submitting the parent form will mean that the `radio` group is
    absent from the sent data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To dynamically check a specific `radio` button (and thus uncheck the currently
    selected one), there needs to be a means to reference the specific `radio` control
    you wish to check. There are several ways to do this, such as providing a unique
    `id` for each `radio` control in a group, but by far the most efficient is to
    simply reference its index in the group. For instance, to select the second `radio`
    button in a group, we may do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`getElementsByName` returns an array of all the elements matching the passed
    criteria. Therefore, providing an index enables direct access to a given element
    index.'
  prefs: []
  type: TYPE_NORMAL
- en: '`radio` control supports the `input` and `change` events, much like the `checkbox`
    control.'
  prefs: []
  type: TYPE_NORMAL
- en: The Text Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `text` control is the most basic of all `input` control types and is used
    to create free-text fields. These fields allow for single-line text strings to
    be entered using the keyboard, though text may also be pasted into it using the
    browser context menu. Text fields are created by setting the `type` attribute
    of the `input` control to `text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The permissible content of a `text` control may be restricted by supplying
    a `pattern` attribute value in the form of a regular expression. As an example,
    a text field can be restricted to accept only numerical values with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the preceding text field, submitting a value other than a number
    will result in the form submission terminating and a tooltip displaying alongside
    the `text` field with the text **Enter a number**. The form data will not be submitted
    under this circumstance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: Text input control with the pattern attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.17: Text input control with the pattern attribute'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of the `text` field is the `placeholder` attribute. Placeholders
    allow for temporary text to exist within the field itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This text does not constitute a value of the control, so the submission of
    the container form will not yield the `placeholder` value. Likewise, querying
    the text control''s `value` attribute will not return the `placeholder` value
    if it is visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18: Text input control with placeholder attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.18: Text input control with placeholder attribute'
  prefs: []
  type: TYPE_NORMAL
- en: The Password Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `password` control works very similarly to the `text` field control, but
    with a couple of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary difference with the `password` control is that any value present
    in the control is presented to the user as a series of dots, known as a hash,
    rather than as the value text itself. The purpose of the hash is for the value
    to be unreadable by the user and, thus, provide a level of security from unwanted
    attention. The user is, therefore, expected to already know the value contained
    within the field. When submitting the form, the value is correctly passed with
    the form data as clear text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19: Password input control'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.19: Password input control'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difference with the `password` control over the `text` control is that
    it is not possible to highlight its content and copy it. Any attempt to copy the
    content of a `password` control is ignored. This prevents malicious users from
    copying and pasting the value of a `password` control into a text editor, or other
    such software, thus making the value text clearly readable. However, despite this,
    it is still possible to reference the control with JavaScript and output its value
    that way, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: email, tel, and url Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `email`, `tel`, and `url` controls are modern variations of the text field
    control. They can be created by simply passing email, tel, or url as the type
    attribute of the input control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'By themselves, each of these controls provides no additional functionality
    over the standard `text` control. All of the attributes, events, and visual look-and-feel
    of these controls are identical to the `text` control and to one another. However,
    the benefit of these types becomes apparent when they''re used with devices that
    present an on-screen keyboard, such as mobile phones and tablets. By using one
    of these `input` types, rather than a `text` control, the visible keyboard that''s
    presented to input text into them is typically oriented toward the control''s
    content type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20: Mobile keyboards for the text, email, tel, and url controls'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.20: Mobile keyboards for the text, email, tel, and url controls'
  prefs: []
  type: TYPE_NORMAL
- en: Note that additional work is needed to ensure that the content of the field
    is appropriate for the field format. This can be accomplished using the `pattern`
    attribute and form validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: The Hidden Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `hidden` control is a very useful field for storing data to be passed to
    the handler of a form, such as a remote server endpoint, without the user of the
    web page being aware of its existence. As its name implies, the `hidden` field
    is hidden from the user and has no visible presence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Many of the attributes provided by the input tag are irrelevant when using the
    `hidden` control since it is not a control that a user will interact with. However,
    its `value`, `id`, and `name` attributes will prove useful and can be used and
    manipulated in the same way as the `text` control.
  prefs: []
  type: TYPE_NORMAL
- en: The Number Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `number` field appears similar to a `text` field but will naturally constrain
    all text input to numerical values, the addition and subtraction symbols, and
    the period symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In some browsers, the number control will also present small up and down arrow
    buttons, which can be used to increment or decrement the contained value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21: Number control'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.21: Number control'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of a `number` control can be further constrained by using its `min`,
    `max`, and `step` attributes. The `min` and `max` attributes are self-explanatory
    and constrain possible numeric entry values to these attributes. For instance,
    providing a `min` value of 0 will ensure a negative number cannot be entered,
    while a `max` value of 100 will ensure the value never exceeds 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `min` and `max` does not mean a value outside of these constraints cannot
    be physically entered as input into the control from the keyboard, but merely
    that the constraints cannot be breached when clicking on the provided arrow buttons
    or that any provided value outside of these parameters will be accepted when submitting
    the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22: Number control constraints'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.22: Number control constraints'
  prefs: []
  type: TYPE_NORMAL
- en: 'The step attribute provides a means to increase the rate at which the arrow
    buttons increase or decrease the value. For instance, if large numbers are allowed
    within the control, incrementing by 1 with each click may be impractical. Therefore,
    setting a larger step size would allow the value change to happen with fewer clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: When using step, the change in value when clicking the arrow buttons will change
    at a rate of the step value from whatever value is currently present within the
    control. Therefore, setting a step of 5 will not constrain the contained value
    to multiples of 5.
  prefs: []
  type: TYPE_NORMAL
- en: The Image Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `image` control works as a hybrid of an `img` tag and a `submit` input
    control. The idea here is that you can use a graphical image as a submit button.
    You specify the image source using the `src` attribute, much like we do with the
    `img` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'An additional benefit to using an `image` input control is that once it''s
    clicked, the x and y coordinates of the mouse in relation to the image are also
    sent with the form data as an `x` and `y` value. This can prove very useful if,
    for instance, you wish to register a location on a map as part of form submission,
    or if you wish to determine the area of the image that the user clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The availability of the `image` control means forms can be stylized beyond the
    confines provided by HTML button controls and can be very popular with web designers.
  prefs: []
  type: TYPE_NORMAL
- en: The File Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `file` control is a requirement when uploading files to a remote server.
    In fact, it is not actually possible to upload a file dynamically without using
    the `file` control in some way. This is due to security as it is unethical to
    be able to dynamically upload files from a user''s machine without their knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The `file` control is typically presented to the user as a `text` field and
    `label` pair. It is possible to style the control so that one of these items,
    or both, is not visible to the user. The text that's supplied within the button
    and label is fixed by the browser and requires some extreme styling to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23: File control'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.23: File control'
  prefs: []
  type: TYPE_NORMAL
- en: When using the `file` control to upload files to a server, it is important to
    set the `enctype` parameter of the surrounding form to `"multipart/form-data"`.
    This value informs the form submission on how to encode the data when sending
    it to the server. Failure to do this will prevent the file from uploading since
    files typically require multiple packets to successfully transfer all of the file's
    data bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file control supports an accept attribute value, which enables the filtering
    of accepted file format types. This attribute can support more than one value,
    but they must be supplied as MIME types (a predefined string representation of
    a file''s type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, only files with a .png, .jpg, or .jpeg extension will
    be visible when selecting files through the control.
  prefs: []
  type: TYPE_NORMAL
- en: The Textarea Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the `text` control is great for accepting single lines of text, the `textarea`
    control is required for capturing multiline text values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: As the name implies, the `textarea` control supports an area of text and is,
    therefore, a larger control than many of the `input` controls. Like the `button`
    tag, the `textarea` control consists of both an opening and a closing tag. Any
    text that's supplied between the tags makes up its text content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the textarea doesn''t utilize a value attribute, its content may still
    be read and set using the `value` attribute in JavaScript, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 6.24: Textarea control'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.24: Textarea control'
  prefs: []
  type: TYPE_NORMAL
- en: The Select Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `select` control provides the functionality of a drop-down list control.
    Like `textarea`, the `select` control utilizes an opening and closing tag, both
    of which form the body of the control. However, the items within the control are
    provided as an additional tag, called `option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The `option` elements of a `select` control typically contain two values: the
    `value` attribute and the `text` body. These are known simply as the `value` and
    `text`. The text contained between the opening and closing `option` tags is the
    string that''s visible to the user within the control, while the `value` attribute
    is the string to be sent when the form is submitted if that particular `option`
    element is selected. When adding `option` elements, the `value` attribute may
    be omitted, but this will mean the `text` value will be sent with the form data
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to checkboxes and radio buttons, an option value may be preselected
    by passing the selected attribute to one of the option values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The select control can be displayed in two formats. The standard format is
    as a dropdown (or combo) list control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25: Select control'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.25: Select control'
  prefs: []
  type: TYPE_NORMAL
- en: 'The secondary format is displayed if the control needs to support multiple
    simultaneously selected options. As such, the control is displayed as a permanently
    open list control, with scrollable options. The `select` control can support multiple
    selected options by supplying the `multiple` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'When displayed, the user must press and hold the Ctrl key on the keyboard while
    selecting items. If the Ctrl key is not pressed, then selecting an item will deselect
    any previously selected items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26: Select control with multiple attributes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.26: Select control with multiple attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a dropdown `select` control, it is possible to get the value
    of the selected `option` by simply querying the `select` control''s `value` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to output the index of the selected item by querying the
    `selectedIndex` property. Index values start at 0 (zero) for the first element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: However, when querying a multi-select list, things aren't so easy. If multiple
    items are selected, querying the `value` property would simply return the first
    selected item in the list, thus ignoring all the other selected items. Instead,
    developers need to make use of the `options` property of the `select` control
    and the `option` item's `selected` property to discern which items are selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `select` control''s `options` property returns all the `option` elements
    contained within it, regardless of their selected state. The `option` item''s
    `selected` property is simply the condition of its selected status; it''s true
    if it is selected and false if it is not. Thus, by combining these two values,
    the selected `option` elements can be discerned with a simple loop, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 6.01: Making Changes to the Model'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot has been covered in this chapter, but you should now have the knowledge
    that's required to make something visual. In this activity, your role will be
    to create a simple form that requests the title and description for a new `To-Do`
    entry which, when submitted, feeds the data to the action handler we created in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once your form is in place and its data is being handled, the model functions
    must be updated to receive this data. Create an event handler that's able to receive
    `CREATE` action events and pass them appropriately to the model.
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no visual cue that data has been successfully stored within the
    model, any updates to the model should result in a notification event being dispatched.
    This way, other areas of your application can respond accordingly as data changes.
    Your project manager has requested that a custom event be dispatched from the
    model, called `CHANGED`. This will notify any interested party that data has either
    been added, updated, or removed from the model.
  prefs: []
  type: TYPE_NORMAL
- en: To verify that the `CHANGED` event works, create a message banner at the top
    of the page that briefly displays the message "`The To-Do model has been updated`".
    This message should be present for three seconds, before being removed.
  prefs: []
  type: TYPE_NORMAL
- en: Your project manager has asked that this information is dispatched as a custom
    event, to be caught by the action handler. This event should match the action
    types already recognized by the model. Therefore, be sure to send the object as
    a `CREATE` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the following HTML in a file called `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This HTML should include the model from the previous chapter, but also a new
    JavaScript file that will contain the logic for this activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the expected output for this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27: TODO submission form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_06_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.27: TODO submission form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a custom event handler to the model. This handler should receive the `CREATE`
    state change and update the model with the new `TODO` details from the event body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `loadHandler` function to the `create_todo.js` file. This handler should
    listen for the submit button's `click` event, but also the custom `CHANGED` event
    from the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a handler function in `create_todo.js` to handle the `CHANGED` event itself.
    This handler should temporarily display a `The TODO model has been updated` message
    within the `notifications` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `TODO` to the `create_todo.js` file. This will be executed when the
    `submit` button click event is raised. This handler should parse the values of
    the form controls and dispatch them in a new `CREATE` custom event if they are
    valid. If any of the data is not valid, then sufficient error messages should
    be temporarily displayed in the `notifications` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `CHANGED` event dispatch when the model is updated. The event body should
    contain a type added and a value containing the details of the new `TODO`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run the HTML page, you will expect to see messages to be written to the
    screen when you submit the form. Remember that the model will receive and send
    events. It will not be contacted directly. The handler functions will ensure that
    the events are attached correctly and that the data has been correctly parsed
    so that it can be sent to the model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 728.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been the first chapter to have utilized an HTML page using JavaScript
    in this book, as well as the first to explain the abstract nature of the event
    messaging system. Understanding these concepts is very valuable when building
    a useful web application in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you have explored the various nuances of event message
    bubbling and capturing, along with how they can be used to control the flow of
    information within an application. You have also seen how to halt these events
    in their tracks and how to create your own custom events.
  prefs: []
  type: TYPE_NORMAL
- en: By adopting the tools and skills you've learned about in this chapter, you will
    have a foundational arsenal at your disposal so that you can tackle applications
    of any size or complexity. These skills will be honed throughout the rest of this
    book while broadening your perspective as to what is possible with this powerful
    language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will dive deeper into the JavaScript event loop and
    gain a greater understanding of the underlying technology.
  prefs: []
  type: TYPE_NORMAL
