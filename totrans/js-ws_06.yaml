- en: 6\. Understanding Core Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 理解核心概念
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to apply timeouts and intervals
    to include asynchronous functionality in applications; identify the different
    browser event types; capture and handle user interaction; intercept and prevent
    events; impersonate events to improve application user experience; summarize the
    different browser supported input controls; and work with forms, form submission,
    and form event handling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够将超时和间隔应用于应用中，以包含异步功能；识别不同的浏览器事件类型；捕获和处理用户交互；拦截和防止事件；模拟事件以改善应用用户体验；总结不同浏览器支持的输入控件；以及处理表单、表单提交和表单事件处理。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In the previous chapter, you were introduced to the many data types supported
    by the JavaScript language and runtime, including functions, JavaScript''s most
    impressive first-class data type. Understanding the differences between data types
    is an important first step for building practical, efficient, and bug-free applications.
    Software applications have many forms and may have many uses. In its simplest
    form, an application may read parameters on execution, process the data, and return
    a response. It may not even interact with any other applications or outside services.
    Terminal commands are a good example of this. For instance, executing `dir` in
    a Windows command window or `ls` in a `Linux Terminal` would simply read the contents
    of a directory on the hard disk and display the details of those files and directories
    within the Terminal window. The Linux operating system is built on the premise
    of such very small and simple applications working together to create a much larger
    ecosystem. The converse of this may be modern multiplayer video games, which typically
    react to user interaction and receive streamed data from remote locations. The
    former of these concepts can be considered much like a function: input enters
    from the top and is output somewhere within the body, typically, the end of the
    function.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你被介绍到了JavaScript语言和运行时支持的许多数据类型，包括函数，这是JavaScript最令人印象深刻的顶级数据类型。理解数据类型之间的差异是构建实用、高效且无错误的程序的重要第一步。软件应用有多种形式，可能有多种用途。在其最简单形式中，应用可能在执行时读取参数，处理数据，并返回响应。它甚至可能不与其他应用或外部服务交互。终端命令是这一点的良好例子。例如，在Windows命令窗口中执行`dir`或在`Linux终端`中执行`ls`，将简单地读取硬盘上的目录内容，并在终端窗口中显示这些文件和目录的详细信息。Linux操作系统建立在非常小且简单的应用协同工作以创建更大生态系统的前提之上。这一点的对立面可能是现代多人视频游戏，它们通常对用户交互做出反应，并从远程位置接收流式数据。这些概念中的前者可以被认为类似于一个函数：输入从顶部进入，在函数体内输出到某个地方，通常是函数的末尾。
- en: JavaScript applications can facilitate both ends of this spectrum, and indeed,
    anything in between. Modern browsers are now fully capable of providing the foundations
    for immense and processor-intensive 3D multiplayer games, responding to data from
    numerous sources, but JavaScript is also frequently used for the simplest of tasks,
    such as formatting a `string` or rounding a `number`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用可以促进这一光谱的两端，以及实际上介于两者之间的任何事物。现代浏览器现在完全能够提供构建巨大和处理器密集型3D多人游戏的基础，响应来自多个来源的数据，但JavaScript也经常用于最简单的任务，例如格式化`字符串`或四舍五入`数字`。
- en: At the core of all of these applications are `events`. Events, conceptually
    speaking, are triggers that execute code. This might, for example, be the ready
    state when a page has finished loading or a mouse event when the user clicks an
    element within the page. Typically, without events, functions won't know when
    to execute and, therefore, nothing can happen.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些应用的核心都是`事件`。从概念上讲，事件是执行代码的触发器。例如，这可能是页面加载完成时的就绪状态，或者用户在页面内点击元素时的鼠标事件。通常，没有事件，函数不知道何时执行，因此，什么都不会发生。
- en: Throughout this chapter, we will examine the options JavaScript provides for
    listening to and handling different types of events within the browser environment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查JavaScript为在浏览器环境中监听和处理不同类型的事件提供的选项。
- en: Event Types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件类型
- en: An event is simply a notification or a "`triggered`" alert within the JavaScript
    runtime. These notifications can represent practically anything but are a means
    to invoke one or more of your own functions when such an event occurs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 事件简单来说就是JavaScript运行时内的一个通知或一个"`触发`"警报。这些通知可以代表几乎所有事物，但它们是在这种事件发生时调用一个或多个你自己的函数的手段。
- en: When a web page loads, the browser will typically display content as soon as
    it is available. This means some content will be presented to the user before
    the entire page has finished downloading. The browser does this to prevent long-loading
    assets from withholding other content from being available to the user.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当网页加载时，浏览器通常会在内容可用时立即显示内容。这意味着在整页下载完成之前，一些内容将呈现给用户。浏览器这样做是为了防止长时间加载的资产阻止其他内容对用户可用。
- en: Now, imagine you want to invoke a function immediately within a web page to
    rotate an image. JavaScript code embedded into a web page is able to run immediately
    once it has been parsed by the JavaScript engine, which could possibly be before
    the image in question is available. To overcome this conundrum, JavaScript provides
    an `onload` event, which is dispatched as soon as all the page's content has finished
    downloading. By refraining from invoking your function until this event has been
    dispatched, you can ensure that your image can be rotated.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您想在网页中立即调用一个函数来旋转一个图片。嵌入到网页中的JavaScript代码在由JavaScript引擎解析后能够立即运行，这可能在相关图片可用之前。为了克服这个难题，JavaScript提供了一个`onload`事件，该事件在所有页面内容下载完成后立即触发。通过在事件触发之前不调用您的函数，您可以确保您的图片可以被旋转。
- en: 'Of course, there are many other such events. Arguably, there are four specific
    types of events within the JavaScript ecosystem:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他此类事件。可以说，在JavaScript生态系统中存在四种特定类型的事件：
- en: '**Timer events** provide forced asynchronous functionality within your applications.
    They allow you to invoke a function after a period of time, either once or repeatedly.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计时器事件**在您的应用程序中提供强制性的异步功能。它们允许您在一段时间后调用一个函数，一次或重复多次。'
- en: '`callbacks`, are dispatched when something has finished executing but has occurred
    in parallel to any other function execution in your application. This means the
    process has not stopped your application from doing other tasks.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`回调`是在某个操作执行完毕但与您的应用程序中任何其他函数执行并行发生时触发的。这意味着该过程并没有阻止应用程序执行其他任务。'
- en: '`DOM` or keyboard events, are events that are dispatched due to the user interacting
    with your application.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOM`或键盘事件，是由于用户与您的应用程序交互而触发的事件。'
- en: '**Custom events** are events that you create yourself. These can be almost
    anything but are usually created as a response to one of the JavaScript event
    types listed previously.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义事件**是您自己创建的事件。这些事件可以是几乎任何东西，但通常是在对之前列出的JavaScript事件类型之一做出响应时创建的。'
- en: The type of event you will require is very specific to a given use case. In
    this chapter, we will examine both timer-based events and interaction events.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要的事件类型非常具体，取决于特定的用例。在本章中，我们将检查基于计时器的事件和交互事件。
- en: Timer Events
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时器事件
- en: 'In some languages, such as C, the base application may be run using a continuous
    loop. In C, specifically, an application runs during the lifetime of its `main`
    function; when this function returns, the application exits. Typically, applications
    that need to run for some time and respond to events would utilize a simple loop.
    In fact, it''s not uncommon to see applications start with something like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，例如C，基本应用程序可能使用一个连续的循环来运行。具体来说，应用程序在其`main`函数的生命周期内运行；当此函数返回时，应用程序退出。通常，需要运行一段时间并响应事件的应用程序会使用一个简单的循环。事实上，看到应用程序以类似以下内容开始并不罕见：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the application simply enters an indefinite loop. If the application needs
    to quit, it would call a command similar to JavaScript's `break` keyword. Otherwise,
    the application would quite happily run and invoke functions as needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，应用程序简单地进入一个不确定的循环。如果应用程序需要退出，它将调用一个类似于JavaScript的`break`关键字的命令。否则，应用程序将非常乐意运行并按需调用函数。
- en: Applications written in C are able to do this for several reasons. The first
    is that C is a multi-threaded platform. This means that several processes, known
    as threads, can be created within a C application and may run concurrently, providing
    the underlying hardware it supports. In the worst-case scenario, these threads
    are cycled, allowing each one to utilize a period of execution time within the
    CPU. Another reason this is possible is that C applications run very close to
    the hardware and, unlike JavaScript, are unencumbered by a lower-level engine
    that dictates execution flow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用C语言编写的应用程序能够这样做有几个原因。首先，C语言是一个多线程平台。这意味着可以在C应用程序中创建多个进程，称为线程，并且可以并发运行，前提是底层硬件支持。在最坏的情况下，这些线程会循环，使每个线程都能在CPU中利用一段执行时间。另一个原因是C应用程序运行得非常接近硬件，并且与JavaScript不同，它们不受底层引擎的限制，该引擎决定了执行流程。
- en: Since a program can exist with a loop at its core, it stands to reason that
    functions will, or can, be called with each iteration. However, if a function
    was called indefinitely with every iteration, such a process may be overly resource-intensive
    or simply run too fast. An alternative is to make the function conditional by
    requiring it to execute only when enough time has passed since its last execution.
    This is the essential basis of a timer event.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个程序可以有一个循环作为其核心，因此可以合理地认为函数将在每次迭代中被调用，或者可以调用。然而，如果函数在每次迭代中都无限期地被调用，这样的过程可能会过于资源密集，或者简单地运行得太快。一个替代方案是使函数条件化，要求它仅在自上次执行以来经过足够的时间后才执行。这就是计时器事件的基本原理。
- en: Unlike C, JavaScript is a `single-threaded` platform, meaning it can only execute
    a single thread throughout your entire application. A thread is an execution space
    in the CPU. If you have one thread, then only a single series of function executions
    can occur at once. In JavaScript, this does not mean the underlying engine doesn't
    use, or have access to, more than one thread; only that your application has programmatic
    access to one single thread.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与C语言不同，JavaScript是一个`单线程`的平台，这意味着它只能在整个应用程序中执行单个线程。线程是CPU中的执行空间。如果你只有一个线程，那么一次只能发生一个函数执行序列。在JavaScript中，这并不意味着底层引擎不使用或没有访问多个线程；只是你的应用程序只能程序化地访问一个线程。
- en: Since JavaScript runs within an engine, known as a virtual machine, it is driven
    by a number of rules that determine how your code is run. The JavaScript virtual
    machine follows an architecture known as an event loop. This means that the loop
    in the preceding C example is already occurring within the JavaScript engine that
    your application runs within. However, within that loop, the JavaScript engine
    manages code execution for each of the function calls your application makes,
    among other things, regardless of whether those calls invoke your own functions
    or those native to JavaScript.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript在虚拟机（也称为引擎）中运行，它遵循一系列规则，这些规则决定了你的代码是如何运行的。JavaScript虚拟机遵循一个称为事件循环的架构。这意味着前面C语言示例中的循环已经在你的应用程序运行的JavaScript引擎中发生了。然而，在这个循环中，JavaScript引擎管理着应用程序中每个函数调用的代码执行，包括调用你自己的函数或JavaScript的本地函数。
- en: 'Exercise 6.01: Custom Timer'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.01：自定义计时器
- en: 'As we mentioned previously, many developers coming from lower-level languages
    will consider a loop as a means to create timed function invocations. If a loop
    can occur indefinitely, then we only need to check the current system time and
    invoke functions when sufficient time has passed. For instance, when animating,
    in order to control the `speed` of the animation, you may want to ensure your
    frame update functions are executed with a sufficient period of time between each
    invocation. Without this control, your animation frames will update with every
    possible cycle of the JavaScript runtime, which may be very fast on some machines,
    while not so fast on weaker machines. In this exercise, you will implement one
    such loop. Let''s get started:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，许多来自底层语言的开发者会将循环视为创建定时函数调用的手段。如果一个循环可以无限发生，那么我们只需要检查当前系统时间，并在足够的时间过去后调用函数。例如，在动画处理中，为了控制动画的`速度`，你可能希望确保你的帧更新函数在每次调用之间有足够的时间间隔。如果没有这种控制，你的动画帧将随着JavaScript运行时的每个可能的周期更新，这在某些机器上可能非常快，而在较弱的机器上则可能不那么快。在这个练习中，你将实现这样一个循环。让我们开始吧：
- en: 'To begin, you''ll need three variables. The first will store the current time
    in milliseconds for each iteration, the second variable will contain the time
    in milliseconds of the last time the custom timer function executed, and the third
    variable will be the required minimal interval between timer function calls in
    milliseconds:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要三个变量。第一个将存储每次迭代的当前时间（以毫秒为单位），第二个变量将包含自定义计时器函数上次执行的时间（以毫秒为单位），第三个变量将是计时器函数调用之间所需的最低间隔（以毫秒为单位）：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we open the `main` function and the indefinite loop. Similar to the preceding
    example, we''ll simply use a `while` loop and pass it a decrementing value:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们打开 `main` 函数和无限循环。类似于前面的例子，我们将简单地使用 `while` 循环并传递一个递减的值：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, the first thing that needs to happen with each iteration is that we need
    to get the current time in milliseconds and compare it to the last stored time:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每个迭代需要发生的第一件事是获取当前时间（以毫秒为单位）并将其与上次存储的时间进行比较：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `lastTime` variable, if it is `null`, will be passed the value of `curTime`.
    This way, it will execute correctly from its first iteration since `null` cannot
    be deducted from an `integer`.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `lastTime` 变量是 `null`，它将被赋予 `curTime` 的值。这样，它将从第一次迭代开始正确执行，因为 `null` 不能从
    `integer` 中减去。
- en: 'If the values are sufficiently different (greater than the `interval` amount),
    you can invoke your timed functions. You will then need to update the `lastTime`
    variable to equal the current time so that the function doesn''t execute again
    in succession and instead waits for the next duration to occur:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值足够不同（大于 `interval` 数量），你可以调用你的定时函数。然后你需要更新 `lastTime` 变量，使其等于当前时间，这样函数就不会连续执行，而是等待下一个持续时间发生：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, you close out the conditional, loop, and function:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要关闭条件语句、循环和函数：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That''s it. If you execute the function by calling `main()`, you will see the
    current time in milliseconds output to the console every `500` milliseconds:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样。如果你通过调用 `main()` 来执行函数，你将看到每 `500` 毫秒在控制台输出当前时间：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What you have just created is similar to an application loop. Many programming
    languages support the notion of an application loop. In fact, languages such as
    C++ require such a loop in order to prevent an application from exiting. In such
    circumstances, the loop is a simple "`keep-alive`" mechanism whereby checks for
    potential events occur manually within the loop. In JavaScript, such loops are
    unnecessary. This is because the JavaScript engine already enlists the help of
    such a loop under the hood, known as the event loop.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建的是类似于应用程序循环。许多编程语言支持应用程序循环的概念。事实上，像 C++ 这样的语言要求这样的循环以防止应用程序退出。在这种情况下，循环是一个简单的
    "`保持活动状态`" 机制，其中在循环中手动检查潜在的事件。在 JavaScript 中，这样的循环是不必要的。这是因为 JavaScript 引擎已经在幕后提供了这样的循环的帮助，称为事件循环。
- en: Event Timers
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件计时器
- en: The previous exercise exhibits perfectly legitimate code and would facilitate
    a working function invocation timer. However, creating timers in this fashion
    has a number of drawbacks. The first issue here is that since JavaScript is single-threaded,
    the entire application will be contained within the loop. There is no way to continue
    processing data outside of the loop without breaking out of it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个练习展示了完全合法的代码，并且可以方便地实现一个工作函数调用计时器。然而，以这种方式创建计时器有许多缺点。首先的问题是，由于 JavaScript
    是单线程的，整个应用程序将包含在循环中。没有方法可以在不跳出循环的情况下继续处理循环外的数据。
- en: 'The second issue in the previous exercise is that since the JavaScript engine
    is already running its own event loop, the example code is actually performing
    two infinite loops, one nested within the other:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个练习的第二个问题是，由于 JavaScript 引擎已经运行自己的事件循环，示例代码实际上执行了两个无限循环，一个嵌套在另一个内部：
- en: '![Figure 6.1: Nested infinite event loop'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1：嵌套无限事件循环'
- en: '](img/C14377_06_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_01.jpg)'
- en: 'Figure 6.1: Nested infinite event loop'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：嵌套无限事件循环
- en: Since delayed and repeated function invocation is a common programming requirement,
    the JavaScript language provides two functions that make timers simple without
    us having to construct our own loops. These are `setInterval` and `setTimeout`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于延迟和重复函数调用是常见的编程需求，JavaScript 语言提供了两个函数，使得计时器简单，无需我们构建自己的循环。这些是 `setInterval`
    和 `setTimeout`。
- en: The setInterval Function
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`setInterval` 函数'
- en: '`setInterval` is a native implementation of our previous infinite loop. The
    premise is that, given a function and an interval value in milliseconds, JavaScript
    will repeatedly execute the function whenever the interval time has passed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval`是我们之前无限循环的原生实现。前提是，给定一个函数和一个以毫秒为单位的间隔值，JavaScript将在间隔时间通过时重复执行该函数：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The time-based execution in JavaScript is "as near to" the interval value as
    possible. JavaScript is unable to guarantee absolute accuracy when executing triggers
    due to various limitations with the underlying hardware, operating system, and
    resource availability.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的基于时间的执行尽可能接近间隔值。由于底层硬件、操作系统和资源可用性的各种限制，JavaScript无法保证在执行触发器时的绝对准确性。
- en: 'We can reproduce our previous example with the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码重现先前的例子：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The function expression in this example will be executed `500` milliseconds
    after we call `setInterval` and every `500` milliseconds thereafter. It is executed
    asynchronously, so the code that follows the `setInterval` call is executed without
    delay:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`setInterval`后`500`毫秒以及之后的每个`500`毫秒，这个示例中的函数表达式将被执行。它是异步执行的，所以`setInterval`调用之后的代码将无延迟地执行：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `setInterval` function itself, when invoked, returns a reference to the
    resulting interval handler, that is, the execution stack that invokes the passed
    `callback` function. This reference may be used to terminate the interval loop
    at any time using the `clearInterval` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`setInterval`函数时，它本身会返回一个指向结果间隔处理程序的引用，即调用传递的`callback`函数的执行栈。这个引用可以用来在任何时候使用`clearInterval`函数终止间隔循环：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The setTimeout Function
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`setTimeout`函数'
- en: 'The `setTimeout` function works identically to the `setInterval` function,
    the difference being that its passed `callback` function is only ever called once.
    The `setTimeout` function is useful when animating elements within an HTML page,
    or when you wish to delay a process for a period of time, such as clearing a visible
    error message or dialog:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout`函数与`setInterval`函数工作方式相同，区别在于其传递的`callback`函数只被调用一次。`setTimeout`函数在动画HTML页面中的元素或当你希望延迟一段时间的过程时（例如清除一个可见的错误消息或对话框）非常有用：'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Like `setInterval`, the `setTimeout` function also returns a reference to its
    execution handler so that the timer can be cleared with `clearTimeout`. Since
    the `setTimeout` callback is only executed once, calling `clearTimeout` after
    the `callback` has executed has no effect. It is, however, possible to cancel
    `setTimeout` before it executes, which is a perfectly reasonable requirement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与`setInterval`一样，`setTimeout`函数也返回一个指向其执行处理程序的引用，以便可以使用`clearTimeout`清除定时器。由于`setTimeout`回调只执行一次，在`callback`执行后调用`clearTimeout`没有效果。然而，在它执行之前取消`setTimeout`是完全合理的：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `setTimeout` function can be mimicked by the `setInterval` function by
    simply clearing its reference after its first timer iteration, like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在第一次定时器迭代后清除其引用，`setTimeout`函数可以被`setInterval`函数模拟，如下所示：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Timer Parameters
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时器参数
- en: 'In modern browsers (excluding `IE9` and below), the `setInterval` and `setTimeout`
    functions may receive additional parameters. If any are supplied proceeding the
    interval parameter, those additional parameters will be passed as parameters to
    the `callback` function when it is invoked. This provides a useful means to customize
    timer functions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代浏览器中（不包括`IE9`及以下版本），`setInterval`和`setTimeout`函数可以接收额外的参数。如果提供了间隔参数之前的任何参数，这些额外的参数将在调用时作为参数传递给`callback`函数。这为自定义定时器函数提供了一种有用的方法：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you anticipate older browsers running your scripts, the same effect may
    be attained by wrapping the passed `callback` within an anonymous function call:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你预计较老的浏览器会运行你的脚本，可以通过将传递的`callback`包裹在一个匿名函数调用中达到相同的效果：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Exercise 6.02: Real-Time Clock'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02：实时时钟
- en: 'It is now time to put your knowledge of timers to use. In this exercise, you
    will be creating a real-time in-page clock display that will count up in seconds
    and show the full time using a 24-hour digital clock format. This exercise will
    make use of an HTML file, albeit a simple one. Let''s get started:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将你对定时器的知识付诸实践了。在这个练习中，你将创建一个实时页面时钟显示，它会以秒为单位递增，并使用24小时数字时钟格式显示完整的时间。这个练习将使用一个HTML文件，尽管它很简单。让我们开始吧：
- en: 'Create a new file called `script` tag:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`script`的新文件：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `script` tag will contain the JavaScript to be executed within the page.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`script`标签将包含要在页面中执行的JavaScript代码。'
- en: 'Next, you''ll need some placeholder variables for the `seconds`, `minutes`,
    `hours`, and the current `Date` object instance:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要一些占位符变量用于 `seconds`、`minutes`、`hours` 和当前的 `Date` 对象实例：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `handler` function you''ll use for the timer will also be assigned to a
    variable called `setTime`. In it, you will simply populate the preceding variables
    with the current time components:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将用于计时器的 `handler` 函数也将分配给一个名为 `setTime` 的变量。在其中，你将简单地用当前的时间组件填充前面的变量：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To output the time to the page, you''ll simply need to update the `body` content.
    There are better solutions to this that will be explained later in this module:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将时间输出到页面，你只需更新 `body` 内容。这个模块后面会解释更好的解决方案：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, close the function and assign it to an interval. Set the interval
    to run every `500` milliseconds to ensure better accuracy:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，关闭函数并将其分配给一个间隔。将间隔设置为每 `500` 毫秒运行一次，以确保更好的准确性：
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the `script` complete, you should close out the `script` tag block:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `script` 完成，你应该关闭 `script` 标签块：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The page should end with a `body` tag block, which will contain the clock and
    the closing `html` tag:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面应该以一个包含时钟和关闭 `html` 标签的 `body` 标签块结束：
- en: '[PRE22]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, save the page and load it (or drag it) into your browser. You should see
    the time displayed in the top left-hand corner of the page, and it should update
    every second. You have successfully built your first timer-based JavaScript application.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存页面并加载到你的浏览器中（或拖动它）。你应该在页面的左上角看到时间显示，并且每秒更新一次。你已经成功构建了第一个基于计时器的 JavaScript
    应用程序。
- en: Displaying a real-time clock on a web page is a practical application, particularly
    within corporate websites and intranets that may exhibit times for several time
    zones around the world. However, utilizing a timer to update page content is not
    limited to clocks. This same process could be utilized to update stock market
    prices, real-time chat forums, or just about any kind of real-time presentation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上显示实时时钟是一个实际的应用，尤其是在可能展示全球几个时区时间的公司网站和内部网络中。然而，使用计时器更新页面内容并不仅限于时钟。这个过程同样可以用于更新股票市场价格、实时聊天论坛或几乎任何类型的实时展示。
- en: The JavaScript Events Model
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 事件模型
- en: As we noted previously, the JavaScript engine utilizes an event loop. In fact,
    events are at the center point of the JavaScript engine and its language. At its
    simplest definition, an event is a notification that something has occurred. This
    may be interaction by the user with a web page or the completion of some process
    that occurs within the browser.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，JavaScript 引擎使用事件循环。实际上，事件是 JavaScript 引擎及其语言的核心。在最简单的定义中，事件是某种事情发生的通知。这可能是由用户与网页的交互，或者是在浏览器内完成的某个过程的完成。
- en: To make use of events, a `callback` function must be assigned to the event type,
    much like with the timer-based function. However, typically, events are a little
    more complex and feature-rich than simple timers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用事件，必须将一个 `callback` 函数分配给事件类型，就像计时器函数一样。然而，通常，事件比简单的计时器更复杂，功能更丰富。
- en: An event notification is known in programming as a dispatched event. When JavaScript
    events are dispatched, they are passed an event object. This is true of all JavaScript
    events. The event object contains useful details about the dispatched event, including
    the name of the event, a reference to the object that holds the context of the
    event, and a reference to the object that triggered the event.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，事件通知被称为已派发的事件。当 JavaScript 事件被派发时，它们会传递一个事件对象。这对于所有 JavaScript 事件都是成立的。事件对象包含有关派发事件的详细信息，包括事件名称、一个指向包含事件上下文的对象的引用，以及一个指向触发事件的对象的引用。
- en: 'The following table lists the properties of the event object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了事件对象的属性：
- en: '![Figure 6.2:  Event Object properties'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2：事件对象属性'
- en: '](img/C14377_06_02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_06_02.jpg](img/C14377_06_02.jpg)'
- en: 'Figure 6.2: Event Object properties'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：事件对象属性
- en: Event Bubbling
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件冒泡
- en: In order to understand event bubbling, it helps if we understand browser-based
    HTML. HTML is an abbreviation for HyperText Markup Language, which itself is a
    derivative of eXtensible Markup Language (XML). HTML is not really a language
    at all, but a declarative information markup that structures data, which, in the
    case of websites, is page content.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解事件冒泡，如果我们了解基于浏览器的 HTML 会很有帮助。HTML 是超文本标记语言的缩写，它本身是可扩展标记语言（XML）的衍生。HTML 实际上根本不是一种语言，而是一种声明性信息标记，用于结构化数据，在网站的情况下，是页面内容。
- en: 'HTML is a hierarchical construct that can be best envisaged as a data tree.
    Imagine the following page content:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 是一种层次结构，最好将其想象成一个数据树。想象以下页面内容：
- en: '![Figure 6.3: HTML mockup'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3：HTML 模拟'
- en: '](img/C14377_06_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_06_03.jpg](img/C14377_06_03.jpg)'
- en: 'Figure 6.3: HTML mockup'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3：HTML 模拟'
- en: 'The structure of the page consists of two columns. On the left is an image
    and on the right is a container with two rows; the first row contains three buttons
    and the second row contains a block of text. Like a tree, this layout may look
    something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的结构由两列组成。左侧是一张图片，右侧是一个包含两行的容器；第一行包含三个按钮，第二行包含一段文本。就像一棵树，这种布局可能看起来像这样：
- en: '![Figure 6.4: HTML data tree'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4：HTML 数据树'
- en: '](img/C14377_06_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_06_04.jpg](img/C14377_06_04.jpg)'
- en: 'Figure 6.4: HTML data tree'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：HTML 数据树
- en: The preceding tree outlines the visible content of the page, but the `body`
    node is not the actual top of the literal HTML tree. Instead, the page content
    tree starts with a node called the `document`. This then has a child called `html`,
    and that node contains the `body` node.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的树概述了页面的可见内容，但 `body` 节点并不是实际的 HTML 树的顶部。相反，页面内容树从名为 `document` 的节点开始。然后它有一个名为
    `html` 的子节点，该节点包含 `body` 节点。
- en: Each node within the HTML tree will raise events if interacted with, even if
    that node is not immediately visible. When clicking the page with your mouse,
    for instance, the visible node beneath the mouse arrow that is closest to the
    bottom of the tree will raise a `click` event. If one or more event handlers have
    been assigned to that node, then those handlers will be invoked and will be passed
    an `event` object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 树中的每个节点在与交互时都会引发事件，即使该节点不是立即可见的。例如，当用鼠标点击页面时，最接近树底部的鼠标箭头下的可见节点将引发一个 `click`
    事件。如果已经为该节点分配了一个或多个事件处理器，那么这些处理器将被调用，并将传递一个 `event` 对象。
- en: Event bubbling occurs when event handlers are not assigned to the node for that
    event type or if the event is handled but the event is allowed to continue propagating.
    At this point, the handlers of the parent node for that specific event are called,
    and the same process occurs. If the event continues to not be explicitly halted,
    it will `bubble` through each parent node until it reaches the `document` node.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件处理器未分配给该事件的节点或事件被处理但允许事件继续传播时，就会发生事件冒泡。此时，将调用父节点对该特定事件的处理器，并且发生相同的过程。如果事件继续没有被明确阻止，它将
    `冒泡` 通过每个父节点，直到达到 `document` 节点。
- en: If multiple handlers exist on a given node for a specific event, any one of
    those handlers may halt the event, preventing it from bubbling. It is not required
    for all handlers to halt the event.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个节点上存在针对特定事件的多个处理器，任何一个处理器都可以阻止事件，防止其冒泡。不需要所有处理器都阻止事件。
- en: Traversing the Node Tree
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历节点树
- en: In order to handle an event, you first need to add an event type handler to
    a node. However, to do that, you need some way to acquire a reference to the node
    on which you wish to listen. JavaScript provides numerous functions for selecting
    and acquiring nodes based on many different factors, including direct named access,
    acquisition through node tree traversal, and acquisition by attribute value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理一个事件，你首先需要向一个节点添加一个事件类型处理器。然而，为了做到这一点，你需要某种方式来获取你希望监听的节点的引用。JavaScript 提供了多种函数，可以根据许多不同的因素选择和获取节点，包括直接命名访问、通过节点树遍历获取以及通过属性值获取。
- en: 'Of all the nodes within your HTML pages, the easiest to acquire are the `body`
    and `document` nodes. Both of these nodes have simple attribute accessors on the
    global `document` object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 HTML 页面中的所有节点中，最容易获取的是 `body` 和 `document` 节点。这两个节点都在全局 `document` 对象上具有简单的属性访问器：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you have a reference to the top of the tree, acquiring a node elsewhere
    within the tree is simply a matter of traversing it. JavaScript provides several
    properties for acquiring a node''s parent, siblings, or children, each of which
    uses the `familiar relationship` metaphor:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了树的顶部的引用，获取树中其他地方的节点就简单了，只需遍历它。JavaScript 提供了几个属性来获取节点的前一个、兄弟或子节点，每个属性都使用了
    `熟悉的关系` 比喻：
- en: '![Figure 6.5: Node properties and their description'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5：节点属性及其描述'
- en: '](img/C14377_06_05.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_06_05.jpg](img/C14377_06_05.jpg)'
- en: 'Figure 6.5: Node properties and their description'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5：节点属性及其描述'
- en: 'Each of these properties can be read from the given node. If a corresponding
    node cannot be found, then the property will return `null` (or an empty array
    in the case of `childNodes`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性都可以从给定的节点中读取。如果找不到相应的节点，则该属性将返回 `null`（或者在 `childNodes` 的情况下返回空数组）：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Direct Node Acquisition
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接节点获取
- en: Aside from node tree traversal, JavaScript also provides a means to specify
    the node reference you require by supplying a node property filter, which is a
    string value describing the node you require using a specific format.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节点树遍历之外，JavaScript 还提供了一种通过提供节点属性过滤器来指定所需节点引用的方法，该过滤器是一个字符串值，它使用特定格式描述所需的节点。
- en: 'All HTML nodes follow a certain pattern:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 HTML 节点都遵循一定的模式：
- en: They are opened and closed, sometimes in a single tag.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以打开和关闭，有时在一个标签内完成。
- en: They have a node name or type.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个节点名称或类型。
- en: They may have an optional `id` property, which should be unique to the page.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能有一个可选的 `id` 属性，该属性应对于页面是唯一的。
- en: They may have one or more optional `class` names.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能有一个或多个可选的 `class` 名称。
- en: They may have other optional known properties, such as `name`, `styles`, `type`,
    `value`, or `src`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能还有其他可选的已知属性，例如 `name`、`styles`、`type`、`value` 或 `src`。
- en: They may have optional custom properties, named by the page creator.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能有可选的自定义属性，由页面创建者命名。
- en: 'The node''s signature is known as its `tag`, which is defined within angle
    brackets, with a left-facing angle bracket at the start of the node and a right-facing
    bracket at the end of the node. Immediately after the left-facing bracket is the
    node''s name. Properties are appended to the node as `attribute="value"`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的签名称为其 `tag`，它定义在尖括号内，节点开始处有一个左向尖括号，节点结束处有一个右向括号。左向括号之后是节点的名称。属性作为 `attribute="value"`
    追加到节点上：
- en: '![Figure 6.6: HTML node structure'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6：HTML 节点结构'
- en: '](img/C14377_06_06.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_06_06.jpg)'
- en: 'Figure 6.6: HTML node structure'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：HTML 节点结构
- en: The closing tag of a node contains the node's name and is also wrapped with
    a left-facing and right-facing angle bracket. However, to differentiate it from
    a new opening tag, its left-facing angle bracket is preceded by a forward-slash
    (`/`) character.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的结束标签包含节点的名称，并且也被左向和右向的尖括号包围。然而，为了将其与新的开始标签区分开来，其左向尖括号之前有一个正斜杠（`/`）字符。
- en: 'If a node has no children, it is acceptable to immediately close the node without
    supplying a distinct closing tag. This is accomplished by providing the forward-slash
    character immediately before the right-facing angle bracket:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个节点没有子节点，则可以立即关闭节点而不提供特定的结束标签。这是通过在右向尖括号之前提供正斜杠字符来实现的：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The properties of a node are its description. Later, these values allow you
    to style the node''s look-and-feel, but they specifically facilitate the node''s
    data and identity. As such, it is perfectly legitimate to add attributes to nodes
    in order to make them easily acquirable. The `id` attribute is one such value
    that exists solely to differentiate tags and it is important that all the tags
    that are used within a page have a unique `id` attribute, if they have one at
    all. If an `id` attribute is present, the associated node can be acquired using
    the `getElementById` method of the `document` object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的属性是其描述。稍后，这些值允许您设置节点的外观和感觉，但它们特别便于节点的数据和身份。因此，向节点添加属性以使其易于获取是完全合法的。`id` 属性就是这样一种值，它仅用于区分标签，并且所有在页面内使用的标签都应该有一个唯一的
    `id` 属性，如果有的话。如果存在 `id` 属性，则可以使用 `document` 对象的 `getElementById` 方法获取相关的节点：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since node IDs are deemed to be unique, the `getElementById` method returns
    a single node, or `null` if a matching node is not found. If, for some reason,
    a page contains multiple nodes with the same ID attribute value, then calling
    `getElementById` with that value will return the first element found within the
    page.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于节点 ID 被认为是唯一的，`getElementById` 方法返回单个节点，或者在找不到匹配节点时返回 `null`。如果由于某种原因，页面包含具有相同
    ID 属性值的多节点，则使用该值调用 `getElementById` 将返回页面中找到的第一个元素。
- en: 'Other similar functions exist in order to query using other tag descriptors,
    such as the `name` or `class`. The majority of these return an array since it
    is expected that many tags may share matching descriptors. The following table
    lists some of the common functions for acquiring tag references:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 存在其他类似的功能，用于使用其他标签描述符进行查询，例如 `name` 或 `class`。其中大多数返回一个数组，因为预期许多标签可能共享匹配的描述符。以下表格列出了获取标签引用的一些常见函数：
- en: '![Figure 6.7: Common functions for tag references'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7：标签引用的常用函数'
- en: '](img/C14377_06_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_07.jpg)'
- en: 'Figure 6.7: Common functions for tag references'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：标签引用的常用函数
- en: Assigning and Removing an Event Handler
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配和移除事件处理程序
- en: 'Once you have a node reference, you are then able to assign listeners (or handlers)
    for specific event types. Listeners can be assigned to a node using the `addEventListener`
    function, which accepts two parameters, the type of the event as a string value
    and the handler of the event as a function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了节点引用，您就可以为特定的事件类型分配监听器（或处理程序）。您可以使用 `addEventListener` 函数将监听器分配给节点，该函数接受两个参数，即事件类型作为字符串值和事件处理程序作为函数：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When an event is dispatched, the event handler is passed a single value, known
    as an event object. Event objects may have slightly different parameters depending
    on the event type being handled. The object is actually an instance of a specific
    event object type. For instance, mouse-based events, such as `click` or `mousedown`,
    generate `MouseEvent` objects. These differ from many other events in that they
    contain `x` and `y` values detailing the mouse coordinates within the web document
    at the time the event was dispatched:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被分发时，事件处理程序会传递一个单一值，称为事件对象。事件对象可能根据处理的事件类型略有不同。实际上，这个对象是特定事件对象类型的实例。例如，基于鼠标的事件，如
    `click` 或 `mousedown`，会生成 `MouseEvent` 对象。这些对象与许多其他事件的不同之处在于，它们包含 `x` 和 `y` 值，这些值详细说明了在事件分发时鼠标在网页文档中的坐标：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When attaching an event handler, it will not overwrite existing handlers attached
    to that node, even if the handler is assigned to the same event type. In fact,
    a node may have any number of event listeners attached at any one time. This way,
    multiple facets of your application can independently access the same event notifications
    for the same object, as needed. What is not possible, however, is for the same
    `function reference` to be assigned more than once to the same event type, like
    so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在附加事件处理程序时，即使处理程序被分配给相同的事件类型，它也不会覆盖该节点上附加的现有处理程序。实际上，一个节点在任何时候都可能附加任意数量的事件监听器。这样，您的应用程序的多个方面可以独立访问同一对象的相同事件通知，如需。然而，不可能将相同的
    `函数引用` 分配给同一事件类型，如下所示：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, since the `display` function is a single reference,
    the second listener assignment was simply ignored. JavaScript will not repeat
    the function invocation more than once. However, the previous assignments were
    both invoked because, although the functionality was the same, the functions themselves
    possessed different references.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，由于 `display` 函数是单一引用，因此第二个监听器分配被简单地忽略。JavaScript 不会重复调用函数超过一次。然而，之前的分配都调用了，因为尽管功能相同，但函数本身具有不同的引用。
- en: 'If you wish to remove an event handler, you can do so with the `removeEventListener`
    method, which takes identical parameters to its counterpart:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想移除事件处理程序，可以使用 `removeEventListener` 方法，该方法接受与其对应方法相同的参数：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `removeEventListener` method finds the handler association by reference.
    This means that any event listener assignments you make using anonymous functions
    cannot be removed using the `removeEventListener` method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeEventListener` 方法通过引用查找处理程序关联。这意味着您使用匿名函数所做的任何事件监听器分配都无法使用 `removeEventListener`
    方法移除。'
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you dispose of a node that has event handlers attached to it, it will not
    be cleaned up by the JavaScript engine's `garbage Collector`. Removing nodes without
    cleaning up their event handlers is a common cause of memory leaks in JavaScript,
    which leads to poor application performance. If you know a node may be removed
    from the `DOM`, do not add event listeners to it, or its children, using anonymous
    functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您销毁了一个附加有事件处理程序的节点，JavaScript 引擎的垃圾回收器不会对其进行清理。在不清理其事件处理程序的情况下移除节点是 JavaScript
    中内存泄漏的常见原因，这会导致应用程序性能下降。如果您知道一个节点可能从 `DOM` 中移除，请不要使用匿名函数向它或其子节点添加事件监听器。
- en: 'Exercise 6.03: Tabbed Content'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.03：标签内容
- en: 'In this exercise, you''ll use what you have learned so far to create a tabbed
    display. The display will utilize three buttons at the top of the page, with a
    container `div` tag at the bottom. When a button is pressed, content associated
    with the button handler will be displayed within the container `div` tag. Let''s
    get started:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用到目前为止所学到的知识来创建一个标签显示。显示将使用页面顶部的三个按钮，底部有一个容器 `div` 标签。当按下按钮时，与按钮处理程序相关的内容将在容器
    `div` 标签内显示。让我们开始吧：
- en: 'First, create a new document called **tabs.html** and add the starting HTML:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为**tabs.html**的新文档，并添加起始HTML：
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The three buttons will sit side by side in a single container `div`. Each one
    will have a unique ID so that we can easily reference them:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个按钮将并排放置在一个单独的容器`div`中。每个按钮都将有一个唯一的ID，这样我们就可以轻松引用它们：
- en: '[PRE32]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, add the container `div`. We''ll add a descriptive body to inform the
    user of the page. However, once a button has been pressed, that content will disappear
    for good and will be replaced by dynamic content:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加容器`div`。我们将添加一个描述性主体来告知用户页面内容。然而，一旦按钮被按下，该内容将永久消失，并被动态内容所取代：
- en: '[PRE33]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the structure of the page in place, you can now close out the body and
    begin the `script` block:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面的结构就绪后，你现在可以关闭`body`标签并开始`script`块：
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we've created a variable for each element in the page we need to interact
    with. This makes the code neater and cleaner.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们为需要与之交互的页面中的每个元素创建了一个变量。这使得代码更加整洁和清晰。
- en: 'Next, you''ll need some content to add when the buttons are pressed, one for
    each button:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要一些内容在按钮被按下时添加，每个按钮一个：
- en: '[PRE35]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we need to wire up the content. To do this, simply add an event listener
    to each button, updating the container `div` content in each one:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要连接内容。为此，只需为每个按钮添加一个事件监听器，更新每个容器`div`的内容：
- en: '[PRE36]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, simply close out the open tags and save the page:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需关闭打开的标签并保存页面：
- en: '[PRE37]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That's it. If you now run the page in your browser and click each button, you
    should see that the content has been updated.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样。如果你现在在浏览器中运行页面并点击每个按钮，你应该会看到内容已被更新。
- en: 'The interactive page is as follows:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 交互式页面如下：
- en: '![Figure 6.8: Tabbed control exercise'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：标签控制练习'
- en: '](img/C14377_06_08.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_08.jpg)'
- en: 'Figure 6.8: Tabbed control exercise'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：标签控制练习
- en: This has been your first exploration of interactive content. Manipulating page
    content based on user interactivity is a common requirement for JavaScript and
    is something it excels at. Through careful planning and good coding practices,
    it is possible to create JavaScript applications that can mimic almost any kind
    of native software application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你对交互式内容的第一次探索。根据用户交互操作页面内容是JavaScript的常见需求，也是它擅长的领域。通过仔细规划和良好的编码实践，可以创建出可以模仿几乎所有原生软件应用的JavaScript应用程序。
- en: Bubbling versus Capturing
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冒泡与捕获
- en: So far, you've seen that event bubbling is where an event bubbles up from the
    node that dispatched it to the top of the tree, but JavaScript also provides an
    alternative to bubbling called capturing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到事件冒泡是从发出事件的节点向上冒泡到树的顶部，但JavaScript还提供了一个名为捕获的冒泡的替代方案：
- en: '`Event capturing` is where events are handled in the reverse order to bubbling,
    capturing notifications from the node that dispatched it to the bottom of the
    tree. This means that, when a node is interacted with, its attached event handlers
    may not be the first to intercept the event. Instead, a parent (or ancestor) may
    receive the event first, instead. If one of those ancestral handlers halts the
    event, then the handlers on the node that gave rise to the event may never actually
    be invoked at all:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`事件捕获`是指事件处理顺序与冒泡相反，从发出事件的节点到树的底部的捕获通知。这意味着当一个节点被交互时，其附加的事件处理器可能不是第一个拦截事件的。相反，一个父节点（或祖先节点）可能首先接收到事件。如果这些祖先处理器之一阻止了事件，那么引发事件的节点上的处理器可能根本不会被调用：'
- en: '![Figure 6.9: Bubbling versus capturing'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：冒泡与捕获'
- en: '](img/C14377_06_09.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_09.jpg)'
- en: 'Figure 6.9: Bubbling versus capturing'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：冒泡与捕获
- en: 'To attach an event handler to a capture event, you simply need to pass a third
    parameter to the `addEventListener` method. This third parameter is known as the
    `useCapture` parameter and is a Boolean. If set to `true`, the attached event
    will be assigned in `capture` mode. Thus, not supplying the `useCapture` parameter
    to the `addEventListener` method is the same as supplying `false` for that parameter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要将事件处理器附加到捕获事件，你只需将一个第三个参数传递给`addEventListener`方法。这个第三个参数被称为`useCapture`参数，是一个布尔值。如果设置为`true`，附加的事件将以捕获模式分配。因此，不向`addEventListener`方法提供`useCapture`参数与提供该参数的`false`相同：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Event handlers that are attached to capture events sit in a different space
    to bubbling event listeners. When assigning capturing events, they will not conflict
    with bubbling events. Therefore, assigning a function reference as an event handler
    as both bubbling and capturing, using the same event type on the same node, will
    mean that function will be called twice when that event is dispatched:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到捕获事件的处理器位于与冒泡事件监听器不同的空间。在分配捕获事件时，它们不会与冒泡事件冲突。因此，在同一个节点上使用相同的事件类型将函数引用作为冒泡和捕获的事件处理程序，意味着当该事件被派发时，该函数将被调用两次：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To remove an event that''s been added with `useCapture` set to `true`, you
    simply pass the same `useCapture` value to the `removeEventListener` method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除使用`useCapture`设置为`true`添加的事件，你只需将相同的`useCapture`值传递给`removeEventListener`方法：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The JavaScript Event Life Cycle
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript事件生命周期
- en: Regardless of which node has dispatched the event, all event notifications start
    at the `document` node. They then travel in capture mode through the tree branches
    toward the node that dispatched it (the `target` node). Once all the appropriate
    capture handlers along that path have been invoked, the event then travels back
    to the `document` node, invoking all the appropriate bubbling handlers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不论哪个节点派发了事件，所有事件通知都从`document`节点开始。然后它们以捕获模式通过树分支向派发事件的节点（即`target`节点）移动。一旦沿该路径的所有适当的捕获处理程序都被调用，事件随后返回到`document`节点，调用所有适当的冒泡处理程序。
- en: When traveling down the tree, the event is said to be in its capture phase and
    is said to be in its bubbling phase when returning to the `document` node. It
    is in its target phase when the target nodes handlers are invoked, regardless
    of whether it is its capturing handler or bubbling handler.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件沿着树向下传递时，我们称事件处于捕获阶段；当事件返回到`document`节点时，我们称其处于冒泡阶段。当目标节点的处理程序被调用时，无论它是捕获处理程序还是冒泡处理程序，事件都处于目标阶段。
- en: At any point in an event's round-trip travels, it may be halted by a handler,
    preventing all further event handlers from being invoked.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件往返旅行的任何一点，它都可能被处理程序阻止，从而防止所有其他事件处理程序被调用。
- en: Halting Event Propagation
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止事件传播
- en: Sometimes, when handling events, you may need to stop an event in its tracks.
    Knowing an event may be acted upon elsewhere in your page, it may make sense to
    halt an event if the conditions within your app are not in a state to allow the
    event to continue.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在处理事件时，你可能需要阻止事件。知道事件可能在页面的其他地方被处理，如果你的应用程序的条件不允许事件继续，那么停止事件可能是有意义的。
- en: For instance, if an event is dispatched when a user enters a new password within
    a `textfield` control, the event may be useless if the password does not meet
    certain requirements, such as consisting of too few characters or including characters
    that are not allowed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果当用户在`textfield`控件中输入新密码时派发事件，如果密码不符合某些要求，例如字符数太少或包含不允许的字符，那么该事件可能就毫无用处。
- en: 'JavaScript provides two similar functions to halt events: `stopPropagation`
    and `stopImmediatePropagation`. Both functions are methods of the event object
    that are passed to event handlers as their sole parameters.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了两个类似的功能来停止事件：`stopPropagation`和`stopImmediatePropagation`。这两个函数都是事件对象的方法，作为它们的唯一参数传递给事件处理程序。
- en: 'The `stopPropagation` method will prevent event handlers on further nodes along
    its journey from being invoked, regardless of whether the event is in its capturing
    phase or bubbling phase. However, it will still allow all remaining as-yet-uninvoked
    event handlers for the current event type to execute if they are on the same node
    as the event handler that called `stopPropagation`. The `stopImmediatePropagation`
    method will stop all further handlers, including those as-yet-uninvoked on the
    current node:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`stopPropagation`方法将阻止其旅程中进一步节点上的事件处理程序被调用，无论事件是在捕获阶段还是冒泡阶段。然而，如果它们与调用`stopPropagation`的事件处理程序位于同一节点上，它仍然允许所有剩余尚未调用的当前事件类型的事件处理程序执行。`stopImmediatePropagation`方法将停止所有进一步的处理程序，包括当前节点上尚未调用的处理程序：'
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Either method may be invoked anywhere within a handler and may be called in
    multiple handlers, though only the first instance will execute.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法都可以在处理程序中的任何位置调用，并且可以在多个处理程序中调用，尽管只有第一个实例会执行。
- en: Halting Event Actions
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止事件动作
- en: Some events within the JavaScript engine result in an action. An action is a
    browser-specific response to an event, outside of your own custom event handlers.
    Examples of this include the submission of a `form` or a page redirection when
    clicking a link.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎内部的一些事件会导致动作发生。动作是浏览器对事件的特定响应，它位于你自己的自定义事件处理程序之外。这包括在点击链接时提交`form`或页面重定向。
- en: Actions occur after the event bubbling phase, once the event has finished its
    journey through the node tree. If an event is stopped due to the invocation of
    either `stopPropagation` or `stopImmediatePropagation`, the action will still
    occur.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 动作发生在事件冒泡阶段之后，一旦事件完成了其在节点树中的旅程。如果由于调用`stopPropagation`或`stopImmediatePropagation`而停止了事件，动作仍然会发生。
- en: 'To prevent an action, the event object''s `preventDefault` method must be called:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要阻止一个动作，必须调用事件对象的`preventDefault`方法：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Calling `preventDefault` does not halt the event passing through the capture
    or bubbling phases. Therefore, if you want to stop an event in its tracks and
    prevent its action, you must call both types of method:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`preventDefault`不会阻止事件通过捕获或冒泡阶段。因此，如果你想阻止事件并防止其动作，你必须调用这两种类型的方法：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note that not all events can be prevented from initiating an action. Each dispatched
    event contains a property called cancelable. If this property is `true`, then
    it can be canceled by calling its `preventDefault` method. If, however, the property
    is `false`, then calling `preventDefault` will do nothing to change its behavior:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有事件都可以阻止其触发动作。每个派发的事件都包含一个名为`cancelable`的属性。如果这个属性是`true`，那么可以通过调用它的`preventDefault`方法来取消它。然而，如果属性是`false`，那么调用`preventDefault`将不会对其行为产生任何影响：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `onload` event is one such event that can't be canceled, and with good reason,
    since it is imperative that the event completes its life cycle to ensure the proper
    functionality of the browser. Conversely, a form `onsubmit` event is cancelable
    since its success must be at the discretion of the page's business logic.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`onload`事件就是这样一种无法取消的事件，这是有充分理由的，因为它对于确保浏览器的正常功能至关重要。相反，表单的`onsubmit`事件是可取消的，因为其成功必须由页面的业务逻辑来决定。'
- en: 'Exercise 6.04: Conditional Event Prevention'
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.04：条件事件阻止
- en: 'In this exercise, you will create a group of links. Each link, when clicked,
    will raise a `click` event. Above these links, the containing `div` will listen
    for the event each one raises and will determine if it should stop the event propagation,
    stop its action, or stop both. Let''s get started:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一组链接。每个链接在被点击时都会引发一个`click`事件。在这些链接上方，包含它们的`div`将监听每个链接引发的每个事件，并确定是否应该停止事件传播、停止其动作或两者都停止。让我们开始吧：
- en: 'Let''s start by creating a document called **ev-prev.html** and adding some
    HTML code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为**ev-prev.html**的文档并添加一些HTML代码开始：
- en: '[PRE45]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we have a container with three links and a secondary container for output
    messages.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含三个链接和一个用于输出消息的次级容器的容器。
- en: 'Next, open a `script` tag for the JavaScript and create variables to reference
    the `link` container, the links themselves, and the `message` container:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开一个`script`标签用于JavaScript，并创建变量来引用`link`容器、链接本身和`message`容器：
- en: '[PRE46]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When each link is clicked, we want a message to display, showing which link
    was clicked. Therefore, we will attach an `event listener` to the `link` container
    so that when the events bubble up, the handler will be there to catch the event
    object and identify which link dispatched the event:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当每个链接被点击时，我们希望显示一条消息，显示哪个链接被点击了。因此，我们将向`link`容器附加一个`event listener`，以便当事件冒泡时，处理程序将在那里捕获事件对象并确定哪个链接派发了事件：
- en: '[PRE47]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we will add a behavior for each link. The first will prevent actions,
    the second will stop `propagation`, and the third will do both:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将为每个链接添加一个行为。第一个将阻止动作，第二个将停止`propagation`，第三个将两者都做：
- en: '[PRE48]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, close out the `script` tag and `html` tag:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，关闭`script`标签和`html`标签：
- en: '[PRE49]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By running this page in a browser, you should see that the first link will print
    `Google` clicked in the message container, the second will redirect the user to
    the `Bing` website, and the third will do nothing at all. When clicking the second
    link, the message is never displayed because the event propagation is stopped
    in the handler.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在浏览器中运行此页面，你应该会看到第一个链接将在消息容器中打印`Google`点击，第二个链接将重定向用户到`Bing`网站，而第三个则什么都不做。当点击第二个链接时，消息永远不会显示，因为事件传播在处理程序中被停止。
- en: 'You have now successfully marshaled events and caught them as they bubbled
    up through the node tree:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你已经成功地将事件序列化并捕获了它们在节点树中冒泡的过程：
- en: '![Figure 6.10: Event prevention'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10：事件阻止'
- en: '](img/C14377_06_10.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_10.jpg)'
- en: 'Figure 6.10: Event prevention'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：事件阻止
- en: Event Triggers
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件触发器
- en: You have seen that events are dispatched dynamically when interacting with a
    web page, but events can also be triggered manually, through your own code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，在与网页交互时，事件是动态分发的，但事件也可以通过你的代码手动触发。
- en: As we mentioned previously, events in JavaScript are typed objects. When a dynamic
    event is raised, the JavaScript engine creates such an object and dispatches it.
    The object contains a type value that stores the event type as a string, such
    as `click`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，JavaScript 中的事件是有类型的对象。当一个动态事件被引发时，JavaScript 引擎创建这样一个对象并将其分发。该对象包含一个类型值，它将事件类型作为字符串存储，例如
    `click`。
- en: 'It is possible to instantiate your own event objects and dispatch them, rather
    than simply relying on events being created dynamically. There are many reasons
    why you might like to do this, such as to simulate user interaction or to easily
    invoke code already assigned as an event handler without duplicating code. To
    do so, you simply create an instance of an `Event` using the `new` keyword and
    pass it the type of event you wish to raise:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实例化自己的事件对象并分发它们，而不仅仅是依赖于动态创建的事件。你可能有很多原因想要这样做，比如模拟用户交互或轻松调用已分配为事件处理器的代码，而不重复代码。要做到这一点，你只需使用
    `new` 关键字创建一个 `Event` 实例，并传递你希望引发的事件类型：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once created, you then simply dispatch it using the node''s `dispatchEvent`
    method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，你只需使用节点的 `dispatchEvent` 方法来分发它：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The node that the `dispatchEvent` method is called from becomes the event object's
    target property. Once dispatched, the event enters the capture phase down through
    the `DOM` to this node, then the bubbling phase back up from it as normal, triggering
    event listeners as it goes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `dispatchEvent` 方法的节点成为事件对象的 target 属性。一旦分发，事件就会进入捕获阶段，通过 `DOM` 传递到该节点，然后以正常的方式从它向上冒泡，在移动过程中触发事件监听器。
- en: Custom Events
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义事件
- en: The `Event` object is the simplest type of event provided by the JavaScript
    framework. In fact, all the other events provided by JavaScript extend the simple
    `Event` type. However, the `Event` object by itself is not very flexible and does
    not provide a means of easily attaching additional data for an event. To alleviate
    this, the JavaScript language supplies the `CustomEvent` type, that is, an event
    specifically designed for custom developer events.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event` 对象是 JavaScript 框架提供的最简单的事件类型。实际上，JavaScript 提供的所有其他事件都是简单 `Event` 类型的扩展。然而，`Event`
    对象本身并不灵活，并且不提供为事件轻松附加额外数据的方法。为了解决这个问题，JavaScript 语言提供了 `CustomEvent` 类型，即专门为自定义开发者事件设计的事件。'
- en: 'When instantiated, the `CustomEvent` object accepts an additional named parameter
    called `detail`. By providing an object with a `detail` property as the second
    constructor parameter, the value of that property is then available to all event
    handlers that intercept it, like so:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化时，`CustomEvent` 对象接受一个额外的命名参数，称为 `detail`。通过将具有 `detail` 属性的对象作为第二个构造函数参数提供，该属性的值随后对所有拦截该事件的处理器都可用，如下所示：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, any event handlers that may intercept this event can retrieve the detail
    value by simply referencing it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何可能拦截此事件的处理器都可以通过简单地引用它来检索 detail 值：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`CustomEvent` exists for more than just manually triggering native event types;
    it is also possible to create your own event types. The name that''s passed to
    an event object when it is created may be any string you choose. By listening
    for that event, you are able to handle it just like events built into the JavaScript
    engine:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomEvent` 不仅用于手动触发原生事件类型；还可以创建自己的事件类型。在创建事件对象时传递给它的名称可以是任何你选择的字符串。通过监听该事件，你能够像处理内置在
    JavaScript 引擎中的事件一样处理它：'
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Native Event Triggers
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生事件触发器
- en: 'There are many native event types in the JavaScript language, some with actions
    and some without. So far, you have seen the `click` event being used, but there
    are far more than that. The mouse events group alone includes `15` different event
    types, and there are over `40` different groups of events, including the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 语言中有许多原生事件类型，一些有动作，一些没有。到目前为止，你已经看到了 `click` 事件的使用，但远不止这些。鼠标事件组就包括
    `15` 种不同的事件类型，还有超过 `40` 个不同的事件组，包括以下内容：
- en: Network
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Element focus
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素聚焦
- en: Web sockets
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web sockets
- en: CSS animations and transitions
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 动画和过渡
- en: Forms
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单
- en: Printing
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印
- en: Keyboard interactivity
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘交互性
- en: Element drag and drop
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素拖放
- en: Window and document events
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口和文档事件
- en: There are even events that occur through touch screen display interaction, virtual
    reality headsets, device battery changes, smartcard events, and many, many more.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有通过触摸屏显示交互、虚拟现实头盔、设备电池变化、智能卡事件等发生的事件，还有更多。
- en: Event Hander Attributes
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理器属性
- en: When building out your HTML page, the HTML specification also caters to infix
    event handling notation. This is where event handlers are assigned within the
    HTML nodes themselves. Infix event notation is known in HTML as event attributes.
    There are numerous available event attribute types, though not as many as there
    are event types provided by JavaScript.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建 HTML 页面时，HTML 规范还提供了中缀事件处理表示法。这就是事件处理器在 HTML 节点内部分配的地方。在 HTML 中，中缀事件表示法被称为事件属性。有众多可用的事件属性类型，尽管不如
    JavaScript 提供的事件类型多。
- en: 'Event attributes typically have names that are identical to their native JavaScript
    event type counterparts but are prepended with the word `on`. For instance, the
    `click` event would be assigned to a node as the `onclick` attribute:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 事件属性通常具有与它们的原生 JavaScript 事件类型相对应的名称，但前面加上单词 `on`。例如，`click` 事件会被分配给节点作为 `onclick`
    属性：
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The value of the event attribute is an executable JavaScript statement, such
    as a function invocation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 事件属性的价值是一个可执行的 JavaScript 语句，例如函数调用。
- en: 'DOM nodes can only support one event attribute of each type; it is not possible,
    for instance, to provide two `onclick` attributes in a single node. However, event
    attributes can execute multiple statements within a single attribute by ensuring
    the correct use of the semi-colon character to distinguish the separate statements:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 节点只能支持每种类型的一个事件属性；例如，不可能在单个节点中提供两个 `onclick` 属性。然而，通过确保正确使用分号字符来区分不同的语句，事件属性可以在单个属性内执行多个语句：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Functions called as event attribute handlers are not passed an event object.
    However, unlike typical event handlers, they can be called with additional parameters.
    For instance, to pass a reference to the node containing the event attribute,
    the event attribute function statement can be passed the `this` context:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 作为事件属性处理程序调用的函数不会传递事件对象。然而，与典型的事件处理器不同，它们可以用额外的参数调用。例如，要传递包含事件属性节点的一个引用，事件属性函数声明可以传递
    `this` 上下文：
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this instance, `this` resolves as the first parameter, which is a reference
    to the `div` node.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`this` 解析为第一个参数，它是对 `div` 节点的引用。
- en: Many developers consider event attributes to be a last resort since their inclusion
    mixes the view (HTML) with the logic (JavaScript). The recommended option is to
    always assign event handlers dynamically using `addEventListener`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为事件属性是最后的手段，因为它们的包含将视图（HTML）与逻辑（JavaScript）混合在一起。推荐的做法是始终使用 `addEventListener`
    动态分配事件处理器。
- en: Events and Memory
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件和内存
- en: In the previous chapter, the `delete` keyword was introduced and a chapter regarding
    memory management was touched upon. When working with event handlers, managing
    memory becomes very important. If an event handler is attached to a node but that
    node is then removed from the page `DOM`, it may not be cleaned up by the JavaScript
    engine's `garbage collector` (cleaned from memory) until the handler is removed
    from the node. This is particularly true if the event handler is not an anonymous
    function.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，介绍了 `delete` 关键字，并简要提到了内存管理章节。当与事件处理器一起工作时，内存管理变得非常重要。如果一个事件处理器被附加到一个节点上，但该节点随后从页面
    `DOM` 中移除，那么它可能不会被 JavaScript 引擎的垃圾回收器（从内存中清理）清理，直到处理器从节点中移除。这尤其适用于事件处理器不是匿名函数的情况。
- en: When using events against nodes that may be deleted from the `DOM`, ensure you
    perform a proper cleanup of your nodes and handlers. This may mean removing the
    event handlers and properly deleting a variable's contents prior to removal.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用可能从 `DOM` 中删除的节点的事件时，确保您正确清理您的节点和处理程序。这可能意味着在删除之前移除事件处理器并正确删除变量的内容。
- en: Working with Forms
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与表单一起工作
- en: Forms are an integral part of the HTML specification and exist separately to
    the JavaScript engine, though they are also fully interactive with JavaScript.
    HTML forms are declarative structures are defined using the `form` tag. This tag
    outlines a context that can be submitted, and its data is sent to a remote server
    location.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是HTML规范的一部分，它独立于JavaScript引擎存在，尽管它们也与JavaScript完全交互。HTML表单是使用`form`标签定义的声明性结构。此标签概述了一个可以提交的上下文，其数据被发送到远程服务器位置。
- en: To understand how the `form` tag works, it helps to understand HTTP requests,
    their type differentiation, and how data is sent within the request.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`form`标签的工作原理，了解HTTP请求、它们的类型区分以及数据如何在请求中发送是有帮助的。
- en: HTTP
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP
- en: HTTP is a specification, the long form of which is `HyperText Transfer Protocol`.
    It was originally released as `HTTP 1.0` in 1990 and detailed in the `RFC 1945`
    specification (where 1945 is the specification number, not a year). This transport
    format was designed for the transfer of HyperText documents across the internet,
    such as `HyperText Markup Language` (HTML) documents.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一个规范，其完整形式为`HyperText Transfer Protocol`。它最初于1990年以`HTTP 1.0`的形式发布，并在`RFC
    1945`规范中详细说明（其中1945是规范编号，而不是年份）。这种传输格式旨在在互联网上传输超文本文档，如`HyperText Markup Language`（HTML）文档。
- en: Within the HTTP specification, numerous metadata is identified that can be sent
    with an `HTTP request`. This metadata is known as **headers**, as it sits within
    the starting bytes of a request packet and is used to identify how the request
    is read.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP规范中，识别了许多可以与`HTTP请求`一起发送的元数据。这些元数据被称为**头部**，因为它们位于请求包的开始字节中，用于标识如何读取请求。
- en: The HTTP protocol provides an option to identify the purpose of the request
    packet, known as the `Method`. There are numerous `Method` options available,
    some of which are parsed and read differently by the HTTP servers that receive
    them, though their use may also be simply contextual. Two of the most common HTTP
    `Methods` are `GET` and `POST`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议提供了一个选项来识别请求包的目的，称为`Method`。有众多`Method`选项可用，尽管它们被接收它们的HTTP服务器以不同的方式解析和读取，但它们的使用也可能是简单的上下文相关。最常用的两个HTTP`Methods`是`GET`和`POST`。
- en: '`GET` is a method that simply means "`get me information at this address`",
    where the address is the URL the request was sent from. When making a `GET` request,
    parameters may be appended to the address in the form of query variables or as
    part of the path itself, which the server could then make use of in some way.
    However, in early versions of the `HTTP protocol`, `Uniform Resource Locator`
    (`URL`) addresses were only supplied with up to `255` characters, including the
    protocol and domain address, which proved tricky for larger amounts of data, including
    file uploads. To alleviate this problem, the specification also provides a `Method`
    called `POST`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`是一种方法，其简单含义是“`在这个地址获取信息`”，其中地址是请求发送的URL。当进行`GET`请求时，参数可以作为查询变量或作为路径本身附加到地址上，服务器可以据此以某种方式使用。然而，在`HTTP协议`的早期版本中，`统一资源定位符`（`URL`）地址仅提供最多`255`个字符，包括协议和域名地址，这对于大量数据，包括文件上传来说很棘手。为了解决这个问题，规范还提供了一个名为`POST`的方法。'
- en: '`POST` is an extension of `GET` and allows us to include a request `body`.
    In an HTTP request, a `body` is the packet content that is included after the
    headers; thus, it is the literal packet body:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`是`GET`的扩展，允许我们包含一个请求`body`。在HTTP请求中，`body`是包含在头部之后的包内容；因此，它是实际的包主体：'
- en: '![Figure 6.11: HTTP packet'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：HTTP包'
- en: '](img/C14377_06_11.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_06_11.jpg)'
- en: 'Figure 6.11: HTTP packet'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：HTTP包
- en: Since nothing follows the `body` in the request packet, the `body` is able to
    be much larger than the `GET` limitation of `255` characters.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求包中没有跟随`body`的内容，因此`body`可以比`GET`限制的`255`个字符大得多。
- en: When sending a `body` with a request, the sender is able to provide a `Content-Type`
    header, which describes the format (or MIME type) of the `body`. For instance,
    if the body is a `JavaScript Object Notation` (`JSON`) string, then the request's
    `Content-Type` may be `application/jpeg`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送请求的`body`时，发送者可以提供一个`Content-Type`头，该头描述了`body`的格式（或MIME类型）。例如，如果`body`是一个`JavaScript
    Object Notation`（`JSON`）字符串，那么请求的`Content-Type`可能是`application/jpeg`。
- en: The Form Tag
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单标签
- en: 'The `form` tag has existed in HTML since its public inception and is detailed
    in the `HTML RFC 1866` specification. The `form` tag typically encloses elements
    of a literal form, presented visibly to users of an HTML page. As with any HTML
    node, a `form` tag may be styled visually or left invisible as required:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`form`标签自HTML公开以来就存在，并在`HTML RFC 1866`规范中有详细说明。`form`标签通常包围了实际表单的元素，对HTML页面的用户可见。与任何HTML节点一样，`form`标签可以根据需要视觉化或保持不可见：'
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The attributes of the form tag include the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 表单标签的属性包括以下内容：
- en: '![Figure 6.12: Form Tag attributes and their description'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12：表单标签属性及其描述](img/C14377_06_12.jpg)'
- en: '](img/C14377_06_12.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_12.jpg)'
- en: 'Figure 6.12: Form Tag attributes and their description'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：表单标签属性及其描述
- en: In comparison to the HTTP packet specification, the `method` attribute is equivalent
    to the method of the HTTP packet itself, the `action` is the same as the URL parameter,
    and the `enctype` is the same as the **Content-Type** header value.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTTP包规范相比，`method`属性等同于HTTP包本身的`method`，`action`与URL参数相同，`enctype`与**Content-Type**头值相同。
- en: 'The `form` tag provides a logical request block around groups of input controls.
    Each `form` tag within a web page needs to be submitted for a request to be formulated
    and sent. Submission can occur dynamically with JavaScript or via user interaction
    through the use of a `submit` button control:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`form`标签为输入控件组提供了一个逻辑上的请求块。网页中的每个`form`标签都需要提交，以便形成并发送请求。提交可以通过JavaScript动态发生，或者通过使用`submit`按钮控件通过用户交互发生：'
- en: '[PRE59]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When you prefer direct user interaction, forms may be submitted using either
    a `submit` or an `image` input control, where the latter provides a means to display
    a styled graphic as the submission button:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当您更喜欢直接的用户交互时，可以使用`submit`或`image`输入控件提交表单，其中后者提供了一种显示样式图形作为提交按钮的方法：
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Submitting a Form with JavaScript
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript提交表单
- en: Sometimes, it is not appropriate to send a `form` request via user interaction.
    Instead, forms may send data after an animation has completed or perhaps redirect
    a user once their browser capabilities have been discovered. At such times, it
    helps to be able to trigger a form's submission dynamically using JavaScript.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过用户交互发送`form`请求可能不合适。相反，表单可能在动画完成后发送数据，或者一旦发现浏览器的功能，就重定向用户。在这些时候，能够使用JavaScript动态触发表单的提交非常有帮助。
- en: 'As with all DOM-based interaction, submitting a form first requires the acquisition
    of the form node. Once acquired, a form can be submitted by simply calling its
    `submit` function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有基于DOM的交互一样，首先需要获取表单节点才能提交表单。一旦获取，只需调用其`submit`函数即可提交表单：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that more than one form tag may exist within a page. Form tags may include
    identification and style-based attributes, the same as any other tag, such as
    `name`, `id`, `class`, and `style`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个页面中可能存在多个表单标签。表单标签可以包括标识和基于样式的属性，就像任何其他标签一样，例如`name`、`id`、`class`和`style`。
- en: Form Submission Events
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单提交事件
- en: The `form` tag supports a number of useful events oriented around controls and
    form handling. The most useful of these events is the `submit` event.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`form`标签支持围绕控件和表单处理的一系列有用的事件。其中最有用的事件是`submit`事件。'
- en: The `submit` event is dispatched when the form is submitted, but prior to the
    request actually being sent to the designated endpoint. This event is typically
    used for validating the user-supplied values of the form to ensure that no obvious
    mistakes were made or to ensure that the required fields have been completed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，会触发`submit`事件，但在实际将请求发送到指定的端点之前。此事件通常用于验证用户提供的表单值，以确保没有明显的错误或确保已填写所有必填字段。
- en: Note
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since the `submit` event is dispatched before the request is sent, be sure not
    to redirect the user to another page using this event or to do anything that will
    prevent the form submission from completing. If you wish to halt the form's submission,
    see the Preventing Form Submission section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`submit`事件在请求发送之前触发，请确保不要使用此事件将用户重定向到另一个页面或执行任何会阻止表单提交完成的事情。如果您希望阻止表单提交，请参阅“防止表单提交”部分。
- en: 'Like many events, the `submit` event handler may be assigned to a form node
    using explicit HTML attribute syntax:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多事件一样，可以使用显式的HTML属性语法将`submit`事件处理器分配给表单节点：
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `submit` event functions just like any other event, meaning that it captures
    from and bubbles to the `document` node.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit`事件的功能就像任何其他事件一样，意味着它从`document`节点捕获并冒泡。'
- en: Preventing Form Submission
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻止表单提交
- en: Stopping a `form` from submitting is a common requirement in HTML and JavaScript.
    Often, if the validation of the `form` fails, it is preferable to cancel the submission
    and display appropriate messages to the user. To cancel a `form` submission, we
    could call the `preventDefault` method of the event, which stops the eventual
    action of the event, just like it does with other event types. An alternative
    method is to return the `false` value from the function.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML和JavaScript中，阻止`表单`提交是一个常见的需求。通常，如果表单验证失败，最好取消提交并向用户显示适当的消息。要取消表单提交，我们可以调用事件的`preventDefault`方法，这将阻止事件的最终操作，就像对其他事件类型所做的那样。另一种方法是函数返回`false`值。
- en: Returning `false` from an event handler has the same effect as calling the event's
    `preventDefault` function, but it doesn't halt the capturing/bubbling.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件处理器返回`false`与调用事件的`preventDefault`函数具有相同的效果，但它不会停止捕获/冒泡。
- en: 'If your function is handling a jQuery event, returning `false` is the same
    as performing both the `preventDefault` and `stopPropagation` method calls:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数正在处理jQuery事件，返回`false`与执行`preventDefault`和`stopPropagation`方法调用相同：
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Resetting a Form
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置表单
- en: Resetting a form means returning the form to its initial state. This feature
    is provided as a way to restore a form to a clean state, or if the form was loaded
    with default or original values, then it returns those values to each of the controls.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 重置表单意味着将表单恢复到其初始状态。此功能提供了一种将表单恢复到干净状态的方法，或者如果表单已加载默认或原始值，则将这些值返回到每个控制项。
- en: Website users may sometimes require a reset capability if they're working with
    complex values. Being able to reset a form saves the user from having to memorize
    the initial values present in the form, or at least to quickly return to the original
    state prior to repopulating the form.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 网站用户有时可能需要重置功能，如果他们正在处理复杂值。能够重置表单可以节省用户记住表单中存在的初始值，或者至少快速返回到重新填充表单之前的原始状态。
- en: 'Like submitting, resetting a form may be carried out via user interaction through
    the use of a reset input control:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与提交类似，重置表单可以通过使用重置输入控制项通过用户交互来实现：
- en: '[PRE64]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Once the control has been clicked, the `form` will revert to its initial state.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制项被点击，`表单`将恢复到其初始状态。
- en: 'Another means to reset a form is by using the `reset` method of the `form`
    node:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 重置表单的另一种方法是使用`form`节点的`reset`方法：
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A `form` `reset` cannot be reversed automatically. If such a feature is required,
    all the values of the form will need to be saved first and then individually reapplied
    to the controls.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`表单`重置操作不能自动撤销。如果需要此功能，首先需要保存表单的所有值，然后逐个重新应用到控制项上。'
- en: Form Reset Event
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单重置事件
- en: 'When resetting a form, the browser will raise the `reset` event. The handler
    for the reset event may be applied explicitly within the HTML node''s declaration:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当重置表单时，浏览器将引发`reset`事件。重置事件的处理器可以显式地应用于HTML节点的声明中：
- en: '[PRE66]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Similarly, form reset events may be handled by simply assigning the event handler
    with JavaScript:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以通过简单地分配事件处理器来处理表单重置事件：
- en: '[PRE67]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Exercise 6.05: Simple Form Handling'
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.05：简单表单处理
- en: 'In this exercise, you will create a simple form with `submit` and `reset` buttons.
    When submitting, the form action will be canceled, but the submitted values will
    still be handled and displayed on the screen. This is the first step to creating
    a form validation system. Let''s get started:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个带有`submit`和`reset`按钮的简单表单。在提交时，表单操作将被取消，但提交的值仍然会被处理并在屏幕上显示。这是创建表单验证系统的第一步。让我们开始吧：
- en: 'Let''s begin with the standard opening HTML boilerplate:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从标准的HTML模板开始：
- en: '[PRE68]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, create the opening form tag. This will be given an ID, for ease of acquisition,
    and will provide a random action URL since it won''t be used in this exercise:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建开头的表单标签。这将赋予一个ID，以便于获取，并提供一个随机的操作URL，因为在这个练习中它不会被使用：
- en: '[PRE69]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To make this more interesting, let''s introduce a simple `text` field control.
    It won''t be used, per se, but it will help demonstrate the reset functionality:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这更有趣，让我们引入一个简单的`文本`字段控制项。虽然它本身不会被使用，但它将有助于演示重置功能：
- en: '[PRE70]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Input controls will be discussed in the next section of this chapter.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入控制项将在本章下一节中讨论。
- en: 'Now, you will need the two buttons: one for `submit` and one for `reset`:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要两个按钮：一个用于`submit`，一个用于`reset`：
- en: '[PRE71]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, let''s close out the `form` tag and open the `script` tag, ready for
    our JavaScript:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们关闭 `form` 标签并打开 `script` 标签，准备我们的 JavaScript：
- en: '[PRE72]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `reset` button handler will be simple. Once clicked, display a message
    in the console. However, you won''t be attaching the handler to the button''s
    `click` event as doing that will not provide the power to stop the `reset`, should
    you wish to. Instead, the event will be assigned to the form''s `reset` event:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reset` 按钮处理器将很简单。一旦点击，将在控制台显示一条消息。但是，你不会将处理器附加到按钮的 `click` 事件，因为这样做将无法提供停止
    `reset` 的能力，如果你希望这样做的话。相反，事件将被分配给表单的 `reset` 事件：'
- en: '[PRE73]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Likewise, with the `submit` handler, the form''s `submit` event will be listened
    to. In this instance, however, you will call `ev.preventDefault()` from the handler
    to prevent the form from actually submitting:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，使用 `submit` 处理器，将监听表单的 `submit` 事件。然而，在这种情况下，你将调用 `ev.preventDefault()` 从处理器中，以防止表单实际提交：
- en: '[PRE74]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, close out the `script` tag and the page:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，关闭 `script` 标签和页面：
- en: '[PRE75]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '![Figure 6.13: Form buttons'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.13：表单按钮'
- en: '](img/C14377_06_13.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_13.jpg)'
- en: 'Figure 6.13: Form buttons'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13：表单按钮
- en: That's it. Now, if you run the page in the browser, you will see that clicking
    `submit` will display one message in the console, while the `reset` button will
    show another. Also, clicking `reset` will always revert the text in the text field
    to the words original text.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，如果你在浏览器中运行页面，你会看到点击 `submit` 将在控制台显示一条消息，而 `reset` 按钮将显示另一条消息。此外，点击 `reset`
    总是将文本字段中的文本恢复到原始文本。
- en: Form Controls
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单控制
- en: Form tags are pretty useless without data to send. This data is typically provided
    using the various form controls or widgets that are available in the HTML specification.
    Where possible, and where the control has no child nodes, a form control typically
    utilizes the `input` node tag type. Other controls include `select`, `textarea`,
    `button`, and `datalist`. We will look at each of these control types throughout
    the rest of this chapter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 没有数据发送的表单标签几乎毫无用处。这些数据通常使用 HTML 规范中提供的各种表单控件或小部件提供。在可能的情况下，并且当控件没有子节点时，表单控件通常使用
    `input` 节点标签类型。其他控件包括 `select`、`textarea`、`button` 和 `datalist`。我们将在本章的其余部分查看这些控件类型。
- en: Input Controls
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入控制
- en: 'The majority of the controls that are available to HTML forms are provided
    using the `input` tag. The `input` tag requires a `type` parameter, which displays
    a relative control within the HTML page:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可用于 HTML 表单的控件都是通过 `input` 标签提供的。`input` 标签需要一个 `type` 参数，它显示 HTML 页面中的相对控件：
- en: '[PRE76]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The following are the types that are available in modern browsers when using
    the `input` control.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `input` 控制时，现代浏览器中可用的类型如下：
- en: The Button Control
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮控制
- en: 'The `button` control appears very much like the `submit` and `reset` form buttons.
    However, unlike `submit` and `reset`, the `button` control has no default action:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`button` 控制看起来非常像 `submit` 和 `reset` 表单按钮。然而，与 `submit` 和 `reset` 不同，`button`
    控制没有默认操作：'
- en: '[PRE77]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `button` control also has an alternative tag format, which we can use by
    using the `button` tag:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`button` 控制还有一个替代的标签格式，我们可以通过使用 `button` 标签来使用它：'
- en: '[PRE78]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Note that the `input` format requires a label to be passed in the `value` attribute,
    while the `button` tag format requires the button text to be passed as content
    using a closing `button` tag, like so:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`input` 格式需要在 `value` 属性中传递一个标签，而 `button` 标签格式需要将按钮文本作为内容传递，使用一个关闭的 `button`
    标签，如下所示：
- en: '![Figure 6.14: Button input control'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.14：按钮输入控制'
- en: '](img/C14377_06_14.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_14.jpg)'
- en: 'Figure 6.14: Button input control'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14：按钮输入控制
- en: The button control supports the `click` event, or the `onclick` attribute, as
    we explained earlier in this chapter.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮控制支持 `click` 事件，或 `onclick` 属性，正如我们在本章前面所解释的。
- en: The Checkbox Control
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复选框控制
- en: 'The `checkbox` control represents a "true or false," "on or off," or "yes or
    no" control:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkbox` 控制代表“是或否”、“开启或关闭”或“是或否”控制：'
- en: '[PRE79]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `checked` parameter in the preceding example is a valueless attribute. When
    supplied, the `checkbox` is presented checked by default and will be set to check
    whether the encompassing `form` is reset.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`checked` 参数是一个无值的属性。当提供时，`checkbox` 默认被选中，并将设置为检查是否重置包含的 `form`。
- en: 'An alternative implementation of this is to supply a value for `checked`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现的另一种方法是提供 `checked` 的值：
- en: '[PRE80]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Any values supplied with valueless attributes are disregarded, and thus any
    value may be provided:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 任何无值的属性提供的值都被忽略，因此可以提供任何值：
- en: '![Figure 6.15: Checkbox input control'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.15：复选框输入控件'
- en: '](img/C14377_06_15.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_06_15.jpg]'
- en: 'Figure 6.15: Checkbox input control'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15：复选框输入控件
- en: The `checkbox` control supports the `change` and `input` events. The `input`
    event will be dispatched whenever the `value` parameter of a control is changed,
    while the `change` event is raised only when the `value` of that control is committed,
    such as when losing focus or when the *Enter* key is pressed. Typically, there
    is very little difference between the two events when they're used with the `checkbox`
    control, though it is deemed preferable to always use the `change` event.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkbox` 控件支持 `change` 和 `input` 事件。当控制器的 `value` 参数发生变化时，将触发 `input` 事件，而
    `change` 事件仅在控制器的 `value` 被提交时触发，例如在失去焦点或按下 *Enter* 键时。通常，当与 `checkbox` 控件一起使用时，这两个事件之间几乎没有区别，尽管被认为始终使用
    `change` 事件是更好的选择。'
- en: When a `checkbox` is present in a form, its value is only submitted if it is
    `checked`. When unchecked, no value is passed to the handling script at all.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `checkbox` 出现在表单中时，只有当它被选中时才会提交其值。如果没有选中，则完全不将任何值传递给处理脚本。
- en: 'To check the checked status of a checkbox using JavaScript, simply query its
    `checked` parameter:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 JavaScript 检查复选框的选中状态，只需查询其 `checked` 参数：
- en: '[PRE81]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The value of `checked` will be `true` if the control is checked, or `false`
    if it isn't.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控件被选中，则 `checked` 的值将是 `true`，如果没有选中，则将是 `false`。
- en: To set the `checked` state of the control, simply pass a `Boolean` value to
    the `checked` parameter.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置控件的 `checked` 状态，只需将一个 `Boolean` 值传递给 `checked` 参数。
- en: The Radio Control
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无线电控制
- en: 'The `radio` control is similar to the `checkbox` control, with the exception
    that it handles multiple-choice options. Unlike a `checkbox` control, a `radio`
    control cannot be deselected by clicking on it. Instead, a different option must
    be selected, thereby providing at least one result when submitting the `form`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`radio` 控件类似于 `checkbox` 控件，但除了处理多选选项。与 `checkbox` 控件不同，`radio` 控件不能通过点击来取消选择。相反，必须选择不同的选项，从而在提交
    `form` 时至少提供一个结果：'
- en: '[PRE82]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `name` attribute of the `radio` control provides the grouping functionality.
    If a different `name` is provided from previous `radio` controls, then that new
    control belongs to a different group. Only by clicking the `radio` controls within
    the same group can the previously selected `radio` control be deselected:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`radio` 控件的 `name` 属性提供了分组功能。如果从之前的 `radio` 控件提供了不同的 `name`，则新控件属于不同的组。只有通过点击同一组内的
    `radio` 控件，才能取消选择之前选中的 `radio` 控件：'
- en: '![Figure 6.16: Radio input control'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.16：单选按钮输入控件'
- en: '](img/C14377_06_16.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_06_16.jpg]'
- en: 'Figure 6.16: Radio input control'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16：单选按钮输入控件
- en: Like the `checkbox` controls, the `radio` control is selected using the `checked`
    attribute. If a `radio` control group is present within a page, but none of the
    controls have been set to `checked`, none of those `radio` controls will be selected.
    At such times, submitting the parent form will mean that the `radio` group is
    absent from the sent data.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `checkbox` 控件一样，`radio` 控件是通过 `checked` 属性来选择的。如果页面中存在 `radio` 控件组，但没有设置任何控件为
    `checked`，则不会选择任何这些 `radio` 控件。在这种情况下，提交父表单意味着 `radio` 组不会出现在发送的数据中。
- en: 'To dynamically check a specific `radio` button (and thus uncheck the currently
    selected one), there needs to be a means to reference the specific `radio` control
    you wish to check. There are several ways to do this, such as providing a unique
    `id` for each `radio` control in a group, but by far the most efficient is to
    simply reference its index in the group. For instance, to select the second `radio`
    button in a group, we may do this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要动态检查特定的 `radio` 按钮（从而取消选中当前选中的按钮），需要有一种方法来引用希望检查的特定 `radio` 控件。有几种方法可以实现这一点，例如为组中的每个
    `radio` 控件提供唯一的 `id`，但最有效的方法是简单地引用其在组中的索引。例如，要选择组中的第二个 `radio` 按钮，我们可以这样做：
- en: '[PRE83]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`getElementsByName` returns an array of all the elements matching the passed
    criteria. Therefore, providing an index enables direct access to a given element
    index.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`getElementsByName` 返回与传入标准匹配的所有元素的数组。因此，提供索引可以实现对给定元素索引的直接访问。'
- en: '`radio` control supports the `input` and `change` events, much like the `checkbox`
    control.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`radio` 控件支持 `input` 和 `change` 事件，就像 `checkbox` 控件一样。'
- en: The Text Control
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本控件
- en: 'The `text` control is the most basic of all `input` control types and is used
    to create free-text fields. These fields allow for single-line text strings to
    be entered using the keyboard, though text may also be pasted into it using the
    browser context menu. Text fields are created by setting the `type` attribute
    of the `input` control to `text`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`text` 控件是所有 `input` 控件类型中最基本的，用于创建自由文本字段。这些字段允许使用键盘输入单行文本字符串，尽管也可以使用浏览器上下文菜单将其粘贴到其中。通过将
    `input` 控件的 `type` 属性设置为 `text` 来创建文本字段：'
- en: '[PRE84]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The permissible content of a `text` control may be restricted by supplying
    a `pattern` attribute value in the form of a regular expression. As an example,
    a text field can be restricted to accept only numerical values with the following
    code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过提供正则表达式形式的 `pattern` 属性值来限制 `text` 控件的允许内容。例如，可以使用以下代码将文本字段限制为仅接受数值：
- en: '[PRE85]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When using the preceding text field, submitting a value other than a number
    will result in the form submission terminating and a tooltip displaying alongside
    the `text` field with the text **Enter a number**. The form data will not be submitted
    under this circumstance:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用前面的文本字段时，提交除数字以外的值将导致表单提交终止，并在 `text` 字段旁边显示一个工具提示，提示“输入一个数字”。在这种情况下，表单数据将不会提交：
- en: '![Figure 6.17: Text input control with the pattern attribute'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.17：具有模式属性的文本输入控件'
- en: '](img/C14377_06_17.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_17.jpg)'
- en: 'Figure 6.17: Text input control with the pattern attribute'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17：具有模式属性的文本输入控件
- en: 'Another feature of the `text` field is the `placeholder` attribute. Placeholders
    allow for temporary text to exist within the field itself:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`text` 字段的另一个特性是 `placeholder` 属性。占位符允许在字段本身中存在临时文本：'
- en: '[PRE86]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This text does not constitute a value of the control, so the submission of
    the container form will not yield the `placeholder` value. Likewise, querying
    the text control''s `value` attribute will not return the `placeholder` value
    if it is visible:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 此文本不是控件的值，因此提交容器表单不会产生 `placeholder` 值。同样，如果 `placeholder` 可见，查询文本控件的 `value`
    属性也不会返回 `placeholder` 值：
- en: '![Figure 6.18: Text input control with placeholder attribute'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.18：具有占位符属性的文本输入控件'
- en: '](img/C14377_06_18.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_18.jpg)'
- en: 'Figure 6.18: Text input control with placeholder attribute'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18：具有占位符属性的文本输入控件
- en: The Password Control
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码控件
- en: 'The `password` control works very similarly to the `text` field control, but
    with a couple of differences:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`password` 控件与 `text` 字段控件非常相似，但有一些区别：'
- en: '[PRE87]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The primary difference with the `password` control is that any value present
    in the control is presented to the user as a series of dots, known as a hash,
    rather than as the value text itself. The purpose of the hash is for the value
    to be unreadable by the user and, thus, provide a level of security from unwanted
    attention. The user is, therefore, expected to already know the value contained
    within the field. When submitting the form, the value is correctly passed with
    the form data as clear text:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `password` 控件的主要区别是，控件中存在的任何值都向用户呈现为一系列点，称为散列，而不是作为值文本本身。散列的目的是使值对用户不可读，从而提供一定程度的保护，防止不受欢迎的注意。因此，用户预计已经知道字段中包含的值。在提交表单时，值会以明文形式正确地随表单数据传递：
- en: '![Figure 6.19: Password input control'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19：密码输入控件'
- en: '](img/C14377_06_19.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_19.jpg)'
- en: 'Figure 6.19: Password input control'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19：密码输入控件
- en: 'Another difference with the `password` control over the `text` control is that
    it is not possible to highlight its content and copy it. Any attempt to copy the
    content of a `password` control is ignored. This prevents malicious users from
    copying and pasting the value of a `password` control into a text editor, or other
    such software, thus making the value text clearly readable. However, despite this,
    it is still possible to reference the control with JavaScript and output its value
    that way, like so:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `text` 控件相比，`password` 控件的另一个区别是，无法突出显示其内容并复制它。尝试复制 `password` 控件的内容将被忽略。这防止恶意用户将
    `password` 控件的值复制并粘贴到文本编辑器或其他此类软件中，从而使值文本清晰可读。然而，尽管如此，仍然可以通过 JavaScript 引用控件并以此方式输出其值，如下所示：
- en: '[PRE88]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: email, tel, and url Controls
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: email、tel 和 url 控件
- en: 'The `email`, `tel`, and `url` controls are modern variations of the text field
    control. They can be created by simply passing email, tel, or url as the type
    attribute of the input control:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`email`、`tel` 和 `url` 控件是文本字段控件的现代变体。它们可以通过简单地将 email、tel 或 url 作为输入控件的类型属性传递来创建：'
- en: '[PRE89]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'By themselves, each of these controls provides no additional functionality
    over the standard `text` control. All of the attributes, events, and visual look-and-feel
    of these controls are identical to the `text` control and to one another. However,
    the benefit of these types becomes apparent when they''re used with devices that
    present an on-screen keyboard, such as mobile phones and tablets. By using one
    of these `input` types, rather than a `text` control, the visible keyboard that''s
    presented to input text into them is typically oriented toward the control''s
    content type:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这些控件在功能上并没有比标准的 `text` 控件提供额外的功能。这些控件的属性、事件和视觉外观都与 `text` 控件以及彼此相同。然而，当与提供屏幕键盘的设备（如手机和平板电脑）一起使用时，这些类型的好处就显现出来了。通过使用这些
    `input` 类型之一，而不是 `text` 控件，向其中输入文本时显示的可见键盘通常面向控件的内容类型：
- en: '![Figure 6.20: Mobile keyboards for the text, email, tel, and url controls'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.20：文本、电子邮件、电话和URL控件的移动键盘'
- en: '](img/C14377_06_20.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_20.jpg)'
- en: 'Figure 6.20: Mobile keyboards for the text, email, tel, and url controls'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：文本、电子邮件、电话和URL控件的移动键盘
- en: Note that additional work is needed to ensure that the content of the field
    is appropriate for the field format. This can be accomplished using the `pattern`
    attribute and form validation logic.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，需要做额外的工作来确保字段的内容适合字段格式。这可以通过使用 `pattern` 属性和表单验证逻辑来实现。
- en: The Hidden Control
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏控件
- en: 'The `hidden` control is a very useful field for storing data to be passed to
    the handler of a form, such as a remote server endpoint, without the user of the
    web page being aware of its existence. As its name implies, the `hidden` field
    is hidden from the user and has no visible presence:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`hidden` 控件是一个非常有用的字段，用于存储要传递给表单处理程序（如远程服务器端点）的数据，而网页的用户不会意识到其存在。正如其名称所暗示的，`hidden`
    字段对用户来说是隐藏的，并且没有可见的存在：'
- en: '[PRE90]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Many of the attributes provided by the input tag are irrelevant when using the
    `hidden` control since it is not a control that a user will interact with. However,
    its `value`, `id`, and `name` attributes will prove useful and can be used and
    manipulated in the same way as the `text` control.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `hidden` 控件时，输入标签提供的许多属性都是无关紧要的，因为它不是用户会与之交互的控件。然而，它的 `value`、`id` 和 `name`
    属性将非常有用，并且可以像 `text` 控件一样使用和操作。
- en: The Number Control
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字控件
- en: 'A `number` field appears similar to a `text` field but will naturally constrain
    all text input to numerical values, the addition and subtraction symbols, and
    the period symbol:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`number` 字段看起来与 `text` 字段相似，但会自然地将所有文本输入约束为数值、加减符号和点符号：'
- en: '[PRE91]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In some browsers, the number control will also present small up and down arrow
    buttons, which can be used to increment or decrement the contained value:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些浏览器中，数字控件还会显示小的上下箭头按钮，可以用来增加或减少包含的值：
- en: '![Figure 6.21: Number control'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.21：数字控件'
- en: '](img/C14377_06_21.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_21.jpg)'
- en: 'Figure 6.21: Number control'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21：数字控件
- en: 'The content of a `number` control can be further constrained by using its `min`,
    `max`, and `step` attributes. The `min` and `max` attributes are self-explanatory
    and constrain possible numeric entry values to these attributes. For instance,
    providing a `min` value of 0 will ensure a negative number cannot be entered,
    while a `max` value of 100 will ensure the value never exceeds 100:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`number` 控件的内容可以通过使用其 `min`、`max` 和 `step` 属性进一步约束。`min` 和 `max` 属性是自解释的，它们将可能的数字输入值约束到这些属性。例如，提供一个
    `min` 值为 0 将确保不能输入负数，而 `max` 值为 100 将确保值永远不会超过 100：'
- en: '[PRE92]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Using `min` and `max` does not mean a value outside of these constraints cannot
    be physically entered as input into the control from the keyboard, but merely
    that the constraints cannot be breached when clicking on the provided arrow buttons
    or that any provided value outside of these parameters will be accepted when submitting
    the form:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `min` 和 `max` 并不意味着超出这些约束的值不能从键盘物理输入到控件中，而只是说在点击提供的箭头按钮时不能违反这些约束，或者当提交表单时，任何超出这些参数的提供的值都将被接受：
- en: '![Figure 6.22: Number control constraints'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.22：数字控件约束'
- en: '](img/C14377_06_22.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_22.jpg)'
- en: 'Figure 6.22: Number control constraints'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22：数字控件约束
- en: 'The step attribute provides a means to increase the rate at which the arrow
    buttons increase or decrease the value. For instance, if large numbers are allowed
    within the control, incrementing by 1 with each click may be impractical. Therefore,
    setting a larger step size would allow the value change to happen with fewer clicks:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 步进属性提供了一种方法来增加箭头按钮增加或减少值的速率。例如，如果控件中允许大数字，每次点击增加1可能不太实用。因此，设置更大的步进值将允许通过更少的点击来改变值：
- en: '[PRE93]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When using step, the change in value when clicking the arrow buttons will change
    at a rate of the step value from whatever value is currently present within the
    control. Therefore, setting a step of 5 will not constrain the contained value
    to multiples of 5.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用步进时，点击箭头按钮时值的改变将以步进值的速率从控件中当前存在的任何值开始改变。因此，设置步进值为5不会将包含的值限制为5的倍数。
- en: The Image Control
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像控制
- en: 'The `image` control works as a hybrid of an `img` tag and a `submit` input
    control. The idea here is that you can use a graphical image as a submit button.
    You specify the image source using the `src` attribute, much like we do with the
    `img` tag:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`控件作为一个`img`标签和`submit`输入控件的混合体工作。这里的想法是你可以使用图形图像作为提交按钮。你使用`src`属性指定图像源，就像我们使用`img`标签一样：'
- en: '[PRE94]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'An additional benefit to using an `image` input control is that once it''s
    clicked, the x and y coordinates of the mouse in relation to the image are also
    sent with the form data as an `x` and `y` value. This can prove very useful if,
    for instance, you wish to register a location on a map as part of form submission,
    or if you wish to determine the area of the image that the user clicked on:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`image`输入控件的一个额外好处是，一旦点击，鼠标相对于图像的x和y坐标也会作为`x`和`y`值与表单数据一起发送。如果，例如，你希望在表单提交中将地图上的某个位置注册为一部分，或者如果你希望确定用户点击的图像区域，这可能会非常有用：
- en: '[PRE95]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The availability of the `image` control means forms can be stylized beyond the
    confines provided by HTML button controls and can be very popular with web designers.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`控件的可用性意味着表单可以超越HTML按钮控件提供的限制进行样式化，并且可能非常受网页设计师的欢迎。'
- en: The File Control
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件控件
- en: 'The `file` control is a requirement when uploading files to a remote server.
    In fact, it is not actually possible to upload a file dynamically without using
    the `file` control in some way. This is due to security as it is unethical to
    be able to dynamically upload files from a user''s machine without their knowledge:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当上传文件到远程服务器时，`file`控件是必需的。实际上，如果不以某种方式使用`file`控件，就无法动态上传文件。这是由于安全性的原因，在没有用户知情的情况下动态上传文件是不道德的：
- en: '[PRE96]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `file` control is typically presented to the user as a `text` field and
    `label` pair. It is possible to style the control so that one of these items,
    or both, is not visible to the user. The text that's supplied within the button
    and label is fixed by the browser and requires some extreme styling to be changed.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`控件通常以`text`字段和`label`对的形式呈现给用户。可以样式化控件，使得这些项目中的一个或两个对用户不可见。按钮和标签中提供的文本由浏览器固定，并且需要一些极端的样式才能更改。'
- en: '![Figure 6.23: File control'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.23：文件控制'
- en: '](img/C14377_06_23.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_06_23.jpg]'
- en: 'Figure 6.23: File control'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23：文件控制
- en: When using the `file` control to upload files to a server, it is important to
    set the `enctype` parameter of the surrounding form to `"multipart/form-data"`.
    This value informs the form submission on how to encode the data when sending
    it to the server. Failure to do this will prevent the file from uploading since
    files typically require multiple packets to successfully transfer all of the file's
    data bytes.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`file`控件将文件上传到服务器时，设置周围表单的`enctype`参数为`"multipart/form-data"`非常重要。此值告知表单提交在发送到服务器时如何编码数据。如果不这样做，将阻止文件上传，因为文件通常需要多个数据包才能成功传输所有文件的数据字节。
- en: 'The file control supports an accept attribute value, which enables the filtering
    of accepted file format types. This attribute can support more than one value,
    but they must be supplied as MIME types (a predefined string representation of
    a file''s type):'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 文件控件支持`accept`属性值，该值可以启用接受文件格式类型的过滤。此属性可以支持多个值，但它们必须作为MIME类型（文件类型的预定义字符串表示）提供：
- en: '[PRE97]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In the preceding example, only files with a .png, .jpg, or .jpeg extension will
    be visible when selecting files through the control.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，只有具有.png、.jpg或.jpeg扩展名的文件在通过控件选择文件时才会可见。
- en: The Textarea Control
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本区域控件
- en: 'While the `text` control is great for accepting single lines of text, the `textarea`
    control is required for capturing multiline text values:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `text` 控件非常适合接受单行文本，但 `textarea` 控件是捕获多行文本值所必需的：
- en: '[PRE98]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As the name implies, the `textarea` control supports an area of text and is,
    therefore, a larger control than many of the `input` controls. Like the `button`
    tag, the `textarea` control consists of both an opening and a closing tag. Any
    text that's supplied between the tags makes up its text content.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`textarea` 控件支持文本区域，因此它比许多 `input` 控件都要大。与 `button` 标签一样，`textarea` 控件由一个开标签和一个闭标签组成。在标签之间提供的任何文本都构成了其文本内容。
- en: 'Although the textarea doesn''t utilize a value attribute, its content may still
    be read and set using the `value` attribute in JavaScript, like so:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管文本区域不使用 value 属性，但其内容仍然可以通过 JavaScript 中的 `value` 属性进行读取和设置，如下所示：
- en: '[PRE99]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '![Figure 6.24: Textarea control'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.24：文本区域控件'
- en: '](img/C14377_06_24.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_24.jpg)'
- en: 'Figure 6.24: Textarea control'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24：文本区域控件
- en: The Select Control
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选取控件
- en: 'The `select` control provides the functionality of a drop-down list control.
    Like `textarea`, the `select` control utilizes an opening and closing tag, both
    of which form the body of the control. However, the items within the control are
    provided as an additional tag, called `option`:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 控件提供了下拉列表控件的功能。与 `textarea` 类似，`select` 控件使用一个开标签和一个闭标签，这两个标签共同构成了控件的主体。然而，控件内的项目是通过一个额外的标签提供的，称为
    `option`：'
- en: '[PRE100]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The `option` elements of a `select` control typically contain two values: the
    `value` attribute and the `text` body. These are known simply as the `value` and
    `text`. The text contained between the opening and closing `option` tags is the
    string that''s visible to the user within the control, while the `value` attribute
    is the string to be sent when the form is submitted if that particular `option`
    element is selected. When adding `option` elements, the `value` attribute may
    be omitted, but this will mean the `text` value will be sent with the form data
    instead.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 控件的 `option` 元素通常包含两个值：`value` 属性和 `text` 主体。这些简单地被称为 `value` 和 `text`。在开
    `option` 标签和闭 `option` 标签之间的文本是用户在控件中可见的字符串，而 `value` 属性是在选择该特定 `option` 元素时提交表单时要发送的字符串。在添加
    `option` 元素时，可以省略 `value` 属性，但这将意味着将 `text` 值与表单数据一起发送。'
- en: 'Similar to checkboxes and radio buttons, an option value may be preselected
    by passing the selected attribute to one of the option values:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 与复选框和单选按钮类似，可以通过将 selected 属性传递给选项值之一来预先选择一个选项值：
- en: '[PRE101]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The select control can be displayed in two formats. The standard format is
    as a dropdown (or combo) list control:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 选取控件可以以两种格式显示。标准格式是一个下拉（或组合）列表控件：
- en: '![Figure 6.25: Select control'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.25：选取控件'
- en: '](img/C14377_06_25.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_25.jpg)'
- en: 'Figure 6.25: Select control'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25：选取控件
- en: 'The secondary format is displayed if the control needs to support multiple
    simultaneously selected options. As such, the control is displayed as a permanently
    open list control, with scrollable options. The `select` control can support multiple
    selected options by supplying the `multiple` attribute:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控件需要支持同时选择多个选项，则会显示第二种格式。因此，控件以永久打开的列表控件形式显示，具有可滚动的选项。`select` 控件可以通过提供 `multiple`
    属性来支持多个选定的选项：
- en: '[PRE102]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When displayed, the user must press and hold the Ctrl key on the keyboard while
    selecting items. If the Ctrl key is not pressed, then selecting an item will deselect
    any previously selected items:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示时，用户在选择项目时必须按住键盘上的 Ctrl 键。如果没有按 Ctrl 键，则选择一个项目将取消选择之前选定的任何项目：
- en: '![Figure 6.26: Select control with multiple attributes'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.26：具有多个属性的选取控件'
- en: '](img/C14377_06_26.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_06_26.jpg)'
- en: 'Figure 6.26: Select control with multiple attributes'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26：具有多个属性的选取控件
- en: 'When working with a dropdown `select` control, it is possible to get the value
    of the selected `option` by simply querying the `select` control''s `value` property:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用下拉 `select` 控件时，可以通过查询 `select` 控件的 `value` 属性来获取所选 `option` 的值：
- en: '[PRE103]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'It is also possible to output the index of the selected item by querying the
    `selectedIndex` property. Index values start at 0 (zero) for the first element:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过查询 `selectedIndex` 属性来输出所选项目的索引。索引值从 0（零）开始，对应第一个元素：
- en: '[PRE104]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: However, when querying a multi-select list, things aren't so easy. If multiple
    items are selected, querying the `value` property would simply return the first
    selected item in the list, thus ignoring all the other selected items. Instead,
    developers need to make use of the `options` property of the `select` control
    and the `option` item's `selected` property to discern which items are selected.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当查询多选列表时，事情并不那么简单。如果多个项目被选中，查询`value`属性将简单地返回列表中第一个选中的项目，从而忽略所有其他选中的项目。相反，开发者需要利用`select`控件的`options`属性和`option`项的`selected`属性来识别哪些项目被选中。
- en: 'The `select` control''s `options` property returns all the `option` elements
    contained within it, regardless of their selected state. The `option` item''s
    `selected` property is simply the condition of its selected status; it''s true
    if it is selected and false if it is not. Thus, by combining these two values,
    the selected `option` elements can be discerned with a simple loop, like so:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`控件中的`options`属性返回所有包含在其内的`option`元素，无论它们的选中状态如何。`option`项的`selected`属性只是其选中状态的简单条件；如果选中则为真，如果没有选中则为假。因此，通过结合这两个值，可以通过简单的循环识别选中的`option`元素，如下所示：'
- en: '[PRE105]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Activity 6.01: Making Changes to the Model'
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.01：对模型进行更改
- en: A lot has been covered in this chapter, but you should now have the knowledge
    that's required to make something visual. In this activity, your role will be
    to create a simple form that requests the title and description for a new `To-Do`
    entry which, when submitted, feeds the data to the action handler we created in
    the previous chapter.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量内容，但你现在应该具备制作可视内容所需的知识。在这个活动中，你的角色是创建一个简单的表单，该表单请求输入新`待办事项`条目的标题和描述。当提交时，这些数据将被发送到我们在上一章中创建的动作处理器。
- en: Once your form is in place and its data is being handled, the model functions
    must be updated to receive this data. Create an event handler that's able to receive
    `CREATE` action events and pass them appropriately to the model.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的表单就位并且其数据正在被处理，模型功能必须更新以接收这些数据。创建一个能够接收`CREATE`动作事件并将它们适当传递给模型的处理器。
- en: Since there is no visual cue that data has been successfully stored within the
    model, any updates to the model should result in a notification event being dispatched.
    This way, other areas of your application can respond accordingly as data changes.
    Your project manager has requested that a custom event be dispatched from the
    model, called `CHANGED`. This will notify any interested party that data has either
    been added, updated, or removed from the model.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型中没有视觉提示表示数据已成功存储，因此对模型的任何更新都应导致发送通知事件。这样，应用程序的其他区域可以根据数据变化做出相应的响应。你的项目经理要求从模型中发送一个名为`CHANGED`的自定义事件。这将通知任何感兴趣的方，数据已被添加、更新或从模型中删除。
- en: To verify that the `CHANGED` event works, create a message banner at the top
    of the page that briefly displays the message "`The To-Do model has been updated`".
    This message should be present for three seconds, before being removed.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证`CHANGED`事件是否工作，在页面顶部创建一个消息横幅，该横幅将短暂显示消息“`待办事项模型已更新`”。此消息应存在三秒钟，然后被移除。
- en: Your project manager has asked that this information is dispatched as a custom
    event, to be caught by the action handler. This event should match the action
    types already recognized by the model. Therefore, be sure to send the object as
    a `CREATE` event.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目经理要求将这些信息作为自定义事件发送，以便由动作处理器捕获。此事件应与模型已识别的动作类型相匹配。因此，请确保以`CREATE`事件的形式发送对象。
- en: 'Save the following HTML in a file called `index.html`:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下HTML保存到名为`index.html`的文件中：
- en: '[PRE106]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This HTML should include the model from the previous chapter, but also a new
    JavaScript file that will contain the logic for this activity.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 此HTML应包括上一章中的模型，但还应包含一个包含此活动逻辑的新JavaScript文件。
- en: 'The following is the expected output for this activity:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个活动的预期输出：
- en: '![Figure 6.27: TODO submission form'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.27：待办事项提交表单'
- en: '](img/C14377_06_27.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.27：待办事项提交表单](img/C14377_06_27.jpg)'
- en: 'Figure 6.27: TODO submission form'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27：待办事项提交表单
- en: 'Follow these steps to complete this activity:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Add a custom event handler to the model. This handler should receive the `CREATE`
    state change and update the model with the new `TODO` details from the event body.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向模型添加一个自定义事件处理器。此处理器应接收`CREATE`状态变化，并使用事件主体的新`TODO`详细信息更新模型。
- en: Add a `loadHandler` function to the `create_todo.js` file. This handler should
    listen for the submit button's `click` event, but also the custom `CHANGED` event
    from the model.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `loadHandler` 函数添加到 `create_todo.js` 文件中。这个处理函数应该监听提交按钮的 `click` 事件，但也监听模型发出的自定义
    `CHANGED` 事件。
- en: Add a handler function in `create_todo.js` to handle the `CHANGED` event itself.
    This handler should temporarily display a `The TODO model has been updated` message
    within the `notifications` tag.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `create_todo.js` 文件中添加一个处理函数来处理 `CHANGED` 事件本身。这个处理函数应该暂时在 `notifications`
    标签内显示一条 `The TODO model has been updated` 消息。
- en: Add the `TODO` to the `create_todo.js` file. This will be executed when the
    `submit` button click event is raised. This handler should parse the values of
    the form controls and dispatch them in a new `CREATE` custom event if they are
    valid. If any of the data is not valid, then sufficient error messages should
    be temporarily displayed in the `notifications` tag.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TODO` 添加到 `create_todo.js` 文件中。这将执行当 `submit` 按钮点击事件被触发时。这个处理函数应该解析表单控件中的值，并在它们有效的情况下，通过一个新的
    `CREATE` 自定义事件将它们分发出去。如果任何数据无效，那么应该在 `notifications` 标签中暂时显示足够的错误消息。
- en: Add a `CHANGED` event dispatch when the model is updated. The event body should
    contain a type added and a value containing the details of the new `TODO`.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当模型更新时，添加一个 `CHANGED` 事件分发。事件体应包含一个添加的类型和一个包含新 `TODO` 详细信息的值。
- en: If you run the HTML page, you will expect to see messages to be written to the
    screen when you submit the form. Remember that the model will receive and send
    events. It will not be contacted directly. The handler functions will ensure that
    the events are attached correctly and that the data has been correctly parsed
    so that it can be sent to the model.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 HTML 页面，你将期望在提交表单时看到消息被写入屏幕。记住，模型将接收和发送事件。它不会被直接联系。处理函数将确保事件被正确附加，并且数据已经被正确解析，以便可以发送到模型。
- en: Note
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 728.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第 728 页找到。
- en: Summary
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This has been the first chapter to have utilized an HTML page using JavaScript
    in this book, as well as the first to explain the abstract nature of the event
    messaging system. Understanding these concepts is very valuable when building
    a useful web application in JavaScript.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中第一个使用 JavaScript 在 HTML 页面上，以及第一个解释事件消息系统抽象性质的章节。理解这些概念对于在 JavaScript 中构建有用的网络应用程序非常有价值。
- en: Throughout this chapter, you have explored the various nuances of event message
    bubbling and capturing, along with how they can be used to control the flow of
    information within an application. You have also seen how to halt these events
    in their tracks and how to create your own custom events.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经探索了事件消息冒泡和捕获的各种细微差别，以及如何使用它们来控制应用程序内部的信息流。你还看到了如何阻止这些事件，以及如何创建你自己的自定义事件。
- en: By adopting the tools and skills you've learned about in this chapter, you will
    have a foundational arsenal at your disposal so that you can tackle applications
    of any size or complexity. These skills will be honed throughout the rest of this
    book while broadening your perspective as to what is possible with this powerful
    language.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用本章中你学到的工具和技能，你将拥有一个基础的工具库，这样你就可以处理任何大小或复杂性的应用程序。这些技能将在本书的其余部分得到磨练，同时拓宽你对这个强大语言可能性的认识。
- en: In the next chapter, you will dive deeper into the JavaScript event loop and
    gain a greater understanding of the underlying technology.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将更深入地研究 JavaScript 事件循环，并更深入地了解底层技术。
