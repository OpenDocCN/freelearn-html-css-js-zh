<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with Jasmine"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Jasmine</h1></div></div></div><p>It is an exciting time to be a JavaScript developer; technologies have matured, web browsers are more standardized, and there are new things to play with every day. JavaScript has become an established language, and the Web is the true open platform of today. We've seen the rise of single-page web applications, the proliferation of <span class="strong"><strong>Model View Controller</strong></span> (<span class="strong"><strong>MVC</strong></span>)<a id="id0" class="indexterm"/> frameworks, such as Backbone.js and AngularJS, the use of JavaScript on the server with Node.js, and even mobile applications created entirely with HTML, JavaScript, and CSS using technologies such as PhoneGap.</p><p>From its humble beginnings with handling HTML forms, to the massive applications of today, the JavaScript language has come very far, and with it, a number of tools have matured to ensure that you can have the same level of quality with it that you have with any other language.</p><p>This book is about the tools that keep you in control of your JavaScript development.</p><div class="section" title="JavaScript – the bad parts"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>JavaScript – the bad parts</h1></div></div></div><p>There are many <a id="id1" class="indexterm"/>complications when dealing with client JavaScript code; the obvious one, is that you cannot control the client's runtime. While on the server, you can run a specific version of your Node.js server, you can't oblige your clients to run the latest version of Chrome or Firefox.</p><p>The JavaScript language is defined by the ECMAScript specification; therefore, each browser can have its own implementation of a runtime, which means there could be small differences or bugs between them.</p><p>Besides that, you have issues with the language itself. Brendan Eich developed JavaScript in just 10 days, under a lot of management pressure at Netscape. Although it got itself right in its simplicity, first-class functions, and object prototypes, it also introduced some problems with the attempt to make the language malleable and allow it to evolve.</p><p>Every JavaScript object is mutable; this means that there is nothing you can do to prevent a module from overwriting pieces of other modules. The following code illustrates how simple it is to overwrite the global <code class="literal">console.log</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>console.log('test');</strong></span>
<span class="strong"><strong>&gt;&gt; 'test'</strong></span>
<span class="strong"><strong>console.log = 'break';</strong></span>
<span class="strong"><strong>console.log('test');</strong></span>
<span class="strong"><strong>&gt;&gt; TypeError: Property 'log' of object #&lt;Console&gt; is not a function</strong></span>
</pre></div><p>This was a conscious <a id="id2" class="indexterm"/>decision on the language design; it allows developers to tinker and add missing functionality to the language. But given such power, it is relatively easy to make a mistake.</p><p>Version 5 of the ECMA specification introduced<a id="id3" class="indexterm"/> the <code class="literal">Object.seal</code> function, which prevents further changes on any object once called. But its current support is not widespread; Internet Explorer, for example, only implemented it on its version 9.</p><p>Another problem, is with how JavaScript deals with type. In other languages, an expression like <code class="literal">'1' + 1</code> would probably raise an error; in JavaScript, due to some non-intuitive type coercion rules, the aforementioned code results in <code class="literal">'11'</code>. But the main problem is in its inconsistency; on multiplication, a string is converted into a number, so <code class="literal">'3' * 4</code>, is actually <code class="literal">12</code>.</p><p>This can lead to some hard-to-find problems on big expressions. Suppose you have some data coming from a server, and although you are expecting numbers, one value came as a string:</p><div class="informalexample"><pre class="programlisting">var a = 1, b = '2', c = 3, d = 4;
var result = a + b + c * d;</pre></div><p>The resulting value of the preceding example is <code class="literal">'1212'</code>, a string.</p><p>These are just two common problems faced by developers. Throughout the book, you are going to apply best practices and write tests to guarantee that you don't fall into these, and other, pitfalls.</p></div></div>
<div class="section" title="Jasmine and behavior-driven development"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Jasmine and behavior-driven development</h1></div></div></div><p>Jasmine<a id="id4" class="indexterm"/> is a little <span class="strong"><strong>behavior-driven development</strong></span> (BDD)<a id="id5" class="indexterm"/> test framework created by the developers at Pivotal Labs, to allow you to write automated JavaScript unit tests.</p><p>But before we can go any further, first we need to get some fundamentals right, starting with what a test unit is.</p><p>A test unit<a id="id6" class="indexterm"/> is a piece of code that tests a functionality unit of the application code. But sometimes, it can be tricky to understand what a functionality unit can be, so for that reason, Dan North came up with a solution in the form of BDD, which is a rethink of <a id="id7" class="indexterm"/>
<span class="strong"><strong>test-driven development</strong></span> (<span class="strong"><strong>TDD</strong></span>).</p><p>In traditional unit testing practice, the developer is left with loose guidelines on how to start the process of testing, what to test, how big a test should be, or even how to call a test.</p><p>To fix these problems, Dan <a id="id8" class="indexterm"/>took the concept of <span class="strong"><strong>user stories</strong></span><a id="id9" class="indexterm"/> from the standard agile construct, as a model on how to write tests.</p><p>For example, a music player application could have an acceptance criterion such as:</p><p><span class="strong"><strong>Given</strong></span> a player, <span class="strong"><strong>when</strong></span> the song has been paused, <span class="strong"><strong>then</strong></span> it should indicate that the song is currently paused.</p><p>As shown in the following list, this acceptance criterion is written following an underlying pattern:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Given</strong></span>: This provides an initial context</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>When</strong></span>: This defines the event that occurs</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Then</strong></span>: This ensures an outcome</li></ul></div><p>In Jasmine, this translates into a very expressive language that allows tests to be written in a way that reflects actual business values. The preceding acceptance criterion written as a Jasmine test unit would be as follows:</p><div class="informalexample"><pre class="programlisting">describe("Player", function() {
  describe("when song has been paused", function() {
    it("should indicate that the song is paused", function() {

    });
  });
});</pre></div><p>You can see how the criterion translates well into the Jasmine syntax. In the next chapter, we will get into the details of how these functions work.</p><p>With Jasmine, as with other BDD frameworks, each acceptance criterion directly translates to a test unit. For that reason, each test unit is usually called a <a id="id10" class="indexterm"/>
<span class="strong"><strong>spec</strong></span>, short for specification. During the course of this book, we will be using this terminology.</p></div>
<div class="section" title="Downloading Jasmine"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Downloading Jasmine</h1></div></div></div><p>Getting started with<a id="id11" class="indexterm"/> Jasmine is actually pretty simple.</p><p>Open the Jasmine<a id="id12" class="indexterm"/> website at <a class="ulink" href="http://jasmine.github.io/2.1/introduction.html#section-Downloads">http://jasmine.github.io/2.1/introduction.html#section-Downloads</a> and download the <span class="strong"><strong>Standalone Release</strong></span> (version 2.1.3 is going to be used in the book).</p><p>While at the Jasmine website, you might notice that it is actually a live page executing the specs contained in it. This is made possible by the simplicity of the Jasmine framework, allowing it to be executed in the most diverse environments.</p><p>After you've downloaded the distribution and uncompressed it, you can open the <code class="literal">SpecRunner.html</code> file on your browser. It will show the results of a sample test suite (including the acceptance criterion we showed you earlier):</p><div class="mediaobject"><img src="graphics/B04138_01_01.jpg" alt="Downloading Jasmine"/><div class="caption"><p>This shows the SpecRunner.html file opened on the browser</p></div></div><p>This <code class="literal">SpecRunner.html</code> file<a id="id13" class="indexterm"/> is a Jasmine browser spec runner. It is a simple HTML file that references the Jasmine code, the source files, and the test files. For convention purposes, we are going to refer to this file simply as <a id="id14" class="indexterm"/>
<span class="strong"><strong>runner</strong></span>.</p><p>You can see how simple it is by opening it on a text editor. It is a small HTML file that references the Jasmine source:</p><div class="informalexample"><pre class="programlisting">&lt;script src="lib/jasmine-2.1.3/jasmine.js"&gt;&lt;/script&gt;
&lt;script src="lib/jasmine-2.1.3/jasmine-html.js"&gt;&lt;/script&gt;
&lt;script src="lib/jasmine-2.1.3/boot.js"&gt;&lt;/script&gt;</pre></div><p>The runner references the source files:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="src/Player.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="src/Song.js"&gt;&lt;/script&gt;</pre></div><p>The runner references a special <code class="literal">SpecHelper.js</code> file that contains code shared between specs:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="spec/SpecHelper.js"&gt;&lt;/script&gt;</pre></div><p>The runner also references the spec files:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="spec/PlayerSpec.js"&gt;&lt;/script&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>The <a id="id15" class="indexterm"/>Jasmine framework is set up inside the <code class="literal">lib/jasmine-2.1.3/boot.js</code> file, and although it's an extensive file, most of its content is in documentation on how the setup actually happens. It is recommended that you open it in a text editor and study its content.</p><p>Although, for now, we are running the specs in the browser, in <a class="link" href="ch08.html" title="Chapter 8. Build Automation">Chapter 8</a>, <span class="emphasis"><em>Build Automation</em></span>, we are going to make the same specs and code run on a<a id="id16" class="indexterm"/> <span class="strong"><strong>headless browser</strong></span>, such as <a id="id17" class="indexterm"/>PhantomJS, and have the results written on the console.</p><p>A headless browser is a browser environment without its graphical user interface. It can either be an actual browser environment, such as PhantomJS, which uses the WebKit rendering engine, or a simulated browser environment, such as <a id="id18" class="indexterm"/>Envjs.</p><p>And although not covered in this book, Jasmine can also be used to test server-side JavaScript code written for environments such as <a id="id19" class="indexterm"/>Node.js.</p><p>This Jasmine flexibility is amazing, because you can use the same tool to test all sorts of JavaScript code.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>In this chapter, you saw some of the motivations behind testing a JavaScript application. I showed you some common pitfalls of the JavaScript language and how BDD and Jasmine both help you to write better tests.</p><p>You have also seen how easy it is to download and get started with Jasmine.</p><p>In the next chapter, you are going to learn how to think in BDD and code your very first spec.</p></div></body></html>