- en: Journey Ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have covered the foundational concepts, techniques, and resources
    required to build interactive 3D web applications with WebGL 2\. Now that you're
    on your way to becoming a computer graphics expert, the resources in this final
    chapter are dedicated to helping you on that journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this concluding chapter, you will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cover WebGL libraries of various sizes and capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigate strategies for testing WebGL applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about 3D reconstruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the power of physically-based rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meet various graphics communities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into various WebGL libraries, we should first define what a software
    library is. Although **library** and **framework** are often used interchangeably,
    they refer to *different* concepts in computer science. A software library comprises defined
    code, configuration, documentation, classes, scripts, and more, so that developers
    may include them in their programs to enhance their products. For example, in
    developing a program requiring extensive mathematical operations, a developer
    may include a suitable software library (for example, `glMatrix`) to reduce the
    need for writing those operations themselves.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, as you may have noticed, we've built our 3D application in
    such a way that the classes, utilities, and overall architecture could, eventually,
    be turned into a library. This process was done intentionally so that we could
    learn concepts in isolation and also write code that could eventually comprise
    a feature-rich WebGL library that can be used by other applications.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, it's important to know when and where to use libraries, so
    let's cover a few WebGL libraries of various sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Small Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are a few examples of small, non-prescriptive WebGL libraries that provide
    many helpers, utilities, and abstraction layers over WebGL's low-level API.
  prefs: []
  type: TYPE_NORMAL
- en: TWGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TWGL** ([https://github.com/greggman/twgl.js](https://github.com/greggman/twgl.js))
    is an open-source WebGL library that serves to "*make using the WebGL API less
    verbose*". For example, here''s a simple TWGL demo that shows its intelligible,
    yet low-level, API on top of WebGL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the live demo on their GitHub page, which resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0b4a0d0-7e57-4002-9977-83c5d9d53ad5.png)'
  prefs: []
  type: TYPE_IMG
- en: Regl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Regl** ([https://github.com/regl-project/regl](https://github.com/regl-project/regl)) is
    an open-source WebGL library with a functional flavor. As its documentation explains,
    Regl "*simplifies WebGL programming by removing as much shared state as it can
    get away with. To do this, it replaces the WebGL API with two fundamental abstractions, **resources**
    and **commands***". Here''s the snippet of code that illustrates the functional
    Regl API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the live demo on their GitHub page, which resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8c1263a-a6bb-49b0-a9b1-d9f466f47869.png)'
  prefs: []
  type: TYPE_IMG
- en: StackGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**StackGL** ([http://stack.gl](http://stack.gl/)) is an open source WebGL project
    with an interesting approach to building WebGL applications. Instead of being bundled
    as a single library, it''s an ecosystem, comprised of many small, lean modules,
    inspired by the Unix philosophy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unix philosophyThe Unix mindset is a philosophical approach to writing minimalist,
    modular software, often expressed with the mantra "do one thing, and do it well!".
    For more information, please visit the following URL: [https://en.wikipedia.org/wiki/Unix_philosophy](https://en.wikipedia.org/wiki/Unix_philosophy).'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many 3D engines, StackGL emphasizes lean, modular code that is focused
    on writing shader code. That being said, be sure to visit their website, as it
    includes extensive documentation and demos that will help you master this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Feature-Rich Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While small, lean, and modular WebGL libraries are useful, they may not be enough
    for complex applications. Here are several feature-rich WebGL libraries that offer an
    extensive list of features and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Three.js** ([https://github.com/mrdoob/three.js](https://github.com/mrdoob/three.js)) is
    an open source library that powers many of the WebGL applications on the web. It
    aims to create an easy to use, lightweight, 3D library, with multiple renderers that
    target 2D `canvas`, WebGL, SVG, and CSS3D. Here''s a neat demo of a rotating cube,
    showcasing the simplicity of the Three.js API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the live demo on their GitHub page, which resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3895b6f4-3ce0-4b9a-bf70-85410f41a675.png)'
  prefs: []
  type: TYPE_IMG
- en: Babylon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Babylon.js** ([https://github.com/mrdoob/three.js](https://github.com/mrdoob/three.js)) is
    an open source WebGL library that came to fruition inside of Microsoft. It is
    a powerful library that was recently rewritten entirely in TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScriptTypeScript is an open source language developed by Microsoft. It is
    a powerful language that is a strict syntactical superset of JavaScript and adds
    optional static typing to JavaScript. For more information, visit [https://github.com/Microsoft/TypeScript](https://github.com/Microsoft/TypeScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although choosing Babylon.js doesn''t require using TypeScript, it can be a
    major advantage over other libraries if you or your team prefer the features that
    TypeScript provides. Here''s an interesting JavaScript demo, showcasing the simple
    Babylon.js API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the live demo on their GitHub page, which resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1702a52c-6226-4c6a-8df2-fe558719fb60.png)'
  prefs: []
  type: TYPE_IMG
- en: A-Frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**A-Frame** ([https://github.com/aframevr/aframe](https://github.com/aframevr/aframe)) is
    an open-source web framework for building virtual reality (VR) experiences. It
    is primarily maintained by Mozilla and the WebVR community. Although other WebGL
    libraries, such as Three.js and Babylon.js, offer VR support, A-Frame was designed
    entirely for building VR applications for the web.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A-Frame Core** Although A-Frame is an entirely new project, it is built on
    top of the Three.js game engine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a demo showcasing the A-Frame''s declarative API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the live demo on their GitHub page, which resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c40dbc3-8d84-4d5b-b29f-c7637f975221.png)'
  prefs: []
  type: TYPE_IMG
- en: Game Engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach to building complex 3D applications is to use an established
    game engine. A game engine is a software development environment designed so that
    people can build complex 3D applications. Although developers use 3D engines to
    create games for consoles, mobile devices, and personal computers, they can also
    be used to build interactive web applications. Two powerful game engines that
    you can use in building complex WebGL applications are Unity and PlayCanvas.
  prefs: []
  type: TYPE_NORMAL
- en: Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unity** ([https://unity3D.com](https://unity3d.com)) is a portable game engine
    developed by Unity Technologies that offers cross-platform capabilities. It was
    first announced and released in June 2005 at the Apple Inc. Worldwide Developers
    Conference as an OS X-exclusive game engine. Over the years, it has become the
    leading game engine for delivering some of the most well-known games across diverse
    platforms. Although Unity prioritizes native over web-based outputs, it does offer
    WebGL support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb5f5311-2d9d-4f91-ad52-41bdc1e36b2e.png)'
  prefs: []
  type: TYPE_IMG
- en: PlayCanvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PlayCanvas** ([https://playcanvas.com](https://playcanvas.com/)) is an open source
    3D game engine that also offers a proprietary cloud-hosted creation platform.
    Although other game engines, such as Unity, offer WebGL support, PlayCanvas was
    built from the ground-up for the web. Additionally, PlayCanvas offers a wonderful development
    experience since it has many powerful features, such as a visual workspace, full
    WebGL 2 support, simultaneous editing from multiple computers, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/452bd9d3-1a44-4fec-9ca8-0b7747c26161.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing WebGL 2 Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you happened to open your browser's debugger tools throughout this book,
    you may have noticed that the `canvas` you saw was a complete "black box". That
    is, you cannot inspect any of its elements as you could with the DOM elements
    on a web page. If you come from a traditional web-development background, this
    may seem like a big problem, since we're used to leveraging the DOM to help us
    query elements to test our application. So, how can we ensure the quality and
    stability of our WebGL applications?
  prefs: []
  type: TYPE_NORMAL
- en: Visual Regression Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Image comparisons of various application states throughout the development
    cycle is a common approach for testing WebGL applications. This technique, often referred to
    as **visual regression testing**, performs front-end or user-interface regression
    testing by capturing the screenshots of web pages/UI and comparing them with the
    original images (either historical baseline screenshots or reference images from
    a live website):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/497212fa-0ccd-4cda-9853-6e16eadb74cb.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous screenshot, you can see how the Baseline and Change are different
    via the final Diff output. This technique can be an effective approach for ensuring
    that your WebGL application continues to behave as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Regression Testing ToolsGiven your language of choice, you can find many
    open source visual regression testing tools that fit your technology stack on
    GitHub ([https://github.com/search?q=visual+regression](https://github.com/search?q=visual+regression)).
  prefs: []
  type: TYPE_NORMAL
- en: Application Introspection Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach is to mimic the DOM API by exposing your WebGL elements via
    a custom API. For example, if we want to query a DOM element by its ID, we would
    do so via `document.getElementById('element-id')`. We could do the same with jQuery's
    simpler API via `$('#element-id')`.
  prefs: []
  type: TYPE_NORMAL
- en: jQueryjQuery is a JavaScript library designed to simplify many of the common
    client-side scripting operations that are available. It is a free, open source
    software that uses the permissive MIT License. For more information, please visit [https://jquery.com](https://jquery.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an implementation of this approach, please refer to **Three Musketeers** ([https://github.com/webgl/three-musketeer](https://github.com/webgl/three-musketeer)),
    an open source library, which can be included in *any* Three.js application with
    a single line of code. By including `three-musketeers`, we can run a variety of
    queries on elements in our scene, similar to DOM elements in a web page. Here
    are some sample queries for further illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`$$$` is an alias for a `three-musketeers` instance. The `debug` method enables
    visual debugging mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find` method searches the scene for an item with the ID of `Cube_1`. By
    calling `exists`, it returns a Boolean on whether it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `find`, `findAll` returns an array of items. In this case, instead
    of searching for a unique ID, we''re looking for all of the geometries that match
    the `BoxGeometry` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We find the geometry with the unique ID, `Cube_1`, and trigger a mouse click
    event on the *appropriate* coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple technique that's very helpful for debugging. Every time we
    click in our web page, we log all intersected geometries, given the mouse click's
    2D coordinates mapped onto our 3D scene.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, be sure to check out `three-musketeers` on GitHub ([https://github.com/webgl/three-musketeers](https://github.com/webgl/three-musketeers))
    or its documentation ([https://webgl.github.io/three-musketeers](https://webgl.github.io/three-musketeers)).
  prefs: []
  type: TYPE_NORMAL
- en: 3D Reconstruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we either constructed our own geometries or imported
    models that have been created in 3D modeling tools, such as Maya or Blender. Although
    these are common approaches for building 3D assets, they require manual labor
    to create them. Are there other techniques for getting geometries? Yes, of course!
    **3D reconstruction** is the process of creating 3D models from images. It is
    the reverse process of obtaining 2D images from 3D scenes. Here''s an example
    of a 3D model that has been generated purely from aerial photographs by a technique
    called Photogrammetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03ed1032-51a4-43f3-a709-b6e1b15fc530.png)'
  prefs: []
  type: TYPE_IMG
- en: Photogrammetry
  prefs: []
  type: TYPE_NORMAL
- en: Photogrammetry is the science of making spatial measuring from photographs.
    This is a powerful technique for recovering the exact positions of surface points.
    For more information, please visit [https://en.wikipedia.org/wiki/Photogrammetry](https://en.wikipedia.org/wiki/Photogrammetry).
  prefs: []
  type: TYPE_NORMAL
- en: Physically-Based Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml), *Lights*, we learned
    how to illuminate our scene by mimicking light. We did so by leveraging various
    shading and light reflection techniques that use two main components: specular
    and diffuse. Although we''ve been modeling materials with specular and diffuse
    in computer graphics for a long time, these techniques produce results that are
    not very realistic. For example, changing the specularity of a material doesn''t
    change the diffuse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87673064-c2cb-4076-b77b-ec9b248335fc.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot demonstrates that changing the two parameters of specular
    intensity and specular hardness only changes the whitish part of the reflection.
    The blue diffuse reflection doesn't change at all—that's not how our physical
    world works! So, in applications aiming for more realistic effects, an artist
    would be tasked with manually tuning these values for each material until it "looked
    right", which is an inefficient method at best. There has to be a better way!
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter **Physically-Based Rendering** (**PBR**), an approach to validate our
    material descriptions in the more objective, measurable, and scientific properties of
    real surfaces. One of the most apparent properties is the conservation of energy:
    a rougher surface will scatter light diffusely, while a smoother/more metallic
    surface will reflect light more directly, even though it''s the same pool of light
    they are both drawn from. So, with all things being equal, the rule follows that
    as materials become shinier, the diffuse component should darken:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afb0dd66-850e-4184-9567-0de0c84ea098.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, there's more to physically-based rendering than energy conservation;
    however, this is a clear example that demonstrates the properties of a physically-based
    system. By keeping the reflection models similar to the way materials work in
    real life, we reduce the need for subjective manual tuning and produce real-world
    materials that look realistic under a variety of light conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Communities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Computer graphics is a vast landscape of complex, beautiful, and inspiring
    concepts. One of the best ways to learn, share, and inspire others is to involve
    yourself in communities dedicated to this discipline. Here is a non-exhaustive
    list of some of the most popular communities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chrome** **Experiments** ([https://experiments.withgoogle.com](https://experiments.withgoogle.com/)) is
    an online showroom of web browser-based experiments, interactive programs, and
    artistic projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebGL.com (**[https://WebGL.com](https://webgl.com/)) is the leading community
    for WebGL developers and comprises demos, tutorials, news, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SketchFab **([https://sketchfab.com](https://sketchfab.com/)) is a platform to
    publish, share, discover, buy, and sell 3D, VR, and AR content. It provides a
    viewer based on the WebGL and WebVR technologies that allows users to display
    3D models on the web.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ShaderToy **([https://www.shadertoy.com](https://www.shadertoy.com/)) is
    a cross-browser online community and tool for creating and sharing shaders through
    WebGL, used both for learning and teaching 3D computer graphics in a web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CGTrader **([https://www.cgtrader.com/3D-models](https://www.cgtrader.com/3d-models)) is
    an online platform that allows designers and modeling studios to upload and either
    sell or share their 3D models with their community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TurboSquid **([https://www.turbosquid.com](https://www.turbosquid.com/)) is
    a digital media company that sells stock 3D models used in 3D graphics to a variety
    of industries, including computer games, architecture, and interactive training.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poly **([https://poly.google.com](https://poly.google.com/)) is a website that
    was created by Google for users to browse, distribute, and download 3D objects.
    It features a free library containing thousands of 3D objects that can be used
    in virtual reality and augmented reality applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for taking the time to read this book. By covering a wide range of
    topics—such as rendering, shaders, 3D math, lighting, cameras, textures, and many
    more—and guiding you in building compelling 3D applications, we hope that it has
    accomplished its goal of helping you learn interactive 3D computer graphics with
    WebGL 2.
  prefs: []
  type: TYPE_NORMAL
- en: “Stories don't end," he says. "They just turn into new beginnings."
  prefs: []
  type: TYPE_NORMAL
- en: – Lindsay Eagar, Hour of the Bees
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, please be sure to stay in touch and share your work—we look
    forward to seeing what you build! If you have any questions or feedback, please
    refer to the preface of this book for contact details.
  prefs: []
  type: TYPE_NORMAL
