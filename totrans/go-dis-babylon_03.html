<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-49"><a id="_idTextAnchor049"/>3</h1>
<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Establishing the Development Workflow</h1>
<p>While it is an extremely versatile and powerful tool for developing, running, and sharing a working 3D rendered scene, the <strong class="bold">Babylon.js Playground</strong> (<strong class="bold">PG</strong>) also has a place in the development workflow of a traditional web application. Effective software development is effectively enabled by the removal of friction. Friction in this sense is anything that presents an obstacle between writing code and executing the results and can take almost any form, from the mundane to the obscure. As an example, say it takes an hour between the time a change is made in code to the time that changed code is running in the developer’s web browser. The developer will then be compelled to include as much as possible in every new build, which then makes it more difficult to understand the effects of any one change on the application’s behavior. Focus is diluted and progress is incremental and not in proportion to the effort required in these situations, which is why small tweaks to a development workflow can yield large gains. We’re going to examine one out of many potential <strong class="bold">Babylon.js</strong> development workflows during the course of this chapter, and by the end of it, you will have the tools to rapidly and efficiently build games that can evolve as rapidly as you can think of designs!</p>
<p>Everyone is going to have a different way of approaching the structure and process of development, and that’s OK. Each of these sections illustrates an aspect of the workflow that seeks to maximize developer efficiency and quality while minimizing tech debt and uncertainty:</p>
<ul>
<li>Setting up the Environment</li>
<li>Crafting a Playground Snippet</li>
<li>Transitioning from the Playground to the Application</li>
<li>Constructing the Landing Page</li>
</ul>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>Technical Requirements</h1>
<p>The base set of requirements for running the BJS PG are detailed in <a href="B17266_02_Final_AM.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Ramping up on Babylon.js</em>, but in addition to those requirements, there are some additional development tools that we’re going to be using. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">Although the examples and such are all based on a Windows-based developer experience, there are no Operating System requirements to follow along with this book. All of the tools discussed are available on multiple platforms and any differences in syntax or usage will be highlighted or called out where feasible.</p>
<p>The specific usages of each individual item will be covered during the accompanying chapter material, and it is assumed that you have some familiarity with the tools and/or usage. For information on setting up and configuring a given tool, please see the corresponding link to the tool’s documentation.</p>
<ul>
<li><strong class="bold">Visual Studio Code</strong> is our IDE of choice, is available on all platforms, works wonderfully, and is free: <a href="https://code.visualstudio.com">https://code.visualstudio.com</a> </li>
<li><strong class="bold">Node.js v14.15.4 (LTS)</strong> or greater: <a href="https://docs.npmjs.com/">https://docs.npmjs.com/</a></li>
<li><strong class="bold">Node Package Manager (npm) CLI v6.x (LTS Release)</strong> or greater, installed via a node version manager listed at <a href="https://docs.npmjs.com/cli/v6/configuring-npm/install">https://docs.npmjs.com/cli/v6/configuring-npm/install</a></li>
<li><strong class="bold">Git</strong> SCM client. Also, to be able to submit <strong class="bold">Pull Requests</strong>, file <strong class="bold">issues</strong>, or participate in <strong class="bold">Discussions</strong>, a valid GitHub account is required: <a href="https://github.com">https://github.com</a></li>
</ul>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/>A Note for TypeScript Users</h2>
<p>Should you prefer to do all your coding in <strong class="bold">TypeScript</strong> as opposed to straight-JavaScript, that’s great! Babylon.js itself is <a id="_idIndexMarker089"/>written in <strong class="bold">TypeScript</strong> and is fully supported for developing in BJS. Following along with the code in this book is possible, and any differences in syntax and structure aren’t always going to be explained or called out. That said, the code should be largely compatible between the two languages, keeping in mind the following two primary changes:</p>
<ol>
<li>Playground snippets should use TypeScript mode. This has a slightly different template. Start at <a href="https://www.babylonjs-playground.com/ts.xhtml#">https://www.babylonjs-playground.com/ts.xhtml#</a> and click <strong class="bold">New</strong> The <strong class="source-inline">createScene</strong> method is encapsulated as a <strong class="bold">static method</strong> within a class called <strong class="source-inline">Playground</strong>. Declare new classes and use them in the <strong class="source-inline">createScene</strong> method similar to how you would in regular JavaScript.</li>
<li>When integrating classes written in the PG, it’s important to add the <strong class="bold">export</strong> modifier to <a id="_idIndexMarker090"/>your <strong class="bold">class</strong> declaration, (e.g. <strong class="source-inline">export class Foo { //… }</strong>). Since you will be using the <strong class="bold">tsc</strong> (<strong class="bold">TypeScript Compiler</strong>) to output JavaScript, there are times when you’ll need to <strong class="bold">import</strong> certain Babylon.js modules for their <strong class="bold">side effects</strong>. Please see <a href="https://doc.babylonjs.com/divingDeeper/developWithBjs/npmSupport#typescript-support">https://doc.babylonjs.com/divingDeeper/developWithBjs/npmSupport#typescript-support </a>for more on how to configure <strong class="bold">TypeScript</strong> for use with Babylon.js</li>
</ol>
<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/>Setting up the Environment</h1>
<p>Effective software development relies on being able to confidently introduce changes to an application’s <a id="_idIndexMarker091"/>construction. Confidence in introducing, changing, or removing code comes from a) being able to run the code using the new changes, and b) through not being in a position where undoing changes imposes risks of its own. Let’s park that thought for a moment to back up and start from the beginning.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>Preparatory Steps</h2>
<p>The <em class="italic">a priori</em> assumption going into this step is that you have <strong class="bold">G</strong><strong class="bold">it</strong>, <strong class="bold">VSCode</strong>, <strong class="bold">Node.js</strong>, and <strong class="bold">NPM</strong> all set up and <a id="_idIndexMarker092"/>ready to go. A linting tool such as <strong class="bold">ESLint</strong> is also recommended. If you know what you’re doing, go ahead and get those tools set up and configured now. No rush, it’s just the rest of the book that’s waiting is all – this has been speculated to go faster if you work while humming <em class="italic">The Girl from Ipanema</em> to yourself. <strong class="bold">VSCode</strong> has a rich ecosystem of extensions that can make your life easier. Here is a list of some of the ones you’ll want to install (or their equivalents). Go <a id="_idIndexMarker093"/>to the <strong class="bold">Extensions</strong> panel in <strong class="bold">VSCode</strong>, then <a id="_idIndexMarker094"/>search for the appropriate item’s <strong class="bold">Marketplace ID</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<img alt="Figure 3.1 – List of useful VSCode extensions&#13;&#10;" height="921" src="image/Figure_3.01_B17866.jpg" width="1617"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – List of useful VSCode extensions</p>
<p>If you’re not quite there yet when it comes to knowing where and how to do this sort of thing, here’s what you can do. Ignore the elevator muzak, tie a bandana around your forehead, and dive <a id="_idIndexMarker095"/>straight into an 80s movie montage sequence. You will probably want to set a bookmark on this page first – the montage features a series of vignettes of you flipping to the <em class="italic">Further Reading</em> section at the end of this chapter, reading and following the links, culminating in a triumphantly successful installation… and then flipping back to your bookmark, ready to continue the journey.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Initialize All the Things</h2>
<p>There are a number of unflashy tasks that go on here – things such as creating a new Git repository <a id="_idIndexMarker096"/>in GitHub and cloning it locally, which would take up too much space to go through in detail. Instead, here’s a rough checklist of what to expect to do as part of this step:</p>
<ol>
<li value="1">Create a new <strong class="bold">Git</strong> repository. If created in <strong class="bold">GitHub</strong>, you may need to <strong class="bold">clone</strong> the repos locally.</li>
<li>Add a <strong class="source-inline">.gitignore</strong> file to the repos – the only contents it really needs at this point are entries for the output <strong class="source-inline">dist/</strong> folder and for the <strong class="source-inline">node_modules/</strong> folders.</li>
<li>Create some folders – <strong class="source-inline">src</strong>, <strong class="source-inline">dist</strong>, <strong class="source-inline">public</strong>, and <strong class="source-inline">assets</strong> – to hold the source code, the packed output, and game assets, respectively.</li>
<li>Run <strong class="source-inline">npm init</strong> to create a <strong class="source-inline">package.json</strong> for the application.</li>
<li>Install webpack and core Babylon.js libraries and dependencies as developer dependencies with this command: <p class="source-code">npm install -–save-dev webpack webpack-cli webpack-</p><p class="source-code">  dev-server webpack-merge clean-webpack-plugin file-</p><p class="source-code">  loader html-webpack-plugin source-map-loader url-</p><p class="source-code">  loader eslint `@babylonjs/core </p></li>
<li>Install <a id="_idIndexMarker097"/>additional Babylon.js modules that we’ll be using:<p class="source-code">npm install -save-dev @babylonjs/materials</p><p class="source-code">  @babylonjs/loaders @babylonjs/gui</p><p class="source-code">  @babylonjs/procedural-textures @babylonjs/post-</p><p class="source-code">  processes @babylonjs/serializers</p><p class="source-code">  @babylonjs/inspector</p></li>
</ol>
<p>With the package dependencies squared away, it’s time to add a few more foundational pieces to our nascent application.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>Scripts and ESLint Configuration</h2>
<p>At some point in the very near future, we’re going to want to be able to add some automation around our application’s build and deployment tasks. The key to making this as frictionless as possible is to leverage as much of the (and similar) application infrastructure as possible. Keeping it simple and focusing scripts on a single task will allow for easier automation in the future.</p>
<h3>package.json Scripts</h3>
<p>There are three basic commands that we want to start out adding to our <strong class="source-inline">package.json</strong> file. These <a id="_idIndexMarker098"/>are simple scripts that will allow both local and production builds and linting of source. We’ll address dev versus production builds in an upcoming section, but for now, add these scripts to the <strong class="source-inline">package.json</strong> file:</p>
<ul>
<li><strong class="source-inline">start</strong>: The webpack dev server and related packing processes for local development. Command: <strong class="source-inline">npx webpack serve --mode development</strong> </li>
<li><strong class="source-inline">build</strong>: Runs webpack in production configuration. Command: <strong class="source-inline">npx webpack --mode production</strong></li>
<li><strong class="source-inline">lint</strong>: Makes sure our code doesn’t have any big “whoopsies!”. Command: <strong class="source-inline">npx eslint</strong></li>
</ul>
<p>Check your work for typos, and make sure that you save and commit both your <strong class="source-inline">package.json</strong> and your <strong class="source-inline">package.lock.json</strong> files. At this point, we’re still a couple of items short on our checklist to set up the application, so let’s get them knocked out so we can press forward on our journey!</p>
<p class="callout-heading">Important Note</p>
<p class="callout">While it is possible to simply reference and load the entire Babylon.js library into the application, it is incredibly inefficient to do so – because BJS does so much, there’s a lot to the libraries, meaning they’re quite large in size and complexity. Clients are forced to download the full bundle of JS before the application can become responsive to input, reducing a user’s perception of an application’s performance. One of the most modern and effective ways to reduce an application’s footprint is by leveraging a feature of <strong class="bold">ES6</strong> called <strong class="bold">tree shaking</strong>. The process of tree shaking results in code output that includes only dependencies that are <a id="_idIndexMarker099"/>actually used in the code, resulting in smaller, faster, and more efficient JavaScript modules. </p>
<p class="callout">What’s the downside? As you’ll see, every imported type must have its own <strong class="source-inline">import</strong> statement, but in addition, the full path of the type must be specified – not just the containing package. Still, the benefits can be substantial – as I commented in this pull request: <a href="https://github.com/jelster/space-truckers/pull/15">https://github.com/jelster/space-truckers/pull/15</a>. The start scene was reduced in size from 8.91 MB to 3.11 MB, a more than 50% reduction!</p>
<p class="callout">Babylon.js has been around longer than ES6 modules have been supported, and the team has made a firm commitment to support backward compatibility in the engine. That’s why you’ll notice there are some places where compromises in that vein result in the need to import modules purely for side effects – the <strong class="bold">MeshBuilder CreateXXXX</strong> APIs are a <a id="_idIndexMarker100"/>prominent example of this. The BJS docs have more information located at <a href="https://doc.babylonjs.com/divingDeeper/developWithBjs/treeShaking">https://doc.babylonjs.com/divingDeeper/developWithBjs/treeShaking</a> that can explain more about why and what modules behave in this fashion.</p>
<p>The PG examples we’ve looked at previously haven’t required anything special in the way of <a id="_idIndexMarker101"/>building, but that’s because the PG is built towards a different goal than what we’re looking to accomplish. We’re building a complete application that needs to not be dependent on the same luxuries (such as a CDN for grabbing the Babylon.js libraries) as the PG. To do that, we will sacrifice the flexible but inefficient load-everything approach of the PG for the compactness and efficiency of a webpacked application. </p>
<h3>Adding Configuration for ESLint </h3>
<p>Add a new file using VSCode to the root folder of your repository, named <strong class="source-inline">.eslintignore</strong>. This <a id="_idIndexMarker102"/>is a text file that we’ll use to exclude certain directories from being checked by the lint tool, improving responsiveness and reliability. We don’t want our <strong class="source-inline">node_modules</strong> directory to be checked since we’re not working on those libraries. Neither do we care about JavaScript that’s already been packaged and output – anything in our <strong class="source-inline">dist/</strong> folder. Add the following lines to the <strong class="source-inline">.eslintignore</strong> file you’ve just created:</p>
<p class="source-code">node_modules</p>
<p class="source-code">dist</p>
<p>Save and close the file. </p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Configuring Webpack</h2>
<p>Add another new file to the root directory and name it <strong class="source-inline">webpack.common.js</strong>, then create another <a id="_idIndexMarker103"/>two named <strong class="source-inline">webpack.dev.js</strong> and <strong class="source-inline">webpack.prod.js</strong>. We’ll put the base webpack config <a id="_idIndexMarker104"/>in the <strong class="source-inline">webpack.common.js</strong> file and merge environment-specific config at script runtime using <strong class="source-inline">webpack-merge</strong>. At the same time, create a new empty file in <strong class="source-inline">src</strong> and name it <strong class="source-inline">index.js</strong> along with an empty <strong class="source-inline">index.xhtml</strong> in the <strong class="source-inline">public/</strong> directory. This will serve as a placeholder for future work while allowing us to test and validate our current config.</p>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="bold">Webpack</strong> has a lot of different ways and means of configuration, which can sometimes make it hard to figure <a id="_idIndexMarker105"/>out which way, or how, to approach a particular scenario. Always keep in mind what you want to accomplish and finding a path can be much easier. In this case, the end goal of using <strong class="bold">Webpack</strong> is to identify, aggregate, and compress the source code for our application into an atomic set of bundled JavaScript written to our <strong class="source-inline">dist/</strong> folder. Other related assets may also be affected in ways ranging from generating correct URL paths to rendering markup templates into output <a id="_idIndexMarker106"/>directories and more. Check out the <strong class="bold">Webpack</strong> repos along with the docs at <a href="https://github.com/webpack/webpack">https://github.com/webpack/webpack</a> to learn more about configuration and plugin options.</p>
<h3>Development versus Production Modes</h3>
<p>When running in a production build context, there are really only two things we need to happen. First, Webpack <a id="_idIndexMarker107"/>does its thing, bundling and packaging up all the <strong class="source-inline">.js</strong> scripts in the <strong class="source-inline">src/</strong> folder, outputting the results to the <strong class="source-inline">dist/</strong> folder. Second, a script reference to the application’s entry point – <strong class="source-inline">index.js</strong> – is injected into an <strong class="source-inline">index.xhtml</strong> file that is what gets served to web browsers. </p>
<p>Local development has a slightly different set of needs than a production build. We want to be able to make changes to our code and see the results of those changes as quickly as possible, which rules out the potentially lengthy process of re-bundling everything from scratch upon a change. Instead, the <strong class="bold">webpack development server</strong> is smart enough to both cache build output and selectively rebuild only what’s been changed. A <strong class="bold">WebSocket</strong> connection to the browser is used to automatically refresh the page when a new bundle is compiled, helping further to close any gaps in iteration. We also want to <a id="_idIndexMarker108"/>emit JavaScript <strong class="bold">source maps</strong> to aid in debugging as well as to specify content paths for non-bundled content served by our development server. </p>
<h3>Common Webpack Config</h3>
<p>Regardless of whether webpack is being run for development or production usage, we always want to <a id="_idIndexMarker109"/>make sure that our destination directory is cleaned of any old or potentially stale source files. We’ll use the <strong class="source-inline">CleanWebpackPlugin</strong> for that purpose, and the <strong class="source-inline">HtmlWebpackPlugin</strong> to inject the proper script references into our <strong class="source-inline">index.xhtml</strong> template. </p>
<p>Back to the <strong class="source-inline">webpack.common.js</strong> file, let’s add some <strong class="source-inline">import</strong> statements and define the <strong class="source-inline">module.exports</strong> stub function:</p>
<pre class="source-code">&#13;
const path = require("path");&#13;
const HtmlWebpackPlugin = require(«html-webpack-plugin»);&#13;
const { CleanWebpackPlugin } = require(«clean-webpack-&#13;
  plugin");&#13;
const appDirectory = __dirname;&#13;
module.exports = env =&gt; {&#13;
    return {&#13;
    };&#13;
};</pre>
<p>You may notice that unlike the rest of our application, our webpack configuration isn’t using <strong class="bold">ES6 module syntax</strong>. This is one you’ll probably just need to get over for now, because although there <a id="_idIndexMarker110"/>are workarounds, it’s overall more trouble than it’s worth to use ES6 syntax in just a couple of files that aren’t part of the build output. The configuration requires an <strong class="source-inline">entry</strong> object that designates the script that will serve to launch our application on the client; it will be injected into a <strong class="source-inline">&lt;script&gt;</strong> tag in the site’s default <strong class="source-inline">index.xhtml</strong> landing page. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">File and folder paths can be tricky to navigate when working in a cross-platform environment. The <strong class="source-inline">__dirname</strong> webpack-provided variable is a good way to avoid problems in the first place because it will correctly and consistently represent the equivalent of <strong class="source-inline">fs.cwd()</strong>.</p>
<p>The <strong class="source-inline">entry</strong> item and potentially other config elements will need to know what base paths to use when reading and writing files, so we designate and compute that value. While we’re at it, we <a id="_idIndexMarker111"/>might as well add the output entry to our config. This object specifies where to emit the packed results, and to help identify it among potential other scripts we name it <strong class="source-inline">babylonBundle.js</strong>. Finally, we instantiate new instances of our <strong class="source-inline">CleanWebpackPlugin</strong> and <strong class="source-inline">HtmlWebpackPlugin</strong> modules. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">The order that plugins are added to the plugins array is important! Make sure that your <strong class="source-inline">CleanWebpackPlugin</strong> is always at <a id="_idIndexMarker112"/>the top of the plugin list so that it runs first.</p>
<p>The <strong class="source-inline">HtmlWebpackPlugin</strong> is given the path to our publicly served HTML <strong class="source-inline">index.xhtml</strong> page and told to inject the proper script tags for the bundle into the document. Once that is done, we’ll test our config quickly before completing the common (and also the biggest) configuration setup:</p>
<pre class="source-code">&#13;
module.exports = {&#13;
    const appDirectory = __dirname; &#13;
    return {&#13;
        entry: «./src/index.js"),&#13;
        output: {&#13;
            filename: «js/babylonBundle.js",&#13;
            path: path.resolve(appDirectory, "./dist")&#13;
        },&#13;
        plugins: [&#13;
            new CleanWebpackPlugin(),&#13;
            new HtmlWebpackPlugin({&#13;
                template: path.resolve("public/index.xhtml"),&#13;
                inject: true&#13;
            })&#13;
        ]&#13;
    };&#13;
};</pre>
<p>By specifying an <strong class="source-inline">assetModuleFilename</strong> pattern, we are instructing <strong class="bold">WebPack</strong> to output any assets resolved (see the next section) into the output’s <strong class="source-inline">assets</strong> subfolder with the original file name, extension, and any query string parameters. To test out our configuration, make sure <a id="_idIndexMarker113"/>you’ve saved everything and enter the following command in a terminal window (make sure your working directory is the same as the root of the repository):</p>
<p class="source-code">npx webpack –config webpack.common.js</p>
<p>If everything goes well, you should see a bunch of text in your command window, some green text, and no errors. That’s great, but there’s not much of anything going on so we can’t take a break quite yet – we’re very close to finishing this section!</p>
<h3>Resolver and Loader Configuration</h3>
<p>As part of processing <a id="_idIndexMarker114"/>your source code, Webpack will compile a list of <a id="_idIndexMarker115"/>all the various <strong class="bold">import</strong> (or require for CommonJS modules) and invoke a processing pipeline that uses matching rules to select the appropriate logic to resolve the location for the request. </p>
<p class="callout-heading">Note</p>
<p class="callout">This is an area where <strong class="bold">TypeScript</strong> users will see significant differences between their implementations and this ES6 (-ish) one. <strong class="bold">Raanan Weber</strong> of the BJS team has made a TypeScript <a id="_idIndexMarker116"/>starter repository available at <a href="https://github.com/RaananW/babylonjs-webpack-es6">https://github.com/RaananW/babylonjs-webpack-es6</a>. The TypeScript Webpack code listed here is modeled to be as similar as possible to Raanan’s starter template to make transitioning between reading this text and your code easier.</p>
<p>To avoid the need to have to code for environmental differences in static asset URLs, we use <strong class="bold">asset loader</strong> to serve up various types of asset files from the assets folder as described previously. The <strong class="source-inline">source-map-loader</strong> helps to match symbols from runtime code with <a id="_idIndexMarker117"/>locations in the source code. Before that though, our <a id="_idIndexMarker118"/>config needs a <strong class="source-inline">resolve</strong> object that specifies an array of <strong class="source-inline">extensions</strong> to enable searching through. Add this as a property of the returned config, just below the <strong class="source-inline">output</strong> property. Here’s what that part of the config might look like:</p>
<pre class="source-code">&#13;
// entry, output, etc…        &#13;
        resolve: {&#13;
            extensions: [".js"],&#13;
            fallback: {&#13;
                fs: false,&#13;
                path: false,&#13;
            },&#13;
        },&#13;
        module: {&#13;
            rules: [  &#13;
             {&#13;
                test: /\.(png|jpg|gif|env|glb|stl)$/i,&#13;
                use: [&#13;
                {&#13;
                  loader: "url-loader",&#13;
                  options: {&#13;
                    limit: 8192,&#13;
                  },&#13;
                 },&#13;
               ],&#13;
        },&#13;
// plugins, etc.</pre>
<p>The list of <strong class="source-inline">rules</strong> in the <strong class="source-inline">modules</strong> property define what constitutes a separate module in the eyes of <strong class="bold">WebPack</strong>. Each of these <a id="_idIndexMarker119"/>has their own configuration that defines a <strong class="bold">regular expression</strong>-based <strong class="source-inline">test</strong> to perform to see whether the given <a id="_idIndexMarker120"/>loader will handle the request. The long regular <a id="_idIndexMarker121"/>expression for the asset/resource module type is essentially a list of all the different file extensions that we want to be considered as assets, which are copied without further processing into the output directory.</p>
<h3>Webpack Development and Production Configurations</h3>
<p>In our <strong class="source-inline">webpack.dev.js</strong>, we’re going to make use of the <strong class="source-inline">webpack-merge</strong> add-on to webpack. This handy <a id="_idIndexMarker122"/>utility will merge two webpack config <a id="_idIndexMarker123"/>objects together, returning the combined result. Why is this handy? Because we’ll be able to have separate development and production configurations without needing to hardcode their names into the <strong class="source-inline">webpack.common.js</strong> or the <strong class="source-inline">package.json</strong> scripts. If we want to add another environment configuration, all we need to do is add the new webpack config file, merge our common config, and then point our <strong class="source-inline">npx webpack --config</strong> parameter at the appropriate file.</p>
<p>There are really only two things we need from our dev config that we don’t have in common. First, configuration for the web server launched with <strong class="source-inline">npx webpack serve</strong>. Second, we specify that we want our source maps to be sent inline with our scripts. The top-level mode of “development” ensures that various production-suited optimization paths are not taken by webpack. This is what our <strong class="source-inline">webpack.dev.js</strong> looks like when we’re done:</p>
<pre class="source-code">&#13;
const { merge } = require('webpack-merge');&#13;
const common = require('./webpack.common.js');&#13;
const path = require('path');&#13;
const appDirectory = __dirname;&#13;
const devConfig = {&#13;
    mode: "development",&#13;
    devtool: "inline-source-map",&#13;
    devServer:  {&#13;
        contentBase: path.resolve(appDirectory, "public"),&#13;
        compress: true,&#13;
        hot: true,&#13;
        open: true,&#13;
        publicPath: "/"&#13;
    }&#13;
};&#13;
module.exports = merge(common, devConfig);</pre>
<p>Creating <strong class="source-inline">webpack.prod.js</strong> is even simpler since we don’t need the dev server configuration, and it <a id="_idIndexMarker124"/>shares the same set of top-level <strong class="source-inline">require</strong> statements as <a id="_idIndexMarker125"/>our dev configuration. To reduce the size of our script packages, we will choose not to emit source maps, and other than setting the mode to <strong class="bold">production</strong>, that’s the only difference:</p>
<pre class="source-code">&#13;
const { merge } = require('webpack-merge');&#13;
const common = require('./webpack.common.js');&#13;
const prodConfig = {&#13;
    mode: "production"&#13;
};&#13;
module.exports = merge(common, prodConfig);</pre>
<p>Before we <a id="_idIndexMarker126"/>shift our focus a bit, let’s get some markup into <a id="_idIndexMarker127"/>our <strong class="source-inline">public/index.xhtml</strong> file. We don’t need much right now, so let’s start with this simple markup:</p>
<pre class="source-code">&#13;
&lt;!doctype html&gt;&#13;
&lt;html lang="en"&gt;&#13;
&lt;head&gt;&#13;
  &lt;meta charset="utf-8"&gt;&#13;
  &lt;title&gt;Space-Truckers: The Video Game!&lt;/title&gt;&#13;
    &lt;style&gt;&#13;
      html,&#13;
      body {&#13;
        overflow: hidden;&#13;
        width: 100%;&#13;
        height: 100%;&#13;
        margin: 0;&#13;
        padding: 0;&#13;
      }&#13;
      canvas {&#13;
        width: 100%;&#13;
        height: 100%;&#13;
        touch-action: none;&#13;
      }&#13;
    &lt;/style&gt;&#13;
  &lt;/head&gt;&#13;
  &lt;body&gt;&#13;
  &lt;/body&gt;&#13;
&lt;/html&gt;</pre>
<p>This is <a id="_idIndexMarker128"/>enough for us to check our progress by making sure <a id="_idIndexMarker129"/>all files have been saved before running <strong class="source-inline">npm run start</strong>. Success is indicated by the launching of your web browser and a console output similar to this screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="Figure 3.2 – Webpack output after successful bundle" height="469" src="image/Figure_3.02_B17866.jpg" width="1201"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Webpack output after successful bundle</p>
<p>While the webpack development server is running, any changes you make to your source code will automatically refresh your browser. Leave the dev server running, because we’re going to start making use of it!</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Crafting a PG Snippet</h1>
<p>Before we can use our PG code in our application, we’re going to need to do some light refactoring. A little bit of <a id="_idIndexMarker130"/>preparation can save a lot of time later! The things we’re going to change are select pieces of code that could vary between the PG and local environments, such as texture paths and URLs, along with some minor structural modifications. For your convenience, here’s a link to the refactored snippet. If you are just joining us here in the journey, use the link below. If you’ve been following along, substitute your own snippet URL for the following one. Start by opening your favorite browser and navigating to either your own snippet or to <a href="https://playground.babylonjs.com/%230UYAPE%2342">https://playground.babylonjs.com/#0UYAPE#42</a>. </p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>Cleaning up the BABYLON Namespace Prefix</h2>
<p>One of the things that you may have found annoying about coding in the PG is how in the PG it’s <a id="_idIndexMarker131"/>necessary to <a id="_idIndexMarker132"/>always prefix BJS types with the <strong class="source-inline">BABYLON</strong> namespace. This is not ideal, but we can get rid of the need for them by adding an alias to all the various types we’re using to the top of our snippet. The alias in our PG snippet will be defined as a <strong class="source-inline">const</strong> assembled from the various BJS types used:</p>
<pre class="source-code">&#13;
const { Mesh,&#13;
MeshBuilder,&#13;
StandardMaterial, &#13;
// ...&#13;
} = BABYLON; </pre>
<p>We can then do a Find and Replace (<em class="italic">Ctrl + F</em> or <em class="italic">Command + F</em>) for the string <strong class="source-inline">BABYLON.</strong> (don’t forget the period!) and that will complete our work on this section. To preview where this is headed, when we move this into our VSCode environment, we’ll convert this to an <strong class="source-inline">import</strong> statement. Doing this refactoring after the fact, like we are in this case, isn’t ideal; in the future, we will start our snippets out with this construct and build it over time. That way, it won’t be nearly as much effort!</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/>Extracting Magic Strings</h2>
<p>There are three separate textures (not including the procedural one) in use in our snippet, and we <a id="_idIndexMarker133"/>want to make it easier to change the <a id="_idIndexMarker134"/>specific URL or file path. We begin that by defining a set of <strong class="source-inline">const</strong> strings in the PG to contain the PG-specific paths:</p>
<pre class="source-code">&#13;
const distortTexture = "textures/distortion.png";&#13;
const rockTextureN = "textures/rockn.png";&#13;
const rockTexture = "textures/rock.png";</pre>
<p>We can then go into the <strong class="source-inline">createStar</strong> and <strong class="source-inline">createPlanet</strong> functions and replace the hardcoded paths with our constant expressions:</p>
<pre class="source-code">&#13;
mat.diffuseTexture = new Texture(distortTexture, scene);</pre>
<p>Once you’ve replaced all of the hardcoded string values, click <strong class="bold">Save</strong> and refresh the page to make <a id="_idIndexMarker135"/>sure the snippet still runs OK, paying attention <a id="_idIndexMarker136"/>to any missing textures, and fixing any missing references that may pop up. With these changes in place, it will be a smooth transition from running this in the PG to using it in our application.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>Transitioning from the PG to the Application</h1>
<p>The PG is a rich, robust, and extensible way to quickly get started writing and running code, but <a id="_idIndexMarker137"/>our application has different needs from the PG that we will need to account for and fulfill. We want to make sure that our code is both easy to change and easy to understand, but fortunately, there are small steps we can take that will make a large difference later on.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/>Creating the Engine Instance</h2>
<p>Now, the immediate question is this: how do we take our plucky snippet here and plug it into our application <a id="_idIndexMarker138"/>without turning it into an exercise in both masochism and self-discipline? The secret lies in preparation. When we built our PG snippet, we structured logic as atomically as possible into various discrete <strong class="bold">functions</strong>, which have all their <strong class="bold">dependencies</strong> passed in as <strong class="bold">parameters</strong>. This will help us “lift-and-shift” the code into our application. First, though, we need to add some code to our <strong class="source-inline">index.js</strong> that will take the place of the PG’s <strong class="source-inline">engine</strong> initialization. Add this to the file below the part where we created the <strong class="source-inline">canvas</strong> element:</p>
<pre class="source-code">&#13;
let eng = new Engine(canvas, true, null, true);&#13;
let startScene = createStartScene(eng);&#13;
eng.runRenderLoop(() =&gt; {&#13;
    startScene.scene.render();&#13;
});</pre>
<p>This is a pretty bog-standard Babylon.js <strong class="source-inline">Engine</strong> initialization. The <strong class="source-inline">Engine</strong> constructor has a number of interesting different parameters and configuration options that we’ll explore further on down the road. For now, we are mostly using the engine defaults except for enabling <strong class="bold">anti-aliasing</strong> (the second parameter) and instructing the engine to adapt automatically <a id="_idIndexMarker139"/>to the device’s viewport ratio (the last parameter). Although it’s not yet part of the project, we’ve added the necessary call to <strong class="source-inline">createStartScene</strong> in anticipation of its imminent arrival. </p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>Adding and Importing the StartScene</h2>
<p>Create a new <a id="_idIndexMarker140"/>file in your project’s <strong class="source-inline">src</strong> folder <a id="_idIndexMarker141"/>and name it <strong class="source-inline">startscene.js</strong>. Copy and paste everything from the PG snippet into this new file <em class="italic">except</em> the <strong class="source-inline">createScene</strong> function. A couple of minor modifications are all that’s needed thanks to the groundwork we previously laid down! </p>
<p>Change the <strong class="source-inline">const</strong> to <strong class="source-inline">import</strong>, also replacing the <strong class="source-inline">=</strong> with <strong class="source-inline">from</strong> <strong class="source-inline">“@babylonjs/core”</strong> as the name to source imports. The <strong class="source-inline">StarfieldProceduralTexture</strong> isn’t a part of the core BJS framework, so we’ll also need to pull that entry out of the import list and give it its own entry: <strong class="source-inline">import { StarfieldProceduralTexture } from “@babylonjs/procedural-textures”;</strong>.</p>
<p>The final change is to replace our <strong class="source-inline">const</strong> texture paths with <strong class="source-inline">import</strong> statements pointing to the appropriate texture in our <strong class="source-inline">/assets/textures</strong> folder. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">If you don’t already have the three textures downloaded and in the asset directory, now would be a good time to do it. The URL prefix for textures is just <a href="https://www.babylonjs-playground.com/textures/">https://www.babylonjs-playground.com/textures/</a>, followed by the name of the texture with the extension, (e.g., <strong class="source-inline">rock.png</strong>). We want to be able to use consistent paths to refer to assets throughout the application, so we are using <strong class="bold">Webpack</strong> to resolve and supply the runtime URL to a given asset. The way we are telling Webpack to provide these URLs is via the <strong class="source-inline">import</strong> statement. </p>
<p class="callout">Why don’t we just use the online version of the resource instead of duplicating it locally? Good question. Later <a id="_idIndexMarker142"/>on in the book, we’ll cover how to make Space-Truckers into a <strong class="bold">Progressive Web Application</strong> (<strong class="bold">PWA</strong>), and how to make assets available for offline use.</p>
<p>When the <strong class="bold">Webpack bundle</strong> is created, any assets referenced in one of these <strong class="source-inline">import</strong> statements will <a id="_idIndexMarker143"/>be included in the build <a id="_idIndexMarker144"/>output. In addition, the asset is assigned a unique filename that helps bust aggressive caches when assets are modified:</p>
<pre class="source-code">&#13;
import distortTexture from&#13;
  "../assets/textures/distortion.png";&#13;
import rockTextureN from "../assets/textures/rockn.png";&#13;
import rockTexture from "../assets/textures/rock.png";</pre>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/>Exporting and Importing the Start Scene</h2>
<p>One last item to add to our <strong class="source-inline">startscene.js</strong> and we’ll be ready to finish wiring it into the game! If we <a id="_idIndexMarker145"/>reflect back on <a id="_idIndexMarker146"/>the overall design of our snippet’s functions, we can readily see that the only “public” function need be the <strong class="source-inline">createStartScene</strong> function. Let’s make that function available to consumers by adding <strong class="source-inline">export default</strong> to the function declaration:</p>
<pre class="source-code">&#13;
<strong class="bold">export default</strong> function createStartScene(engine) {</pre>
<p>Save the file and switch back to your <strong class="source-inline">index.js</strong>. Since we’ve already added the invocation of the <strong class="source-inline">createStartScene</strong> and the following <strong class="bold">render loop</strong>, all we need to do to make this complete is to add the following <strong class="source-inline">import</strong> to the top of the file’s import list: <strong class="source-inline">import createStartScene from “./startscene”;</strong>. Save the file and check that the <strong class="bold">Webpack output</strong> doesn’t contain any errors. When your browser refreshes, you should see a familiar scene being rendered. Go ahead and give yourself a pat on the back – you’ve completed pulling in our main application background scene! There’s something still missing, however, and that’s something for visitors to see when they first arrive at the web page but before they launch the game. It would be sort of rude to just <a id="_idIndexMarker147"/>take over a visitor’s <a id="_idIndexMarker148"/>browser and start downloading MBs of content without asking first, so we are going to put out a welcome mat in the form of the landing HTML page.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>Constructing the Landing Page</h1>
<p>Although it is web-based and hosted by a web server, there is a critical principle at play for Space-Truckers: the game that we haven’t done much but hint at previously. That principle is that we <a id="_idIndexMarker149"/>want to, by all means necessary, avoid using the HTML DOM in the game. Now, to be fair, it’s not a total blanket ban on using HTML or CSS anywhere, just anywhere important. The reason for this is we want to give our future selves a gift that makes it seamless to target Space-Truckers to Babylon Native; code that uses the HTML DOM isn’t compatible with BJS Native. That said, there is still the need to do a little bit of HTML and CSS work to make the landing page a little bit more hospitable to visitors.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>The Concept (Art)</h2>
<p>When Space-Truckers was just in the process of being conceived as an idea, early concept sketches were <a id="_idIndexMarker150"/>useful in helping to establish various different aspects of the look, feel, and setting of the game. The following figure depicts what we want our landing page to look like: </p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="Figure 3.3 – HTML landing page design&#13;&#10;" height="743" src="image/Figure_3.03_B17866.jpg" width="923"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – HTML landing page design</p>
<p>When a user navigates to the Space-Truckers website, they’ll be presented with a centered image that functions in the same way that a book cover attempts to convey some sense of the book’s <a id="_idIndexMarker151"/>content. A Call-to-Action button to Launch the game sits prominently and visibly in the center of the viewport, enticing the visitor to click the button and play the game. Lastly, we have a small site footer with the standard privacy, support, repository, license, copyright notices, and so on. </p>
<p class="callout-heading">Note</p>
<p class="callout">We will want to structure our markup such that it will display appropriately on-screen dimensions ranging from the high dpi (but small screen size) of a smartphone or tablet to the much larger but lower resolutions offered by large-screen TVs and display monitors. Aspect ratios are important too!</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>Sticking the Landing</h2>
<p>If all goes well, we’ll end up with something similar to this for our landing page. We’re not going to worry <a id="_idIndexMarker152"/>about fonts or background images right now as much as we want to get more of a sense of how we want to lay out and design various elements. </p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 3.4 – The Space-Truckers landing page. Behind the foreground content are the animated orbiting planets created in Chapter 2, Ramping up on Babylon.js&#13;&#10;" height="920" src="image/Figure_3.04_B17866.jpg" width="1200"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – The Space-Truckers landing page. Behind the foreground content are the animated orbiting planets created in Chapter 2, Ramping up on Babylon.js</p>
<p>To achieve this, there’s some HTML markup along with CSS styles that need to be added to the <strong class="source-inline">/public/index.xhtml</strong> page. There’s an additional small change we’ll need to make to the <strong class="source-inline">index.js</strong> file that will add a class of <strong class="source-inline">background-canvas</strong> to the newly created HTML Canvas that is appended to the document with <strong class="source-inline">canvas.classList.add(“background-canvas”);</strong>, so get that change out of the way and open up the <strong class="source-inline">public/index.xhtml</strong> file in VSCode. There’s enough that needs to be added that it would take up a prohibitive amount of page space, so at this point, you have a couple of options: </p>
<ul>
<li>Take the homework assignment and build out the HTML/CSS to get to the preceding screenshot </li>
<li>Grab the finished files (there will be two or so in total, in addition to the <strong class="source-inline">index.js</strong> change) from <a href="https://github.com/jelster/space-truckers/tree/ch3-final">https://github.com/jelster/space-truckers/tree/ch3-final</a><span class="hidden"> </span></li>
</ul>
<p>There isn’t any right or wrong answer; it’s whatever you will enjoy and learn from the most in the amount of time you have available that means the most and you’re the only one who can decide what <a id="_idIndexMarker153"/>that is! Each chapter in this book has an accompanying branch (and tag) in Git. The purpose of leaving the entire branch with its commit history in place is to give you the opportunity to see how the code evolves, commit by commit, while avoiding adding too much noise to the main branch’s commit history. </p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>Summary</h1>
<p>In a whirlwind of Webpack, ES6 Imports, and CSS shenanigans, we’ve completed a key process that started with a simple PG snippet and finished with an animated landing page. Along the way, we set up our local development scripts so we can take advantage of modern JavaScript features such as tree-shaking to optimize our package bundle sizes, while still being able to quickly integrate and view changes into the application.</p>
<p>What’s next from here should be fairly obvious to anyone who has ever stood in front of a Big Red Button labeled “Launch”. It’s time to Push the Button, and make it do interesting things! Yes, we will be implementing our application’s Launch-time experience, which involves establishing some mechanics of state in the application. Don’t worry if you’re not through with this section yet, there’s more to be done!</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/>Extended Topics</h1>
<p>For the person looking to make the launch page their own or who wants to dive deeper into the potential possibilities opened up by this chapter, here are some things you might consider doing:</p>
<ul>
<li>Add a cool hover-in/out effect to the launch button so that when the cursor hovers over it, a color and/or animated effect is applied. Do the same for clicking the button.</li>
<li>Improve the landing page’s navigational structure with links to the GitHub repos, and so on.</li>
<li>Make the central hero area into an image carousel that can be populated with additional concept art, screenshots, gameplay videos, and so on.</li>
<li>Use CSS to blend the canvas animation with the hero image in an interesting fashion. You can do different types of blending, such as difference, exclusion, screen, and so on, along with other cool transformations.</li>
</ul>
</div>
<div>
<div id="_idContainer031">
</div>
</div>
</div></body></html>