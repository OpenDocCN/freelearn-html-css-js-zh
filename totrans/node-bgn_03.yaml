- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will review all the aspects of JavaScript that are relevant
    to this book. While this topic could be a book in itself, this chapter synthesizes
    the most basic parts (arrays, objects, strings, and data types) in order to do
    a deeper analysis of the most complex parts, such as functions and closures.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you are already familiar with JavaScript, this chapter will help you
    to refresh your knowledge of certain areas. Also, you will learn about the latest
    changes in JavaScript introduced by the latest specification.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how JavaScript has become a standard on how decisions are
    made when a request change is made for the language.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will review some tools that will help us to write better JavaScript
    by using linters, debugging tools, and proper documentation for our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Refresh or acquire JavaScript knowledge, including about many of its features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand JavaScript versioning and the TC39 committee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get familiar with the JavaScript documentation and linting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the most commonly used parts of JavaScript (comments, data types,
    operators, conditionals, loops, functions, objects, arrays, classes, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand advanced JavaScript concepts such as closures and prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/BxM8XZzINmg](https://youtu.be/BxM8XZzINmg)
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a powerful language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a very powerful language. It is used in the frontend, backend,
    mobile, desktop, IoT, and so on. It is very flexible, and it is very easy to get
    started, but it is also very hard to master in depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a very famous quote ([https://www.crockford.com/javascript/javascript.html](https://www.crockford.com/javascript/javascript.html))
    by Douglas Crockford that says:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is the world’s most misunderstood programming language.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a multi-paradigm language, which means that you can use different
    programming styles, such as object-oriented programming, functional programming,
    or declarative programming. This is very useful because you can use the programming
    style that best fits your needs. But on the other hand, it can be very confusing
    for beginners, and not all the programming styles are equally supported by the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a very dynamic language, which means that you can change the behavior
    of the language at runtime. Thanks to JavaScript, you can learn complex concepts,
    such as closures and prototypes, and use them to create very powerful and complex
    applications. But you can also use them to create very confusing and hard-to-maintain
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will learn how to use JavaScript to create powerful
    applications, but we will also learn how to use it in a way that is easy to understand
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you’re not deeply familiar with any of the mentioned paradigms.
    Throughout this book, we’ll gradually incorporate elements from each paradigm,
    introducing them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the role of the TC39 in JavaScript and
    how the specification works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding versioning – TC39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is getting old; it was created in 1995 by Brendan Eich at Netscape
    Communications Corporation. It was originally called Mocha, but it was renamed
    LiveScript and finally JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The first version of JavaScript was released in 1996\. It was called **ECMAScript
    1** (**ES1**) and was standardized by the **European Computer Manufacturers Association**
    (**ECMA**) in 1997.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding versioning – ECMAScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the years, many new features were added to the language, such as classes,
    modules, and arrow functions. The new features were added to the language through
    a submission proposal process called ECMAScript proposals ([https://github.com/tc39/proposals](https://github.com/tc39/proposals))
    that are managed directly by the TC39 ([https://tc39.es/process-document/](https://tc39.es/process-document/)),
    which refers to a committee of ECMA that is responsible for the evolution of the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: From 1997 until 2015, new features were added to the language every few years,
    but in 2015, the TC39 decided to release a new version of the language every year,
    which means that the language is evolving faster than ever. This also helps us
    with the adoption of the new features because we don’t need to wait many years
    to use them in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the latest version of the language is ECMA-262 2023 ([https://tc39.es/ecma262/](https://tc39.es/ecma262/)),
    which was released in June 2023.
  prefs: []
  type: TYPE_NORMAL
- en: What is included in the next version of JavaScript?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to add new features to the language, the TC39 committee has a process
    that is divided into stages. Anybody can submit a proposal to the TC39 committee,
    but it is not an easy task, because the proposal needs to be approved by the committee
    before it is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the proposals in the TC39 GitHub repository ([https://github.com/tc39/proposals](https://github.com/tc39/proposals)).
    You can participate in the discussions and get involved in the community.
  prefs: []
  type: TYPE_NORMAL
- en: What is not included in the JavaScript specification?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript specification is very big, but it does not include many APIs
    that are commonly used in JavaScript applications, such as browser APIs and Node.js
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using JavaScript in the browser, you can use browser APIs, such as
    the **Document Object Model** (**DOM**). If you are using JavaScript in Node.js,
    you can use Node.js APIs, such as the filesystem or HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, JavaScript is just a programming language. If you are
    used to building JavaScript applications in the browser, you might be familiar
    with many APIs that are not included in the JavaScript specification and are not
    available in Node.js. For example, the window object ([https://developer.mozilla.org/en-US/docs/Web/API/Window](https://developer.mozilla.org/en-US/docs/Web/API/Window))
    is available in the browser, but it is not available in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how the specification works, it is time to explore the JavaScript
    documentation in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring JavaScript documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While ECMA-262 ([https://262.ecma-international.org/14.0/](https://262.ecma-international.org/14.0/))
    is a great source of information, it is not very beginner-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: The most complete source of information is the MDN Web Docs ([https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)),
    which is a community-driven documentation. It is very comprehensive, and it is
    updated regularly and even translated into other languages.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with frontend development, you might have used the MDN Web
    Docs before, because it is the main source of information for browser APIs, such
    as the DOM ([https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction))
    and the Fetch API ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)).
  prefs: []
  type: TYPE_NORMAL
- en: If are looking for more concise documentation, you can use W3Schools ([https://www.w3schools.com/js/default.asp](https://www.w3schools.com/js/default.asp)),
    which is a great source of information for beginners, with a lot of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you are looking for a specific answer to a question, you can use
    Stack Overflow ([https://stackoverflow.com/questions/tagged/javascript](https://stackoverflow.com/questions/tagged/javascript)),
    which is a community-driven Q&A website.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how we can use linting tools to improve our
    JavaScript code easily.
  prefs: []
  type: TYPE_NORMAL
- en: Linting JavaScript code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linting is the process of running a program that will analyze your code for
    potential errors. It is very useful in catching errors before running your code,
    so you can fix them before they cause any issues.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a very flexible language, which means that it is very easy to
    make mistakes. As you get more used to it, you will make fewer mistakes, but it
    is always good to have a linter to help you.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will use ESLint ([https://eslint.org/](https://eslint.org/))
    to lint our code, but there are other options available, such as JSLint ([https://www.jslint.com/](https://www.jslint.com/))
    and JSHint ([https://jshint.com/](https://jshint.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a linter is not a trivial task, but it is worth the effort. There
    are many rules available, and it is not easy to know which ones to use. I highly
    recommend that you use the standard rules ([https://standardjs.com/](https://standardjs.com/)),
    which are one of the most popular and used by many open source projects (including
    Node.js, Express, and MongoDB) and companies. You can find all the rules available
    on the JavaScript Standard Style page ([https://standardjs.com/rules.html](https://standardjs.com/rules.html)).
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.1*, you can see how the standard is used to review the source
    code of the project. It will recommend what to do in order to follow the configured
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Screenshot from GitHub Codespaces](img/B21678_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Screenshot from GitHub Codespaces
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to document our own code, so it becomes
    easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting JavaScript code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have multiple options to include comments in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you are new to JavaScript, I recommend you use a lot of comments to help
    you understand what is going on in your code. As you become more experienced,
    you will need fewer comments. Comments also help other developers to read and
    understand your code.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSDoc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need guidance on how to write good comments, you can use the JSDoc ([https://jsdoc.app/](https://jsdoc.app/))
    syntax. Another additional benefit of using JSDoc is that you can use it to autogenerate
    documentation for your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is quite a popular solution. For example, Lodash uses this approach. Use
    the following links to check out how the `_.chunk` method is documented:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSDoc in practice: [https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6818](https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L6818)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation automatically generated by JSDocs: [https://lodash.com/docs/4.17.15#chunk](https://lodash.com/docs/4.17.15#chunk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use `console` to speed up our debugging
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Printing values and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `console` object is non-standard; it is not part of the JavaScript language,
    but it is provided by the browser and Node.js. You can use it to print messages
    to the console, which is very useful for debugging purposes and for the purposes
    of this book, to follow along with the examples. It is quite common to use it
    to print the value of a variable. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Yes, you can use `console.log` to print multiple values at the same time, separated
    by commas, and even include additional information to explain what you are printing.
    You don’t have to worry about the type of the variable as in other languages;
    `console.log` will do it for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you will need to help `console.log` print the value of a variable;
    for example, if you want to print an object, sometimes you end up getting `[object,
    object]` or similar as the output message. In this case, you will need to use
    `console.log(JSON.stringify(object))` to print the object as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Over time, the JavaScript engines improve the `console` output, so this simple
    example might be printed as expected in your browser; but certain complex objects
    might still need to be stringified, for example, the response from a long HTTP
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `console` object offers many methods to print the information in different
    formats, which will improve your developer experience a lot. Documentation is
    available for web browsers ([https://developer.mozilla.org/en-US/docs/Web/API/console](https://developer.mozilla.org/en-US/docs/Web/API/console))
    and for Node.js ([https://nodejs.org/api/console.html](https://nodejs.org/api/console.html)).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how JavaScript uses constants and variables
    to store the information that we need when building applications.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use variables to store values, and we use constants to store values that
    will not change. In JavaScript, we can use the `let` keyword to declare a variable
    and the `const` keyword to declare a constant. Before ES6, we could only use the
    `var` keyword to declare variables, but it is not recommended to use it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, it is very common to use *camelCase* to name variables and constants,
    but other conventions are supported too, such as *snake_case* and *PascalCase*.
    It is also possible to start variables with symbols, but it is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few limitations that we need to consider when naming variables
    and constants:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid starting with a symbol, such as `$resource`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t start with a number, such as `1variable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t use spaces, such as `const my variable = 1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t use reserved words, such as `const const = "``constant"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: let versus const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use `let` to declare variables and `const` to declare constants. The main
    difference is that we can reassign a value to a variable, but we cannot reassign
    a value to a constant. Here is an example of reassigning a value to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see here, we cannot reassign a value to a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to notice that we can change the value of a constant if the
    value is an object, but we cannot reassign a new value to the constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Later in this chapter, we will explore objects in more detail, and we will understand
    these mutations deeper.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, there is another mechanism that you need to understand. Hoisting
    is a behavior in JavaScript where variable and function declarations are moved
    to the top of their containing scope during the compilation phase. This is done
    to optimize the code, but it can have some side effects. You can find a great
    guide at [https://www.freecodecamp.org/news/what-is-hoisting-in-javascript-3](https://www.freecodecamp.org/news/what-is-hoisting-in-javascript-3).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are clear on how variables and constants work, it is time to explore
    the different data types available in JavaScript in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, there are several primitive types. We can group them into two
    groups: before ES6 (`undefined`, `object`, `boolean`, `number`, `string`, and
    `function`) and after ES6 (`bigint` and `symbol`). In order to check the type
    of a variable, we can use the `typeof` operator.'
  prefs: []
  type: TYPE_NORMAL
- en: undefined
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all languages have an `undefined` type, but JavaScript does. It is used
    to represent the absence of a value. It is also used as the default value for
    uninitialized variables.
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `object` type is used to represent a collection of data. It is a very generic
    type, and it is used to represent many different things, such as arrays (lists),
    objects (dictionaries), class instances, and `null`.
  prefs: []
  type: TYPE_NORMAL
- en: boolean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boolean` type is used to represent a logical value. It can be either `true`
    or `false`. This type can be generated by using the `Boolean` function too, as
    everything in JavaScript can be converted to a `boolean` value.
  prefs: []
  type: TYPE_NORMAL
- en: number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `number` type is used to represent a numeric value. It can be either an
    integer or a floating-point number. It is also used to represent special numeric
    values such as `Infinity`, `-Infinity`, and `NaN` (which stands for Not a Number).
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `string` type is used to represent a sequence of characters. It can be created
    explicitly by using single quotes (`'`), double quotes (`"`), or backticks (``
    ` ``) or implicitly by using the `String` function or expressions.
  prefs: []
  type: TYPE_NORMAL
- en: function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `function` type is used to represent a function. Functions in JavaScript
    are very powerful. We will explore them in detail in this chapter. There are two
    ways to create a function, by using the `function` keyword or by using the arrow
    function syntax.
  prefs: []
  type: TYPE_NORMAL
- en: bigint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`bigint` was introduced in ES6 in order to work with large numbers. `number`
    is limited to values between -(253 – 1) and 253 – 1'
  prefs: []
  type: TYPE_NORMAL
- en: symbol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `symbol` type is used to represent a unique identifier. It is a new type
    that was introduced in ES6; you won’t really need to be familiar with it to follow
    along with this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore numbers in depth, including the Math built-in
    library, common operators used for comparison, and useful methods for converting
    numbers and strings.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has good support for mathematical operations and dates, but sometimes
    it can be tricker and more limited than other programming languages, so many developers
    use specialized libraries when the application requires advanced math. For example,
    if you need to work with vectors, matrices, or complex numbers, you should use
    a library such as Math.js ([https://mathjs.org/](https://mathjs.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical example of the floating-point precision problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the result of `0.1 + 0.2` is not `0.3`, but `0.30000000000000004`.
    This is because JavaScript uses the IEEE 754 standard ([https://en.wikipedia.org/wiki/IEEE_754](https://en.wikipedia.org/wiki/IEEE_754))
    to represent numbers, and it is not possible to represent all decimal numbers
    in binary. This is a common problem in many programming languages; it is not an
    exclusively JavaScript problem. But you can solve it by using the `Number` and
    `toPrecision` functions as you will implicitly convert from number to string and
    then back to number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are some edge cases that are not easy to understand or
    solve intuitively. Most of the time, you will not need to worry about this, but
    it is important to know that this problem exists and you can use libraries if
    you are not experienced enough with numbers in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has the expected arithmetic operators, `+`, `-`, `*`, `/`, `%`, and
    `**`, and indicates priority with brackets as in any modern language.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has the expected assignment operators, `=`, `+=`, `-=`, `*=`, `/=`,
    `%=`, and `**=`, as in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can use `++` and `--` to increment and decrement a variable. This
    operator can be added before or after the variable, and it will change the value
    of the variable before or after the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Additional info
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript also supports bitwise operations, so you can work with a set of
    32 bits (zeros and ones), rather than decimal, hexadecimal, or octal numbers.
    You can check out the full documentation here: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#bitwise_operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#bitwise_operators).'
  prefs: []
  type: TYPE_NORMAL
- en: Useful methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are methods that are key to performing mathematical operations or transformations
    in daily work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.prototype.toFixed()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.prototype.toPrecision()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.parseInt()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.parseFloat()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Math object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has a built-in `Math` object that provides a lot of useful methods
    to perform mathematical operations. I will list some of them here, but you can
    find the full list in the MDN documentation ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math)).
  prefs: []
  type: TYPE_NORMAL
- en: Useful methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are methods that are key to performing mathematical operations or transformations
    in daily work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.random()`: Returns a pseudo-random floating-point number between 0 (inclusive)
    and 1 (exclusive) [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/random](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/random)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.max()`: Returns the maximum numeric value among the arguments passed
    to it [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/max](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/max)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.min()`: Returns the minimum numeric value among the arguments passed
    to it [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/min](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/min)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.floor()`: Returns the resulting number from rounding a number down to
    the nearest integer that is less than or equal to the given number [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/floor](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, there are some special values that are numbers, but they are
    not real numbers. These values are `NaN` and `Infinity`.
  prefs: []
  type: TYPE_NORMAL
- en: Not a Number (NaN)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`NaN` is a special value that represents Not a Number. It is the result of
    an invalid or undefined mathematical operation, for example, dividing 0 by 0,
    or multiplying Infinity by 0\. You can use `isNaN()` to check whether a value
    is `NaN` ([https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isNaN](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isNaN)).'
  prefs: []
  type: TYPE_NORMAL
- en: Infinity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Infinity` is a special value that represents infinity. It is the result of
    a mathematical operation that exceeds the largest possible number. You can use
    `isFinite()` to check whether a value is finite ([https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isFinite](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/isFinite)).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore dates in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Dates object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dates are a complex topic for any programming language or system as you need
    to take into account many things, such as time zones. If you need to work with
    dates intensively, consider using a library such as Lunox ([https://github.com/moment/luxon/](https://github.com/moment/luxon/))
    or date-fns ([https://date-fns.org/](https://date-fns.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: For more simple scenarios, you can use the built-in `Date` object and the Intl
    API ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl))
    to format dates.
  prefs: []
  type: TYPE_NORMAL
- en: The API offers several ways to generate the Date object by using numbers, strings,
    or several arguments. Also, you have getters and setters to read and modify specific
    parts, such as the year or milliseconds. It is also possible to perform operations
    such as comparing or adding time.
  prefs: []
  type: TYPE_NORMAL
- en: For many years, the only way to format dates in JavaScript was using the `toLocaleString()`
    method. This method is still valid, but it has a lot of limitations, specifically,
    when you want to compare dates in a human-readable way (e.g., *3 days ago* or
    *2* *weeks ago*).
  prefs: []
  type: TYPE_NORMAL
- en: In the past, we needed to use external libraries to achieve this, but now we
    can use the Intl API ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl))
    to format dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, you can see how to generate, manipulate, and format
    dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The result may vary on your machine as it will have been some time since I wrote
    this code. Therefore, keep in mind that the output you observe may differ from
    mine.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The TC39 is doing a great job at consolidating this API, which includes a lot
    of features to format dates, numbers, currencies, and more. I recommend you follow
    the proposal’s progress and implementation in the JavaScript engines.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use conditionals in JavaScript by
    using several tools that JavaScript provides.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to write conditional statements in JavaScript, but the most
    common are `if`, `switch`, and the ternary operator (`?:`).
  prefs: []
  type: TYPE_NORMAL
- en: Math comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For mathematical operations, we have the following operators: `>`, `<`, `>=`,
    and `<=`. They are used to compare two values and return a Boolean value. Their
    use is the same as in most modern programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Equality operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Equality operators are used to compare two values and return a Boolean value.
    There are two types of equality operators: strict (`===` and `!==`) and non-strict
    (`==` and `!=`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The strict equality operator cannot be used to compare non-primitive types
    (such as `object`, `array`, and `function`) and certain values such as `NaN`,
    as it will always return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not recommended to use non-strict equality operators, as they can lead
    to unexpected results, because this operator does not check the type of the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to combine multiple conditions using logical operators. There
    are three logical operators, `&&`, `||`, and `!`, and some variations of them,
    `&&=` and `||=`, that are used to reduce the amount of code for certain operations.
    We won’t cover them all in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine operators to build more complex validations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The NOT operator (!)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The NOT operator is used to invert the value of a Boolean. It will return `true`
    if the value is false, and `false` if the value is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This example is not clear about all the possibilities that are offered, so let’s
    try to build an analogy with a more verbose structure, `Boolean(value) === false`.
    Basically, the `!` operator converts the value to a Boolean and then compares
    it with a `false` value.
  prefs: []
  type: TYPE_NORMAL
- en: Equality in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Due to the nature of JavaScript, it is possible to use any value as a condition.
    The condition will be evaluated as a Boolean, and if the value is truthy, the
    condition will be `true`. If the value is falsy, the condition will be `false`.
    This can be a bit confusing, so let’s explore the `Boolean` method to understand
    how different data values are transformed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can conclude easily that empty values (such as `null`, `undefined`, an empty
    string, or `NaN`) and `0` are falsy, and values with complex data types (such
    as objects and functions) or non empty strings and non-zero numbers are truthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is quite convenient when we want to check whether a value is empty or
    not, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This Boolean transformation and comparison can turn into a very complex situation
    if you want to compare different data types and values, for example, `Boolean([])
    === Boolean({})`. You can explore this topic in detail in the MDN documentation
    ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)).
    But in general, you don’t need to be an expert in this area to follow along with
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can get a better understanding of this topic by exploring JavaScript Equality
    Table by Dorey at [https://github.com/dorey/Javascript-Equality-Table/](https://github.com/dorey/Javascript-Equality-Table/).
  prefs: []
  type: TYPE_NORMAL
- en: The nullish coalescing operator (??)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The nullish coalescing operator is a new operator that was introduced in ES2020\.
    It is used to check whether a value is `null` or `undefined`; if it is, it will
    return a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `if` statement is the most common way to write a conditional statement.
    It will execute the code inside the block if the condition is true. The `else`
    statement allows us to follow up when the condition is not met by executing the
    code that is in the `else` statement. The `else if` statement is a variation of
    the `if` statement. It will execute the code inside the block if the condition
    is true. If the condition is false, it will execute the code inside the `else`
    block. You can add as many `else if` statements as you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can change the values in `condition` and `condition2` in order to get more
    familiar with the behavior of the conditional structures.
  prefs: []
  type: TYPE_NORMAL
- en: return usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `return` statement is widely used to avoid using `else` statements and
    allows for cleaner code. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `switch` statement is a good option when you want to compare a variable
    against multiple values. It is good when you want to assign a value to a variable
    depending on a condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` structure is composed of the `switch` keyword, followed by the
    variable that you want to compare, and then a block of `case` statements. Each
    `case` statement is composed of the `case` keyword, followed by the value that
    you want to compare, "and then a double colon (:). After the double colon," you
    can write the code that you want to execute if the condition is true. The `default`
    statement is optional, and it will be executed if none of the `case` statements
    are true, like `else` when using `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `break` statement is used to stop the execution of the `switch` statement.
    If you don’t add the `break` statement, the code will continue executing the next
    `case` statement. Here we have a combined example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Ternary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ternary operator is shorthand for the `if` and `else` statements. It is
    a good option when you want to assign a value to a variable depending on a condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure is composed of the condition, followed by a question mark, `?`,
    then the value that you want to assign if the condition is true, followed by a
    double colon (:), and then the value that you want to assign if the condition
    is false: `condition ? valueIfTrue :` `valueIfFalse`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example with the `if` and `else` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The ternary operator can nest multiple ternary operators, but it is not recommended
    because it can be extremely difficult to read. Also, it is possible to use the
    ternary operator to do multiple operations, but it is not recommended because
    it can be extremely difficult to read even if you use parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are clear on how conditional structures work in JavaScript, it is
    time to explore loops in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to create loops in JavaScript, but the most common are the
    `for` and `while` statements and variations of them that are specific to arrays
    and objects. Also, functions in JavaScript can be used to create loops when using
    recursion. In this section, we will look at only the `for`, `while`, and `do...while`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` statement creates a loop that executes a block of code as long
    as the condition is true. The condition is evaluated before executing the block
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: do...while
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `do...while` statement creates a loop that executes a block of code at
    least once even if the condition is not met, and then repeats the loop as long
    as the condition is true. The condition is evaluated after executing the block
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: for
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` statement creates a loop that consists of three optional expressions,
    enclosed in parentheses and separated by semicolons, followed by a statement executed
    in the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first expression is executed before the loop starts. Usually, it is used
    to initialize the variable that will act as counter.
  prefs: []
  type: TYPE_NORMAL
- en: The second expression is the condition that is evaluated before executing the
    block of code. If the condition is true, the block of code is executed. If the
    condition is false, the loop stops.
  prefs: []
  type: TYPE_NORMAL
- en: The third expression is executed after the block of code is executed. Usually,
    it is used to increment or decrement the counter variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure is quite flexible, and some developers tend to abuse it. Let’s
    see an example with bad readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The readability issues are due to the large number of variables defined and
    updated in the `for` loop. It is important to remember that we write code that
    other programmers can understand in the future. Let’s see the same code with a
    more readable approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can already notice the difference; it takes less time and effort to understand
    it. In the next section, we will learn how to use strings.
  prefs: []
  type: TYPE_NORMAL
- en: Using strings in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings are primitive values. They are a sequence of characters. There are
    three ways to create strings in JavaScript: using single quotes, `''`, double
    quotes, `"`, or backticks, `` ` ``.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are immutable, which means that once they are created, they cannot
    be modified, but you can overwrite the variables or references depending on the
    data structure. So, all the methods that you use to modify a string will return
    a new string (or array):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Template strings allow you to use placeholders, `${}`, to insert variables
    or expressions inside a string. There is also added support for multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Important methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to perform operations with strings, but in this section,
    we will see only the most important methods that you will use in your day-to-day
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String.prototype.indexOf()`: Finds the index of the first occurrence of a
    specified substring within a string [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.lastIndexOf()`: Finds the index of the last occurrence of
    a specified substring within a string [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.search()`: Searches for a specified substring within a string
    [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/search](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/search)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.includes()`: Determines whether one string contains another
    string [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/includes](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/includes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.match()`: Extracts matches of a regular expression pattern
    from a string [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/match](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/match)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.matchAll()`: Returns an iterator that yields all matches
    of a regular expression against a string [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.split()`: Splits a string into an array of substrings based
    on a specified separator [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/split](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/split)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.slice()`: Extracts a section of a string and returns it as
    a new string [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/slice](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/slice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.trim()`: Removes whitespace characters from both ends of
    a string [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/trim](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/trim)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.replace()`: Finds and replaces substrings within a string
    [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/replace](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/replace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use arrays, one of the most versatile
    data structures in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are non-primitive values; they are a collection of values. The values
    can be any type of value, including other arrays. Arrays are mutable, which means
    that you can modify them and the changes will be reflected in the original array.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are zero-indexed, which means that the first element is at index 0, the
    second element is at index 1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Array.isArray()` method determines whether the passed value is an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As arrays are objects, you need to be careful because they can’t be compared
    with the `===` or `==` operator, because it will compare the references, not the
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Arrays have a `length` property that returns the number of elements in the array
    and provides an easy way to iterate over the array.
  prefs: []
  type: TYPE_NORMAL
- en: Basic operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at the most common operations that you will perform
    with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many ways to create an array in JavaScript. The most common is using
    the array literal notation, `[]`, but you can also create an array from other
    data types, such as when you split a string, or using the `string.prototype.split()`
    method. The following is an example of creating an array using the array literal
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Array.of()` method creates a new array instance from a variable number
    of arguments, regardless of the number or type of the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Array.from()` method creates a new array instance from an array-like or
    iterable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The spread operator, `...`, can be used to create a new array from an existing
    array or from a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can pass a map function as a second parameter so you can perform
    transformations when the array is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Accessing items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can access an item in an array using the index of the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Replacing items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can replace an item in an array using the index of the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Adding items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can add items to an array using two main methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.push()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/push](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/push)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.unshift()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is always preferable to add new items to the end of the array, because adding
    items to the beginning of the array is an expensive operation. This is because
    it requires re-indexing all the items in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Removing items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several methods that allow you to remove items from the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.pop()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/pop](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.shift()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/shift](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.splice()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/splice](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw at the beginning of this chapter, it is possible to iterate over an
    array using a `for` loop, but there are also other ways to iterate over an array.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript provides great support for declarative programming, which is especially
    useful when you need to iterate over arrays. So, let’s summarize the most common
    ways to iterate over an array.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these methods receive a function as a parameter, and it is executed
    for each item in the array. Depending on the method used and the data returned
    from the function will get one result or another.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to remember is that these methods can be chained together,
    so you can use one method after another and compose more complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As arrays can store a lot of elements, it is important to get familiar with
    the methods that are provided by the array in order to properly iterate over them.
    The most common are `Array.prototype.map()` and `Array.prototype.forEach()`. In
    both cases, we will iterate over the array, but `Array.prototype.map()` will directly
    return a new array with the applied transformation. Let’s see an example comparing
    both methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As arrays can contain any type of data, it is common to need to validate whether
    an array contains a specific item or whether all the items in the array match
    a condition. There are several methods, but the most common are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.every()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/every](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/every)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.some()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/some](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/some)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.includes()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/includes](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays can store a lot of information, and it is quite common to store nested
    structures such as big objects. There are many ways to do filtering in JavaScript.
    The most important difference between them is what your expected output is as
    sometimes we will be interested in a new array with the filtered values, but other
    times we might want the position (index) of certain elements in the array. The
    most used method is `Array.prototype.filter()`, which is used to generate a new
    array with the elements that pass certain criteria. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several methods that you will find relevant in this category:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.slice()`: Returns the copy of a portion of the array [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/slice](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.find()`: Returns the value of the first item in the array
    that satisfies the provided criteria [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.findIndex()`: Returns the index of the first item in the array
    that satisfies the criteria [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you need to flatten an array of arrays. You can use the `array.flat()`
    method to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common method is the `array.join()` method, which is used to join all
    the items in an array into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very useful when you need to create a string with a list of items,
    for example, when you need to create a list of items in HTML, XML, Markdown, and
    so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'While working with data, it is very common that we need to sort the items in
    the array. This can be done with `array.sort()`. In general, it is better if we
    provide a function that specifies how to properly sort the items just to avoid
    unexpected results. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several methods that are quite useful and you will find yourself
    using very frequently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.reverse()`: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.concat()`: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.fill()`: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.reduce()`: [https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES6 introduced a new syntax for destructuring arrays and objects. The left-hand
    side of an assignment is now a pattern for extracting values from arrays and objects.
    This pattern can be used in variable declarations, assignments, function parameters,
    and function return values. Also, you can use default values (fail-soft) in case
    the value is not present in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code sample, we can see the classic way to do a fail-soft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet contains the same code but using ECMAScript 6 destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this version is more compact. Currently, this is the more popular
    way to assign default values when it is possible to combine it with destructuring.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 introduces a new data structure called `Set`. A Set is a collection of
    values, where each value may occur only once. It can be used to store a collection
    of values, but it is not an array as it doesn’t have indexes. It is quite a common
    solution to remove duplicate values from an array, as we can see in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information about set-specific methods at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use objects, one of the most powerful
    data structures in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Using objects in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects are non-primitive values; they are a collection of properties. A property
    is a key-value pair. The key is always a string, and the value can be any type
    of value, including other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Basic operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects are the most versatile structure in JavaScript. In this section, we
    will learn how to create objects, how to access and modify their properties, and
    how to iterate over the properties of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create an object using the object literal syntax, that is, using curly
    braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create an object and directly add properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can store any type of value in an object, including other objects or functions
    (methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Creating and accessing properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create a new property or overwrite existing ones in an object by assigning
    a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also access the properties of an object using the bracket notation,
    which is useful when using programmatic access or when using keys with special
    characters or whitespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Deleting properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can delete a property from an object using the `delete` operator or overwrite
    it to `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see how to iterate over the properties of an object, and how to get an
    array with the keys and values of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our base object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can iterate over the properties of an object using the `for...in` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `Object.keys()` method to get an array with the keys of
    an object, so you can use array-specific methods to manage the iteration, such
    as `array.prototype.forEach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use additional methods introduced recently in the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.values()`: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.entries()`: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shallow copy versus deep copy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way JavaScript works means that sometimes we don’t get the expected copy
    of a variable. Let’s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is quite a specific behavior of JavaScript that frustrates many developers.
    How is it possible that the original variable is modified when we modify the copy?
    The answer is that we are not copying the variable (*deep copy*) in all the scenarios;
    we are copying the reference to the variable (*shallow copy*).
  prefs: []
  type: TYPE_NORMAL
- en: Only the primitive types (*string, number, Boolean, null, undefined,* and *symbol*)
    are copied by value; the rest are copied by reference, so you actually get a reference
    to the original variable, like a shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows you to do some interesting things, such as create shortcut references
    for very nested objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: But, as you can see, this can lead to changes in the original object. This can
    be an unexpected behavior if we are not clear how the original structure was copied.
    It can be trickier to detect if you are using nested structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get a deep copy of a simple object, you can use `Object.assign()`
    or the spread operator, `...`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'But the nested objects will be copied by reference, so you will get the same
    behavior as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: An alternative is to use a specialized library such as Lodash ([https://lodash.com/docs/4.17.15#cloneDeep](https://lodash.com/docs/4.17.15#cloneDeep))
    or transform it into JSON and digest the structure, but this has some limitations,
    such as not being able to copy functions or items that are not defined in the
    JSON specs ([https://datatracker.ietf.org/doc/html/rfc7159](https://datatracker.ietf.org/doc/html/rfc7159)).
  prefs: []
  type: TYPE_NORMAL
- en: Merging objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Merging two objects can be done with `Object.assign`, but you need to understand
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The order is important, so the first item will be overwritten by the next item
    when they share common properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the objects are complex data structures such as nested objects or arrays,
    then the final object will copy the references (shallow copy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since ES6, JavaScript has provided destructuring assignment for objects, which
    is very handy for extracting and including values in objects. Let’s see an example
    with a simple object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If we didn’t use destructuring, we would have to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'But with destructuring, we can do it in a more concise way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Optional chaining (?.)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The optional chaining operator is a new operator introduced in ES2020\. It
    allows you to access deeply nested properties of an object without worrying about
    whether the property exists or not. Before the optional chaining operator, you
    had to check whether the property exists before accessing it. This was quite tedious
    for very nested structures. Let’s see a practical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are familiar with most of the data structures, it is time to explore
    functions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are one of the more meaningful structures in JavaScript. There are
    certain characteristics that make them different from other programming languages;
    for example, they are first-class citizens, which means that they can be assigned
    to a variable, passed as an argument to another function, or returned from another
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many advanced concepts related to functions, but in this section,
    we will just look at the basics of functions in JavaScript. We will start with
    the declaration, execution, and arguments using the `function` keyword. Then,
    we will focus on arrow functions and closures.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In essence, a function is a block of code that can be executed when it is called.
    In JavaScript, we can declare a function using the `function` keyword. The syntax
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function is not executed when it is declared; it is executed when it is
    called. To call a function, we just need to write the name of the function followed
    by parentheses. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions can also be declared as a function expression. This is known as anonymous
    functions. A simple example is when we pass the function as an argument to another
    function, like when we use timers – `setTimeout`, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function can return a value using the `return` keyword. This value can be
    assigned to a variable or used in another function. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions can receive arguments; these arguments are passed to the function
    when it is called. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t need to specify the arguments; you can use the rest operator (`...`)
    to access the arguments. In this example, we will sum all the numbers passed to
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Arrow functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most important features introduced in ES6 is arrow functions. They
    are a new syntax for writing JavaScript functions, but they also introduce certain
    changes that are important to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions introduce a new syntax for writing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions are always anonymous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the beginning of JavaScript, we declared functions using the `function`
    keyword, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The new syntax for writing arrow functions uses `=>` and does not use the `function`
    keyword. The following example is the same as the previous one but with the new
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The new syntax has an implicit return, so if you want to return a value, you
    can do it without using the `return` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example can be translated to the previous syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrow functions can receive arguments, but if you want to receive more than
    one argument, you need to use parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Behavior changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the fact that JavaScript has retro compatibility with older versions,
    arrow functions introduce certain changes in the behavior of the functions. The
    most important one is related to the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Also, arrow functions do not have a `prototype` property, which means that they
    cannot be used as constructors or method handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The management of `this` in JavaScript can be a bit confusing and is quite
    advanced for the objectives of this book. If you want to learn more about it,
    you can read the MDN documentation: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this).'
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is one of the most popular and important concepts in JavaScript, but it
    is a bit advanced, and it is not easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a closure?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Basically, a closure is a function returned by another function. Here, we have
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `outerFunction` returns `innerFunction`, so we can call `innerFunction`
    after calling `outerFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s achieve the same result using less code by doing both executions
    in the same statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: But how is this useful?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most important thing about closures is that they can access and even modify
    the scope of the parent function (code block and arguments), even after the parent
    function has returned. Let’s see a practical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we added the `initialValue` and `incrementalValue` arguments
    to the functions, and also, we defined the `counter` variable to store the counter’s
    current value. In practice, we can use this function to create a counter that
    starts from a specific value, and then we can increment it by a specific value.
    We can’t access the `counter` variable directly because it lives only in the scope
    within the function and not outside, but we can use the closure to access it and
    even manipulate the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we saw the basic usage of closures, but they can be used for
    many other things. One of the most common usages is to create abstractions to
    manage third-party services such as databases and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this structure in the following chapters when using MongoDB and
    Express.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to create and manage classes, as well
    as how prototypical inherence works in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes were introduced in ES6\. They are syntactic sugar over the prototype-based
    inheritance. Historically, JavaScript did not have formal classes as we can expect
    from the typical Object Oriented Programing (OOP) languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to create classes and how to use them with
    ES6\. Also, we will explore how the prototypical inheritance is a key feature
    in maintaining retro compatibility and extends JavaScript’s core features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a class, we need to use the `class` keyword, and then we can define
    the default properties of the class using the `constructor` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created a class called `Human` and then we created an instance
    of the class called `jane`. We can access the properties of the class using dot
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: Class methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define a method in a class, we need to use a similar syntax as we use for
    defining methods in objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we defined a method called `sayHello` in the `Human` class,
    then we created an instance of the class, and we called the method.
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can extend classes using the `extends` keyword. This will allow us to inherit
    the properties and methods of the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created a class called `Colleague` that extends the `Human`
    class, then we created an instance of the class, and we called the methods and
    properties inherited from both classes.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static methods are methods that can be called without instantiating the class.
    They are defined using the `static` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call the `speedLimits` method without instantiating the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Getters and setters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in other languages that support object-oriented programming, you can define
    getters and setters using the `get` and `set` keywords, respectively. This will
    allow you to access and modify the properties of the instance in a more classic
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored JavaScript’s history and current state. We learned
    about the different versions of the language and how the language has evolved
    over time. We also learned about how the new features are added to the language.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we learned how to find the best documentation about the language and how
    to use it to learn about the language in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we explored how to use numbers, dates, conditional statements,
    loops, strings, arrays, objects, and functions, among others, in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we learned about classes and prototype-based inheritance and how
    it is a key feature to maintain retro compatibility and extends JavaScript’s core
    features.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about asynchronous programming with JavaScript.
    You will apply all the knowledge learned in this chapter to manage asynchronous
    code using different approaches, such as callbacks, promises, and async/await.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Weird History of JavaScript: [https://www.youtube.com/watch?v=Sh6lK57Cuk4](https://www.youtube.com/watch?v=Sh6lK57Cuk4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Brief History of JavaScript, talk by Brendan Eich (creator of JavaScript):
    [https://www.youtube.com/watch?v=qKJP93dWn40](https://www.youtube.com/watch?v=qKJP93dWn40)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TC39 Demystified, by Ujjwal Sharma: [https://www.youtube.com/watch?v=YLHhRpaPly8](https://www.youtube.com/watch?v=YLHhRpaPly8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documenting the Web Platform, by Florian Scholz: [https://www.youtube.com/watch?v=f_M0vQcKiW4](https://www.youtube.com/watch?v=f_M0vQcKiW4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TC39: From the Proposal to ECMAScript, Step by Step, by Romulo Cintra: [https://www.youtube.com/watch?v=h5pUuz2qqVQ](https://www.youtube.com/watch?v=h5pUuz2qqVQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
