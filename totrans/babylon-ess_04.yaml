- en: Chapter 4. Using Materials to Customize 3D Objects Appearance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objects that we call *materials* are essential in 3D rendering. They are
    used to render objects on the screen and how they are rendered. This means that
    the materials are used to apply textures and transformations such as waves, for
    example, manage transparency and more. In other words, materials are interfaces
    that are used to easily customize the 3D object's appearance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example with Babylon.js:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Discussing the awesome theory behind the materials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Babylon.js standard material
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using textures with materials
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the awesome theory behind the materials
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The materials are used to customize 3D objects appearance; however, behind them
    lie two programs called **shaders**. The goal of materials is to hide this notion
    of shaders and simply work with the values in the material object. In other words,
    the values in the material can be the emissive color of the object, the diffuse
    color, the transparency level and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, to go further with the theory, there are several types of shader,
    as shown in the following list:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex Shader**: This works directly on the 3D object geometry.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pixel Shader**: This works directly on the pixels on the screen.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geometry Shader** (not available on WebGL): This works on the 3D object geometry;
    however, here it is able to directly add polygons to the geometry of the 3D object
    according to the output of the vertex shader.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compute Shader** (not available on WebGL): This doesn''t work directly on
    the 3D objects and pixels. It is just used to compute some user-defined data using
    the GPU instead of the CPU. For example, a compute shader will take a texture
    as the input (you can see that as a big matrix) and output the results of the
    program in another texture. The compute shader is highly used, for example, to
    compute realistic ocean waves or neural networks.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tesselation Shader** (not available on WebGL): This allows us to compute **Level
    of Detail** (**LOD**) directly on the GPU instead of the CPU (fairly new in the
    modern rendering pipelines, such as Direct3D 11 and OpenGL 4.0).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case and with WebGL, only the vertex and pixel shaders are used to render
    3D scenes on the screen; however, it would not be surprising to see the other
    types of shaders being implemented in WebGL in the future.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The theory
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The meshes that we created in the previous chapters contain vertex buffers and
    index buffers. The vertex buffers describe the 3D positions of the vertices. The
    main problem is how to project the vertices in a 3D space into a 2D space, which
    is the screen space. Indeed, to draw elements on the screen, GPUs are used through
    programs to transform the vertices positions into 2D positions on the screen.
    These programs are the vertex shader and the pixel shader. They are written with
    a language named GLSL, which is the OpenGL shading language used with WebGL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vertex shader is used to transform the vertices positions. It is executed
    by the GPU for each vertex and can be used for an infinite number of functions.
    For example, to create waves on a large ocean plane, we will use the vertex shader
    to compute the wave function for each vertex instead of using the TS code that
    is executed on the CPU side–leave the job to the real worker.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Once the vertex shader computes a triangle (a face) on the screen, thanks to
    the index buffer, the pixel shader is called to illuminate the pixels used by
    the current triangle (current face) of the current mesh that is rendered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The pixel shader
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pixel shader has the same structure as the vertex shader; it is written
    with the same language (GLSL) and is called for each pixel used by the current
    triangle on the screen. The main function of the pixel shader is to return a color
    computed in the RGBA format, which can be determined from a user-defined value
    or directly from a texture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Using the Babylon.js standard material
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Babylon.js allows you to create materials, which means that it can create the
    custom materials with custom shaders; however, it provides a standard material
    with already-developed shaders that are designed to be adapted by many customizations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when you add a light to a Babylon.js scene, the light properties such
    as diffuse color, are sent to the materials of the scene to compute the light
    contributions on the meshes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The standard material and its common properties
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Babylon.js, each mesh has a material and the meshes can share the same material.
    Creating a standard material and assigning it to a mesh with Babylon.js is as
    easy as writing the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Simply create a new `StandardMaterial` object by giving a name to the material
    and the scene where you want to add the material and assign it `the.material`
    property of a mesh. Once the material is created, you can start modifying the
    values and then customize the mesh appearance. The default material by default
    looks similar to the following image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![The standard material and its common properties](img/image_04_001.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'The diffuse color: The diffuse color represents the color of the object, as
    follows:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![The standard material and its common properties](img/image_04_002.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'The specular color: The specular color represents the light color reflected
    by the object (this is mixed with the diffuse color), as shown in the following:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![The standard material and its common properties](img/image_04_003.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'The emissive color: The emissive color represents the color emitted by the
    object (this is mixed with the specular color and the diffuse color), as follows:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![The standard material and its common properties](img/image_04_004.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'Manage transparency: To manage transparency, the standard material provides
    a .alpha property in the [0, 1] interval, as follows:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![The standard material and its common properties](img/image_04_005.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Using the fog
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard material allows you to apply the fog effect that is related to
    the current scene that is rendered. To enable the fog on an object, simply set
    `the.fogEnabled` property to true on the materials and the scene, as shown in
    the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标准材质允许你应用与当前渲染场景相关的雾效。要在一个对象上启用雾，只需在材质和场景上设置 `the.fogEnabled` 属性为 true，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s start with the following scene:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下场景开始：
- en: '![Using the fog](img/image_04_006.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![使用雾效](img/image_04_006.png)'
- en: 'The fog in a scene can be customized. There are several types of fog, as shown
    in the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的雾可以自定义。以下列出了几种雾的类型：
- en: Linear fog (`BABYLON.Scene.FOGMODE_LINEAR`)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性雾 (`BABYLON.Scene.FOGMODE_LINEAR`)
- en: Exponential (`BABYLON.Scene.FOGMODE_EXP`)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数 (`BABYLON.Scene.FOGMODE_EXP`)
- en: Exponential 2 (faster than the previous) (`BABYLON.Scene.FOGMODE_EXP2`)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数 2（比之前更快）(`BABYLON.Scene.FOGMODE_EXP2`)
- en: 'With the linear mode, the two properties—`scene.fogStart` and `scene.fogEnd`—can
    be set. Consider the following, as an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性模式下，可以设置两个属性——`scene.fogStart` 和 `scene.fogEnd`。以下是一个示例：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Using the fog](img/image_04_007.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![使用雾效](img/image_04_007.png)'
- en: 'Change the fog color using the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法更改雾的颜色：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Using the fog](img/image_04_008.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用雾效](img/image_04_008.png)'
- en: With the exponential mode, the `scene.fogDensity` property can be set.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在指数模式下，可以设置 `scene.fogDensity` 属性。
- en: 'Consider the following as an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Using the fog](img/image_04_009.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用雾效](img/image_04_009.png)'
- en: Using textures with materials
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用材质使用纹理
- en: This chapter is the right place to introduce the usage of textures. Textures
    are images (`.png`,`.jpeg`, and so on) that graphics libraries are able to apply
    to meshes. There are several types of texturing methods handled by Babylon.js,
    such as video textures, cube textures, and so on. Now, let's explain how to use
    textures with materials.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是介绍纹理使用的合适位置。纹理是图像（`.png`、`.jpeg` 等），图形库能够将其应用到网格上。Babylon.js 处理了多种纹理方法，例如视频纹理、立方体纹理等。现在，让我们解释如何使用材质来使用纹理。
- en: Load and apply a texture
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载并应用纹理
- en: 'As you may have already guessed, loading and applying a texture to a mesh can
    be easy with Babylon.js. The standard material provides a way, as for colors,
    to apply a diffuse texture (for example, specular, emissive, and ambient textures).
    Simply set the `.diffuseTexture` property to the reference of your texture, as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经猜到的，使用 Babylon.js 加载并将纹理应用到网格上可以很容易。标准材质提供了一种方法，就像颜色一样，可以应用漫反射纹理（例如，镜面、发射和环境纹理）。只需将
    `.diffuseTexture` 属性设置为纹理的引用，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create the `myTexture` object, let''s take a look at the `BABYLON.Texture`
    class, as shown in the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `myTexture` 对象，让我们看看以下所示的 `BABYLON.Texture` 类：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is done now. The diffuse texture will now be applied to the mesh. Consider
    the `floor_diffuse.png` image in the example files as an example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成了。漫反射纹理现在将被应用到网格上。以下是一个示例，考虑示例文件中的 `floor_diffuse.png` 图像：
- en: '![Load and apply a texture](img/image_04_010.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_010.png)'
- en: 'Now, let''s play with the texture''s properties. In the example files, there
    is a `cloud.png` texture that contains an alpha channel (transparency). If you
    apply the cloud texture, the result is as shown in the following image:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们玩一下纹理的属性。在示例文件中，有一个包含 alpha 通道（透明度）的 `cloud.png` 纹理。如果你应用云纹理，结果如下所示：
- en: '![Load and apply a texture](img/image_04_011.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_011.png)'
- en: 'The black part represents the alpha channel and looks like an artifact that
    pollutes the rendering part of the sphere. In fact, the textures are applied on
    meshes thanks to the pixel shaders, and you must tell the shaders that the textures
    can contain an alpha channel. This job can be done thanks to the `.hasAlpha` property
    of the texture, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色部分代表 alpha 通道，看起来像污染球体渲染部分的伪影。实际上，纹理是通过像素着色器应用到网格上的，你必须告诉着色器纹理可以包含 alpha 通道。这项工作可以通过纹理的
    `.hasAlpha` 属性来完成，如下所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result is the following image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Load and apply a texture](img/image_04_012.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_012.png)'
- en: You can see that the back faces of the sphere are not rendered. This is due
    to the optimization of the graphics libraries as it is not necessarily needed
    (in most cases) to render the triangles of the back faces that the cameras cannot
    see. It is called `back-face culling`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到球体的背面没有被渲染。这是由于图形库的优化，因为在大多数情况下，渲染摄像机看不到的背面三角形的三角形并不是必需的。这被称为“背面裁剪”。
- en: 'To disable the `back-face culling`, simply set the `.backFaceCulling` property
    of the material to false, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用`背面裁剪`，只需将材质的`.backFaceCulling`属性设置为false，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is as shown in the following image:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如以下图像所示：
- en: '![Load and apply a texture](img/image_04_013.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_013.png)'
- en: 'Since textures are applied by the pixel shaders, a lot of parameters can be
    set thanks to the materials, for example, the vertical and horizontal scales of
    the texture. Let''s start with the following texture:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纹理是通过像素着色器应用的，因此可以通过材质设置许多参数，例如纹理的垂直和水平缩放。让我们从以下纹理开始：
- en: '![Load and apply a texture](img/image_04_014.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_014.png)'
- en: 'The `.uScale` and`.vScale` properties of a texture allow us to apply a repeat
    pattern to the mesh. The 1.0 default value means that the texture is repeated
    once on the mesh. Let''s see the following result with `5.0`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的`.uScale`和`.vScale`属性允许我们向网格应用重复图案。1.0的默认值意味着纹理在网格上重复一次。让我们看看以下`5.0`的结果：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Load and apply a texture](img/image_04_015.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_015.png)'
- en: 'As for the textures scales, you can create an offset to adjust the texture''s
    positions on the mesh according to the `.uScale` and`.vScale` properties, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 至于纹理缩放，你可以创建一个偏移量来根据`.uScale`和`.vScale`属性调整纹理在网格上的位置，如下所示：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Load and apply a texture](img/image_04_016.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_016.png)'
- en: The bump mapping
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凹凸贴图
- en: 'In the texturing methods that Babylon.js is handling, we can the find the bump mapping
    technique. This technique is used to create a relief on a surface and have more
    realistic surfaces using two different textures: the diffuse texture and a *normal
    texture*. This technique is famous as it doesn''t modify the original geometry
    of the mesh and is only computed by the shaders using the two textures.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Babylon.js处理的纹理方法中，我们可以找到凹凸贴图技术。这项技术用于在表面上创建凸起，并使用两种不同的纹理（漫反射纹理和法线纹理）创建更逼真的表面。这项技术因其不修改网格的原始几何形状，而仅通过着色器使用两种纹理进行计算而闻名。
- en: 'The diffuse and normal textures are provided by the artists and are built by
    some artist''s tools to help the production. An example of normal texture is as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射纹理和法线纹理由艺术家提供，并由一些艺术家工具构建，以帮助生产。以下是一个法线纹理的示例：
- en: '![The bump mapping](img/image_04_017.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![凹凸贴图](img/image_04_017.png)'
- en: In fact, the pixel shader applies the diffuse texture and modifies the pixels
    in the function of the normal texture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，像素着色器应用漫反射纹理并修改根据法线纹理的像素。
- en: 'Let''s see the normal mapping effect. This is without normal mapping:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看法线贴图效果。这是没有法线贴图的情况：
- en: '![The bump mapping](img/image_04_018.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![凹凸贴图](img/image_04_018.png)'
- en: 'With normal mapping, the image will look similar to the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用法线贴图，图像将类似于以下：
- en: '![The bump mapping](img/image_04_019.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![凹凸贴图](img/image_04_019.png)'
- en: 'Applying the normal mapping effect with Babylon.js is as easy as applying a
    diffuse texture. Let''s explain this with the following two lines of code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Babylon.js应用法线贴图效果与应用漫反射纹理一样简单。让我们用以下两行代码来解释：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The internal effect of the material is able to adapt the rendering in the function
    of the properties. Then, if the `.bumpTexture` property is set, the effect will
    compute the bump mapping technique.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 材料内部效果能够根据属性来调整渲染。然后，如果设置了`.bumpTexture`属性，效果将计算凹凸贴图技术。
- en: Advanced texturing
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级纹理
- en: The standard material of Babylon.js allows us to apply a reflection texture.
    If this texture is set, the internal effect of the material will create a reflection
    effect using this texture.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js的标准材质允许我们应用反射纹理。如果设置了此纹理，材质的内部效果将使用此纹理创建反射效果。
- en: The cube texture
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 立方体贴图
- en: The cube texture is special. An interesting use of the reflection texture with
    a cube texture is the skybox mesh. A skybox is composed of six faces and tends
    to reproduce the environment around a scene, typically the sky. To handle the
    six faces with a texture, the cube texture will load six textures and apply them
    to the mesh.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图是特殊的。使用立方体贴图和反射纹理的一个有趣用途是天空盒网格。天空盒由六个面组成，通常用于重现场景周围的环境，通常是天空。为了处理六个面，立方体贴图将加载六个纹理并将它们应用到网格上。
- en: 'Let''s load a cube texture with Babylon.js, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Babylon.js加载一个立方体贴图，如下所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The parameters are as shown in the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下所示：
- en: The path to the six textures. Each texture name must begin with `TropicalSunnyDay`
    in this example, followed by the six directions of the cube: `nx`, `ny`, `nz`, `px`, `py`,
    and `pz`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scene where to add the cube texture.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: the default extension for the cube texture is .jpg. You can learn of
    the precise extension by passing a third parameter, which is an array of String.
    Consider the following as an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s create a skybox. A skybox is a cube with `back-face culling` disabled
    as the camera will be in the cube, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the result, the cube texture is applied to the cube; however, we can find
    some artifacts in the links between parts of the cube texture:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![The cube texture](img/image_04_020.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: These artefacts are due to the coordinates mode of the texture. In fact, the
    textures are applied to meshes by the 2D coordinates provided by the mesh's geometry.
    As for the vertex buffer and the index buffer, the geometry contains a coordinate
    buffer commonly named the **UVs** buffer, and several methods exist to apply a
    certain coordinate pattern. In this case, the skybox coordinate mode should be
    applied. This is possible with `the.coordinatesMode` property, as follows
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the coordinates mode is set, the result looks great, as shown in the following
    image:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![The cube texture](img/image_04_021.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'The result of the skybox outside the cube is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![The cube texture](img/image_04_022.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: The mirror texture
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explain the usage of a reflection texture with a new texture type named
    **Mirror Texture**. With Babylon.js, it is possible to reflect the world using
    a mirror texture. The mirror texture is particular as it is created by Babylon.js
    and can render the scene into a texture. Behind the reflection texture, a new
    texture type is used: the render target texture. Render target textures are used
    to directly render meshes into a texture for further use. Now, let''s create a
    mirror texture, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The parameters are as shown in the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The texture name: The name of the texture created by Babylon.js.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The texture size: The bigger the texture, the cleaner the mirror texture is.
    Unfortunately, bigger the texture, bigger will be its impact on the performance.
    The values 512 or 1024 (512 x 512 or 1024 x 1024 pixels) are good sizes for a
    mirror texture.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scene where to add the texture.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to reflect the world, the mirror texture needs a last parameter: the mirror
    plane. If we take the ground as an example, we want the ground to reflect the
    world above itself:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A plane has four properties: `a`, `b`, `c`, and `d`. The first three properties
    represent the normal vector, where `d` is the distance to the origin. The `FromPositionAndNormal`
    static method is a helper to create a plane. The parameters are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The plane's position vector. Here, the origin (`x=0`, `y=0`, `z=0`).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the example files, the plane position is (`x=0`, `y=-5`, `z=0`). Therefore,
    the plane's position must be (`x=0`, `y=5`, `z=0`).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plane's normal vector. Here, the origin is (`x=0`, `y=-1`, `z=0`).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the code lines become the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To configure the render target texture in the mirror texture, we must provide
    an array of `BABYLON.AbstractMesh`. This array is used to render only the meshes
    indexed in the array. The array is already created by the mirror texture and the
    property''s name is`.renderList`. Then, the mirror texture will only expose the
    added meshes in the array, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result with a ground (plane at the same position) and the reflected spheres
    is as shown in the following image:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![The mirror texture](img/image_04_023.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw what materials are, the theory about what is happening
    backstage, and how to use the standard materials of Babylon.js. You saw that using
    a material in Babylon.js is also easy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The example files tend to reproduce the notions viewed in this chapter: colors,
    alpha, textures, fog, back-face culling, and so on. Now, you can practice with
    materials and customize appearance of meshes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concrete example, the materials are highly used in all the 3D scenes and
    configured by 3D artists: if we take a scene of Babylon.js made by Michel Rousseau,
    where he used two meshes and two different materials to reproduce the following
    image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/image_04_024.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'The first mesh is the body of the vase with a standard material applied to
    it and the second mesh represents the embers with another standard material applied
    to them. Each material is configured with a different diffuse texture. If we set
    the body as `isVisible = false`, we can see how the embers look in reality, as
    shown in the following image:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/image_04_025.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Finally, all the meshes rendered in this scene are using standard materials,
    configured with different values and textures, to finally look similar to the
    following image:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/image_04_026.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: In the next chapter, you'll create your first scene with an FPS camera and collisions
    management. You will learn how to manage collisions between objects and how to
    manage physics with Babylon.js.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
