- en: Chapter 4. Using Materials to Customize 3D Objects Appearance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objects that we call *materials* are essential in 3D rendering. They are
    used to render objects on the screen and how they are rendered. This means that
    the materials are used to apply textures and transformations such as waves, for
    example, manage transparency and more. In other words, materials are interfaces
    that are used to easily customize the 3D object's appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example with Babylon.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Discussing the awesome theory behind the materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Babylon.js standard material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using textures with materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the awesome theory behind the materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The materials are used to customize 3D objects appearance; however, behind them
    lie two programs called **shaders**. The goal of materials is to hide this notion
    of shaders and simply work with the values in the material object. In other words,
    the values in the material can be the emissive color of the object, the diffuse
    color, the transparency level and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, to go further with the theory, there are several types of shader,
    as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex Shader**: This works directly on the 3D object geometry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pixel Shader**: This works directly on the pixels on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geometry Shader** (not available on WebGL): This works on the 3D object geometry;
    however, here it is able to directly add polygons to the geometry of the 3D object
    according to the output of the vertex shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compute Shader** (not available on WebGL): This doesn''t work directly on
    the 3D objects and pixels. It is just used to compute some user-defined data using
    the GPU instead of the CPU. For example, a compute shader will take a texture
    as the input (you can see that as a big matrix) and output the results of the
    program in another texture. The compute shader is highly used, for example, to
    compute realistic ocean waves or neural networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tesselation Shader** (not available on WebGL): This allows us to compute **Level
    of Detail** (**LOD**) directly on the GPU instead of the CPU (fairly new in the
    modern rendering pipelines, such as Direct3D 11 and OpenGL 4.0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case and with WebGL, only the vertex and pixel shaders are used to render
    3D scenes on the screen; however, it would not be surprising to see the other
    types of shaders being implemented in WebGL in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The meshes that we created in the previous chapters contain vertex buffers and
    index buffers. The vertex buffers describe the 3D positions of the vertices. The
    main problem is how to project the vertices in a 3D space into a 2D space, which
    is the screen space. Indeed, to draw elements on the screen, GPUs are used through
    programs to transform the vertices positions into 2D positions on the screen.
    These programs are the vertex shader and the pixel shader. They are written with
    a language named GLSL, which is the OpenGL shading language used with WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vertex shader is used to transform the vertices positions. It is executed
    by the GPU for each vertex and can be used for an infinite number of functions.
    For example, to create waves on a large ocean plane, we will use the vertex shader
    to compute the wave function for each vertex instead of using the TS code that
    is executed on the CPU side–leave the job to the real worker.
  prefs: []
  type: TYPE_NORMAL
- en: Once the vertex shader computes a triangle (a face) on the screen, thanks to
    the index buffer, the pixel shader is called to illuminate the pixels used by
    the current triangle (current face) of the current mesh that is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The pixel shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pixel shader has the same structure as the vertex shader; it is written
    with the same language (GLSL) and is called for each pixel used by the current
    triangle on the screen. The main function of the pixel shader is to return a color
    computed in the RGBA format, which can be determined from a user-defined value
    or directly from a texture.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Babylon.js standard material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Babylon.js allows you to create materials, which means that it can create the
    custom materials with custom shaders; however, it provides a standard material
    with already-developed shaders that are designed to be adapted by many customizations.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when you add a light to a Babylon.js scene, the light properties such
    as diffuse color, are sent to the materials of the scene to compute the light
    contributions on the meshes.
  prefs: []
  type: TYPE_NORMAL
- en: The standard material and its common properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Babylon.js, each mesh has a material and the meshes can share the same material.
    Creating a standard material and assigning it to a mesh with Babylon.js is as
    easy as writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply create a new `StandardMaterial` object by giving a name to the material
    and the scene where you want to add the material and assign it `the.material`
    property of a mesh. Once the material is created, you can start modifying the
    values and then customize the mesh appearance. The default material by default
    looks similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The standard material and its common properties](img/image_04_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The diffuse color: The diffuse color represents the color of the object, as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![The standard material and its common properties](img/image_04_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The specular color: The specular color represents the light color reflected
    by the object (this is mixed with the diffuse color), as shown in the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![The standard material and its common properties](img/image_04_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The emissive color: The emissive color represents the color emitted by the
    object (this is mixed with the specular color and the diffuse color), as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![The standard material and its common properties](img/image_04_004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Manage transparency: To manage transparency, the standard material provides
    a .alpha property in the [0, 1] interval, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![The standard material and its common properties](img/image_04_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the fog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard material allows you to apply the fog effect that is related to
    the current scene that is rendered. To enable the fog on an object, simply set
    `the.fogEnabled` property to true on the materials and the scene, as shown in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the following scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the fog](img/image_04_006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The fog in a scene can be customized. There are several types of fog, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Linear fog (`BABYLON.Scene.FOGMODE_LINEAR`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exponential (`BABYLON.Scene.FOGMODE_EXP`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exponential 2 (faster than the previous) (`BABYLON.Scene.FOGMODE_EXP2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the linear mode, the two properties—`scene.fogStart` and `scene.fogEnd`—can
    be set. Consider the following, as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Using the fog](img/image_04_007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Change the fog color using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Using the fog](img/image_04_008.png)'
  prefs: []
  type: TYPE_IMG
- en: With the exponential mode, the `scene.fogDensity` property can be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Using the fog](img/image_04_009.png)'
  prefs: []
  type: TYPE_IMG
- en: Using textures with materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is the right place to introduce the usage of textures. Textures
    are images (`.png`,`.jpeg`, and so on) that graphics libraries are able to apply
    to meshes. There are several types of texturing methods handled by Babylon.js,
    such as video textures, cube textures, and so on. Now, let's explain how to use
    textures with materials.
  prefs: []
  type: TYPE_NORMAL
- en: Load and apply a texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may have already guessed, loading and applying a texture to a mesh can
    be easy with Babylon.js. The standard material provides a way, as for colors,
    to apply a diffuse texture (for example, specular, emissive, and ambient textures).
    Simply set the `.diffuseTexture` property to the reference of your texture, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the `myTexture` object, let''s take a look at the `BABYLON.Texture`
    class, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done now. The diffuse texture will now be applied to the mesh. Consider
    the `floor_diffuse.png` image in the example files as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load and apply a texture](img/image_04_010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s play with the texture''s properties. In the example files, there
    is a `cloud.png` texture that contains an alpha channel (transparency). If you
    apply the cloud texture, the result is as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load and apply a texture](img/image_04_011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The black part represents the alpha channel and looks like an artifact that
    pollutes the rendering part of the sphere. In fact, the textures are applied on
    meshes thanks to the pixel shaders, and you must tell the shaders that the textures
    can contain an alpha channel. This job can be done thanks to the `.hasAlpha` property
    of the texture, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load and apply a texture](img/image_04_012.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the back faces of the sphere are not rendered. This is due
    to the optimization of the graphics libraries as it is not necessarily needed
    (in most cases) to render the triangles of the back faces that the cameras cannot
    see. It is called `back-face culling`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the `back-face culling`, simply set the `.backFaceCulling` property
    of the material to false, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load and apply a texture](img/image_04_013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since textures are applied by the pixel shaders, a lot of parameters can be
    set thanks to the materials, for example, the vertical and horizontal scales of
    the texture. Let''s start with the following texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load and apply a texture](img/image_04_014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `.uScale` and`.vScale` properties of a texture allow us to apply a repeat
    pattern to the mesh. The 1.0 default value means that the texture is repeated
    once on the mesh. Let''s see the following result with `5.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Load and apply a texture](img/image_04_015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As for the textures scales, you can create an offset to adjust the texture''s
    positions on the mesh according to the `.uScale` and`.vScale` properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Load and apply a texture](img/image_04_016.png)'
  prefs: []
  type: TYPE_IMG
- en: The bump mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the texturing methods that Babylon.js is handling, we can the find the bump mapping
    technique. This technique is used to create a relief on a surface and have more
    realistic surfaces using two different textures: the diffuse texture and a *normal
    texture*. This technique is famous as it doesn''t modify the original geometry
    of the mesh and is only computed by the shaders using the two textures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The diffuse and normal textures are provided by the artists and are built by
    some artist''s tools to help the production. An example of normal texture is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The bump mapping](img/image_04_017.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, the pixel shader applies the diffuse texture and modifies the pixels
    in the function of the normal texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the normal mapping effect. This is without normal mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The bump mapping](img/image_04_018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With normal mapping, the image will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The bump mapping](img/image_04_019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Applying the normal mapping effect with Babylon.js is as easy as applying a
    diffuse texture. Let''s explain this with the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The internal effect of the material is able to adapt the rendering in the function
    of the properties. Then, if the `.bumpTexture` property is set, the effect will
    compute the bump mapping technique.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced texturing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard material of Babylon.js allows us to apply a reflection texture.
    If this texture is set, the internal effect of the material will create a reflection
    effect using this texture.
  prefs: []
  type: TYPE_NORMAL
- en: The cube texture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cube texture is special. An interesting use of the reflection texture with
    a cube texture is the skybox mesh. A skybox is composed of six faces and tends
    to reproduce the environment around a scene, typically the sky. To handle the
    six faces with a texture, the cube texture will load six textures and apply them
    to the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load a cube texture with Babylon.js, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters are as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The path to the six textures. Each texture name must begin with `TropicalSunnyDay`
    in this example, followed by the six directions of the cube: `nx`, `ny`, `nz`, `px`, `py`,
    and `pz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scene where to add the cube texture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: the default extension for the cube texture is .jpg. You can learn of
    the precise extension by passing a third parameter, which is an array of String.
    Consider the following as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a skybox. A skybox is a cube with `back-face culling` disabled
    as the camera will be in the cube, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the result, the cube texture is applied to the cube; however, we can find
    some artifacts in the links between parts of the cube texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The cube texture](img/image_04_020.png)'
  prefs: []
  type: TYPE_IMG
- en: These artefacts are due to the coordinates mode of the texture. In fact, the
    textures are applied to meshes by the 2D coordinates provided by the mesh's geometry.
    As for the vertex buffer and the index buffer, the geometry contains a coordinate
    buffer commonly named the **UVs** buffer, and several methods exist to apply a
    certain coordinate pattern. In this case, the skybox coordinate mode should be
    applied. This is possible with `the.coordinatesMode` property, as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the coordinates mode is set, the result looks great, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The cube texture](img/image_04_021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result of the skybox outside the cube is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The cube texture](img/image_04_022.png)'
  prefs: []
  type: TYPE_IMG
- en: The mirror texture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explain the usage of a reflection texture with a new texture type named
    **Mirror Texture**. With Babylon.js, it is possible to reflect the world using
    a mirror texture. The mirror texture is particular as it is created by Babylon.js
    and can render the scene into a texture. Behind the reflection texture, a new
    texture type is used: the render target texture. Render target textures are used
    to directly render meshes into a texture for further use. Now, let''s create a
    mirror texture, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters are as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The texture name: The name of the texture created by Babylon.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The texture size: The bigger the texture, the cleaner the mirror texture is.
    Unfortunately, bigger the texture, bigger will be its impact on the performance.
    The values 512 or 1024 (512 x 512 or 1024 x 1024 pixels) are good sizes for a
    mirror texture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scene where to add the texture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to reflect the world, the mirror texture needs a last parameter: the mirror
    plane. If we take the ground as an example, we want the ground to reflect the
    world above itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A plane has four properties: `a`, `b`, `c`, and `d`. The first three properties
    represent the normal vector, where `d` is the distance to the origin. The `FromPositionAndNormal`
    static method is a helper to create a plane. The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The plane's position vector. Here, the origin (`x=0`, `y=0`, `z=0`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the example files, the plane position is (`x=0`, `y=-5`, `z=0`). Therefore,
    the plane's position must be (`x=0`, `y=5`, `z=0`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plane's normal vector. Here, the origin is (`x=0`, `y=-1`, `z=0`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the code lines become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure the render target texture in the mirror texture, we must provide
    an array of `BABYLON.AbstractMesh`. This array is used to render only the meshes
    indexed in the array. The array is already created by the mirror texture and the
    property''s name is`.renderList`. Then, the mirror texture will only expose the
    added meshes in the array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result with a ground (plane at the same position) and the reflected spheres
    is as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The mirror texture](img/image_04_023.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw what materials are, the theory about what is happening
    backstage, and how to use the standard materials of Babylon.js. You saw that using
    a material in Babylon.js is also easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example files tend to reproduce the notions viewed in this chapter: colors,
    alpha, textures, fog, back-face culling, and so on. Now, you can practice with
    materials and customize appearance of meshes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concrete example, the materials are highly used in all the 3D scenes and
    configured by 3D artists: if we take a scene of Babylon.js made by Michel Rousseau,
    where he used two meshes and two different materials to reproduce the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/image_04_024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first mesh is the body of the vase with a standard material applied to
    it and the second mesh represents the embers with another standard material applied
    to them. Each material is configured with a different diffuse texture. If we set
    the body as `isVisible = false`, we can see how the embers look in reality, as
    shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/image_04_025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, all the meshes rendered in this scene are using standard materials,
    configured with different values and textures, to finally look similar to the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/image_04_026.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next chapter, you'll create your first scene with an FPS camera and collisions
    management. You will learn how to manage collisions between objects and how to
    manage physics with Babylon.js.
  prefs: []
  type: TYPE_NORMAL
