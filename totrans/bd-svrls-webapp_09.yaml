- en: Handling Serverless Notifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理无服务器通知
- en: Push notifications are a common use case for modern applications. They are important
    not just for mobile devices, but also for websites. When you are browsing your
    Facebook timeline and receive a notification that a friend has commented on one
    of your photos, this is a push notification. In this chapter, you will learn how
    to implement this feature in a serverless solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知是现代应用程序的常见用例。它们不仅对移动设备重要，对网站也很重要。当你浏览你的 Facebook 时间线并收到通知，说有朋友评论了你的一张照片时，这就是一个推送通知。在本章中，你将学习如何在无服务器解决方案中实现这一功能。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Implementing serverless notifications using AWS IoT
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS IoT 实现无服务器通知
- en: Public and private notifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共和私有通知
- en: By the end of this chapter, you'll have learned how to handle real-time notifications
    in a serverless application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何在无服务器应用程序中处理实时通知。
- en: AWS IoT
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS IoT
- en: It may sound strange to use the Internet of Things as a service for websites,
    but AWS IoT is the only service offered by Amazon that supports WebSockets in
    a serverless model. Without WebSockets, we need to rely on *polling*. Polling
    is the process where the client needs to make repeated and frequent requests to
    the server, checking whether a new message is available, while WebSockets are
    used to create a link between the client and the server where the server can send
    the message directly to the client without the need of being constantly requested.
    WebSockets are used to implement the *publish-subscribe* pattern, which is more
    efficient than *polling*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将物联网作为网站的服务听起来可能有些奇怪，但 AWS IoT 是亚马逊提供的唯一支持在无服务器模型中使用 WebSocket 的服务。没有 WebSocket，我们需要依赖
    *轮询*。轮询是客户端需要反复频繁地向服务器发送请求，检查是否有新消息的过程，而 WebSocket 则用于在客户端和服务器之间创建一个连接，服务器可以直接将消息发送到客户端，无需不断请求。WebSocket
    用于实现 *发布-订阅* 模式，这比 *轮询* 更高效。
- en: Besides AWS IoT, another candidate to implement real-time serverless notifications
    is Amazon **Simple Queue Service** (**SQS**). You can create a queue of messages
    that are destined for a single user and wait for this user to request SQS looking
    for new messages. While polling is necessary for this solution, Amazon offers
    a feature named *long-polling*. With this feature, when you request a message
    to SQS, AWS will hold your request up to 20 seconds, waiting for a new message
    to arrive. If one arrives while waiting, you will receive the response immediately.
    If no message appears, after 20 seconds, you will receive an empty response and
    will need to make a new SQS request. This approach reduces the total number of
    requests and the costs associated with a frequent polling approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 AWS IoT，另一个用于实现实时无服务器通知的候选者是亚马逊 **简单队列服务**（**SQS**）。你可以创建一个消息队列，这些消息是针对单个用户的，并等待这个用户请求
    SQS 以查找新消息。虽然轮询对于这个解决方案是必要的，但亚马逊提供了一个名为 *长轮询* 的功能。使用这个功能，当你向 SQS 请求消息时，AWS 将保持你的请求长达
    20 秒，等待新消息的到来。如果在此期间有新消息到达，你将立即收到响应。如果没有消息出现，20 秒后，你将收到一个空响应，并需要发出新的 SQS 请求。这种方法减少了请求的总数和频繁轮询方法相关的成本。
- en: One advantage that SQS has over IoT is the guarantee that a message will be
    read. If you place a message in SQS, it will be removed only when someone receive
    it, while with IoT, the user must be connected to receive the message.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SQS 相比于 IoT 的一个优势是保证了消息的读取。如果你将一条消息放入 SQS，它只有在有人接收它时才会被移除，而在 IoT 中，用户必须连接才能接收消息。
- en: Another service that is used for notifications is Amazon **Simple Notification
    Service** (**SNS**). Although the name sounds like an obvious choice for serverless
    notifications, it does not support WebSockets and you can't hook a browser client
    to receive notifications on demand. However, for mobile applications, you can
    use it with push notifications services, such as **Google Cloud Messaging** (**GCM**),
    for real-time messages without polling.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于通知的服务是亚马逊 **简单通知服务**（**SNS**）。尽管这个名字听起来像是无服务器通知的明显选择，但它不支持 WebSocket，你不能将浏览器客户端连接到接收按需通知。然而，对于移动应用程序，你可以使用它配合推送通知服务，如
    **Google Cloud Messaging**（**GCM**），以实现无需轮询的实时消息。
- en: You may not like the name "IoT", but it is a great service and solves our use
    case of getting notifications respecting the serverless model. AWS IoT is a simple
    messaging service. You can have *devices* subscribed to *topics* to receive messages
    that will be published by other devices. In our examples, you will consider a
    *device* as a user connected through a web browser that will receive messages
    from other users or from a Lambda function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不喜欢“物联网”（IoT）这个名字，但它是一项伟大的服务，解决了我们根据无服务器模型获取通知的使用案例。AWS IoT是一个简单的消息服务。你可以让*设备*订阅*主题*以接收其他设备发布的消息。在我们的示例中，你将把*设备*视为通过网页浏览器连接的用户，他们将接收来自其他用户或Lambda函数的消息。
- en: Protocols
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议
- en: AWS IoT supports *HTTP*, *MQTT*, and *MQTT over WebSockets* protocols. HTTP
    uses a RESTful endpoint and **Message Queue Telemetry Transport** (**MQTT**) is
    a lightweight messaging protocol that was created for small sensors and constrained
    devices.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: AWS IoT支持*HTTP*、*MQTT*和*通过WebSockets的MQTT*协议。HTTP使用RESTful端点，**消息队列遥测传输**（**MQTT**）是一个为小型传感器和受限设备创建的轻量级消息协议。
- en: You may think that using HTTP would be the easiest option for us who already
    know how to use RESTful endpoints, but HTTP support is restricted to publishing
    messages. In a REST architecture, you can't subscribe to messages, since the server
    can't initiate transmissions. The server is only able to answer requests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为对我们这些已经知道如何使用RESTful端点的人来说，使用HTTP会是最佳选择，但HTTP支持仅限于发布消息。在REST架构中，你不能订阅消息，因为服务器不能主动发起传输。服务器只能响应请求。
- en: MQTT over WebSockets is an enhancement to the MQTT protocol with the objective
    of supporting browser-based applications. It supports the *subscribe* feature,
    so your user can be hooked waiting for messages instead of being constantly polling
    for updates every few seconds. Avoiding a polling mechanism is strictly necessary
    for efficiency and to allow scalability when you want to serve thousands of users
    simultaneously.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过WebSockets的MQTT是对MQTT协议的一种增强，旨在支持基于浏览器的应用程序。它支持*订阅*功能，因此你的用户可以等待消息而不是每隔几秒就不断轮询更新。避免轮询机制对于效率和在你想同时服务数千个用户时的可扩展性是绝对必要的。
- en: Finding the IoT endpoint
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找IoT端点
- en: 'To use the AWS IoT service, you must provide the IoT endpoint of your account
    from the region that you want to use this service. Let''s execute the following
    steps to find the IoT endpoint:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用AWS IoT服务，你必须提供你想要使用此服务的区域的账户的IoT端点。让我们执行以下步骤来查找IoT端点：
- en: You can find this information using the IoT Management Console, which is available
    at [https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用IoT管理控制台找到这些信息，该控制台可在[https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot)找到。
- en: 'In the top-right corner, you can change the service region. Click on Get started
    to move to the next screen:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角，你可以更改服务区域。点击“开始”以跳转到下一屏幕：
- en: '![](img/9cab2df0-a742-46ff-b6ef-0df798469484.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9cab2df0-a742-46ff-b6ef-0df798469484.png)'
- en: 'On the console screen, choose the Settings option located in the bottom-left
    corner:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台屏幕上，选择位于左下角的“设置”选项：
- en: '![](img/433dac79-1301-4f61-95b3-432516f393d8.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/433dac79-1301-4f61-95b3-432516f393d8.png)'
- en: 'Write down your IoT endpoint address to use in your application:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的IoT端点地址记录下来，以便在应用程序中使用：
- en: '![](img/7acf80d4-3e09-4105-9846-0be0f4bd32dd.png)**Security observation:** the
    endpoint address doesn''t need to be private. You can hardcode it in your application
    and distribute it to your clients, since the frontend code needs to know this
    address to access IoT messages.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/7acf80d4-3e09-4105-9846-0be0f4bd32dd.png)**安全观察：**端点地址不需要是私有的。你可以在应用程序中将其硬编码并分发给你的客户端，因为前端代码需要知道这个地址来访问IoT消息。'
- en: 'For our demo application, the frontend code we will have this information in
    the `config.js` file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的演示应用程序，前端代码我们将在`config.js`文件中包含以下信息：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: AWS IoT SDK
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS IoT SDK
- en: Handling the MQTT protocol and signing each request can be a troublesome task.
    Fortunately, we don't need to *reinvent the wheel*. AWS offers an SDK that implements
    the MQTT protocol for us and offers all the features that we need to use. You
    can find the source code on GitHub at [https://github.com/aws/aws-iot-device-sdk-js](https://github.com/aws/aws-iot-device-sdk-js).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 处理MQTT协议并对每个请求进行签名可能是一项麻烦的任务。幸运的是，我们不需要“重新发明轮子”。AWS为我们提供了一个SDK，它实现了MQTT协议，并提供了我们使用所需的所有功能。你可以在GitHub上找到源代码：[https://github.com/aws/aws-iot-device-sdk-js](https://github.com/aws/aws-iot-device-sdk-js)。
- en: 'You can install the module using npm by executing this command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令使用npm安装模块：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use this SDK, we need to pass the following information:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此 SDK，我们需要传递以下信息：
- en: '**Credentials**: The SDK will need to know the AWS access key, AWS secret access
    key, and session token to be able to sign the requests and get the authorization
    to access the AWS resources. We are going to use Cognito later to dynamically
    retrieve temporary credentials.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭证**：SDK 需要知道 AWS 访问密钥、AWS 秘密访问密钥和会话令牌，以便能够签署请求并获取访问 AWS 资源的授权。我们稍后将使用 Cognito
    动态检索临时凭证。'
- en: '**Region**: The region of the AWS IoT service that we are going to use.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：我们将要使用的 AWS IoT 服务的区域。'
- en: '**IoT endpoint**: The IoT endpoint that we have just retrieved.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物联网端点**：我们刚刚检索到的物联网端点。'
- en: '**IoT topic**: You don''t need to explicitly create an IoT topic beforehand.
    Just choose a word and use it as a channel to exchange messages. However, your
    credentials must have authorization to this topic or to `*` (all topics).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物联网主题**：您不需要事先明确创建物联网主题。只需选择一个词，并将其用作交换消息的通道。然而，您的凭证必须具有对此主题或 `*`（所有主题）的授权。'
- en: 'For our example, we are going to create a class in a `iot.js` file inside the
    frontend''s `lib` folder:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将在前端 `lib` 文件夹中的 `iot.js` 文件中创建一个类：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class has a constructor which receives the necessary credentials and a
    `messageCallback` function that will be used as a dependency injection. Whenever
    we receive a new message, we are going to call this `messageCallback` function
    to execute the desired logic by the one that has created the new object instance
    of the IoT class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此类有一个构造函数，它接收必要的凭证和一个 `messageCallback` 函数，该函数将用作依赖注入。每当收到一条新消息时，我们将调用此 `messageCallback`
    函数来执行创建物联网类的新对象实例的人所期望的逻辑。
- en: 'Let''s now see how to implement the `connect`, `publish`, and `subscribe` methods:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何实现 `connect`、`publish` 和 `subscribe` 方法：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the previous code, the `connect` method subscribes the `client` object to
    three events:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`connect` 方法将 `client` 对象订阅了三个事件：
- en: The `connect` event
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect` 事件'
- en: The `message` event
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message` 事件'
- en: The `close` event
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close` 事件'
- en: 'There are also three more events that you can subscribe to make your application
    more robust:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以订阅另外三个事件，使您的应用程序更加健壮：
- en: The `error` event
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error` 事件'
- en: The `reconnect` event
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reconnect` 事件'
- en: The `offline` event
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offline` 事件'
- en: 'The last step is to define the methods that will handle these events. They
    are defined as the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是定义将处理这些事件的函数。它们被定义为以下内容：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implementing serverless notifications
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现无服务器通知
- en: 'In the previous section, you learned about the AWS IoT SDK, we just haven''t
    tested it yet. In this section, we will use it in the following two features of
    our serverless store:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学习了关于 AWS IoT SDK 的内容，但我们还没有对其进行测试。在本节中，我们将将其用于我们无服务器商店的以下两个功能：
- en: Live comments in a product review page
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品评论页面的实时评论
- en: Notifications after a payment has been accepted
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付被接受后的通知
- en: The first feature is a type of a **public notification**, as it uses an IoT
    topic that all users can read. The second one is a **private notification**, so
    only one person and the Lambda backend are allowed to access the IoT topic to
    subscribe or publish messages. We will cover both of them to learn how to give
    proper access for each case.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个功能是一种 **公共通知** 类型，因为它使用所有用户都可以读取的物联网主题。第二个是 **私有通知**，因此只有一个人和 Lambda 后端被允许访问物联网主题以订阅或发布消息。我们将介绍这两个，以了解如何为每种情况提供适当的访问权限。
- en: Those two examples will illustrate how you can work with IoT to serve notifications,
    but it does not limit what you can do with it. You can think in other use cases.
    For example, IoT can also be used for serverless multiplayer games. You could
    build an HTML5 game that could make requests to a Lambda backend to execute some
    logic (for example, find a room to play) and an IoT topic to exchange messages
    between players. It may not be well suited to very dynamic games like FPS games,
    but could be pretty useful and cheap for card games, puzzles, and games where
    you don't need extremely low and predictable response times.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例将说明您如何使用物联网来提供通知，但这并不限制您可以使用它的方式。您可以思考其他用例。例如，物联网也可以用于无服务器多人游戏。您可以构建一个
    HTML5 游戏，该游戏可以向 Lambda 后端发出请求以执行某些逻辑（例如，找到一个游戏房间）以及一个物联网主题，用于玩家之间的消息交换。它可能不适合像
    FPS 游戏这样非常动态的游戏，但对于卡牌游戏、谜题和不需要极低且可预测的响应时间的游戏来说可能非常有用且成本低廉。
- en: Public notifications
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共通知
- en: In [Chapter 5](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml), *Building the Frontend*,
    we defined the product details view and it has a list of all customer reviews.
    What we are going to implement here is *live comments*. When a user adds a new
    review, another user that is browsing the same page will see the message at the
    same moment that it is posted. It may not seem to be so important for a customer
    review page, but this is the kind of feature that is extremely important for chat
    systems, forums, and social networks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml) *构建前端* 中，我们定义了产品详情视图，它包含所有客户评论的列表。我们在这里要实现的是*实时评论*。当用户添加新的评论时，浏览同一页面的另一个用户将看到与发布同一时刻的消息。这可能对客户评论页面来说并不重要，但这种功能对于聊天系统、论坛和社交网络来说非常重要。
- en: Adding a comment box
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加评论框
- en: 'The following screenshot shows the current state of our product details page:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的产品详情页的当前状态：
- en: '![](img/ce575d72-1ff9-4c0d-9078-8f039321efc0.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce575d72-1ff9-4c0d-9078-8f039321efc0.png)'
- en: 'We are going to modify the React application to add a comment box like this
    one:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改React应用程序以添加一个如下所示的评论框：
- en: '![](img/123a5d99-f8a7-4528-a481-2d077b26777d.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/123a5d99-f8a7-4528-a481-2d077b26777d.png)'
- en: 'For this task, we need to create a `CommentBox` component that will be rendered
    as input text and a button:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们需要创建一个`CommentBox`组件，该组件将作为输入文本和按钮渲染：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When defining the elements, we have placed an `onChange` event to the input
    text to save the input value and an `onClick` event to send the information to
    the `App` component. They are implemented as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义元素时，我们为输入文本添加了一个`onChange`事件来保存输入值，并为发送信息到`App`组件添加了一个`onClick`事件。它们如下实现：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This completes the `CommentBox` implementation. What we are going to see next
    is how the `App` component will handle these events to update the page and send
    a message to other users that are on the same page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`CommentBox`的实现。接下来我们将看到`App`组件将如何处理这些事件来更新页面并向同一页面的其他用户发送消息。
- en: Updating the list of comments
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新评论列表
- en: 'In the `App` component, we need to handle comment creation. In the following
    code excerpt, we are creating a new comment object and adding it to the beginning
    of the comment list array:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App`组件中，我们需要处理评论创建。在下面的代码片段中，我们创建一个新的评论对象并将其添加到评论列表数组的开头：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To set the ID of the comment, I''ve used the `UUID` module (`npm install uuid
    --save`) to create a random value. Example of an UUID: `110ec58a-a0f2-4ac4-8393-c866d813b8d1`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置评论的ID，我使用了`UUID`模块（`npm install uuid --save`）来创建一个随机值。UUID的示例：`110ec58a-a0f2-4ac4-8393-c866d813b8d1`
- en: 'What we need to do now is to send the new comment to the IoT service, so it
    can be shared with other users on the same page and saved in the database. For
    now, our comment feature should be working and updating the list of customer reviews:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的是将新的评论发送到IoT服务，以便与其他页面的用户共享并保存在数据库中。目前，我们的评论功能应该已经工作，并更新客户评论列表：
- en: '![](img/83eedf92-55dd-4c77-aecc-cb0d2726c5db.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83eedf92-55dd-4c77-aecc-cb0d2726c5db.png)'
- en: Creating a new instance of the IoT SDK
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建IoT SDK的新实例
- en: In this section, we are going to create a new instance of the IoT class that
    uses the IoT SDK. This class needs AWS access keys to connect with the IoT services.
    As we are handling public notifications that don't need an authenticated user,
    we need to create credentials for anonymous users.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的IoT类实例，该实例使用IoT SDK。这个类需要AWS访问密钥来连接IoT服务。由于我们处理的是不需要认证用户的公共通知，我们需要为匿名用户创建凭证。
- en: 'Let''s create a new instance of the IoT SDK by performing the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建IoT SDK的新实例：
- en: 'We will start adding the AWS SDK to our frontend project using npm:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始使用npm将AWS SDK添加到我们的前端项目中：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the AWS SDK, we can request anonymous access to Cognito using the following
    code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用AWS SDK，我们可以使用以下代码请求对Cognito的匿名访问：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we configured in the previous chapter, this identity pool gives access to
    anonymous users to the IoT topic `serverless-store-comments`. With those keys
    in hand, we are ready to create an instance of the IoT class, connect, and subscribe
    with this topic:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在上一章中配置的那样，这个身份池为匿名用户提供了对IoT主题`serverless-store-comments`的访问权限。有了这些密钥在手，我们就可以创建IoT类的实例，连接并订阅此主题：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sending and receiving new comments
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送和接收新的评论
- en: 'The `App` component is our entity responsible for managing the application
    state. Therefore, it will be responsible for sending and receiving comments. To
    implement this, we need to make the following three changes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件是我们负责管理应用程序状态的实体。因此，它将负责发送和接收评论。为了实现这一点，我们需要进行以下三个更改：'
- en: 'Modify the `componentDidMount` to create an instance of the IoT class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`componentDidMount`以创建IoT类的实例：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Modify the `handleComments` function to send new comments using IoT:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`handleComments`函数以使用IoT发送新评论：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the `handleIotMessages` function to receive the messages and update
    the list of comments:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`handleIotMessages`函数以接收消息并更新评论列表：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Test the application, running it using two browser tabs. When you add a comment
    in one tab, the same comment must appear immediately in the other tab.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序，使用两个浏览器标签运行它。当你在其中一个标签中添加评论时，相同的评论必须立即出现在另一个标签中。
- en: Triggering a Lambda function with IoT
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IoT触发Lambda函数
- en: The IoT service is being used to exchange live messages between connected users.
    However, the information is not being persisted. What we are going to do here
    is to trigger a Lambda function when a new message arrives to an IoT topic, so
    this message can be persisted.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网服务正在用于在连接的用户之间交换实时消息。然而，信息没有被持久化。我们在这里要做的是，当新的消息到达IoT主题时触发一个Lambda函数，以便该消息可以被持久化。
- en: 'We can trigger a Lambda function by configuring an event in the `serverless.yml`
    file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`serverless.yml`文件中配置一个事件来触发Lambda函数：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For our example, replace `topic-name` with `serverless-store-comments`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，将`topic-name`替换为`serverless-store-comments`。
- en: IoT uses an SQL-like syntax to trigger the Lambda function and to select which
    content will be sent. In the preceding example, we are passing all contents of
    the message to the Lambda function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网（IoT）使用类似SQL的语法来触发Lambda函数并选择要发送的内容。在先前的示例中，我们将消息的所有内容传递给Lambda函数。
- en: 'This SQL statement can be very useful for filtering messages to only trigger
    a Lambda function when necessary. For example, suppose that we send a message
    with the following JSON object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个SQL语句可以非常有助于过滤消息，仅在必要时触发Lambda函数。例如，假设我们发送以下JSON对象的消息：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We could use the SQL statement to trigger another Lambda function, for example
    `handle-bad-reviews`, only when the rating is low:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用SQL语句来触发另一个Lambda函数，例如`handle-bad-reviews`，只有当评分低时：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Going back to our serverless store example, we have defined the trigger to
    the Lambda function. Now we can implement the function to save the data into the
    database. As using a serverless database was already covered in [Chapter 7](cb2f92df-5bc3-4c8e-8872-fbee58e5b0be.xhtml),
    *Managing a Serverless Database*, the next example will just log the contents
    of the `event` object for testing purposes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的无服务器商店示例，我们已经定义了Lambda函数的触发器。现在我们可以实现将数据保存到数据库中的函数。由于在第7章[管理无服务器数据库](cb2f92df-5bc3-4c8e-8872-fbee58e5b0be.xhtml)中已经涵盖了使用无服务器数据库，下一个示例将仅为了测试目的记录`event`对象的内容：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can test if it is working using the `logs` command of the Serverless Framework:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Serverless Framework的`logs`命令来测试它是否正常工作：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Private notifications
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有通知
- en: 'In [Chapter 8](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml), *Securing the Serverless
    Application*, we defined a policy document for authenticated users to include
    an authorization to the following IoT topic:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml)，*保护无服务器应用程序*中，我们为已认证的用户定义了一个策略文档，包括对以下IoT主题的授权：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This means that an authenticated user will have access to an exclusive topic,
    the name of which is defined by its own federated identity. What we are going
    to implement next is a *private notification*, where a Lambda function will publish
    a message to an IoT topic and just one user will be able to receive it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着已认证的用户将能够访问一个专有的主题，其名称由其自己的联合身份定义。我们接下来要实现的是一种*私有通知*，其中Lambda函数将消息发布到IoT主题，只有一位用户能够接收它。
- en: Using credentials of an authenticated user
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用已认证用户的凭据
- en: 'For an unauthenticated user, we saw that we set credentials using the following
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未认证的用户，我们看到了如何使用以下代码设置凭据：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, for an authenticated user, the `credentials` object needs to be set
    with an extra property: `Logins`. The following code shows how this is done:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于已认证的用户，需要将`credentials`对象设置为一个额外的属性：`Logins`。以下代码展示了如何实现这一点：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Updating the logout feature
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新登出功能
- en: 'When we use the AWS credentials feature, the AWS SDK saves user data to local
    storage. To avoid another user logging on the same browser to use the credentials
    of the previous user, we need to clear that data on logout. This is done by adding
    the following piece of code to the `Logout` handler:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 AWS 凭证功能时，AWS SDK 将用户数据保存到本地存储。为了避免另一个用户在同一个浏览器上登录并使用前一个用户的凭证，我们需要在注销时清除这些数据。这是通过将以下代码片段添加到
    `Logout` 处理器来完成的：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating an IoT policy
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 IoT 策略
- en: 'Using an authenticated user to connect to IoT requires an extra step: we need
    to attach an IoT security policy. Without this attachment, the IoT service will
    reject all requests.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用认证用户连接到 IoT 需要额外一步：我们需要附加一个 IoT 安全策略。如果没有这个附加，IoT 服务将拒绝所有请求。
- en: 'Let''s see how to create this policy by performing the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来查看如何创建此策略：
- en: Open the IoT Console at [https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IoT 控制台，[https://console.aws.amazon.com/iot](https://console.aws.amazon.com/iot)。
- en: 'In the left-hand menu, navigate to Security | Policies and then click on Create
    a policy:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，导航到安全 | 策略，然后点击创建策略：
- en: '![](img/9dd7e082-61e2-487f-bfd2-f921f95a4c96.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9dd7e082-61e2-487f-bfd2-f921f95a4c96.png)'
- en: 'Choose a policy name, use the Action `iot:Connect`, `iot:Subscribe`, `iot:Publish`,
    and `iot:Receive`, type `*` for the Resource, and check Allow for the Effect:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个策略名称，使用操作 `iot:Connect`、`iot:Subscribe`、`iot:Publish` 和 `iot:Receive`，对于资源输入
    `*`，并检查允许的效果：
- en: '![](img/49daa357-88ac-44bc-a60e-945d2dd72296.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49daa357-88ac-44bc-a60e-945d2dd72296.png)'
- en: Click on Create to finish.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建以完成。
- en: '**Security observation:** although we have selected the `*` resource, we won''t
    be able to subscribe or publish to all topics because AWS will use the Cognito
    roles to check permissions and this policy document was set with restricted access.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全观察：**虽然我们选择了 `*` 资源，但我们无法订阅或发布到所有主题，因为 AWS 将使用 Cognito 角色来检查权限，而这个策略文档被设置为受限访问。'
- en: Attaching an IoT policy and connecting
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 IoT 策略附加并连接
- en: 'In the previous chapter, we set the Cognito policy document to allow access
    to the action `iot:attachPrincipalPolicy`. Now we are going to use it. After getting
    the AWS credentials, we are going to use the `AWS.Iot` module and the `attachPrincipalPolicy`
    function to attach the IoT policy that we have just created to the authenticated
    user. After setting the policy, we are going to connect to IoT and subscribe to
    the public and private topics:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将 Cognito 策略文档设置为允许访问 `iot:attachPrincipalPolicy` 动作。现在我们将使用它。在获取 AWS
    凭证后，我们将使用 `AWS.Iot` 模块和 `attachPrincipalPolicy` 函数将我们刚刚创建的 IoT 策略附加到认证用户。设置策略后，我们将连接到
    IoT 并订阅公共和私有主题：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Passing the Cognito Identity to the Lambda function
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Cognito 身份传递给 Lambda 函数
- en: In the previous chapter, when we have defined the restricted access to IoT resources,
    we have used the `${cognito-identity.amazonaws.com:sub}` IAM policy variable to
    define the IoT topic name. This parameter uses the Cognito Identity, but the backend
    code doesn't know this value. The Lambda function will retrieve a User ID through
    the authorizer (`event.requestContext.authorizer.claims.sub`), but the Authorizer
    ID is different from the Cognito Identity.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们定义了对 IoT 资源的受限访问时，我们使用了 `${cognito-identity.amazonaws.com:sub}` IAM
    策略变量来定义 IoT 主题名称。此参数使用 Cognito 身份，但后端代码不知道此值。Lambda 函数将通过授权器（`event.requestContext.authorizer.claims.sub`）检索一个用户
    ID，但授权器 ID 与 Cognito 身份不同。
- en: To pass this value from the frontend code to the backend, AWS recommends we
    send a signed request using its **Signature Version 4** (**Sigv4**) signing process.
    Furthermore, instead of setting the Cognito authorizer in the API Gateway, you
    need to use the **AWS_IAM** authorizer. It's the safest way to pass this information
    to the backend because this method guarantees that only the real user will be
    able to send its Cognito ID.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此值从前端代码传递到后端，AWS 建议我们使用其 **Signature Version 4**（**Sigv4**）签名过程发送已签名的请求。此外，您不需要在
    API Gateway 中设置 Cognito 授权器，而需要使用 **AWS_IAM** 授权器。这是将此信息传递到后端最安全的方式，因为这种方法保证只有真实用户才能发送其
    Cognito ID。
- en: However, we won't cover this topic here. Signing the request with **Sigv4**
    and using **AWS_IAM** authorizer is much more complicated than using the the Cognito
    authorizer and our demo application doesn't need this because we use the Authorizer
    ID to identify a user and not the Cognito ID. Besides, as we have configured the
    IoT role policy, it's impossible for one user to receive a message created to
    another user, even if a malicious user knows the other user's Identity. The worst
    case scenario would be for a malicious user to trigger unwanted messages to other
    users, which will happen only if the other user credentials were compromised.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这里不会涉及这个话题。使用**Sigv4**签名请求并使用**AWS_IAM**授权器要比使用Cognito授权器和我们的演示应用所需的复杂得多，因为我们使用授权器ID来识别用户，而不是Cognito
    ID。此外，由于我们已经配置了IoT角色策略，一个用户无法接收为另一个用户创建的消息，即使恶意用户知道另一个用户的身份。最坏的情况是恶意用户触发对其他用户的未预期消息，这只会发生在其他用户的凭证被破坏的情况下。
- en: So, in our case, we are going to send Cognito ID from the frontend to the backend
    using the `AWS.config.credentials.identityId` parameter in the `Checkout` request.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的例子中，我们将通过`Checkout`请求中的`AWS.config.credentials.identityId`参数，从前端发送Cognito
    ID到后端。
- en: Sending IoT messages with Lambda
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda发送IoT消息
- en: 'We have modified the application to subscribe the authenticated user to a public
    and a private topic. What we are going to look at now is how to send a message
    to this private topic using a Lambda function by performing the following steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修改了应用程序，使认证用户订阅了公共和私有主题。我们现在要探讨的是如何通过以下步骤使用Lambda函数向这个私有主题发送消息：
- en: 'The first step is to modify the `serverless.yml` file to give explicit permissions
    to allow access to `iot:Publish`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是修改`serverless.yml`文件，以明确权限允许访问`iot:Publish`：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For our example, we are going to use the `processCheckout` function. The user
    will click on Checkout and this action will trigger a Lambda function that will
    publish a message to the user topic. The result will be the notification icon
    changing color to notify the user that a new message is available:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用`processCheckout`函数。用户将点击结账，这个动作将触发一个Lambda函数，该函数将向用户主题发布一条消息。结果是通知图标颜色改变，以通知用户有新消息可用：
- en: '![](img/2f41c9a6-9107-4819-b8c1-3a9c899e425b.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f41c9a6-9107-4819-b8c1-3a9c899e425b.png)'
- en: 'Changing the frontend application is a simple task, so it will be an exercise
    for the reader. Regarding the backend code, we are going to use the following
    code for the `processCheckout` function:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改前端应用程序是一个简单的任务，所以这将是读者的练习。至于后端代码，我们将为`processCheckout`函数使用以下代码：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Remember that the `userId` variable was retrieved in the previous chapter by
    analyzing the `event` object: `event.requestContext.authorizer.claims.sub`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`userId`变量是在前一章通过分析`event`对象检索的：`event.requestContext.authorizer.claims.sub`
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create serverless notifications using the
    AWS IoT service. We covered how to implement a live comment system and push notifications
    for individual users. You already know how to use the AWS IoT Device SDK and how
    to use the IoT to trigger Lambda functions or to use a Lambda to send messages
    to an IoT endpoint.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用AWS IoT服务创建无服务器通知。我们介绍了如何实现实时评论系统和为单个用户推送通知。你已经知道如何使用AWS IoT设备SDK，以及如何使用IoT触发Lambda函数或使用Lambda向IoT端点发送消息。
- en: In the next chapter, we will finish the online store, showing how to test our
    serverless application, followed by the definition of a deployment workflow for
    development and production environments, and we will finish off by showing what
    you can (and should) monitor in a serverless solution.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将完成在线商店，展示如何测试我们的无服务器应用，然后定义开发和生产环境中的部署工作流程，最后我们将展示在无服务器解决方案中你可以（和应该）监控的内容。
