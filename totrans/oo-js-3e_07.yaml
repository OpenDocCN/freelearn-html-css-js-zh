- en: Chapter 7. Inheritance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。继承
- en: If you go back to [Chapter 1](ch01.html "Chapter 1. Object-Oriented JavaScript"),
    *Object-Oriented JavaScript*, and review the *Object-oriented programming* section,
    you'll see that you already know how to apply most of them to JavaScript. You
    know what objects, methods, and properties are. You know that there are no classes
    in ES5, although you can achieve them using constructor functions. ES6 introduces
    the notion of classes; we will take a detailed look at how ES6 classes work in
    the next chapter. Encapsulation? Yes, the objects encapsulate both the data and
    the means (methods) to do something with the data. Aggregation? Sure, an object
    can contain other objects. In fact, this is almost always the case since methods
    are functions and functions are also objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回到[第1章](ch01.html "第1章。面向对象的JavaScript")，*面向对象的JavaScript*，并回顾*面向对象编程*部分，您会发现您已经知道如何将其中大部分应用到JavaScript中。您知道对象、方法和属性是什么。您知道ES5中没有类，尽管您可以使用构造函数实现它们。ES6引入了类的概念；我们将在下一章详细探讨ES6类的工作原理。封装？是的，对象封装了数据和操作数据的方法（方法）。聚合？当然，一个对象可以包含其他对象。事实上，这几乎总是如此，因为方法本身就是函数，而函数也是对象。
- en: Now, let's focus on the inheritance part. This is one of the most interesting
    features, as it allows you to reuse existing code, thus promoting laziness, which
    is likely to be what brought human species to computer programming in the first
    place.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于继承部分。这是最有趣的功能之一，因为它允许您重用现有代码，从而促进懒惰，这可能是人类物种最初进入计算机编程的原因。
- en: JavaScript is a dynamic language, and there is usually more than one way to
    achieve any given task. Inheritance is not an exception. In this chapter, you'll
    see some common patterns for implementing inheritance. Having a good understanding
    of these patterns will help you pick the right one, or the right mix, depending
    on your task, project, or style.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种动态语言，通常有多种方式可以完成任何给定的任务。继承也不例外。在本章中，您将看到一些实现继承的常见模式。对这些模式有良好的理解将帮助您根据任务、项目或风格选择正确的方法，或者选择正确的混合方式。
- en: Prototype chaining
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型链
- en: Let's start with the default way of implementing inheritance - inheritance chaining
    through the prototype.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现继承的默认方式开始——通过原型进行继承链。
- en: As you already know, every function has a `prototype` property, which points
    to an object. When a function is invoked using the `new` operator, an object is
    created and returned. This new object has a secret link to the `prototype` object.
    The secret link (called `__proto__` in some environments) allows methods and properties
    of the `prototype` object to be used as if they belonged to the newly created
    object.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，每个函数都有一个 `prototype` 属性，它指向一个对象。当使用 `new` 操作符调用函数时，会创建并返回一个对象。这个新对象有一个指向
    `prototype` 对象的秘密链接。这个秘密链接（在某些环境中称为 `__proto__`）允许使用 `prototype` 对象的方法和属性，就像它们属于新创建的对象一样。
- en: 'The `prototype` object is just a regular object and, therefore, it also has
    the secret link to its prototype. And so, a chain called a prototype chain is
    created:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`prototype` 对象只是一个普通对象，因此它也有一个指向其原型的秘密链接。因此，就创建了一个称为原型链的链：'
- en: '![Prototype chaining](img/proto.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![原型链](img/proto.jpg)'
- en: In this illustration, an object **A** contains a number of properties. One of
    the properties is the hidden `__proto__` property, which points to another object,
    **B**. **B**'s `__proto__` property points to **C**. This chain ends with the
    `Object.prototype` object, the grandparent, and every object inherits from it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，对象 **A** 包含了许多属性。其中一个属性是隐藏的 `__proto__` 属性，它指向另一个对象，**B**。**B** 的 `__proto__`
    属性指向 **C**。这个链以 `Object.prototype` 对象，即祖先对象结束，并且每个对象都继承自它。
- en: This is all good to know, but how does it help you? The practical side is that
    when object **A** lacks a property but **B** has it, **A** can still access this
    property as its own. The same applies if **B** also doesn't have the required
    property, but **C** does. This is how inheritance takes place - an object can
    access any property found somewhere down the inheritance chain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很重要，但它们如何帮助您呢？实用方面是，当对象 **A** 缺少属性但 **B** 有时，**A** 仍然可以访问这个属性，就像它自己的属性一样。如果
    **B** 也没有所需的属性，但 **C** 有，这也适用。这就是继承发生的方式——一个对象可以访问继承链中任何地方找到的属性。
- en: Throughout this chapter, you'll see different examples that use the following
    hierarchy - a generic `Shape` parent is inherited by a `2D shape`, which in turn
    is inherited by any number of specific two-dimensional shapes such as a triangle,
    rectangle, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你会看到使用以下层次结构的不同示例 - 一个通用的 `Shape` 父类被 `2D shape` 继承，而 `2D shape` 又被任何数量的特定二维形状（如三角形、矩形等）继承。
- en: Prototype chaining example
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型链示例
- en: 'Prototype chaining is the default way to implement inheritance. In order to
    implement the hierarchy, let''s define three constructor functions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 原型链是实现继承的默认方式。为了实现层次结构，让我们定义三个构造函数：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code that performs the inheritance magic is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 执行继承魔法的代码如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What's happening here? You take the object contained in the `prototype` property
    of `TwoDShape`, and instead of augmenting it with individual properties, you completely
    overwrite it with another object, created by invoking the `Shape()` constructor
    with `new`. The same process can be followed for `Triangle`-its prototype is replaced
    by an object created by `new TwoDShape()`. It's important to remember that JavaScript
    works with objects, not classes. You need to create an instance using the `new
    Shape()` constructor, and after that, you can inherit its properties; you don't
    inherit from `Shape()` directly. Additionally, after inheriting, you can modify
    the `Shape()` constructor, overwrite it, or even delete it, and this will have
    no effect on `TwoDShape`, because all you needed is one instance to inherit from.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？你从 `TwoDShape` 的 `prototype` 属性中获取对象，而不是用单个属性增强它，而是用另一个对象完全覆盖它，这个对象是通过用
    `new` 调用 `Shape()` 构造函数创建的。同样的过程也可以应用于 `Triangle` - 它的原型被用 `new TwoDShape()` 创建的对象替换。重要的是要记住，JavaScript
    与对象一起工作，而不是与类一起工作。你需要使用 `new Shape()` 构造函数创建一个实例，然后你可以继承其属性；你并不是直接从 `Shape()`
    继承。此外，在继承之后，你可以修改 `Shape()` 构造函数，覆盖它，甚至删除它，这将对 `TwoDShape` 没有影响，因为你所需要的就是一个用于继承的实例。
- en: 'As you know from the previous chapter, overwriting the prototype (as opposed
    to just adding properties to it), has side effects on the `constructor` property.
    Therefore, it''s a good idea to reset the `constructor` property after inheriting.
    Consider the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章所知，覆盖原型（而不是仅仅向其添加属性），会对 `constructor` 属性产生副作用。因此，在继承之后重置 `constructor`
    属性是个好主意。考虑以下示例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s test what has happened so far. Creating a `Triangle` object and
    calling its own `getArea()` method works as expected:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试到目前为止发生了什么。创建一个 `Triangle` 对象并调用它的 `getArea()` 方法，正如预期的那样工作：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although the `my` object doesn''t have its own `toString()` method, it inherited
    one and you can call it. Note how the inherited method `toString()` binds the
    `this` object to `my`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对象 `my` 没有自己的 `toString()` 方法，但它继承了该方法，你可以调用它。注意继承的方法 `toString()` 如何将 `this`
    对象绑定到 `my`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s fascinating to consider what the JavaScript engine does when you call
    `my.toString()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `my.toString()` 时，考虑 JavaScript 引擎做了什么是非常有趣的：
- en: It loops through all of the properties of `my` and doesn't find a method called
    `toString()`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遍历 `my` 的所有属性，但没有找到名为 `toString()` 的方法。
- en: It looks at the object that `my.__proto__` points to `this` object is the instance
    `new TwoDShape()` created during the inheritance process.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它查看 `my.__proto__` 指向的对象，`this` 对象是在继承过程中创建的 `new TwoDShape()` 实例。
- en: Now, the JavaScript engine loops through the instance of `TwoDShape` and doesn't
    find a `toString()` method. It then checks `__proto__` of that object. This time,
    `__proto__` points to the instance created by `new Shape()`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，JavaScript 引擎遍历 `TwoDShape` 的实例，但没有找到 `toString()` 方法。然后它检查那个对象的 `__proto__`。这次，`__proto__`
    指向由 `new Shape()` 创建的实例。
- en: The instance of `new Shape()` is examined, and `toString()` is finally found.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 `new Shape()` 的实例，并最终找到 `toString()`。
- en: This method is invoked in the context of `my`, meaning that `this` points to
    `my`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个方法是在 `my` 的上下文中调用的，这意味着 `this` 指向 `my`。
- en: 'If you ask `my`, Who''s your constructor?, it reports it correctly because
    of the reset of the `constructor` property after the inheritance:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你询问 `my`，"你的构造函数是谁？"，它会正确地报告，因为继承之后`constructor`属性被重置了：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the `instanceof` operator, you can validate that `my` is an instance
    of all three constructors:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `instanceof` 操作符，你可以验证 `my` 是否是所有三个构造函数的实例：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same happens when you call `isPrototypeOf()`on the constructors by passing
    `my`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过传递 `my` 调用构造函数的 `isPrototypeOf()` 时，也会发生相同的情况：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also create objects using the other two constructors. Objects created
    with `new TwoDShape()` also get the `toString()`method inherited from `Shape()`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用其他两个构造函数来创建对象。使用 `new TwoDShape()` 创建的对象也会继承自 `Shape()` 的 `toString()`
    方法：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Moving shared properties to the prototype
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将共享属性移动到原型
- en: 'When you create objects using a constructor function, own properties are added
    using `this`. This could be inefficient in cases where properties don''t change
    across instances. In the previous example, `Shape()` was defined as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用构造函数创建对象时，使用 `this` 添加自己的属性。在属性在实例之间不发生变化的情况下，这可能会效率低下。在上一个例子中，`Shape()`
    被定义为如下所示：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This means that every time you create a new object using `new Shape()`, a new
    `name` property is created and stored somewhere in the memory. The other option
    is to have the `name` property added to the prototype and shared among all the
    instances:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次使用 `new Shape()` 创建新对象时，都会创建一个新的 `name` 属性，并将其存储在内存中的某个位置。另一种选择是将 `name`
    属性添加到原型中，并在所有实例之间共享：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, every time you create an object using `new Shape()`, this object doesn't
    get its own property `name`, but uses the one added to the prototype. This is
    more efficient, but you should only use it for properties that don't change from
    one instance to another. Methods are ideal for this type of sharing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次使用 `new Shape()` 创建对象时，该对象不会获得自己的属性 `name`，而是使用添加到原型的那个。这更有效率，但您应该只为那些从一个实例到另一个实例不发生变化的属性使用它。方法对于这种共享是理想的。
- en: 'Let''s improve the preceding example by adding all methods and suitable properties
    to `prototype`. In the case of `Shape()` and `TwoDShape()`, everything is meant
    to be shared:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将所有方法和合适的属性添加到 `prototype` 来改进前面的例子。在 `Shape()` 和 `TwoDShape()` 的情况下，一切都是为了共享：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, you have to take care of inheritance first before augmenting
    the prototype. Otherwise, anything you add to `TwoDShape.prototype` gets wiped
    out when you inherit.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在增强原型之前，您必须首先处理继承。否则，您添加到 `TwoDShape.prototype` 中的任何内容，在继承时都会被清除。
- en: 'The `Triangle` constructor is a little different, because every object it creates
    is a new triangle, which is likely to have different dimensions. So, it''s good
    to keep `side` and `height` as own properties and share the rest. The `getArea()`
    method, for example, is the same, regardless of the actual dimensions of each
    triangle. Again, you do the inheritance bit first and then augment the prototype:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triangle` 构造函数略有不同，因为它创建的每个对象都是一个新三角形，其尺寸可能不同。因此，保留 `side` 和 `height` 作为自己的属性，共享其余部分是好的。例如，`getArea()`
    方法与每个三角形的实际尺寸无关。再次强调，您首先进行继承部分，然后增强原型：'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'All the preceding test code works exactly the same. Here is an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述测试代码都完全相同。以下是一个示例：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is only a slight behind-the-scenes difference when calling `my.toString()`.
    The difference is that there is one more lookup to be done before the method is
    found in `Shape.prototype`, as opposed to in the `new Shape()` instance, like
    it was in the previous example.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `my.toString()` 时，幕后只有细微的差别。差别在于，在 `Shape.prototype` 中找到该方法之前，需要多进行一次查找，而不是像上一个例子中在
    `new Shape()` 实例中那样。
- en: 'You can also play with `hasOwnProperty()` to see the difference between the
    own property versus a property coming down the prototype chain:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `hasOwnProperty()` 来查看自己的属性与从原型链下来的属性之间的区别：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The calls to `isPrototypeOf()` and the `instanceof` operator from the previous
    example work in exactly the same way:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个例子中 `isPrototypeOf()` 调用和 `instanceof` 操作符的工作方式完全相同：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inheriting the prototype only
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅继承原型
- en: 'As explained earlier, for reasons of efficiency, you should add the reusable
    properties and methods to the prototype. If you do so, then it''s a good idea
    to inherit only the prototype, because all the reusable code is there. This means
    that inheriting the `Shape.prototype` object is better than inheriting the object
    created with `new Shape()`. After all, `new Shape()` only gives you own shape
    properties that are not meant to be reused (otherwise, they would be in the prototype).
    You gain a little more efficiency by:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，出于效率的考虑，您应该将可重用的属性和方法添加到原型中。如果您这样做，那么只继承原型是一个好主意，因为所有可重用的代码都在那里。这意味着继承
    `Shape.prototype` 对象比继承使用 `new Shape()` 创建的对象更好。毕竟，`new Shape()` 只提供了自己的形状属性，这些属性不应该被重用（否则，它们会在原型中）。通过以下方式，您可以获得一点额外的效率：
- en: Not creating a new object for the sake of inheritance alone
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅为了继承而创建新对象
- en: Having fewer lookups during runtime (when it comes to searching for `toString()`)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时（当搜索 `toString()` 时）查找次数更少
- en: 'For example, here''s the updated code; the changes are highlighted:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是更新的代码；更改已突出显示：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The test code gives you the same result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码给出相同的结果：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What's the difference in the lookups when calling `my.toString()`? First, as
    usual, the JavaScript engine looks for a `toString()`method of the `my` object
    itself. The engine doesn't find such a method, so it inspects the prototype. The
    prototype turns out to be pointing to the same object that the prototype of `TwoDShape`
    points to and also the same object that `Shape.prototype` points to. Remember
    that objects are not copied by value, but only by reference. So, the lookup is
    only a two-step process as opposed to four (in the previous example) or three
    (in the first example).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `my.toString()` 时，查找有什么不同？首先，像往常一样，JavaScript 引擎会查找 `my` 对象自身的 `toString()`
    方法。引擎没有找到这样的方法，因此它检查原型。结果原型指向的对象与 `TwoDShape` 的原型指向的对象相同，也指向 `Shape.prototype`
    指向的对象。记住，对象不是按值复制，而是按引用复制。因此，查找过程只有两步，而不是之前的四个（在先前的例子中）或三个（在第一个例子中）。
- en: Simply copying the prototype is more efficient, but it has a side effect because,
    all the prototypes of the children and parents point to the same object, when
    a child modifies the prototype, the parents get the changes and so do the siblings.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地复制原型更高效，但它有一个副作用，因为所有子类和父类的原型都指向同一个对象，当子类修改原型时，父类会接收到这些更改，以及兄弟姐妹也会。
- en: 'Look at the following line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下行：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It changes the `name` property, so it effectively changes `Shape.prototype.name`
    too. If you create an instance using `new Shape()`, its `name` property says `"Triangle"`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它改变了 `name` 属性，因此实际上也改变了 `Shape.prototype.name`。如果您使用 `new Shape()` 创建一个实例，它的
    `name` 属性会显示 `"Triangle"`：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method is more efficient, but may not suit all your use cases.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法更高效，但可能不适合所有您的用例。
- en: A temporary constructor - new F()
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个临时的构造函数 - new F()
- en: A solution to the previously outlined problem, where all prototypes point to
    the same object and the parents get children's properties, is to use an intermediary
    to break the chain. The intermediary is in the form of a temporary constructor
    function. Creating an empty function `F()` and setting its `prototype` to the
    prototype of the parent constructor allows you to call `new F()`and create objects
    that have no properties of their own, but inherit everything from the parent's
    `prototype`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 解决之前概述的问题（即所有原型都指向同一个对象，并且父类会接收到子类的属性）的一种方法是使用中介来断开链。中介的形式是一个临时的构造函数。创建一个空的函数
    `F()` 并将其 `prototype` 设置为父构造函数的原型，允许您调用 `new F()` 并创建没有任何自身属性但继承父类 `prototype`
    的对象。
- en: 'Let''s take a look at the modified code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看修改后的代码：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Creating `my` triangle and testing the methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `my` 三角形并测试方法：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using this approach, the prototype chain stays in place:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，原型链保持不变：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, the parents'' properties are not overwritten by the children:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，父类的属性不会被子类覆盖：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At the same time, this approach supports the idea that only properties and methods
    added to the prototype should be inherited and own properties should not. The
    rationale behind this is that own properties are likely to be too specific to
    be reusable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，这种方法支持这样一个观点：只有添加到原型的属性和方法应该被继承，而自身的属性则不应该被继承。背后的理由是，自身的属性可能过于特定，难以复用。
- en: Uber - access to the parent from a child object
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Uber - 从子对象访问父对象
- en: Classical OO languages usually have a special syntax that gives you access to
    the parent class, also referred to the superclass. This could be convenient when
    a child wants to have a method that does everything the parent's method does,
    plus something in addition to it. In such cases, the child calls the parent's
    method with the same name and works with the result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的面向对象语言通常有特殊的语法，可以让你访问父类，也称为超类。当子类想要有一个执行父类方法所有操作，并在此基础上添加额外操作的方法时，这可能很方便。在这种情况下，子类会调用具有相同名称的父类方法，并处理结果。
- en: 'In JavaScript, there is no such special syntax, but it''s trivial to achieve
    the same functionality. Let''s rewrite the last example, and while taking care
    of inheritance, also create an `uber` property that points to the parent''s `prototype`
    object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，没有这样的特殊语法，但实现相同功能很简单。让我们重写最后一个例子，同时注意继承，并创建一个指向父类 `prototype`
    对象的 `uber` 属性：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The new things here are:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新特性包括：
- en: A new `uber` property points to the parent's `prototype`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `uber` 属性指向父对象的 `prototype`
- en: The updated `toString()`method
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新的 `toString()` 方法
- en: 'Previously, `toString()` only returned `this.name`. Now, in addition to this,
    there is a check to see whether `this.constructor.uber` exists and, if it does,
    call its `toString()` first. The `this.constructor` is the function itself, and
    `this.constructor.uber` points to the parent''s `prototype`. The result is that
    when you call `toString()` for a `Triangle` instance, all `toString()` methods
    up the prototype chain are called:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，`toString()` 只返回 `this.name`。现在，除了这个之外，还有一个检查来查看 `this.constructor.uber`
    是否存在，如果存在，则首先调用它的 `toString()`。`this.constructor` 是函数本身，`this.constructor.uber`
    指向父对象的 `prototype`。结果是，当你为 `Triangle` 实例调用 `toString()` 时，原型链上的所有 `toString()`
    方法都会被调用：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The name of the `uber` property could've been superclass, but this would suggest
    that JavaScript has classes. Ideally, it could've been super (as in Java), but
    super is a reserved word in JavaScript. The German word uber suggested by Douglas
    Crockford means more or less the same as super, and you have to admit, it sounds
    uber cool.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`uber` 属性的名称原本可以是 superclass，但这会暗示 JavaScript 有类。理想情况下，它可以是 super（就像 Java 一样），但
    super 是 JavaScript 中的一个保留字。Douglas Crockford 提出的德语词 uber 大约意味着与 super 相同的意思，而且你必须承认，它听起来超级酷。'
- en: Isolating the inheritance part into a function
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将继承部分隔离到函数中
- en: 'Let''s move the code that takes care of all the inheritance details from the
    last example into a reusable `extend()` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把处理所有继承细节的代码从上一个例子移动到一个可重用的 `extend()` 函数中：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using this function (or your own custom version of it) helps you keep your
    code clean with regard to the repetitive inheritance-related tasks. This way,
    you can inherit by simply using the following two lines of code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数（或你自己的自定义版本）可以帮助你保持代码的整洁，特别是关于重复的继承相关任务。这样，你只需使用以下两行代码就可以继承：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s see a complete example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个完整的例子：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Lets test the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试以下代码：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Copying properties
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制属性
- en: 'Now, let''s try a slightly different approach. Since inheritance is all about
    reusing code, can you simply copy the properties you like from one object to another?
    Or from a parent to a child? Keeping the same interface as the preceding `extend()`
    function, you can create a `extend2()`function, which takes two constructor functions
    and copies all the properties from the parent''s `prototype` to the child''s `prototype`.
    This will, of course, carry over methods too, as methods are just properties that
    happen to be functions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一种稍微不同的方法。既然继承全部是关于代码重用，你能否简单地从一个对象复制你喜欢的属性到另一个对象？或者从父对象到子对象？保持与前面的
    `extend()` 函数相同的接口，你可以创建一个 `extend2()` 函数，它接受两个构造函数并将父对象的 `prototype` 中的所有属性复制到子对象的
    `prototype` 中。当然，这也会携带方法，因为方法只是碰巧是函数的属性：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, a simple loop through the properties is all it takes. As with
    the previous example, you can set an `uber` property if you want to have handy
    access to parent's methods from the child. Unlike the previous example though,
    it's not necessary to reset `Child.prototype.constructor` because here, the child
    `prototype` is augmented, not overwritten completely. So, the `constructor` property
    points to the initial value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只需简单地遍历属性即可。与前面的例子一样，如果你想从子对象方便地访问父对象的方法，可以设置一个 `uber` 属性。然而，与前面的例子不同，没有必要重置
    `Child.prototype.constructor`，因为在这里，子 `prototype` 是被增强，而不是完全覆盖。所以，`constructor`
    属性指向初始值。
- en: This method is a little inefficient compared to the previous method because
    properties of the child `prototype` are being duplicated instead of simply being
    looked up via the prototype chain during execution. Bear in mind that this is
    only true for properties containing primitive types. All objects (including functions
    and arrays) are not duplicated, because these are passed by reference only.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法相比，这个方法在效率上略低，因为子 `prototype` 的属性是在执行期间被复制的，而不是简单地通过原型链查找。请注意，这仅适用于包含原始类型的属性。所有对象（包括函数和数组）都不会被复制，因为这些是通过引用传递的。
- en: 'Let''s see an example of using two constructor functions, `Shape()` and `TwoDShape()`.
    The `Shape()` function''s `prototype` object contains a primitive property, `name`,
    and a non-primitive one, the `toString()`method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用两个构造函数 `Shape()` 和 `TwoDShape()` 的一个例子。`Shape()` 函数的 `prototype` 对象包含一个原始属性
    `name` 和一个非原始属性，即 `toString()` 方法：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you inherit with `extend()`, neither the objects created with `TwoDShape()`
    nor its prototype get an own `name` property, but they have access to the one
    they inherit:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `extend()` 继承，使用 `TwoDShape()` 创建的对象及其原型都不会获得自己的 `name` 属性，但它们可以访问它们继承的属性：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, if you inherit with `extend2()`, the prototype of `TwoDShape()`gets
    its own copy of the `name` property. It also gets its own copy of `toString()`,
    but it''s a reference only, so the function will not be recreated a second time:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用 `extend2()` 继承，`TwoDShape()` 的原型会获得 `name` 属性的自己的副本。它也会获得自己的 `toString()`
    副本，但这是一个引用，所以函数不会再次创建：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the two `toString()` methods are the same function object. This
    is good because it means that no unnecessary duplicates of the methods are created.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两个 `toString()` 方法是同一个函数对象。这是好事，因为它意味着不会创建不必要的重复方法。
- en: So, you can say that `extend2()` is less efficient than `extend()` because it
    recreates the properties of the prototype. However, this is not so bad because
    only the primitive data types are duplicated. Additionally, this is beneficial
    during the prototype chain lookups as there are fewer chain links to follow before
    finding the property.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以说 `extend2()` 比起 `extend()` 效率更低，因为它重新创建了原型的属性。然而，这并不那么糟糕，因为只有原始数据类型被复制。此外，这在原型链查找期间是有益的，因为找到属性之前需要遵循的链链接更少。
- en: 'Take a look at the `uber` property again. This time, for a change, it''s set
    on the `Parent` object''s prototype `p`, not on the `Parent` constructor. This
    is why `toString()` uses it as `this.uber` as opposed to `this.constructor.uber`.
    This is just an illustration that you can shape your favorite inheritance pattern
    in any way you see fit. Let''s test it out:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看 `uber` 属性。这次，为了改变一下，它被设置在 `Parent` 对象的原型 `p` 上，而不是在 `Parent` 构造函数上。这就是为什么
    `toString()` 使用 `this.uber` 而不是 `this.constructor.uber` 作为 `this.uber` 的原因。这只是一个说明，你可以以任何你想要的方式塑造你喜欢的继承模式。让我们来测试一下：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`TwoDShape` didn''t redefine the `name` property, hence the repetition. It
    can do that at any time, and (the prototype chain being live) all the instances
    see the update:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwoDShape` 没有重新定义 `name` 属性，因此出现了重复。它可以在任何时候这样做，并且（由于原型链是活跃的）所有实例都会看到更新：'
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Heads-up when copying by reference
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意在通过引用复制时的操作
- en: The fact that objects (including functions and arrays) are copied by reference
    could sometimes lead to results you don't expect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象（包括函数和数组）是通过引用进行复制的，这有时可能会导致你意想不到的结果。
- en: 'Let''s create two constructor functions and add properties to the prototype
    of the first one:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个构造函数，并将属性添加到第一个函数的原型上：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s have `Wee` inherit from `Papa` (either `extend()` or `extend2()`
    will do):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让 `Wee` 从 `Papa` 继承（无论是 `extend()` 还是 `extend2()` 都可以）：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using `extend2()`, the `Wee` function''s prototype inherited the properties
    of `Papa.prototype` as its own:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `extend2()`，`Wee` 函数的原型继承了 `Papa.prototype` 的属性作为它自己的属性：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `name` property is primitive, so a new copy of it is created. The `owns`
    property is an array object, so it''s copied by reference:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 属性是原始类型，因此会创建一个新的副本。`owns` 属性是一个数组对象，所以它是通过引用进行复制的：'
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Changing the `Wee` function''s copy of `name` doesn''t affect `Papa`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `Wee` 函数的 `name` 副本不会影响 `Papa`：
- en: '[PRE40]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Changing the `Wee` function''s `owns` property, however, affects `Papa`, because
    both properties point to the same array in memory:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，修改 `Wee` 函数的 `owns` 属性会影响 `Papa`，因为这两个属性都指向内存中的同一个数组：
- en: '[PRE41]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It''s a different story when you completely overwrite the `Wee` function''s
    copy of `owns` with another object (as opposed to modifying the existing one).
    In this case, `Papa.owns` keeps pointing to the old object, while `Wee.owns` points
    to a new one:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完全覆盖 `Wee` 函数的 `owns` 副本为另一个对象（而不是修改现有的一个）时，情况就不同了。在这种情况下，`Papa.owns` 继续指向旧对象，而
    `Wee.owns` 指向一个新的对象：
- en: '[PRE42]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Think of an object as something that is created and stored in a physical location
    in memory. Variables and properties merely point to this location, so when you
    assign a brand new object to `Wee.prototype.owns`, you essentially say-Hey, forget
    about this other old object, move your pointer to this new one instead.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象想象成在内存中某个物理位置创建和存储的东西。变量和属性仅仅指向这个位置，所以当你将一个全新的对象赋值给 `Wee.prototype.owns`
    时，你本质上是在说——嘿，忘了这个其他旧对象，把你的指针移动到这个新对象上。
- en: 'The following diagram illustrates what happens if you imagine the memory being
    a heap of objects (like a wall of bricks) and you point to (refer to) some of
    these objects:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了如果你想象内存是一个堆叠的对象（就像一堵砖墙）并且你指向（引用）其中的一些对象会发生什么：
- en: A new object is created, and **A** points to it.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个新对象，并且 **A** 指向它。
- en: A new variable **B** is created and made equal to **A**, meaning it now points
    to the same place **A** is pointing to.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个新的变量 **B** 并将其设置为等于 **A**，这意味着它现在指向 **A** 指向的地方。
- en: A property color is changed using the **B** handle (pointer). The brick is now
    white. **A** check for `A.color === "white"` would be true.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **B** 处理器（指针）更改属性颜色。砖现在变白了。对 `A.color === "white"` 的检查将是真实的。
- en: 'A new object is created, and the **B** variable/pointer is recycled to point
    to that new object. **A** and **B** are now pointing to different parts of the
    memory pile. They have nothing in common and changes to one of them don''t affect
    the other:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个新对象，并且将 **B** 变量/指针回收以指向那个新对象。现在 **A** 和 **B** 指向内存堆的不同部分。它们没有任何共同点，对其中一个的更改不会影响另一个：
- en: '![Heads-up when copying by reference](img/image_07_002.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![通过引用复制时的注意事项](img/image_07_002.jpg)'
- en: If you want to address the problem that objects are copied by reference, consider
    a deep copy, described later in the chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要解决对象通过引用复制的问题，可以考虑稍后在章节中描述的深度复制。
- en: Objects inherit from objects
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象继承自对象
- en: All the examples so far in this chapter assume that you create your objects
    with constructor functions, and you want objects created with one constructor
    to inherit properties that come from another constructor. However, you can also
    create objects without the help of a constructor function, just using the object
    literal, and this is, in fact, less typing. So, how about inheriting those?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本章迄今为止的所有示例都假设你使用构造函数创建对象，并且你希望使用一个构造函数创建的对象继承来自另一个构造函数的属性。然而，你也可以不使用构造函数的帮助，仅使用对象字面量来创建对象，这实际上更少打字。那么，如何继承这些属性呢？
- en: 'In Java or PHP, you define classes and have them inherit from other classes.
    That''s why you''ll see the term classical, because the OO functionality comes
    from the use of classes. In JavaScript, there are no classes, so programmers that
    come from a classical background resort to constructor functions, because constructors
    are the closest to what they are used to. In addition, JavaScript provides the
    `new` operator, which can further suggest that JavaScript is like Java. The truth
    is that, in the end, it all comes down to objects. The first example in this chapter
    used this syntax:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 或 PHP 中，你定义类并让它们继承自其他类。这就是为什么你会看到“经典”这个词，因为面向对象的功能来自于类的使用。在 JavaScript
    中，没有类，所以来自经典背景的程序员会求助于构造函数，因为构造函数是他们最熟悉的。此外，JavaScript 提供了 `new` 操作符，这进一步暗示 JavaScript
    类似于 Java。事实是，最终，一切都归结于对象。本章的第一个例子使用了这种语法：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the `Child` constructor (or class, if you will) inherits from `Parent`.
    However, this is done by creating an object using `new Parent()` and inheriting
    from it. That's why this is also referred to as a **pseudo-classical inheritance
    pattern**, because it resembles classical inheritance, although it isn't (no classes
    are involved).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Child` 构造函数（或者如果你愿意，类）从 `Parent` 继承。然而，这是通过使用 `new Parent()` 创建一个对象并从中继承来完成的。这就是为什么这也被称为
    **伪经典继承模式**，因为它类似于经典继承，尽管它不是（没有涉及类）。
- en: So, why not get rid of the middleman (the constructor/class) and just have objects
    inherit from objects? In `extend2()`, the properties of the parent `prototype`
    object were copied as properties of the child `prototype` object. The two prototypes
    are, in essence, just objects. Forgetting about prototypes and constructor functions,
    you can simply take an object and copy all of its properties into another object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么不摆脱中间人（构造函数/类）而直接让对象继承自对象呢？在 `extend2()` 中，父 `prototype` 对象的属性被复制为子 `prototype`
    对象的属性。这两个原型本质上只是对象。忘记原型和构造函数，你可以简单地取一个对象并将其所有属性复制到另一个对象中。
- en: 'You already know that objects can start as a blank canvas without any own properties,
    using `var o = {};`, and then get properties later. However, instead of starting
    fresh, you can start by copying all of the properties of an existing object. Here''s
    a function that does exactly this: it takes an object and returns a new copy of
    it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道对象可以从一个没有任何自身属性的空白画布开始，使用 `var o = {};`，然后后来再添加属性。然而，你不必从头开始，你可以通过复制现有对象的所有属性来开始。这里有一个执行这一操作的确切函数：它接受一个对象并返回它的一个新副本：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Simply copying all the properties is a straightforward pattern, and it''s widely
    used. Let''s see this function in action. You start by having a base object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地复制所有属性是一个直接的模式，并且它被广泛使用。让我们看看这个函数的实际效果。你首先有一个基础对象：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In order to create a new object that builds upon the old one, you can call
    the `extendCopy()` function, which returns a new object. Then, you can augment
    the new object with additional functionality:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个基于旧对象的新对象，你可以调用 `extendCopy()` 函数，它返回一个新的对象。然后，你可以通过添加额外的功能来增强这个新对象：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is a triangle object that inherits the `2D shape` object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个继承自 `2D shape` 对象的三角形对象：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Using the triangle, for example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用三角形：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A possible drawback of this method is the somewhat verbose way of initializing
    the new `triangle` object, where you manually set values for `side` and `height`,
    as opposed to passing them as values to a constructor. However, this is easily
    resolved by having a function, for example, called `init()` (or `__construct()`
    if you come from PHP) that acts as a constructor and accepts initialization parameters.
    Alternatively, have `extendCopy()` accept two parameters, an object to inherit
    from and another object literal of properties to add to the copy before it's returned.
    In other words, just merge two objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的可能缺点是初始化新的 `triangle` 对象的方式有些冗长，你必须手动设置 `side` 和 `height` 的值，而不是将它们作为值传递给构造函数。然而，这可以通过有一个函数来解决，例如，称为
    `init()`（如果你来自 PHP，则称为 `__construct()`），它充当构造函数并接受初始化参数。或者，让 `extendCopy()` 接受两个参数，一个要继承的对象和另一个要在返回之前添加到副本中的对象字面量属性。换句话说，就是合并两个对象。
- en: Deep copy
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深拷贝
- en: The `extendCopy()` function discussed previously creates what is called a shallow
    copy of an object, just like `extend2()` before that. The opposite of a shallow
    copy would be, naturally, a deep copy. As discussed previously (in the *Heads-up
    when copying by reference* section of this chapter), when you copy objects, you
    only copy pointers to the location in memory where the object is stored. This
    is what happens in a shallow copy. If you modify an object in the copy, you also
    modify the original. The deep copy avoids this problem.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的 `extendCopy()` 函数创建了一个浅拷贝的对象，就像之前的 `extend2()`。浅拷贝的相反自然是深拷贝。正如之前所讨论的（在本章的
    *拷贝引用时的注意事项* 部分中），当你复制对象时，你只复制对象存储在内存中的位置的指针。这就是浅拷贝发生的情况。如果你修改了副本中的对象，你也会修改原始对象。深拷贝避免了这个问题。
- en: 'The deep copy is implemented in the same way as the shallow copy-you loop through
    the properties and copy them one by one. However, when you encounter a property
    that points to an object, you call the `deepcopy` function again:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 深拷贝的实现方式与浅拷贝相同——你遍历属性并将它们逐个复制。然而，当你遇到指向对象的属性时，你会再次调用 `deepcopy` 函数：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s create an object that has arrays and a subobject as properties:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有数组和子对象属性的对象：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s test this by creating a deep copy and a shallow copy. Unlike the shallow
    copy, when you update the `numbers` property of a deep copy, the original is not
    affected:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个深拷贝和一个浅拷贝来测试这一点。与浅拷贝不同，当你更新深拷贝的 `numbers` 属性时，原始对象不会受到影响：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Two side notes about the `deepCopy()` function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `deepCopy()` 函数的两个注意事项：
- en: Filtering out non-own properties with `hasOwnProperty()` is always a good idea
    to make sure you don't carry over someone's additions to the core prototypes.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `hasOwnProperty()` 过滤掉非自身属性总是一个好主意，以确保你不会将某人的添加应用到核心原型上。
- en: '`Array.isArray()` exists since ES5 because it''s surprisingly hard otherwise
    to tell real arrays from objects. The best cross-browser solution (if you need
    to define `isArray()` in ES3 browsers) looks a little hacky, but it works:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.isArray()` 自从 ES5 以来就存在，因为否则很难区分真正的数组和对象。如果你需要在 ES3 浏览器中定义 `isArray()`，那么最好的跨浏览器解决方案看起来有点像黑客手段，但它有效：'
- en: '[PRE52]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using object() method
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 object() 方法
- en: 'Based on the idea that objects inherit from objects, Douglas Crockford advocates
    the use of an `object()` function that accepts an object and returns a new one
    that has the parent as a prototype:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对象继承自对象的想法，道格拉斯·克罗克福德提倡使用一个接受对象并返回一个新的具有父对象作为原型的 `object()` 函数：
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you need access to an `uber` property, you can modify the `object()` function
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要访问一个 `uber` 属性，你可以按如下方式修改 `object()` 函数：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Using `this` function is the same as using `extendCopy()`, you take an object
    such as `twoDee`, create a new object from it, and then proceed to augmenting
    the new object:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `this` 函数与使用 `extendCopy()` 函数相同，你从一个对象，例如 `twoDee`，创建一个新的对象，然后继续增强这个新对象：
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The new triangle still behaves the same way:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 新的三角形仍然以相同的方式表现：
- en: '[PRE56]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This pattern is also referred to as **prototypal inheritance**, because you
    use a parent object as the prototype of a child object. It''s also adopted and
    built upon in ES5 and called `Object.create()`. Here is an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式也被称为**原型继承**，因为你可以使用父对象作为子对象的原型。它也被ES5采用并扩展，称为`Object.create()`。以下是一个示例：
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Using a mix of prototypal inheritance and copying properties
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原型继承和复制属性的混合
- en: When you use inheritance, you will most likely want to take an already existing
    functionality and then build upon it. This means creating a new object by inheriting
    from an existing object and then adding additional methods and properties. You
    can do this with one function call using a combination of the last two approaches
    just discussed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用继承时，你很可能会想要使用已经存在的功能，并在其基础上进行扩展。这意味着通过从一个现有对象继承并添加额外的方法和属性来创建一个新的对象。你可以通过一个函数调用，使用前面讨论的最后两种方法的组合来实现这一点。
- en: 'You can:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以：
- en: Use prototypal inheritance to use an existing object as a prototype of a new
    one
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型继承将现有对象作为新对象的原型
- en: 'Copy all the properties of another object into the newly created one:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将另一个对象的全部属性复制到新创建的对象中：
- en: '[PRE58]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This function takes an object `o` to inherit from and another object `stuff`
    that has the additional methods and properties that are to be copied. Let's see
    this in action.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个要继承的对象`o`和另一个具有要复制的额外方法和属性的对象`stuff`。让我们看看它是如何工作的。
- en: 'Start with the base `shape` object:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个基本的`shape`对象开始：
- en: '[PRE59]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a 2D object by inheriting shape and adding more properties. The additional
    properties are simply created with an object literal:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承形状并添加更多属性来创建一个二维对象。额外的属性只是用对象字面量创建的：
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, let''s create a `triangle` object that inherits from 2D and adds more
    properties:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个继承自2D并添加更多属性的`triangle`对象：
- en: '[PRE61]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can test how it all works by creating a concrete triangle `my` with defined
    `side` and `height`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个具有定义的`side`和`height`的具象三角形`my`来测试这一切是如何工作的：
- en: '[PRE62]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The difference here, when executing `toString()`, is that the `Triangle` name
    is repeated twice. That''s because the concrete instance was created by inheriting
    `triangle`, so there was one more level of inheritance. You could give the new
    instance a name:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的不同之处在于，当执行`toString()`时，`Triangle`名称会重复两次。这是因为具体的实例是通过继承`triangle`创建的，所以有另一个继承层级。你可以给这个新实例一个名字：
- en: '[PRE63]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This `objectPlus()` is even closer to ES5's `Object.create();` only the ES5
    one takes the additional properties (the second argument) using something called
    property descriptors (discussed in [Appendix C](apc.html "Appendix C. Built-in
    Objects"), *Built-In Objects*).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`objectPlus()`函数甚至更接近ES5的`Object.create();`，只是ES5的那个使用某种称为属性描述符的东西（在[附录C](apc.html
    "附录 C. 内置对象"), *内置对象*中讨论）来获取额外的属性。
- en: Multiple inheritance
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: Multiple inheritance is where a child inherits from more than one parent. Some
    OO languages support multiple inheritance out of the box and some don't. You can
    argue both ways, that multiple inheritance is convenient or that it's unnecessary,
    complicates application design, and it's better to use an inheritance chain instead.
    Leaving the discussion of multiple inheritance's pros and cons for the long, cold
    winter nights, let's see how you can do it in practice in JavaScript.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承是指一个子对象从多个父对象继承。一些面向对象的语言默认支持多重继承，而另一些则不支持。你可以从两个角度进行争论，即多重继承既方便又没有必要，它会使应用程序设计复杂化，最好使用继承链。关于多重继承的优缺点，我们留待漫长的寒冷冬夜再讨论，现在让我们看看如何在JavaScript中实际操作。
- en: The implementation can be as simple as taking the idea of inheritance by copying
    properties and expanding it so that it takes an unlimited number of input objects
    to inherit from.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以像通过复制属性继承的概念一样简单，只是将其扩展到可以继承无限数量的输入对象。
- en: 'Let''s create a `multi()` function that accepts any number of input objects.
    You can wrap the loop that copies properties in another loop that goes through
    all the objects passed as `arguments` to the function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`multi()`函数，该函数接受任意数量的输入对象。你可以将复制属性的循环包裹在另一个循环中，该循环遍历传递给函数的所有作为`arguments`的对象：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s test this by creating three objects-`shape`, `twoDee`, and a third,
    unnamed object. Then, creating a `triangle` object means calling `multi()` and
    passing all three objects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建三个对象——`shape`、`twoDee`和第三个未命名的对象来测试这一点。然后，创建一个`triangle`对象意味着调用`multi()`并传递所有三个对象：
- en: '[PRE65]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Does this work? Let''s see. The `getArea()` method should be an own property,
    `dimensions` should come from `twoDee`, and `toString()` should come from `shape`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这行得通吗？让我们看看。`getArea()` 方法应该是一个自有属性，`dimensions` 应该来自 `twoDee`，而 `toString()`
    应该来自 `shape`：
- en: '[PRE66]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Bear in mind that `multi()` loops through the input objects in the order they
    appear and if it happens that two of them have the same property, the last one
    wins.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`multi()` 方法按照输入对象出现的顺序遍历它们，如果其中两个对象具有相同的属性，则最后一个获胜。
- en: Mixins
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合
- en: You might come across the term mixin. Think of a mixin as an object that provides
    some useful functionality but is not meant to be inherited and extended by subobjects.
    The approach to multiple inheritance outlined previously can be considered an
    implementation of the mixins idea. When you create a new object, you can pick
    and choose any other objects to mix into your new object. By passing them all
    to `multi()`, you get all their functionality without making them part of the
    inheritance tree.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到术语mixin。将mixin想象成一个提供一些有用功能但不是旨在被子对象继承和扩展的对象。之前概述的多种继承方法可以被认为是mixin想法的实现。当你创建一个新的对象时，你可以挑选并选择任何其他对象将其混合到你的新对象中。通过将它们全部传递给
    `multi()`，你就可以获得它们的所有功能，而无需使它们成为继承树的一部分。
- en: Parasitic inheritance
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄生继承
- en: If you like the fact that you can have all kinds of different ways to implement
    inheritance in JavaScript and you're hungry for more, here's another one. This
    pattern, courtesy of Douglas Crockford, is called parasitic inheritance. It's
    about a function that creates objects by taking all the functionality from another
    object into a new one, augmenting the new object, and returning it, pretending
    that it has done all the work.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢JavaScript中实现继承的多种方式，并且渴望更多，这里还有一个。这个模式，由Douglas Crockford提供，被称为寄生继承。它涉及到一个函数通过将另一个对象的所有功能都带到新对象中，增强新对象，并返回它，假装它已经完成了所有工作。
- en: 'Here''s an ordinary object, defined with an object literal, and unaware of
    the fact that it''s soon going to fall victim to parasitism:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个普通对象，使用对象字面量定义，并且不知道它很快将成为寄生行为的受害者：
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A function that creates `triangle` objects could:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `triangle` 对象的函数可能包括：
- en: Use the `twoD` object as a prototype of an object called that (similar to this
    for convenience). This can be done in any way you saw previously, for example,
    using the `object()` function or copying all the properties.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `twoD` 对象作为名为该（类似于this以方便起见）的对象的原型。这可以通过任何你之前看到的方式完成，例如，使用 `object()` 函数或复制所有属性。
- en: Augment that with more properties.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加更多属性。
- en: 'Return `that`:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `that`：
- en: '[PRE68]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Because `triangle()` is a normal function, not a constructor, it doesn''t require
    the `new` operator. However, because it returns an object, calling it with `new`
    by mistake works too:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `triangle()` 是一个普通函数，而不是构造函数，它不需要 `new` 操作符。然而，因为它返回一个对象，所以错误地使用 `new` 也可以：
- en: '[PRE69]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that `that` is just a name, it doesn't have a special meaning, the way
    `this` does.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`that` 只是一个名字，它没有特殊含义，就像 `this` 一样。
- en: Borrowing a constructor
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用构造函数
- en: One more way of implementing inheritance (the last one in the chapter, I promise)
    has to do again with constructor functions and not the objects directly. In this
    pattern, the constructor of the child calls the constructor of the parent using
    either the `call()` or `apply()` method. This can be called **stealing a constructor**
    or **inheritance by borrowing a constructor** if you want to be more subtle about
    it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实现继承的另一种方式（章节中的最后一个，我保证）再次与构造函数有关，而不是直接与对象有关。在这个模式中，子构造函数使用 `call()` 或 `apply()`
    方法调用父构造函数。如果你想更微妙一些，这可以被称为**偷取构造函数**或**通过借用构造函数进行继承**。
- en: The `call()` and `apply()` methods were discussed in [Chapter 4](ch04.html "Chapter 4. Objects"),
    *Objects*, but here's a refresher; they allow you to call a function and pass
    an object that the function should bind to its `this` value. So for inheritance
    purposes, the child constructor calls the parent's constructor and binds the child's
    newly created `this` object as the parent's `this`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。对象") *对象* 中讨论了 `call()` 和 `apply()` 方法，但这里是一个复习；它们允许你调用一个函数并传递一个对象，该对象应该绑定到函数的
    `this` 值。因此，为了继承的目的，子构造函数调用父构造函数并将新创建的子 `this` 对象绑定到父的 `this`。
- en: 'Let''s have this parent constructor `Shape()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们有一个这个父构造函数 `Shape()`：
- en: '[PRE70]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, let''s define `Triangle()`, which uses `apply()` to call the `Shape()`
    constructor, passing `this` (an instance created with `new Triangle()`) and any
    additional arguments:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义 `Triangle()`，它使用 `apply()` 来调用 `Shape()` 构造函数，传递 `this`（使用 `new Triangle()`
    创建的实例）和任何额外的参数：
- en: '[PRE71]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that both `Triangle()` and `Shape()`have added some extra properties to
    their prototypes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Triangle()` 和 `Shape()` 都已经向它们的原型添加了一些额外的属性。
- en: 'Now, let''s test this by creating a new `triangle` object:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一个新的 `triangle` 对象来测试：
- en: '[PRE72]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The new `triangle` object inherits the `id` property from the parent, but it
    doesn''t inherit anything added to the parent''s `prototype`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `triangle` 对象从父类继承了 `id` 属性，但它没有继承添加到父类 `prototype` 中的任何内容：
- en: '[PRE73]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The triangle failed to get the `Shape` function''s prototype properties because
    there was never a `new Shape()` instance created, so the prototype was never used.
    However, you saw how to do this at the beginning of this chapter. You can redefine
    `Triangle` as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形未能获取 `Shape` 函数的原型属性，因为没有创建 `new Shape()` 实例，所以原型从未被使用。然而，你已经在本章的开头看到了如何做到这一点。你可以如下重新定义
    `Triangle`：
- en: '[PRE74]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this inheritance pattern, the parent's own properties are recreated as the
    child's own properties. If a child inherits an array or other object, it's a completely
    new value (not a reference), and modifying it won't affect the parent.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种继承模式中，父类的自有属性被重新创建为子类的自有属性。如果一个子类继承了一个数组或其他对象，它将是一个全新的值（而不是引用），修改它不会影响父类。
- en: 'The drawback is that the parent''s constructor gets called twice-once with
    `apply()` to inherit own properties and once with `new` to inherit the prototype.
    In fact, the own properties of the parent are inherited twice. Let''s take this
    simplified scenario:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是父构造函数被调用了两次——一次是使用 `apply()` 来继承自有属性，一次是使用 `new` 来继承原型。实际上，父类的自有属性被继承了两次。让我们考虑这个简化的场景：
- en: '[PRE75]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here, we will create a new instance:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将创建一个新的实例：
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'There''s an own property `id,` but there''s also one that comes down the prototype
    chain, ready to shine through:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个自有属性 `id`，但还有一个从原型链下来的属性，准备闪耀：
- en: '[PRE77]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Borrowing a constructor and copying its prototype
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 借用一个构造函数并复制其原型
- en: 'The problem of the double work performed by calling the constructor twice can
    easily be corrected. You can call `apply()` on the parent constructor to get all
    own properties and then copy the prototype''s properties using a simple iteration
    (or `extend2()` as discussed previously):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 调用构造函数两次导致的双重工作问题可以很容易地纠正。你可以在父构造函数上调用 `apply()` 来获取所有自有属性，然后通过简单的迭代（或之前讨论过的
    `extend2()`）来复制原型属性：
- en: '[PRE78]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Lets test the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试以下代码：
- en: '[PRE79]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'No double inheritance:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 没有双重继承：
- en: '[PRE80]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `extend2()` method also gives access to `uber` if needed:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend2()` 方法也提供了访问 `uber` 的权限，如果需要的话：'
- en: '[PRE81]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Case study - drawing shapes
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 - 绘制形状
- en: Let's finish off this chapter with a more practical example of using inheritance.
    The task is to be able to calculate the area and the perimeter of different shapes,
    as well as to draw them, while reusing as much code as possible.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个更实际的例子来结束这一章，这个例子展示了如何使用继承。任务是能够计算不同形状的面积和周长，同时尽可能重用代码。
- en: Analysis
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析
- en: Let's have one `Shape` constructor that contains all the common parts. From
    there, let's have `Triangle`, `Rectangle`, and `Square` constructors, all inheriting
    from `Shape`. A square is really a rectangle with the same length sides, so let's
    reuse `Rectangle` when building `Square`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们有一个包含所有公共部分的 `Shape` 构造函数。然后，让我们有 `Triangle`、`Rectangle` 和 `Square` 构造函数，它们都从
    `Shape` 继承。一个正方形实际上是一个具有相同长度边的矩形，所以当构建 `Square` 时我们可以重用 `Rectangle`。
- en: In order to define a shape, you'll need points with `x` and `y` coordinates.
    A generic shape can have any number of points. A triangle is defined with three
    points, a rectangle (to keep it simpler) with one point and the lengths of the
    sides. The perimeter of any shape is the sum of its side's lengths. Calculating
    the area is shape specific and will be implemented by each shape.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义一个形状，你需要具有 `x` 和 `y` 坐标的点。一个通用的形状可以具有任意数量的点。三角形由三个点定义，为了简化，矩形只有一个点和边的长度。任何形状的周长是其边长的总和。计算面积是形状特定的，将由每个形状实现。
- en: 'The common functionality in `Shape` would be:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape` 中的共同功能会是：'
- en: A `draw()` method that can draw any shape given the points
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以给定点绘制任何形状的 `draw()` 方法
- en: A `getParameter()` method
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `getParameter()` 方法
- en: A property that contains an array of `points`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 `points` 数组的属性
- en: Other methods and properties as needed
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要添加其他方法和属性
- en: For the drawing part, let's use a `<canvas>` tag. It's not supported in early
    IEs, but hey, this is just an exercise.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绘图部分，让我们使用一个`<canvas>`标签。它不支持早期的IE，但嘿，这只是一个练习。
- en: Let's have two other helper constructors-`Point` and `Line`. `Point` will help
    when defining shapes. `Line` will make calculations easier, as it can give the
    length of the line connecting any two given points.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们有两个其他辅助构造函数——`Point`和`Line`。`Point`在定义形状时会有所帮助。`Line`将使计算更容易，因为它可以给出连接任意两个给定点的线的长度。
- en: You can play with a working example at [http://www.phpied.com/files/canvas/](http://www.phpied.com/files/canvas/).
    Just open your console and start creating new shapes as you'll see in a moment.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://www.phpied.com/files/canvas/](http://www.phpied.com/files/canvas/)上玩一个可工作的示例。只需打开你的控制台，然后像你一会儿看到的那样创建新的形状。
- en: Implementation
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Let''s start by adding a `canvas` tag to a blank HTML page:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向空白HTML页面添加一个`canvas`标签开始：
- en: '[PRE82]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then, put the JavaScript code inside `<script>` tags:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将JavaScript代码放在`<script>`标签内：
- en: '[PRE83]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, let''s take a look at what''s in the JavaScript part. First is the helper
    `Point` constructor. It just can''t get any simpler than the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看JavaScript部分的内容。首先是辅助`Point`构造函数。它不能比以下更简单了：
- en: '[PRE84]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Bear in mind that the coordinates of the points on the `canvas` start from
    `x=0`, `y=0`, which is the top left. The bottom right will be `x = 800`, `y =
    600`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`canvas`上点的坐标从`x=0`，`y=0`开始，这是左上角。右下角将是`x = 800`，`y = 600`：
- en: '![Implementation](img/image_07_003.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/image_07_003.jpg)'
- en: 'Next comes the `Line` constructor. It takes two points and calculates the length
    of the line between them, using the Pythagorean theorem *a² + b² = c²* (imagine
    a right-angled triangle where the hypotenuse connects the two given points):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Line`构造函数。它接受两个点，并使用勾股定理计算它们之间的线长（想象一个直角三角形，其中斜边连接两个给定的点）：*a² + b² = c²*（想象一个直角三角形，其中斜边连接两个给定的点）：
- en: '[PRE85]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Next comes the `Shape` constructor. The shapes will have their points (and
    the lines that connect them) as own properties. The constructor also invokes an
    initialization method, `init()`, that will be defined in the prototype:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Shape`构造函数。形状将拥有它们自己的点（以及连接它们的线）作为自己的属性。构造函数还调用一个初始化方法`init()`，该方法将在原型中定义：
- en: '[PRE86]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, the big part-the methods of `Shape.prototype`. Let''s define all these
    methods using the object literal notation. Refer to the comments for guidelines
    as to what each method does:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重要的部分——`Shape.prototype`的方法。让我们使用对象字面量表示法定义所有这些方法。请参考注释以了解每个方法的作用：
- en: '[PRE87]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, the children constructor functions. `Triangle` comes first:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是子构造函数。`Triangle`首先：
- en: '[PRE88]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `Triangle` constructor takes three point objects and assigns them to `this.points`
    (its own collection of points). Then, it implements the `getArea()` method, using
    Heron''s formula:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triangle`构造函数接受三个点对象并将它们分配给`this.points`（它自己的点集合）。然后，它实现`getArea()`方法，使用海伦公式：'
- en: '[PRE89]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`s` is the semi-perimeter (perimeter divided by two).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`s`是半周长（周长除以二）。'
- en: 'Next comes the `Rectangle` constructor. It receives one point (the upper-left
    point) and the lengths of the two sides. Then, it populates its `points` array
    starting from that one point:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Rectangle`构造函数。它接收一个点（左上角点）和两条边的长度。然后，它从那个点开始填充其`points`数组：
- en: '[PRE90]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The last child constructor is `Square`. A square is a special case of a rectangle,
    so it makes sense to reuse `Rectangle`. The easiest thing to do here is to borrow
    the constructor:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个子构造函数是`Square`。正方形是矩形的特殊情况，因此重用`Rectangle`是有意义的。这里最简单的事情是借用构造函数：
- en: '[PRE91]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now that all constructors are done, let''s take care of inheritance. Any pseudo-classical
    pattern (one that works with constructors as opposed to objects) will do. Let''s
    try using a modified and simplified version of the prototype-chaining pattern
    (the first method described in this chapter). This pattern calls for creating
    a new instance of the parent and setting it as the child''s prototype. In this
    case, it''s not necessary to have a new instance for each child-they can all share
    it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有构造函数都已完成，让我们来处理继承。任何伪经典模式（与构造函数一起工作而不是与对象一起工作）都可以。让我们尝试使用原型链模式（本章中描述的第一个方法）的修改和简化版本。这个模式要求创建一个父类的新实例并将其设置为子类的原型。在这种情况下，对于每个子类不需要有一个新实例——它们都可以共享它：
- en: '[PRE92]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Testing
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'Let''s test this by drawing shapes. First, define three points for a triangle:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过绘制形状来测试这个。首先，定义一个三角形的三个点：
- en: '[PRE93]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now you can create a triangle by passing the three points to the `Triangle`
    constructor:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将三个点传递给`Triangle`构造函数来创建一个三角形：
- en: '[PRE94]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You can call the methods to draw the triangle on the `canvas` and get its area
    and perimeter:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用方法在 `canvas` 上绘制三角形，并获取其面积和周长：
- en: '[PRE95]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now let''s play with a rectangle instance:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们玩一个矩形实例：
- en: '[PRE96]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And finally, let''s play with a square:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们玩一个正方形的例子：
- en: '[PRE97]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'It''s fun to draw these shapes. You can also be as lazy as the following example,
    which draws another square, reusing a triangle''s point:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制这些形状很有趣。你也可以像以下示例一样懒惰，它绘制了另一个正方形，重用了三角形的顶点：
- en: '[PRE98]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The result of the tests will be something like the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的结果将类似于以下内容：
- en: '![Testing](img/image_07_004.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![测试](img/image_07_004.jpg)'
- en: Exercises
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Lets do the following exercise:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做以下练习：
- en: 'Implement multiple inheritance but with a prototypal inheritance pattern, not
    property copying. Here is an example:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现多重继承，但使用原型继承模式，而不是属性复制。以下是一个示例：
- en: '[PRE99]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `additional` property should be an own property; all the rest should be
    mixed into the prototype.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`additional` 属性应该是一个自身属性；其余的都应该混合到原型中。'
- en: 'Use the `canvas` example to practice. Try out different things. Here are some
    examples:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `canvas` 示例进行练习。尝试不同的事情。以下是一些示例：
- en: Draw a few triangles, squares, and rectangles.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制几个三角形、正方形和矩形。
- en: Add constructors for more shapes, such as `Trapezoid`, `Rhombus`, `Kite`, and
    `Pentagon`. If you want to learn more about the `canvas` tag, create a `Circle`
    constructor too. It will need to overwrite the `draw()` method of the parent.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为更多形状添加构造函数，例如 `Trapezoid`、`Rhombus`、`Kite` 和 `Pentagon`。如果你想了解更多关于 `canvas`
    标签的信息，也可以创建一个 `Circle` 构造函数。它需要覆盖父对象的 `draw()` 方法。
- en: Can you think of another way to approach the problem and use another type of
    inheritance?
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能想到另一种解决问题的方法并使用另一种类型的继承吗？
- en: Pick one of the methods that uses `uber` as a way for a child to access its
    parent. Add functionality where the parents can keep track of who their children
    are, perhaps using a property that contains a `children` array?
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一种使用 `uber` 作为子对象访问其父对象的方法。添加功能，让父对象能够跟踪其子对象，可能使用一个包含 `children` 数组的属性？
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned quite a few ways (patterns) of implementing inheritance,
    and the following table summarizes them. The different types can roughly be divided
    into the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了相当多的实现继承的方法（模式），以下表格总结了它们。不同类型可以大致分为以下几类：
- en: Patterns that work with constructors
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与构造函数一起工作的模式
- en: Patterns that work with objects
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象一起工作的模式
- en: 'You can also classify the patterns based on whether they:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以根据它们是否：
- en: Use the prototype
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型
- en: Copy properties
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: 'Do both (copy properties of the prototype):'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 都做（复制原型的属性）：
- en: '| **#** | **Name** | **Example** | **Classification** | **Notes** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **#** | **名称** | **示例** | **分类** | **注意** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | Prototype chaining(pseudo-classical) |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 原型链（伪经典） |'
- en: '[PRE100]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '|'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与构造函数一起工作
- en: Uses the prototype chain
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The default mechanism
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认机制
- en: Tip - move all properties/methods that are meant to be reused to the prototype,
    and add the non-reusable as own properties
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小贴士 - 将所有打算重用的属性/方法移动到原型中，并将不可重用的添加为自身属性
- en: '|'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 2 | Inherit only the prototype |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 仅继承原型 |'
- en: '[PRE101]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '|'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与构造函数一起工作
- en: Copies the prototype (no prototype chain, as all share the same prototype object)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制原型（没有原型链，因为它们共享同一个原型对象）
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: More efficient; no new instances are created just for the sake of inheritance
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高效；无需仅为了继承而创建新实例
- en: Prototype chain lookup during runtime; it is fast, since there's no chain
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时原型链查找；因为它没有链，所以速度快
- en: 'Drawback: children can modify parents'' functionality'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：子对象可以修改父对象的功能
- en: '|'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 3 | Temporary constructor |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 临时构造函数 |'
- en: '[PRE102]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '|'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与构造函数一起工作
- en: Uses the prototype chain
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Unlike #1, it only inherits properties of the prototype; own properties (created
    with this inside the constructor) are not inherited.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '与 #1 不同，它只继承原型的属性；自身属性（在构造函数中使用 `this` 创建的）不继承。'
- en: Provides convenient access to the parent (through `uber`)
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `uber` 提供方便的父对象访问
- en: '|'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 4 | Copying the `prototype` properties |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 复制 `prototype` 属性 |'
- en: '[PRE103]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '|'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与构造函数一起工作
- en: Copies properties
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: Uses the prototype chain
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: All properties of the parent prototype become properties of the child prototype
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父原型中的所有属性都成为子原型的属性
- en: No need to create a new object only for inheritance purposes
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需仅为了继承目的而创建新对象
- en: Shorter prototype chains
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较短的原型链
- en: '|'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 5 | Copy all properties(shallow copy) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 复制所有属性（浅复制） |'
- en: '[PRE104]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '|'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象一起工作
- en: Copies properties
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Simple
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单
- en: Doesn't use prototypes
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用原型
- en: '|'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 6 | Deep copy | Same as the previous one, but recurse into objects |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 深度复制 | 与上一个相同，但递归到对象中 |'
- en: Works with objects
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象一起工作
- en: Copies properties
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Same as #5, but clones objects and arrays'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '与 #5 相同，但克隆对象和数组'
- en: '|'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 7 | Prototypal inheritance |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 原型继承 |'
- en: '[PRE105]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '|'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象一起工作
- en: Uses the prototype chain
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: No pseudo-classes, objects inherit from objects
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有伪类，对象继承自对象
- en: Leverages the benefits of the prototype
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用原型的优势
- en: '|'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 8 | Extend and augment |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 扩展和增强 |'
- en: '[PRE106]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象一起工作
- en: Uses the prototype chain
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: Copies properties
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Mix of prototypal inheritance (#7) and copying properties (#5)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型继承（#7）和复制属性（#5）的混合
- en: One function call to inherit and extend at the same time
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数调用即可同时继承和扩展
- en: '|'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 9 | Multiple inheritance |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 多重继承 |'
- en: '[PRE107]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '|'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象一起工作
- en: Copies properties
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A mixin-style implementation
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合式实现
- en: Copies all the properties of all the parent objects in the order of appearance
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按出现顺序复制所有父对象的属性
- en: '|'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 10 | Parasitic inheritance |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 寄生继承 |'
- en: '[PRE108]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '|'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with objects
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象一起工作
- en: Uses the prototype chain
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: '|'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Constructor-like function creates objects
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似构造函数的函数创建对象
- en: Copies an object, and augments and returns the copy
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制一个对象，并增强并返回副本
- en: '|'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 11 | Borrowing constructors |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 借用构造函数 |'
- en: '[PRE109]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '|'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与构造函数一起工作
- en: '|'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Inherits only own properties
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只继承自己的属性
- en: 'Can be combined with #1 to inherit the prototype too'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '可以与 #1 结合以继承原型'
- en: Convenient way to deal with the issues when a child inherits a property that
    is an object (and therefore, passed by reference)
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当子类继承一个属性是对象（因此，通过引用传递）时处理问题的便捷方式
- en: '|'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 12 | Borrow a constructor and copy the prototype |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 借用构造函数并复制原型 |'
- en: '[PRE110]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '|'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Works with constructors
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与构造函数一起工作
- en: Uses the prototype chain
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原型链
- en: Copies properties
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制属性
- en: '|'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Combination of #11 and #4'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '#11 和 #4 的组合'
- en: Allows you to inherit both own properties and prototype properties without calling
    the parent constructor twice
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您在不调用父构造函数两次的情况下继承自己的属性和原型属性
- en: '|'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Given so many options, you must be wondering which is the right one. That depends
    on your style and preferences, your project, task, and team. Are you more comfortable
    thinking in terms of classes? Then pick one of the methods that work with constructors.
    Are you going to need just one or a few instances of your class? Then choose an
    object-based pattern.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如此多的选项，您可能想知道哪个是正确的。这取决于您的风格和偏好，您的项目、任务和团队。您是否更习惯于用类来思考？那么请选择一种与构造函数一起工作的方法。您是否只需要您类的单个或少数几个实例？那么请选择基于对象的模式。
- en: Are these the only ways of implementing inheritance? No. You can choose a pattern
    from the preceding table, you can mix them, or you can think of your own. The
    important thing is to understand and be comfortable with objects, prototypes,
    and constructors; the rest is just pure joy.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是实现继承的唯一方法吗？不。您可以从前面的表中选择一个模式，混合它们，或者您可以自己思考。重要的是要理解和熟悉对象、原型和构造函数；其余的都是纯粹的乐趣。
