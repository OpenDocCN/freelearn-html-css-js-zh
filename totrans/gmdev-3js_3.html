<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Exploring and Interacting"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Exploring and Interacting</h1></div></div></div><p>This chapter explains how users can interact with our games. We'll also cover some physics and use what we've learned to create a basic first-person shooter game.</p><div class="section" title="Keyboard movement and mouse looking"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Keyboard movement and mouse looking</h1></div></div></div><p>In order to move our camera around,<a class="indexterm" id="id241"/> we're going to encapsulate some state, so let's define a <code class="literal">KeyboardControls</code> class<a class="indexterm" id="id242"/> in a new JavaScript file:</p><div class="informalexample"><pre class="programlisting">function KeyboardControls(object, options) {
  this.object = object;
  options = options || {};
  this.domElement = options.domElement || document;
  this.moveSpeed = options.moveSpeed || 1;

  this.domElement.addEventListener('keydown', this.onKeyDown.bind(this), false);
  this.domElement.addEventListener('keyup', this.onKeyUp.bind(this), false);
}

KeyboardControls.prototype = {
  update: function() {
    if (this.moveForward)  this.object.translateZ(-this.moveSpeed);
    if (this.moveBackward) this.object.translateZ( this.moveSpeed);
    if (this.moveLeft)     this.object.translateX(-this.moveSpeed);
    if (this.moveRight)    this.object.translateX( this.moveSpeed);
  },
  onKeyDown: function (event) {
    switch (event.keyCode) {
      case 38: /*up*/
      case 87: /*W*/ this.moveForward = true; break;

      case 37: /*left*/
      case 65: /*A*/ this.moveLeft = true; break;

      case 40: /*down*/
      case 83: /*S*/ this.moveBackward = true; break;

      case 39: /*right*/
      case 68: /*D*/ this.moveRight = true; break;
    }
  },
  onKeyUp: function (event) {
    switch(event.keyCode) {
      case 38: /*up*/
      case 87: /*W*/ this.moveForward = false; break;

      case 37: /*left*/
      case 65: /*A*/ this.moveLeft = false; break;

      case 40: /*down*/
      case 83: /*S*/ this.moveBackward = false; break;

      case 39: /*right*/
      case 68: /*D*/ this.moveRight = false; break;
    }
  }
};</pre></div><p>In the constructor, we added listeners for the <code class="literal">keydown</code> event<a class="indexterm" id="id243"/> and the <code class="literal">keyup</code> event<a class="indexterm" id="id244"/> so that when a key is pressed, we can keep track of the direction in which we should move. (In JavaScript, pressed keys are identified by numeric key codes.) In our <code class="literal">update</code> method<a class="indexterm" id="id245"/>, we just move in the specified direction. This is accomplished by checking flags that we set during key events so that we can poll<a class="indexterm" id="id246"/> the keyboard state during each frame. We can then use the controller by declaring it with <code class="literal">new</code> <code class="literal">KeyboardControls(camera)</code> and make it affect the camera in every frame by calling <code class="literal">controls.update(delta)</code> in our animation loop.</p><p>If you've ever written event-driven JavaScript before, most of this should look pretty familiar, and it's not hard to see how this could be extended in different ways to support different control mechanisms. Luckily, most applications are controlled pretty similarly, so Three.js provides a number of default control handlers that take care of most of this for you. These controllers are located in <code class="literal">examples/js/controls</code> and not in the main library, so you need to make sure to include them separately in your HTML file if you want to use them. Feel free to copy and extend an existing controller if you want a slightly different behavior,<a class="indexterm" id="id247"/> rather than writing your own controller from <a class="indexterm" id="id248"/>scratch every time.</p><p>The available controllers are:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Constructor</p>
</th><th style="text-align: left" valign="bottom">
<p>Important properties</p>
</th><th style="text-align: left" valign="bottom">
<p>Explanation</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">FirstPersonControls</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">movementSpeed = 1.0</code></p>
<p><code class="literal">lookSpeed = 0.005</code></p>
<p><code class="literal">constrainVertical = false</code></p>
<p><code class="literal">freeze = false</code></p>
</td><td style="text-align: left" valign="top">
<p>Keyboard <a class="indexterm" id="id249"/>movement (<span class="emphasis"><em>WASD</em></span> or arrow keys for forward/back/strafe; up/down<a class="indexterm" id="id250"/> with <span class="emphasis"><em>R</em></span> or <span class="emphasis"><em>F</em></span>) and look around by following the mouse.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">FlyControls</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">movementSpeed = 1.0</code></p>
<p><code class="literal">rollSpeed = 0.005</code></p>
</td><td style="text-align: left" valign="top">
<p>Press<a class="indexterm" id="id251"/> keys<a class="indexterm" id="id252"/> to move (<span class="emphasis"><em>WASD</em></span>), tilt (<span class="emphasis"><em>QE</em></span>), and look around (up/down/left/right).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">OculusControls</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">freeze = false</code></p>
</td><td style="text-align: left" valign="top">
<p>Use<a class="indexterm" id="id253"/> the<a class="indexterm" id="id254"/> Oculus Rift virtual reality headset.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">OrbitControls</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">enabled = true</code></p>
<p><code class="literal">target = new THREE.Vector3()</code></p>
<p><code class="literal">zoomSpeed = 1.0</code></p>
<p><code class="literal">minDistance = 0</code></p>
<p><code class="literal">maxDistance = Infinity</code></p>
<p><code class="literal">rotateSpeed = 1.0</code></p>
<p><code class="literal">keyPanSpeed = 7.0</code></p>
<p><code class="literal">autoRotateSpeed = 2.0</code></p>
</td><td style="text-align: left" valign="top">
<p>Rotate, <a class="indexterm" id="id255"/>pan, and zoom with mouse or touch <a class="indexterm" id="id256"/>controls, maintaining the <span class="emphasis"><em>up</em></span> direction along the positive y axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">PathControls</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">duration = 10000</code></p>
<p><code class="literal">waypoints = []</code></p>
<p><code class="literal">lookSpeed = 0.005</code></p>
<p><code class="literal">lookVertical = true</code></p>
<p><code class="literal">lookHorizontal = true</code></p>
</td><td style="text-align: left" valign="top">
<p>Move<a class="indexterm" id="id257"/> along<a class="indexterm" id="id258"/> a predefined route and look around by following the mouse.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">PointerLockControls</code></p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>Keyboard<a class="indexterm" id="id259"/> movement (<span class="emphasis"><em>WASD</em></span> or arrow<a class="indexterm" id="id260"/> keys for forward/back/strafe/jump) and look around by locking to the mouse. Requires that the canvas is in pointer lock mode.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">TrackballControls</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">enabled = true</code></p>
<p><code class="literal">rotateSpeed = 1.0</code></p>
<p><code class="literal">zoomSpeed = 1.2</code></p>
<p><code class="literal">panSpeed = 0.3</code></p>
<p><code class="literal">minDistance = 0</code></p>
<p><code class="literal">maxDistance = Infinity</code></p>
</td><td style="text-align: left" valign="top">
<p>Rotate,<a class="indexterm" id="id261"/> pan, <a class="indexterm" id="id262"/>zoom, and tilt with mouse or touch controls.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">TransformControls</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">size = 1</code></p>
</td><td style="text-align: left" valign="top">
<p>Creates<a class="indexterm" id="id263"/> a widget around an<a class="indexterm" id="id264"/> object that allows users to rotate, scale, and translate it. Mainly used in an editor.</p>
</td></tr></tbody></table></div><p>All the <code class="literal">controller</code> constructors<a class="indexterm" id="id265"/> take <code class="literal">camera</code> <a class="indexterm" id="id266"/>as their first parameter.</p><p>Let's add the <code class="literal">FirstPersonControls</code> controller to our city example from the last chapter and try flying around to see the city from the streets. First, we need to add the JavaScript file:</p><div class="informalexample"><pre class="programlisting">&lt;script src="FirstPersonControls.js"&gt;&lt;/script&gt;</pre></div><p>Then, we'll add some globals:</p><div class="informalexample"><pre class="programlisting">var controls, clock;</pre></div><p>Next, we'll instantiate the <code class="literal">controls</code> variable<a class="indexterm" id="id267"/> and the <code class="literal">clock</code> variable<a class="indexterm" id="id268"/> in<a class="indexterm" id="id269"/> <code class="literal">setupThreeJS()</code>:</p><div class="informalexample"><pre class="programlisting">clock = new THREE.Clock();
controls = new THREE.FirstPersonControls(camera);
controls.movementSpeed = 100;
controls.lookSpeed = 0.1;</pre></div><p>A <code class="literal">clock</code> is a timer. We'll use<a class="indexterm" id="id270"/> it in this case to keep track of the amount of time that passes between each frame we draw. Also note that we changed the speed at which the camera moves and looks; otherwise, it feels very sluggish.</p><p>Finally, we'll change our animation loop in the <code class="literal">setup()</code> function<a class="indexterm" id="id271"/> to update our controller:</p><div class="informalexample"><pre class="programlisting">requestAnimationFrame(function animate() {
  renderer.render(scene, camera);
<span class="strong"><strong>  controls.update(clock.getDelta());</strong></span>
  requestAnimationFrame(animate);
});</pre></div><p>Updating the controls allows the camera to move when each frame is rendered. The clock's <code class="literal">getDelta</code> method<a class="indexterm" id="id272"/> returns the amount of time in seconds since the last time the <code class="literal">getDelta</code> method was called, so in this case it returns the number of seconds since the last frame was rendered. Internally, the controls use that delta to make sure that the<a class="indexterm" id="id273"/> animation is smooth over time. Now we can fly around our city!</p><p>You can see in the following screenshot what the city might look like from the ground:</p><div class="mediaobject"><img alt="Keyboard movement and mouse looking" src="graphics/8539OS_03_01.jpg"/><div class="caption"><p>Flying around the city</p></div></div></div></div>
<div class="section" title="Clicking"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Clicking</h1></div></div></div><p>Clicking on the screen<a class="indexterm" id="id274"/> in order to select or interact with something is a common requirement, but it's somewhat harder than it sounds because of the need to project the location of the click in the 2D plane of your screen into the 3D world of Three.js. To do this, we draw an imaginary line, called a ray, from the camera toward the position where the mouse might be in 3D space and see if it intersects with anything.</p><p>In order to project, we first need a projector:</p><div class="informalexample"><pre class="programlisting">projector = new THREE.Projector();</pre></div><p>Then we need to register a listener on the<a class="indexterm" id="id275"/> click event for the canvas:</p><div class="informalexample"><pre class="programlisting">renderer.domElement.addEventListener('mousedown', function(event) {
  var vector = new THREE.Vector3(
     renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
    -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,
    0
    );
  projector.unprojectVector(vector, camera);

  var raycaster = new THREE.Raycaster(
    camera.position,
    vector.sub(camera.position).normalize()
  );
  var intersects = raycaster.intersectObjects(OBJECTS);
  if (intersects.length) {
    // intersects[0] describes the clicked object
  }
}, false);</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>The previous code assumes that you are using the <code class="literal">PerspectiveCamera</code> class<a class="indexterm" id="id276"/>. If you are using the <code class="literal">OrthographicCamera</code> class<a class="indexterm" id="id277"/>, projectors have a utility method that returns an appropriate raycaster, and you do not have to un-project the vector first:</p><div class="informalexample"><pre class="programlisting">var raycaster = projector.pickingRay(vector, camera);</pre></div></div></div><p>The previous code listens to the <code class="literal">mousedown</code> event<a class="indexterm" id="id278"/> on the renderer's canvas. Then, it creates a new <code class="literal">Vector3</code> instance<a class="indexterm" id="id279"/> with the mouse's coordinates on the screen relative to the center of the canvas as a percent of the canvas width. That vector is then un-projected (from 2D into 3D space) relative to the camera.</p><p>Once we have the point in 3D space representing the mouse's location, we draw a line to it using the <code class="literal">Raycaster</code>. The two arguments that it receives are the starting point and the direction to the ending point. We determine the direction by subtracting the mouse and camera positions and then normalizing the result, which divides each dimension by the length of the vector to scale it so that no dimension has a value greater than <code class="literal">1</code>. Finally, we use the ray to check which objects are located in the given direction (that is, under the mouse) with the <code class="literal">intersectObjects</code> method<a class="indexterm" id="id280"/>. <code class="literal">OBJECTS</code> <a class="indexterm" id="id281"/>is an array of objects (generally meshes) to check; be sure to change it appropriately for your code. An array of objects that are behind the mouse are returned and sorted by distance, so the first result is the object that was clicked.</p><p>Each object in the <code class="literal">intersects</code> array<a class="indexterm" id="id282"/> has an <code class="literal">object</code>,<a class="indexterm" id="id283"/> <code class="literal">point</code>,<a class="indexterm" id="id284"/> <code class="literal">face</code>,<a class="indexterm" id="id285"/> and <code class="literal">distance</code> property<a class="indexterm" id="id286"/>. Respectively, the values of these properties are the clicked object (generally a <code class="literal">Mesh</code>), a <code class="literal">Vector3</code> instance representing the clicked location in space, the <code class="literal">Face3</code> instance at the clicked location, and the distance from the camera to the clicked point.</p><p>It's also possible to go in reverse (3D to 2D) by projecting instead of un-projecting:</p><div class="informalexample"><pre class="programlisting">var widthHalf  = 0.5 * renderer.domElement.width  / renderer.devicePixelRatio,
  heightHalf = 0.5 * renderer.domElement.height / renderer.devicePixelRatio;

var vector = mesh.position.clone(); // or an arbitrary point
projector.projectVector(vector, camera);

vector.x =  vector.x * widthHalf  + widthHalf;
vector.y = -vector.y * heightHalf + heightHalf;</pre></div><p>After this code runs, <code class="literal">vector.x</code> and <code class="literal">vector.y</code> will hold the horizontal and vertical coordinates of the specified point relative to the upper-left corner of the canvas. (Make sure you actually specify the point you want, instead of using <code class="literal">mesh.position.clone()</code>,<a class="indexterm" id="id287"/> and that you've instantiated your <code class="literal">projector</code>.) Note that the resulting coordinates might not be over the canvas if the original 3D point is not on the screen.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>The last thing you want when your player is clicking madly to shoot at enemies is for the whole screen to suddenly turn blue because the browser thinks the user is trying to select something. To avoid this, you can either cancel the <code class="literal">select</code> event in JavaScript with <code class="literal">document.onselectstart = function() { return false; }</code> or disable it in CSS:</p><div class="informalexample"><pre class="programlisting">* {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}</pre></div></div></div></div>
<div class="section" title="Timing"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Timing</h1></div></div></div><p>As we start building more<a class="indexterm" id="id288"/> realistic examples, you'll notice delta parameters being passed around to functions that affect physics. Those deltas represent an amount of time since the last time physics was calculated, and they're used to smooth out movement over time.</p><p>The naive way to move objects in code is to simply change the object's position. For example, to move an object across the canvas, you might write <code class="literal">obj.x += 10</code> inside your animation loop to move it 10 units every frame. This approach suffers from the issue that it is dependent on the frame rate. In other words, if your game is running slowly (that is, fewer frames per second), your object will also appear to move slowly, whereas if your game is running quickly (that is, more frames per second), your object will appear to move quickly.</p><p>One solution is to multiply the speed by the amount of time that has passed between rendering frames. For example, if you want your object to move 600 units per second, you might write <code class="literal">obj.x += 600 * delta</code>. In this way, your object will move a constant distance over time. However, at low frame rates and high speeds, your object will be moving large distances every frame, which can cause it to do strange things such as move through walls. At high frame rates, computing your physics might take longer than the amount of time between frames, which will cause your application to freeze and crash (this is called a <span class="emphasis"><em>spiral of death</em></span>). Additionally, we would like to achieve perfect reproducibility. That is, every time we run the application with the same input, we would like exactly the same output. If we have variable frame deltas, our output will diverge the longer the program runs due to accumulated rounding errors, even at normal frame rates.</p><p>A better solution is to separate physics update time-steps from frame refresh time-steps. The physics engine should receive fixed-size time deltas, while the rendering engine should determine how many physics updates should occur per frame. The fixed-size deltas avoid an inconsistent rounding error and ensure that there are no giant leaps between frames. The following code shows how to divide the amount of time between frames into discrete chunks to use for physics calculations:</p><div class="informalexample"><pre class="programlisting">// Globals
INV_MAX_FPS = 1 / 60;
frameDelta = 0;
clock = new THREE.Clock();

// In the animation loop (the requestAnimationFrame callback)…
frameDelta += clock.getDelta();
while (frameDelta &gt;= INV_MAX_FPS) {
  update(INV_MAX_FPS); // calculate physics
  frameDelta -= INV_MAX_FPS;
}</pre></div><p>First, we declare <code class="literal">INV_MAX_FPS</code>, the multiplicative inverse of the maximum frames per second that we want to render (<code class="literal">60</code> in this case). This is the time-step we will feed to our physics engine via the <code class="literal">update</code> function<a class="indexterm" id="id289"/>, and you may need to adjust it depending on how slowly your simulation runs (keep in mind that most monitors can't refresh faster than 60 frames<a class="indexterm" id="id290"/> per second, and above 30 is usually considered acceptable). Then, we start tracking our <code class="literal">frameDelta</code>, the accumulated amount of time since the last physics update<a class="indexterm" id="id291"/>. Our clock will be used to keep track of the time between rendering frames.</p><p>In the animation loop, we first add the amount of time since the last render to <code class="literal">frameDelta</code>, <a class="indexterm" id="id292"/>then perform as many fixed-size physics updates as we need. We might end up with some time left over in <code class="literal">frameDelta</code>, but it will be used up during the next frame.</p><p>For our purposes, "physics updates" means both moving objects in our world and moving the player's camera.</p></div>
<div class="section" title="First-person shooter project"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>First-person shooter project</h1></div></div></div><p>Let's write a real game! This project will be bigger than any others we've done, so let's start by specifying exactly<a class="indexterm" id="id293"/> what to accomplish. We're going to build an arena-based first-person shooter game with<a class="indexterm" id="id294"/> the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A world based on a voxel map</li><li class="listitem" style="list-style-type: disc">A player that can look, run, and jump around in the world</li><li class="listitem" style="list-style-type: disc">Pointer lock and full-screen, so that the player is fully immersed as in a desktop or console game</li><li class="listitem" style="list-style-type: disc">The player should be able to shoot at enemies that wander around, and the enemies should shoot back</li><li class="listitem" style="list-style-type: disc">The player's and enemies' health should deteriorate when shot, and players should respawn when they run out of health</li><li class="listitem" style="list-style-type: disc">The player's screen should flash red when shot</li><li class="listitem" style="list-style-type: disc">There should be a <span class="strong"><strong>HUD</strong></span> (<span class="strong"><strong>heads-up display</strong></span>)<a class="indexterm" id="id295"/> with crosshairs and a health indicator</li><li class="listitem" style="list-style-type: disc">We do not care much about lighting or texturing, except that the player must be able to see and perceive distances in depth</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>The complete code is too long to include here, but you can download it online from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> or have the files e-mailed to you at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>. The rest of this section covers interesting excerpts from the code.</p></div></div><p>The first step is to write<a class="indexterm" id="id296"/> the HTML code. In the previous examples, we've written all of our code in a single HTML file, but this is a bigger project so we should split the code into separate files and reference them from our <code class="literal">index.html</code> file. We'll also want to add some user-interface elements to the basic HTML document, notably including a <code class="literal">start</code> screen that the user must click in order to enter the game and a <code class="literal">hurt</code> div, which is just a translucent red overlay that we'll flash briefly on the screen as a helpful warning when the player gets hit by an enemy bullet.</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;!-- ... --&gt;
<span class="strong"><strong>    &lt;link rel="stylesheet" href="main.css" /&gt;</strong></span>
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="start"&gt;&lt;div id="instructions"&gt;
      Click to start
    &lt;/div&gt;&lt;/div&gt;
    &lt;div id="hud" class="hidden"&gt;
      &lt;!-- ... --&gt;
      &lt;div id="hurt" class="hidden"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="three.min.js"&gt;&lt;/script&gt;
<span class="strong"><strong>    &lt;script src="main.js"&gt;&lt;/script&gt;</strong></span>
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>We'll also break up the <code class="literal">main.js</code> file into a few different files when we start writing classes. For simplicity we've put everything in the same folder. In <a class="link" href="ch05.html" title="Chapter 5. Design and Development">Chapter 5</a>, <span class="emphasis"><em>Design and Development</em></span>, we take a closer look at better organizational structures for large projects.</p><div class="section" title="Designing a map"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Designing a map</h2></div></div></div><p>Now that we have a place<a class="indexterm" id="id297"/> to put some code, we need an<a class="indexterm" id="id298"/> interesting world to look at. Let's design a map to use. For example:</p><div class="informalexample"><pre class="programlisting">var map = "XXXXXXX  \n" +
          "X     X  \n" +
          "X  S  X  \n" +
          "X     X  \n" +
          "X   S XXX\n" +
          "XXX     X\n" +
          "  XX  S X\n" +
          "   X    X\n" +
          "   XXXXXX";
map = map.split("\n");
var HORIZONTAL_UNIT = 100,
    VERTICAL_UNIT   = 100,
    ZSIZE = map.length * HORIZONTAL_UNIT,
    XSIZE = map[0].length * HORIZONTAL_UNIT;</pre></div><p>Our map is represented as a string where <code class="literal">X</code> indicates a wall and <code class="literal">S</code> indicates a location where players can spawn into the world. We split the string into an array for easier access, then decide how big <a class="indexterm" id="id299"/>each voxel should be (in this case, 100 * 100 * 100 as indicated by the <code class="literal">HORIZONTAL_UNIT</code> <a class="indexterm" id="id300"/>and <code class="literal">VERTICAL_UNIT</code> variables<a class="indexterm" id="id301"/>) and track <a class="indexterm" id="id302"/>how big the map is overall using <code class="literal">XSIZE</code> and <code class="literal">ZSIZE</code>.</p><p>Next, we need to use our map to generate the 3D world:</p><div class="informalexample"><pre class="programlisting">for (var i = 0, rows = map.length; i &lt; rows; i++) {
  for (var j = 0, cols = map[i].length; j &lt; cols; j++) {
    addVoxel(map[i].charAt(j), i, j);
  }
}</pre></div><p>This is pretty straightforward—iterating over the map and adding something into the world at the specified row and column. Our <code class="literal">addVoxel</code> method<a class="indexterm" id="id303"/> looks similar to the following code:</p><div class="informalexample"><pre class="programlisting">function addVoxel(type, row, col) {
  var z = (row+1) * HORIZONTAL_UNIT - ZSIZE * 0.5,
      x = (col+1) * HORIZONTAL_UNIT - XSIZE * 0.5;
  switch(type) {
    case ' ': break;
    case 'S':
      spawnPoints.push(new THREE.Vector3(x, 0, z));
      break;
    case 'X':
      var geo = new THREE.CubeGeometry(HORIZONTAL_UNIT, VERTICAL_UNIT, HORIZONTAL_UNIT);
      var material = new THREE.MeshPhongMaterial({
        color: Math.random() * 0xffffff
      });
      var mesh = new THREE.Mesh(geo, material);
      mesh.position.set(x, VERTICAL_UNIT*0.5, z);
      scene.add(mesh);
      break;
  }
}</pre></div><p>In order to see our world, we'll also need to add lighting (the easiest approach is one or two <code class="literal">DirectionalLights</code> similar to what we used in the city project) and you may also want to add fog to help with depth<a class="indexterm" id="id304"/> perception. You can manually adjust the camera's <code class="literal">position</code> and <code class="literal">rotation</code> to see what you've just constructed, or temporarily add <code class="literal">FirstPersonControls</code> <a class="indexterm" id="id305"/>similar to what we used in the city project. Since we are only using our map to add walls, you<a class="indexterm" id="id306"/> should add a floor as we did in the city project as well, using a single large plane.</p></div><div class="section" title="Constructing a player"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Constructing a player</h2></div></div></div><p>Now that we have a world,<a class="indexterm" id="id307"/> let's create a player that can move <a class="indexterm" id="id308"/>around in it. We'll need a <code class="literal">Player</code> class<a class="indexterm" id="id309"/> to keep track of each player's state, so let's extend <code class="literal">THREE.Mesh</code> in a new file, which we'll call <code class="literal">player.js</code>:</p><div class="informalexample"><pre class="programlisting">function Player() {
  THREE.Mesh.apply(this, arguments);
  this.rotation.order = 'YXZ';
  this._aggregateRotation = new THREE.Vector3();
  this.cameraHeight = 40;
  this.velocity = new THREE.Vector3();
  this.acceleration = new THREE.Vector3(0, -150, 0);
  this.ambientFriction = new THREE.Vector3(-10, 0, -10);
  this.moveDirection = {
    FORWARD: false,
    BACKWARD: false,
    LEFT: false,
    RIGHT: false
  };
}
Player.prototype = Object.create(THREE.Mesh.prototype);
Player.prototype.constructor = Player;</pre></div><p>We implemented <code class="literal">Player</code> as a child of the <code class="literal">THREE.Mesh</code> class<a class="indexterm" id="id310"/> by calling the <code class="literal">Mesh</code> constructor<a class="indexterm" id="id311"/> from inside the <code class="literal">Player</code> constructor<a class="indexterm" id="id312"/> and copying over the <code class="literal">prototype</code>. This means that players automatically have geometry, materials, position, rotation, and scaling, and additionally we can implement our own features (such as velocity and acceleration). Note that the player functions similar to a controller because it contains code to move and look around, with the difference that the input event handlers are bound outside the class in order to make it reusable.</p><p>One thing that may look strange here is changing the <code class="literal">rotation.order</code>. Rotation is tracked using a Euler representation, which consists of angles in radians around each axis in addition to the order in which the axial rotation should be applied. The default order is <code class="literal">'XYZ'</code>, which rotates up and down first (x), then left to right (y). In this configuration, the world will appear to tilt if <a class="indexterm" id="id313"/>the player looks horizontally after looking vertically. To visualize this, imagine tilting a donut so that the side away from you is up and the side near you is down; that is x rotation, or <span class="strong"><strong>pitch</strong></span><a class="indexterm" id="id314"/>. If you then move your finger around the donut from the <a class="indexterm" id="id315"/>front to the left, that is y rotation, or <span class="strong"><strong>yaw</strong></span><a class="indexterm" id="id316"/>. (Tilting the donut to the right would be z rotation, or <span class="strong"><strong>roll</strong></span><a class="indexterm" id="id317"/>
<span class="strong"><strong>.</strong></span>) Notice that if you were looking out from the middle of the donut towards your finger, your head would be tilted relative to the world. As a result, we have to change the Euler order to <code class="literal">'YXZ'</code> to make the camera rotate relative to the world instead of to itself. With this change, we move our finger first, then tilt the donut so our finger goes up or down instead of the front of the donut, and we end up with a level head.</p><p>To actually implement this looking around, we'll lock the mouse and track its movement. We'll use libraries to make this easier since the APIs are a little wordy. You can get <code class="literal">PointerLock.js</code> <a class="indexterm" id="id318"/>at <a class="ulink" href="https://github.com/IceCreamYou/PointerLock.js">https://github.com/IceCreamYou/PointerLock.js</a> and BigScreen from <span class="emphasis"><em>Brad Dougherty</em></span> at <a class="ulink" href="https://github.com/bdougherty/BigScreen">https://github.com/bdougherty/BigScreen</a>. Once we have included these libraries, starting the game looks similar to the following code, which requests the browser to enter full screen and pointer lock mode before starting animation:</p><div class="informalexample"><pre class="programlisting">document.getElementById('start').addEventListener('click', function() {
  if (BigScreen.enabled) {
    var instructions = this;
    BigScreen.request(document.body, function() {
      PL.requestPointerLock(document.body, function() {
        instructions.className = 'hidden';
        startAnimating();
      }, function() {
        stopAnimating();
      });
    }, function() {
      instructions.className = 'exited';
      stopAnimating();
    });
  }
});</pre></div><p>The Pointer Lock and Full Screen APIs can only be engaged when users take an action (clicking or hitting the keyboard) as a security precaution to prevent attackers from hijacking your screen, so we're waiting for a click in this case. Once we're in full screen, we can listen to the <code class="literal">mousemove</code> event<a class="indexterm" id="id319"/> to rotate the player:</p><div class="informalexample"><pre class="programlisting">document.addEventListener('mousemove', function(event) {
  player.rotate(event.movementY, event.movementX, 0);
}, false);</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>The <code class="literal">event.movementX</code> property<a class="indexterm" id="id320"/> and the <code class="literal">event.movementY</code> property<a class="indexterm" id="id321"/> are normalized across browsers here by the <code class="literal">PointerLock.js</code> library.</p></div></div><p>The <code class="literal">rotate()</code> method<a class="indexterm" id="id322"/> simply changes the player's <code class="literal">_aggregateRotation</code> vector<a class="indexterm" id="id323"/>. We're assuming here that the player has been instantiated, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">player = new Player();
player.add(camera);
scene.add(player);</pre></div><p>Yes, we just added<a class="indexterm" id="id324"/> the <code class="literal">camera</code> to the <code class="literal">player</code>. It turns out that any object that is a descendant of <code class="literal">THREE.Object3D</code> can have other objects added to it. Those child objects are accessible through the<a class="indexterm" id="id325"/> parent's <code class="literal">children</code> array, and they will be grouped together with the parent so that movement, rotation, and scaling are composed. (In other words, if a child's local position is <code class="literal">(0, 0, 5)</code> and the parent's position is <code class="literal">(0, 0, 10)</code>, then the child's position in the world will be <code class="literal">(0, 0, 15)</code>. Rotation and scale work similarly.) In this case, we use this composition to cause our camera to follow our player around.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Because child objects' position, rotation, and scaling are relative to the parent's position, rotation, and scaling, you could create a third-person camera by positioning the camera on the positive z axis (and probably a little higher on the y axis) and giving the <code class="literal">player</code> object<a class="indexterm" id="id326"/> a geometry and material (remember, <code class="literal">Player</code> inherits from <code class="literal">Mesh</code>, so you can instantiate a player with <code class="literal">new Player(geometry, material)</code>).</p></div></div></div><div class="section" title="Player movement"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Player movement</h2></div></div></div><p>We'll finish off the code to look around<a class="indexterm" id="id327"/> in a moment, but because it's closely related to the player's movement, let's address that first.</p><div class="section" title="Physical movement"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec02"/>Physical movement</h3></div></div></div><p>Getting movement right is a complex topic. Although simply adding a constant velocity to an object's position can <a class="indexterm" id="id328"/>work for some simulations, more advanced games will want to have acceleration at play (for example, for gravity) and potentially other forces as well. The most straightforward approach to linear forces is to keep track of acceleration and velocity vectors and add them together:</p><div class="informalexample"><pre class="programlisting">// When the mesh is instantiated
mesh.velocity = new THREE.Vector3(0, 0, 0);
mesh.acceleration = new THREE.Vector3(0, 0, 0);

// Called in the animation loop
function update(delta) {
  // Apply acceleration
  mesh.velocity.add(mesh.acceleration().clone().multiplyScalar(delta));
  // Apply velocity
  mesh.position.add(mesh.velocity.clone().multiplyScalar(delta));
}</pre></div><p>This is called <span class="strong"><strong>Euler</strong></span> integration<a class="indexterm" id="id329"/> (pronounced oiler, not yew-ler). A simple modification gives us <span class="strong"><strong>Midpoint</strong></span> integration<a class="indexterm" id="id330"/>, which yields a reasonable improvement in accuracy. All we need to do is apply the acceleration in halves before and after applying velocity:</p><div class="informalexample"><pre class="programlisting">  var halfAccel = mesh.acceleration.clone().multiplyScalar(delta * 0.5);
  // Apply half acceleration (first half of midpoint formula)
  mesh.velocity.add(halfAccel);
  // Apply thrust
  mesh.position.add(mesh.velocity.clone().multiplyScalar(delta));
  // Apply half acceleration (second half of midpoint formula)
  mesh.velocity.add(halfAccel);</pre></div><p>To understand how this works, consider the following graph:</p><div class="mediaobject"><img alt="Physical movement" src="graphics/8539OS_03_02.jpg"/><div class="caption"><p>Euler versus Midpoint integration</p></div></div><p>The goal of our integration formula is to stay as close to the true position as possible. In the graph, the vertical jumps are at our time-steps, where physics updates are calculated. The midpoint curve is just a shift of the Euler curve so that the area between the midpoint and true positions cancel out. More error is introduced when acceleration, jerk, and nonlinear forces are applied, but<a class="indexterm" id="id331"/> for our purposes (and in the space we have) the midpoint formula is a reasonable trade-off between simplicity and <a class="indexterm" id="id332"/>accuracy.</p><p>The <span class="strong"><strong>fourth-order Runge-Kutta</strong></span> method (also known as <span class="strong"><strong>RK4</strong></span>)<a class="indexterm" id="id333"/> is another commonly used method for computing motion over time. RK4 extrapolates several intermediate states between frames, resulting in a more accurate final approximation for the state in the next frame. The trade-off for increased accuracy is increased complexity and decreased speed. Because of its complexity, we won't cover it here, but usually if you need something as sophisticated as this, you will want to delegate physics handling to one of the libraries addressed in the next section on collision.</p></div><div class="section" title="Updating the player's movement and rotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Updating the player's movement and rotation</h3></div></div></div><p>Let's listen for the movement<a class="indexterm" id="id334"/> keys<a class="indexterm" id="id335"/> so that we know when to move the player:</p><div class="informalexample"><pre class="programlisting">document.addEventListener('keydown', function(event) {
  switch (event.keyCode) {
    case 38: // up
    case 87: // w
      player.moveDirection.FORWARD = true;
      break;
    case 37: // left
    case 65: // a
      player.moveDirection.LEFT = true;
      break;
    case 40: // down
    case 83: // s
      player.moveDirection.BACKWARD = true;
      break;
    case 39: // right
    case 68: // d
      player.moveDirection.RIGHT = true;
      break;
    case 32: // space
      player.jump();
      break;
  }
}, false);</pre></div><p>We'll check these flags in every frame to see how much thrust to apply. We also need a <code class="literal">keyup</code> listener<a class="indexterm" id="id336"/>, which looks almost identical to the <code class="literal">keydown</code> listener<a class="indexterm" id="id337"/> except that it should set our directions back to <code class="literal">false</code> when the relevant keys <a class="indexterm" id="id338"/>are released.</p><p>And now, finally, we can<a class="indexterm" id="id339"/> implement <a class="indexterm" id="id340"/>the player's<a class="indexterm" id="id341"/> <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">Player.prototype.update = (function() {
  var halfAccel = new THREE.Vector3();
  var scaledVelocity = new THREE.Vector3();
  return function(delta) {
    var r = this._aggregateRotation
      .multiplyScalar(delta)
      .add(this.rotation);
    r.x = Math.max(Math.PI * -0.5, Math.min(Math.PI * 0.5, r.x));
    this.rotation.x = 0;

    if (this.moveDirection.FORWARD) this.velocity.z -= Player.SPEED;
    if (this.moveDirection.LEFT) this.velocity.x -= Player.SPEED;
    if (this.moveDirection.BACKWARD) this.velocity.z += Player.SPEED;
    if (this.moveDirection.RIGHT) this.velocity.x += Player.SPEED;

    halfAccel.copy(this.acceleration).multiplyScalar(delta * 0.5);
    this.velocity.add(halfAccel);
    var squaredVelocity = this.velocity.x*this.velocity.x + this.velocity.z*this.velocity.z;
    if (squaredVelocity &gt; Player.SPEED*Player.SPEED) {
      var scalar = Player.SPEED / Math.sqrt(squaredVelocity);
      this.velocity.x *= scalar;
      this.velocity.z *= scalar;
    }
    scaledVelocity.copy(this.velocity).multiplyScalar(delta);
    this.translateX(scaledVelocity.x);
    this.translateZ(scaledVelocity.z);
    this.position.y += scaledVelocity.y;
    this.velocity.add(halfAccel);

    this.velocity.add(scaledVelocity.multiply(
      this.ambientFriction
    ));

    this.rotation.set(r.x, r.y, r.z);
    this._aggregateRotation.set(0, 0, 0);
  };
})();</pre></div><p>There's a lot going on here. The first thing to notice is that our definition of the method immediately invokes an anonymous function that returns our actual method definition. We do this to create some helper objects for efficiency. Most Three.js math happens in place (as opposed to returning a new object with the result of each operation), which means that to perform calculations with existing math objects such as the <code class="literal">acceleration</code> vector<a class="indexterm" id="id342"/>, we either <a class="indexterm" id="id343"/>need to clone them or copy values to a <code class="literal">helper</code> object<a class="indexterm" id="id344"/> that we can manipulate without side effects. Cloning creates too much<a class="indexterm" id="id345"/> garbage-collection churn, meaning<a class="indexterm" id="id346"/> that the browser will lag if it has to process all the objects we would be rapidly creating and then discarding. Instead, we define  the <code class="literal">halfAccel</code> vector,<a class="indexterm" id="id347"/> for example, in a closure (so that it doesn't pollute the global namespace) and do our vector math with that. This pattern is used frequently in the Three.js library itself.</p><p>Almost everything else in the <code class="literal">update</code> method <a class="indexterm" id="id348"/>is addition and multiplication. To look around, we aggregate how far the mouse has moved between each frame, then add the corresponding amount of rotation when the player is updating. Also, the acceleration and velocity part should look familiar—it's the same midpoint strategy we just covered in the <span class="emphasis"><em>Physical movement</em></span> section. We have to be sensitive to a few issues though. First, we restrict <code class="literal">r.x</code> in order to constrain how far the player can look up and down so that they don't get confused which way is up. Second, we want the concept of <span class="emphasis"><em>forward</em></span> to be relative to the world instead of where the camera is looking, so that we can look up and walk forward without <a class="indexterm" id="id349"/>flying into the air in the direction we're looking. To do this, we reset the pitch (making the player look straight ahead instead of up or down) before adding the velocity to the position. Finally, we add friction, which allows the player to slow down and stop after moving in a given direction. In your <a class="indexterm" id="id350"/>actual game, you will probably want to use different levels<a class="indexterm" id="id351"/> of friction depending on whether your player is in the air or not.</p></div></div><div class="section" title="Player collision"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Player collision</h2></div></div></div><p>There are several different<a class="indexterm" id="id352"/> approaches to <a class="indexterm" id="id353"/>detecting collision:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Voxels</strong></span>: As discussed in <a class="link" href="ch02.html" title="Chapter 2. Building a World">Chapter 2</a>, <span class="emphasis"><em>Building a World</em></span>, one common way to design worlds is to use a string or image to represent repeatable building blocks, such as LEGOs. <a class="indexterm" id="id354"/>When using this method, the fastest way to check for collision between an actor and the world is to simply check if the actor's coordinates are inside the zone that the map designates for use by a building block. This avoids the complexity of comparing 3D shapes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rays</strong></span>: Just like <a class="indexterm" id="id355"/>we used the <code class="literal">Raycaster</code> class<a class="indexterm" id="id356"/> earlier to detect clicked objects, we can also use it to detect collision between multiple objects with the <code class="literal">intersectObjects()</code> method<a class="indexterm" id="id357"/>. To do this, we can cast rays in multiple directions from the object that needs to check for collision, such as the player; for example, we could cast a ray from the player's position toward each of the player's vertices. If an intersection occurs at a distance smaller than the distance from the player's position to the vertex, a collision has occurred. There are several problems with this method. First, it's inefficient for large numbers of vertices or dynamic objects. Second, objects can escape detection if they are not exactly in the direction of a ray. Lastly, rays check for intersection using an approximation of objects' shapes, so irregularly-shaped objects can be incorrectly selected. However, this is the simplest general-purpose approach that can work without additional libraries or knowledge about the world's layout.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Intersection</strong></span>: We can manually<a class="indexterm" id="id358"/> compare objects' geometries and positions to see if they overlap. Since detecting collision between complex 3D shapes is mathematically difficult, most games use simplified approximations instead of the actual geometry to make calculations easier. Even so, 3D collision detection algorithms are complex and slow unless we use very simple shapes such as boxes or spheres that don't do a great job of approximating our objects. It's also computationally expensive without some complex optimizations such as using a data structure called an <span class="strong"><strong>Octree</strong></span><a class="indexterm" id="id359"/> to make sure only nearby objects need to check for collision. If you want to try implementing your own collision, Three.js includes an Octree implementation in the <code class="literal">examples/js</code> folder.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Libraries</strong></span>: Luckily, we don't have<a class="indexterm" id="id360"/> to do complex collision detection manually, as there are several libraries that can take care of the complications for us. They also handle collision response and associated physics. The leading contenders are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ammo.js</strong></span><a class="indexterm" id="id361"/> is a large but complete library compiled to JavaScript from C++. It is <a class="indexterm" id="id362"/>available at <a class="ulink" href="https://github.com/kripken/ammo.js/">https://github.com/kripken/ammo.js/</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cannon.js</strong></span><a class="indexterm" id="id363"/> is a smaller library written from scratch in JavaScript and inspired in part by concepts from Three.js. It is<a class="indexterm" id="id364"/> available at <a class="ulink" href="https://github.com/schteppe/cannon.js">https://github.com/schteppe/cannon.js</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Physi.js</strong></span> is<a class="indexterm" id="id365"/> a bridge between Ammo or Cannon and Three.js that also runs the physics simulation in a separate thread to avoid blocking the rendering. It is <a class="indexterm" id="id366"/>available at <a class="ulink" href="https://github.com/chandlerprall/Physijs">https://github.com/chandlerprall/Physijs</a>.</li></ul></div></li></ul></div><p>For our shooter game, we'll use voxel collision and a little bit of manual intersection. Unfortunately, all the physics libraries are large, so we don't have space to cover their APIs here. However,<a class="indexterm" id="id367"/> Cannon.js and Physi.js have examples specifically for use with Three.js available from their project pages.</p><div class="section" title="Voxel collision"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Voxel collision</h3></div></div></div><p>If we try to <a class="indexterm" id="id368"/>walk around<a class="indexterm" id="id369"/> our world now, we'll just fall through the floor. Let's create a function to check for collision between the player and the voxel world:</p><div class="informalexample"><pre class="programlisting">function checkPlayerCollision(player) {
  player.collideFloor(floor.position.y);
  var cell = mapCellFromPosition(player.position);
  switch (cell.char) {
    case ' ':
    case 'S':
      break;
    case 'X':
      moveOutside(cell, player);
      break;
  }
}</pre></div><p>Our <code class="literal">collideFloor</code> method<a class="indexterm" id="id370"/> keeps the player above the floor's y position. Then, the <code class="literal">mapCellFromPosition</code> method<a class="indexterm" id="id371"/> looks up the map cell from the player's position to determine whether the player is in a wall or open space. If the player is colliding with a wall, the <code class="literal">moveOutside()</code> method<a class="indexterm" id="id372"/> moves the player outside of it by shifting the player toward the closest cell. The cell-from-position lookup is just the reverse of what<a class="indexterm" id="id373"/> we used <a class="indexterm" id="id374"/>to place<a class="indexterm" id="id375"/> each voxel originally:</p><div class="informalexample"><pre class="programlisting">var XOFFSET = (map.length+1) * 0.5 * HORIZONTAL_UNIT,
    ZOFFSET = (map[0].length+1) * 0.5 * HORIZONTAL_UNIT,
    col = Math.floor((position.x+XOFFSET) / HORIZONTAL_UNIT) - 1,
    row = Math.floor((position.z+ZOFFSET) / HORIZONTAL_UNIT) - 1,
    char = map[mapRow].charAt(mapCol);</pre></div></div></div><div class="section" title="Bots"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Bots</h2></div></div></div><p>Now that we've got the <a class="indexterm" id="id376"/>player working, it's time to add enemy bots<a class="indexterm" id="id377"/>. Enemies can be <code class="literal">Player</code>s just as the user is, so apart from initializing them, the main thing we need to add is autonomous behavior. We don't have the space here to go in depth on artificial intelligence strategies, so we'll just set each bot's <code class="literal">moveDirection</code> flags randomly every once in awhile:</p><div class="informalexample"><pre class="programlisting">bot.rotation.y = Math.random() * Math.PI * 2;
bot.moveDirection.FORWARD = Math.random() &lt; 0.8;</pre></div></div><div class="section" title="Bullets"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Bullets</h2></div></div></div><p>Finally, let's add<a class="indexterm" id="id378"/> shooting so we can <a class="indexterm" id="id379"/>pulverize those enemies! First, we'll create a new <code class="literal">Bullet</code> class<a class="indexterm" id="id380"/> in <code class="literal">bullet.js</code> similar to what we did for the <code class="literal">Player</code> class<a class="indexterm" id="id381"/>. Bullets are just meshes with a <code class="literal">direction</code> vector<a class="indexterm" id="id382"/> and a <code class="literal">speed</code> scalar<a class="indexterm" id="id383"/>, so their <code class="literal">update</code> method<a class="indexterm" id="id384"/> can be pretty simple:</p><div class="informalexample"><pre class="programlisting">Bullet.prototype.update = (function() {
  var scaledDirection = new THREE.Vector3();
  return function(delta) {
    scaledDirection.copy(this.direction).multiplyScalar(this.speed*delta);
    this.position.add(scaledDirection);
  };
})();</pre></div><p>We'll set bullets' directions when they're shot. Bullets can either be shot in the camera's direction or from an enemy bot toward<a class="indexterm" id="id385"/> another player. To get the relevant direction, our <code class="literal">shoot</code> function<a class="indexterm" id="id386"/> will look similar to the following code:</p><div class="informalexample"><pre class="programlisting">var shoot = (function() {
  var negativeZ = new THREE.Vector3(0, 0, -1);
  return function(from, to) {
    bullet = new Bullet();
    bullet.position.copy(from.position);
    if (to) {
      bullet.direction = to.position.clone().sub(from.position).normalize();
    }
    else {
      bullet.direction = negativeZ.clone().applyEuler(from.rotation);
    }
    bullets.push(bullet);
    scene.add(bullet);
  };
})();</pre></div><p>We get the direction from one<a class="indexterm" id="id387"/> player to another by subtracting their positions. If the user is shooting then we aren't necessarily aiming at anything, so we just want the direction in which the camera is looking. We retrieve this direction from the player's rotation.</p></div><div class="section" title="Updating the game loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Updating the game loop</h2></div></div></div><p>Bringing it all together,<a class="indexterm" id="id388"/> we should<a class="indexterm" id="id389"/> end up with a function like this, which executes all of our game's behavior:</p><div class="informalexample"><pre class="programlisting">function update(delta) {
  player.update(delta);
  checkPlayerCollision(player);

  for (var i = bullets.length - 1; i &gt;= 0; i--) {
    bullets[i].update(delta);
    checkBulletCollision(bullets[i], i);
  }

  for (var j = 0; j &lt; enemies.length; j++) {
    var enemy = enemies[j];
    enemy.update(delta);
    checkPlayerCollision(enemy);
    if (enemy.health &lt;= 0) {
      spawn(enemy);
    }
    shoot(enemy, player);
    move(enemy);
  }

  if (player.health &lt;= 0) {
    spawn(player);
  }
}</pre></div><p>This function calculates all physics (including movement and collision checking), triggers autonomous behavior such as the bots shooting at targets, and implements game logic (such as players dying when their health is too low). It is called in every frame from the animation loop. The <a class="indexterm" id="id390"/>delta parameter is the physics time-step, so it should always be the same value as discussed in the <span class="emphasis"><em>Timing</em></span> section of this chapter.</p><p>That was a lot of code to write! <a class="indexterm" id="id391"/>We're rewarded, though, with an awesome arena-based first-person shooter game that you can put online and send to all your friends. You can see how all that work might look in the following image:</p><div class="mediaobject"><img alt="Updating the game loop" src="graphics/8539OS_03_03.jpg"/><div class="caption"><p>A screenshot of the finished game</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we learned how to implement user interaction and game physics. We also built a full-fledged first-person shooter game. In the next chapter, we'll add detail to our worlds with imported models, particle systems, sound, and post-processing effects.</p></div></body></html>