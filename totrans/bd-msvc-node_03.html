<html><head></head><body>
		<div><h1 id="_idParaDest-53" class="chapter-number"><a id="_idTextAnchor054"/>3</h1>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor055"/>Understanding Node.js Fundamentals: Building Blocks and Key Concepts</h1>
			<p>Node.js is a JavaScript runtime built on the V8 JavaScript engine. It allows you to run JavaScript code outside of a web browser, making it a popular choice for server-side and command-line applications. Understanding these fundamentals of Node.js will provide you with a solid foundation for developing server-side applications, command-line tools, and other JavaScript-based solutions using the Node.js runtime.</p>
			<p>We’ll start this chapter with the exploration of Node.js framework fundamentals. To learn how to develop with the Node.js framework, you need to master its building blocks and key concepts. One thing is for sure: Node.js is a framework with which you can build even the most difficult projects. You can build REST APIs, authorization systems, data visualization and management systems/applications, frontend frameworks with templating languages, AI and machine learning apps, and many more.</p>
			<p>We need to have a little understanding of synchronous and asynchronous programming. In synchronous programming, tasks are executed sequentially, one after the other. When a function is called, the program waits until that function completes its execution before moving on to the next task. This means that each operation must finish before the next one starts. In a synchronous process, if an operation takes a long time to complete (such as reading data from a database or making a network request), it can block the entire program, making it unresponsive. In asynchronous programming, tasks are executed independently from the main program flow. When an asynchronous operation is initiated, the program can continue executing other tasks without waiting for the asynchronous operation to complete. Once the asynchronous operation finishes, a callback function or a promise resolves, allowing the program to handle the result.</p>
			<p>Also, let’s talk a little about the V8 JavaScript engine. The V8 JavaScript engine is an open source JavaScript engine developed by Google. It is written in C++ and is used in Google Chrome and many other projects, including Node.js. V8’s speed and efficiency have made it a fundamental component of many web browsers and server-side JavaScript frameworks, contributing to the rapid growth of JavaScript-based applications and services on the web.</p>
			<p>By the end of this chapter, you will have learned the fundamentals of Node.js and how to apply them in your everyday work.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Asynchronous and non-blocking communication and event-driven architecture</li>
				<li>The JavaScript ecosystem and server-side development</li>
				<li>Command-line applications and scalability and performance</li>
				<li>Cross-platform compatibility and community and support</li>
				<li>Microservices and serverless architectures and their integration through APIs</li>
			</ul>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor056"/>Asynchronous and non-blocking communication and event-driven architecture</h1>
			<p>In this section, we’re going to learn about asynchronous and non-blocking communication along with event-driven architecture. Asynchronous and non-blocking communication, along with event-driven architecture, are crucial concepts in microservices that enable efficient, responsive, and loosely coupled interactions among services.</p>
			<p>Let’s explore these concepts in more detail in the following subsections.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>Asynchronous and non-blocking communication</h2>
			<p>In a microservices architecture, services often<a id="_idIndexMarker132"/> need to interact with one another to complete tasks. <strong class="bold">Asynchronous and non-blocking communication</strong> refers to the practice of allowing services to continue their operations without waiting for immediate responses from other services.</p>
			<p>This approach offers<a id="_idIndexMarker133"/> several advantages, such as the following:</p>
			<ul>
				<li><strong class="bold">Improved responsiveness</strong>: Asynchronous communication prevents services from being blocked while waiting for responses, leading to faster overall response times.</li>
				<li><strong class="bold">Scalability</strong>: Non-blocking communication allows services to process other tasks, such as API requests and responses, while waiting for responses. Scalability is essential for handling high volumes of concurrent requests.</li>
				<li><strong class="bold">Reduced coupling</strong>: Services are not tightly coupled to one another’s response times. This flexibility supports the autonomy and independence of microservices.</li>
				<li><strong class="bold">Resilience</strong>: Asynchronous communication can handle scenarios where a service is temporarily unavailable<a id="_idIndexMarker134"/> and retries can be attempted later.</li>
			</ul>
			<p>Mastering this communication is a fundamental way for services to interact better with one another.</p>
			<p><em class="italic">Figure 3</em><em class="italic">.1</em> illustrates asynchronous and non-blocking communication:</p>
			<div><div><img src="img/B14980_03_01.jpg" alt="Figure 3.1: Asynchronous and non-blocking communication"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Asynchronous and non-blocking communication</p>
			<p>Therefore, asynchronous and non-blocking communication leads to improved responsiveness, scalability, reduced coupling, and resilience of our systems/applications while maintaining a bug-free code.</p>
			<p>In summary, in synchronous<a id="_idIndexMarker135"/> communication, the sender and receiver operate in a synchronized manner. The sender sends a request and waits until it receives a response before proceeding with further actions. This communication style is similar to making a phone call: you wait for the other person to answer and respond before you continue the conversation. In asynchronous communication, the sender and receiver operate independently. The sender sends a request and continues with other tasks without waiting for a response. When the receiver processes the request and generates a response, it is sent back to the sender. This style of communication is similar to sending an email: you send the message and continue with your work, expecting a response later.</p>
			<p>In the next section, we’ll learn about event-driven architecture.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>Event-driven architecture</h2>
			<p><strong class="bold">Event-driven architecture</strong> is a pattern whereby services<a id="_idIndexMarker136"/> communicate through the exchange of events. An <strong class="bold">event</strong> is a significant occurrence<a id="_idIndexMarker137"/> or state change that other services might be interested in.</p>
			<p>The key features<a id="_idIndexMarker138"/> of this architecture include the following:</p>
			<ul>
				<li><strong class="bold">Publish-subscribe model</strong>: Services that generate events (publishers) notify other services (subscribers) about these events. Subscribers can react to events without direct communication with publishers.</li>
				<li><strong class="bold">Loose coupling</strong>: Event-driven architecture promotes loose coupling between services. Publishers and subscribers don’t need to know each other’s details, reducing dependencies.</li>
				<li><strong class="bold">Flexibility</strong>: New services can easily subscribe to events as needed, without affecting the existing services. This flexibility supports the evolution of the system.</li>
				<li><strong class="bold">Scalability</strong>: Event-driven systems can distribute the processing of events, allowing for efficient scalability as the system grows.</li>
				<li><strong class="bold">Real-time updates</strong>: Event-driven architecture supports real-time updates and enables services to respond<a id="_idIndexMarker139"/> quickly to changes in the system.</li>
			</ul>
			<p>When we develop microservices in Node.js, we can apply the event-driven architecture to develop in a better way, with all the preceding advantages, and we can assure the best quality for our application/system.</p>
			<p><em class="italic">Figure 3</em><em class="italic">.2</em> shows an event-driven architecture:</p>
			<div><div><img src="img/B14980_03_02.jpg" alt="Figure 3.2: An event-driven architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: An event-driven architecture</p>
			<p>Common implementations of event-driven architecture<a id="_idIndexMarker140"/> include message queues (e.g., RabbitMQ and Apache Kafka) and event streaming platforms (e.g., Apache Kafka and IBM Event Streams).</p>
			<p>In summary, embracing asynchronous and non-blocking communication, along with event-driven architecture, empowers microservices to work independently, efficiently handle communication, and respond dynamically to changes. These concepts are vital for building resilient, scalable, and loosely coupled microservices systems that align with the requirements of modern, agile software development.</p>
			<p>With the understanding of these concepts, let’s now move on to the JavaScript ecosystem and server-side development.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor059"/>The JavaScript ecosystem and server-side development</h1>
			<p>In this section, we’re going to learn about the JavaScript ecosystem and server-side development.</p>
			<p>The JavaScript ecosystem is a vast collection of tools, libraries, frameworks, and resources that support the development of web applications, both on the client side (browser) and the server side. JavaScript has become one of the most popular and versatile programming languages, powering a wide range of applications from interactive websites to complex server-side systems.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>The JavaScript ecosystem</h2>
			<p>The <strong class="bold">JavaScript ecosystem</strong> refers to the vast collection<a id="_idIndexMarker141"/> of libraries, frameworks, tools, and resources that revolve around the JavaScript programming language. This ecosystem has evolved over the years to support various aspects of software development, ranging from frontend web development to server-side programming and more.</p>
			<p>Some key features of the JavaScript ecosystem<a id="_idIndexMarker142"/> are as follows:</p>
			<ul>
				<li><strong class="bold">Node.js</strong>: This is a runtime that allows running JavaScript on the server side. It’s used for building server-side applications and APIs.</li>
				<li><code>npm</code> is a package manager for JavaScript that enables developers<a id="_idIndexMarker143"/> to easily share and reuse code. It hosts a massive repository of open-source packages such as <code>express</code> and <code>xlsx</code>, which can be used to extend the functionality of your applications.</li>
				<li><code>body-parser</code>, <code>cookie-parser</code>), routing (express router), templating engines (<code>ejs</code>, <code>pug</code>), session management (express-session), security (<code>helmet</code>, <code>csurf</code>), caching (cache-control), authentication and authorization (<code>express-jwt</code>, <code>passport</code>), file uploads (<code>multer</code>), internationalization (<code>i18n</code>), and so on.</li>
				<li><strong class="bold">Frontend frameworks</strong>: Frameworks such as React, Angular, and Vue.js enable the creation of dynamic and interactive user interfaces on the client side. These frameworks offer components, state management, and routing capabilities.</li>
				<li><strong class="bold">Build tools</strong>: Tools such as Webpack, Parcel, and Rollup help bundle and optimize JavaScript code, CSS, and other assets for production-ready applications.</li>
				<li><strong class="bold">Testing libraries</strong>: Jest, Mocha, and Jasmine are common testing libraries that facilitate writing and running tests for your code base.</li>
				<li><strong class="bold">Database access</strong>: Libraries such as Sequelize, Mongoose, and Knex provide database abstraction and management, allowing you to interact with various databases.</li>
				<li><strong class="bold">RESTful APIs</strong>: Libraries such as Express.js make it easy to create RESTful APIs for your applications, enabling<a id="_idIndexMarker144"/> communication between client and server.</li>
			</ul>
			<p>The JavaScript ecosystem is so big that we can take hours learning it, but we need to make sure to use the best practices when we develop in Node.js with tools, frameworks, and libraries offered by the JavaScript ecosystem.</p>
			<p><em class="italic">Figure 3</em><em class="italic">.3</em> depicts the JavaScript ecosystem:</p>
			<div><div><img src="img/B14980_03_03.jpg" alt="Figure 3.3: A JavaScript ecosystem"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: A JavaScript ecosystem</p>
			<p>Learning primarily what a JavaScript ecosystem<a id="_idIndexMarker145"/> is the proper way to interact better with its tools, libraries, and frameworks.</p>
			<p>With these concepts learned, we can continue with server-side development.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Server-side development with Node.js</h2>
			<p><strong class="bold">Server-side development</strong> with Node.js allows you to build<a id="_idIndexMarker146"/> scalable and efficient applications that handle tasks such as data processing, file manipulation, and interacting with databases.</p>
			<p>Some key concepts and advantages<a id="_idIndexMarker147"/> of Node.js for server-side development include the following:</p>
			<ul>
				<li><strong class="bold">Non-blocking I/O</strong>: Node.js’s asynchronous and event-driven architecture allows it to handle a large number of concurrent connections without blocking the execution of the other tasks.</li>
				<li><strong class="bold">Scalability</strong>: Node.js applications can be easily scaled horizontally, making them suitable for real-time applications and microservices architectures.</li>
				<li><strong class="bold">Single language</strong>: Using JavaScript on both the client and server sides can streamline development and maintenance, as developers can work with the same language throughout the stack.</li>
				<li><code>npm</code> packages and the vibrant JavaScript community provide resources and tools to solve various development challenges.</li>
				<li><strong class="bold">Fast development</strong>: Node.js’s rapid development cycle allows for quick iteration and deployment<a id="_idIndexMarker148"/> of applications.</li>
			</ul>
			<p>We can do so much while we develop on the server side in Node.js, such as data processing, file manipulation, interacting with databases, authenticating and authorization in our systems/applications, applying best practices for security issues, and making our system/application international.</p>
			<p><em class="italic">Figure 3</em><em class="italic">.4</em> depicts server-side development with Node.js:</p>
			<div><div><img src="img/B14980_03_04.jpg" alt="Figure 3.4: Server-side development with Node.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: Server-side development with Node.js</p>
			<p>In conclusion, the JavaScript<a id="_idIndexMarker149"/> ecosystem, bolstered by Node.js, offers a comprehensive toolkit for building both client-side and server-side applications. With its non-blocking nature and extensive libraries, JavaScript is well-suited for modern, responsive, and efficient server-side development.</p>
			<p>Now, we can continue to the next section, in which we will talk about command-line applications, scalability, and performance.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/>Command-line applications and scalability and performance</h1>
			<p>In this section, we will learn about command-line applications, scalability, and performance in Node.js. Command-line applications and scalability/performance are two important aspects in the realm of software development.</p>
			<p>We’ll start with command-line applications.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Command-line applications</h2>
			<p><strong class="bold">Command-line applications</strong> are software programs that<a id="_idIndexMarker150"/> are operated through the <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) of an operating system. These programs<a id="_idIndexMarker151"/> allow users to interact with the application<a id="_idIndexMarker152"/> by typing commands instead of using a <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>). Command-line applications are widely used for various tasks, including system administration, file manipulation, data processing, and development workflows.</p>
			<p>The key advantages of command-line applications<a id="_idIndexMarker153"/> are as follows:</p>
			<ul>
				<li><strong class="bold">Efficiency</strong>: Command-line applications often require fewer system resources and can execute tasks more quickly due to their lightweight nature.</li>
				<li><strong class="bold">Automation</strong>: Command-line applications are well-suited for automation scripts, allowing developers to create repeatable and complex tasks with ease.</li>
				<li><strong class="bold">Remote access</strong>: Command-line applications can be accessed remotely, making them ideal for managing servers and systems over the network.</li>
				<li><strong class="bold">Scripting</strong>: Developers can create scripts using CLI tools to automate repetitive tasks and improve productivity.</li>
				<li><strong class="bold">Headless environments</strong>: Command-line applications work well in headless environments, such as servers<a id="_idIndexMarker154"/> without graphical interfaces.</li>
			</ul>
			<p>Command-line applications are widely used in various<a id="_idIndexMarker155"/> operating systems to realize the various tasks of everyday work. These tasks can range from the simplest ones, such as system administration, to the most complex ones, such as development workflows.</p>
			<p><em class="italic">Figure 3</em><em class="italic">.5</em> shows a command-line prompt:</p>
			<div><div><img src="img/B14980_03_05.jpg" alt="Figure 3.5: A command-line prompt"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: A command-line prompt</p>
			<p>Command-line applications are the first and most common programs to start with in the extensive world of applications. They are often used in industries, software agencies, enterprises, and so on.</p>
			<p>In the next section, we will talk about scalability and performance in Node.js.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>Scalability and performance</h2>
			<p><strong class="bold">Scalability and performance</strong> are critical considerations when designing and developing software applications, particularly in the context of modern web applications and microservices architectures.</p>
			<p>Let’s start with scalability.</p>
			<h3>Scalability</h3>
			<p><strong class="bold">Scalability</strong> refers to an application’s ability<a id="_idIndexMarker156"/> to handle increasing workloads and to grow in terms of resources, users, and data volume. Scalability can be achieved through two main approaches:</p>
			<ul>
				<li><strong class="bold">Vertical scaling</strong> (<strong class="bold">scaling up</strong>): This means adding more resources (CPU, memory) to a single <a id="_idIndexMarker157"/>machine to handle an increased<a id="_idIndexMarker158"/> load. However, there’s a limit to how much a single machine can scale.</li>
				<li><strong class="bold">Horizontal scaling</strong> (<strong class="bold">scaling out</strong>): This means adding more machines<a id="_idIndexMarker159"/> to distribute the load. This is often used in microservices <a id="_idIndexMarker160"/>architectures, where individual services can be scaled independently.</li>
			</ul>
			<p><em class="italic">Figure 3</em><em class="italic">.6</em> illustrates scalability in Node.js:</p>
			<div><div><img src="img/B14980_03_06.jpg" alt="Figure 3.6: Scalability in Node.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: Scalability in Node.js</p>
			<p>Scalability can help developers<a id="_idIndexMarker161"/> scale up or scale down their applications/systems without too much effort and cost.</p>
			<p>Now, let’s take a look at performance.</p>
			<h3>Performance</h3>
			<p><strong class="bold">Performance</strong> refers to the speed and efficiency<a id="_idIndexMarker162"/> at which an application operates. Several factors influence performance, such as the following:</p>
			<ul>
				<li><strong class="bold">Optimized code</strong>: Writing efficient code<a id="_idIndexMarker163"/> that minimizes resource consumption and maximizes execution speed</li>
				<li><strong class="bold">Caching</strong>: Implementing caching mechanisms to store frequently accessed data and reduce the need for repeated calculations or database queries</li>
				<li><strong class="bold">Database optimization</strong>: Proper indexing, query optimization, and using caching layers to significantly improve database performance</li>
				<li><strong class="bold">Load balancing</strong>: Distributing incoming traffic across multiple servers to prevent overloading individual instances</li>
				<li><strong class="bold">Asynchronous processing</strong>: Using asynchronous operations to handle tasks that don’t need immediate responses, freeing up resources for other tasks</li>
				<li><strong class="bold">Bottleneck identification</strong>: Regularly monitoring and profiling to help identify performance bottlenecks<a id="_idIndexMarker164"/> and areas for improvement</li>
			</ul>
			<p>In modern software development, building scalable and high-performance applications is essential for delivering a positive user experience and handling the demands of a growing user base. Both command-line applications and scalability/performance considerations play a crucial role in creating efficient and responsive software solutions.</p>
			<p>In the next section, we will learn about cross-platform compatibility, community, and support.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor065"/>Cross-platform compatibility and community and support</h1>
			<p>In this section, we are going to learn about cross-platform compatibility, community, and support.</p>
			<p>Cross-platform compatibility and strong community support are two significant factors that contribute to the success and effectiveness of software development. Let’s delve into each of these aspects in the following subsections.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>Cross-platform compatibility</h2>
			<p><strong class="bold">Cross-platform compatibility</strong> refers to the ability of software <a id="_idIndexMarker165"/>applications to run consistently and smoothly across different operating systems and devices. Ensuring cross-platform compatibility is essential in today’s diverse technological landscape, where users interact with applications on various platforms such as Windows, macOS, Linux, Android, and iOS.</p>
			<p>Here are some key points on cross-platform compatibility:</p>
			<ul>
				<li><strong class="bold">User reach</strong>: Developing cross-platform<a id="_idIndexMarker166"/> applications broadens the user base, as the software can be accessed by a larger audience using different devices and operating systems.</li>
				<li><strong class="bold">Consistent experience</strong>: Cross-platform applications aim to provide a consistent user experience regardless of the device or platform being used.</li>
				<li><strong class="bold">Code reusability</strong>: Using frameworks and tools that support cross-platform development allows developers to reuse a significant portion of the code base, saving time and effort.</li>
				<li><strong class="bold">Reduced development costs</strong>: Developing a single application for multiple platforms can reduce development costs compared to building separate native applications for each platform.</li>
				<li><strong class="bold">Efficient updates</strong>: Updates and bug fixes can be applied simultaneously to all platforms, ensuring consistent performance and security.</li>
				<li><strong class="bold">Challenges</strong>: Achieving cross-platform compatibility might require dealing with platform-specific nuances and limitations, which could impact certain features or performance aspects.</li>
			</ul>
			<p>Cross-platform compatibility is essential when trying to create a software application because it offers the majority of users the ability to test their software and use it for their everyday work.</p>
			<p>In the next section, we will talk about community and support in Node.js.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor067"/>Community and support</h2>
			<p>A strong and active community<a id="_idIndexMarker167"/> is crucial for any programming language, framework, or tool. A vibrant community provides developers with resources, guidance, and solutions to challenges they encounter during development.</p>
			<p>Some key aspects of community and support<a id="_idIndexMarker168"/> include the following:</p>
			<ul>
				<li><strong class="bold">Documentation and tutorials</strong>: An engaged community often contributes to comprehensive documentation and tutorials, making it easier for developers to understand and use technologies effectively.</li>
				<li><strong class="bold">Problem-solving</strong>: Community forums, discussion groups, and platforms, such as Stack Overflow, allow developers to seek help, share experiences, and find solutions to issues they encounter.</li>
				<li><strong class="bold">Open source projects</strong>: A strong community often leads to the creation of open source projects, libraries, and tools that enhance development productivity and provide additional functionality.</li>
				<li><strong class="bold">Feedback and improvement</strong>: A community provides feedback, identifies bugs, and suggests improvements, leading to the continuous enhancement of technologies.</li>
				<li><strong class="bold">Networking and collaboration</strong>: Engaging with a community provides opportunities for networking, collaboration, and learning from others’ experiences.</li>
				<li><strong class="bold">Staying updated</strong>: A thriving community helps developers stay informed about the latest trends, updates, and best<a id="_idIndexMarker169"/> practices in the field.</li>
			</ul>
			<p>In conclusion, cross-platform compatibility ensures wider accessibility and a consistent user experience, while a supportive community provides the necessary resources, solutions, and collaborative opportunities for successful software development. Both aspects contribute significantly to the efficiency, effectiveness, and overall success of software projects.</p>
			<p>In the next section, we are going to talk about microservices and serverless architectures as well as their integration through APIs.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor068"/>Microservices and serverless architectures and their integration through APIs</h1>
			<p>In this section, we will learn about microservices and serverless architectures as well as their integration through APIs.</p>
			<p>Microservices architecture, serverless architecture, and integration through APIs are all fundamental concepts in modern software development. Let’s explore each of these concepts and their relationships in the following subsections.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>What is microservices architecture?</h2>
			<p><strong class="bold">Microservices architecture</strong> is a software development approach<a id="_idIndexMarker170"/> where a complex application is broken down into smaller, independent services that can be developed, deployed, and maintained separately. Each microservice focuses on a specific business capability and communicates with other microservices through well-defined APIs. This architectural style offers several benefits but also requires careful design and management.</p>
			<p>The advantages of microservices<a id="_idIndexMarker171"/> include the following:</p>
			<ul>
				<li><strong class="bold">Scalability</strong>: Microservices can be scaled individually, allowing resources to be allocated where needed, leading to efficient resource utilization.</li>
				<li><strong class="bold">Autonomous teams</strong>: Development teams can work on different microservices independently, using the technology stack that suits their service’s requirements.</li>
				<li><strong class="bold">Fault isolation</strong>: Issues in one microservice don’t necessarily affect others, improving fault tolerance and system reliability.</li>
			</ul>
			<p>Microservices offer infinite advantages but the preceding ones are the most known, and applying these when you architect a software is a must because this helps every developer in your team to code, debug, and deploy faster.</p>
			<p><em class="italic">Figure 3</em><em class="italic">.7</em> represents a microservices architecture:</p>
			<div><div><img src="img/B14980_03_07.jpg" alt="Figure 3.7: A microservices architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: A microservices architecture</p>
			<p>Microservices architecture allows developers to build applications/systems in a better way while organizing the components<a id="_idIndexMarker172"/> of the software in a clearer way and allowing them to communicate via APIs.</p>
			<p>In the next section, we will learn more about a serverless architecture.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>What is a serverless architecture?</h2>
			<p>A <strong class="bold">serverless architecture</strong> is an execution model where cloud<a id="_idIndexMarker173"/> providers automatically manage the infrastructure and developers focus solely on writing code for specific functions. It abstracts server management, reducing operational overhead.</p>
			<p>The advantages of a serverless architecture<a id="_idIndexMarker174"/> include the following:</p>
			<ul>
				<li><strong class="bold">Automatic scaling</strong>: Serverless platforms automatically scale functions based on incoming requests, ensuring optimal performance.</li>
				<li><strong class="bold">Cost efficiency</strong>: You only pay for the actual usage, making it cost-effective for applications with variable workloads.</li>
				<li><strong class="bold">Simplified deployment</strong>: Developers can deploy and update functions without dealing with server provisioning.</li>
			</ul>
			<p>A serverless architecture allows developers to automate the process of managing the infrastructure and focus on building the application/system.</p>
			<p><em class="italic">Figure 3</em><em class="italic">.8</em> represents a serverless architecture:</p>
			<div><div><img src="img/B14980_03_08.jpg" alt="Figure 3.8: A serverless architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: A serverless architecture</p>
			<p>Serverless architecture is the modern way of managing servers and allows developers to focus on writing software without errors.</p>
			<p>With this brief overview of microservices<a id="_idIndexMarker175"/> and serverless architectures, let’s learn how to integrate them using APIs.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>Integration through APIs</h2>
			<p>In both microservices<a id="_idIndexMarker176"/> and serverless architectures, <strong class="bold">integration</strong> is crucial to enable communication between different components. APIs are the mechanisms through which services, functions, or applications interact and exchange data.</p>
			<p>The advantages of integration through APIs<a id="_idIndexMarker177"/> include the following:</p>
			<ul>
				<li><strong class="bold">Loose coupling</strong>: APIs promote loose coupling between components, allowing them to evolve independently without affecting others.</li>
				<li><strong class="bold">Modularity</strong>: Integration through APIs supports modular design, enabling components to be developed, tested, and maintained separately.</li>
				<li><strong class="bold">Interoperability</strong>: APIs enable different systems, services, or applications to work together, even if they are built <a id="_idIndexMarker178"/>on different technologies.</li>
			</ul>
			<p>APIs are the better way to communicate between the components of the software. Enabling communication via components of the software can lead to better applications/systems and services.</p>
			<p><em class="italic">Figure 3</em><em class="italic">.9</em> depicts integration through APIs:</p>
			<div><div><img src="img/B14980_03_09.jpg" alt="Figure 3.9: Integration through APIs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Integration through APIs</p>
			<p>In the modern age of computing, APIs are an ingenious invention to make services in Node.js interact with one another in a proper manner.</p>
			<p>To wrap up this chapter, let’s see how integration works in microservices and serverless architectures.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Integration in microservices and serverless architectures</h2>
			<p>In a microservices<a id="_idIndexMarker179"/> architecture, services<a id="_idIndexMarker180"/> communicate through APIs, enabling them to work together seamlessly while remaining loosely coupled. Meanwhile, in a serverless architecture, functions are often triggered by events, and APIs are used to pass data between functions and external services.</p>
			<p>Microservices architecture, serverless<a id="_idIndexMarker181"/> architecture, and integration<a id="_idIndexMarker182"/> through APIs are interconnected concepts that enable developers to build scalable, modular, and efficient applications. By combining these approaches, developers can create flexible and resilient systems that meet the demands of modern software development.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/>Summary</h1>
			<p>In this chapter, we have learned a lot about Node.js fundamentals as well as its building blocks and key concepts. These fundamentals encompass the core concepts and features that make Node.js a powerful and versatile runtime environment for server-side and network applications.</p>
			<p>In summary, Node.js fundamentals revolve around its event-driven, asynchronous nature, which facilitates building scalable and high-performance applications. Mastering these fundamentals empowers developers to leverage Node.js effectively and create a wide range of applications, from web servers to networking tools, APIs, and beyond.</p>
			<p>In the next chapter, we are going to learn about leveraging the JavaScript and Node.js ecosystem for microservices development.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/>Quiz time</h1>
			<ul>
				<li>What is asynchronous and non-blocking communication?</li>
				<li>What is event-driven architecture?</li>
				<li>What are the key features of JavaScript ecosystem?</li>
			</ul>
		</div>
	</body></html>