<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Securing and Scaling Node.js Applications</h1></div></div></div><p>It's very important to scale and secure your applications. Scaling and securing are not one-time tasks. You need to keep making changes to your code as you add new features to increase application security, and as your application traffic and data increases, you need to scale your servers. In this chapter, you will learn how to make Node.js applications more secure and how to scale Node.js applications. I will be assuming that your are using Express for creating your web server as it is the most common.</p><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Application vulnerabilities</li><li class="listitem" style="list-style-type: disc">Non-vulnerability attacks</li><li class="listitem" style="list-style-type: disc">Various third-party services to protect your application</li><li class="listitem" style="list-style-type: disc">Checking security issues in third-party packages</li><li class="listitem" style="list-style-type: disc">Techniques of distributing traffic</li></ul></div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec106"/>Common vulnerabilities in applications</h1></div></div></div><p>According to Wikipedia, a <strong>vulnerability</strong> is <a id="id659" class="indexterm"/>a weakness in the application <a id="id660" class="indexterm"/>that allows an attacker to reduce a system's information assurance. Applications expose different types of vulnerability.</p><p>Let's look at some important vulnerabilities and how to prevent them.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec95"/>Helmet</h2></div></div></div><p>
<strong>Helmet</strong> is a <a id="id661" class="indexterm"/>Node.js library that <a id="id662" class="indexterm"/>helps you prevent various attacks by setting various security-related HTTP headers.</p><p>Here are the various headers added by Helmet:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Strict-Transport-Policy</code>: This <a id="id663" class="indexterm"/>header is used to enforce secure (HTTP over SSL/TLS) connections to the server. HTTPS prevents man-in-the-middle attacks. In a man-in-the-middle attack, an attacker secretly alters the communication between the client and server. This is done to steal data, add ads to web pages, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">X-Frame-Options</code>: This <a id="id664" class="indexterm"/>header provides clickjacking protection. <strong>Clickjacking</strong> <a id="id665" class="indexterm"/>is a technique by which an attacker uses multiple transparent or opaque layers to trick a user into clicking on a button or link on another page when they intended to click on the top-level page. Thus, the attacker is "hijacking" clicks meant for their page and routing them to some other page, most likely owned by another application, domain, or both. This header prevents the application from being viewed inside an iFrame, therefore providing clickjacking protection.</li><li class="listitem" style="list-style-type: disc"><code class="literal">X-XSS-Protection</code>: This <a id="id666" class="indexterm"/>header prevents reflective XSS attacks. Reflective XSS attacks are a type of XSS attack. <strong>Cross-Site Scripting</strong> (<strong>XSS</strong>) attacks are a <a id="id667" class="indexterm"/>type of injection in which malicious scripts are injected into otherwise benign and trusted web sites. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser-side script, to a different end user. Reflected XSS is the most frequent type of XSS attack. They are also known as non-persistent XSS attacks since the attack payload is delivered and executed via a single request and response. Reflected XSS occurs when the attacker injects executable JavaScript code into the HTML response by injecting the code into the URL.</li><li class="listitem" style="list-style-type: disc"><code class="literal">X-Content-Type-Options</code>: Browsers <a id="id668" class="indexterm"/>can override response <code class="literal">Content-Type</code> headers to guess and process data using an implicit content type. While this can be convenient in some scenarios, it can also lead to some kinds of attack, such as a MIME confusion attack, authorized hotlinking, and so on. Returning <code class="literal">X-Content-Type-Options</code> will cause browsers to use the provided <code class="literal">Content-Type</code> header and not interpret the content as a different content type.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Content-Security-Policy</code>: This <a id="id669" class="indexterm"/>header lets us provide a list of trusted sources to the browser, from which content such as JavaScript, CSS, HTML frames, fonts, images, and embeddable objects (Java applets, ActiveX, audio, and video) can be loaded onto a page. This helps us prevent XSS attacks.</li></ul></div><p>To learn <a id="id670" class="indexterm"/>more about Helmet, visit <a class="ulink" href="https://www.npmjs.com/package/helmet">https://www.npmjs.com/package/helmet</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec96"/>Cross-site request forgery</h2></div></div></div><p>
<strong>Cross-site request forgery</strong> (<strong>CSRF</strong>) is a <a id="id671" class="indexterm"/>type of <a id="id672" class="indexterm"/>attack in which requests from a user are sent to servers without the user knowing about it.</p><p>For example, if an attacker is able to find a reproducible link that executes a specific action on the target page while the victim is logged in to it, he is able to embed such a link on a page he controls and trick the victim into opening it. The attack-carrying link may be placed in a location that the victim is likely to visit while logged in to the target site sent in a HTML e-mail body or attachment.</p><p>There are various ways to prevent CSRF attacks. Most CSRF prevention techniques work by embedding additional authentication data into requests, which allows the web application to detect requests from unauthorized locations.</p><p>There is a library <a id="id673" class="indexterm"/>named <code class="literal">csrf</code> (<a class="ulink" href="https://www.npmjs.com/package/csrf">https://www.npmjs.com/package/csrf</a>) for Node.js that lets you prevent CSRF attacks. It provides you middleware to protect Express web servers from CSRF attacks.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec97"/>Cross-site scripting</h2></div></div></div><p>We saw <a id="id674" class="indexterm"/>earlier what the XSS vulnerability is. We basically saw what a reflected XSS attack is. There is another type of XSS <a id="id675" class="indexterm"/>attack called <strong>stored XSS</strong>.</p><p>Stored XSS occurs when the application stores user input that is not correctly filtered. For example, while chatting, if a message is not sanitized, then both users can run scripts on each other's browsers by sending JS code within <code class="literal">&lt;script&gt;</code> tags as messages.</p><p>To prevent both types of XSS attack, we should always filter/sanitize user input.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec98"/>Session fixation</h2></div></div></div><p>
<strong>Session fixation</strong> is <a id="id676" class="indexterm"/>an attack that permits an attacker to hijack a valid user session. Here are several techniques to prevent session fixation:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set session timeouts</li><li class="listitem" style="list-style-type: disc">Regenerate session tokens frequently</li><li class="listitem" style="list-style-type: disc">When logged out, expire the session token</li><li class="listitem" style="list-style-type: disc">Store the user agent and IP address of the user when creating a session and check whether the value matches during the following HTTP requests.</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec107"/>Non-vulnerability based attacks</h1></div></div></div><p>There are <a id="id677" class="indexterm"/>various kinds of attack that can be made on any kind of application, as they depend on loopholes in the application. Still, applications can do a lot to prevent these attacks.</p><p>Let's see a few of the most common non-vulnerability-based attacks and how to prevent them.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec99"/>Denial-of-service attacks</h2></div></div></div><p>A<strong> denial-of-service</strong> (<strong>DoS</strong>) attack <a id="id678" class="indexterm"/>is an attempt to make a <a id="id679" class="indexterm"/>server machine unavailable to its intended users temporarily. An attacker uses one or many machines to make continuous requests to the server to take it down.</p><p>The best way to prevent DoS is to use an external service such as CloudFlare, which uses a lot of different techniques and data from various sources to block malicious requests on your server. It's always better to avoid handling DoS on your server and leave it to a service created by DoS experts.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec100"/>Brute force attacks</h2></div></div></div><p>A<strong> brute force attack</strong> aims <a id="id680" class="indexterm"/>at being the simplest kind of method to gain access to a site: trying usernames <a id="id681" class="indexterm"/>and passwords, over and over, until it gets in.</p><p>Here are several ways to prevent brute force attacks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can embed CAPTCHA in forms that can completely prevent bots from making brute force attacks and slow down brute force attacks made by humans.</li><li class="listitem" style="list-style-type: disc">There is a <a id="id682" class="indexterm"/>middleware program for Express servers called <strong>express-brute</strong> that limits the rate of incoming requests based on several factors. You can <a id="id683" class="indexterm"/>find out more about <strong>express-brute</strong> at <a class="ulink" href="https://www.npmjs.com/package/express-brute">https://www.npmjs.com/package/express-brute</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec108"/>Using secure packages</h1></div></div></div><p>The npm packages <a id="id684" class="indexterm"/>you use may contain critical security vulnerabilities that could also affect your application. It's not possible to go through every package's code or test each of them separately.</p><p>There is a <a id="id685" class="indexterm"/>database called <code class="literal">Node Security Project</code> that has a list of the most important <a id="id686" class="indexterm"/>vulnerable packages. You can use command-line tools such as <code class="literal">nsp</code> (<a class="ulink" href="https://www.npmjs.com/package/nsp">https://www.npmjs.com/package/nsp</a>) and <code class="literal">requireSafe</code> (<a class="ulink" href="https://www.npmjs.com/package/requiresafe">https://www.npmjs.com/package/requiresafe</a>) to check the vulnerable dependencies of your application.</p><p>You should always keep an eye on the new version releases of the packages that your application is dependent on and update it, as a new release often fixes issues related to security.</p></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec109"/>Scaling Node.js servers</h1></div></div></div><p>If your <a id="id687" class="indexterm"/>application has lots of users accessing the system simultaneously, then obviously a single server cannot handle all the traffic. It will slow down and crash. Therefore, we need to deploy the application on multiple servers and then distribute the traffic equally between them.</p><p>To distribute traffic between servers, we need to use something called a <strong>load balancer</strong>. A load balancer is a server that sits in front of the application servers. The client communicates with the load balancer instead of the application servers, and instead of handling the request, the load balancer forwards it to an application server; when the application servers sends the response, it sends the same response to the client.</p><p>As a load balancer doesn't actually process the request, it can handle many more requests than an application server. Obviously, a load balancer cannot handle unlimited requests, so we can use multiple load balancers. When we use multiple load balancers, the traffic between them is distributed by using the round-robin DNS technique. In round-robin DNS, the IP address of the domain pointing to the load balancer changes according to an appropriate statistical model.</p><p>
<strong>Amazon Web Services</strong> (<strong>AWS</strong>) provides a load balancer called Amazon ELB, which can be used to distribute traffic between Amazon EC2 servers, that is, application servers. Obviously, it difficult to predict the total number of EC2 instances you would need to scale your application; therefore, AWS also provides <a id="id688" class="indexterm"/>something called <strong>auto scaling</strong>, which can add/remove EC2 instances as needed. Therefore, to host a large-scale application, Amazon is the best choice. It also provides lots of other cloud services to scale and deploy your application.</p><p>In case you don't want to worry about scaling, deploying, and managing your servers, then <a id="id689" class="indexterm"/>you can use cloud services such as Heroku, which makes it much easier to achieve all this, and you just need to worry about the application code—that's it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec110"/>Summary</h1></div></div></div><p>In this chapter, we saw a lot of services and libraries to scale and secure Node.js applications. We saw various vulnerabilities and how to prevent them. Make sure you take regular backups of your data so that even if your app is hacked, you will still have a chance to get the application running again as the data is not lost. Obviously, there is a lot more to learn about scaling and securing Node.js applications as this is an unending topic and new things come up regularly.</p></div></body></html>