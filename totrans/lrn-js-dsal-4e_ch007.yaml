- en: 6 Linked Lists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 链表
- en: '**Before you begin: Join our book community on Discord**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**在开始之前：加入我们的 Discord 书籍社区**'
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“学习 JavaScript 数据结构与算法 4e”频道下找到“早期访问订阅”）。
- en: '![](img/file0.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![img/file0.png](img/file0.png)'
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
- en: 'In previous chapters, we explored data structures stored sequentially in memory.
    Now, we turn our attention to linked lists, a dynamic and linear data structure
    with a non-sequential memory arrangement. This chapter delves into the inner workings
    of linked lists, covering:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了存储在内存中的顺序数据结构。现在，我们将注意力转向链表，这是一种动态且线性的数据结构，具有非顺序的内存排列。本章深入探讨了链表的内部工作原理，包括：
- en: The linked list data structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表数据结构
- en: Techniques for adding and removing elements from linked lists
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和删除链表元素的技术
- en: 'Variations of linked lists: doubly linked lists, circular linked lists and
    sorted linked lists'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表的变体：双向链表、循环链表和有序链表
- en: How linked lists can be used to implement other data structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表如何用于实现其他数据结构
- en: Implementing other data structures with linked lists
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用链表实现其他数据结构
- en: Exercises using linked lists
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用链表的练习
- en: The linked list data structure
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表数据结构
- en: 'Arrays, a ubiquitous data structure found in nearly every programming language,
    offer a convenient way to store collections of elements. Their familiar bracket
    notation (`[]`) provides direct access to individual items. However, arrays come
    with a key limitation: their fixed size in most languages. This constraint makes
    inserting or removing elements from the beginning or middle a costly operation
    due to the need to shift remaining elements. While JavaScript provides methods
    to handle this, the underlying process still involves these shifts, impacting
    performance.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数组，这是一种几乎在每种编程语言中都存在的通用数据结构，提供了一种方便的方式来存储元素集合。它们熟悉的括号表示法（`[]`）提供了对单个项目的直接访问。然而，数组存在一个关键限制：在大多数语言中它们的固定大小。这种限制使得从开始或中间插入或删除元素变得昂贵，因为需要移动剩余的元素。虽然
    JavaScript 提供了处理这些的方法，但底层过程仍然涉及这些移动，影响性能。
- en: 'Linked lists, like arrays, maintain a sequential collection of elements. However,
    unlike arrays where elements occupy contiguous memory locations, linked lists
    store elements as nodes scattered throughout memory. Each node encapsulates the
    element''s data (the information or value we want to store) along with a reference
    (also called a pointer or link) that directs you to the next node in the sequence.
    The following diagram illustrates this linked list structure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 链表，就像数组一样，维护一个元素的顺序集合。然而，与数组中元素占据连续内存位置不同，链表将元素存储为散布在内存中的节点。每个节点封装了元素的数据（我们想要存储的信息或值）以及一个引用（也称为指针或链接），它指向序列中的下一个节点。以下图展示了这种链表结构：
- en: '![The structure of a linked list data structure with nodes, data and pointers](img/file28.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![The structure of a linked list data structure with nodes, data and pointers](img/file28.png)'
- en: The structure of a linked list data structure with nodes, data and pointers
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 具有节点、数据和指针的链表数据结构
- en: The first node is called the *head*, and the last node usually points to `null`
    (or `undefined`) to indicate the end of the list.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个节点被称为 *头*，最后一个节点通常指向 `null`（或 `undefined`）以指示列表的末尾。
- en: A key advantage of linked lists over conventional arrays is the ability to insert
    or remove elements without the costly overhead of shifting other items. However,
    this flexibility comes with the tradeoff of using pointers, requiring greater
    care during implementation. While arrays allow direct access to elements at any
    position, linked lists necessitate traversal from the head to reach elements in
    the middle, potentially impacting access time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的数组相比，链表的一个关键优势是能够在不涉及其他项的昂贵开销的情况下插入或删除元素。然而，这种灵活性是以使用指针为代价的，这要求在实现过程中更加小心。虽然数组允许直接访问任何位置的元素，但链表需要从头部遍历才能到达中间的元素，这可能会影响访问时间。
- en: However, linked lists are not the best data structure if you need to access
    elements by their index (like we do with arrays). This is because we need to traverse
    the list from the beginning, which can be slower. Linked lists also require additional
    memory for storage, as each node requires extra memory to store the pointer(s),
    which can be overhead for simple data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要通过索引访问元素（就像我们使用数组那样），链表并不是最佳的数据结构。这是因为我们需要从列表的开始遍历，这可能会更慢。链表还需要额外的内存来存储，因为每个节点都需要额外的内存来存储指针，这对于简单的数据来说可能是额外的开销。
- en: 'Linked lists have numerous real-world applications due to their flexibility
    and efficiency in handling dynamic data. One of the popular examples are media
    players. Media players use linked lists to organize and manage playlists. Adding,
    removing, and rearranging songs or videos are straightforward operations on a
    linked list as represented as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其灵活性和处理动态数据的效率，链表在现实世界中有着众多的应用。一个流行的例子是媒体播放器。媒体播放器使用链表来组织和管理工作表。添加、删除和重新排列歌曲或视频在链表上作为以下表示是直接的操作：
- en: '![A media player representation using linked list as data structure](img/file29.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![使用链表作为数据结构的媒体播放器表示](img/file29.png)'
- en: A media player representation using linked list as data structure
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链表作为数据结构的媒体播放器表示
- en: 'There are different types of linked lists:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着不同类型的链表：
- en: '**Singly Linked List** (or simply Linked List): each node has a pointer to
    the next node.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单链表**（或简称链表）：每个节点都有一个指向下一个节点的指针。'
- en: '**Doubly Linked List**: Each node has pointers to both the next and previous
    nodes.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双链表**：每个节点都有指向下一个和前一个节点的指针。'
- en: '**Circular Linked List**: The last node points back to the head, forming a
    loop.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环链表**：最后一个节点指向头节点，形成一个循环。'
- en: In this chapter, we will cover the linked list as well as these variations,
    but let's start with the easiest data structure first.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍链表及其变体，但让我们先从最简单的数据结构开始。
- en: Creating the LinkedList class
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建LinkedList类
- en: Now that you understand what a linked list is, let's start implementing our
    data structure. We are going to create our own class to represent a linked list.
    The source code for this chapter is available inside the `src/06-linked-list`
    folder. We will start by creating the `linked-list.js` file which will contain
    our class that represents our data structure as well the node needed to store
    the data and the pointer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了链表是什么，让我们开始实现我们的数据结构。我们将创建自己的类来表示链表。本章的源代码位于`src/06-linked-list`文件夹中。我们将首先创建`linked-list.js`文件，该文件将包含表示我们的数据结构的类以及存储数据和指针所需的节点。
- en: 'To start, we define a `LinkedListNode` class, which represents each element
    (or node) within our linked list. Each node holds the `data` we want to store,
    along with a reference (`next`) pointing to the subsequent node:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`LinkedListNode`类，它代表链表中的每个元素（或节点）。每个节点包含我们想要存储的数据，以及一个指向后续节点的引用（`next`）：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By default, a newly created node's `next` pointer is initialized to `null`.
    However, the constructor also allows you to specify the next node if it is known
    beforehand, proving beneficial in certain scenarios.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新创建的节点的`next`指针被初始化为`null`。然而，构造函数还允许你在事先知道的情况下指定下一个节点，这在某些场景中非常有用。
- en: 'Next, we declare the `LinkedList` class which represents our linked list data
    structure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明`LinkedList`类，它代表我们的链表数据结构：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This class begins by declaring a private `#head` reference, pointing to the
    first node (element) in the list. To avoid traversing the entire list whenever
    we need the element count, we also maintain a private `#size` variable. Both properties
    are kept private using the `#` prefix to ensure encapsulation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类首先声明一个私有的`#head`引用，指向列表中的第一个节点（元素）。为了避免每次需要元素计数时都遍历整个列表，我们还维护一个私有的`#size`变量。这两个属性都使用`#`前缀来保持私有，以确保封装。
- en: 'The `LinkedList` class will provide the following methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`类将提供以下方法：'
- en: '`append(data)`: adds a new node containing the `data` at the end of the list.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append(data)`: 在列表的末尾添加包含`data`的新节点。'
- en: '`prepend(data)`: adds a new node containing the `data` at the beginning (head)
    of the list.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepend(data)`: 在列表的头部（头节点）添加包含`data`的新节点。'
- en: '`insert(data, position)`: inserts a new node containing the `data` at the specified
    `position` in the list.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert(data, position)`: 在列表的指定`position`位置插入包含`data`的新节点。'
- en: '`removeAt(position)`: removes the node at the specific `position` in the list.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeAt(position)`: 从列表的特定`position`位置删除节点。'
- en: '`remove(data)`: removes the first node containing the specified `data` from
    the list.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(data)`: 从列表中删除包含指定 `data` 的第一个节点。'
- en: '`indexOf(data)`: returns the index of the first node containing the specified
    `data`. If the `data` is not found, returns `-1`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf(data)`: 返回包含指定 `data` 的第一个节点的索引。如果 `data` 未找到，则返回 `-1`。'
- en: '`isEmpty()`: returns `true` if the list does not contain any elements, and `false` otherwise.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 如果列表不包含任何元素，则返回 `true`，否则返回 `false`。'
- en: '`clear()`:removes all the elements from the list.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 从列表中删除所有元素。'
- en: '`size()`:returns the number of elements currently in the list.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 返回当前列表中元素的数量。'
- en: '`toString()`:returns a string representation of the linked list, showing the
    elements in order.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`: 返回链表的字符串表示形式，按顺序显示元素。'
- en: We will implement each of these methods in detail in the following sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中详细实现这些方法。
- en: Appending elements to the end of the linked list
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将元素追加到链表末尾
- en: 'When appending an element at the end of a LinkedList, we encounter two scenarios:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 LinkedList 的末尾追加元素时，我们会遇到两种情况：
- en: 'Empty list: the list has no existing elements, and we are adding the first
    one.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表：列表没有现有元素，我们正在添加第一个元素。
- en: 'Non-empty list: the list already contains elements, and we are adding a new
    one to the end of the list.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非空列表：列表已经包含元素，我们正在将其添加到列表的末尾。
- en: 'The following is the implementation of the `append` method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `append` 方法的实现：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Regardless of the list's state, the first step is to create a new node to hold
    the data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无论列表的状态如何，第一步是创建一个新节点以保存数据。
- en: For the first scenario, we check if the list is empty. The condition `!this.#head`
    evaluates to `true` if the `#head` pointer is currently `null` (or `undefined`),
    indicating an empty list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，我们检查列表是否为空。如果 `#head` 指针当前为 `null`（或 `undefined`），则条件 `!this.#head`
    评估为 `true`，表示列表为空。
- en: if the list is empty, the newly created node (`newNode`) becomes the head of
    the list. Its next pointer will automatically be `null` since it is the only node
    in the list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为空，新创建的节点（`newNode`）将成为列表的头部。由于它是列表中唯一的节点，其下一个指针将自动为 `null`。
- en: 'Let''s see a visual representation of these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些步骤的直观表示：
- en: '![Adding a new element to an empty linked list](img/file30.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![向空链表添加新元素](img/file30.png)'
- en: Adding a new element to an empty linked list
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 向空链表添加新元素
- en: 'In the scenario where our linked list is not empty, we have a reference only
    to the `head` (the first node). To append a new element to the end, we need to
    traverse the list:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的链表不为空的情况下，我们只有一个对 `head`（第一个节点）的引用。要向末尾添加新元素，我们需要遍历列表：
- en: We start by assigning a temporary variable, often called current, to the `head`
    of the list. This variable will act as our pointer as we move through the list.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先将一个临时变量，通常称为 `current`，赋值给列表的 `head`。这个变量将作为我们在列表中移动时的指针。
- en: Using a while loop, we continuously move current to the next node (`current.next`)
    as long as `current.next` is not `null`. This means we keep moving until we reach
    the last node, whose next pointer will be `null`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环，我们不断地将 `current` 移动到下一个节点（`current.next`），只要 `current.next` 不是 `null`。这意味着我们继续移动，直到达到最后一个节点，其下一个指针将是
    `null`。
- en: Once the loop terminates, `current` will be referencing the last node. We simply
    set `current.next` to our new node, effectively adding it to the end of the list.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦循环终止，`current` 将引用最后一个节点。我们只需将 `current.next` 设置为我们的新节点，从而将其添加到列表的末尾。
- en: Finally, we increment the `size` to reflect the addition of the new node.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们增加 `size` 以反映新节点的添加。
- en: 'The following diagram exemplifies appending an element to the end of a linked
    list when it is not empty:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了在链表不为空时将元素追加到末尾的情况：
- en: '![Adding a new element to the end of a linked list](img/file31.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![向链表末尾添加新元素](img/file31.png)'
- en: Adding a new element to the end of a linked list
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新元素到链表末尾
- en: Prepending a new element to the linked list
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向链表添加新元素到头部
- en: 'Adding a new element as the head (beginning) of the linked list is a simple
    operation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将新元素添加到链表的头部（开始处）是一个简单的操作：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first step is to create a new node to hold the `data`. Importantly, we pass
    the current `head` of the list as the second argument to the constructor. This
    sets the `next` pointer of the new node to the current `head`, establishing the
    link. If the list is empty, the current head is `null`, so the new node's `next`
    reference will also be `null`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新节点以保存`data`。重要的是，我们将列表的当前`head`作为构造函数的第二个参数传递。这设置了新节点的`next`指针指向当前`head`，从而建立了链接。如果列表为空，当前头部是`null`，因此新节点的`next`引用也将是`null`。
- en: 'Next, we update the `head` of the list to point to the newly created node (`newNode`).
    Since the new node is already linked to the previous head, the entire list is
    seamlessly adjusted. And finally, we increase the `size` of the list to reflect
    the addition of the new node. The following diagram exemplifies this scenario:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新列表的`head`，使其指向新创建的节点（`newNode`）。由于新节点已经与之前的头部节点相连，整个列表可以无缝调整。最后，我们增加列表的`size`以反映新节点的添加。以下图表展示了这一场景：
- en: '![Prepending a new element to the linked list](img/file32.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![在链表中预加一个新元素](img/file32.png)'
- en: Prepending a new element to the linked list
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表中预加一个新元素
- en: Inserting a new element at a specific position
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在特定位置插入新元素
- en: 'Now, let''s explore how to insert an element at any position within the linked
    list. For this, we will create an `insert` method, taking both the `data` and
    the desired `position` as parameters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨如何在链表的任何位置插入元素。为此，我们将创建一个`insert`方法，该方法接受`data`和期望的`position`作为参数：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We first verify if the provided `position` is valid using a helper private
    method, `#isInvalidPosition`. A valid position is one that falls within the bounds
    of the list (0 to size-1). If the position is invalid, the method returns `false`
    to indicate the failure to insert. The helper method is declared as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一个名为`#isInvalidPosition`的辅助私有方法验证提供的`position`是否有效。有效的位置是指落在列表边界内（0到size-1）的位置。如果位置无效，该方法返回`false`以表示插入失败。辅助方法声明如下：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we create the new node that will hold the data we are inserting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建将保存要插入的数据的新节点。
- en: The first scenario is handling the insertion at the head of the list. if the
    `position` is 0, it means we're inserting at the beginning of the list. In this
    case, we can simply call the prepend method we defined earlier and return `true`
    for success.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是处理在列表头部插入。如果`position`为0，这意味着我们在列表的起始位置进行插入。在这种情况下，我们可以简单地调用我们之前定义的`prepend`方法，并返回`true`表示成功。
- en: If not inserting at the head, it means we will need to traverse the list. To
    do so, we will need a helper variable we will name current and set it to the first
    node (`head`). We also need a second helper variable to assist with the linkage
    of the new node we will name `previous`. And we also initialize an index variable
    to keep track of our position as we traverse.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是在头部插入，这意味着我们需要遍历列表。为此，我们需要一个名为`current`的辅助变量，并将其设置为第一个节点（`head`）。我们还需要第二个辅助变量来帮助连接新节点，我们将其命名为`previous`。同时，我们初始化一个索引变量以跟踪我们在遍历中的位置。
- en: Then, we will traverse the list until we reach the desired position. To do so,
    the `while` loop iterates until the index matches the `position`. In each iteration,
    we move `previous` to the `current` node and the `current` to the `next` node.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将遍历列表，直到达到期望的位置。为此，`while`循环迭代，直到索引与`position`匹配。在每次迭代中，我们将`previous`移动到`current`节点，并将`current`移动到下一个节点。
- en: 'After the loop, `previous` points to the node before the insertion point, and
    `current` points to the node at the insertion point. We adjust the next pointers:
    `newNode.next` is set to current (the node that was originally at the insertion
    point), and `previous.next` is set to `newNode`, effectively inserting the new
    node into the list.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，`previous`指向插入点之前的节点，而`current`指向插入点的节点。我们调整下一个指针：`newNode.next`设置为`current`（原本位于插入点的节点），而`previous.next`设置为`newNode`，从而将新节点有效地插入到列表中。
- en: 'Let''s see this scenario in action in the following diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下图表中看看这个场景的实际操作：
- en: '![Inserting an element in the middle of a linked list](img/file33.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![在链表中间插入元素](img/file33.png)'
- en: Inserting an element in the middle of a linked list
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表中间插入元素
- en: It is very important to have variables referencing the nodes we need to control
    so that we do not lose the link between the nodes. We could work with only one
    variable (`previous`), but it would be harder to control the links between the
    nodes. For this reason, it is better to declare an extra variable to help us with
    these references.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拥有引用我们需要控制的节点的变量非常重要，这样我们才不会丢失节点之间的链接。我们可以只用一个变量（`previous`），但这样控制节点之间的链接会更困难。因此，最好声明一个额外的变量来帮助我们进行这些引用。
- en: Returning the position of an element
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回元素的索引
- en: Now that we know how to traverse the list until a desired position, it makes
    easier to traverse the list searching for a particular element and returning its
    index.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何遍历列表直到达到期望的位置，这使得在列表中搜索特定元素并返回其索引变得更容易。
- en: 'Let''s review the `indexOf` method implementation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`indexOf`方法的实现：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We start by creating a variable `current` to track the node in the list and
    it is initially set to the head of the list. We also initialize an index variable
    to 0, representing the current position in the list.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个变量`current`来跟踪列表中的节点，它最初设置为列表的头部。我们还初始化一个索引变量为0，代表列表中的当前位置。
- en: The `while` loop continues if current is not `null` (we have not reached the
    end of the list). In each iteration, we check if the data property of the current
    node matches the element we are searching for, and if so, it returns the index
    of the element's position.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前节点不是`null`时（我们还没有到达列表的末尾），`while`循环会继续。在每次迭代中，我们检查当前节点的数据属性是否与我们要搜索的元素匹配，如果是，则返回该元素位置的索引。
- en: We can pass a custom comparison function to the `indexOf` method. This function
    should take two arguments (two different objects) and return `true` if the two
    objects match according to the desired criteria, or `false` otherwise. With this
    function, we gain flexibility and the ability to define exactly how elements are
    compared, accommodating complex data structures and different matching criteria.
    By default, we simply compare the references of the objects in case no comparison
    function is informed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将自定义比较函数传递给`indexOf`方法。这个函数应该接受两个参数（两个不同的对象）并返回`true`，如果根据所需标准两个对象匹配，否则返回`false`。有了这个函数，我们获得了灵活性，能够精确地定义元素的比较方式，以适应复杂的数据结构和不同的匹配标准。如果没有提供比较函数，默认情况下我们只是比较对象的引用。
- en: Using a comparison function is also a standard practice in other programming
    languages. If you prefer, instead of passing the function to the method directly,
    we can have the function in the constructor of the `LinkedList` class so it can
    be used whenever needed.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用比较函数也是其他编程语言中的标准做法。如果你愿意，我们可以在`LinkedList`类的构造函数中放置该函数，这样就可以在需要时使用它，而不是直接将函数传递给方法。
- en: If the element is not found in the current node, it increments the `index` and
    moves to the next node.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素在当前节点中未找到，则增加`index`并移动到下一个节点。
- en: If the loop completes without finding the element, it means the element is not
    present in the list. In this case, the method returns `-1` (which is an industry
    convention).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环完成而没有找到元素，这意味着元素不在列表中。在这种情况下，该方法返回`-1`（这是行业惯例）。
- en: It is useful to have an `indexOf` method as we can use this method to search
    for elements, and we will also reuse it to remove elements from the list.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个`indexOf`方法很有用，因为我们可以使用这个方法来搜索元素，我们也会重用它来从列表中删除元素。
- en: Removing an element from a specific position
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从特定位置删除元素
- en: 'Let''s explore how we can remove elements from our linked list. Similar to
    appending, there are two scenarios to consider: removing the first element (the
    head) and removing any other element.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何从我们的链表中删除元素。与追加类似，有两个场景需要考虑：删除第一个元素（头节点）和删除任何其他元素。
- en: 'The `removeAt` code is presented as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeAt`代码如下所示：'
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will delve into this code step by step:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步深入这段代码：
- en: First, we check if the list is not empty, if it is empty, we return an error.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查列表是否为空，如果为空，则返回错误。
- en: Next, we check if the given position is valid using the `#isInvalidPosition`
    helper method.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`#isInvalidPosition`辅助方法检查给定位置是否有效。
- en: 'Then we check for the first scenario: removing the first element of the list,
    and if so, we will segregate the logic into a separate private method for better
    organization and understanding.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们检查第一种情况：删除列表的第一个元素，如果是这样，我们将逻辑分离到一个单独的私有方法中，以获得更好的组织和理解。
- en: Finally, if we are not removing the first element, it means we are removing
    the last element or from the middle of the list. For the singly linked list, both
    scenarios are similar, so we will handle them in a separate private method.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果我们不是删除第一个元素，这意味着我们正在删除最后一个元素或链表中间的元素。对于单链表，这两种情况是相似的，因此我们将它们在单独的私有方法中处理。
- en: While removing a node from a linked list might seem intricate, breaking down
    the problem into smaller, more manageable steps can simplify the process. This
    approach is a valuable technique not only for linked list operations but also
    for tackling complex tasks in various real-world scenarios.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从链表中删除节点可能看起来很复杂，但将问题分解成更小、更易于管理的步骤可以简化过程。这种方法不仅对于链表操作是一种有价值的技巧，而且在各种现实场景中解决复杂任务时也非常有用。
- en: 'Let''s dive into the `#removeFromHead` method, which is our first scenario
    to remove the first element from the linked list:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解`#removeFromHead`方法，这是我们第一个场景，用于从链表中删除第一个元素：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the `position` is 0 (indicating the head), we first store a reference to
    the head node in `nodeToRemove`. Then, we simply shift the `head` pointer to its
    `next` node, effectively disconnecting the original `head`. Finally, we decrease
    the list size and return the data of the removed node.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`position`是0（表示头部），我们首先将头节点存储在`nodeToRemove`中。然后，我们简单地移动`head`指针到它的`next`节点，从而有效地断开原始的`head`。最后，我们减少链表的大小并返回被删除节点的数据。
- en: 'The following diagram exemplifies this action:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这一动作：
- en: '![Removing the element at the head of the linked list](img/file34.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![删除链表头部的元素](img/file34.png)'
- en: Removing the element at the head of the linked list
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 删除链表头部的元素
- en: 'Next, let''s check the code to remove a node from the middle or from the end
    of a linked list:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查删除链表中间或末尾节点的代码：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For any position other than 0, we need to traverse the list to find the node
    to remove. In previous sections, we used the `while` loop, and we will use the
    `for` loop now to demonstrate there are different ways of achieving the same result.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除了位置0之外的其他位置，我们需要遍历链表以找到要删除的节点。在之前的章节中，我们使用了`while`循环，现在我们将使用`for`循环来展示有不同方式可以达到相同的结果。
- en: We keep two variables, `nodeToRemove` (starting at the first element) and `previous`
    to navigate through the list. At each iteration, we shift `previous` to the current
    node (`nodeToRemove`) and move `nodeToRemove` to the next node.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留两个变量，`nodeToRemove`（从第一个元素开始）和`previous`，以遍历链表。在每次迭代中，我们将`previous`移动到当前节点（`nodeToRemove`），并将`nodeToRemove`移动到下一个节点。
- en: Once we reach the target position, `previous` points to the node before the
    one we want to remove, and `nodeToRemove` points to the node itself. We adjust
    the `previous` node's `next` pointer to skip over the `nodeToRemove` node, linking
    it directly to the node after `nodeToRemove`. This effectively removes the `nodeToRemove`
    node. Then we can decrement the size of the list and return the removed data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达目标位置，`previous`指向我们想要删除的节点之前的节点，而`nodeToRemove`指向节点本身。我们调整`previous`节点的`next`指针以跳过`nodeToRemove`节点，直接链接到`nodeToRemove`之后的节点。这实际上删除了`nodeToRemove`节点。然后我们可以减少链表的大小并返回被删除的数据。
- en: 'The following diagram exemplifies removing an element from the middle of the
    list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了从链表中间删除元素的过程：
- en: '![Removing the element from the middle of the linked list](img/file35.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![从链表中间删除元素](img/file35.png)'
- en: Removing the element from the middle of the linked list
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从链表中间删除元素
- en: 'The logic also works for the last element of the list, as the `nodeToRemove`''s
    next value will be `null` and when `previous.next` receives `null`, it automatically
    unlinks the last element. The following diagram exemplifies this action:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑也适用于链表的最后一个元素，因为`nodeToRemove`的下一个值将是`null`，当`previous.next`接收到`null`时，它将自动断开最后一个元素的链接。以下图表展示了这一动作：
- en: '![Removing the last element of the linked list](img/file36.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![删除链表的最后一个元素](img/file36.png)'
- en: Removing the last element of the linked list
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 删除链表的最后一个元素
- en: Now that we know how to remove any element from the list, let's learn how to
    search for a specific element and then remove it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从列表中删除任何元素，让我们学习如何搜索特定元素然后删除它。
- en: Searching and removing an element from the linked list
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在链表中搜索和删除元素
- en: 'Sometimes, we need to remove an element from a linked list without knowing
    its exact position. In this scenario, we require a method that searches for the
    element based on its data and then removes it. We''ll create a `remove` method
    that accepts the target data and an optional `compareFunction` for custom comparison
    logic:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要在不了解其确切位置的情况下从链表中删除一个元素。在这种情况下，我们需要一个基于其数据搜索元素并删除它的方法。我们将创建一个接受目标数据和可选的`compareFunction`以进行自定义比较逻辑的`remove`方法：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The method first utilizes the `indexOf` method we created earlier to determine
    the position (`index`) of the first node whose data matches the provided `data`
    using the optional `compareFunction`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先利用我们之前创建的`indexOf`方法来确定第一个数据与提供的`data`匹配的节点的位置（`index`），使用可选的`compareFunction`。
- en: If `indexOf` returns -1, it means the element is not found in the list. In this
    case, we return `null`. If the element is found, the method calls `removeAt(index)`
    to remove the node at that position. The `removeAt` method returns the removed
    data, which is then returned by the `remove` method as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`indexOf`返回-1，则表示元素未在列表中找到。在这种情况下，我们返回`null`。如果找到元素，该方法将调用`removeAt(index)`来删除该位置的节点。`removeAt`方法返回被删除的数据，然后该方法也返回该数据。
- en: Checking if it is empty, clearing and getting the current size
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查是否为空、清除和获取当前大小
- en: 'The `isEmpty`, get `size` and `clear` methods are very similar to the ones
    we created in previous chapter and provide fundamental operations for managing
    our linked list. Let''s look at them anyways:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty`、获取`size`和`clear`方法与我们在上一章中创建的方法非常相似，为管理我们的链表提供了基本操作。让我们无论如何看看它们：'
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is an explanation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个解释：
- en: '`isEmpty`: this method checks if the linked list is empty. It does so by simply
    comparing the private `#size` property to zero. If #size is 0, it means the list
    has no elements and returns `true`; otherwise, it returns `false`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty`：此方法检查链表是否为空。它是通过简单地比较私有`#size`属性与零来完成的。如果`#size`是0，则表示列表没有元素，并返回`true`；否则，它返回`false`。'
- en: '`size`: this method directly returns the value of the private `#size` property,
    providing the current number of elements in the linked list.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：此方法直接返回私有`#size`属性的值，提供链表中当前元素的数量。'
- en: '`clear`: this method is used to completely empty the linked list. It does this
    by setting the `#head` pointer to `null`, effectively disconnecting all nodes.
    The `#size` property is also reset to 0.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear`：此方法用于完全清空链表。它是通过将`#head`指针设置为`null`来完成的，从而有效地断开所有节点。`#size`属性也被重置为0。'
- en: Transforming the linked list into a string
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将链表转换为字符串
- en: 'The last method is the `toString` method, which its primary goal is to provide
    a string representation of the linked list. This is incredibly useful for debugging,
    logging, or simply displaying the contents of the list to users:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法是`toString`方法，其主要目标是提供链表的字符串表示形式。这对于调试、记录或简单地向用户显示列表内容非常有用：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A temporary variable `current` is initialized to point to the `head` of the
    linked list. This will be our cursor as we traverse the list. An empty string
    `objString` is created to accumulate the string representation of the list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个临时变量`current`以指向链表的`head`。这将是我们在遍历列表时的游标。创建一个空字符串`objString`以累积列表的字符串表示形式。
- en: The `while` loop continues as long as `current` is not `null`. This means we
    will iterate over each node in the list until we reach the end (where the last
    node's next property is `null`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在`current`不是`null`的情况下继续。这意味着我们将遍历列表中的每个节点，直到我们到达末尾（最后一个节点的`next`属性是`null`）。'
- en: The `#elementToString` private method (which we have coded in previous chapters)
    is called to convert the data stored in the `current` node (`current.data`) into
    a string representation. This string is then appended (added) to the `objString`.
    We advance the `current` cursor to the `next` node of the list, and if there is
    a next node (we have not reached the end yet), a comma and a space are appended
    to the `objString` to separate the elements in the final string representation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为`#elementToString`的私有方法（我们在前面的章节中已经编写过）被调用来将存储在`current`节点（`current.data`）中的数据转换为字符串表示形式。然后，这个字符串被附加（添加）到`objString`中。我们将`current`游标向前推进到列表的`next`节点，如果有下一个节点（我们还没有到达末尾），则将逗号和空格附加到`objString`中以分隔最终字符串表示中的元素。
- en: Doubly linked lists
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向链表
- en: 'The difference between a doubly linked list and a normal or singly linked list
    is that in a linked list we make the link from one node to the next one only,
    while in a doubly linked list, we have a double link: one for the next element
    and one for the previous element, as shown in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 双链表与普通或单链表之间的区别在于，在链表中我们只从一个节点到下一个节点建立链接，而在双链表中，我们有一个双链接：一个用于下一个元素，一个用于前一个元素，如下面的图所示：
- en: '![Doubly linked list with previous and next nodes](img/file37.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![带有前一个和下一个节点的双链表](img/file37.png)'
- en: Doubly linked list with previous and next nodes
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 带有前一个和下一个节点的双链表
- en: 'Let''s get started with the changes that are needed to implement the `DoublyLinkedList`
    class. We will start by declaring the node of our doubly linked list:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实施`DoublyLinkedList`类所需的变化。我们首先声明我们的双链表节点：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In a doubly linked list, each node maintains two references:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中，每个节点维护两个引用：
- en: '`next`: a pointer to the next node in the list.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`next`：指向列表中下一个节点的指针。'
- en: '`previous`: a pointer to the previous node in the list.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`previous`：指向列表中前一个节点的指针。'
- en: This dual linking enables efficient traversal in both directions. To accommodate
    this structure, we add the `previous` pointer to our `DoublyLinkedListNode` class.
    The constructor is designed to be flexible. By default, both the `next` and `previous`
    pointers are initialized to `null`. This allows us to create new nodes that are
    not yet connected to other nodes in the list. When inserting a node into the list,
    we explicitly update these pointers to establish the correct links within the
    list.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种双向链接使得双向遍历变得高效。为了适应这种结构，我们在`DoublyLinkedListNode`类中添加了`previous`指针。构造函数被设计成灵活的。默认情况下，`next`和`previous`指针都被初始化为`null`。这允许我们创建尚未连接到列表中其他节点的节点。当将节点插入列表中时，我们明确更新这些指针以在列表内建立正确的链接。
- en: 'Next, we will declare our `DoublyLinkedList` class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将声明我们的`DoublyLinkedList`类：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A key distinction of a doubly linked list is that it tracks both the `head`
    (the first node) and the `tail` (the last node). This bidirectional linking enables
    us to traverse the list efficiently in either direction, offering greater flexibility
    compared to a singly linked list.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 双链表的一个关键区别是它跟踪了`head`（第一个节点）和`tail`（最后一个节点）。这种双向链接使我们能够高效地在两个方向上遍历列表，与单链表相比提供了更大的灵活性。
- en: 'While the core functionality of a doubly linked list remains similar to a singly
    linked list, the implementation differs. In a doubly linked list, we must manage
    two references for each node: `next` (pointing to the following node) and `previous`
    (pointing to the preceding node). Therefore, when inserting or removing nodes,
    we need to carefully update not only the next pointers (as in a singly linked
    list) but also the previous pointers to maintain the correct links throughout
    the list. This means that methods like `append`, `prepend`, `insert`, and `removeAt`
    will require modifications to accommodate this dual linking.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然双链表的核心功能与单链表相似，但实现方式不同。在双链表中，我们必须为每个节点管理两个引用：`next`（指向后续节点）和`previous`（指向前一个节点）。因此，在插入或删除节点时，我们不仅需要仔细更新下一个指针（如单链表中的情况），还需要更新前一个指针以保持整个列表的正确链接。这意味着像`append`、`prepend`、`insert`和`removeAt`这样的方法将需要修改以适应这种双向链接。
- en: Let's dive into each of the modifications needed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每个必要的修改。
- en: Appending a new element
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新元素
- en: Inserting a new element in a doubly linked list is very similar to a linked
    list. The difference is that in the linked list, we only control one pointer (`next`),
    and in the doubly linked list we need control both the `next` and `previous` references.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中插入新元素与链表非常相似。区别在于在链表中我们只控制一个指针（`next`），而在双链表中我们需要控制`next`和`previous`两个引用。
- en: 'Let''s see how the append method behaves in the doubly linked list:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`append`方法在双链表中的表现：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we are trying to add a new element to the end of the list, we run into
    two different scenarios: if the list is empty or not empty. If the list is empty
    (`head` is `null`), we create a new node (`newNode`) and set both the `head` and
    `tail` to this new node. Since it is the only node, it becomes both the start
    and end.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图将新元素添加到列表末尾时，会遇到两种不同的场景：如果列表为空或非空。如果列表为空（`head`为`null`），我们创建一个新的节点（`newNode`）并将`head`和`tail`都设置为这个新节点。由于它是唯一的节点，它既是开始也是结束。
- en: 'If the list is not empty, the beauty of the doubly linked list is we do not
    have to traverse the entire list to get to its end. As we have the `tail` reference,
    we can simply link the new node''s `previous` pointer to the tail, then we will
    link the tail''s next pointer to the new node, and finally, we update the `tail`
    reference to the new node. The order of this operations is crucial, as if we update
    the `tail` prematurely, we will lose the reference to the original last node,
    making it impossible to correctly link the new node to the end of the list. The
    following diagram demonstrates the process of adding a new node to the end of
    the list:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表不为空，双链表的优点是我们不需要遍历整个列表就能到达其末尾。因为我们有`tail`引用，我们可以简单地将新节点的`previous`指针链接到尾部，然后我们将尾部的`next`指针链接到新节点，最后我们将`tail`引用更新为新节点。这些操作的顺序至关重要，因为如果我们提前更新`tail`，我们将失去对原始最后一个节点的引用，这将使得无法正确地将新节点链接到列表的末尾。以下图示了将新节点添加到列表末尾的过程：
- en: '![Appending a new node to the doubly linked list](img/file38.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![在双链表中添加新节点](img/file38.png)'
- en: Appending a new node to the doubly linked list
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中添加新节点
- en: Next, let's review and changes needed to prepend an element to a doubly linked
    list.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾并修改需要添加到双链表中的元素。
- en: Prepending a new element to the doubly linked list
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在双链表中添加新元素到头部
- en: 'Prepending a new element to the doubly linked list is not much different then
    prepending a new element to a singly linked list:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中添加新元素到头部与在单链表中添加新元素到头部没有太大区别：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, we have two scenarios. In case the list is empty, the behavior is identical
    to the `append` method, the new node becomes both the `head` and `tail`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有两种情况。如果列表为空，其行为与`append`方法相同，新节点同时成为`head`和`tail`。
- en: If the list is not empty, we set the `next` pointer of the new node (`newNode`)
    to the current `head`. We then update the `previous` pointer of the current head
    to reference the `newNode`. Finally, we update the `head` to be the `newNode`,
    as it is now the first node in the list.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表不为空，我们将新节点（`newNode`）的`next`指针设置为当前的`head`。然后我们更新当前头节点的`previous`指针以引用`newNode`。最后，我们将`head`更新为`newNode`，因为它现在是列表中的第一个节点。
- en: In a singly linked list, the prepend operation only requires updating the `next`
    pointer of the new node and the `head` of the list. However, in a doubly linked
    list, we must also update the `previous` pointer of the original head node to
    ensure the bidirectional links are maintained.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在单链表中， prepend 操作只需要更新新节点的`next`指针和列表的`head`。然而，在双链表中，我们必须还更新原始头节点的`previous`指针以确保双向链接得到维护。
- en: Now that we are able to add elements at the head and at the tail of the list,
    let's checkout how to insert at any position.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够向列表的头部和尾部添加元素，让我们来看看如何在任何位置插入。
- en: Inserting a new element at any position
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在任何位置插入新元素
- en: 'Inserting an element at an arbitrary position within a doubly linked list requires
    some additional considerations compared to simply appending or prepending. Let''s
    see how to insert at any position:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中任意位置插入元素需要比简单地追加或 prepend 考虑更多的因素。让我们看看如何在任何位置插入：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s review case by case:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个案例进行回顾：
- en: First, we start by checking if the position if valid, and if not, we return
    `false` to indicate the insertion was not successful.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查位置是否有效，如果不是，我们返回`false`以指示插入操作未成功。
- en: Next, we will check if the insertion is at the `head`, and if so, we can reuse
    the `prepend` method, and return `true` to indicate the insertion was a success.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查插入操作是否在`head`处，如果是的话，我们可以重用`prepend`方法，并返回`true`以指示插入操作成功。
- en: The next scenario is in case the insertion is at the end of the list, and if
    so, we can reuse the `append` method and return `true`. Checking for this case
    will avoid traversing the list to get to its end.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一种情况是，如果插入操作在列表的末尾，那么我们可以重用`append`方法并返回`true`。检查这种情况将避免遍历整个列表以到达其末尾。
- en: If not prepending and not appending, it means the position is in the middle
    of the list, and for this case, we will create a private method that will hold
    the logic.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果既不是在头部添加也不是在尾部添加，这意味着位置在列表的中间，对于这种情况，我们将创建一个私有方法来保存逻辑。
- en: 'In case the position is in the middle, we will use the `#insertInTheMiddle`
    to help us organize the steps better as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位置在中间，我们将使用`#insertInTheMiddle`来帮助我们更好地组织步骤，如下所示：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, we will create a new node and we will traverse the list to the desired
    position. After the `for` loop, we will insert the new node between the previous
    and current references with the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个新节点，并将遍历列表到所需的位置。在`for`循环之后，我们将按照以下步骤在之前的引用和当前引用之间插入新节点：
- en: The `newNode`'s `next` pointer is set to the `currentNode`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newNode`的`next`指针被设置为`currentNode`。'
- en: The `newNode`'s `previous` pointer is set to the `previousNode`. With these
    two steps, we have the new node partially inserted to the list. What we need to
    do now is updating the references of the existing nodes in the list to the new
    node.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newNode`的`previous`指针被设置为`previousNode`。通过这两个步骤，我们已经将新节点部分插入到列表中。我们现在需要更新列表中现有节点的引用到新节点。'
- en: The `currentNode`'s `previous` pointer is updated to point to the `newNode`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`currentNode`的`previous`指针被更新，以指向`newNode`。'
- en: The `previousNode`'s `next` pointer is updated to point to the `newNode`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`previousNode`的`next`指针被更新，以指向`newNode`。'
- en: 'The following diagram exemplifies this scenario:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这一场景：
- en: '![Inserting a new node in the middle of the doubly linked list](img/file39.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![在双链表的中间插入新节点](img/file39.png)'
- en: Inserting a new node in the middle of the doubly linked list
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表的中间插入一个新节点
- en: Given we have a refence to both the `head` and the `tail` of the list, an improvement
    we could make to this method is checking if position is greater than size/2, then
    it would be best to iterate from the end than start from the beginning (by doing
    so, we will have to iterate through fewer elements from the list).
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于我们有一个对列表的`head`和`tail`的引用，我们可以对这个方法进行改进，即检查位置是否大于大小/2，如果是，则最好从末尾开始迭代而不是从开头开始（这样做，我们将不得不遍历列表中的更少元素）。
- en: Now that we have learned the details of how to handle two pointers for inserting
    nodes in the list, let's see how to remove an element from any position.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何处理列表中插入节点时两个指针的细节，让我们看看如何从任何位置删除一个元素。
- en: Removing an element from a specific position
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从特定位置删除一个元素
- en: 'Let''s delve into the details and differences of removing an element from any
    position of the list:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解删除列表中任何位置的元素的细节和区别：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will start by checking if the list is empty and for an invalid position.
    If the list is empty or if the given position is outside the valid range of the
    list (0 to size-1), we throw a `RangeError`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查列表是否为空，以及是否有一个无效的位置。如果列表为空或给定位置超出了列表的有效范围（0到size-1），我们将抛出一个`RangeError`。
- en: 'Next, we will check for the three possible scenarios:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查三种可能的情况：
- en: If the removal is from the head (first position of the list)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是从头部（列表的第一个位置）进行删除
- en: If the removal is from the tail (last position of the list)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是从尾部（列表的最后一个位置）进行删除
- en: or from the middle of the list.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或从列表的中间删除。
- en: Let's dive into each scenario.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每个场景。
- en: 'The first scenario is if are removing the first element. Following is the code
    for the `#removeFromHead` private method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是删除第一个元素。以下是`#removeFromHead`私有方法的代码：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We start by creating a reference (`nodeToRemove`) to the current head node.
    This is important because we will need to return its data later. Next, the `head`
    reference is now moved to the `next` node in the list.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个引用（`nodeToRemove`）到当前头节点。这很重要，因为我们需要稍后返回其数据。接下来，`head`引用现在移动到列表中的下一个节点。
- en: If there was only one node, `nodeToRemove.next` will be `null`, and the `head`
    will become `null`, indicating an empty list.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个节点，`nodeToRemove.next`将是`null`，`head`将变为`null`，表示列表为空。
- en: If the list is not empty after the removal, the `previous` reference of the
    new `head` node (which was previously the second node) is set to `null`, since
    it is now the first node and has no predecessor.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果删除后列表不为空，新`head`节点的`previous`引用（之前是第二个节点）被设置为`null`，因为它现在是第一个节点，没有前驱。
- en: If the list is empty, both `head` and `tail` need to be set to `null`. As we
    have already set the `head` to `null` in the second line of the method, we only
    need to set the `tail` to `null`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为空，则`head`和`tail`都需要设置为`null`。由于我们在方法的第二行已经将`head`设置为`null`，我们只需要将`tail`设置为`null`。
- en: 'Finally, we remove the `nodeToRemove` next reference in case there is any.
    The following diagram demonstrates this scenario:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要移除`nodeToRemove`的下一个引用，以防万一。以下图表展示了这一场景：
- en: '![Removing the node at the head of a doubly linked list](img/file40.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![从双链表头部删除节点](img/file40.png)'
- en: Removing the node at the head of a doubly linked list
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从双链表的头部移除节点
- en: 'The next scenario is checking if we are removing the tail (the last element).
    Following is the code for the `#` `removeFromTail` private method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个场景是检查我们是否在移除尾部（最后一个元素）。以下是对 `#` `removeFromTail` 私有方法的代码：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After creating the reference to the current `tail` node, the `tail` reference
    is moved to the `previous` node. We need to check if the list if empty after the
    removal – this is similar to the `removeFromHead` method behavior. If the list
    is not empty, we set the new tail''s `next` pointer is set to `null`. If the list
    is empty, we also update the `head` to `null`. The following diagram demonstrates
    this scenario:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建对当前 `tail` 节点的引用后，将 `tail` 引用移动到 `previous` 节点。我们需要检查移除后列表是否为空——这与 `removeFromHead`
    方法的行为类似。如果列表不为空，我们将新尾部的 `next` 指针设置为 `null`。如果列表为空，我们还将 `head` 更新为 `null`。以下图展示了这个场景：
- en: '![Removing the node at the tail of a doubly linked list](img/file41.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![从双链表的尾部移除节点](img/file41.png)'
- en: Removing the node at the tail of a doubly linked list
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从双链表的尾部移除节点
- en: 'The last scenario is removing the element from the middle of the list. The
    method `#removeFromMiddle` is listed as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个场景是从列表的中间移除元素。`#removeFromMiddle` 方法如下所示：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the position is not the `head` or `tail`, we need to traverse the list
    to find the node and correctly adjust the surrounding nodes' references. We start
    by declaring a `nodeToRemove`, referencing it to the `head` as the starting point
    and we will move this node through the list as we iterate. The `previousNode`
    keeps track of the node just before the `nodeToRemove` and it starts with `null`
    since the head has no previous node.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于位置不是 `head` 或 `tail`，我们需要遍历列表以找到节点并正确调整周围节点的引用。我们首先声明一个 `nodeToRemove`，将其引用到
    `head` 作为起点，我们将在迭代过程中移动这个节点。`previousNode` 跟踪 `nodeToRemove` 之前的节点，它从 `null` 开始，因为头部没有前一个节点。
- en: The `for` loop continues until `index` matches the `position` we want to remove
    from. Inside the loop, we update `previousNode` to be the current node (before
    we move it) and we mode `nodeToRemove` to the next node.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环会一直继续，直到 `index` 与我们想要移除的位置 `position` 匹配。在循环内部，我们更新 `previousNode`
    为当前节点（在我们移动它之前）并将 `nodeToRemove` 设置为下一个节点。'
- en: When the loop stops, `nodeToRemove` will reference the node we want to remove.
    So, we skip the reference to the `nodeToRemove` by making the `previousNode`'s
    `next` pointer point to the node after `nodeToRemove`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环停止时，`nodeToRemove` 将引用我们想要移除的节点。因此，我们通过使 `previousNode` 的 `next` 指针指向 `nodeToRemove`
    后的节点来跳过对 `nodeToRemove` 的引用。
- en: Then, `nodeToRemove.next.previous = previousNode` updates the `previous` pointer
    of the node after `nodeToRemove` to point back to `previousNode`. This step is
    essential to maintain the doubly linked list's structure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`nodeToRemove.next.previous = previousNode` 更新了 `nodeToRemove` 后的节点的 `previous`
    指针，使其指向 `previousNode`。这一步对于维护双链表的结构至关重要。
- en: At last, we remove the `nodeToRemove` next and previous references, we decrease
    the size of the list and return the removed data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们移除 `nodeToRemove` 的下一个和前一个引用，减少列表的大小，并返回被移除的数据。
- en: 'The following diagram demonstrates this scenario:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了这个场景：
- en: '![Removing the node from the middle of a doubly linked list](img/file42.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![从双链表的中间移除节点](img/file42.png)'
- en: Removing the node from the middle of a doubly linked list
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从双链表的中间移除节点
- en: 'To check the implementation of other methods of the doubly linked list (as
    they are the same as the linked list), refer to the source code of the book. The
    download link of the source code is mentioned in the Preface of the book, and
    it can also be accessed at: [http://github.com/loiane/javascript-datastructures-algorithms](http://github.com/loiane/javascript-datastructures-algorithms).'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要检查双链表其他方法的实现（因为它们与链表相同），请参考书籍的源代码。源代码的下载链接在书的序言中提到，也可以在以下网址访问：[http://github.com/loiane/javascript-datastructures-algorithms](http://github.com/loiane/javascript-datastructures-algorithms)。
- en: Circular linked lists
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环链表
- en: 'A circular linked list is a variation of a linked list where the last node''s
    next pointer (or `tail.next`) references the first node (`head`) instead of being
    `null` or `undefined`. This creates a closed loop structure., as we can see in
    the following diagram:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表是链表的一种变体，其中最后一个节点的下一个指针（或 `tail.next`）引用第一个节点（`head`），而不是 `null` 或 `undefined`。这创建了一个封闭的环状结构，如下面的图所示：
- en: '![The structure of a circular linked list](img/file43.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![循环链表的结构](img/file43.png)'
- en: The structure of a circular linked list
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表的结构
- en: 'A doubly circular linked list has `tail.next` pointing to the head element,
    and `head.previous` pointing to the `tail` element as showed as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 双向循环链表有`tail.next`指向头元素，`head.previous`指向`tail`元素，如下所示：
- en: '![The structure of a doubly circular linked list](img/file44.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![双向循环链表的结构](img/file44.png)'
- en: The structure of a doubly circular linked list
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 双向循环链表的结构
- en: The key difference between circular and regular (linear) linked lists is that
    there is no explicit *end* to a circular linked list. You can continuously traverse
    the list starting from any node and eventually return to the starting point.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表与常规（线性）链表的关键区别在于，循环链表没有明确的*结束*。你可以从任何节点开始连续遍历列表，最终返回到起点。
- en: We will implement a singly circular linked list, and you can find the bonus
    source code for a doubly circular linked list in the source code from this book.
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将实现一个单链循环链表，你可以在本书的源代码中找到双向循环链表的奖励源代码。
- en: 'Let''s check the code to create the `CircularLinkedList` class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看创建`CircularLinkedList`类的代码：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will utilize the same `LinkedListNode` structure for our `CircularLinkedList`
    class, as the fundamental node structure remains the same. However, the circular
    nature of the list introduces some key differences in how we implement operations
    like `append`, `prepend`, and `removeAt`. Let's explore these modifications in
    detail.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用相同的`LinkedListNode`结构为我们的`CircularLinkedList`类，因为基本的节点结构保持不变。然而，列表的循环性质引入了一些关键差异，这些差异体现在我们实现`append`、`prepend`和`removeAt`等操作的方式上。让我们详细探讨这些修改。
- en: Appending a new element
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 追加新元素
- en: 'Appending a new element to a circular linked list shares similarities with
    appending to a standard linked list, but with a few key distinctions due to the
    circular structure. Let''s see the code for the `append` method:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将新元素追加到循环链表与追加到标准链表有相似之处，但由于循环结构，有一些关键的区别。让我们看看`append`方法的代码：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We start by creating the new node to hold that data. Then checks if the list
    is empty. If so, the new node becomes the `head`, and its next pointer is set
    to point back to itself, completing the circle. The following diagram exemplifies
    the first scenario:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新节点来保存数据。然后检查列表是否为空。如果是，新节点成为`head`，其下一个指针设置为指向自身，完成循环。以下图例展示了第一种情况：
- en: '![Appending an element as the only node in a circular linked list](img/file45.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![循环链表中追加唯一节点](img/file45.png)'
- en: Appending an element as the only node in a circular linked list
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环链表中追加一个元素作为唯一的节点
- en: If the list is not empty, we need to find the last node. This is done by traversing
    the list starting from the `head` until we find a node whose next pointer points
    back to the `head`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表不为空，我们需要找到最后一个节点。这是通过从`head`开始遍历列表，直到找到一个其下一个指针指向`head`的节点来完成的。
- en: 'Once the last node (`current`) is found, its next pointer is updated to reference
    the `newNode`. The `newNode`''s next pointer is then set to the `head`, re-establishing
    the circular link. The following diagram exemplifies the second scenario:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到最后一个节点（`current`），其下一个指针被更新为引用`newNode`。然后`newNode`的下一个指针设置为指向`head`，重新建立循环链接。以下图例展示了第二种情况：
- en: '![Appending an element in a non-empty circular linked list](img/file46.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![非空循环链表中追加元素](img/file46.png)'
- en: Appending an element in a non-empty circular linked list
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 非空循环链表中追加元素
- en: Next, let's see how to insert a new node in the beginning of a circular linked
    list.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在循环链表的开始处插入一个新节点。
- en: Prepending a new element
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预先添加一个新元素
- en: 'Prepending a new element in a circular linked list involves a few key steps
    due to the circular nature of the structure. Let''s check out the code first:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于循环结构的性质，在循环链表中预先添加一个新元素涉及几个关键步骤。让我们首先查看代码：
- en: '[PRE25]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We start by creating a new node to hold the data. The `next` pointer of the
    new node is immediately set to the current `head` of this list, to maintain the
    circular nature of the list after the insertion.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新节点来保存数据。新节点的`next`指针立即设置为该列表的当前`head`，以保持插入后的列表的循环性质。
- en: If the list is empty, the new node becomes the `head` and we add a self-reference
    as the next pointer.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为空，新节点成为`head`，我们添加一个自引用作为下一个指针。
- en: 'In case the list is not empty, we find the last element, so we can update its
    `next` pointer to the new node, which will become the new `head`. The diagram
    below exemplifies this action:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表不为空，我们找到最后一个元素，因此我们可以更新它的`next`指针到新节点，该节点将成为新的`head`。下面的图例展示了这一动作：
- en: '![Prepending an element in a non-empty circular linked list](img/file47.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![在非空循环链表中预加一个元素](img/file47.png)'
- en: Prepending an element in a non-empty circular linked list
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在非空循环链表中预加一个元素
- en: If we want to insert a new element in the middle of the list, the code is the
    same as the `LinkedList` class since no changes will be applied to the last or
    first nodes of the list.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在列表中间插入一个新元素，代码与`LinkedList`类相同，因为不会对列表的最后一个或第一个节点应用任何更改。
- en: Removing an element from a specific position
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从特定位置移除元素
- en: For the removal of an element of a circular linked list, we will cover removing
    the first and the last elements, since removing an element from the middle is
    the same behavior as the singly linked list.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于循环链表元素的移除，我们将介绍移除第一个和最后一个元素，因为从中间移除元素的行为与单链表相同。
- en: 'First, let''s cover removing from the head, with the code as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何从头部移除，代码如下：
- en: '[PRE26]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Following is the explanation:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对此的解释：
- en: First, we traverse the list to find the last node.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们遍历列表以找到最后一个节点。
- en: Next, we set the head to the next node to remove the first element.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将头节点设置为下一个节点以移除第一个元素。
- en: Then we make the last node point to the new `head`, closing the circle.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将最后一个节点指向新的`head`，闭合循环。
- en: Finally, if the removed node was the only one in the list, set the `head` to
    `null` to reset it.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果移除的节点是列表中唯一的节点，将`head`设置为`null`以重置它。
- en: 'The diagram below exemplifies this action:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图例展示了这一动作：
- en: '![Removing the head from a circular linked list](img/file48.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![从循环链表中移除头部](img/file48.png)'
- en: Removing the head from a circular linked list
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从循环链表中移除头部
- en: 'Now, let''s check out how to remove from the end of the list:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何从列表末尾移除：
- en: '[PRE27]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And following is the explanation:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对此的解释：
- en: If there is only one node (`head` points to itself), removing it makes the list
    empty. We update `head` to `null` and return the removed data.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果只有一个节点（`head`指向自身），移除它会使列表为空。我们更新`head`为`null`并返回移除的数据。
- en: If the list is not empty, we need to find the last node and the second last
    node (`previousNode`). So we traverse the list until we reach its end, updating
    the `previous` and the `last` node references.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果列表不为空，我们需要找到最后一个节点和第二个最后一个节点（`previousNode`）。因此，我们遍历列表直到其末尾，更新`previous`和`last`节点引用。
- en: When the `while` loop is finished, the `lastNode` is the one we want to remove.
    So we set `previousNode.next = this.#head` to make the second last node point
    to the head, skipping the last node, which is now removed.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`while`循环结束时，`lastNode`就是我们想要移除的节点。因此，我们设置`previousNode.next = this.#head`，使第二个最后一个节点指向头部，跳过现在已被移除的最后一个节点。
- en: We decrement the list size and return the removed `data`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们减少列表大小并返回移除的`data`。
- en: 'The diagram below exemplifies this action:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图例展示了这一动作：
- en: '![Removing the tail from a circular linked list](img/file49.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![从循环链表中移除尾部](img/file49.png)'
- en: Removing the tail from a circular linked list
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从循环链表中移除尾部
- en: Now that we know how to add and remove elements from three different types of
    linked lists, let's put all these concepts learned by creating a fun project!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何从三种不同类型的链表中添加和移除元素，让我们通过创建一个有趣的项目来应用我们学到的所有这些概念！
- en: Creating a media player using a linked list
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用链表创建媒体播放器
- en: 'To solidify our understanding of linked lists and explore new concepts, let''s
    build a real-world application: a media player! This project will leverage the
    linked list structure and introduce us to additional techniques like working with
    doubly circular linked lists and ordered insertion.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们对链表的理解并探索新的概念，让我们构建一个现实世界的应用：一个媒体播放器！这个项目将利用链表结构，并介绍我们如何使用双循环链表和有序插入等额外技术。
- en: 'Before we dive in, let''s outline the core features of our media player:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，让我们概述一下媒体播放器的核心功能：
- en: 'Ordered song insertion: add songs to the playlist based on song title.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序歌曲插入：根据歌曲标题将歌曲添加到播放列表中。
- en: 'Sequential playback: simulate playing songs one after the other in the playlist''s
    order.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序播放：模拟按播放列表顺序播放歌曲。
- en: 'Navigation: easily jump to the previous or next song.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航：轻松跳转到上一首或下一首歌。
- en: 'Continuous repeat: automatically loop the playlist, playing songs repeatedly.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续重复：自动循环播放列表，重复播放歌曲。
- en: 'The following image represents the media player we will develop using linked
    lists:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像表示我们将使用链表开发的媒体播放器：
- en: '![A media player using doubly circular linked list](img/file50.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![使用双循环链表的多媒体播放器](img/file50.png)'
- en: A media player using doubly circular linked list
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双循环链表的多媒体播放器
- en: 'To model our media player''s playlist, we will use a custom node structure
    to represent each song. Following is the `MediaPlayerSong` class:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟我们的媒体播放器的播放列表，我们将使用自定义节点结构来表示每首歌曲。以下是 `MediaPlayerSong` 类：
- en: '[PRE28]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Each `MediaPlayerSong` node stores:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `MediaPlayerSong` 节点存储：
- en: '`songTitle`: the title of the song.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`songTitle`: 歌曲的标题。'
- en: '`previous`: a reference to the previous song node in the playlist (or a reference
    to the last song, if it is the first song).'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previous`: 对播放列表中前一个歌曲节点的引用（如果是第一首歌曲，则是最后一个歌曲的引用）。'
- en: '`next`: a reference to the next song node in the playlist (or a reference to
    the first song if it is the last song).'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`: 对播放列表中下一个歌曲节点的引用（如果是最后一首歌曲，则是第一个歌曲的引用）。'
- en: This will allow us to implement the continuous repeat feature of our media player.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够实现媒体播放器的连续重复功能。
- en: 'Next, let''s define the structure of our `MediaPlayer` class:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义我们的 `MediaPlayer` 类的结构：
- en: '[PRE29]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `MediaPlayer` class maintains:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaPlayer` 类维护：'
- en: '`#firstSong`: a reference to the first `MediaPlayerSong` in the playlist.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#firstSong`: 对播放列表中第一个 `MediaPlayerSong` 的引用。'
- en: '`#lastSong`: a reference to the last `MediaPlayerSong` in the playlist.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#lastSong`: 对播放列表中最后一个 `MediaPlayerSong` 的引用。'
- en: '`#size`: the count of songs currently in the playlist.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#size`: 当前播放列表中歌曲的数量。'
- en: '`#playingSong`: a reference to the `MediaPlayerSong` that is currently being
    played.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#playingSong`: 对当前正在播放的 `MediaPlayerSong` 的引用。'
- en: Before we can start playing songs, we need to be able to add songs to our playlist.
    Let's see how to do it in the next section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始播放歌曲之前，我们需要能够将歌曲添加到我们的播放列表中。让我们看看下一节如何实现。
- en: Adding new songs by title order (sorted insertion)
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按标题顺序添加新歌曲（排序插入）
- en: To maintain an alphabetically ordered playlist, we will implement a method called
    `addSongByTitle`. This method will insert a new song into the correct position
    based on its title, ensuring the playlist remains sorted.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持字母顺序的播放列表，我们将实现一个名为 `addSongByTitle` 的方法。此方法将根据歌曲的标题将新歌曲插入正确的位置，确保播放列表保持排序。
- en: Behind the scenes, we are doing a sorted insertion in a doubly circular linked
    list!
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在幕后，我们正在双循环链表中执行排序插入操作！
- en: 'We will start by declaring the method to insert a new song:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先声明插入新歌曲的方法：
- en: '[PRE30]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is a brief explanation before we start diving into the details:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解细节之前，这里有一个简要的解释：
- en: We start by creating a new `MediaPlayerSong` node with the given `newSongTitle`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用给定的 `newSongTitle` 创建一个新的 `MediaPlayerSong` 节点。
- en: If the playlist is empty, we call a private method `#insertEmptyPlayList` to
    handle the insertion of the first song.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果播放列表为空，我们调用私有方法 `#insertEmptyPlayList` 来处理第一首歌曲的插入。
- en: For non-empty playlists, we callsa private method `#findIndexOfSortedSong` to
    determine the correct `position` where the new song should be inserted to maintain
    alphabetical order.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于非空播放列表，我们调用私有方法 `#findIndexOfSortedSong` 来确定新歌曲应该插入的正确 `位置` 以保持字母顺序。
- en: 'Based on the returned `position`, the method dispatches the insertion to one
    of three private methods:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据返回的 `位置`，方法将插入操作调度到三个私有方法之一：
- en: '`#insertAtBeginning`: inserts the new song at the start of the list.'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#insertAtBeginning`: 在列表开头插入新歌曲。'
- en: '`#insertAtEnd`: inserts the new song at the end of the list.'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#insertAtEnd`: 在列表末尾插入新歌曲。'
- en: '`#insertInMiddle`: inserts the new song in the middle of the list at the specified
    position.'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#insertInMiddle`: 在指定位置将新歌曲插入列表中间。'
- en: Finally, the `#size` of the playlist is incremented to reflect the addition
    of the new song.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将播放列表的 `#size` 增加以反映新歌曲的添加。
- en: Let's review each of the steps with more details.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地回顾每个步骤。
- en: Inserting into an empty playlist
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向空播放列表插入
- en: 'In this scenario, we are handling an insertion into a doubly circular linked
    list. Let''s dive into the `#insertEmptyPlayList` method:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们正在处理双循环链表的插入。让我们深入了解 `#insertEmptyPlayList` 方法：
- en: '[PRE31]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are assigning the new song to the `firstSong` (head) and the `lastSong` (tail).
    And to keep the circular references, we set the new song's `next` and `previous`
    references to itself.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新歌曲分配给 `firstSong`（头）和 `lastSong`（尾）。为了保持循环引用，我们将新歌曲的 `next` 和 `previous`
    引用设置为自身。
- en: The next step in the logic is to find the position we need to insert the song
    in case the playlist is not empty.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑的下一步是找到在播放列表不为空的情况下需要插入歌曲的位置。
- en: Finding the alphabetically sorted insertion position
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找字母顺序排序的插入位置
- en: 'We are dealing with a complex scenario: sorted insertion into a doubly circular
    linked list. To simplify this, we will tackle it in two phases, the first one
    determining the correct position (index) where the new song should be inserted
    to maintain alphabetical order and the second one being the insertion itself.
    So, for now, let''s focus on finding the correct insertion index:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理一个复杂场景：将排序插入到双循环链表中。为了简化，我们将分两个阶段来处理，第一阶段是确定新歌曲应该插入以保持字母顺序的正确位置（索引），第二阶段是实际的插入操作。所以，现在让我们专注于找到正确的插入索引：
- en: '[PRE32]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We will traverse the list to find the position of the insertion. To do so, we
    will use a cursor called `currentSong`. We also need an index counter `i`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遍历列表以找到插入的位置。为此，我们将使用一个名为 `currentSong` 的光标。我们还需要一个索引计数器 `i`。
- en: We will loop from the first song up until the last song of the playlist. Inside
    the loop, we will call a helper method that contains the logic to compare the
    songs. If the result of the helper method is 0 (duplicate song) or a positive
    number, it means we found the position.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从播放列表的第一首歌曲循环到最后一首歌曲。在循环内部，我们将调用一个包含比较歌曲逻辑的辅助方法。如果辅助方法的结果是 0（重复歌曲）或正数，这意味着我们找到了位置。
- en: If the new song does not belong at the current position, we move to the next
    song in the list. If the loop completes without returning, it means the new song
    should be inserted at the beginning (index 0).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新歌曲不属于当前位置，我们将移动到列表中的下一首歌曲。如果循环完成而没有返回，这意味着新歌曲应该插入到开始位置（索引 0）。
- en: 'Next let''s check the code for the `#compareSongs` method:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查 `#compareSongs` 方法的代码：
- en: '[PRE33]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This method is a helper function used to compare two song titles alphabetically,
    considering locale-specific sorting rules. The localeCompare method returns a
    number that indicates the sorting relationship between the two strings:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是一个辅助函数，用于按字母顺序比较两首歌曲标题，考虑地区特定的排序规则。localeCompare 方法返回一个数字，表示两个字符串之间的排序关系：
- en: 'Negative number: `songTitle1` comes before `songTitle2` in alphabetical order.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负数：`songTitle1` 在字母顺序中排在 `songTitle2` 之前。
- en: '0 (zero): `songTitle1` and `songTitle2` are considered equal in the current
    locale.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0（零）：在当前地区，`songTitle1` 和 `songTitle2` 被认为是相等的。
- en: 'Positive number: `songTitle1` comes after `songTitle2` in alphabetical order.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正数：`songTitle1` 在字母顺序中排在 `songTitle2` 之后。
- en: You can modify this method as needed to customize how you would like to compare
    song titles.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要修改此方法以自定义您想要比较歌曲标题的方式。
- en: Now that we know the position we need to insert, let's review each of the methods.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了需要插入的位置，让我们回顾一下每个方法。
- en: Inserting at the beginning of the playlist
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在播放列表开头插入
- en: 'Let''s check how to prepend a new song in a playlist that is not empty:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查如何在非空播放列表中添加一首新歌曲：
- en: '[PRE34]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Given our next song, we will point its next reference to the first song (head)
    and its last reference to the last song (tail). Then, we update the existing first
    song's previous reference to the new song, and the last song's next reference
    also to the new song. Finally, we update the first song reference to the new song.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的下一首歌曲，我们将将其 `next` 引用指向第一首歌曲（头），并将其 `last` 引用指向最后一首歌曲（尾）。然后，我们更新现有第一首歌曲的前一个引用到新歌曲，并更新最后一首歌曲的
    `next` 引用到新歌曲。最后，我们更新第一首歌曲引用到新歌曲。
- en: Next, let's see how to append a new song.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何追加一首新歌曲。
- en: Inserting at the end of the playlist
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在播放列表末尾插入
- en: 'Let''s review how we can add new songs at the end of the playlist with the
    following method:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何使用以下方法在播放列表末尾添加新歌曲：
- en: '[PRE35]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Given the new song, when inserting at the end, we need to link its next reference
    to the first song and its previous reference to the last song so we can keep the
    doubly circular references. Then, we need to update the last song's next reference
    to the new song, the first song's previous reference also to the new song to also
    keep the circular reference, and finally, update the reference of the last song
    to the new song.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 给定新歌曲，当插入到末尾时，我们需要将其下一个引用链接到第一首歌曲，并将其上一个引用链接到最后一首歌曲，这样我们就可以保持双重循环引用。然后，我们需要更新最后一首歌曲的下一个引用为新歌曲，第一首歌曲的前一个引用也更新为新歌曲以保持循环引用，最后，更新最后一首歌曲的引用为新歌曲。
- en: Now, the last step is to insert a song in the middle of the playlist.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一步是在播放列表的中间插入一首歌曲。
- en: Inserting in the middle of the playlist
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在播放列表中间插入
- en: 'Now that we have covered the insertion at the head and at the tail of the doubly
    circular linked list, let''s dive into the details to insert a new element in
    the middle of the list as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了在双链表的头部和尾部插入，让我们深入了解如何在列表的中间插入一个新元素，如下所示：
- en: '[PRE36]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Inserting in the middle is the same as inserting in a doubly linked list. As
    we have both the previous and next references, we do not need two references.
    So first, we find the position we are looking for, and we stop at one position
    before the one we want. Then, we link the new song's next reference to the current's
    next reference, and the new song's previous reference to the current song. With
    this step, we have inserted the new song in the list, and now we need to fix the
    remaining links. So, we fix the current songs' next node's previous reference
    to the new song, and the current song's next reference to the new song.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间插入与在双链表中插入相同。因为我们既有前一个也有下一个引用，所以我们不需要两个引用。所以首先，我们找到我们正在寻找的位置，并在我们想要的位置之前停止。然后，我们将新歌曲的下一个引用链接到当前歌曲的下一个引用，并将新歌曲的前一个引用链接到当前歌曲。通过这一步，我们已经将新歌曲插入到列表中，现在我们需要修复剩余的链接。因此，我们修复当前歌曲的下一个节点的上一个引用为新歌曲，以及当前歌曲的下一个引用为新歌曲。
- en: With the songs added to the playlist, we can start playing them!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 将歌曲添加到播放列表后，我们可以开始播放它们！
- en: Playing a song
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放歌曲
- en: 'When we select the play song feature of our media player, the goal is to start
    playing the song. For our simulation, it means assigning the first song to the
    playing song reference, as described as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择媒体播放器的播放歌曲功能时，目标是开始播放歌曲。对于我们的模拟，这意味着将第一首歌曲分配给正在播放的歌曲引用，如下所述：
- en: '[PRE37]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If there are no songs in the playlist, we can return null, or if you prefer,
    you can throw an error as well. Then, we assign the reference of the playing song
    to the first song, and we return the title we are playing.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果播放列表中没有歌曲，我们可以返回`null`，或者如果您愿意，也可以抛出一个错误。然后，我们将正在播放的歌曲的引用分配给第一首歌曲，并返回我们正在播放的标题。
- en: Playing the next or previous song
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放下一首或上一首歌曲
- en: 'The behavior to play the next or previous song are very similar. The difference
    is on the reference we are updating: `previous` or `next`. Let''s review the behavior
    for playing the next song first:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 播放下一首或上一首歌曲的行为非常相似。区别在于我们正在更新的引用：“前一个”或“下一个”。让我们首先回顾播放下一首歌曲的行为：
- en: '[PRE38]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If there are no songs in the playlist, we return `null`. Also, if there is not
    any song playing at the moment, we play the first song. However, if there are
    songs playing and we decide we want to play the next song, we simply update the
    playing song with its next reference and we return the song title.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果播放列表中没有歌曲，我们返回`null`。同样，如果此时没有歌曲正在播放，我们将播放第一首歌曲。然而，如果有歌曲正在播放，而我们决定想播放下一首歌曲，我们只需更新正在播放的歌曲为其下一个引用，并返回歌曲标题。
- en: 'The code of the previous method is also very similar:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 之前方法的代码也非常相似：
- en: '[PRE39]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The difference is if there are songs playing, and we want to play the previous
    song, we update the current song with its previous reference.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于如果有歌曲正在播放，而我们想播放上一首歌曲，我们只需更新当前歌曲为其上一个引用。
- en: In both cases, when we reach the end of the playlist, or the first song of the
    playlist, we can keep playing, because of the circular doubly references.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，当我们到达播放列表的末尾或播放列表的第一首歌曲时，我们可以继续播放，因为有了双重循环引用。
- en: Using our media player
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用我们的媒体播放器
- en: 'Now that we have built our media player, let''s put it to the test. We will
    start by creating an instance and adding our favorite songs:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经构建了我们的媒体播放器，让我们来测试一下。我们将从创建一个实例并添加我们最喜欢的歌曲开始：
- en: '[PRE40]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After our playlist is created, we can start playing songs and seeing the output:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的播放列表创建后，我们可以开始播放歌曲并查看输出：
- en: '[PRE41]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can select the next song multiple times and check that the continuous playback
    works as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以多次选择下一首歌曲并检查连续播放是否按以下方式工作：
- en: '[PRE42]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And if we go the other way around it, selecting the previous button:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们反过来选择上一个按钮：
- en: '[PRE43]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we review the output, we can confirm the songs were inserted in an alphabetical
    order.
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们回顾输出，可以确认歌曲是按字母顺序插入的。
- en: Have fun playing with our media player!
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 享受使用我们的媒体播放器吧！
- en: Reviewing the efficiency of the linked lists
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查链表的效率
- en: 'Let''s review the efficiency of each method by review the Big O notation in
    terms of time of execution:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看每种方法的执行时间的大O符号来检查每个方法的效率：
- en: '| **Method** | **Singly** | **Doubly** | **Circular** | **Explanation** |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **单链表** | **双链表** | **循环链表** | **说明**|'
- en: '| `append` | *O(n)* | *O(1)* | *O(n)* | In singly and circular lists, we must
    traverse to the end to append. Doubly lists have a tail reference for constant
    time append. |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `append` | *O(n)* | *O(1)* | *O(n)* | 在单链表和循环链表中，我们必须遍历到末尾才能追加。双链表有尾引用，可以实现常数时间的追加。|'
- en: '| `prepend` | *O(1)* | *O(1)* | *O(n)* | All lists can add a new node as the
    head directly. However, in circular lists, we must update the last node''s next
    pointer to the new head. |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `prepend` | *O(1)* | *O(1)* | *O(n)* | 所有列表都可以直接添加新节点作为头部。然而，在循环链表中，我们必须更新最后一个节点的下一个指针到新的头部。|'
- en: '| `insert` | *O(n)* | *O(n)* | *O(n)* | For all types, we need to traverse
    to the position to insert. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `insert` | *O(n)* | *O(n)* | *O(n)* | 对于所有类型，我们都需要遍历到插入位置。|'
- en: '| `removeAt` | *O(n)* | *O(n)* | *O(n)* | Similar to insertion, traversal to
    the position is required. Doubly lists have an optimization when removing the
    tail ( *O(1)* ), but this is less common than removing from an arbitrary position.
    |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `removeAt` | *O(n)* | *O(n)* | *O(n)* | 与插入类似，需要遍历到指定位置。双链表在删除尾部时有一个优化（*O(1)*），但这比从任意位置删除要少见。|'
- en: '| `remove` | *O(n)* | *O(n)* | *O(n)* | Searching for the data takes *O(n)*
    in all cases, then removal itself is either *O(1)* (if the node is found at the
    head) or *O(n)* (traversing to the node). |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | *O(n)* | *O(n)* | *O(n)* | 在所有情况下，搜索数据需要 *O(n)*，然后删除本身要么是 *O(1)*（如果节点在头部找到）或
    *O(n)*（遍历到节点）。|'
- en: '| `indexOf` | *O(n)* | *O(n)* | *O(n)* | In the worst case, we might need to
    traverse the entire list to find the data or determine it''s not present. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `indexOf` | *O(n)* | *O(n)* | *O(n)* | 在最坏的情况下，我们可能需要遍历整个列表来找到数据或确定其不存在。|'
- en: '| `isEmpty` | *O(1)* | *O(1)* | *O(1)* | Checking if the list is empty is a
    simple size reference check. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `isEmpty` | *O(1)* | *O(1)* | *O(1)* | 检查列表是否为空是一个简单的尺寸参考检查。|'
- en: '| `size` | *O(1)* | *O(1)* | *O(1)* | The size is tracked as a property and
    directly accessible. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `size` | *O(1)* | *O(1)* | *O(1)* | 大小作为一个属性跟踪，可以直接访问。|'
- en: '| `clear` | *O(1)* | *O(1)* | *O(1)* | Clearing a list simply involves resetting
    the head pointer (and tail in doubly linked lists), which is a constant-time operation.
    |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `clear` | *O(1)* | *O(1)* | *O(1)* | 清空列表只需重置头指针（在双链表中还包括尾指针），这是一个常数时间操作。|'
- en: '| `toString` | *O(n)* | *O(n)* | *O(n)* | Building a string representation
    requires visiting each node. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `toString` | *O(n)* | *O(n)* | *O(n)* | 构建字符串表示需要访问每个节点。|'
- en: Doubly linked lists often have a performance advantage in append due to the
    tail pointer. Otherwise, all three list types have similar time complexities for
    most operations, as they all involve some degree of traversal.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 由于尾指针的存在，双链表在追加操作中通常具有性能优势。否则，所有三种列表类型在大多数操作中的时间复杂度相似，因为它们都涉及某种程度的遍历。
- en: Space complexity is *O(n)* for all three types, as the space used is proportional
    to the number of elements stored.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种类型的空间复杂度都是 *O(n)*，因为使用的空间与存储的元素数量成正比。
- en: 'If we had to compare liked lists to arrays, there are pros and cons to each
    data structure. Let''s review a few key points:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将链表与数组进行比较，每种数据结构都有其优缺点。让我们回顾几个关键点：
- en: '*Linked Lists*: prefer linked lists when:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链表*：在以下情况下优先选择链表：'
- en: You need a dynamic collection where the number of elements changes frequently.
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要一个动态集合，其中元素的数目频繁变化。
- en: You perform frequent insertions and deletions, especially at the beginning or
    middle of the list.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您经常在列表的开始或中间进行插入和删除操作。
- en: You do not require random access to elements.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不需要随机访问元素。
- en: '*Arrays*: prefer arrays when:'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组*：在以下情况下优先选择数组：'
- en: You know the maximum size of the collection beforehand.
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您事先知道集合的最大大小。
- en: You need fast random access to elements by index.
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要通过索引快速访问元素。
- en: You primarily need to iterate through the elements sequentially.
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您主要需要按顺序遍历元素。
- en: 'We have also learned about stacks, queues and deques earlier in this book and
    we have used arrays internally. These data structures can also be implemented
    using linked lists. So, what is the best implementation for each? We need to consider
    these factors when deciding:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书的前面也学习了栈、队列和双端队列，并且我们内部使用了数组。这些数据结构也可以使用链表实现。那么，每种数据结构最好的实现方式是什么？在决定时，我们需要考虑以下因素：
- en: 'Frequency of operations: if you frequently need to access elements by index
    (random access), arrays might be a better choice. If insertions and deletions
    at the beginning or middle are common, linked lists could be more suitable.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作频率：如果你经常需要通过索引（随机访问）访问元素，数组可能是一个更好的选择。如果开始或中间的插入和删除操作很常见，链表可能更适合。
- en: 'Memory constraints: if memory is a significant concern and you know the maximum
    size of your data structure beforehand, arrays might be more memory efficient.
    However, if the size is highly variable, linked lists can save space by not reserving
    unused memory.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存限制：如果内存是一个重要的问题，并且你知道数据结构的最大大小，数组可能更节省内存。然而，如果大小高度可变，链表可以通过不预留未使用的内存来节省空间。
- en: 'Simplicity versus flexibility: array implementations are often simpler to code.
    Linked lists offer more flexibility for dynamic resizing and efficient modifications.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单性与灵活性：数组实现通常更容易编码。链表提供了更多动态调整大小和高效修改的灵活性。
- en: When it comes to answer, it all depends on what operations we will perform the
    most (and where) and the space we need to store our data.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到答案时，这完全取决于我们将要执行的最多的操作（以及在哪里）以及我们需要存储数据的空间。
- en: For stacks and queues, array implementations are often the default choice due
    to their simplicity. However, if you need to implement a queue with very frequent
    operations such as push/pop and queue/dequeue, a doubly linked list where we have
    the head and tail references might be more efficient. For deques, doubly linked
    lists are a natural fit, as they allow efficient insertion and removal at both
    ends at constant time.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 对于栈和队列，由于它们的简单性，数组实现通常是默认选择。然而，如果你需要实现一个具有非常频繁操作（如push/pop和queue/dequeue）的队列，一个具有头和尾引用的双向链表可能更有效率。对于双端队列，双向链表是自然的选择，因为它们允许在两端以常数时间进行高效的插入和删除。
- en: Since we've covered linked lists, a versatile dynamic data structure, put your
    knowledge to the test! Try re-implementing classic data structures like stacks,
    deques, and queues using linked lists instead of arrays. This hands-on exercise
    will deepen your understanding of both linked lists and these abstract data types.
    Plus, you can compare the performance and characteristics of your linked list-based
    versions with their array-based counterparts. For reference, you'll find these
    linked list implementations within the source code accompanying this book.
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于我们已经学习了链表，这是一种多功能的动态数据结构，现在用你的知识来测试一下！尝试使用链表而不是数组来重新实现经典的数据结构，如栈、双端队列和队列。这个动手练习将加深你对链表和这些抽象数据类型的理解。此外，你可以比较你的基于链表的版本与基于数组的版本的性能和特性。作为参考，你可以在本书的源代码中找到这些链表实现。
- en: Let's put our knowledge into practice with some exercises.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些练习来将我们的知识付诸实践。
- en: Exercises
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: We will resolve one exercise from **LeetCode** so we can learn another concept
    we have not covered in this chapter so far.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决一个来自**LeetCode**的练习，这样我们可以学习本章尚未涉及的概念。
- en: 'However, there are many fun linked list exercises available in LeetCode that
    we should be able to resolve with the concepts we learned in this chapter. Below
    are some additional suggestions you can try to resolve, and you can also find
    the solution along with the explanation within the source code from this book:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在LeetCode上有很多有趣的链表练习，我们应该能够用本章学到的概念来解决。以下是一些额外的建议，你可以尝试解决，你还可以在本书的源代码中找到解决方案和解释：
- en: '2\. Add Two Numbers: traverse two linked list and sum each number.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2. 加法两个数：遍历两个链表并求和每个数字。
- en: '62\. Rotate List: remove nodes from the tail and prepend them in the list.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 62. 旋转列表：从尾部移除节点并将它们预加到列表中。
- en: '203\. Remove Linked List Elements: traverse the list and check for the value
    that needs to be removed. Tip: keep a previous reference to make the removal easier.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 203. 删除链表元素：遍历列表并检查需要删除的值。提示：保持一个前向引用可以使删除更容易。
- en: '234\. Palindrome Linked List: check if the elements of the list are a palindrome.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 234. 回文链表：检查链表的元素是否是回文。
- en: '642\. Design Circular Deque: implement the deque data structure.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 642. 设计循环双端队列：实现双端队列数据结构。
- en: 622\. Design Circular Queue implement the queue data structure.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 622. 设计循环队列实现队列数据结构。
- en: Reverse Linked List
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反转链表
- en: The exercise we will resolve the is the *206\. Reverse Linked List* problem
    available at [https://leetcode.com/problems/reverse-linked-list/description/](https://leetcode.com/problems/reverse-linked-list/description/).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的练习是可在 [https://leetcode.com/problems/reverse-linked-list/description/](https://leetcode.com/problems/reverse-linked-list/description/)
    找到的 *206. 反转链表* 问题。
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `function reverseList(head: ListNode | null):
    ListNode | null`, which receives the head of a linked list and is expecting a
    node that represents the head of the reverse list. The `ListNode` class consists
    of a `val` (number), and the `next` pointer.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用 JavaScript 或 TypeScript 解决这个问题时，我们需要在函数 `function reverseList(head: ListNode
    | null): ListNode | null` 中添加我们的逻辑，该函数接收链表的头节点，并期望一个表示反转链表头节点的节点。`ListNode` 类由一个
    `val`（数字）和一个 `next` 指针组成。'
- en: 'Let''s write the `reverseList` function:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写 `reverseList` 函数：
- en: '[PRE44]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To better understand what is happening in the code, let''s use some diagrams.
    We will use the example provided by the exercise, which is a linked list with
    the following values: [1, 2, 3, 4, 5], and is expecting the following result:
    [5, 4, 3, 2, 1].'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解代码中发生的事情，让我们使用一些图表。我们将使用练习提供的示例，这是一个具有以下值的链表：[1, 2, 3, 4, 5]，并期望以下结果：[5,
    4, 3, 2, 1]。
- en: 'For this exercise, we will use three variables:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将使用三个变量：
- en: '`current` points to the head of the list.'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`current` 指向列表的头部。'
- en: '`newHead` starts as `null`, representing the new head of the reversed list.
    It is also the variable we will return as a result of the function.'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newHead` 开始时为 `null`，代表反转链表的新头节点。它也是我们将作为函数结果返回的变量。'
- en: '`nextNode` is a temporary cursor for the next node in the original list.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nextNode` 是原始列表中下一个节点的一个临时指针。'
- en: 'The logic consists only of a loop, which will traverse the entire list. Inside
    the loop we have four important operations:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑仅由一个循环组成，该循环将遍历整个列表。在循环内部，我们有四个重要的操作：
- en: '`nextNode = current.next`: saves the next node before we modify the current
    node''s links.'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nextNode = current.next`：在我们修改当前节点的链接之前保存下一个节点。'
- en: '`current.next = newHead`: reverses the current node''s link to point to the
    previous node (which is now `newHead`).'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`current.next = newHead`：反转当前节点的链接，使其指向前一个节点（现在是 `newHead`）。'
- en: '`newHead = current`: moves the `newHead` one step forward, making the `current`
    node the new head.'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newHead = current`：将 `newHead` 向前移动一步，使 `current` 节点成为新的头节点。'
- en: '`current = nextNode`: moves current to the next node (which was previously
    stored in `nextNode`).'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`current = nextNode`：将 `current` 移动到下一个节点（之前存储在 `nextNode` 中）。'
- en: 'After the first pass inside the loop, this is how the list will look like:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部第一次遍历之后，列表将看起来是这样的：
- en: '![The reverse linked list after the first pass inside the while loop](img/file51.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![while循环内部第一次遍历后的反转链表](img/file51.png)'
- en: The reverse linked list after the first pass inside the while loop
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: while循环内部第一次遍历后的反转链表
- en: 'After the second pass on the loop, this is how the list will look like:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的第二次遍历之后，列表将看起来是这样的：
- en: '![The reverse linked list after the second pass inside the while loop](img/file52.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![while循环内部第二次遍历后的反转链表](img/file52.png)'
- en: The reverse linked list after the second pass inside the while loop
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: while循环内部第二次遍历后的反转链表
- en: And the process continues until `current` is `null` and the list is reversed.
    This solution passes all the tests and resolves the problem.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这个过程会一直持续到 `current` 是 `null` 并且链表被反转。这个解决方案通过了所有的测试并且解决了问题。
- en: The time complexity of this function is *O(n)*, where *n* is the number of nodes
    we have in the list. The space complexity is *O(1)*, because we only used the
    additional variables to track the nodes and we are not using any additional space,
    as our solution reverses the linked list in place.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的时间复杂度是 *O(n)*，其中 *n* 是链表中的节点数量。空间复杂度是 *O(1)*，因为我们只使用了额外的变量来跟踪节点，并且我们没有使用任何额外的空间，因为我们的解决方案是在原地反转链表。
- en: Go back to the `LinkedList`, `DoublyLinkedList` and `CircularLinkedList` classes
    and create a method to reverse each list in place, following a similar logic we
    used to resolve this exercise. You will also find this method in the source of
    this book.
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回到 `LinkedList`、`DoublyLinkedList` 和 `CircularLinkedList` 类，创建一个方法来原地反转每个列表，遵循我们用来解决这个练习的类似逻辑。你也会在这个书的源代码中找到这个方法。
- en: Summary
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter explored linked lists and their variations: singly, doubly, and
    circular. We covered insertion, removal, and traversal techniques, highlighting
    the advantage of linked lists over arrays for frequent element additions and removals
    due to their dynamic nature.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了链表及其变体：单链表、双链表和循环链表。我们涵盖了插入、删除和遍历技术，强调了链表由于其动态特性，在频繁添加和删除元素方面相较于数组具有的优势。
- en: To solidify our knowledge, we built a media player, applying concepts like doubly
    circular and sorted linked lists. We also solved a LeetCode challenge, reversing
    linked lists in place for an added twist.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们的知识，我们构建了一个媒体播放器，应用了双循环链表和有序链表等概念。我们还解决了一个LeetCode挑战，就地反转链表，增加了额外的趣味性。
- en: Get ready! Next up, we dive into sets, a unique data structure for storing distinct
    elements.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了！接下来，我们将深入探讨集合，这是一种独特的用于存储不同元素的数据结构。
