- en: 6 Linked Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Before you begin: Join our book community on Discord**'
  prefs: []
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous chapters, we explored data structures stored sequentially in memory.
    Now, we turn our attention to linked lists, a dynamic and linear data structure
    with a non-sequential memory arrangement. This chapter delves into the inner workings
    of linked lists, covering:'
  prefs: []
  type: TYPE_NORMAL
- en: The linked list data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for adding and removing elements from linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variations of linked lists: doubly linked lists, circular linked lists and
    sorted linked lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How linked lists can be used to implement other data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing other data structures with linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises using linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The linked list data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays, a ubiquitous data structure found in nearly every programming language,
    offer a convenient way to store collections of elements. Their familiar bracket
    notation (`[]`) provides direct access to individual items. However, arrays come
    with a key limitation: their fixed size in most languages. This constraint makes
    inserting or removing elements from the beginning or middle a costly operation
    due to the need to shift remaining elements. While JavaScript provides methods
    to handle this, the underlying process still involves these shifts, impacting
    performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linked lists, like arrays, maintain a sequential collection of elements. However,
    unlike arrays where elements occupy contiguous memory locations, linked lists
    store elements as nodes scattered throughout memory. Each node encapsulates the
    element''s data (the information or value we want to store) along with a reference
    (also called a pointer or link) that directs you to the next node in the sequence.
    The following diagram illustrates this linked list structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The structure of a linked list data structure with nodes, data and pointers](img/file28.png)'
  prefs: []
  type: TYPE_IMG
- en: The structure of a linked list data structure with nodes, data and pointers
  prefs: []
  type: TYPE_NORMAL
- en: The first node is called the *head*, and the last node usually points to `null`
    (or `undefined`) to indicate the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: A key advantage of linked lists over conventional arrays is the ability to insert
    or remove elements without the costly overhead of shifting other items. However,
    this flexibility comes with the tradeoff of using pointers, requiring greater
    care during implementation. While arrays allow direct access to elements at any
    position, linked lists necessitate traversal from the head to reach elements in
    the middle, potentially impacting access time.
  prefs: []
  type: TYPE_NORMAL
- en: However, linked lists are not the best data structure if you need to access
    elements by their index (like we do with arrays). This is because we need to traverse
    the list from the beginning, which can be slower. Linked lists also require additional
    memory for storage, as each node requires extra memory to store the pointer(s),
    which can be overhead for simple data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linked lists have numerous real-world applications due to their flexibility
    and efficiency in handling dynamic data. One of the popular examples are media
    players. Media players use linked lists to organize and manage playlists. Adding,
    removing, and rearranging songs or videos are straightforward operations on a
    linked list as represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A media player representation using linked list as data structure](img/file29.png)'
  prefs: []
  type: TYPE_IMG
- en: A media player representation using linked list as data structure
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of linked lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singly Linked List** (or simply Linked List): each node has a pointer to
    the next node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doubly Linked List**: Each node has pointers to both the next and previous
    nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circular Linked List**: The last node points back to the head, forming a
    loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will cover the linked list as well as these variations,
    but let's start with the easiest data structure first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the LinkedList class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand what a linked list is, let's start implementing our
    data structure. We are going to create our own class to represent a linked list.
    The source code for this chapter is available inside the `src/06-linked-list`
    folder. We will start by creating the `linked-list.js` file which will contain
    our class that represents our data structure as well the node needed to store
    the data and the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we define a `LinkedListNode` class, which represents each element
    (or node) within our linked list. Each node holds the `data` we want to store,
    along with a reference (`next`) pointing to the subsequent node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By default, a newly created node's `next` pointer is initialized to `null`.
    However, the constructor also allows you to specify the next node if it is known
    beforehand, proving beneficial in certain scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare the `LinkedList` class which represents our linked list data
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This class begins by declaring a private `#head` reference, pointing to the
    first node (element) in the list. To avoid traversing the entire list whenever
    we need the element count, we also maintain a private `#size` variable. Both properties
    are kept private using the `#` prefix to ensure encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LinkedList` class will provide the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`append(data)`: adds a new node containing the `data` at the end of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prepend(data)`: adds a new node containing the `data` at the beginning (head)
    of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert(data, position)`: inserts a new node containing the `data` at the specified
    `position` in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeAt(position)`: removes the node at the specific `position` in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(data)`: removes the first node containing the specified `data` from
    the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf(data)`: returns the index of the first node containing the specified
    `data`. If the `data` is not found, returns `-1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty()`: returns `true` if the list does not contain any elements, and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`:removes all the elements from the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()`:returns the number of elements currently in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`:returns a string representation of the linked list, showing the
    elements in order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement each of these methods in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Appending elements to the end of the linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When appending an element at the end of a LinkedList, we encounter two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Empty list: the list has no existing elements, and we are adding the first
    one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-empty list: the list already contains elements, and we are adding a new
    one to the end of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the implementation of the `append` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of the list's state, the first step is to create a new node to hold
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: For the first scenario, we check if the list is empty. The condition `!this.#head`
    evaluates to `true` if the `#head` pointer is currently `null` (or `undefined`),
    indicating an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: if the list is empty, the newly created node (`newNode`) becomes the head of
    the list. Its next pointer will automatically be `null` since it is the only node
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a visual representation of these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a new element to an empty linked list](img/file30.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new element to an empty linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'In the scenario where our linked list is not empty, we have a reference only
    to the `head` (the first node). To append a new element to the end, we need to
    traverse the list:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by assigning a temporary variable, often called current, to the `head`
    of the list. This variable will act as our pointer as we move through the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a while loop, we continuously move current to the next node (`current.next`)
    as long as `current.next` is not `null`. This means we keep moving until we reach
    the last node, whose next pointer will be `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the loop terminates, `current` will be referencing the last node. We simply
    set `current.next` to our new node, effectively adding it to the end of the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we increment the `size` to reflect the addition of the new node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram exemplifies appending an element to the end of a linked
    list when it is not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a new element to the end of a linked list](img/file31.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new element to the end of a linked list
  prefs: []
  type: TYPE_NORMAL
- en: Prepending a new element to the linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding a new element as the head (beginning) of the linked list is a simple
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to create a new node to hold the `data`. Importantly, we pass
    the current `head` of the list as the second argument to the constructor. This
    sets the `next` pointer of the new node to the current `head`, establishing the
    link. If the list is empty, the current head is `null`, so the new node's `next`
    reference will also be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we update the `head` of the list to point to the newly created node (`newNode`).
    Since the new node is already linked to the previous head, the entire list is
    seamlessly adjusted. And finally, we increase the `size` of the list to reflect
    the addition of the new node. The following diagram exemplifies this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepending a new element to the linked list](img/file32.png)'
  prefs: []
  type: TYPE_IMG
- en: Prepending a new element to the linked list
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a new element at a specific position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s explore how to insert an element at any position within the linked
    list. For this, we will create an `insert` method, taking both the `data` and
    the desired `position` as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We first verify if the provided `position` is valid using a helper private
    method, `#isInvalidPosition`. A valid position is one that falls within the bounds
    of the list (0 to size-1). If the position is invalid, the method returns `false`
    to indicate the failure to insert. The helper method is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create the new node that will hold the data we are inserting.
  prefs: []
  type: TYPE_NORMAL
- en: The first scenario is handling the insertion at the head of the list. if the
    `position` is 0, it means we're inserting at the beginning of the list. In this
    case, we can simply call the prepend method we defined earlier and return `true`
    for success.
  prefs: []
  type: TYPE_NORMAL
- en: If not inserting at the head, it means we will need to traverse the list. To
    do so, we will need a helper variable we will name current and set it to the first
    node (`head`). We also need a second helper variable to assist with the linkage
    of the new node we will name `previous`. And we also initialize an index variable
    to keep track of our position as we traverse.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will traverse the list until we reach the desired position. To do so,
    the `while` loop iterates until the index matches the `position`. In each iteration,
    we move `previous` to the `current` node and the `current` to the `next` node.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the loop, `previous` points to the node before the insertion point, and
    `current` points to the node at the insertion point. We adjust the next pointers:
    `newNode.next` is set to current (the node that was originally at the insertion
    point), and `previous.next` is set to `newNode`, effectively inserting the new
    node into the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this scenario in action in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting an element in the middle of a linked list](img/file33.png)'
  prefs: []
  type: TYPE_IMG
- en: Inserting an element in the middle of a linked list
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to have variables referencing the nodes we need to control
    so that we do not lose the link between the nodes. We could work with only one
    variable (`previous`), but it would be harder to control the links between the
    nodes. For this reason, it is better to declare an extra variable to help us with
    these references.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Returning the position of an element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know how to traverse the list until a desired position, it makes
    easier to traverse the list searching for a particular element and returning its
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the `indexOf` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a variable `current` to track the node in the list and
    it is initially set to the head of the list. We also initialize an index variable
    to 0, representing the current position in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop continues if current is not `null` (we have not reached the
    end of the list). In each iteration, we check if the data property of the current
    node matches the element we are searching for, and if so, it returns the index
    of the element's position.
  prefs: []
  type: TYPE_NORMAL
- en: We can pass a custom comparison function to the `indexOf` method. This function
    should take two arguments (two different objects) and return `true` if the two
    objects match according to the desired criteria, or `false` otherwise. With this
    function, we gain flexibility and the ability to define exactly how elements are
    compared, accommodating complex data structures and different matching criteria.
    By default, we simply compare the references of the objects in case no comparison
    function is informed.
  prefs: []
  type: TYPE_NORMAL
- en: Using a comparison function is also a standard practice in other programming
    languages. If you prefer, instead of passing the function to the method directly,
    we can have the function in the constructor of the `LinkedList` class so it can
    be used whenever needed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the element is not found in the current node, it increments the `index` and
    moves to the next node.
  prefs: []
  type: TYPE_NORMAL
- en: If the loop completes without finding the element, it means the element is not
    present in the list. In this case, the method returns `-1` (which is an industry
    convention).
  prefs: []
  type: TYPE_NORMAL
- en: It is useful to have an `indexOf` method as we can use this method to search
    for elements, and we will also reuse it to remove elements from the list.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an element from a specific position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explore how we can remove elements from our linked list. Similar to
    appending, there are two scenarios to consider: removing the first element (the
    head) and removing any other element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `removeAt` code is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will delve into this code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the list is not empty, if it is empty, we return an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we check if the given position is valid using the `#isInvalidPosition`
    helper method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we check for the first scenario: removing the first element of the list,
    and if so, we will segregate the logic into a separate private method for better
    organization and understanding.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, if we are not removing the first element, it means we are removing
    the last element or from the middle of the list. For the singly linked list, both
    scenarios are similar, so we will handle them in a separate private method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While removing a node from a linked list might seem intricate, breaking down
    the problem into smaller, more manageable steps can simplify the process. This
    approach is a valuable technique not only for linked list operations but also
    for tackling complex tasks in various real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the `#removeFromHead` method, which is our first scenario
    to remove the first element from the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the `position` is 0 (indicating the head), we first store a reference to
    the head node in `nodeToRemove`. Then, we simply shift the `head` pointer to its
    `next` node, effectively disconnecting the original `head`. Finally, we decrease
    the list size and return the data of the removed node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram exemplifies this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the element at the head of the linked list](img/file34.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the element at the head of the linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s check the code to remove a node from the middle or from the end
    of a linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For any position other than 0, we need to traverse the list to find the node
    to remove. In previous sections, we used the `while` loop, and we will use the
    `for` loop now to demonstrate there are different ways of achieving the same result.
  prefs: []
  type: TYPE_NORMAL
- en: We keep two variables, `nodeToRemove` (starting at the first element) and `previous`
    to navigate through the list. At each iteration, we shift `previous` to the current
    node (`nodeToRemove`) and move `nodeToRemove` to the next node.
  prefs: []
  type: TYPE_NORMAL
- en: Once we reach the target position, `previous` points to the node before the
    one we want to remove, and `nodeToRemove` points to the node itself. We adjust
    the `previous` node's `next` pointer to skip over the `nodeToRemove` node, linking
    it directly to the node after `nodeToRemove`. This effectively removes the `nodeToRemove`
    node. Then we can decrement the size of the list and return the removed data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram exemplifies removing an element from the middle of the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the element from the middle of the linked list](img/file35.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the element from the middle of the linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic also works for the last element of the list, as the `nodeToRemove`''s
    next value will be `null` and when `previous.next` receives `null`, it automatically
    unlinks the last element. The following diagram exemplifies this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the last element of the linked list](img/file36.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the last element of the linked list
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to remove any element from the list, let's learn how to
    search for a specific element and then remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Searching and removing an element from the linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, we need to remove an element from a linked list without knowing
    its exact position. In this scenario, we require a method that searches for the
    element based on its data and then removes it. We''ll create a `remove` method
    that accepts the target data and an optional `compareFunction` for custom comparison
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The method first utilizes the `indexOf` method we created earlier to determine
    the position (`index`) of the first node whose data matches the provided `data`
    using the optional `compareFunction`.
  prefs: []
  type: TYPE_NORMAL
- en: If `indexOf` returns -1, it means the element is not found in the list. In this
    case, we return `null`. If the element is found, the method calls `removeAt(index)`
    to remove the node at that position. The `removeAt` method returns the removed
    data, which is then returned by the `remove` method as well.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if it is empty, clearing and getting the current size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `isEmpty`, get `size` and `clear` methods are very similar to the ones
    we created in previous chapter and provide fundamental operations for managing
    our linked list. Let''s look at them anyways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isEmpty`: this method checks if the linked list is empty. It does so by simply
    comparing the private `#size` property to zero. If #size is 0, it means the list
    has no elements and returns `true`; otherwise, it returns `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: this method directly returns the value of the private `#size` property,
    providing the current number of elements in the linked list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear`: this method is used to completely empty the linked list. It does this
    by setting the `#head` pointer to `null`, effectively disconnecting all nodes.
    The `#size` property is also reset to 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming the linked list into a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last method is the `toString` method, which its primary goal is to provide
    a string representation of the linked list. This is incredibly useful for debugging,
    logging, or simply displaying the contents of the list to users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A temporary variable `current` is initialized to point to the `head` of the
    linked list. This will be our cursor as we traverse the list. An empty string
    `objString` is created to accumulate the string representation of the list.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop continues as long as `current` is not `null`. This means we
    will iterate over each node in the list until we reach the end (where the last
    node's next property is `null`).
  prefs: []
  type: TYPE_NORMAL
- en: The `#elementToString` private method (which we have coded in previous chapters)
    is called to convert the data stored in the `current` node (`current.data`) into
    a string representation. This string is then appended (added) to the `objString`.
    We advance the `current` cursor to the `next` node of the list, and if there is
    a next node (we have not reached the end yet), a comma and a space are appended
    to the `objString` to separate the elements in the final string representation.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The difference between a doubly linked list and a normal or singly linked list
    is that in a linked list we make the link from one node to the next one only,
    while in a doubly linked list, we have a double link: one for the next element
    and one for the previous element, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Doubly linked list with previous and next nodes](img/file37.png)'
  prefs: []
  type: TYPE_IMG
- en: Doubly linked list with previous and next nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with the changes that are needed to implement the `DoublyLinkedList`
    class. We will start by declaring the node of our doubly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In a doubly linked list, each node maintains two references:'
  prefs: []
  type: TYPE_NORMAL
- en: '`next`: a pointer to the next node in the list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`previous`: a pointer to the previous node in the list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This dual linking enables efficient traversal in both directions. To accommodate
    this structure, we add the `previous` pointer to our `DoublyLinkedListNode` class.
    The constructor is designed to be flexible. By default, both the `next` and `previous`
    pointers are initialized to `null`. This allows us to create new nodes that are
    not yet connected to other nodes in the list. When inserting a node into the list,
    we explicitly update these pointers to establish the correct links within the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will declare our `DoublyLinkedList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A key distinction of a doubly linked list is that it tracks both the `head`
    (the first node) and the `tail` (the last node). This bidirectional linking enables
    us to traverse the list efficiently in either direction, offering greater flexibility
    compared to a singly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the core functionality of a doubly linked list remains similar to a singly
    linked list, the implementation differs. In a doubly linked list, we must manage
    two references for each node: `next` (pointing to the following node) and `previous`
    (pointing to the preceding node). Therefore, when inserting or removing nodes,
    we need to carefully update not only the next pointers (as in a singly linked
    list) but also the previous pointers to maintain the correct links throughout
    the list. This means that methods like `append`, `prepend`, `insert`, and `removeAt`
    will require modifications to accommodate this dual linking.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into each of the modifications needed.
  prefs: []
  type: TYPE_NORMAL
- en: Appending a new element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inserting a new element in a doubly linked list is very similar to a linked
    list. The difference is that in the linked list, we only control one pointer (`next`),
    and in the doubly linked list we need control both the `next` and `previous` references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the append method behaves in the doubly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we are trying to add a new element to the end of the list, we run into
    two different scenarios: if the list is empty or not empty. If the list is empty
    (`head` is `null`), we create a new node (`newNode`) and set both the `head` and
    `tail` to this new node. Since it is the only node, it becomes both the start
    and end.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the list is not empty, the beauty of the doubly linked list is we do not
    have to traverse the entire list to get to its end. As we have the `tail` reference,
    we can simply link the new node''s `previous` pointer to the tail, then we will
    link the tail''s next pointer to the new node, and finally, we update the `tail`
    reference to the new node. The order of this operations is crucial, as if we update
    the `tail` prematurely, we will lose the reference to the original last node,
    making it impossible to correctly link the new node to the end of the list. The
    following diagram demonstrates the process of adding a new node to the end of
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Appending a new node to the doubly linked list](img/file38.png)'
  prefs: []
  type: TYPE_IMG
- en: Appending a new node to the doubly linked list
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's review and changes needed to prepend an element to a doubly linked
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Prepending a new element to the doubly linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prepending a new element to the doubly linked list is not much different then
    prepending a new element to a singly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Again, we have two scenarios. In case the list is empty, the behavior is identical
    to the `append` method, the new node becomes both the `head` and `tail`.
  prefs: []
  type: TYPE_NORMAL
- en: If the list is not empty, we set the `next` pointer of the new node (`newNode`)
    to the current `head`. We then update the `previous` pointer of the current head
    to reference the `newNode`. Finally, we update the `head` to be the `newNode`,
    as it is now the first node in the list.
  prefs: []
  type: TYPE_NORMAL
- en: In a singly linked list, the prepend operation only requires updating the `next`
    pointer of the new node and the `head` of the list. However, in a doubly linked
    list, we must also update the `previous` pointer of the original head node to
    ensure the bidirectional links are maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are able to add elements at the head and at the tail of the list,
    let's checkout how to insert at any position.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a new element at any position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inserting an element at an arbitrary position within a doubly linked list requires
    some additional considerations compared to simply appending or prepending. Let''s
    see how to insert at any position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review case by case:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we start by checking if the position if valid, and if not, we return
    `false` to indicate the insertion was not successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will check if the insertion is at the `head`, and if so, we can reuse
    the `prepend` method, and return `true` to indicate the insertion was a success.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next scenario is in case the insertion is at the end of the list, and if
    so, we can reuse the `append` method and return `true`. Checking for this case
    will avoid traversing the list to get to its end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not prepending and not appending, it means the position is in the middle
    of the list, and for this case, we will create a private method that will hold
    the logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In case the position is in the middle, we will use the `#insertInTheMiddle`
    to help us organize the steps better as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we will create a new node and we will traverse the list to the desired
    position. After the `for` loop, we will insert the new node between the previous
    and current references with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The `newNode`'s `next` pointer is set to the `currentNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `newNode`'s `previous` pointer is set to the `previousNode`. With these
    two steps, we have the new node partially inserted to the list. What we need to
    do now is updating the references of the existing nodes in the list to the new
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `currentNode`'s `previous` pointer is updated to point to the `newNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `previousNode`'s `next` pointer is updated to point to the `newNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram exemplifies this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting a new node in the middle of the doubly linked list](img/file39.png)'
  prefs: []
  type: TYPE_IMG
- en: Inserting a new node in the middle of the doubly linked list
  prefs: []
  type: TYPE_NORMAL
- en: Given we have a refence to both the `head` and the `tail` of the list, an improvement
    we could make to this method is checking if position is greater than size/2, then
    it would be best to iterate from the end than start from the beginning (by doing
    so, we will have to iterate through fewer elements from the list).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have learned the details of how to handle two pointers for inserting
    nodes in the list, let's see how to remove an element from any position.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an element from a specific position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s delve into the details and differences of removing an element from any
    position of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will start by checking if the list is empty and for an invalid position.
    If the list is empty or if the given position is outside the valid range of the
    list (0 to size-1), we throw a `RangeError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will check for the three possible scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: If the removal is from the head (first position of the list)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the removal is from the tail (last position of the list)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: or from the middle of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's dive into each scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first scenario is if are removing the first element. Following is the code
    for the `#removeFromHead` private method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a reference (`nodeToRemove`) to the current head node.
    This is important because we will need to return its data later. Next, the `head`
    reference is now moved to the `next` node in the list.
  prefs: []
  type: TYPE_NORMAL
- en: If there was only one node, `nodeToRemove.next` will be `null`, and the `head`
    will become `null`, indicating an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: If the list is not empty after the removal, the `previous` reference of the
    new `head` node (which was previously the second node) is set to `null`, since
    it is now the first node and has no predecessor.
  prefs: []
  type: TYPE_NORMAL
- en: If the list is empty, both `head` and `tail` need to be set to `null`. As we
    have already set the `head` to `null` in the second line of the method, we only
    need to set the `tail` to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we remove the `nodeToRemove` next reference in case there is any.
    The following diagram demonstrates this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the node at the head of a doubly linked list](img/file40.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the node at the head of a doubly linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'The next scenario is checking if we are removing the tail (the last element).
    Following is the code for the `#` `removeFromTail` private method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the reference to the current `tail` node, the `tail` reference
    is moved to the `previous` node. We need to check if the list if empty after the
    removal – this is similar to the `removeFromHead` method behavior. If the list
    is not empty, we set the new tail''s `next` pointer is set to `null`. If the list
    is empty, we also update the `head` to `null`. The following diagram demonstrates
    this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the node at the tail of a doubly linked list](img/file41.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the node at the tail of a doubly linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'The last scenario is removing the element from the middle of the list. The
    method `#removeFromMiddle` is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since the position is not the `head` or `tail`, we need to traverse the list
    to find the node and correctly adjust the surrounding nodes' references. We start
    by declaring a `nodeToRemove`, referencing it to the `head` as the starting point
    and we will move this node through the list as we iterate. The `previousNode`
    keeps track of the node just before the `nodeToRemove` and it starts with `null`
    since the head has no previous node.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop continues until `index` matches the `position` we want to remove
    from. Inside the loop, we update `previousNode` to be the current node (before
    we move it) and we mode `nodeToRemove` to the next node.
  prefs: []
  type: TYPE_NORMAL
- en: When the loop stops, `nodeToRemove` will reference the node we want to remove.
    So, we skip the reference to the `nodeToRemove` by making the `previousNode`'s
    `next` pointer point to the node after `nodeToRemove`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `nodeToRemove.next.previous = previousNode` updates the `previous` pointer
    of the node after `nodeToRemove` to point back to `previousNode`. This step is
    essential to maintain the doubly linked list's structure.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we remove the `nodeToRemove` next and previous references, we decrease
    the size of the list and return the removed data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the node from the middle of a doubly linked list](img/file42.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the node from the middle of a doubly linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the implementation of other methods of the doubly linked list (as
    they are the same as the linked list), refer to the source code of the book. The
    download link of the source code is mentioned in the Preface of the book, and
    it can also be accessed at: [http://github.com/loiane/javascript-datastructures-algorithms](http://github.com/loiane/javascript-datastructures-algorithms).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Circular linked lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A circular linked list is a variation of a linked list where the last node''s
    next pointer (or `tail.next`) references the first node (`head`) instead of being
    `null` or `undefined`. This creates a closed loop structure., as we can see in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The structure of a circular linked list](img/file43.png)'
  prefs: []
  type: TYPE_IMG
- en: The structure of a circular linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'A doubly circular linked list has `tail.next` pointing to the head element,
    and `head.previous` pointing to the `tail` element as showed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The structure of a doubly circular linked list](img/file44.png)'
  prefs: []
  type: TYPE_IMG
- en: The structure of a doubly circular linked list
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between circular and regular (linear) linked lists is that
    there is no explicit *end* to a circular linked list. You can continuously traverse
    the list starting from any node and eventually return to the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement a singly circular linked list, and you can find the bonus
    source code for a doubly circular linked list in the source code from this book.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s check the code to create the `CircularLinkedList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We will utilize the same `LinkedListNode` structure for our `CircularLinkedList`
    class, as the fundamental node structure remains the same. However, the circular
    nature of the list introduces some key differences in how we implement operations
    like `append`, `prepend`, and `removeAt`. Let's explore these modifications in
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Appending a new element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Appending a new element to a circular linked list shares similarities with
    appending to a standard linked list, but with a few key distinctions due to the
    circular structure. Let''s see the code for the `append` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating the new node to hold that data. Then checks if the list
    is empty. If so, the new node becomes the `head`, and its next pointer is set
    to point back to itself, completing the circle. The following diagram exemplifies
    the first scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Appending an element as the only node in a circular linked list](img/file45.png)'
  prefs: []
  type: TYPE_IMG
- en: Appending an element as the only node in a circular linked list
  prefs: []
  type: TYPE_NORMAL
- en: If the list is not empty, we need to find the last node. This is done by traversing
    the list starting from the `head` until we find a node whose next pointer points
    back to the `head`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the last node (`current`) is found, its next pointer is updated to reference
    the `newNode`. The `newNode`''s next pointer is then set to the `head`, re-establishing
    the circular link. The following diagram exemplifies the second scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Appending an element in a non-empty circular linked list](img/file46.png)'
  prefs: []
  type: TYPE_IMG
- en: Appending an element in a non-empty circular linked list
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how to insert a new node in the beginning of a circular linked
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Prepending a new element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prepending a new element in a circular linked list involves a few key steps
    due to the circular nature of the structure. Let''s check out the code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a new node to hold the data. The `next` pointer of the
    new node is immediately set to the current `head` of this list, to maintain the
    circular nature of the list after the insertion.
  prefs: []
  type: TYPE_NORMAL
- en: If the list is empty, the new node becomes the `head` and we add a self-reference
    as the next pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case the list is not empty, we find the last element, so we can update its
    `next` pointer to the new node, which will become the new `head`. The diagram
    below exemplifies this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepending an element in a non-empty circular linked list](img/file47.png)'
  prefs: []
  type: TYPE_IMG
- en: Prepending an element in a non-empty circular linked list
  prefs: []
  type: TYPE_NORMAL
- en: If we want to insert a new element in the middle of the list, the code is the
    same as the `LinkedList` class since no changes will be applied to the last or
    first nodes of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an element from a specific position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the removal of an element of a circular linked list, we will cover removing
    the first and the last elements, since removing an element from the middle is
    the same behavior as the singly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s cover removing from the head, with the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we traverse the list to find the last node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we set the head to the next node to remove the first element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we make the last node point to the new `head`, closing the circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, if the removed node was the only one in the list, set the `head` to
    `null` to reset it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The diagram below exemplifies this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the head from a circular linked list](img/file48.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the head from a circular linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check out how to remove from the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And following is the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: If there is only one node (`head` points to itself), removing it makes the list
    empty. We update `head` to `null` and return the removed data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the list is not empty, we need to find the last node and the second last
    node (`previousNode`). So we traverse the list until we reach its end, updating
    the `previous` and the `last` node references.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `while` loop is finished, the `lastNode` is the one we want to remove.
    So we set `previousNode.next = this.#head` to make the second last node point
    to the head, skipping the last node, which is now removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We decrement the list size and return the removed `data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The diagram below exemplifies this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the tail from a circular linked list](img/file49.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the tail from a circular linked list
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to add and remove elements from three different types of
    linked lists, let's put all these concepts learned by creating a fun project!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a media player using a linked list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To solidify our understanding of linked lists and explore new concepts, let''s
    build a real-world application: a media player! This project will leverage the
    linked list structure and introduce us to additional techniques like working with
    doubly circular linked lists and ordered insertion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive in, let''s outline the core features of our media player:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordered song insertion: add songs to the playlist based on song title.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sequential playback: simulate playing songs one after the other in the playlist''s
    order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigation: easily jump to the previous or next song.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Continuous repeat: automatically loop the playlist, playing songs repeatedly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image represents the media player we will develop using linked
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A media player using doubly circular linked list](img/file50.png)'
  prefs: []
  type: TYPE_IMG
- en: A media player using doubly circular linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'To model our media player''s playlist, we will use a custom node structure
    to represent each song. Following is the `MediaPlayerSong` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `MediaPlayerSong` node stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '`songTitle`: the title of the song.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previous`: a reference to the previous song node in the playlist (or a reference
    to the last song, if it is the first song).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: a reference to the next song node in the playlist (or a reference to
    the first song if it is the last song).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will allow us to implement the continuous repeat feature of our media player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s define the structure of our `MediaPlayer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MediaPlayer` class maintains:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#firstSong`: a reference to the first `MediaPlayerSong` in the playlist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#lastSong`: a reference to the last `MediaPlayerSong` in the playlist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#size`: the count of songs currently in the playlist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#playingSong`: a reference to the `MediaPlayerSong` that is currently being
    played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we can start playing songs, we need to be able to add songs to our playlist.
    Let's see how to do it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new songs by title order (sorted insertion)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To maintain an alphabetically ordered playlist, we will implement a method called
    `addSongByTitle`. This method will insert a new song into the correct position
    based on its title, ensuring the playlist remains sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, we are doing a sorted insertion in a doubly circular linked
    list!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We will start by declaring the method to insert a new song:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a brief explanation before we start diving into the details:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a new `MediaPlayerSong` node with the given `newSongTitle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the playlist is empty, we call a private method `#insertEmptyPlayList` to
    handle the insertion of the first song.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For non-empty playlists, we callsa private method `#findIndexOfSortedSong` to
    determine the correct `position` where the new song should be inserted to maintain
    alphabetical order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on the returned `position`, the method dispatches the insertion to one
    of three private methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#insertAtBeginning`: inserts the new song at the start of the list.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#insertAtEnd`: inserts the new song at the end of the list.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#insertInMiddle`: inserts the new song in the middle of the list at the specified
    position.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `#size` of the playlist is incremented to reflect the addition
    of the new song.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's review each of the steps with more details.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting into an empty playlist
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this scenario, we are handling an insertion into a doubly circular linked
    list. Let''s dive into the `#insertEmptyPlayList` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We are assigning the new song to the `firstSong` (head) and the `lastSong` (tail).
    And to keep the circular references, we set the new song's `next` and `previous`
    references to itself.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in the logic is to find the position we need to insert the song
    in case the playlist is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the alphabetically sorted insertion position
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are dealing with a complex scenario: sorted insertion into a doubly circular
    linked list. To simplify this, we will tackle it in two phases, the first one
    determining the correct position (index) where the new song should be inserted
    to maintain alphabetical order and the second one being the insertion itself.
    So, for now, let''s focus on finding the correct insertion index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We will traverse the list to find the position of the insertion. To do so, we
    will use a cursor called `currentSong`. We also need an index counter `i`.
  prefs: []
  type: TYPE_NORMAL
- en: We will loop from the first song up until the last song of the playlist. Inside
    the loop, we will call a helper method that contains the logic to compare the
    songs. If the result of the helper method is 0 (duplicate song) or a positive
    number, it means we found the position.
  prefs: []
  type: TYPE_NORMAL
- en: If the new song does not belong at the current position, we move to the next
    song in the list. If the loop completes without returning, it means the new song
    should be inserted at the beginning (index 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next let''s check the code for the `#compareSongs` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is a helper function used to compare two song titles alphabetically,
    considering locale-specific sorting rules. The localeCompare method returns a
    number that indicates the sorting relationship between the two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Negative number: `songTitle1` comes before `songTitle2` in alphabetical order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0 (zero): `songTitle1` and `songTitle2` are considered equal in the current
    locale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Positive number: `songTitle1` comes after `songTitle2` in alphabetical order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can modify this method as needed to customize how you would like to compare
    song titles.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the position we need to insert, let's review each of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting at the beginning of the playlist
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s check how to prepend a new song in a playlist that is not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Given our next song, we will point its next reference to the first song (head)
    and its last reference to the last song (tail). Then, we update the existing first
    song's previous reference to the new song, and the last song's next reference
    also to the new song. Finally, we update the first song reference to the new song.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how to append a new song.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting at the end of the playlist
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s review how we can add new songs at the end of the playlist with the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Given the new song, when inserting at the end, we need to link its next reference
    to the first song and its previous reference to the last song so we can keep the
    doubly circular references. Then, we need to update the last song's next reference
    to the new song, the first song's previous reference also to the new song to also
    keep the circular reference, and finally, update the reference of the last song
    to the new song.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the last step is to insert a song in the middle of the playlist.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting in the middle of the playlist
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have covered the insertion at the head and at the tail of the doubly
    circular linked list, let''s dive into the details to insert a new element in
    the middle of the list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Inserting in the middle is the same as inserting in a doubly linked list. As
    we have both the previous and next references, we do not need two references.
    So first, we find the position we are looking for, and we stop at one position
    before the one we want. Then, we link the new song's next reference to the current's
    next reference, and the new song's previous reference to the current song. With
    this step, we have inserted the new song in the list, and now we need to fix the
    remaining links. So, we fix the current songs' next node's previous reference
    to the new song, and the current song's next reference to the new song.
  prefs: []
  type: TYPE_NORMAL
- en: With the songs added to the playlist, we can start playing them!
  prefs: []
  type: TYPE_NORMAL
- en: Playing a song
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we select the play song feature of our media player, the goal is to start
    playing the song. For our simulation, it means assigning the first song to the
    playing song reference, as described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If there are no songs in the playlist, we can return null, or if you prefer,
    you can throw an error as well. Then, we assign the reference of the playing song
    to the first song, and we return the title we are playing.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the next or previous song
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The behavior to play the next or previous song are very similar. The difference
    is on the reference we are updating: `previous` or `next`. Let''s review the behavior
    for playing the next song first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If there are no songs in the playlist, we return `null`. Also, if there is not
    any song playing at the moment, we play the first song. However, if there are
    songs playing and we decide we want to play the next song, we simply update the
    playing song with its next reference and we return the song title.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the previous method is also very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The difference is if there are songs playing, and we want to play the previous
    song, we update the current song with its previous reference.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, when we reach the end of the playlist, or the first song of the
    playlist, we can keep playing, because of the circular doubly references.
  prefs: []
  type: TYPE_NORMAL
- en: Using our media player
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have built our media player, let''s put it to the test. We will
    start by creating an instance and adding our favorite songs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After our playlist is created, we can start playing songs and seeing the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can select the next song multiple times and check that the continuous playback
    works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we go the other way around it, selecting the previous button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If we review the output, we can confirm the songs were inserted in an alphabetical
    order.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Have fun playing with our media player!
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the efficiency of the linked lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s review the efficiency of each method by review the Big O notation in
    terms of time of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Singly** | **Doubly** | **Circular** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `append` | *O(n)* | *O(1)* | *O(n)* | In singly and circular lists, we must
    traverse to the end to append. Doubly lists have a tail reference for constant
    time append. |'
  prefs: []
  type: TYPE_TB
- en: '| `prepend` | *O(1)* | *O(1)* | *O(n)* | All lists can add a new node as the
    head directly. However, in circular lists, we must update the last node''s next
    pointer to the new head. |'
  prefs: []
  type: TYPE_TB
- en: '| `insert` | *O(n)* | *O(n)* | *O(n)* | For all types, we need to traverse
    to the position to insert. |'
  prefs: []
  type: TYPE_TB
- en: '| `removeAt` | *O(n)* | *O(n)* | *O(n)* | Similar to insertion, traversal to
    the position is required. Doubly lists have an optimization when removing the
    tail ( *O(1)* ), but this is less common than removing from an arbitrary position.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `remove` | *O(n)* | *O(n)* | *O(n)* | Searching for the data takes *O(n)*
    in all cases, then removal itself is either *O(1)* (if the node is found at the
    head) or *O(n)* (traversing to the node). |'
  prefs: []
  type: TYPE_TB
- en: '| `indexOf` | *O(n)* | *O(n)* | *O(n)* | In the worst case, we might need to
    traverse the entire list to find the data or determine it''s not present. |'
  prefs: []
  type: TYPE_TB
- en: '| `isEmpty` | *O(1)* | *O(1)* | *O(1)* | Checking if the list is empty is a
    simple size reference check. |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | *O(1)* | *O(1)* | *O(1)* | The size is tracked as a property and
    directly accessible. |'
  prefs: []
  type: TYPE_TB
- en: '| `clear` | *O(1)* | *O(1)* | *O(1)* | Clearing a list simply involves resetting
    the head pointer (and tail in doubly linked lists), which is a constant-time operation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toString` | *O(n)* | *O(n)* | *O(n)* | Building a string representation
    requires visiting each node. |'
  prefs: []
  type: TYPE_TB
- en: Doubly linked lists often have a performance advantage in append due to the
    tail pointer. Otherwise, all three list types have similar time complexities for
    most operations, as they all involve some degree of traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Space complexity is *O(n)* for all three types, as the space used is proportional
    to the number of elements stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had to compare liked lists to arrays, there are pros and cons to each
    data structure. Let''s review a few key points:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Linked Lists*: prefer linked lists when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need a dynamic collection where the number of elements changes frequently.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You perform frequent insertions and deletions, especially at the beginning or
    middle of the list.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You do not require random access to elements.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Arrays*: prefer arrays when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You know the maximum size of the collection beforehand.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You need fast random access to elements by index.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You primarily need to iterate through the elements sequentially.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have also learned about stacks, queues and deques earlier in this book and
    we have used arrays internally. These data structures can also be implemented
    using linked lists. So, what is the best implementation for each? We need to consider
    these factors when deciding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Frequency of operations: if you frequently need to access elements by index
    (random access), arrays might be a better choice. If insertions and deletions
    at the beginning or middle are common, linked lists could be more suitable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory constraints: if memory is a significant concern and you know the maximum
    size of your data structure beforehand, arrays might be more memory efficient.
    However, if the size is highly variable, linked lists can save space by not reserving
    unused memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simplicity versus flexibility: array implementations are often simpler to code.
    Linked lists offer more flexibility for dynamic resizing and efficient modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to answer, it all depends on what operations we will perform the
    most (and where) and the space we need to store our data.
  prefs: []
  type: TYPE_NORMAL
- en: For stacks and queues, array implementations are often the default choice due
    to their simplicity. However, if you need to implement a queue with very frequent
    operations such as push/pop and queue/dequeue, a doubly linked list where we have
    the head and tail references might be more efficient. For deques, doubly linked
    lists are a natural fit, as they allow efficient insertion and removal at both
    ends at constant time.
  prefs: []
  type: TYPE_NORMAL
- en: Since we've covered linked lists, a versatile dynamic data structure, put your
    knowledge to the test! Try re-implementing classic data structures like stacks,
    deques, and queues using linked lists instead of arrays. This hands-on exercise
    will deepen your understanding of both linked lists and these abstract data types.
    Plus, you can compare the performance and characteristics of your linked list-based
    versions with their array-based counterparts. For reference, you'll find these
    linked list implementations within the source code accompanying this book.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's put our knowledge into practice with some exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will resolve one exercise from **LeetCode** so we can learn another concept
    we have not covered in this chapter so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are many fun linked list exercises available in LeetCode that
    we should be able to resolve with the concepts we learned in this chapter. Below
    are some additional suggestions you can try to resolve, and you can also find
    the solution along with the explanation within the source code from this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Add Two Numbers: traverse two linked list and sum each number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '62\. Rotate List: remove nodes from the tail and prepend them in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '203\. Remove Linked List Elements: traverse the list and check for the value
    that needs to be removed. Tip: keep a previous reference to make the removal easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '234\. Palindrome Linked List: check if the elements of the list are a palindrome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '642\. Design Circular Deque: implement the deque data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 622\. Design Circular Queue implement the queue data structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse Linked List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exercise we will resolve the is the *206\. Reverse Linked List* problem
    available at [https://leetcode.com/problems/reverse-linked-list/description/](https://leetcode.com/problems/reverse-linked-list/description/).
  prefs: []
  type: TYPE_NORMAL
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `function reverseList(head: ListNode | null):
    ListNode | null`, which receives the head of a linked list and is expecting a
    node that represents the head of the reverse list. The `ListNode` class consists
    of a `val` (number), and the `next` pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `reverseList` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To better understand what is happening in the code, let''s use some diagrams.
    We will use the example provided by the exercise, which is a linked list with
    the following values: [1, 2, 3, 4, 5], and is expecting the following result:
    [5, 4, 3, 2, 1].'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, we will use three variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`current` points to the head of the list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`newHead` starts as `null`, representing the new head of the reversed list.
    It is also the variable we will return as a result of the function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nextNode` is a temporary cursor for the next node in the original list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The logic consists only of a loop, which will traverse the entire list. Inside
    the loop we have four important operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nextNode = current.next`: saves the next node before we modify the current
    node''s links.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`current.next = newHead`: reverses the current node''s link to point to the
    previous node (which is now `newHead`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`newHead = current`: moves the `newHead` one step forward, making the `current`
    node the new head.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`current = nextNode`: moves current to the next node (which was previously
    stored in `nextNode`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the first pass inside the loop, this is how the list will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The reverse linked list after the first pass inside the while loop](img/file51.png)'
  prefs: []
  type: TYPE_IMG
- en: The reverse linked list after the first pass inside the while loop
  prefs: []
  type: TYPE_NORMAL
- en: 'After the second pass on the loop, this is how the list will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The reverse linked list after the second pass inside the while loop](img/file52.png)'
  prefs: []
  type: TYPE_IMG
- en: The reverse linked list after the second pass inside the while loop
  prefs: []
  type: TYPE_NORMAL
- en: And the process continues until `current` is `null` and the list is reversed.
    This solution passes all the tests and resolves the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of this function is *O(n)*, where *n* is the number of nodes
    we have in the list. The space complexity is *O(1)*, because we only used the
    additional variables to track the nodes and we are not using any additional space,
    as our solution reverses the linked list in place.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the `LinkedList`, `DoublyLinkedList` and `CircularLinkedList` classes
    and create a method to reverse each list in place, following a similar logic we
    used to resolve this exercise. You will also find this method in the source of
    this book.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter explored linked lists and their variations: singly, doubly, and
    circular. We covered insertion, removal, and traversal techniques, highlighting
    the advantage of linked lists over arrays for frequent element additions and removals
    due to their dynamic nature.'
  prefs: []
  type: TYPE_NORMAL
- en: To solidify our knowledge, we built a media player, applying concepts like doubly
    circular and sorted linked lists. We also solved a LeetCode challenge, reversing
    linked lists in place for an added twist.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready! Next up, we dive into sets, a unique data structure for storing distinct
    elements.
  prefs: []
  type: TYPE_NORMAL
