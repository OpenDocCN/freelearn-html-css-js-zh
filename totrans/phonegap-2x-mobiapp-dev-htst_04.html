<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Let's Take a Trip</h1></div></div></div><p>Geolocation has<a id="id378" class="indexterm"/> become very important in today's world, especially since most phones have the capability to determine your position to an astonishing degree of accuracy. Given that this used to (not so long ago) be the mainstay of expensive GPS gadgets, it is amazing how quickly this ability has become ubiquitous. Because of this, users expect location-aware applications, and not just that, but they expect a nice map that responds to their input right along with it.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>What do we build?</h1></div></div></div><p>Our project <a id="id379" class="indexterm"/>is aimed at two concepts, the first being to simply use a (very) small portion of the Google Maps API (as of this writing, 3.9). We will use this API to display a fully<a id="id380" class="indexterm"/> functional map that is centered on the user's current location. Secondly, we will use the geolocation features that PhoneGap provides in order to obtain the user's current location. When we're done, we'll have an app that can not only display a map centered around the user's current location, but we'll also have an app that can record their movements and show them on-screen. Instead of a voice recorder, think of it as a location recorder.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec79"/>What does it do?</h2></div></div></div><p>We introduced <a id="id381" class="indexterm"/>document management in the last project, and we'll further shore up those capabilities in this project. Thankfully, most of the work is done for us, but as you recall, there were a few situations where the user could get into trouble (if they used a name that collided with an existing file). We'll take care of that in this project so that we have a much more robust solution.</p><p>We'll also be going over the various methods that we can use to load in the Google Maps APIs, something that turns out to be a little more difficult than one would initially think, and this is<a id="id382" class="indexterm"/> complicated by the fact that we have to deal with the possibility of losing (or not having) network access. We won't use the entire Google Maps API, it deserves a book all its own, but we will use some basic features, including markers and lines.</p><p>Finally, we'll be using geolocation. Some browsers are kind enough to provide a good implementation of geolocation, and since PhoneGap's implementation follows the W3C standard, it will use the browser solution if it is good enough. This also means that what we're building could even be made to work outside of PhoneGap if one switched to using <code class="literal">localStorage</code>
<a id="id383" class="indexterm"/> instead of persistent files.</p><p>When we've put it all together, we'll have a pretty interesting app. An app that records our location (while we let it) and that can then display it. This opens up all sorts of possibilities for extension: you could share a path with a friend, you could export to KML for ingestion by other applications, and more.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec80"/>Why is it great?</h2></div></div></div><p>Geolocation<a id="id384" class="indexterm"/> and interactive maps are something users expect in today's apps. If you display an address, you should at least be able to display a map to go along with it. If you offer searches by location, you should be able to locate where the user is and provide them with relevant results. Geolocation and interactive maps aren't just for turn-by-turn location or helping someone who's become lost; they are invaluable in a lot of other applications as well.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec81"/>How are we going to do it?</h2></div></div></div><p>In many ways, <a id="id385" class="indexterm"/>this task is easier than those that have preceded it. For one, our framework has become pretty stable (though there are some changes for this project), and we have a good start on document management. What's really left is creating the data model that is capable of storing location information and saving and retrieving it. This is also our first app where we'll dispense with the start view – we'll jump straight into the app from now on.</p><p>In order to accomplish this, we'll use the same familiar steps we've used before:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing our UI and the look and feel</li><li class="listitem" style="list-style-type: disc">Designing our data model</li><li class="listitem" style="list-style-type: disc">Implementing our data model</li><li class="listitem" style="list-style-type: disc">Changing our document manager</li><li class="listitem" style="list-style-type: disc">Implementing our map view</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec82"/>What do I need to get started?</h2></div></div></div><p>As always, <a id="id386" class="indexterm"/>go ahead and create your project. Be sure to follow the same project steps as in previous projects, though you don't need to worry about plugin support; we don't need any native plugins for this app.</p><p>Also, take a look at the <a id="id387" class="indexterm"/>Google Maps API (<a class="ulink" href="https://developers.google.com/maps/documentation/javascript/3.9/reference">https://developers.google.com/maps/documentation/javascript/3.9/reference</a>). While there, you might want to sign up for an API key as well. Although you can use the API without one (and we do here), having a key allows for usage metrics, and should your app become popular enough, the ability to pay for your use so that you aren't restricted to the low API caps enforced for non-key users. Be sure to take a look at their documentation as well; there's a lot of it there, enough to fill several chapters alone, but it is well worth perusing. Put it this way: there are things Google Maps does that I never knew it could do, and you might discover the same.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Designing our UI and the look and feel</h1></div></div></div><p>As always,<a id="id388" class="indexterm"/> let's not start coding until we have a good idea about how we want <a id="id389" class="indexterm"/>our app to look. Thankfully, we really only have to focus on the map view. We've already covered the look and feel of our document manager in the previous project, and it's not changed much here. Furthermore, since a good portion of the view will actually be taken up by the interactive map provided by Google, there's not even a lot we have to do there.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec83"/>Getting ready</h2></div></div></div><p>Once again, get your pencil and paper out or your favorite graphics editor; we'll be using them to design our wireframe and then build out any of the assets we might need later on.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec84"/>Getting on with it</h2></div></div></div><p>The following screenshot gives a final mockup of our map view:</p><div><img src="img/9403_04_01.jpg" alt="Getting on with it"/></div><p>At first glance, this <a id="id390" class="indexterm"/>appears like a pretty simple view<a id="id391" class="indexterm"/>—and it is—but don't <a id="id392" class="indexterm"/>let that fool you. There's a lot of power underneath!</p><p>Let's go over the various items:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong>Back</strong> button will take the user back to the document management interface. For Android, of course, this button will not be present; the device's physical back button will do the trick.</li><li class="listitem" style="list-style-type: disc">The title on the navigation bar will be the title of the document. The user can tap on it to change the document via a prompt alert from our framework.</li><li class="listitem" style="list-style-type: disc">The button with the <em>globe</em> is intended to be the <em>find me</em> button. The view will automatically do this when shown, but one of the hallmarks of an interactive map is that you should be able to explore it on your own without constantly being dragged back to your current position. This button is intended to re-center your map after you've done some exploration.</li><li class="listitem" style="list-style-type: disc">The button<a id="id393" class="indexterm"/> with the <em>red dot</em> is the <em>record</em> button. When tapped the view will begin to record your position (as often as it changes) and draw a line following your progress. If tapped again, it will stop tracking your location.</li><li class="listitem" style="list-style-type: disc">Below the navigation bar is the Google Map (here, an <em>X</em> image). This will, of course, be populated from Google. Moving the map with your finger will, of course, pan the map, but more importantly, we will catch this event so that we can <em>unlock</em> the map from your current location.</li><li class="listitem" style="list-style-type: disc">The downward pointing arrow is a representation of the typical <em>Google Marker</em>; this will indicate your current position.</li><li class="listitem" style="list-style-type: disc">The line is a representation of some path already recorded; it will indicate every update in your path during the recording.</li></ul></div><p>Now that we've <a id="id394" class="indexterm"/>defined how everything should work together, let's go into our graphics program and create the graphical assets we'll need.</p><p>The documents view<a id="id395" class="indexterm"/> will be as follows:</p><div><img src="img/9403_04_02.jpg" alt="Getting on with it"/></div><p>The map view<a id="id396" class="indexterm"/> will be as follows:</p><div><img src="img/9403_04_04.jpg" alt="Getting on with it"/></div><p>Generally, we've <a id="id397" class="indexterm"/>used the same assets as for our previous project, though our document image has changed to a map. We'll also need to use the images on our buttons, one for the standard find me icon, and two for the various states of the record button—a circle (for record) and a pause icon (not shown). These icons are from App-Bits' free icon set available at <a class="ulink" href="http://app-bits.com/free-icons.html">http://app-bits.com/free-icons.html</a>. You might want to go ahead and download that set as well, if you haven't already.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec85"/>What did we do?</h2></div></div></div><p>In this task we've covered how the user interface will be designed and how the various pieces of it will work. We skipped discussing the document manager since it is virtually identical to the prior project, the only thing that has changed is the image we're using and the file extension.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Designing our data model</h1></div></div></div><p>In this task, <a id="id398" class="indexterm"/>we will work on designing our data models. <a id="id399" class="indexterm"/>We'll focus on our document and the items that go in it; the document manager model remains unchanged from the previous project.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec86"/>Getting ready</h2></div></div></div><p>If you look up the documentation for geolocation, you'll notice that the position information contains quite a bit of information including latitude, longitude, altitude, heading, and speed. Most implementations also return the accuracy of the location and altitude, but we'll be ignoring that for now. Since our map will show the current location, we will assume that the user won't start recording until the current location is correct, and so waiting for the accuracy to settle down is less important. If we were going to begin recording instantly, we would need to wait for the accuracy to narrow to an acceptable limit, and this is where those values become useful.</p><p>Go ahead and get out your paper and pencil, and we'll start working on our data model.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec87"/>Getting on with it</h2></div></div></div><p>Our data model will look like the following screenshot:</p><div><img src="img/9403_04_03.jpg" alt="Getting on with it"/></div><p>Technically, we<a id="id400" class="indexterm"/> have three models: the two shown in the preceding screenshot and the <code class="literal">PathRecDocumentCollection</code> model<a id="id401" class="indexterm"/>, which is identical to the document manager model<a id="id402" class="indexterm"/> we saw in the last project. <a id="id403" class="indexterm"/>Since it is identical, we'll skip that and focus on the two models shown in the preceding screenshot. Let's start with <code class="literal">PathRecDocumentItem</code>
<a id="id404" class="indexterm"/>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">timestamp</code><a id="id405" class="indexterm"/>, <code class="literal">latitude</code><a id="id406" class="indexterm"/>, <code class="literal">longitude</code><a id="id407" class="indexterm"/>, <code class="literal">altitude</code><a id="id408" class="indexterm"/>, <code class="literal">heading</code><a id="id409" class="indexterm"/>, and <code class="literal">speed</code><a id="id410" class="indexterm"/> are all properties our item needs to store. We'll collect these at object creation time and store them via <code class="literal">setPosition()</code> so that our item will be immediately populated. Unlike the <code class="literal">position</code> object used for geolocation, we won't store the coordinates in a <code class="literal">coords</code> object, but we will have to deal with that later.</li><li class="listitem" style="list-style-type: disc"><code class="literal">setPosition()</code><a id="id411" class="indexterm"/> takes either a geolocation position (with a <code class="literal">coords</code> object) or a serialized <code class="literal">PathRecDocumentItem</code> object (without a <code class="literal">coords</code> object). It will update the properties appropriately.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">get…()</code> property<a id="id412" class="indexterm"/> will return the requested property value.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">getLatLong()</code> property<a id="id413" class="indexterm"/> returns the latitude and longitude in the form <code class="literal">lat, long</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">getGoogleLatLng()</code> property<a id="id414" class="indexterm"/> returns a Google Maps <code class="literal">LatLng</code> object.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">getGoogleMarker()</code> property<a id="id415" class="indexterm"/> returns a Google Maps <code class="literal">Marker</code> object.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">serialize()</code> property<a id="id416" class="indexterm"/> returns an object ready for storing in a JSON document.</li></ul></div><p>Keep in mind that the preceding model only stores a single geolocation position; to string a bunch of them together requires the next model, <code class="literal">PathRecDocument</code>, which includes the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fileEntry</code><a id="id417" class="indexterm"/>, <code class="literal">filename</code><a id="id418" class="indexterm"/>, <code class="literal">completion</code><a id="id419" class="indexterm"/>, <code class="literal">failure</code><a id="id420" class="indexterm"/>, and <a id="id421" class="indexterm"/><code class="literal">state</code> are all the same as the document in our last project.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">title</code> property<a id="id422" class="indexterm"/> stores the title of the document.</li><li class="listitem" style="list-style-type: disc"><code class="literal">nodes</code><a id="id423" class="indexterm"/> is an array of the earlier-listed items; this is how we'll store a series of geolocation positions. Put them all together in a line, and we'll have the path that a user took during a recording.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">get</code>/<code class="literal">setTitle()</code> methods<a id="id424" class="indexterm"/> returns <a id="id425" class="indexterm"/>and sets the title of the document.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">get</code>/<code class="literal">setNodes()</code> methods <a id="id426" class="indexterm"/>will <a id="id427" class="indexterm"/>return and set the nodes; these take arrays.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">addNode()</code> method<a id="id428" class="indexterm"/> will push a node onto the list of notes; this must be a <code class="literal">PathRecDocumentItem</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">getNodeAtIndex()</code> method<a id="id429" class="indexterm"/> will return a node at the given index.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">getNodeCount()</code> method<a id="id430" class="indexterm"/> will return how many nodes are in the path.</li><li class="listitem" style="list-style-type: disc">The remaining methods are the same as the document model in the previous project.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">serialize()</code> method<a id="id431" class="indexterm"/> will return an object suitable for storing in a file. Unlike in the previous project, this time <code class="literal">serialize()</code> must iterate through each node, calling its <code class="literal">serialize()</code> method to build up an array of nodes without all the extra methods in <code class="literal">PathRecDocumentItem</code>. (After all, there's no reason to store these.) The result will be an object with a title property, and a nodes array with only the position information contained within; everything else will be stripped out.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec88"/>What did we do?</h2></div></div></div><p>In this task, we <a id="id432" class="indexterm"/>created our data model, and reused portions of our previous project's data model. After all, why reinvent the wheel, right?</p><p>Next up, we need to actually implement this data model. We'll tackle that in the next task.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Implementing our data model</h1></div></div></div><p>We'll be <a id="id433" class="indexterm"/>creating<a id="id434" class="indexterm"/> two files, namely, <code class="literal">PathRecDocumentCollection.js</code> and <code class="literal">PathRecDocument.js</code> to store our three data models. Since the first is so much like the last project's document manager, we'll skip over most of that code in the project and focus on the latter script.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec89"/>Getting ready</h2></div></div></div><p>Go ahead and open up <a id="id435" class="indexterm"/>your editor and copy the <code class="literal">PathRecDocument.js</code> and <code class="literal">PathRecDocumentCollection.js</code>, files from the <code class="literal">www/models</code> directory to your project so that you can follow along with our discussion of the implementation.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec90"/>Getting on with it</h2></div></div></div><p>Before we get <a id="id436" class="indexterm"/>started with the real meat, let's take a quick look at some changes in our <code class="literal">PathRecDocumentCollection</code> model in the <code class="literal">PathRecDocumentCollection.js</code> file:</p><div><pre class="programlisting">    self.renameDocumentAtIndexTo = function ( idx, newName, completion, failure )
    {
        self.completion = completion;
        self.failure = failure;
        self.state = "Renaming a Document";
        for (var i=0; i&lt;self.documents.length;i++)
        {
          if (self.documents[i].name.toLowerCase().trim() == newName.toLowerCase().trim())
            {
              self.dispatchFailure ( { "error": "The file already exists" } );
              return;
            }
        }
        self.documents [ idx ].moveTo ( self.fileSystem.root, newName.trim(), self.renameDocumentAtIndexToSuccess, self.dispatchFailure);
    }</pre></div><p>You'll notice that our <code class="literal">renameDocumentAtIndexTo</code> now has an additional few lines of code to ensure we don't overwrite a file that already exists. If there is a file with the same name, we dispatch an error to the <code class="literal">failure</code> method, and our document manager will happily prevent the user from doing anything dangerous. We've done the same thing to creating a document and copying a document.</p><p>With that out of the way, let's go to <code class="literal">PathRecDocumentItem</code> in <code class="literal">PathRecDocument.js</code>:</p><div><pre class="programlisting">var DOC = DOC || {};

DOC.PathRecDocumentItem = function ( position )
{
    var self = this;
    
    self.timestamp = {};
    self.latitude = 0;
    self.longitude = 0;
    self.altitude = 0;
    self.heading = 0;
    self.speed = 0;</pre></div><p>As with our model, the preceding defines our properties.</p><div><pre class="programlisting">    self.setPosition = function ( position )
    {
        self.timestamp = position.timestamp;
        
        if (position.coords)
        {
            self.latitude = position.coords.latitude;
            self.longitude = position.coords.longitude;
            self.altitude = position.coords.altitude;
            self.heading = position.coords.heading;
            self.speed = position.coords.speed;
        }
        else
        {
            self.latitude = position.latitude;
            self.longitude = position.longitude;
            self.altitude = position.altitude;
            self.heading = position.heading;
            self.speed = position.speed;
        }
    }</pre></div><p>The <code class="literal">setPosition()</code> method<a id="id437" class="indexterm"/> <a id="id438" class="indexterm"/>will set the properties to the incoming position<a id="id439" class="indexterm"/>. If it is a geolocation position (it will have a <code class="literal">coords</code> object), we use those values, but if it is a serialized <code class="literal">PathRecDocumentItem</code>, we just use those values instead.</p><div><pre class="programlisting">    self.getLatitude = function ()
    {
        return self.latitude;
    }</pre></div><p>Like in all good objects, we provide getters for all the properties. Since they are all so simple, we won't go over each one of them.</p><div><pre class="programlisting">    self.getLatLong = function ()
    {
      return self.latitude + "," + self.longitude;
    }
    
    self.getGoogleLatLng = function ()
    {
      return new google.maps.LatLng( self.latitude, self.longitude );
    }</pre></div><p>The previous two methods are really convenience methods. One is to return the latitude and longitude in the form <code class="literal">lat, long</code>, and another to return a Google Maps <code class="literal">LatLng</code> object. This object is a critical object in the Google Maps API.</p><div><pre class="programlisting">    self.getGoogleMarker = function ( withMap )
    {
      return new google.maps.Marker(
        {
            map:withMap,
            title:self.getLatLong(),
            draggable:false,
            position:self.getGoogleLatLng()
          }
        );
    }</pre></div><p>This is also a <a id="id440" class="indexterm"/>convenience method, but it returns a Google Maps <code class="literal">Marker</code> instead. This requires a Google Map to<a id="id441" class="indexterm"/> already be initialized, but otherwise it will set up a marker with the title of <code class="literal">Lat,</code> <code class="literal">Long</code> at the same position.</p><div><pre class="programlisting">    self.serialize = function ()
    {
      return {
        "timestamp": self.timestamp,
        "latitude": self.latitude,
        "longitude": self.longitude,
        "altitude": self.altitude,
        "heading": self.heading,
        "speed": self.speed
        };
    }</pre></div><p>In order to save the item to a file, it needs to be serialized. Since we don't need to serialize the methods, all we'll do is return an object with the location in it.</p><div><pre class="programlisting">    if (position)
    {
        self.setPosition ( position );
    }
}</pre></div><p>Finally, at the end of the constructor, we'll set the position, if one was passed to us. If not, the object will have no position data set at all.</p><p>Next, we'll look at the <code class="literal">PathRecDocument</code> object. A good majority of it is similar to the document object in the last project, so we'll omit those portions.</p><div><pre class="programlisting">DOC.PathRecDocument = function ( theFileEntry, completion, failure )
{
    
    self.title = "My Path";
    self.nodes = []; </pre></div><p>The only real difference so far is that instead of storing text, we're storing an array of <code class="literal">PathRecDocumentItems</code>. These will be used to store the coordinates within the path.</p><div><pre class="programlisting">    self.getNodes = function ()
    {
      return self.nodes;
    }
    
    self.setNodes = function ( theNodes )
    {
      self.nodes = theNodes;
    }</pre></div><p>So far, these getters <a id="id442" class="indexterm"/>and <a id="id443" class="indexterm"/>setters are pretty typical. We can request the list of items (<code class="literal">getNodes</code>), and give the object a new list (<code class="literal">setNodes</code>).</p><div><pre class="programlisting">    self.addNode = function ( aNode )
    {
      self.nodes.push ( aNode );
    }</pre></div><p>The <code class="literal">addNode()</code> method<a id="id444" class="indexterm"/> will put a new <code class="literal">PathRecDocumentItem</code> into our node list.</p><div><pre class="programlisting">    self.getNodeAtIndex = function ( idx )
    {
      return self.nodes[idx];
    }
    
      self.getNodeCount = function ()
    {
      return self.nodes.length;
    }</pre></div><p>While we could use the <code class="literal">getNodes()</code> method<a id="id445" class="indexterm"/> to return the entire list, it can also be convenient to work with them individually; hence we work with <code class="literal">getNodeAtIndex</code> and <code class="literal">getNodeCount</code>.</p><div><pre class="programlisting">    self.finishedReadingFile = function ( e )
    {
      var theFileContents = e.target.result;
      if (!theFileContents)
      {
        theFileContents = '{"title":"New File","nodes":[]}';
      }</pre></div><p>Most of the code leading up to the actually loading of our document has been omitted here. It's the same as the prior project, but here we start seeing some differences. First, if there's nothing in the file, we assume it to be a blank document, but we need to initialize our document with a default title and an empty list of nodes.</p><div><pre class="programlisting">        try
        {
          var data = JSON.parse ( theFileContents );
          self.title = data.title;
          for (var i=0; i&lt;data.nodes.length; i++)
          {
            self.addNode ( new DOC.PathRecDocumentItem ( data.nodes[i] ) );
          }
        }</pre></div><p>Next, while the title is easy enough to set, we have to iterate through the list of nodes from the file and add them to the document. When we complete, our document will have all the saved nodes in the file.</p><div><pre class="programlisting">    self.serialize = function ()
    {
      var serializedNodes = [];
      for (var i=0; i&lt;self.nodes.length; i++)
      {
        serializedNodes.push ( self.nodes[i].serialize() );
      }
      return { "title": self.title, "nodes": serializedNodes };
    }</pre></div><p>Saving the file<a id="id446" class="indexterm"/> contents is actually the same as in the previous project, but what has changed in the previous<a id="id447" class="indexterm"/> code snippet is the <code class="literal">serialize()</code> method<a id="id448" class="indexterm"/>. First, we create an empty array and then iterate through our list of positions. We then serialize each one and add the serialized result to our array. This ensures that the array has only position data without method definitions. Then we return the title and the serialized positions, this is enough to save the document!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec91"/>What did we do?</h2></div></div></div><p>In this task, we created the data model for each geolocation position, the document that contains them, and then reused the document manager implementation from the previous project.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Changing our document manager</h1></div></div></div><p>We've made a<a id="id449" class="indexterm"/> few <a id="id450" class="indexterm"/>minor changes to the way the document manager works. Nothing huge, but it does merit going over.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec92"/>Getting ready</h2></div></div></div><p>Open up <code class="literal">www/views/documentsView.html</code> in an editor so that you can follow along with the discussion.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec93"/>Getting on with it</h2></div></div></div><p>The largest change is how we deal with tapping parts of the document list display based on the platform <a id="id451" class="indexterm"/>we're on. If you recall in the last project, Android didn't feel terribly at home because one had to tap the icon to open the document, but if they tapped the name, they would be prompted to rename the document. In our new manager, we've reversed it so that tapping the name will open the document, and tapping the icon will prompt for a rename operation.</p><p>The changes are shown in the following document template:</p><div><pre class="programlisting">&lt;div id="documentsView_documentTemplate" class="hidden"&gt;
  &lt;div class="documentContainer"&gt;
<strong>  &lt;div class="documentTapArea" onclick="documentsView.documentContainerTapped(%INDEX%)"&gt;&lt;/div&gt;</strong>
  &lt;div class="documentImage"&gt;
<strong>    &lt;img src="img/DocumentImage.png" border=0 onclick="documentsView.documentIconTapped(%INDEX%)"/&gt;</strong>
  &lt;/div&gt;
<strong>  &lt;div class="documentTitle" onclick="documentsView.documentNameTapped(%INDEX%)"&gt;</strong>
    &lt;span &gt;%TITLE%&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class="documentActions"&gt;
    &lt;img src="img/Copy.png" width=28 height=28 border=0 onclick="documentsView.copyDocument(%INDEX%)" /&gt;
    &lt;img src="img/Share.png" width=27 height=28  border=0 onclick="documentsView.shareDocument(%INDEX%)" /&gt;
    &lt;img src="img/Trash.png" width=28 height=28  border=0 onclick="documentsView.deleteDocument(%INDEX%)" /&gt;
  &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>The key differences have <a id="id452" class="indexterm"/>been highlighted. First, we've introduced a new <code class="literal">div</code> element called <code class="literal">documentTapArea</code>
<a id="id453" class="indexterm"/>. This lives behind the entire document detail so that it can be a tap target for Android. It will fire off <code class="literal">documentContainerTapped()</code>
<a id="id454" class="indexterm"/> so that we can respond to the event should it happen.</p><p>The next difference is for the icon: we fire off <code class="literal">documentIconTapped()</code>
<a id="id455" class="indexterm"/> instead of <code class="literal">openDocument</code>.</p><p>The final difference is the title: we fire off <code class="literal">documentNameTapped()</code> instead of <code class="literal">renameDocument</code>.</p><p>These changes are easily picked out in the code, as seen in the following code snippet:</p><div><pre class="programlisting">  documentsView.documentIconTapped = function ( idx )
  {
    if (PKDEVICE.platform() == "ios")
    {
      documentsView.openDocument(idx);
    }
    else
    {
      documentsView.renameDocument(idx);
    }
  }
  
  documentsView.documentNameTapped = function ( idx )
  {
    if (PKDEVICE.platform() == "ios")
    {
      documentsView.renameDocument(idx);
    }
    else
    {
      documentsView.openDocument(idx);
    }
  }

  documentsView.documentContainerTapped = function ( idx )
  {
    if (PKDEVICE.platform() == "ios")
    {
      return;
    }
    else
    {
      documentsView.openDocument(idx);
    }
  }</pre></div><p>What we do in each of these methods is determine how to react based on the current platform. If we're an iOS device, <a id="id456" class="indexterm"/>the icon should open the <a id="id457" class="indexterm"/>document (it's the largest tap target), the tap target beneath the document should do nothing, and the title should prompt for a rename. On the other hand, all other devices should open a document if the name or tap target have been tapped, and only prompt for a rename if the icon has been tapped.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec94"/>What did we do?</h2></div></div></div><p>In this task we covered some of the subtle changes made to the document manager to help make it feel more at home on the Android platform.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Implementing our map view</h1></div></div></div><p>In reality, the appearance <a id="id458" class="indexterm"/>of our map view will be fairly simple.<a id="id459" class="indexterm"/> Google Maps will take care of the interactive content (and scrolling it, thankfully), so our primary focus will be on the navigation bar and interacting with the Google Maps.</p><p>When we're done, we should have something that looks like the following on iOS:</p><div><img src="img/9403_04_05.jpg" alt="Implementing our map view"/></div><p>The view on an <a id="id460" class="indexterm"/>Android device should be as follows:</p><div><img src="img/9403_04_06.jpg" alt="Implementing our map view"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec95"/>Getting ready</h2></div></div></div><p>We'll be<a id="id461" class="indexterm"/> working from <a id="id462" class="indexterm"/>the <code class="literal">mapView.js</code> file in the <code class="literal">www/views</code> directory, so go ahead and open it so you can follow along.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec96"/>Getting on with it</h2></div></div></div><p>Let's look at our HTML for the view first:</p><div><pre class="programlisting">&lt;div class="viewBackground"&gt;
  &lt;div class="navigationBar"&gt;
    &lt;div id="mapView_title"&gt;&lt;/div&gt;
    &lt;span style="display: block; position: absolute; right:10px; top: 6px; width:auto; text-align: right;"&gt;
    &lt;span class="iconButton " id="mapView_trackButton" style="margin-right: 10px;" &gt;&lt;/span&gt;
    &lt;span class="iconButton " id="mapView_actionButton" &gt;&lt;/span&gt;
    &lt;/span&gt;
    &lt;button class="barButton backButton" id="mapView_backButton" style="left:10px;" &gt;&lt;/button&gt;
  &lt;/div&gt;</pre></div><p>First, our navigation bar has a few buttons in it. <code class="literal">trackButton</code>
<a id="id463" class="indexterm"/> is intended to re-center the map on the user's<a id="id464" class="indexterm"/> location if the map has been moved. <code class="literal">actionButton</code>
<a id="id465" class="indexterm"/> is essentially the <em>record</em> button, but we've named it <em>action</em> because it controls the state of recording, essentially <em>start</em> and <em>stop</em>.</p><div><pre class="programlisting">  &lt;div class="content avoidNavigationBar" style="padding:0; overflow:hidden; " id="mapView_scroller"&gt;
    &lt;div id="mapView_contentArea"&gt;
    &lt;div id="mapView_mapCanvas" style="width:100%; height:100%;"&gt;
    &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>The only real difference <a id="id466" class="indexterm"/>between our other views and this one at this point in the code is the <code class="literal">div</code> element named <code class="literal">mapView_mapCanvas</code>; this will be used to hold our Google Map. We give it a <code class="literal">100%</code> width and height so that it fills the view.</p><p>And that's all there is to the view. Now let's look at the code behind it:</p><div><pre class="programlisting">  var mapView = $ge("mapView") || {};
  
  mapView.theFirstTime = true;
  mapView.theFileEntry = {};
  mapView.thePathDocument = {};
  mapView.theSaveTimer = -1;

  mapView.map = {};
  mapView.watchID = -1;
  mapView.polyline;
  mapView.currentPositionMarker = {};
  mapView.keepMapCentered = true;
  mapView.lastKnownPosition = {};
  mapView.recordingPath = false;</pre></div><p>The initial properties should look familiar, they are like those in the previous project. But beyond those, we start with several properties that are going to be critically important to our view. Let's go over them before proceeding:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">map</code> property<a id="id467" class="indexterm"/> will store the reference to the Google Map we'll eventually be creating.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">watchID</code> property<a id="id468" class="indexterm"/> will store the timer ID for the watch we'll create for geolocation. The idea is that PhoneGap will call an <code class="literal">update</code> function every time the position changes, and gives us this ID to cancel this update functionality when needed. While we're in the view, we can get as many position updates as needed, but when we leave the view, we should cancel the watch.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Polyline</code><a id="id469" class="indexterm"/> is another Google Maps API object. It will store a series of positions in an array, much like our own <code class="literal">PathRecDocument.nodes</code> property, but it does so in a <em>Google</em> way. We will have to translate our position items into this object in order to display the path on a map.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">currentPositionMarker</code> property<a id="id470" class="indexterm"/> will store a Google Maps <code class="literal">Marker</code> object. We'll use this marker to indicate the user's current position. You can get pretty fancy with the marker, including animating it and giving a custom image, but for now we'll use the defaults.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">keepMapCentered</code> property<a id="id471" class="indexterm"/> tracks whether or not we should, as the name implies, keep the map centered on the user's current position. If <code class="literal">true</code>, we'll pan the map's center to the current position at each update. But if <code class="literal">false</code>, we won't. We change this value whenever a <em>drag</em> is detected on the map. This means the user wants to explore the map around the current position, and if we didn't set this to <code class="literal">false</code>, the map would snap back to the current position every time the position changed, creating a disconcerting and painful experience.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">lastKnownPosition</code> property<a id="id472" class="indexterm"/> will store our last known position. This will always be kept up-to-date so that we can pan to the last known position whenever <code class="literal">keepMapCentered</code> is set to <code class="literal">true</code> after having once been set to <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">recordingPath</code> property<a id="id473" class="indexterm"/> indicates whether or not we are recording the current location. If true, we'll store position updates and add them to the document, but if false, we won't store any updates. The user can toggle this by tapping on <code class="literal">actionButton</code>.<div><pre class="programlisting">  mapView.actionButtonPressed = function ()
  {
    mapView.recordingPath = !mapView.recordingPath;
    if (mapView.recordingPath)
    {
      mapView.actionButton.innerHTML = __T("STOP");</pre></div><div><pre class="programlisting">    }
    else
    {
      mapView.actionButton.innerHTML = __T("RECORD");
    }
    mapView.geolocationUpdate ( mapView.lastKnownPosition );
  }</pre></div></li></ul></div><p>The <code class="literal">initializeView()</code> method<a id="id474" class="indexterm"/> itself is similar to our other views, so we'll skip ahead to <code class="literal">actionButtonPressed()</code>.<a id="id475" class="indexterm"/> <a id="id476" class="indexterm"/>All this function will do is toggle whether or not we are recording (and update the button accordingly). It then sends our view a geolocation update with the last known position. This way recording starts immediately and at the current position rather than waiting until a new position is received.</p><div><pre class="programlisting">  mapView.trackButtonPressed = function ()
  {
    mapView.keepMapCentered = true;
    mapView.geolocationUpdate ( mapView.lastKnownPosition );
  }</pre></div><p>If the user pans the map, <a id="id477" class="indexterm"/>we will turn <code class="literal">keepMapCentered</code>
<a id="id478" class="indexterm"/> to <code class="literal">false</code> so that the map doesn't keep springing back to the current position. This method will set it back to <code class="literal">true</code> and send a new update so that the map immediately moves to the current position (rather than waiting for a new update). This ensures that the map responds immediately, otherwise the user may not think anything happened.</p><p>If we're recording, this does of course incur an additional position in our path, but it will be at a previously known position, so it won't display. One could add code to prevent adding nodes that are exactly like the previous node.</p><div><pre class="programlisting">  mapView.geolocationUpdate = function ( position )
  {
    var theLatLng = new google.maps.LatLng ( 
      position.coords.latitude,
        position.coords.longitude );

    mapView.lastKnownPosition = position;

    if (mapView.keepMapCentered)
    {
      mapView.map.panTo ( theLatLng );
    }

    mapView.currentPositionMarker.setPosition (theLatLng);
    
    if (mapView.recordingPath)
    {
      mapView.polyline.getPath().push ( theLatLng );
      mapView.thePathDocument.addNode ( new 
         DOC.PathRecDocumentItem ( position ) );
    }
  }</pre></div><p>The <code class="literal">geolocationUpdate()</code> method<a id="id479" class="indexterm"/> is called every time the user's position changes (or at a set frequency, if you wish). The first thing we do is create a new <code class="literal">LatLng</code> object<a id="id480" class="indexterm"/> with the coordinates so that we can update our marker. We also store the position into our <code class="literal">lastKnownPosition</code> property<a id="id481" class="indexterm"/> so that we can re-center the map at any point.</p><p>If <code class="literal">keepMapCentered</code> is <code class="literal">true</code>, we call the <code class="literal">panTo()</code> method<a id="id482" class="indexterm"/> on the map, which will pan the map smoothly to the new position, if possible. If the new position is a long way out of the current view of <a id="id483" class="indexterm"/>the map, <a id="id484" class="indexterm"/>Google Maps will just snap to the new position without any animation. Thankfully, we don't have to actually track that on our own; we can be assured the map will be centered on the correct location.</p><p>We then update our marker with the correct location so that it is also up-to-date. If the user is playing with the map, this means they can always see the current location (if in view).</p><p>Finally, if we're recording, we call the <code class="literal">push()</code> method for the path in our polyline. This has the nice benefit of automatically updating the Google Maps view to include the change in our path. Then we add the node to our own document so that we can keep track of it as well.</p><div><pre class="programlisting">  mapView.geolocationError = function ( error )
  { 
    var anAlert =
      new PKUI.MESSAGE.Alert (
        __T("Geolocation Error"),
        __T(error.message) );
    anAlert.show();
  }</pre></div><p>The geolocation functionality also allows an error function. You could do many different things here as the error object will indicate with some granularity why the function is being called: a timeout (couldn't retrieve the position in a certain period of time), the position itself is unavailable, or our request for the position was denied (which a user has the right to do). In our case, we just display the message in an alert.</p><div><pre class="programlisting">...
  mapView.loadDocument = function ()
  {
    mapView.viewTitle = $ge("mapView_title");
    mapView.viewTitle.innerHTML =  mapView.theFileEntry.name.substr(0,mapView.theFileEntry.name.length-4);

    mapView.thePathDocument = new DOC.PathRecDocument (mapView.theFileEntry,function ()
        { 
          mapView.viewTitle.innerHTML = mapView.thePathDocument.getTitle();
          mapView.theSaveTimer = setInterval ( mapView.saveDocument, 5000 );
          for (var i=0; i&lt;mapView.thePathDocument.getNodeCount(); i++)
            {
              var theNode = mapView.thePathDocument.getNodeAtIndex ( i );
              mapView.polyline.getPath().push ( new google.maps.LatLng ( theNode.latitude, theNode.longitude ) );
            }
        },
        function (e)
        {
          PKUI.CORE.popView();
          var anAlert = new PKUI.MESSAGE.Alert (__T("Oops!"),__T("Couldn't open the file.") );
          anAlert.show();
        }
      );

    mapView.polyline = new google.maps.Polyline ( { strokeColor: '#80A0C0', strokeOpacity:0.85, strokeWeight:5 } );
    mapView.polyline.setMap ( mapView.map );
  }</pre></div><p>Loading our document is pretty similar to the previous project except for what happens after the document<a id="id485" class="indexterm"/> is completely <a id="id486" class="indexterm"/>loaded into memory. In order to display our path on the Google Map, we have to push all the loaded positions into the polyline, which is created near the end of the method.</p><div><pre class="programlisting">…
  mapView.viewWillAppear = function ()
  {
    document.addEventListener("backbutton", mapView.backButtonPressed, false );
    mapView.actionButton.innerHTML = __T("RECORD");
    mapView.trackButton.innerHTML = __T("CENTER");
  }
  mapView.viewDidAppear = function ()
  {

    if (mapView.theFirstTime)
    {
      mapView.map = new google.maps.Map ( $ge("mapView_mapCanvas"),
        {  disableDefaultUI: true,
              center: new google.maps.LatLng(40,-90),
              zoom: 15,
              mapTypeId: google.maps.MapTypeId.ROADMAP
         }
        );
        google.maps.event.addListener ( mapView.map, 'dragstart', function () { 
        mapView.keepMapCentered = false; } );
        mapView.currentPositionMarker = new 
        google.maps.Marker(
          {
            map:mapView.map,
            title: "Current Position"
          }
        );
    }
        mapView.watchID = navigator.geolocation.watchPosition (         mapView.geolocationUpdate, mapView.geolocationError,
        {
          enableHighAccuracy: true
        }
    );

    mapView.loadDocument(); 
  }</pre></div><p>When showing the view for the first time, we will create the Google Map. There's no real reason to create<a id="id487" class="indexterm"/> it again later <a id="id488" class="indexterm"/>which is why we do this once. The map uses our <code class="literal">mapView_mapCanvas</code> element<a id="id489" class="indexterm"/>, which is set to fill the entire view. Notice that we pass several properties to the constructor:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">disableDefaultUI</code><a id="id490" class="indexterm"/> when <code class="literal">true</code> will turn off all the UI <a id="id491" class="indexterm"/>elements on the Google Map. This means buttons such as switching between satellite and road map types will be gone, as well as street view, panning, and zooming. Interactions with the map still work, but getting the controls out of the way is a good idea in this case, since some of them will cause the app to open a new browser (such as street view).</li><li class="listitem" style="list-style-type: disc"><code class="literal">center</code><a id="id492" class="indexterm"/> is where<a id="id493" class="indexterm"/> the map should be initially centered. The latitude and longitude mean nothing in particular. It will be reset when the we get our first geolocation update.</li><li class="listitem" style="list-style-type: disc"><code class="literal">zoom</code> indicates<a id="id494" class="indexterm"/> how<a id="id495" class="indexterm"/> far the map should be zoomed. A level of 15 permits users to see their current street, so it is a pretty good level to start at. The user, of course, can change their zoom later to anything they want.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mapTypeId</code><a id="id496" class="indexterm"/> indicates<a id="id497" class="indexterm"/> the type of map, in this case, the road map type.</li></ul></div><p>Once we create a map, we also add a listener to it that is fired whenever the user pans the map on their own. If they do, we set <code class="literal">keepMapCentered</code> to <code class="literal">false</code> so that future updates won't re-center the map.</p><p>After that, we initialize<a id="id498" class="indexterm"/> our current position marker. We have to tell the marker which map it will be displayed on (the one we just created), and also the title of the marker. The title doesn't appear by default, so we've picked something nice and generic.</p><p>Near the end of the method, we create a watch for the user's position using <code class="literal">navigator.geolocation.watchPosition()</code>
<a id="id499" class="indexterm"/>. The first parameter indicates the <code class="literal">success</code> method to call, the second the <code class="literal">failure</code> method, and the third indicates the various options. All we are requesting in this option list is that the GPS return a highly accurate position. This can take several seconds to acquire, especially if the GPS hasn't been used in a while, so the user will see the position update as the GPS narrows things down. This is why we don't start recording <a id="id500" class="indexterm"/>immediately upon displaying the view; otherwise, we'd have to implement some sort of tolerance method to figure out when the position was accurate enough. In our case, the user will only start recording once they are satisfied with the current position on the screen, so they do our work for us.</p><p>At the end of the method, we kick off loading our document so that the view will be populated as quickly as possible.</p><p>Oh, and if you're asking why we are using <code class="literal">viewWillAppear</code>
<a id="id501" class="indexterm"/> and <code class="literal">viewDidAppear</code>
<a id="id502" class="indexterm"/>, it's because the Google Map doesn't like to be created while the view is in the process of being animated in. Therefore, we let the animation occur, and then load the map when everything has settled down.</p><div><pre class="programlisting">  mapView.viewWillHide = function ()
  {
    navigator.geolocation.clearWatch ( mapView.watchID );
    mapView.recordingPath = false;
    mapView.keepMapCentered = true;
    mapView.polyline.setMap (null); // remove from the map.
    mapView.polyline = null; // and destroy.

  }</pre></div><p>When the view is about to be dismissed, we clear the watch on the user's position. After all, there's little to no reason to continue receiving updates when the view isn't the current view on the stack. We also turn recording off (just in case the user didn't stop the recording before dismissing the view), and turn map centering back on. We then tell the polyline that it shouldn't be<a id="id503" class="indexterm"/> visible on the map anymore and destroy it. If we didn't do this, it would be all too easy for previous paths to show up on the map from previously loaded documents.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec97"/>What did we do?</h2></div></div></div><p>In this task, we created an interactive Google Map that displays a recorded path as well as the user's current position. We dealt with polylines (which actually display the path on the map) as well as markers. We also handled recording the path and centering the map.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec98"/>What else do I need to know?</h2></div></div></div><p>Here's the sad truth as our application currently stands: when the phone is locked or the app is in the background, no updates occur. This is expected behavior as the phone has no real way to know that we want to continue receiving updates. There are platform-specific methods that you can use to register your app to continue working during a lock or backgrounding, but we'll let you go into those yourself. For now, the app only receives updates when the screen is on and the app is in the foreground.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Game Over..... Wrapping it up</h1></div></div></div><p>In this project we <a id="id504" class="indexterm"/>achieved quite a bit. We created an interactive Google Map that the user can pan and zoom. We created markers and polylines that displayed on the map as well. We also created a way to record a path and then later display it. We also created the document model capable of storing the positional information so that it could be saved and loaded. Finally, we also made some minor changes to the document manager to make it a little more friendly to Android devices.</p><p>Some resources you might find useful:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Google Maps API (3.9) at <a class="ulink" href="https://developers.google.com/maps/documentation/javascript/3.9/reference">https://developers.google.com/maps/documentation/javascript/3.9/reference</a></li><li class="listitem" style="list-style-type: disc">KML at <a class="ulink" href="https://developers.google.com/kml/documentation/">https://developers.google.com/kml/documentation/</a></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Can you take the HEAT? The HotshotChallenge</h1></div></div></div><p>We've done quite a bit in this project, but there's always room for improvement<a id="id505" class="indexterm"/> and extension. Why don't you see if you can complete some of these challenges?</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add the ability to share a path with a friend. This could include an image of the path, the file, or some creative representation. Or, you could get into the <em>native</em> side of things and look at how to tell the phone that your app can open certain kinds of files.</li><li class="listitem" style="list-style-type: disc">Add the ability to export a path to KML. This is a standard interchange format for geolocation data.</li><li class="listitem" style="list-style-type: disc">Add displays of the additional data we're capturing. We only show a path using latitude and longitude, but we're capturing heading, speed, and altitude as well.</li><li class="listitem" style="list-style-type: disc">Add the ability to edit the path once recorded, including moving, removing, and adding points.</li><li class="listitem" style="list-style-type: disc">Come up with a way to reduce the amount of data recorded. We track every point as the user's position changes, but this is often not necessary. If someone is driving in a straight line, it would make the most sense to discard the intervening points (as well as save memory).</li><li class="listitem" style="list-style-type: disc">This may involve some native coding, but look into and implement what is required to allow the app to capture geolocation data even while in the background and/or the device is locked. (This would save battery life, since the display wouldn't need to be visible.)</li></ul></div></div></body></html>