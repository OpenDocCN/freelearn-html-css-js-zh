<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;SOLID Principles"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. SOLID Principles</h1></div></div></div><p>SOLID Principles are well-known Object-Oriented Design (<span class="strong"><strong>OOD</strong></span>)principles summarized by Uncle Bob (Robert C. Martin). The word SOLID comes from the initials of the five principles it refers to, including <span class="strong"><strong>Single responsibility principle</strong></span>, <span class="strong"><strong>Open-closed principle</strong></span>, <span class="strong"><strong>Liskov substitution principle</strong></span>, <span class="strong"><strong>Interface segregation principle</strong></span> and <span class="strong"><strong>Dependency inversion principle</strong></span>. Those principles are closely related to each other, and can be a great guidance in practice.</p><p>Here is a widely used summary of SOLID principles from Uncle Bob:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Single responsibility principle</strong></span>: A class should have one, and only one, reason to change</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Open-closed principle</strong></span>: You should be able to extend a classes behavior, without modifying it</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Liskov substitution principle</strong></span>: Derived classes must be substitutable for their base classes</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Interface segregation principle</strong></span>: Make fine-grained interfaces that are client specific</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dependency inversion principle</strong></span>: Depend on abstractions, not on concretions</li></ul></div><p>In this chapter, we will walk through them and find out how those principles can help form a design that <span class="emphasis"><em>smells</em></span> nice.</p><p>But before we proceed, I want to mention that a few of the reasons why those principles exist might be related to the age in which they were raised, the languages and their building or distributing process people were working with, and even computing resources. When being applied to JavaScript and TypeScript projects nowadays, some of the details may not be necessary. Think more about what problems those principles want to prevent people from getting into, rather than the literal descriptions of how a principle should be followed.</p><div class="section" title="Single responsibility principle"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Single responsibility principle</h1></div></div></div><p>The single responsibility principle declares that a class should have one, and only one reason to change. And the definition of the world <span class="emphasis"><em>reason</em></span> in this sentence is important.</p><div class="section" title="Example"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec121"/>Example</h2></div></div></div><p>Consider a <code class="literal">Command</code> class that is designed to work with both command-line interface and graphical user interface:</p><pre class="programlisting">class Command { &#13;
  environment: Environment; &#13;
 &#13;
  print(items: ListItem[]) { &#13;
    let stdout = this.environment.stdout; &#13;
   &#13;
    stdout.write('Items:\n'); &#13;
   &#13;
    for (let item of items) { &#13;
      stdout.write(item.text + '\n'); &#13;
    } &#13;
  } &#13;
   &#13;
  render(items: ListItem[]) { &#13;
    let element = &lt;List items={items}&gt;&lt;/List&gt;; &#13;
    this.environment.render(element); &#13;
  } &#13;
   &#13;
  execute() { } &#13;
} &#13;
</pre><p>To make this actually work, <code class="literal">execute</code> method would need to handle both the command execution and result displaying:</p><pre class="programlisting">class Command { &#13;
  .. &#13;
   &#13;
<span class="strong"><strong>  execute() {</strong></span>
<span class="strong"><strong>    &#13;
  let items = ...;&#13;
</strong></span>
<span class="strong"><strong>    if (this.environment.type === 'cli') {&#13;
</strong></span>
<span class="strong"><strong>      this.print(items);&#13;
</strong></span>
<span class="strong"><strong>    } else {&#13;
</strong></span>
<span class="strong"><strong>      this.render(items);&#13;
</strong></span>
<span class="strong"><strong>    }&#13;
</strong></span>
<span class="strong"><strong>  }</strong></span> &#13;
} &#13;
</pre><p>In this example, there are two reasons for changes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">How a command gets executed.</li><li class="listitem">How the result of a command gets displayed in different environments.</li></ol></div><p>Those reasons lead to changes in different dimensions and violate the single responsibility principle. This might result in a messy situation over time. A better solution is to have those two responsibilities separated and managed by the <code class="literal">CommandEnvironment</code>:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_001.jpg" alt="Example"/></div><p>
</p><p>Does this look familiar to you? Because it is a variant of the Visitor Pattern. Now it is the environment that executes a specific command and handles its result based on a concrete environment class.</p></div><div class="section" title="Choosing an axis"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec122"/>Choosing an axis</h2></div></div></div><p>You might be thinking, doesn't <code class="literal">CommandResult</code> violate the single responsibility principle by having the abilities to display content in a different environment? Yes, and no. When the axis of this reason is set to displaying content, it does not; but if the axis is set to displaying in a specific environment, it does. But take the overall structure into consideration, the result of a command is expected to be an output that can adapt to a different environment. And thus the reason is one-dimensional and confirms the principle.</p></div></div></div>
<div class="section" title="Open-closed principle"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Open-closed principle</h1></div></div></div><p>The open-closed principle declares that you should be able to extend a class' behavior, without modifying it. This principle is raised by Bertrand Meyer in 1988:</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</em></span>
</p></blockquote></div><p>A program depends on all the entities it uses, that means changing the already-being-used part of those entities may just crash the entire program. So the idea of the open-closed principle is straightforward: we'd better have entities that never change in any way other than extending itself.</p><p>That means once a test is written and passing, ideally, it should never be changed for newly added features (and it needs to keep passing, of course). Again, ideally.</p><div class="section" title="Example"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec123"/>Example</h2></div></div></div><p>Consider an API hub that handles HTTP requests to and responses from the server. We are going to have several files written as modules, including <code class="literal">http-client.ts</code>, <code class="literal">hub.ts</code> and <code class="literal">app.ts</code> (but we won't actually write <code class="literal">http-client.ts</code> in this example, you will need to use some imagination).</p><p>Save the code below as file <code class="literal">hub.ts</code>.</p><pre class="programlisting">import { HttpClient, HttpResponse } from './http-client'; &#13;
 &#13;
export function update(): Promise&lt;HttpResponse&gt; { &#13;
  let client = new HttpClient(); &#13;
   &#13;
  return client.get('/api/update'); &#13;
} &#13;
</pre><p>And save the code below as file <code class="literal">app.ts</code>.</p><pre class="programlisting">import Hub from './hub'; &#13;
 &#13;
Hub &#13;
  .update() &#13;
  .then(response =&gt; JSON.stringify(response.text)) &#13;
  .then(result =&gt; { &#13;
    console.log(result); &#13;
}); &#13;
</pre><p>Bravely done! Now we have <code class="literal">app.ts</code> badly coupled with <code class="literal">http-client.ts</code>. And if we want to adapt this API hub to something like WebSocket, BANG.</p><p>So how can we create entities that are open for extension, but closed for modification? The key is a <span class="emphasis"><em>stable abstraction that adapts</em></span>. Consider the storage and client example we took with Adapter Pattern in <a class="link" href="ch04.html" title="Chapter 4. Structural Design Patterns">Chapter 4</a>, <span class="emphasis"><em>Structural Design Patterns</em></span> we had a <code class="literal">Storage</code> interface that isolates implementation of database operations from the client. And assuming that the interface is well-designed to meet upcoming feature requirements, it is possible that it will never change or just need to be extended during the life cycle of the program.</p></div><div class="section" title="Abstraction in JavaScript and TypeScript"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec124"/>Abstraction in JavaScript and TypeScript</h2></div></div></div><p>Guess what, our beloved JavaScript does not have an interface, and it is dynamically typed. We were not even able to actually write an interface. However, we could still write down documentation about the abstraction and create new concrete implementations just by obeying that description.</p><p>But TypeScript offers interface, and we can certainly take advantage of it. Consider the <code class="literal">CommandResult</code> class in the previous section. We were writing it as a concrete class, but it may have subclasses that override the <code class="literal">print</code> or <code class="literal">render</code> method for customized output. However, the type system in TypeScript cares only about the shape of a type. That means, while you are declaring an entity with type <code class="literal">CommandResult</code>, the entity does not need to be an instance of <code class="literal">CommandResult</code>: any object with a compatible type (namely has methods <code class="literal">print</code> and <code class="literal">render</code> with proper signatures in this case) will do the job.</p><p>For example, the following code is valid:</p><pre class="programlisting">let environment: Environment; &#13;
 &#13;
let command: Command = { &#13;
  environment, &#13;
  print(items) { }, &#13;
  render(items) { }, &#13;
  execute() { } &#13;
}; &#13;
</pre></div><div class="section" title="Refactor earlier"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec125"/>Refactor earlier</h2></div></div></div><p>I double stressed that the open-closed principle can only be perfectly followed under ideal scenarios. That can be a result of two reasons:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="emphasis"><em>Not all entities in a system can be open to extension and closed to modification at the same time</em></span>. There will always be changes that need to break the closure of existing entities to complete their functionalities. When we are designing the interfaces, we need different strategies for creating stable closures for different foreseeable situations. But this requires notable experience and no one can do it perfectly.</li><li class="listitem"><span class="emphasis"><em>None of us is too good at designing a program that lasts long and stays healthy forever</em></span>. Even with thorough consideration, abstractions designed at the beginning can be choppy facing the changing requirements.</li></ol></div><p>So when we are expecting the entities to be closed for modification, it does not mean that we should just stand there and watch it being closed. Instead, when things are still under control, we should refactor and <span class="emphasis"><em>keep the abstraction in the status of being open to extension and closed to modification</em></span> at the time point of refactoring.</p></div></div>
<div class="section" title="Liskov substitution principle"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Liskov substitution principle</h1></div></div></div><p>The open-closed principle is the essential principle of keeping code maintainable and reusable. And the key to the open-closed principle is abstraction with polymorphism. Behaviors like implementing interfaces, or extending classes make polymorphic <span class="emphasis"><em>shapes</em></span>, but that might not be enough.</p><p>The Liskov substitution principle declares that derived classes must be substitutable for their base classes. Or in the words of Barbara Liskov, who raised this principle:</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</em></span>
</p></blockquote></div><p>Never mind. Let's try another one: <span class="emphasis"><em>any foreseeable usage of the instance of a class should be working with the instances of its derived classes.</em></span>
</p><div class="section" title="Example"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec126"/>Example</h2></div></div></div><p>And here we go with a straightforward violation example. Consider <code class="literal">Noodles</code> and <code class="literal">InstantNoodles</code> (a subclass of <code class="literal">Noodles</code>) to be cooked:</p><pre class="programlisting">function cookNoodles(noodles: Noodles) { &#13;
  if (noodles instanceof InstantNoodles) { &#13;
    cookWithBoiledWaterAndBowl(noodles); &#13;
  } else { &#13;
    cookWithWaterAndBoiler(noodles); &#13;
  } &#13;
} &#13;
</pre><p>Now if we want to have some fried noodles... The <code class="literal">cookNoodles</code> function does not seem to be capable of handling that. Clearly, this violates the Liskov substitution principle, though it does not mean that it's a bad design.</p><p>Let's consider another example written by Uncle Bob in his article talking about this principle. We are creating class <code class="literal">Square</code> which is a subclass of <code class="literal">Rectangle</code>, but instead of adding new features, it adds a constraint to <code class="literal">Rectangle</code>: the width and height of a square should always be equal to each other. Assume we have a <code class="literal">Rectangle</code> class that allows its width and height to be set:</p><pre class="programlisting">class Rectangle { &#13;
  constructor( &#13;
    private _width: number; &#13;
    private _height: number; &#13;
  ) { } &#13;
   &#13;
  set width(value: number) { &#13;
    this._width = value; &#13;
  } &#13;
   &#13;
  set height(value: number) { &#13;
    this._height = value; &#13;
  } &#13;
} &#13;
</pre><p>Now we have a problem with its subclass <code class="literal">Square</code>, because it gets <code class="literal">width</code> and <code class="literal">height</code> setters from <code class="literal">Rectangle</code> while it shouldn't. We can certainly override those setters and make both of them update width and height simultaneously. But in some situations, the client might just not want that, because doing so will make the program harder to be predicted.</p><p>The <code class="literal">Square</code> and <code class="literal">Rectangle</code> example violates the Liskov substitution principle. Not because we didn't find a good way to inherit, but because <code class="literal">Square</code> does not conform the behavior of <code class="literal">Rectangle</code> and should not be a subclass of it at the beginning.</p></div><div class="section" title="The constraints of substitution"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec127"/>The constraints of substitution</h2></div></div></div><p>Type is an important part in a programming language, even in JavaScript. But having the same <span class="emphasis"><em>shape</em></span>, being on the same hierarchy does not mean they can be the substitution of another without some pain. More than just the <span class="emphasis"><em>shape</em></span>, the complete behavior is what really matters for implementations that hold to the Liskov substitution principle.</p></div></div>
<div class="section" title="Interface segregation principle"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Interface segregation principle</h1></div></div></div><p>We've already discussed the important role played by abstractions in object-oriented design. The abstractions and their derived classes without separation usually come up with hierarchical tree structures. That means when you choose to create a branch, you create a parallel abstraction to all of those on another branch.</p><p>For a family of classes with only one level of inheritance, this is not a problem: because it is just what you want to have those classes derived from. But for a hierarchy with greater depth, it could be.</p><div class="section" title="Example"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec128"/>Example</h2></div></div></div><p>Consider the <code class="literal">TextReader</code> example we took with Template Method Pattern in <a class="link" href="ch06.html" title="Chapter 6. Behavioral Design Patterns: Continuous">Chapter 6</a>, <span class="emphasis"><em>Behavioral Design Patterns: Continuous</em></span> we had <code class="literal">FileAsciiTextReader</code> and <code class="literal">HttpAsciiTextReader</code> derived from <code class="literal">AsciiTextReader</code>. But what if we want to have other readers that understand UTF-8 encoding?</p><p>To achieve that goal, we have two common options: separate the interface into two for different objects that cooperate, or separate the interface into two then get them implemented by a single class.</p><p>For the first case, we can refactor the code with two abstractions, <code class="literal">BytesReader</code> and <code class="literal">TextReader</code>:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_002.jpg" alt="Example"/></div><p>
</p><p>And for the second case, we can separate method <code class="literal">readAllBytes</code> and <code class="literal">decodeBytes</code> onto two interfaces, for example, <code class="literal">BytesReader</code> and <code class="literal">BytesDecoder</code>. Thus we may implement them separately and use techniques like mixin to put them together:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_003.jpg" alt="Example"/></div><p>
</p><p>An interesting point about this example is that <code class="literal">TextReader</code> above itself is an abstract class. To make this mixin actually work, we need to create a concrete class of <code class="literal">TextReader</code> (without actually implementing <code class="literal">readAllBytes</code> and <code class="literal">decodeBytes</code>), and then mixin two concrete classes of <code class="literal">BytesReader</code> and <code class="literal">BytesDecoder</code>.</p></div><div class="section" title="Proper granularity"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec129"/>Proper granularity</h2></div></div></div><p>It is said that by creating smaller interfaces, we can avoid a client from using big classes with features that it never needs. This may cause unnecessary usage of resources, but in practice, that usually won't be a problem. The most important part of the interface segregation principle is still about keeping code maintainable and reusable.</p><p>Then the question comes out again, how small should an interface be? I don't think I have a simple answer for that. But I am sure that being too small might not help.</p></div></div>
<div class="section" title="Dependency inversion principle"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Dependency inversion principle</h1></div></div></div><p>When we talk about dependencies, the natural sense is about dependencies from bottom to top, just like how buildings are built. But unlike a building that stands for tens of years with little change, software keeps changing during its life cycle. Every change costs, more or less.</p><p>The dependency inversion principle declares that entities should depend on abstractions, not on concretions. Higher level code should not depend directly on low-level implementations, instead, it should depend on abstractions that <span class="emphasis"><em>lead to</em></span> those implementations. And this is why things are <span class="emphasis"><em>inverse</em></span>.</p><div class="section" title="Example"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec130"/>Example</h2></div></div></div><p>Still taking the HTTP client and API hub as an example, which obviously violates the dependency inversion principle, taking the foreseeable application into consideration, what the API hub should depend on is a messaging mechanism bridging client and server, but not bare HTTP client. This means we should have an abstraction layer of messaging before the concrete implementation of HTTP client:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_004.jpg" alt="Example"/></div><p>
</p></div><div class="section" title="Separating layers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec131"/>Separating layers</h2></div></div></div><p>Compared to other principles discussed in this chapter, the dependency inversion principle cares more about the scope of modules or packages. As the abstraction might usually be more stable than concrete implementations, by following dependency inversion principle, we can minimize the impact from low-level changes to higher level behaviors.</p><p>But for JavaScript (or TypeScript) projects as the language is dynamically typed, this principle is more about an idea of guidance that leads to a stable abstraction between different layers of code implementation.</p><p>Originally, an important benefit of following this principle is that, if modules or packages are relatively larger, separating them by abstraction could save a lot of time in compilation. But for JavaScript, we don't have to worry about that; and for TypeScript, we don't have to recompile the entire project for making changes to separated modules either.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, we walked through the well-known SOLID principles with simple examples. Sometimes, following those principles could lead us to a useful design pattern. And we also found that those principles are strongly bound to each other. Usually violating one of them may indicate other violations.</p><p>Those principles could be extremely helpful for OOD, but could also be overkill if they are applied without proper adaptions. A well-designed system should have those principles confirmed just right, or it might harm.</p><p>In the next chapter, instead of theories, we'll have more time with a complete workflow with testing and continuous integration involved.</p></div></body></html>