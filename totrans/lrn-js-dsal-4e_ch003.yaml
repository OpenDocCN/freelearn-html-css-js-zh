- en: 2 Big O notation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 Big O 表示法
- en: '**Before you begin: Join our book community on Discord**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**在开始之前：加入我们的Discord书籍社区**'
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的Discord服务器上与其他早期读者聊天（在“学习-javascript-dsa-4e”频道下找到“EARLY ACCESS
    SUBSCRIPTION”）。
- en: '![](img/file0.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
- en: 'In this chapter, we will unlock the power of **Big O notation**, a fundamental
    tool for analyzing the efficiency of algorithms in terms of both **time complexity**
    (how runtime scales with input size) and **space complexity** (how memory usage
    scales). We will explore common time complexities like *O(1)*, *O(log n)*, *O(n)*,
    and others, along with their real-world implications for choosing the right algorithms
    and optimizing code. Understanding Big O notation is not only essential for writing
    scalable and performant software but also for acing technical interviews, as it
    demonstrates your ability to think critically about algorithmic efficiency. In
    this chapter we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将揭示**Big O 表示法**的力量，这是一个分析算法效率的基本工具，它涉及**时间复杂度**（运行时间如何随着输入规模的变化而变化）和**空间复杂度**（内存使用率如何变化）。我们将探讨常见的如
    *O(1)*、*O(log n)*、*O(n)* 等时间复杂度，以及它们在选择正确算法和优化代码方面的实际影响。理解Big O 表示法不仅对于编写可扩展和性能良好的软件至关重要，而且对于通过技术面试也至关重要，因为它展示了你批判性地思考算法效率的能力。在本章中，我们将涵盖：
- en: Big O time complexities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Big O 时间复杂度
- en: Space complexity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间复杂度
- en: Calculating the complexity of an algorithm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算算法的复杂度
- en: Big O notation and tech interviews
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Big O 表示法和技术面试
- en: Exercises
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习
- en: Understanding Big O notation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Big O 表示法
- en: Big O notation is used to describe and classify the performance or complexity
    of an algorithm according to how much time it will take for the algorithm to run
    as the input size grows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Big O 表示法用于描述和分类算法的性能或复杂度，根据输入规模增长时算法运行所需的时间来衡量。
- en: And how do we measure the efficiency of an algorithm? We usually use resources
    such as CPU (time) usage, memory usage, disk usage, and network usage. When talking
    about Big O notation, we usually consider CPU (time) usage.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何衡量算法的效率呢？我们通常使用资源，如CPU（时间）使用率、内存使用率、磁盘使用率和网络使用率。当谈到Big O 表示法时，我们通常考虑CPU（时间）使用率。
- en: In simpler terms, this notation is a way to describe how the running time of
    an algorithm grows as the size of the input gets bigger. While the actual time
    an algorithm takes to run can vary depending on factors like processor speed and
    available resources, Big O notation allows us to focus on the fundamental steps
    an algorithm must take. Think of it as measuring the number of operations an algorithm
    performs relative to the input size.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用更简单的话来说，这种表示法是一种描述算法运行时间如何随着输入规模增大而增长的方法。虽然算法实际运行所需的时间可能会因处理器速度和可用资源等因素而变化，但Big
    O 表示法允许我们关注算法必须执行的基本步骤。把它想象成测量算法相对于输入规模执行的操作数量。
- en: Imagine you have a stack of papers on your desk. If you need to find a specific
    document, you will have to search through each paper one by one until you locate
    it. With a small stack of 10 papers, this would not take long. But if you had
    20 papers, the search would likely take twice as long, and with 100 papers, it
    could take ten times as long!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你桌子上有一摞文件。如果你需要找到一份特定的文件，你必须逐张搜索直到找到它。对于10张小文件堆，这不会花很长时间。但是如果你有20张文件，搜索可能需要两倍的时间，而有100张文件时，可能需要十倍的时间！
- en: The tasks that a developer must perform daily include choosing what data structure
    and algorithms to use to resolve a specific problem. It can be an existing algorithm,
    or you may have to write your own logic to resolve a business user story. It is
    important to note that any algorithm can work fine and seem okay for a low volume
    of data, however, then the volume of the input data increases, an inefficient
    algorithm will grind to halt and impact the application. Knowing how to measure
    performance is key to achieving these tasks successfully.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者必须每天完成的任务包括选择使用哪些数据结构和算法来解决特定问题。这可能是一个现有的算法，或者你可能需要编写自己的逻辑来解决业务用户故事。需要注意的是，任何算法在处理低量级数据时可能运行良好，看起来也还不错，然而，当输入数据的量增加时，效率低下的算法将变得缓慢，并影响应用程序。了解如何衡量性能是实现这些任务成功的关键。
- en: Big O notation is important because it helps us compare different algorithms
    and choose the most efficient one for a particular task. For instance, if you
    are searching for a specific product in a large online store, you would not want
    to use an algorithm that requires looking at every single product. Instead, you
    would use a more efficient algorithm that only needs to look at a small subset
    of products.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号很重要，因为它帮助我们比较不同的算法，并为特定任务选择最有效的算法。例如，如果你在一个大型在线商店中寻找特定的产品，你不会想使用需要查看每个产品的算法。相反，你会使用一个更高效的算法，该算法只需要查看产品的小子集。
- en: Big O time complexities
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大O时间复杂度
- en: Big O notation uses capital *O* to denote upper bound. It signifies that the
    actual running time could be less than but not greater than what the function
    expresses. It does not tell us the exact running time of an algorithm. Instead,
    it tells us how bad things could get as the input size grows large.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号使用大写 *O* 来表示上界。它表示实际运行时间可能小于但不大于函数所表达的时间。它并不告诉我们算法的确切运行时间。相反，它告诉我们当输入大小增大时，事情可能变得有多糟糕。
- en: Imagine you have a messy room and need to find a specific sock. In the worst
    case, you have to check each item of clothing one by one (this is like a linear
    time algorithm). Big O tells you that even if your room gets super messy, you
    will not need to look at more items than are actually there. You might get lucky
    and find the sock quickly! The actual time might be much less than the Big O prediction.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有一个杂乱的房间，需要找到一只特定的袜子。在最坏的情况下，你必须逐件检查每一件衣服（这就像线性时间算法）。大O告诉你，即使你的房间变得非常杂乱，你也不需要查看比实际存在的物品更多的物品。你可能很幸运，能快速找到袜子！实际时间可能远小于大O预测的时间。
- en: 'When analyzing algorithms, the following classifications of time and space
    complexities are most encountered:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析算法时，最常遇到的时间复杂度和空间复杂度的分类如下：
- en: '| **Notation** | **Name** | **Explanation** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **名称** | **说明** |'
- en: '| O(1) | Constant | The algorithm''s runtime or space usage remains the same
    regardless of the input size (n). |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| O(1) | 常数 | 算法的运行时间或空间使用量不随输入大小（n）的变化而变化。|'
- en: '| O(log(n)) | Logarithmic | The algorithm''s runtime or space usage grows logarithmically
    with the input size (n). This means that as the input size doubles, the number
    of operations or memory usage increases by a constant amount. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| O(log(n)) | 对数 | 算法的运行时间或空间使用量与输入大小（n）的对数成正比。这意味着当输入大小加倍时，操作次数或内存使用量增加一个常数量。|'
- en: '| O(n) | Linear | The algorithm''s runtime or space usage grows linearly with
    the input size (n). This means that as the input size doubles, the number of operations
    or memory usage also doubles. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| O(n) | 线性 | 算法的运行时间或空间使用量与输入大小（n）线性增长。这意味着当输入大小加倍时，操作次数或内存使用量也会加倍。|'
- en: '| O(n ² ) | Quadratic | The algorithm''s runtime or space usage grows quadratically
    with the input size (n). This means that as the input size doubles, the number
    of operations or memory usage quadruples. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| O(n²) | 二次方 | 算法的运行时间或空间使用量与输入大小（n）的平方成正比。这意味着当输入大小加倍时，操作次数或内存使用量会增加到原来的四倍。|'
- en: '| O(n ^c ) | Polynomial | The algorithm''s runtime or space usage grows as
    a polynomial function of the input size (n). This means that as the input size
    doubles, the number of operations or memory usage increases by a factor (c) that
    is a polynomial function of the input size. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| O(n^c) | 多项式 | 算法的运行时间或空间使用量随着输入大小（n）的多项式函数增长。这意味着当输入大小加倍时，操作次数或内存使用量增加一个因子（c），该因子是输入大小的多项式函数。|'
- en: '| O(c ^n ) | Exponential | The algorithm''s runtime or space usage grows exponentially
    with the input size (n). This means that as the input size increases, the number
    of operations or memory usage grows at an increasingly rapid rate. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| O(c^n) | 指数 | 算法的运行时间或空间使用量与输入大小（n）的指数成正比。这意味着当输入大小增加时，操作次数或内存使用量的增长速度会越来越快。|'
- en: 'Table 2.1: Big O notation classifications of time and space complexities'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：大O符号的时间复杂度和空间复杂度分类
- en: Let's review each one to understand time complexities in detail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一回顾，以详细了解时间复杂度。
- en: 'O(1): constant time'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O(1)：常数时间
- en: '*O(1)* signifies that an algorithm''s runtime (or sometimes space complexity)
    remains constant, regardless of the size of the input data. Whether we are dealing
    with a small input or a massive one, the time it takes to execute the algorithm
    does not change significantly.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*O(1)* 表示算法的运行时间（或有时是空间复杂度）保持不变，无论输入数据的大小如何。无论是处理小输入还是大输入，执行算法所需的时间都不会显著变化。'
- en: 'For example, suppose we would like to calculate the number of seconds of a
    given number of days. We could create the following function to resolve this request:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each minute has 60 seconds, each hour has 60 minutes, and each day has 24 hours.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'And we can use `console.log` to see the output of the results passing different
    numbers of days:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we call this function passing `1` as argument (`secondsinDays(1)`), it will
    take a few milliseconds for this code to output the results. If we execute the
    function again passing `10` as argument (`secondsinDays(10)`), it will also take
    a few milliseconds for the code to output the results.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: This `secondsInDays` function has a time complexity of *O(1)* – constant time.
    The number of operations it performs (multiplication) is fixed and doesn't change
    with the input `numberOfDays`. It will take the same amount of time to calculate
    the result, whether you input 1 day or 1000 days.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '*O(1)* algorithms typically do not involve loops that iterate over the data
    or recursive calls that multiply operations. They often involve direct access
    to data, like looking up a value in an array by its index or performing a simple
    calculation. And while *O(1)* algorithms are incredibly efficient, they are not
    always applicable to every problem. Some tasks inherently require processing each
    item in the input, leading to different time complexities.'''
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'O(log(n)): logarithmic time'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *O(log n)* algorithm's runtime (or sometimes space complexity) grows logarithmically
    with the input size (*n*). This means that each step of the algorithm significantly
    reduces the problem size, often by dividing it in half or a similar fraction.
    The larger the input size, the smaller the impact each additional element has
    on the overall runtime. In other words, as the input size doubles, the runtime
    increases by a constant amount (for example, only one more step).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are playing a "*guess the number*" game. You start with a range
    of 1 to 64, and with each guess, you cut the possible numbers in half. Let's say
    your first guess is 30\. If it is too high, you now know the number is somewhere
    between 1 and 29\. You have effectively halved the search space! Next, you guess
    10 (too low), narrowing the range further to 11 through 29\. Your third guess,
    20, happens to be correct!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Even if you had started with a much larger range of numbers (like 1 to 1000
    or even 1 to 1 million), this halving strategy would still allow you to find the
    number in a surprisingly small number of guesses – around 7 for 1 to 64, 10 for
    1 to 1000, and 20 for 1 to 1 million. This demonstrates the power of logarithmic
    growth.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: We can say this approach has a time complexity of *O(log(n))*. With each step,
    the algorithm eliminates a significant portion of the input, making the remaining
    work much smaller.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: A function that has a time complexity of *O(log(n))* typically halves the problem
    size with each step. This complexity is often related to divide and conquer algorithms,
    which we will cover in *Chapter 18, Algorithm Designs and Techniques*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 时间复杂度为*O(log(n))的函数通常在每一步将问题规模减半。这种复杂性与分而治之算法相关，我们将在第18章“算法设计和技巧”中介绍。
- en: Logarithmic algorithms are incredibly efficient, especially for large datasets.
    They are often used in scenarios where you need to quickly search or manipulate
    sorted data, which we will also cover later in this book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对数算法非常高效，尤其是在处理大数据集时。它们通常用于需要快速搜索或操作排序数据的场景，我们将在本书的后面部分介绍这些内容。
- en: 'O(n): linear time'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O(n)：线性时间
- en: '*O(n)* signifies that an algorithm''s runtime (or sometimes space complexity)
    grows linearly and proportionally with the input size (*n*). If we double the
    size of the input data, the algorithm will take approximately twice as long to
    run. If we triple the input, it will take about three times as long, and so on.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*O(n)*表示算法的运行时间（有时是空间复杂度）与输入大小*n*线性且成比例增长。如果我们加倍输入数据的大小，算法运行所需的时间大约也会加倍。如果我们增加输入的三倍，它将大约需要三倍的时间，依此类推。'
- en: 'Imagine you have an array of monthly expenses and want to calculate the total
    amount spent. Here is how we could do it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个月度费用的数组，并想计算总支出金额。以下是我们可以这样做的方法：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The for loop iterates through each element (`monthlyExpense`) in the array adding
    it to the `total` variable, which is then returned with the amount of the total
    expenses.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: for循环遍历数组中的每个元素（`monthlyExpense`），将其添加到`total`变量中，然后返回总费用的金额。
- en: 'We can use the following code to check the output of this function, passing
    different parameters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来检查此函数的输出，传递不同的参数：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The number of iterations (and additions to the `total`) directly depends on
    the size of the array (`monthlyExpenses.length`). If the array has 12 months of
    expenses, the loop runs 12 times. If it has 24 months, the loop runs 24 times.
    The runtime increases proportionally to the number of elements in the array.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代次数（以及`total`的增加）直接取决于数组的大小（`monthlyExpenses.length`）。如果数组有12个月的费用，循环运行12次。如果它有24个月，循环运行24次。运行时间与数组中的元素数量成比例增加。
- en: This is because the function contains a loop that runs *n* times. Therefore,
    the time it takes to run this function grows in proportion to the size of the
    input *n*. If *n* doubles, the time to run the function approximately doubles
    as well. For this reason, we can say the preceding function has a complexity of *O(n)*,
    where in this context, *n* is the input size.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为该函数包含一个运行*n*次的循环。因此，运行此函数所需的时间与输入大小*n*成正比。如果*n*加倍，运行函数的时间大约也会加倍。因此，我们可以说前面的函数具有*O(n)*的复杂度，在这个上下文中，*n*代表输入大小。
- en: While *O(n)* algorithms are not as fast as constant time (*O(1)*) algorithms,
    they are still considered efficient for many tasks. There are many situations
    where you need to process every element of the input, making linear time a reasonable
    expectation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*O(n)*算法不如常数时间(*O(1)*)算法快，但它们对于许多任务仍然被认为是高效的。有许多情况需要处理输入的每个元素，使得线性时间是一个合理的期望。
- en: 'O(nˆ2): quadratic time'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O(n²)：二次时间
- en: '*O(n²)* signifies that an algorithm''s runtime (or sometimes space complexity)
    grows quadratically with the input size (*n*). This means that as the input size
    doubles, the runtime roughly quadruples. If you triple the input, the runtime
    increases by a factor of nine, and so on. *O(n²)* algorithms often involve nested
    loops, where the inner loop iterates *n* times for each iteration of the outer
    loop. This results in approximately *n * n* (or *n²*) operations.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*O(n²)*表示算法的运行时间（有时是空间复杂度）随着输入大小*n*的平方增长。这意味着当输入大小加倍时，运行时间大约会增加到四倍。如果你将输入增加到三倍，运行时间将增加九倍，依此类推。*O(n²)*算法通常涉及嵌套循环，其中内循环在外循环的每次迭代中迭代*n*次。这导致大约*n
    * n*（或*n²*）次操作。'
- en: 'Let''s go back to the calculation of expenses example. Suppose you have the
    following data in a spreadsheet, with each expense by month:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到计算费用的例子。假设你在电子表格中有以下数据，每个月的费用如下：
- en: '| **Month/Expense** | **January** | **February** | **March** | **April** |
    **May** | **June** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **月份/费用** | **一月** | **二月** | **三月** | **四月** | **五月** | **六月** |'
- en: '| Water Utility | 100 | 105 | 100 | 115 | 120 | 135 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 水务公用事业 | 100 | 105 | 100 | 115 | 120 | 135 |'
- en: '| Power Utility | 180 | 185 | 185 | 185 | 200 | 210 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 功率公用事业 | 180 | 185 | 185 | 185 | 200 | 210 |'
- en: '| Trash Fees | 30 | 30 | 30 | 30 | 30 | 30 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 垃圾处理费 | 30 | 30 | 30 | 30 | 30 | 30 |'
- en: '| Rent/Mortgage | 2000 | 2000 | 2000 | 2000 | 2000 | 2000 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| Groceries | 600 | 620 | 610 | 600 | 620 | 600 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| Hobbies | 150 | 100 | 130 | 200 | 150 | 100 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: Example of monthly expenses'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to write a function that calculates the total expenses for
    several months? The code for this function is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function has two nested loops:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The outer loop (`i`) iterates over the rows of the matrix (categories or types
    of expenses within each month).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inner loop (`j`) iterates over the columns of the matrix (each month) for
    each row.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the nested loop we simply add the expense to the `total`, which is then
    returned at the end of the function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this function with the data we previous represented:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can say the preceding function has a complexity of *O(nˆ2)*. This is because
    the function contains two nested loops. The outer loop will run 6 times (*n*)
    and the inner loop will also run 6 times as we have 6 months (*m*). We can say
    the total number of operations is *n * m*. If *n* and *m* are similar numbers,
    we can say *n * n*, hence *nˆ2*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In Big O notation, we simplify this to the highest order of magnitude, which
    is *nˆ2*. This means the time complexity of the function grows quadratically (input
    size squared) with the input size. So, If you have a 12x12 matrix (12 categories
    of expenses with 12 months each), the inner loop runs 12 times for each of the
    12 months, resulting in 144 operations. If we expand the list of expenses and
    also the number of months, with a matrix 24x24, the number of operations becomes
    576 (24 * 24). This is characteristic of an algorithm with *O(nˆ2)* time complexity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'O(2^n): exponential time complexity'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*O(2^n)* signifies that an algorithm''s runtime (or sometimes space complexity)
    doubles with each additional unit of input size (*n*). If you add just one more
    element to the input, the algorithm takes approximately twice as long. If you
    add two more elements, it takes about four times as long, and so on. The runtime
    increases exponentially. An algorithm with exponential time complexity does not
    have satisfactory performance.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: A classic example of an algorithm that is *O(2ˆn)* is when we have brute force
    that will try all possible combinations of a set of values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we want to know how many unique combinations we can have with ice cream
    toppings or no toppings at all. The available toppings are chocolate sauce, maraschino
    cherries and rainbow sprinkles.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: What are the possible combinations?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Since each topping can be either present or absent, and we have three different
    toppings, the total number of possible combinations is: 2 * 2 * 2 = 2^3 = 8.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the following combinations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: No toppings
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chocolate sauce only
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maraschino cherries only
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rainbow sprinkles only
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chocolate sauce + maraschino cherries
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chocolate sauce + rainbow sprinkles
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maraschino cherries + rainbow sprinkles
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chocolate sauce + maraschino cherries + rainbow sprinkles
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we had 10 toppings to choose from, we would have 2 ^ 10 possible combinations,
    totaling 1024 different combinations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Another example of exponential complexity algorithm is the brute force attack
    to break passwords or PINs. If we have a 4-digit (0-9) code PIN, we have a total
    of 10ˆ4 combinations, totaling 10000 combinations. If we have passwords using
    letters only, we will have a total of 26ˆn combinations, where n is the number
    of letters in the password. If we allow uppercase and lowercase characters in
    the password, we have a total of 62ˆn combinations. This is one of the reasons
    it is important to always create long passwords with letters (both uppercase and
    lowercase), numbers and especial characters, as the number of possible combinations
    grow exponentially, making it more difficult to break the password by using brute
    force.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Exponential algorithms are generally considered impractical for large inputs
    due to their incredibly rapid growth in runtime. They can quickly become infeasible
    even for moderately sized datasets. It is crucial to find more efficient algorithms
    whenever possible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'O(n!): factorial time'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*O(n!)* signifies an algorithm''s runtime (or sometimes space complexity) grows
    incredibly rapidly with the input size (*n*). This growth is even faster than
    exponential time complexity. An algorithm with factorial time complexity has one
    of the worst performances.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The factorial of a number *n* (denoted as *n!*) is calculated as *n * (n-1)
    * (n-2) , …, * 1*. For example, 4! is 4 * 3 * 2 * 1 = 24 .1 As we can see, factorials
    get very large very quickly
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'A classic example of an algorithm that is *O(n!)* is when we try to find all
    possible permutations of a set, for example, the letters ABCD as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '| ABCD | BACD | CABD | DABC |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| ABDC | BADC | CADB | DACB |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| ACBD | BCAD | CBAD | DBAC |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| ACDB | BCDA | CBDA | DBCA |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| ADBC | BDAC | CDAB | DCAB |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| ADCB | BDCA | CDBA | DCBA |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: 'Table 2.3: All permutations of letters ABCD'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithms with factorial time complexity are generally considered highly inefficient
    and should be avoided whenever possible. For many problems that initially seem
    to require *O(n!)* solutions, there are often cleverer algorithms with much better
    time complexities (for example: dynamic programming technique).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We will cover algorithms with exponential and factorial times in *Chapter 18,
    Algorithm Designs and Techniques*.
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Comparing complexities
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create a table with some values to exemplify the cost of the algorithm
    based on its time complexity and input size, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input Size (n)** | **O(1)** | **O(log (n))** | **O(n)** | **O(n log(n))**
    | **O(nˆ2)** | **O(2ˆn)** | **O(n!)** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1 | 1 | 10 | 10 | 100 | 1024 | 3628800 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| 20 | 1 | 1.30 | 20 | 26.02 | 400 | 1048576 | 2.4329E+18 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| 50 | 1 | 1.69 | 50 | 84.94 | 2500 | 1.1259E+15 | 3.04141E+64 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| 100 | 1 | 2 | 100 | 200 | 10000 | 1.26765E+30 | 9.33262E+157 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| 500 | 1 | 2.69 | 500 | 1349.48 | 250000 | 3.27339E+150 | Very big number
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| 1000 | 1 | 3 | 1000 | 3000 | 1000000 | 1.07151E+301 | Very big number |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 1 | 3 | 1000 | 3000 | 1000000 | 1.07151E+301 | 非常大的数字 |'
- en: '| 10000 | 1 | 4 | 10000 | 40000 | 100000000 | Very big number | Very big number
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 10000 | 1 | 4 | 10000 | 40000 | 100000000 | 非常大的数字 | 非常大的数字 |'
- en: 'Table 2.4: Comparing Big O time complexity based on input size'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.4：基于输入大小比较大O时间复杂度
- en: 'We can draw a chart based on the information presented in the preceding table
    to display the cost of different Big O notation complexities as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据前表中提供的信息绘制一张图表，以显示不同大O表示法复杂性的成本如下：
- en: '![Figure 2.1 – Big O Notation complexity chart](img/file7.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 大O表示法复杂度图表](img/file7.png)'
- en: Figure 2.1 – Big O Notation complexity chart
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 大O表示法复杂度图表
- en: The preceding chart was also plotted using JavaScript. You can find its source
    code in the `src/02-bigOnotation` directory of the source code bundle.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 前面的图表也是使用JavaScript绘制的。您可以在源代码包的`src/02-bigOnotation`目录中找到其源代码。
- en: 'When we plot the runtime of algorithms with different time complexities against
    the input size on a graph, distinct patterns emerge:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将具有不同时间复杂度的算法的运行时间与输入大小在图表上绘制时，会出现不同的模式：
- en: '***O(1) - Constant Time***: a horizontal line. The runtime remains the same
    regardless of the input size.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(1) - 常数时间***：一条水平线。无论输入大小如何，运行时间都保持不变。'
- en: '***O(log n) - Logarithmic Time***: a gently rising curve that gradually flattens
    as the input size increases. Think of it as a slope that gets less and less steep.
    Each additional input element has a diminishing impact on the overall runtime.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(log n) - 对数时间***：一条随着输入大小增加而逐渐变平缓的曲线。可以将其视为越来越不陡峭的斜率。每个额外的输入元素对整体运行时间的影响逐渐减小。'
- en: '***O(n) - Linear Time***: a straight line with a positive slope. The runtime
    increases proportionally with the input size. Double the input, and the runtime
    roughly doubles.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(n) - 线性时间***：一条具有正斜率的直线。运行时间与输入大小成比例增加。输入加倍，运行时间大约也加倍。'
- en: '***O(n²) - Quadratic Time***: a curve that starts shallow but becomes increasingly
    steep. The runtime grows much faster than the input size. Double the input, and
    the runtime roughly quadruples.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(n²) - 二次时间***：一条开始时较浅但变得越来越陡峭的曲线。运行时间增长速度远快于输入大小。输入加倍，运行时间大约增加四倍。'
- en: '***O(2^n) - Exponential Time***: a curve that initially seems flat but then
    explodes upwards as the input size increases even slightly. The runtime grows
    incredibly rapidly.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(2^n) - 指数时间***：一条最初看似平坦但随后随着输入大小略微增加而急剧上升的曲线。运行时间增长速度极快。'
- en: '***O(n!) - Factorial Time***: a curve that rises almost vertically. The runtime
    becomes astronomically large even for relatively small inputs, quickly becoming
    impractical to compute.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(n!) - 阶乘时间***：一条几乎垂直上升的曲线。即使对于相对较小的输入，运行时间也会变得极其巨大，很快变得不切实际。'
- en: These visualizations are invaluable tools for understanding the long-term behavior
    of algorithms as the input size grows. They help us make informed choices about
    which algorithms are best suited for different scenarios, especially when dealing
    with large datasets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可视化是理解算法随着输入大小增长长期行为的宝贵工具。它们帮助我们做出明智的选择，关于哪些算法最适合不同的场景，尤其是在处理大数据集时。
- en: Space complexity
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间复杂度
- en: Space complexity refers to the amount of memory (or space) an algorithm uses
    to solve a problem. It is a measure of how much additional storage the algorithm
    requires beyond the space occupied by the input data itself.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度指的是算法解决问题时使用的内存（或空间）量。它是衡量算法除输入数据本身占用的空间外还需要多少额外存储的指标。
- en: It is important to understand space complexity as real-world computers have
    finite memory. If the algorithm's space complexity is too high, it might run out
    of memory on large datasets. And even if we have plenty of memory, an algorithm
    with a high space complexity can still be slower due to factors like increased
    memory access times and cache issues. Also, it is all about tradeoffs. Sometimes,
    we might choose an algorithm with a slightly higher space complexity if it offers
    a significant improvement in time complexity. This of course, needs to be reviewed
    case by case.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 理解空间复杂度很重要，因为现实世界的计算机内存是有限的。如果算法的空间复杂度太高，它可能在处理大数据集时耗尽内存。即使我们有足够的内存，具有高空间复杂度的算法也可能因为内存访问时间增加和缓存问题等因素而变慢。此外，这完全是关于权衡。有时，如果我们选择的算法在时间复杂度上提供了显著的改进，我们可能会选择稍微高一点的空间复杂度。当然，这需要根据具体情况逐一审查。
- en: 'Big O notation works for space complexity just like it does for time complexity.
    It expresses the upper bound of how the algorithm''s memory usage grows as the
    input size increases. Let''s review the common Big O space complexities:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '***O(1) - Constant Space*:** the algorithm uses a fixed amount of memory, regardless
    of the input size. This is ideal, as the memory usage will not become a bottleneck.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: swapping two variables.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***O(n) - Linear Space*:** the algorithm''s memory usage grows linearly with
    the input size. If we double the input, the memory usage roughly doubles.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: storing a copy of an input array.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***O(log n) - Logarithmic Space*:** the algorithm''s memory usage grows logarithmically.
    This is relatively efficient, especially for large datasets.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: certain recursive algorithms where the depth of recursion is logarithmic.'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***O(nˆ2) - Quadratic Space*:** the algorithm''s memory usage grows quadratically.
    This can become a problem for large inputs.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: storing a multiplication table in a 2D array.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***O(2^n) - Exponential Space*:** like the exponential time complexity, this
    indicates extremely rapid growth in memory usage. It is generally not practical
    and should be avoided.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the complexity of an algorithm
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also important to understand how to read algorithmic code and identify
    its complexity in terms of Big O notation. By analyzing the complexity of an algorithm,
    we can identify potential bottlenecks and focus on improving that specific area.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the cost of a code in terms of ***time complexity***, we need
    to review it step by step, and focus on the following points:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Basic operations such as assignments, bits and math operations, which will usually
    have constant time (*O(1)*).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logarithmic algorithms (*O(log (n))*) typically follow a divide-and-conquer
    strategy. They break the problem into smaller subproblems and solve them recursively.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loops: the number of times a loop runs directly impacts time complexity. Nested
    loops multiply their effects. So, if we have one loop iterating through the input
    of size *n*, it will be linear time (*O(n)*), two nested loops (*O(nˆ2)*), and
    so on.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recursions: recursive functions call themselves, potentially leading to exponential
    time complexity if not carefully designed. We will cover recursion in *Chapter
    9, Recursion*.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function calls: consider the time complexity of any functions that are called
    within your code.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And to determine the cost of a code in terms of **space complexity**, we need
    to review it step by step, and focus on the following points:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables: how much memory do variables used in the algorithm consume? Does
    the number of variables grow with the input size?'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data structures: what data structures are being used (arrays, lists, trees,
    etc.)? How does their size scale with the input?'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function calls: if the algorithm uses recursion, how many recursive calls are
    made? Each call adds to the space complexity of the call stack.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allocations: are we dynamically allocating memory within the algorithm? How
    much memory is allocated, and how does it relate to the input size?'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配：算法中是否动态分配内存？分配了多少内存，它与输入大小有何关系？
- en: 'Let''s see an example of a function that logs the multiplication table of a
    given number:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个函数的示例，该函数记录给定数字的乘法表：
- en: '[PRE6]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s break down the time and space complexity of the `multiplicationTable`
    function using Big O notation. First, let''s focus on time complexity:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Big O 表示法分解 `multiplicationTable` 函数的时间和空间复杂度。首先，让我们关注时间复杂度：
- en: '***O(1) operations***:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(1) 操作***:'
- en: Assigning variables (`let s = ''` and `let numberOfAsterisks = num * x`)
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值变量（`let s = ''` 和 `let numberOfAsterisks = num * x`）
- en: Printing fixed strings (`console.log('Calculating the time complexity of a function')`)
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印固定字符串（`console.log('Calculating the time complexity of a function')`）
- en: '***O(n) operations***:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(n) 操作***:'
- en: 'Building the asterisk string: the loop iterates *num * x* times, and each iteration
    involves string concatenation, which can be a linear operation depending on the
    JavaScript implementation.'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建星号字符串：循环迭代 *num * x* 次，每次迭代涉及字符串连接，这取决于 JavaScript 实现的线性操作。
- en: 'Printing the asterisk string: outputting a string of length *num * x* takes
    time proportional to its length.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印星号字符串：输出长度为 *num * x* 的字符串所需的时间与其实际长度成比例。
- en: '***O(nˆ2) operations***:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(nˆ2) 操作***:'
- en: 'Nested loops: the outer loop runs num times, and for each iteration, the inner
    loop runs *x* times. This leads to roughly *num * x* (or *nˆ2*) iterations of
    the innermost `console.log` statement, where the actual multiplication takes place.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套循环：外循环运行 `num` 次，对于每次迭代，内循环运行 *x* 次。这导致大约 *num * x*（或 *nˆ2*）次内层 `console.log`
    语句的迭代，其中实际进行乘法操作。
- en: While there are *O(1)* and *O(n)* operations in the function, the dominant factor
    in the time complexity is the nested loop structure, which leads to quadratic
    time complexity *O(n^2)*. In Big O notation, we simplify this to the highest order
    of magnitude, which is *n^2*. Therefore, the overall time complexity of the function
    is *O(n^2)*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数中存在 *O(1)* 和 *O(n)* 操作，但时间复杂度中的主导因素是嵌套循环结构，这导致二次时间复杂度 *O(n^2)*。在 Big O 表示法中，我们将其简化为最高阶数，即
    *n^2*。因此，函数的整体时间复杂度是 *O(n^2)*。
- en: 'Now let''s review the space complexity:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾空间复杂度：
- en: '***O(1) space***:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(1) 空间***:'
- en: Simple variables (`s`, `numberOfAsterisks`, loop counters `i` and `j`) use a
    fixed amount of memory, regardless of the input values `num` and `x`.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单变量（`s`，`numberOfAsterisks`，循环计数器 `i` 和 `j`）使用固定数量的内存，无论输入值 `num` 和 `x` 如何。
- en: '***O(n) space*** (*potential*):'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***O(n) 空间复杂度*** (*潜在*):'
- en: The string `s` could potentially grow to a size of *num * x*, meaning its space
    usage is linear in the input size. However, in most implementations, string concatenation
    is optimized, so this might not be a major concern unless the input values are
    very large.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串 `s` 可能会增长到 *num * x* 的大小，这意味着其空间使用与输入大小成线性关系。然而，在大多数实现中，字符串连接是经过优化的，所以这可能不是一个大问题，除非输入值非常大。
- en: So, overall, the space complexity could be considered *O(n)* due to the potential
    growth of the asterisk string. However, for practical purposes, the space usage
    is usually not a significant issue, and we often focus on the *O(n²)* time complexity
    as the primary concern for this function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总体而言，由于星号字符串的潜在增长，空间复杂度可以被认为是 *O(n)*。然而，出于实际目的，空间使用通常不是一个重大问题，我们通常关注此函数的主要关注点是
    *O(n²)* 时间复杂度。
- en: Big O notation and tech interviews
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Big O 表示法和技术面试
- en: During technical interviews for software developer positions, it is common for
    companies to do a coding test using some services online such as **LeetCode**,
    **Hackerrank**, and other similar services.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程师职位的技术面试中，公司通常会在一些在线服务（如 **LeetCode**，**Hackerrank** 和其他类似服务）上执行编码测试。
- en: Choosing the correct data structure or algorithm to solve a problem can tell
    the company some information about how you solve problems that might pop up for
    you to resolve.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的数据结构或算法来解决问题可以告诉公司一些关于你如何解决可能出现的解决问题的信息。
- en: Interviewers might ask you to analyze code and predict how its runtime or memory
    usage might change under different input sizes. Once you write code to resolve
    a problem, interviewers might also ask you to pinpoint potential performance problems
    in your code and if you can identify areas of optimization. Also, different algorithms
    and data structures have different time complexities, and knowing Big O allows
    you to make informed decisions about which solution is best suited for a particular
    problem, considering all the tradeoffs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 面试官可能会要求你分析代码并预测在不同的输入大小下其运行时间或内存使用情况可能会有何变化。一旦你编写了代码来解决问题，面试官还可能会要求你指出代码中可能存在的性能问题，以及你是否能够识别出优化的区域。此外，不同的算法和数据结构具有不同的时间复杂度，了解大O符号可以帮助你做出明智的决定，选择最适合特定问题的解决方案，考虑到所有的权衡。
- en: During interviews, you can also showcase your velocity in resolving problems
    and how to optimize them. For example, in case there is any problem involving
    array search, you can start with a simple algorithm, to demonstrate you can resolve
    a problem quickly, depending on the criticality, and once the problem is fixed,
    demonstrate it can be optimized to use a more performative search, if you have
    more time to resolve the problem.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试过程中，你也可以展示你解决问题的速度以及如何优化它们。例如，如果遇到任何涉及数组搜索的问题，你可以从一个简单的算法开始，以展示你能够快速解决问题，根据问题的紧急程度，一旦问题得到解决，如果你有更多时间解决问题，可以展示如何将其优化为使用更高效的搜索算法。
- en: In each chapter of this book, we will cover some problems pertaining to the
    chapter topic, and what we can do to further optimize them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的每一章中，我们将涵盖一些与章节主题相关的问题，以及我们可以如何进一步优化它们。
- en: Exercises
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Now that you've explored the fundamentals of time and space complexity with
    Big O notation, it's time to test your understanding! Analyze the following JavaScript
    functions and determine their time and space complexities. Experiment with different
    inputs to see how the functions behave.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经通过大O符号探索了时间和空间复杂性的基础知识，是时候测试你的理解了！分析以下JavaScript函数并确定它们的时间和空间复杂度。尝试不同的输入以查看函数的行为。
- en: '***1***: determines if the array''s size is odd or even:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '***1***：确定数组的大小是奇数还是偶数：'
- en: '[PRE7]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***2***: calculates and returns the average of an array of numbers:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '***2***：计算并返回一个数字数组的平均值：'
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***3***: checks if two arrays have any common values:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '***3***：检查两个数组是否有任何共同值：'
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***4***: filters odd numbers from an input array:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '***4***：从输入数组中过滤出奇数：'
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You will find the answers in the source code for this chapter (file `src/02-bigOnotation/03-exercises.js`).
    Compare your analysis with the provided solutions to solidify your understanding
    of Big O notation in real-world JavaScript code!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章的源代码中找到答案（文件 `src/02-bigOnotation/03-exercises.js`）。将你的分析结果与提供的解决方案进行比较，以巩固你在实际JavaScript代码中对大O符号的理解！
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the fundamental concept of Big O notation, a
    powerful tool for analyzing and expressing the efficiency of algorithms. We explored
    how to calculate both time complexity (the relationship between input size and
    runtime) and space complexity (the relationship between input size and memory
    usage). We also discussed how Big O analysis is a crucial skill for software developers,
    aiding in algorithm selection, performance optimization, and technical interviews.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了Big O符号的基本概念，这是一个分析并表达算法效率的强大工具。我们探讨了如何计算时间复杂度（输入大小与运行时间之间的关系）和空间复杂度（输入大小与内存使用之间的关系）。我们还讨论了Big
    O分析对于软件开发者来说是一个关键技能，有助于算法选择、性能优化和技术面试。
- en: 'In the next chapter, we will dive into our first data structure: the versatile
    **Array**. We will explore its common operations, analyze their time complexities,
    and tackle some practical coding challenges.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨我们的第一个数据结构：多才多艺的**数组**。我们将探讨其常见操作，分析它们的时间复杂度，并解决一些实际的编码挑战。
