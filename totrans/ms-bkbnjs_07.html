<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Build Like a Pro"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Build Like a Pro</h1></div></div></div><p>Some years ago, you could create a website with PHP, upload your source files through FTP to a server, and then go online. During those days, JavaScript was a tight piece of the whole system, used for UI tasks such as validating forms or small chunks of functionality.</p><p>Today, web is more JavaScript intensive, we are building web applications instead websites, this means that JavaScript is no more a trivial piece of applications, it is now a core piece. For this reason, it is important to pack our JavaScript application before being deployed for production.</p><p>You will learn the following in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a workflow to automatically process your source files</li><li class="listitem" style="list-style-type: disc">Minifying the application script size</li><li class="listitem" style="list-style-type: disc">Minifying the number of requests to the server when the application is loaded</li><li class="listitem" style="list-style-type: disc">Minifying the images</li><li class="listitem" style="list-style-type: disc">Optimizing the CSS files</li><li class="listitem" style="list-style-type: disc">Wiring up everything in an HTML file</li><li class="listitem" style="list-style-type: disc">Setting up a development environment to automatically reload the application</li></ul></div><p>At the time of writing this book, there are many tools to build JavaScript applications; however, two of them are the most popular: Grunt and Gulp. Grunt <a id="id274" class="indexterm"/>is an older choice with a big community around and an amazing collection of plugins available. Gulp, on<a id="id275" class="indexterm"/> the other hand, is gaining more popularity each day and almost has the most popular plugins that exist for Grunt.</p><div class="section" title="Development workflow"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Development workflow</h1></div></div></div><p>When you <a id="id276" class="indexterm"/>are developing an application, some tasks are very repetitive; for example, our contacts application uses Browserify to manage dependencies. It needs to rebundle the source code every time you make a change, which means that you need to run the <code class="literal">browserify</code> command each time:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm bundle</strong></span>
<span class="strong"><strong>$ npm start</strong></span>
</pre></div><p>To run these <a id="id277" class="indexterm"/>commands every time you make a small change is a very tedious task, there should be a better way to do it:</p><div class="mediaobject"><img src="graphics/B01962_07_01.jpg" alt="Development workflow"/><div class="caption"><p>Figure 7.1. Development workflow</p></div></div><p>The above figure shows the ideal development process; the first time you run the application, you should bundle the source files and run the BrowserSync web server and then open the browser. After that, for any change that you make in any source file, the application should be rebundled and then the browser should be refreshed to get the new changes.</p><p>Currently, we are manually doing this process; however, in the next section, you will learn how to automatize this task to let the machine do all this for you.</p></div></div>
<div class="section" title="What's a task runner?"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/>What's a task runner?</h1></div></div></div><p>A task runner <a id="id278" class="indexterm"/>is computer program that runs a sequence of tasks over your source code, applying transformations to the files. For example, consider that you are writing a source code in the CoffeeScript programming language, one task would be compiling all your source code in JavaScript, other task can be concatenating all the output JavaScript files in a single file, and the third task can finally be minifying the concatenated file to minimize the file size.</p><p>These tasks will automatically be run by the task runner, you just need to write a script file to program what needs to be done and then forget to run any command line again. The task runner provides triggers to start a task whenever you change a file so that it is done transparently.</p><p>As you can see, a <a id="id279" class="indexterm"/>task runner can improve your productivity as you can forget about the details of the compilation process once you have correctly configured a task runner. It will allow you to automate all these repetitive and boring tasks and then, you can focus on product development.</p><p>Grunt and Gulp are the most popular task runners for JavaScript; they take different approach to run the tasks. In Grunt, the tasks are run sequentially: once a task is running, the next task cannot start until the first is done. In Gulp, the tasks can run parallel to each other, as shown in the following:</p><div class="mediaobject"><img src="graphics/B01962_07_02.jpg" alt="What's a task runner?"/><div class="caption"><p>Figure 7.2 Different approach on running task by Grunt and Gulp</p></div></div><p>The above figure illustrates how Grunt and Gulp will run three tasks. Task B depends on whether Task A and Task C are done. Note that Grunt can run the tasks parallel to each other using plugins. While, Gulp does this from its core design.</p><p>Another difference between Grunt and Gulp is that, in Grunt, you can configure the tasks on writing a big configuration object. While, in Gulp, you will write standard JavaScript functions. An <a id="id280" class="indexterm"/>interesting point is that Grunt and Gulp can work together in the same project; however, it is better to choose just one of them in order to reduce complexity.</p><p>If your project uses Grunt, you should not switch to Gulp unless have a good reason to do it.</p></div>
<div class="section" title="How Gulp works"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>How Gulp works</h1></div></div></div><p>As I <a id="id281" class="indexterm"/>mentioned at the beginning of the chapter, Gulp is the most popular JavaScript task runner at the time of writing this book and that's the main reason why we chose it. Gulp and Grunt work in a similar way, they both use third-party plugins to work. Keep in mind that Gulp is more like a framework, it does not make too much by itself.</p><p>Gulp acts as the glue that coordinates the build workflow; it has some basic functionality and an API, which the Gulp plugins can use to do their work. The plugins use the compilers and utility programs that make the real file processing, such as the CoffeeScript transpiler. The plugins connect these programs to the Gulp workflow:</p><div class="mediaobject"><img src="graphics/B01962_07_03.jpg" alt="How Gulp works"/><div class="caption"><p>Figure 7.3 Relationship between Gulp plugins and libraries</p></div></div><p>The preceding figure shows the relationship that was described earlier, you can get a better idea of how Gulp connects with its plugins; notice how the plugins delegate the file processing to the utility programs that they connect to.</p><p>Gulp is composed of several named tasks where each task can have dependencies on other tasks. A typical Gulp task opens a stream of files at the beginning and applies transformation to each file in the stream with the installed plugins.</p><p>A stream is <a id="id282" class="indexterm"/>opened with the <code class="literal">gulp.src()</code> method. It starts a stream that you can connect to several pipes in order to apply the necessary transformations. When you open a stream, you need to specify the target files that will be used in the stream. You will select these files using the <code class="literal">node-glob format</code>:</p><div class="informalexample"><pre class="programlisting">// get only the index.html file
gulp.src('app/index.html');

// get all the files with .html extension
gulp.src('app/*.html');

// get all the .js files available 1 path depth in 
// the app directory
gulp.src('app/*/*.js');

// get all the .js files in every subdirectory available
gulp.src('app/**/*.js');</pre></div><p>It is easy to specify the files for the stream, it is similar to what you do in the command line. The figure below shows how the stream and pipes are connected. The files that are selected are streamed into the Gulp plugins, they make the transformations and put the output back in the stream, the next plugin can then make its work, and put the result back in the stream:</p><div class="mediaobject"><img src="graphics/B01962_07_04.jpg" alt="How Gulp works"/><div class="caption"><p>Figure 7.4 Using node-blob to select files</p></div></div><p>At the end of the pipe, you will normally write the result in a file that is ready to be used. You can put as <a id="id283" class="indexterm"/>many Gulp tasks as you need and each task can have as many dependencies as it needs.</p></div>
<div class="section" title="Getting started with Gulp"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Getting started with Gulp</h1></div></div></div><p>First of all, install <a id="id284" class="indexterm"/>the Gulp package globally; this will give you access to the <code class="literal">gulp</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install -g gulp</strong></span>
</pre></div><p>Once you have installed Gulp globally, you will need to install it in your local project in order to have access to the Gulp core utilities:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install -save-dev gulp</strong></span>
</pre></div><p>To configure the Gulp tasks, you will need to create a file called <code class="literal">gulpfile.js</code> that Gulp will read every time you run the <code class="literal">gulp</code> command. All Gulp tasks have a name and a function that is executed when the task is invoked:</p><div class="informalexample"><pre class="programlisting">var gulp = require('gulp');

gulp.task('hello', function() {
  console.log('Hello world!');
});</pre></div><p>The following simple Gulp task will print Hello world! on the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gulp hello</strong></span>
<span class="strong"><strong>[22:43:15] Using gulpfile ~/path/to/project/gulpfile.js</strong></span>
<span class="strong"><strong>[22:43:15] Starting 'hello'...</strong></span>
<span class="strong"><strong>Hello world!</strong></span>
<span class="strong"><strong>[22:43:15] Finished 'hello' after 118 μs</strong></span>
</pre></div><p>Note how we invoke Gulp, <code class="literal">gulp hello</code>, the argument used in the command is the name of the task to be executed. This is the simplest Gulp task that you can write and it is the starting point for developing an effective build pipeline.</p></div>
<div class="section" title="Creating a development workflow"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Creating a development workflow</h1></div></div></div><p>In this section, we<a id="id285" class="indexterm"/> will build a script to help us in the development process and, later, to build a production-ready script. You will need to install the basic dependencies first:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev gulp gulp-load-plugins gulp-util</strong></span>
</pre></div><p>The <code class="literal">gulp-load-plugins</code> is useful to automatically load all the available plugins without manually requiring them in the <code class="literal">gulpfile.js</code> script; the <code class="literal">gulp-util</code> plugin provides utility functions such as log messages.</p><div class="section" title="Bundling the JavaScript files with Browserify"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec38"/>Bundling the JavaScript files with Browserify</h2></div></div></div><p>The <code class="literal">gulp-browserify</code> plugin is currently deprecated and should not be used. The project <a id="id286" class="indexterm"/>author recommends using one of the recipes developed by the Gulp development team.</p><p>The recipes <a id="id287" class="indexterm"/>described in the repository needs to install some plugins first:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev jstifywatchify vinyl-source-stream</strong></span>
</pre></div><p>In <code class="literal">gulpfile.js</code>, we can define the <code class="literal">browserify</code> task:</p><div class="informalexample"><pre class="programlisting">var gulp = require('gulp');
var $ = require('gulp-load-plugins')();
var browserify = require('browserify');
var jstify = require('jstify');
var source = require('vinyl-source-stream');

// Bundle files with browserify
gulp.task('browserify', () =&gt; {
  // set up the browserify instance on a task basis
  var bundler = browserify({
    entries: 'app/js/main.js',
    debug: true,
    // defining transforms here will avoid crashing your stream
    transform: [jstify]
  });

  return bundler.bundle()
    .on('error', $.util.log)
    .pipe(source('app.js'))
    .pipe(gulp.dest('.tmp/js'));
});</pre></div><p>Notice how we configure the Browserify bundle, we use the Browserify <code class="literal">jstify</code> transformation to compile the underscore templates. As the <code class="literal">browserify</code> task is not a standard Gulp plugin, we are using <code class="literal">vinyl-source-stream</code> to stream the files to the bundler. Finally, we will write the output in the <code class="literal">.tmp/js</code> path.</p><p>Now, you can run Gulp with the Browserify argument to run the task:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gulp browserify</strong></span>
<span class="strong"><strong>[07:13:18] Using gulpfile ~/path/to/your/project/gulpfile.js</strong></span>
<span class="strong"><strong>[07:13:18] Starting 'browserify'...</strong></span>
<span class="strong"><strong>[07:13:19] Finished 'browserify' after 1.13 s</strong></span>
</pre></div><p>The<code class="literal">.tmp/js/app.js</code> file should<a id="id288" class="indexterm"/> exist <a id="id289" class="indexterm"/>and be ready to be used. You can run the project to verify all is working:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
</pre></div><div class="section" title="Sourcemaps"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec01"/>Sourcemaps</h3></div></div></div><p>When<a id="id290" class="indexterm"/> you run the project, the browser gets a single file named <code class="literal">app.js</code>, which contains all the concatenated source code. That's good for the production environments as it reduces the number of requests made to the server in order to get the assets. However, in development environments, it is more useful to see the individual files in the browser as you have it in the source code for the debugging process.</p><p>You can make sure that the browser shows you the original source files with sourcemaps so that you can put debug breakpoints or simply inspect the code without the noise of the other dependencies such as the Backbone library.</p><p>To include sourcemaps in the <code class="literal">browserify</code> task, you will need to install some extra dependencies:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev vinyl-buffergulp-sourcemaps</strong></span>
</pre></div><p>Then, modify the task:</p><div class="informalexample"><pre class="programlisting">// ...
var buffer = require('vinyl-buffer');

// Bundle files with browserify
gulp.task('browserify', () =&gt; {
  // set up the browserify instance on a task basis
  var bundler = browserify({
    entries: 'app/js/main.js',
    debug: true,
    // defining transforms here will avoid crashing your stream
    transform: [jstify]
  });

  return bundler.bundle()
    .on('error', $.util.log)
    .pipe(source('app.js'))
<span class="strong"><strong>      .pipe(buffer())</strong></span>
<span class="strong"><strong>      .pipe($.sourcemaps.init({loadMaps: true}))</strong></span>
<span class="strong"><strong>        // Add transformation tasks to the pipeline here.</strong></span>
<span class="strong"><strong>        .on('error', $.util.log)</strong></span>
<span class="strong"><strong>      .pipe($.sourcemaps.write('./'))</strong></span>
    .pipe(gulp.dest('.tmp/js'));
});</pre></div><p>The following figure <a id="id291" class="indexterm"/>shows the source files in the Google Chrome browser. You can inspect the original files and put breakpoints, the browser will ensure to stop the execution at the right time.</p><p>It is useful for Browserify bundles to see all the original files instead of a huge script; however, this technique can be used for the compiled programming languages such as CoffeeScript or maybe you can write your source code in ECMAScript 6 and transpile it with babel and then, the original files with sourcemaps:</p><div class="mediaobject"><img src="graphics/B01962_07_05.jpg" alt="Sourcemaps"/><div class="caption"><p>Figure 7.5 Sourcemaps in action</p></div></div></div><div class="section" title="Re-bundle automatically"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec02"/>Re-bundle automatically</h3></div></div></div><p>If you change<a id="id292" class="indexterm"/> a source file, then you will need to run the <code class="literal">browserify</code> task again. You can make sure that Gulp and Browserify do this job for you. First, you will need to install another Browserify plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev watchify</strong></span>
</pre></div><p>The <code class="literal">watchify</code> plugin listens for file changes in the source code and can be used to trigger a re-bundle task:</p><div class="informalexample"><pre class="programlisting">//...
var watchify = require('watchify');

// Bundle files with browserify
gulp.task('browserify-2', () =&gt; {
  // set up the browserify instance on a task basis
  var bundler = browserify({
    entries: 'app/js/main.js',
    debug: true,
    // defining transforms here will avoid crashing your stream
    transform: [jstify]
  });

<span class="strong"><strong>  bundler = watchify(bundler);</strong></span>

<span class="strong"><strong>  var rebundle = function() {</strong></span>
    return bundler.bundle()
      .on('error', $.util.log)
      .pipe(source('app.js'))
      .pipe(buffer())
      .pipe($.sourcemaps.init({loadMaps: true}))
        // Add transformation tasks to the pipeline here.
        .on('error', $.util.log)
      .pipe($.sourcemaps.write('./'))
      .pipe(gulp.dest('.tmp/js'));
<span class="strong"><strong>  };</strong></span>

<span class="strong"><strong>  bundler.on('update', rebundle);</strong></span>

<span class="strong"><strong>  return rebundle();</strong></span>
});</pre></div><p>When a change<a id="id293" class="indexterm"/> is triggered, the <code class="literal">rebundle()</code> function will be executed automatically so that you only need to refresh the browser. In the next section, you will see how to automate this too.</p></div></div><div class="section" title="BrowserSync"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec39"/>BrowserSync</h2></div></div></div><p>BrowserSync <a id="id294" class="indexterm"/>is an asset server that is useful for the <a id="id295" class="indexterm"/>purpose of developing, you should avoid its use for production environments. BrowserSync is a node package that runs an HTTP server that automatically reloads the browser when a change on the files that serve is detected. With <a id="id296" class="indexterm"/>BrowserSync, you may forget to manually refresh your browser every time you make a change.</p><p>You need to install the package before starting to use it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev browser-sync</strong></span>
</pre></div><p>Once the package is installed, we can create a new Gulp task to run BrowserSync:</p><div class="informalexample"><pre class="programlisting">// ...
var browserSync = require('browser-sync');
var reload = browserSync.reload;

gulp.task('serve', () =&gt;{
  browserSync({
    port: 9000,
    ui: {
      port: 9001
    },
    server: {
      baseDir: ['.tmp', 'app']
    }
  });

  gulp.watch([
    'app/*.html',
    'app/**/*.css',
    '.tmp/**/*.js'
  ]).on('change', reload);
});</pre></div><p>On this Gulp task, we <a id="id297" class="indexterm"/>will run BrowserSync in the 9000 port and open an additional 9001 port to allow us to configure the BrowserSync behavior. You can, for example, remotely debug your application, which is useful for mobile devices.</p><p>We configure BrowserSync to serve the files from the <code class="literal">app</code> and <code class="literal">.tmp</code> directories. If you access <code class="literal">http://localhost:9000/</code>from your browser, the <code class="literal">app/index.html</code> file will be served as default and will use the script files in the <code class="literal">.tmp</code> directory.</p><p>To automatically refresh the browser when a change in the source files is detected, we use the <code class="literal">gulp.watch()</code> method as it accepts a list of files to watch in the <code class="literal">node-blob</code> format and then, we can listen for the <code class="literal">change</code> event to fire a refresh signal to the browser through the <code class="literal">reload()</code> function that is included in BrowserSync.</p><p>As the server task depends on the availability of the bundle script file, this task should depend on the Browserify task that we earlier created. To<a id="id298" class="indexterm"/> indicate Gulp that the task has a dependency, we should add a new argument to the <code class="literal">gulp.task()</code> function:</p><div class="informalexample"><pre class="programlisting">// ...
var browserSync = require('browser-sync');
var reload = browserSync.reload;

gulp.task('serve', <span class="strong"><strong>['browserify'], </strong></span>() =&gt; {
// ...
});</pre></div><p>The second argument<a id="id299" class="indexterm"/> is a list of strings that the task depends on. In the previous snippet, Gulp will ensure that the <code class="literal">browserify</code> task runs and finishes first before executing the <code class="literal">browserify</code> task function.</p></div><div class="section" title="Run server with Express"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec40"/>Run server with Express</h2></div></div></div><p>Now that <a id="id300" class="indexterm"/>we have the assets server working, we need to run our Express server with <code class="literal">nodemon</code>, this package is very similar to BrowserSync; however, it does not include the browser features. With nodemon, you can run a node script that will watch for any changes on the JavaScript files. When a change is detected, the node script will be reloaded automatically.</p><p>You need to install the npm package first:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev gulp-nodemon</strong></span>
</pre></div><p>Then, we can create the task for nodemon:</p><div class="informalexample"><pre class="programlisting">// ...
var nodemon = require('gulp-nodemon');

gulp.task('express', () =&gt; {
  nodemon({
    script: 'server/index.js',
    ignore: ['app']
  });
});</pre></div><p>In this task, we are informing nodemon to ignore the changes under the <code class="literal">app </code>directory. The reason for this is that the <code class="literal">app</code> path is already watched by BrowserSync.</p><p>Now that we have the server, and the assets are served and reloaded automatically, we can merge these two tasks in order to run the project in development mode:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var httpProxy = require('http-proxy');</strong></span>

gulp.task('serve', ['browserify', 'express'], () =&gt; {
<span class="strong"><strong>  var serverProxy = httpProxy.createProxyServer();</strong></span>

  browserSync({
    port: 9000,
    ui: {
      port: 9001
    },
    server: {
      baseDir: ['.tmp', 'app'],
<span class="strong"><strong>      middleware: [</strong></span>
<span class="strong"><strong>        function (req, res, next) {</strong></span>
<span class="strong"><strong>          if (req.url.match(/^\/(api|avatar)\/.*/)) {</strong></span>
<span class="strong"><strong>            serverProxy.web(req, res, {</strong></span>
<span class="strong"><strong>              target: 'http://localhost:8000'</strong></span>
<span class="strong"><strong>            });</strong></span>
<span class="strong"><strong>          } else {</strong></span>
<span class="strong"><strong>            next();</strong></span>
<span class="strong"><strong>          }</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>      ]</strong></span>
    }
  });

  gulp.watch([
    'app/*.html',
    'app/**/*.css',
    '.tmp/**/*.js'
  ]).on('change', reload);
});</pre></div><p>A new dependency <a id="id301" class="indexterm"/>should be installed, <span class="strong"><strong>http-proxy</strong></span>. This dependency allows us to redirect all the API requests to the Express server so that BrowserSync does not try to serve these requests:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev http-proxy</strong></span>
</pre></div><p>This time, we add the <code class="literal">express</code> task dependency to the <code class="literal">serve</code> task. As we are now running two servers on different ports, assets on 9000 and API on 8000, we add a middleware in BrowserSync to redirect the traffic that starts with <code class="literal">/api/</code> or <code class="literal">/avatar/</code> to the server located at port 8000.</p><p>Now, when you run <a id="id302" class="indexterm"/>the <code class="literal">serve</code> task from your command line, you will get an amazing development environment. Every time a file in the frontend is changed, the browser will be reloaded automatically with a new bundle. If a change in the server files is detected, the Express server will also be reloaded.</p><p>That's a great improvement for your development workflow; you will be more productive and forget about manual reloads.</p></div></div>
<div class="section" title="Creating a production workflow"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Creating a production workflow</h1></div></div></div><p>The development workflow <a id="id303" class="indexterm"/>that we built in the previous sections is an amazing improvement for the project; however, we are not finished yet. In this section, you will see how to optimize the project that is to be run in the production environments.</p><p>In this section, you will learn how to minimize your JavaScript and CSS files to obfuscate your source code and reduce the time the browser takes to load the asset files. The images can also be minified in order to reduce its weight without altering its appearance.</p><div class="section" title="Gulp useref"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec41"/>Gulp useref</h2></div></div></div><p>The <code class="literal">gulp-useref</code> plugin <a id="id304" class="indexterm"/>processes your HTML files to concatenate your JavaScript and CSS assets into a single file. Please note that the JavaScript is already processed by Browserify, therefore, it is not necessary to process the JavaScript files with useref; on the other hand, CSS can be processed here.</p><p>You will need to install the plugin with npm as a development dependency:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev gulp-useref</strong></span>
</pre></div><p>Then, to use it, you will need to create a new task. Let's call it <code class="literal">html</code>:</p><div class="informalexample"><pre class="programlisting">// ...

gulp.task('html', function() {
  var assets = $.useref.assets();

  return gulp.src('app/*.html')
    .pipe(assets)
    .pipe(assets.restore())
    .pipe($.useref())
    .pipe(gulp.dest('dist'));
});</pre></div><p>The <code class="literal">gulp.src('app/*.html')</code> function grabs all the files with the<code class="literal">.html</code> extension. In our case, only the <code class="literal">index.html</code> file exists, therefore, it is the only file that will be processed. The <code class="literal">useref.assets()</code> function concatenates all the assets that are found in the HTML files and puts them in a stream, the <code class="literal">assets.restore()</code> function will restore the original stream of HTML files that are picked in the beginning.</p><p>When you call<a id="id305" class="indexterm"/> the <code class="literal">useref()</code> function, the HTML file is parsed in order to replace the assets files in a single HTML tag. For example, if you have five CSS files, it replaces these five link tags in the HTML file in a single tag that points to the concatenated version.</p><p>You should indicate the <code class="literal">useref</code> task how to concatenate the files with special tags in the HTML files:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;!-- ... --&gt;
<span class="strong"><strong>&lt;!-- build:css(app) css/vendor.css --&gt;</strong></span>
&lt;link rel="stylesheet" href="css/bootstrap.css"&gt;
&lt;link rel="stylesheet" href="css/main.css"&gt;
<span class="strong"><strong>&lt;!-- endbuild --&gt;</strong></span>
&lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;
&lt;/html&gt;</pre></div><p>You need add two HTML comments to the code, these comments have a special meaning for useref. Its syntax is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!-- build:&lt;type&gt;(alternate search path) &lt;path&gt; --&gt;
... HTML Markup, list of script / link tags.
&lt;!-- endbuild --&gt;</pre></div><p>As we are processing CSS files, we use <code class="literal">css</code> as type, and the search path indicates where useref will look for the files. If we left this optional parameter blank, then it will use the root project path. The last <code class="literal">path</code> argument indicates where the concatenated CSS files will be put.</p><p>If you run the Gulp <code class="literal">html</code> task, you will get a concatenated file with all your styles under the <code class="literal">dist/css/vendor.css</code> path. The output HTML file will point to this file instead of the development ones:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;!-- ... --&gt;
&lt;link rel="stylesheet" href="css/vendor.css"&gt;
&lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;
&lt;/html&gt;</pre></div><p>You can optimize<a id="id306" class="indexterm"/> the output CSS files by minifying them with the <code class="literal">gulp-minify-css</code> plugin. As you may have guessed, you should install the plugin with npm:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev gulp-minify-css</strong></span>
</pre></div><p>Then you can use the plugin in your build process, as follows:</p><div class="informalexample"><pre class="programlisting">// ...
<span class="strong"><strong>var minifyCss = require('gulp-minify-css');</strong></span>

gulp.task('html', function() {
  var assets = $.useref.assets();

  return gulp.src('app/*.html')
    .pipe(assets)
<span class="strong"><strong>    .pipe(minifyCss())</strong></span>
    .pipe(assets.restore())
    .pipe($.useref())
    .pipe(gulp.dest('dist'));
});</pre></div><p>This will minify the concatenated CSS file. However, as <code class="literal">useref</code> can process CSS and JavaScript files, the code can be buggy if a JavaScript build tag is added. To prevent errors, you can use the <code class="literal">gulp-if </code>plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev gulp-if gulp-uglify</strong></span>
</pre></div><p>This will also install <code class="literal">uglify</code> in order to also process the JavaScript files:</p><div class="informalexample"><pre class="programlisting">// ...

gulp.task('html', function() {
  var assets = $.useref.assets();

  return gulp.src('app/*.html')
    .pipe(assets)
<span class="strong"><strong>    .pipe($.if('*.js', uglify()))</strong></span>
<span class="strong"><strong>    .pipe($.if('*.css', minifyCss()))</strong></span>
    .pipe(assets.restore())
    .pipe($.useref())
    .pipe(gulp.dest('dist'));
});</pre></div><p>With <code class="literal">gulp-if</code> we <a id="id307" class="indexterm"/>test if the file in the stream is a CSS or a JavaScript file and then apply the right transformation.</p></div><div class="section" title="Image Optimization"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec42"/>Image Optimization</h2></div></div></div><p>When <a id="id308" class="indexterm"/>you are developing your project in the local machine, the assets load pretty fast as images and code live in the same computer; however, when you go to the production images, they travel through the Internet to your user machine.</p><p>With image optimization, we can compress these images in order to reduce the amount of data that your app downloads from the server. With node, you can use the <code class="literal">imagemin</code> package; however, as we are using Gulp, <code class="literal">gulp-imagemin</code> will do the job.</p><p>As we did earlier, you will need to install the plugin first:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev gulp-imagemin</strong></span>
</pre></div><p>Now that the plugin is installed, we can use it:</p><div class="informalexample"><pre class="programlisting">gulp.task('images', function() {
  gulp.src('app/images/*.{jpg,gif,svg,png}')
    .pipe($.imagemin())
    .pipe(gulp.dest('dist/images'));
});</pre></div><p>It grabs the images from the <code class="literal">app/images</code> path and applies the <code class="literal">imagemin()</code> process to each image.</p></div><div class="section" title="Fonts"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec43"/>Fonts</h2></div></div></div><p>Fonts for<a id="id309" class="indexterm"/> Bootstrap are located under the <code class="literal">node_modules/</code> directory. If you install other type of fonts, such as Font Awesome, or download a specific fonts; they should be copied to the <code class="literal">dist/</code> directory. You can create a <code class="literal">fonts</code> task to do this, as shown in the following:</p><div class="informalexample"><pre class="programlisting">// ...

gulp.task('fonts', function () {
  return gulp.src([
    'app/{,styles/}fonts/**/*',
    'node_modules/bootstrap/dist/fonts/**/*'
  ])
    .pipe($.flatten())
    .pipe(gulp.dest('dist/fonts'));
});</pre></div><p>Note that you <a id="id310" class="indexterm"/>will need to install the <code class="literal">gulp-flatten</code> plugin; this plugin will remove any prefix directory:</p><div class="informalexample"><pre class="programlisting">$ npm install --save-dev gulp-flatten</pre></div></div><div class="section" title="Bundle JavaScript files for production"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec44"/>Bundle JavaScript files for production</h2></div></div></div><p>The <code class="literal">browserify</code> task <a id="id311" class="indexterm"/>that we have is useful for development, it creates sourcemaps and the output is not minified. If you want to go to the production, you will need to remove the sourcemaps and minimize the output too.</p><p>For production environment, we will transform the ECMAScript 6 code into JavaScript in order to add support for these browsers that does not support for ECMAScript 6. Babel is the best transpiler at the moment to make this transformation.</p><p>The babelify plugin of Browserify will apply the transformations, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev babelify</strong></span>
</pre></div><p>You will need to configure Babel before using the babelify plugin. In Babel 6, you have to install individual packages for the functions that you want to support. For this project, we support ES2015:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev babel-preset-es2015</strong></span>
</pre></div><p>In the <code class="literal">.babelrc</code> file, you should configure the preset:</p><div class="informalexample"><pre class="programlisting">// .babelrc
{
  "presets": ["es2015"]
}</pre></div><p>Once you have configured Babel properly, we can create the <code class="literal">browserify</code> task for production:</p><div class="informalexample"><pre class="programlisting">// Bundle files with browserify for production
gulp.task('browserify:dist', function () {
  // set up the browserify instance on a task basis
  var bundler = browserify({
    entries: 'app/js/main.js',
    // defining transforms here will avoid crashing your stream
    transform: [babelify, jstify]
  });

  return bundler.bundle()
    .on('error', $.util.log)
    .pipe(source('app.js'))
    .pipe(buffer())
    .pipe($.uglify())
    .pipe(gulp.dest('dist/js'));
});</pre></div><p>This task does <a id="id312" class="indexterm"/>not generate sourcemaps and optimize the output.</p></div><div class="section" title="Putting it all together"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec45"/>Putting it all together</h2></div></div></div><p>You have learned how to optimize several kind of assets: CSS, JavaScript, and images. Now let's put all this together in order to build our application. The <code class="literal">serve:dist</code> task wires all the processes into a pipeline:</p><div class="informalexample"><pre class="programlisting">gulp.task('serve:dist', ['browserify:dist', 'images', 'fonts', 'express'], () =&gt; {
  var serverProxy = httpProxy.createProxyServer();

  browserSync({
    port: 9000,
    ui: {
      port: 9001
    },
    server: {
      baseDir: 'dist',
      middleware: [
        function (req, res, next) {
          if (req.url.match(/^\/(api|avatar)\/.*/)) {
            serverProxy.web(req, res, {
              target: 'http://localhost:8000'
            });
          } else {
            next();
          }
        }
      ]
    }
  });
});</pre></div><p>To test our pipeline, we can run the <code class="literal">serve:dist</code> task in the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gulp serve:dist</strong></span>
<span class="strong"><strong>[11:18:04] Using gulpfile ~/Projects/mastering-backbone/ch07/gulpfile.js</strong></span>
<span class="strong"><strong>[11:18:04] Starting 'browserify:dist'...</strong></span>
<span class="strong"><strong>[11:18:04] Starting 'images'...</strong></span>
<span class="strong"><strong>[11:18:04] Finished 'images' after 305 ms</strong></span>
<span class="strong"><strong>[11:18:04] Starting 'fonts'...</strong></span>
<span class="strong"><strong>[11:18:04] Starting 'express'...</strong></span>
<span class="strong"><strong>[11:18:05] Finished 'express' after 141 ms</strong></span>
<span class="strong"><strong>[11:18:05] gulp-imagemin: Minified 0 images</strong></span>
<span class="strong"><strong>[11:18:05] [nodemon] 1.8.1</strong></span>
<span class="strong"><strong>[11:18:05] [nodemon] to restart at any time, enter `rs`</strong></span>
<span class="strong"><strong>[11:18:05] [nodemon] watching: *.*</strong></span>
<span class="strong"><strong>[11:18:05] [nodemon] starting `node server/index.js`</strong></span>
<span class="strong"><strong>Express server is running on port 8000</strong></span>
<span class="strong"><strong>[11:18:08] Finished 'fonts' after 4.04 s</strong></span>
<span class="strong"><strong>[11:18:12] Finished 'browserify:dist' after 8.02 s</strong></span>
<span class="strong"><strong>[11:18:12] Starting 'serve:dist'...</strong></span>
<span class="strong"><strong>[11:18:12] Finished 'serve:dist' after 40 ms</strong></span>
<span class="strong"><strong>[11:18:12] [nodemon] restarting due to changes...</strong></span>
<span class="strong"><strong>[BS] Access URLs:</strong></span>
<span class="strong"><strong> --------------------------------------</strong></span>
<span class="strong"><strong>       Local: http://localhost:9000</strong></span>
<span class="strong"><strong>    External: http://192.168.100.4:9000</strong></span>
<span class="strong"><strong> --------------------------------------</strong></span>
<span class="strong"><strong>          UI: http://localhost:9001</strong></span>
<span class="strong"><strong> UI External: http://192.168.100.4:9001</strong></span>
<span class="strong"><strong> --------------------------------------</strong></span>
<span class="strong"><strong>[BS] Serving files from: dist</strong></span>
<span class="strong"><strong>[11:18:12] [nodemon] starting `node server/index.js`</strong></span>
<span class="strong"><strong>Express server is running on port 8000</strong></span>
</pre></div><p>Notice how the tasks are executed by Gulp. After all these processes, the browser will automatically open while pointing to the <code class="literal">http://localhost:9000</code> address, running the application in the production environment.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Summary</h1></div></div></div><p>In this chapter, we have seen how to use tools to build our Backbone application. First, you learned what a task runner is and the most popular choices available for Node. Then, we saw how Gulp works and creates tasks.</p><p>With Gulp, you can build a development environment and configure it in order to apply optimizations to your assets for the production environments. Gulp is stream-based, which means that you can grab a bunch of files from a <code class="literal">glob</code> specification and stream these files in order to apply transformations, such as compiling, concatenating, transpiling, and so on, as you need.</p><p>Task runners are amazing tools that allow you to automatize tasks. You can not only create development and production workflows, but also tasks for almost anything, which you don't want to repeat. For example, a task to make deployments.</p><p>In the next chapter, we will see how to test the Backbone applications. You will learn how to isolate and fake dependencies for easy testing, the what and how to make Backbone testing.</p></div></body></html>