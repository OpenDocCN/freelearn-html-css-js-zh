- en: '*Chapter 4*: Interacting with a page'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：与页面交互'
- en: Thanks to [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050), *Navigating
    through a website*, we now know how to open a browser and all the different options
    we have to launch browsers and create new pages. We also know how to navigate
    through other pages. We learned about HTTP responses and how they are related
    to a request.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢[*第三章*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050)，“网站导航”，我们现在知道如何打开浏览器以及我们启动浏览器和创建新页面所拥有的所有不同选项。我们还了解了如何导航到其他页面。我们学习了HTTP响应以及它们与请求的关系。
- en: 'This chapter is about interaction. Emulating user interaction is essential
    in UI testing. There is one pattern in unit testing called **Arrange-Act-Assert**
    (**AAA**). This pattern enforces a particular order in the test code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的是交互。在UI测试中，模拟用户交互是至关重要的。单元测试中有一个名为** Arrange-Act-Assert**（**AAA**）的模式。这个模式强制测试代码遵循特定的顺序：
- en: Arrange – Prepare the context.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arrange – 准备上下文。
- en: Act – Interact with the page.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Act – 与页面交互。
- en: Assert – Check the page reaction.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Assert – 检查页面反应。
- en: In this chapter, we will learn how to find elements on a page. We will understand
    how the development team can improve their HTML so that you can easily find elements.
    But if you cannot change the page HTML, we will also look at another set of tools
    to find the elements we need.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在页面上查找元素。我们将了解开发团队如何改进他们的HTML，以便你能够轻松地找到元素。但如果无法更改页面HTML，我们还将探讨另一组工具来查找所需的元素。
- en: 'Once we find an element, we will want to interact with it. Puppeteer provides
    two sets of APIs: One is action functions, such as click, select, or type. Then
    we have a set of emulation functions, such as mouse events or keyboard emulation.
    We will cover all those functions.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了一个元素，我们就会想要与之交互。Puppeteer提供了两组API：一组是动作函数，如点击、选择或输入。然后我们有一组模拟函数，如鼠标事件或键盘模拟。我们将涵盖所有这些函数。
- en: 'This chapter will introduce a new object we haven''t mentioned yet: **The element
    handle**.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一个我们尚未提及的新对象：**元素句柄**。
- en: 'By the end of this chapter, we will have added another tool to our toolbox:
    The Visual Studio Code debugging tools.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将把另一个工具添加到我们的工具箱中：Visual Studio Code调试工具。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introduction to HTML, the DOM, and CSS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML、DOM和CSS简介
- en: Finding elements
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找元素
- en: Finding elements using XPath
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XPath查找元素
- en: Interacting with elements
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与元素交互
- en: Keyboard and mouse emulation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘和鼠标模拟
- en: Interacting with multiple frames
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多个框架交互
- en: Debugging tests with Visual Studio Code
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Visual Studio Code调试测试
- en: By the end of this chapter, you will be able to emulate most types of user interaction.
    But first, we need to lay the groundwork. Let's talk about HTML, the **Document
    Object Model** (**DOM**), and CSS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够模拟大多数类型的用户交互。但首先，我们需要打下基础。让我们来谈谈HTML、**文档对象模型**（**DOM**）和CSS。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code of this chapter on the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter4` directory. Remember to run `npm install` on that directory
    and then go to the `Chapter4/vuejs-firebase-shopping-cart directory` directory
    and run `npm install` again.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库（[https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer)）的`Chapter4`目录下找到本章的所有代码。请记住在该目录下运行`npm
    install`，然后进入`Chapter4/vuejs-firebase-shopping-cart`目录并再次运行`npm install`。
- en: If you want to implement the code while following this chapter, you can start
    from the code you left in the `Chapter3` directory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在遵循本章的同时实现代码，你可以从`Chapter3`目录中留下的代码开始。
- en: Introduction to HTML, the DOM, and CSS
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML、DOM和CSS简介
- en: You won't be able to find elements if you don't know CSS, and you won't understand
    CSS if you don't understand the **DOM** and **HTML**. So, we need to start with
    the basics.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道CSS，你就找不到元素；如果你不理解**DOM**和**HTML**，你就不会理解CSS。因此，我们需要从基础知识开始。
- en: I bet you've heard that you can build a site with HTML, CSS, and JavaScript.
    You might be using different server-side technologies. Your frontend might be
    implemented using cool technologies such as React or Angular. But in the end,
    the result will be a page based on HTML, CSS, and JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你已经听说你可以用HTML、CSS和JavaScript来构建网站。你可能正在使用不同的服务器端技术。你的前端可能使用像React或Angular这样的酷技术来实现。但最终，结果将是一个基于HTML、CSS和JavaScript的页面。
- en: '**HTML** is the page''s content. If you go to any website, open the **DevTools**,
    and click on the **Elements** tab, you will see the content of the page. You will
    see the page''s title. If it''s a news site, you will see all the articles there.
    If you visit a blog post, you will see the text of that post.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTML** 是页面的内容。如果你访问任何网站，打开 **开发者工具**，然后点击 **元素** 选项卡，你将看到页面的内容。你会看到页面的标题。如果你是一个新闻网站，你将看到那里的所有文章。如果你访问一篇博客文章，你将看到那篇文章的文本。'
- en: Without **CSS**, an HTML page would look like text written in Notepad. CSS not
    only brings color and fonts, but it's also the scaffolding that gives structure
    to a page.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 **CSS**，HTML 页面看起来就像记事本中写的文本。CSS 不仅带来了颜色和字体，它还是给页面提供结构的框架。
- en: Fun fact
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实
- en: Firefox has a built-in tool to disable all the styles on a page. If you go to
    **View** | **Page Style** and click on **No Style**, you will see how our life
    would be without CSS.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox 内置了一个工具可以禁用页面上的所有样式。如果你转到 **查看** | **页面样式** 并点击 **无样式**，你将看到没有 CSS 的生活会是怎样的。
- en: The last piece is JavaScript. JavaScript brings behavior to a page. Once the
    browser parses the HTML and builds the DOM, it allows us to manipulate and give
    life to a page.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个部分是 JavaScript。JavaScript 为页面带来了行为。一旦浏览器解析了 HTML 并构建了 DOM，它就允许我们操作并赋予页面生命。
- en: But, as I mentioned before, we need to go to the basics, to the foundations
    of the web. Let's begin with HTML.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我之前提到的，我们需要回到基础，回到网络的基石。让我们从 HTML 开始。
- en: HTML
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML
- en: '**HTML** stands for **HyperText Markup Language**: HyperText because the HTML
    is not content per se; HTML contains the content. Markup because it uses tags
    to give meaning to that content. And language because, although many developers
    disagree and they get mad about the idea, HTML is a language.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTML** 代表 **超文本标记语言**：超文本是因为 HTML 本身不是内容；HTML 包含内容。标记是因为它使用标签来赋予内容意义。语言是因为，尽管许多开发者不同意，并且对此感到愤怒，但
    HTML 是一种语言。'
- en: If we read an HTML file as a data structure, we can say that HTML is a **relaxed**
    version of XML. So, to better understand HTML, we need to look at the basics of
    XML.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 HTML 文件作为数据结构来读取，我们可以说 HTML 是 XML 的 **宽松** 版本。因此，为了更好地理解 HTML，我们需要查看 XML
    的基础知识。
- en: 'These are the basic elements of XML content:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 XML 内容的基本元素：
- en: '![XML Content'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![XML 内容'
- en: '](img/Figure_4.1_B16113.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B16113.jpg)'
- en: XML Content
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: XML 内容
- en: 'If you look at this figure, you already know almost everything you need to
    know about XML. Well, maybe I''m exaggerating. But this is the idea:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看这张图，你几乎已经知道了你需要了解的关于 XML 的所有内容。好吧，也许我在夸张。但这就是想法：
- en: You have elements, which are represented as `<ElementName>`. In our example,
    we have `element>` and `<child-element>`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有元素，这些元素表示为 `<ElementName>`。在我们的例子中，我们有 `element>` 和 `<child-element>`。
- en: The element might have attributes, which are represented as `AttributeName="
    AttributeValue"`. We have `value="3``value="4"` in our example.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素可能具有属性，这些属性表示为 `AttributeName=" AttributeValue"`。在我们的例子中，我们有 `value="3"` 和
    `value="4"`。
- en: The element might contain other elements. You can see we have two **child-element**
    elements inside the main **element**.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素可能包含其他元素。你可以看到我们在主 **element** 中有两个 **child-element** 元素。
- en: An element finishes (is closed) with `</ElementName>`, or with `/>` at the end
    instead of `>`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个元素通过 `</ElementName>` 结束（闭合），或者用 `/>` 结尾而不是 `>`。
- en: XML parsers are very strict with these rules. If the XML content you are trying
    to parse breaks just a single rule, the parser will consider the entire XML invalid.
    Whether it's a missing closing element or an attribute without quotes, the parser
    will fail to evaluate the XML content.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: XML 解析器对这些规则非常严格。如果你正在尝试解析的 XML 内容违反了其中任何一条规则，解析器将认为整个 XML 无效。无论是缺少闭合元素还是没有引号的属性，解析器都将无法评估
    XML 内容。
- en: 'But we will find that browsers are not that strict when parsing HTML content.
    Let''s take a look at the following HTML:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们会发现，在解析 HTML 内容时，浏览器并不那么严格。让我们看看以下 HTML：
- en: '![A broken HTML'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个损坏的 HTML'
- en: '](img/Figure_4.2_B16113.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_B16113.jpg)'
- en: A broken HTML
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个损坏的 HTML
- en: This simple HTML will print *Hello World* in red in the browser.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这简单的 HTML 会在浏览器中用红色打印出 *Hello World*。
- en: Is this valid XML? No. As you can see, the `<div>` element is not closed. But
    is this valid HTML? Yes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不是有效的 XML？不是。正如你所见，`<div>` 元素没有闭合。但这是不是有效的 HTML？是的。
- en: Important Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The fact that a browser would try to render *broken* HTML doesn't mean that
    you should take that lightly. It's possible you have heard a developer say that
    a particular bug was due to a *missing closing div*. If the HTML is broken, for
    instance, it has a missing closing `div`, the browser will try to guess the best
    way to render that HTML. The decision the browser makes when trying to fix broken
    HTML could end up with the page working as expected or with the full page layout
    broken.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器试图渲染 *损坏的* HTML 的行为并不意味着你应该轻视它。你可能已经听到开发者说，某个特定的错误是由于 *缺少关闭的 div*。例如，如果 HTML
    损坏了，比如缺少关闭的 `div`，浏览器将尝试猜测渲染该 HTML 的最佳方式。浏览器在尝试修复损坏的 HTML 时所做的决定可能会导致页面按预期工作，或者整个页面布局损坏。
- en: Another interesting concept is that the XML specification doesn't give meaning
    to the elements. The names of the elements, the attributes, and the resulting
    information coming from that content depend on who wrote the XML and who is reading
    it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的概念是，XML 规范并没有给元素赋予意义。元素名称、属性以及从该内容产生的信息取决于谁编写了 XML 以及谁在阅读它。
- en: HTML is XML with meaning. In *1993*, *Tim Berners-Lee*, who is known as the
    inventor of the World Wide Web, decided that the main element would be called
    `HTML` and that it would contain a `BODY`. He decided that images would be represented
    as `IMG` elements, paragraphs would be `P` elements, and so on. Over the years,
    browser and web developers followed and improved this convention, getting to what
    we today call HTML5\. We, as a community, agreed on the meaning of HTML elements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 是具有意义的 XML。在 *1993* 年，被称为万维网发明者的 *Tim Berners-Lee* 决定，主要元素将被称为 `HTML`，并且它将包含一个
    `BODY`。他决定图像将用 `IMG` 元素表示，段落将是 `P` 元素，等等。多年来，浏览器和网页开发者遵循并改进了这一惯例，最终形成了我们今天所说的
    HTML5。作为社区的一员，我们一致同意 HTML 元素的意义。
- en: We agreed that if we add the `text` attribute with the value `red`, we will
    get the text in red, and so on. How many types of elements do we have in HTML?
    A lot! The good news is that you don't need to know all of them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们达成共识，如果我们添加具有值 `red` 的 `text` 属性，我们将得到红色的文本，等等。HTML 中有多少种元素类型？很多！好消息是，你不需要知道所有这些。
- en: The more you know, the more productive you will be. However, these are the most
    common elements you will find on a page.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 知识越多，你将越有效率。然而，这些是在页面上最常见到的元素。
- en: Document structure elements
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档结构元素
- en: Every HTML document will be contained inside an `<html>` element. That HTML
    element will have two child elements. The first element you will find is `<head>`.
    Inside that `<head>` element, you will find metadata elements, such as `<title>`
    with the page title, and many `<meta>` elements with metadata not supported by
    the standard HTML. Many sites use `<meta>` to enforce how the page should be shown
    on social media. The second set of elements you will find are `<link>` elements,
    including CSS files, and `<script>` files, including JavaScript code. Although
    the script elements are accepted in the header, most sites would add their script
    elements at the bottom of the page for faster rendering.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 HTML 文档都将包含在一个 `<html>` 元素内部。这个 HTML 元素将有两个子元素。你将找到的第一个元素是 `<head>`。在这个 `<head>`
    元素内部，你可以找到元数据元素，例如 `<title>`，它包含页面标题，以及许多 `<meta>` 元素，它们包含标准 HTML 不支持的元数据。许多网站使用
    `<meta>` 来强制页面在社交媒体上的显示方式。你将找到的第二组元素是 `<link>` 元素，包括 CSS 文件，以及 `<script>` 文件，包括
    JavaScript 代码。尽管脚本元素被接受在头部，但大多数网站会在页面底部添加它们的脚本元素以实现更快的渲染。
- en: The second element you will find is the `<body>` element. The page itself will
    be inside this element.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你将找到的第二个元素是 `<body>` 元素。页面本身将在这个元素内部。
- en: Text elements
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本元素
- en: Then we have the basic text elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有基本的文本元素。
- en: '`<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`, and `<h6>` are headings. If you have
    a text editor, you might have seen that there are many levels of headings and
    subheadings.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h1>`、`<h2>`、`<h3>`、`<h4>`、`<h5>` 和 `<h6>` 是标题。如果你有一个文本编辑器，你可能已经看到有很多级别的标题和副标题。'
- en: '`<p>` will denote paragraphs. Then you might find `<span>` elements, which
    help style part of the text in a paragraph.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`<p>` 将表示段落。然后你可能会发现 `<span>` 元素，它有助于在段落中样式化文本的一部分。'
- en: 'Another type of text element is `<label>`. These labels are linked to an input
    control, such as a radio button, giving context to that control. For example,
    a radio button or a checkbox doesn''t have text; it''s just a check or a radio.
    You need a label to give them context:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种文本元素是`<label>`。这些标签与输入控件相关联，例如单选按钮，为该控件提供上下文。例如，单选按钮或复选框没有文本；它只是一个勾选或单选。你需要标签来为它们提供上下文：
- en: '![Radio buttons with labels'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![Radio buttons with labels]'
- en: '](img/Figure_4.3_B16113.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.3_B16113.jpg]'
- en: Radio buttons with labels
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 带标签的单选按钮
- en: This HTML has three labels. *Huey* gives context to the first radio option,
    *Dewey* to the second, and *Louie* to the last one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML有三个标签。*Huey*为第一个单选选项提供上下文，*Dewey*为第二个，*Louie*为最后一个。
- en: The last type of text element we will look at is list elements. Lists are expressed
    as a parent element, `<ul>` for unordered lists or `<ol>` for ordered lists, and
    `<li>` elements. You will see lots of these in menu bars.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一种文本元素是列表元素。列表以父元素表示，`<ul>`用于无序列表或`<ol>`用于有序列表，以及`<li>`元素。你将在菜单栏中看到很多这样的元素。
- en: Action elements
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动作元素
- en: There are two main action elements in HTML. The `<a>` anchor, also known as
    a link, was designed to take you to another page, but these days it's not limited
    to that, and it could trigger actions inside the page.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: HTML中有两种主要的动作元素。`<a>`锚点，也称为链接，最初是为了带你到另一个页面而设计的，但如今它不仅仅局限于这一点，它还可以在页面内触发动作。
- en: 'The second element is `<button>`, which again, although it was designed to
    send data to the server using an HTTP POST request, is now being used for many
    other kinds of actions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个元素是`<button>`，尽管它最初是为了通过HTTP POST请求将数据发送到服务器而设计的，但现在它被用于许多其他类型的动作：
- en: Important note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The days when you would only use buttons and links to perform actions are in
    the past. As most HTML elements support click events, you will find pages that
    show elements as buttons, but in fact, those buttons are HTML elements such as
    **DIVs**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那些只使用按钮和链接来执行操作的日子已经过去了。由于大多数HTML元素都支持点击事件，你会发现一些页面将元素显示为按钮，但实际上，那些按钮是HTML元素，例如**DIVs**。
- en: '![Links and buttons at packtpub.com'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![Links and buttons at packtpub.com]'
- en: '](img/Figure_4.4_B16113.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.4_B16113.jpg]'
- en: Links and buttons at packtpub.com
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: packtpub.com上的链接和按钮
- en: Many times, you won't notice the difference between a link and a button. For
    instance, in the [packtpub.com](http://packtpub.com) site, the search button is
    a `button` element, whereas the cart button is, in fact, an `anchor`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你不会注意到链接和按钮之间的区别。例如，在[packtpub.com](http://packtpub.com)网站上，搜索按钮是一个`button`元素，而购物车按钮实际上是一个`anchor`。
- en: Most of your automation code will involve clicking on these action elements.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你的大部分自动化代码将涉及点击这些动作元素。
- en: Container Elements
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器元素
- en: 'The role of container elements is grouping elements, mostly for layout and
    style purposes. The most popular element is `DIV`. What is `DIV`? It can be anything:
    A list of items, a popup, a header, anything. It is used to create groups of elements.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 容器元素的作用是分组元素，主要用于布局和样式目的。最受欢迎的元素是`DIV`。`DIV`是什么？它可以是一切：项目列表、弹出窗口、页眉，等等。它用于创建元素组。
- en: One element that was the king of the container elements was `TABLE`. As you
    can infer from the name, a table represents a grid. Inside a `TABLE` element,
    you can have `TR` elements representing rows, `TH` elements representing header
    cells, and `TD` elements representing a column inside a row. I mentioned that
    this *was* the king of containers because the community has now moved on from
    tables to `DIVs` due to performance issues, the need for more complex layouts,
    and responsiveness issues. But you might still see some tables on sites showing
    information using a grid style.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经是容器元素之王的元素是`TABLE`。正如其名称所暗示的，表格代表一个网格。在`TABLE`元素内部，你可以有`TR`元素代表行，`TH`元素代表表头单元格，`TD`元素代表行内的列。我提到这是容器元素之王，是因为社区现在已经从表格转向了`DIVs`，这是由于性能问题、对更复杂布局的需求以及响应性问题。但你在一些使用网格样式显示信息的网站上仍然可能会看到一些表格。
- en: '`<header>` for the site header, `<footer>` for the footer, `<nav>` for the
    navigation options, `<articles>` for blog posts, and so on. The purpose of these
    elements is to help external tools (such as screen readers, search engines, and
    even the same browser) to understand the HTML content.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`<header>`用于网站页眉，`<footer>`用于页脚，`<nav>`用于导航选项，`<articles>`用于博客文章，等等。这些元素的目的在于帮助外部工具（如屏幕阅读器、搜索引擎甚至同一浏览器）理解HTML内容。'
- en: Input elements
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入元素
- en: The last group of elements we need to know about are the input elements. The
    most common input element is the multifaceted `input` element. Depending on the
    `type` attribute, it can be `"text"`, `"password"`, `"checkbox"`, `"file"` (upload),
    and so on; the list goes on to a total of 22 types.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解的最后一批元素是输入元素。最常见的输入元素是多功能的`input`元素。根据`type`属性，它可以是`"text"`、`"password"`、`"checkbox"`、`"file"`（上传）等等；列表继续到总共22种类型。
- en: Then we have `select` elements for drop-down lists and the `option` element
    to represent the items of a drop-down list.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有下拉列表的`select`元素和表示下拉列表项的`option`元素。
- en: Of course, we shouldn't forget the `<IMG>` element. It's impossible to picture
    a site without images.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不应该忘记`<IMG>`元素。没有图片的网站是无法想象的。
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Not every input you will see these days will be one of these elements. To make
    inputs more user-friendly or just nicer, you will find that developers might build
    inputs based on many other elements. For instance, you could find a drop-down
    list, which instead of being a select element would be an input element, plus
    an arrow button, which would show a floating list on clicking it. This kind of
    control makes sites prettier but automation more challenging.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在看到的输入并不都是这些元素之一。为了使输入更用户友好或更美观，你会发现开发者可能会基于许多其他元素构建输入。例如，你可能会找到一个下拉列表，它不是选择元素，而是一个输入元素，加上一个箭头按钮，点击它会显示一个浮动列表。这种控件使网站更美观，但自动化更具挑战性。
- en: 'HTML has not only a known list of elements but also a known list of attributes.
    These are the most common attributes you will find:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HTML不仅有已知的元素列表，还有已知的属性列表。这些是你最常看到的属性：
- en: '`id`: Identifies a unique element. It''s the element ID in the `DOM` (we will
    talk about the DOM in the next section).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 识别一个唯一元素。它是`DOM`（我们将在下一节中讨论`DOM`）中的元素ID。'
- en: '`class`: Contains the CSS classes applied to the element. It accepts more than
    one CSS class separated by a space.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`: 包含应用于元素的CSS类。它接受多个CSS类，用空格分隔。'
- en: '`style`: CSS style assigned to the element.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style`: 分配给元素的CSS样式。'
- en: HTML won't limit the attributes you can add to an element. You can add any attribute
    you want, for instance, `defaultColor="blue"`. One convention is using `defaultColor`
    is a valid attribute, the general convention uses `data-default-color="blue"`
    instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HTML不会限制你可以添加到元素中的属性。你可以添加任何你想要的属性，例如，`defaultColor="blue"`。一个惯例是使用`defaultColor`是一个有效的属性，而一般惯例使用`data-default-color="blue"`代替。
- en: The other set of attributes of interest to us is the `role="treeitem"` and `aria-expanded="true"`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的另一组属性是`role="treeitem"`和`aria-expanded="true"`。
- en: In the past few paragraphs, the DOM has been mentioned a few times. Let's talk
    about the DOM.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几段中，DOM被提到了几次。让我们来谈谈DOM。
- en: The DOM
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM
- en: The DOM is the interface you can use in JavaScript to interact with the HTML.
    According to the MDN ([https://www.hardkoded.com/ui-testing-with-puppeteer/dom](https://www.hardkoded.com/ui-testing-with-puppeteer/dom)),
    it is *the data representation of the objects that comprise the structure and
    content of a document on the web*. Why should we care about that? Because we are
    going to use the same tools to automate our pages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DOM是你可以使用JavaScript与之交互的HTML接口。根据MDN([https://www.hardkoded.com/ui-testing-with-puppeteer/dom](https://www.hardkoded.com/ui-testing-with-puppeteer/dom))，它是*构成网页上文档结构和内容的对象的数据表示*。我们为什么要关心这个？因为我们将要使用相同的工具来自动化我们的页面。
- en: In the previous section, we mentioned that an element might have an ID. You'll
    find that the search input at [https://www.packtpub.com/](https://www.packtpub.com/)
    has the ID search, so you will be able to get that element in JavaScript using
    `document.getElementById('search')`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到一个元素可能有一个ID。你会发现[https://www.packtpub.com/](https://www.packtpub.com/)上的搜索输入框具有ID搜索，因此你可以使用`document.getElementById('search')`在JavaScript中获取该元素。
- en: 'You might be wondering: How do I know the ID of a button? Or how do I check
    that the ID is valid? Remember we talked about the dev tools?'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道：我如何知道按钮的ID？或者我如何检查ID是否有效？记得我们讨论过开发者工具吗？
- en: 'The developer tools can be opened by clicking on the three dots in the top-right
    corner of Chrome and then going to **More Tools** | **Developer Tools**. You can
    also use the *Ctrl* + *Shift* + *J* shortcut in Windows or *Cmd* + *Option* +
    *I* in macOS:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过点击Chrome右上角的三点来打开开发者工具，然后转到**更多工具** | **开发者工具**。你还可以在Windows中使用*Ctrl* +
    *Shift* + *J*快捷键，或在macOS中使用*Cmd* + *Option* + *I*快捷键：
- en: '![Developer Tools'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![开发者工具'
- en: '](img/Figure_4.5_B16113.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.5_B16113.jpg)'
- en: Developer Tools
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者工具
- en: 'If you right-click on any element on the page, for instance, the search button,
    you will find the **Inspect** option, which will select that element in the **Elements**
    tab. There you will be able to see all the attributes of that element:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你右键点击页面上的任何元素，例如搜索按钮，你会找到 **检查** 选项，它将在 **元素** 标签中选中该元素。在那里，你将能够看到该元素的所有属性：
- en: '![Inspect option'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![检查选项'
- en: '](img/Figure_4.6_B16113.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.6_B16113.jpg)'
- en: Inspect option
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 检查选项
- en: 'Another tab you will use a lot is the **Console** tab, where you will be able
    to run JavaScript code. If you are in the **Elements** tab and press the *Esc*
    key, you will get the **Console** tab below the **Elements** one. From there,
    you will be able to test your code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会经常使用的一个标签是 **控制台** 标签，在那里你可以运行 JavaScript 代码。如果你在 **元素** 标签中，并按下 *Esc* 键，你将得到位于
    **元素** 下的 **控制台** 标签。从那里，你将能够测试你的代码：
- en: '![Console tab'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![控制台标签'
- en: '](img/Figure_4.7_B16113.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.7_B16113.jpg)'
- en: Console tab
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台标签
- en: Another set of functions that you will use a lot are `document.querySelector`
    and `document.querySelectorAll`. The first function returns the first element
    matching a CSS selector, whereas the second function returns a list of elements
    matching a CSS selector. So, we need to learn about some CSS selectors next.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会经常使用的一组功能是 `document.querySelector` 和 `document.querySelectorAll`。第一个函数返回与
    CSS 选择器匹配的第一个元素，而第二个函数返回与 CSS 选择器匹配的元素列表。因此，我们需要了解一些 CSS 选择器。
- en: CSS Selectors
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS 选择器
- en: 'You don''t need to learn CSS to understand how to style a page, but you should
    master how to find elements on a page. There are around 60 different selectors
    ([https://www.w3schools.com/cssref/css_selectors.asp](https://www.w3schools.com/cssref/css_selectors.asp))
    we can use for finding elements. We won''t cover all 60 here, but let''s go through
    the most common selectors:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要学习 CSS 就能理解如何设置页面样式，但你应该掌握如何在页面上查找元素。我们可以使用大约 60 种不同的选择器([https://www.w3schools.com/cssref/css_selectors.asp](https://www.w3schools.com/cssref/css_selectors.asp))来查找元素。我们不会在这里涵盖所有
    60 种，但让我们来看看最常见的选择器：
- en: 'Select by element name:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过元素名选择：
- en: 'Selector: `ElementName`.'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择器：`ElementName`。
- en: 'Example: `input` will select `<input>` elements.'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：`input` 将选择 `<input>` 元素。
- en: 'Select by class name:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过类名选择：
- en: 'Selector: `.ClassName`.'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择器：`.ClassName`。
- en: 'Example: `.input-text` will select any element that contains the `input-text`
    class.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：`.input-text` 将选择包含 `input-text` 类的任何元素。
- en: If you look at the search input in [https://www.packtpub.com/](https://www.packtpub.com/),
    the class attribute is `class="input-text algolia-search-input aa-input"`. This
    selector won't check whether the class attribute is equal to `input-text`. It
    has to contain it.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你查看 [https://www.packtpub.com/](https://www.packtpub.com/) 上的搜索输入，其类属性为 `class="input-text
    algolia-search-input aa-input"`。此选择器不会检查类属性是否等于 `input-text`。它必须包含它。
- en: 'Select by ID:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ID 选择：
- en: 'Selector: `#SomeID`.'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择器：`#SomeID`。
- en: 'Example: `#search` will select the element with the `search` ID. In this case,
    it does check equality.'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：`#search` 将选择具有 `search` ID 的元素。在这种情况下，它确实检查了等式。
- en: 'Select by attribute:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过属性选择：
- en: 'Selector: `[attribute=value]`.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择器：`[attribute=value]`。
- en: 'Example: `[aria-labelledby= "search"]` will select the element with the `aria-labelledby`
    attribute with the value `search`. This is an excellent example of the use of
    ARIA attributes for automation.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：`[aria-labelledby= "search"]` 将选择具有 `aria-labelledby` 属性且值为 `search` 的元素。这是一个使用
    ARIA 属性进行自动化的优秀示例。
- en: This selector is not limited by only the equality check (`=`). You could use
    only `[attribute]` to check whether the element contains the attribute, no matter
    the value. You can also use many other operators. For example, you can use `*=`
    to check whether the attribute contains a value or `|=` to check whether it begins
    with a value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此选择器不仅限于等式检查（`=`）。你可以使用 `[attribute]` 来检查元素是否包含属性，无论其值如何。你还可以使用许多其他运算符。例如，你可以使用
    `*=` 来检查属性是否包含值，或者使用 `|=` 来检查它是否以某个值开头。
- en: Combining selectors
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合选择器
- en: What's great about CSS is that you can combine all these selectors. You could
    use `input.input-search[aria-labelledby=" search"]` to select an input with the
    `input-search` class and the `aria-labelledby` attribute with the value `search`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 的好处在于你可以组合所有这些选择器。你可以使用 `input.input-search[aria-labelledby=" search"]`
    来选择具有 `input-search` 类和 `aria-labelledby` 属性且值为 `search` 的输入。
- en: 'You can also look for child elements. CSS allows us to "cascade" (that''s what
    the *C* in *CSS* stands for) selectors. You can search for child elements by adding
    new selectors separated by a space. Let''s take, for instance, the following selector:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以查找子元素。CSS允许我们“级联”（这就是*CSS*中的*C*代表的意思）选择器。你可以通过添加由空格分隔的新选择器来搜索子元素。让我们以以下选择器为例：
- en: '[PRE0]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you read it backwards, it will select an `input` inside an element with the
    `algolia-autocomplete` class, which is inside a `form` element. Notice that I
    said an input *inside* an element with the `algolia-autocomplete` class. That
    doesn't need to be the direct parent of the input element.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你倒着读，它会选择一个具有`algolia-autocomplete`类的元素内部的`input`，而这个元素位于一个`form`元素内部。注意，我说的是一个具有`algolia-autocomplete`类的元素内部的`input`。这不需要是输入元素的直接父元素。
- en: 'If you want to check strictly a parent-child relationship, you can separate
    selectors with a `>` instead of a space:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要严格检查父子关系，你可以用`>`而不是空格来分隔选择器：
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This selector will look for an input whose direct parent element is an element
    with the `algolia-autocomplete` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选择器将寻找一个直接父元素是具有`algolia-autocomplete`类的元素的`input`。
- en: 'Maybe you are thinking, why do I need to know all this information? I just
    want to get up and running with Puppeteer! Let me tell you something: You will
    spend half of your time inside the developer tools, and the most frequent element
    in your code will be a CSS selector. The more you know about HTML, the DOM, and
    CSS, the more proficient you will be at browser automation.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你会想，我为什么要知道所有这些信息？我只是想用Puppeteer开始工作！让我告诉你一些事情：你有一半的时间会在开发者工具中度过，你代码中最频繁出现的元素将会是CSS选择器。你对HTML、DOM和CSS了解得越多，你在浏览器自动化方面的技能就会越熟练。
- en: But now it's time to go back to the Puppeteer world.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在是我们回到Puppeteer世界的时候了。
- en: Finding elements
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找元素
- en: It's time to apply everything we have learned so far. We need to master selectors
    because our Puppeteer code will be mostly about finding elements and interacting
    with them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们应用到目前为止所学的一切的时候了。我们需要掌握选择器，因为我们的Puppeteer代码将主要关于查找元素和与它们交互。
- en: 'Let''s bring back the login page from our e-commerce app:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把电子商务应用中的登录页面恢复回来：
- en: '![Login page'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![登录页面'
- en: '](img/Figure_4.8_B16113.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.8_B16113.jpg]'
- en: Login page
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面
- en: 'If we want to test the login page, we need to find these three elements: The
    **email input**, the **password input**, and the **login button**.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要测试登录页面，我们需要找到这三个元素：**电子邮件输入框**、**密码输入框**和**登录按钮**。
- en: 'If we right-click on each input and click on the **Inspect element** menu item,
    we will find the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们右键点击每个输入并点击**检查元素**菜单项，我们会找到以下内容：
- en: The email has the ID `email`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件的ID是`email`。
- en: The password has the ID `password`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码的ID是`password`。
- en: 'The login is a `button` element, with the `btn` and `btn-success` CSS classes,
    and the `style=" width: 100%;"` style.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '登录是一个具有`btn`和`btn-success`CSS类，以及`style=" width: 100%;"`样式的`button`元素。'
- en: Puppeteer provides two functions to get elements from the page. The `$(selector)`
    function will run the `document.querySelector` function and return the first element
    matching that selector or `null` if no elements were found. The `$$(selector)`
    function will run the `document.querySelectorAll` function, returning an array
    of elements matching the selector or an empty array if no elements were found.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer提供了两个从页面获取元素的功能。`$(selector)`函数将运行`document.querySelector`函数，并返回匹配该选择器的第一个元素，如果没有找到元素则返回`null`。`$$$(selector)`函数将运行`document.querySelectorAll`函数，返回匹配该选择器的元素数组，如果没有找到元素则返回空数组。
- en: 'If we want to implement the `login` function in our `LoginPageModel` class
    using these new functions, finding the login inputs would be easy:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在`LoginPageModel`类中使用这些新功能来实现`login`函数，查找登录输入将会很容易：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To find the login button, you might think that you could use the `btn-success`
    selector, and you could, but you shouldn't use classes used to style a button
    because they might change in the future if the development team changes the style.
    You should try to pick a CSS selector to overcome a design change.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到登录按钮，你可能认为你可以使用`btn-success`选择器，你确实可以，但你不应该使用用于样式化按钮的类，因为如果开发团队更改了样式，它们可能会在未来发生变化。你应该尝试选择一个CSS选择器来克服设计变化。
- en: Let's re-evaluate our login button. If you look for `button` elements, you will
    find that you have five buttons on that page, so the `button` selector won't work.
    But, we can see that the login button is the only button with a `type="submit"`
    attribute, so we could use the `[type=submit]` CSS selector to find this element.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新评估我们的登录按钮。如果您寻找`button`元素，您会发现您在该页面上有五个按钮，所以`button`选择器不起作用。但是，我们可以看到登录按钮是唯一具有`type="submit"`属性的按钮，因此我们可以使用`[type=submit]`CSS选择器来找到这个元素。
- en: 'But the `[type=submit]` selector is too generic. The developers might, for
    instance, add a new button with the `submit` type in the toolbar, breaking our
    code. But we can see that the login button is inside a form with the ID `login-form`.
    So now, we can create a more stable selector. So, we could look for the login
    button in our login function in this way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但`[type=submit]`选择器太通用。例如，开发者可能会在工具栏中添加一个具有`submit`类型的按钮，这会破坏我们的代码。但我们可以看到登录按钮位于ID为`login-form`的表单中。因此，现在我们可以创建一个更稳定的选择器。所以，我们可以在登录函数中这样查找登录按钮：
- en: '[PRE3]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we have everything we need to test our login page. But we are not going
    to interact with the login page yet. Let''s go to the home page and find some
    more complex scenarios:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了测试登录页面所需的一切。但我们不会立即与登录页面交互。让我们转到主页并找到一些更复杂的场景：
- en: '![Home Page'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![主页'
- en: '](img/Figure_4.9_B16113.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.9_B16113.jpg)'
- en: Home Page
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 主页
- en: Let's say we want to test that the **Macbook Pro 13.3' Retina MF841LL/A** product
    has 15 items left in stock, and the price is $1,199.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试**Macbook Pro 13.3' Retina MF841LL/A**产品库存剩余15件，价格为$1,199。
- en: 'First, a piece of advice: It''s better to code these kinds of tests down the
    testing pyramid. You could test the API that sends those values or the function
    that makes that query to the database.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一些建议：最好将这些测试代码放在测试金字塔的底层。您可以测试发送这些值的API或向数据库发出查询的函数。
- en: 'But let''s try to solve this as a UI test:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们尝试将其作为一个UI测试来解决这个问题：
- en: '![Product HTML'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![产品HTML'
- en: '](img/Figure_4.10_B16113.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B16113.jpg)'
- en: Product HTML
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 产品HTML
- en: If we take a look at the HTML, there is nothing that helps us find the product
    on the list, and if we were able to find the product, it's hard to find the elements
    inside that `div` element.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看HTML，没有东西能帮助我们找到列表中的产品，即使我们能够找到产品，也很难找到该`div`元素内部的元素。
- en: 'Here is where the collaboration between the development team and the QA team
    becomes valuable. How can developers help the QA team? Using data- attributes.
    Your team can use a `data-test-` attribute to help you find the elements you need:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是开发团队和QA团队之间协作变得有价值的地方。开发者如何帮助QA团队？使用data-属性。您的团队可以使用`data-test-`属性来帮助您找到所需的元素：
- en: '![HTML with data-test attributes'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![带有data-test属性的HTML'
- en: '](img/Figure_4.11_B16113.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B16113.jpg)'
- en: HTML with data-test attributes
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 带有data-test属性的HTML
- en: 'As you can see in this HTML, it will be way easier to find elements with those
    new attributes. This is how we can get the values to test product ID `2`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在HTML中看到的，使用这些新属性查找元素将容易得多。这就是我们如何获取测试产品ID `2`的值：
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With these four lines, we were able to find the three elements for our new
    test: The product container and the elements containing the stock and the price.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这四行代码，我们能够找到我们新测试所需的三个元素：产品容器以及包含库存和价格的元素。
- en: 'The are a few things to notice in this piece of code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，有几个需要注意的地方：
- en: First, remember not to hardcode values in your code. That's why we are going
    to grab the product ID from our config file.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，记住不要在代码中硬编码值。这就是为什么我们要从我们的配置文件中获取产品ID。
- en: Second, notice that we are getting `stockElement` and `priceElement` using `productDiv.$`
    instead of `page.$`. That means that *the CSS selector you pass to that function
    will be processed in the element's context*.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，请注意，我们使用`productDiv.$`而不是`page.$`来获取`stockElement`和`priceElement`。这意味着*传递给该函数的CSS选择器将在元素的上下文中进行处理*。
- en: If we'd used `page.$$('[data-test-stock]')`, we would get many elements because
    each product has a `data-test-stock` element, but as we use `productDiv.$('[data-test-stock]')`,
    we'll get the element inside `productDiv`. This is an important resource.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们使用`page.$$('[data-test-stock]')`，我们会得到许多元素，因为每个产品都有一个`data-test-stock`元素，但因为我们使用`productDiv.$('[data-test-stock]')`，我们将在`productDiv`内部得到元素。这是一个重要的资源。
- en: The last thing to highlight here is that our development team gave us the number
    of items in stock inside the `data-test-stock` element. This will come in handy
    when we need to test the stock but notice that we don't need to use the value
    of the attribute, in this case, 15, to get the element. Passing the attribute
    as a selector will be enough.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里要强调的最后一件事是，我们的开发团队给了我们 `data-test-stock` 元素中库存数量的信息。当我们需要测试库存时，这会很有用。但请注意，我们不需要使用属性的值，在这种情况下是
    15，来获取元素。传递属性作为选择器就足够了。
- en: What if we don't have the chance to add these attributes? There is one more
    resource – trying to find those elements using XPath.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有机会添加这些属性怎么办？还有一个资源——尝试使用 XPath 查找这些元素。
- en: Finding elements using XPath
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XPath 查找元素
- en: XPath is a language to query XML-like documents. Remember how we said that HTML
    was a relaxed kind of XML? This means that we could navigate through the DOM using
    some kind of XML query language such as XPath.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: XPath 是一种查询类似 XML 文档的语言。记得我们说过 HTML 是一种放松版的 XML 吗？这意味着我们可以使用某种 XML 查询语言，如 XPath，来遍历
    DOM。
- en: 'Before digging into XPath''s selectors, if you want to try XPath queries, Chrome
    DevTools includes a set of functions you can use inside the developer tools `$x`,
    which expects an XPath expression and returns an array of elements:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨 XPath 选择器之前，如果你想尝试 XPath 查询，Chrome DevTools 包含了一组可以在开发者工具中使用的函数 `$x`，它期望一个
    XPath 表达式并返回一个元素数组：
- en: '![Testing XPath inside the Chrome Developer Tools'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![在 Chrome 开发者工具中测试 XPath'
- en: '](img/Figure_4.12_B16113.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.12_B16113.jpg)'
- en: Testing XPath inside the Chrome Developer Tools
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 开发者工具中测试 XPath
- en: If you open the `$x('//*')` to test the `//*` selector.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `$x('//*')` 来测试 `//*` 选择器。
- en: To better understand an XPath expression, you need to see your HTML as XML content.
    We are going to navigate this XML document from the very same root, the HTML attribute.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 XPath 表达式，你需要将你的 HTML 视为 XML 内容。我们将从这个相同的根节点开始遍历这个 XML 文档，即 HTML 属性。
- en: Select from the current node
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从当前节点选择
- en: 'Selector: `//`. This means "From the current node, bring me everything inside,
    no matter the position."'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器：`//`。这意味着“从当前节点，给我所有内容，无论位置。”
- en: 'Example: `$x(''//div//a'')` will return, from the root, all the *divs* inside
    the document, no matter the position, and from those *divs* all `a` elements inside
    that `div`, no matter the position.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：`$x('//div//a')` 将会从根节点返回文档中所有的 `div` 元素，无论位置如何，以及那些 `div` 中的所有 `a` 元素，无论位置如何。
- en: Are you confused about the "no matter the position" part? Well, let's now see
    the root selector.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你对“无论位置”的部分感到困惑吗？好吧，现在让我们看看根选择器。
- en: Select from the root
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从根节点选择
- en: 'Selector: `/`. This means "From the current node, bring me all the direct child
    elements."'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器：`/`。这意味着“从当前节点，给我所有直接子元素。”
- en: 'Example: If we use `$x(''/div//a'')`, we''ll get no results because there is
    no `div` as a child of the root object. The only valid root option would be `$x(''/HTML'')`
    because the HTML element is the only one under the main root object. But we could
    do something such as `$x(''//div/a'')`, which would mean "Bring me all the `div`
    elements, and from there all the `a` elements that are a direct child of those
    *divs*."'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：如果我们使用 `$x('/div//a')`，我们将得到没有结果，因为没有 `div` 是根对象的子元素。唯一有效的根选项将是 `$x('/HTML')`，因为
    HTML 元素是唯一一个位于主要根对象下的元素。但我们可以做的是 `$x('//div/a')`，这意味着“给我所有 `div` 元素，并从那里获取那些 `div`
    的直接子元素 `a`。”
- en: Select all the elements
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择所有元素
- en: 'Selector: `*`. This means "Bring me all the elements."'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器：`*`。这意味着“给我所有元素。”
- en: 'Example: When we say "all the elements," it will be based on the previous selector.
    `$x(''/*'')` will bring only the HTML element because that would mean "all the
    direct elements." But `$x(''//*'')` will bring you all the elements from the page.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：当我们说“所有元素”时，它将基于前面的选择器。`$x('/*')` 将只会获取 HTML 元素，因为这表示“所有直接元素”。但 `$x('//*')`
    将会给你页面上所有的元素。
- en: Filter by attribute
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过属性过滤
- en: 'Selector: `[@attributeName=value]`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器：`[@attributeName=value]`。
- en: 'Example: `$x(''//div[@class="card-body"]'')` will bring all the `div` elements
    where the class attribute is equal to `card-body`. This might look similar to
    the class selector in CSS, but it''s not because this selector won''t work if
    `div` has more than one class.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：`$x('//div[@class="card-body"]')` 将会获取所有类属性等于 `card-body` 的 `div` 元素。这看起来可能和
    CSS 中的类选择器相似，但实际上并不相同，因为这个选择器在 `div` 有多个类时将不会工作。
- en: Up to this point, it seems just like CSS with another syntax. What's so powerful
    about XPath? Well, let's get to some power tools.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这似乎就像CSS，只是语法不同。XPath有什么如此强大的地方？好吧，让我们来看看一些强大的工具。
- en: It turns out that the syntax we used to filter attributes is, in fact, expressions,
    also called predicates. This gives us the chance to not only use the `@attributeName`
    option but to also check for many other things.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们用来过滤属性的语法是，实际上，是表达式，也称为谓词。这给了我们不仅使用`@attributeName`选项，还可以检查许多其他事情的机会。
- en: Filter by text
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过文本过滤
- en: 'Selector: `[text()=value]`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器：`[text()=value]`。
- en: 'Example: `$x(''//div[text()="Admin Panel (Testing purpose)"]'')` will bring
    all the `div` elements where its content is a the text *Admin Panel (Testing purpose)*.
    You could even make it more generic and use something like this, `$x(''//*[text()="Admin
    Panel (Testing purpose)"]'')`, so you wouldn''t care whether it''s a `div` or
    another type of element.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：`$x('//div[text()="Admin Panel (Testing purpose)"]')`将返回所有内容为文本*Admin Panel
    (Testing purpose)*的`div`元素。你甚至可以使其更通用，使用如下，`$x('//*[text()="Admin Panel (Testing
    purpose)"]')`，这样你就不必关心它是一个`div`还是其他类型的元素。
- en: This function is by far one of the main reasons you would see people using XPath.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是人们使用XPath的主要原因之一。
- en: Contains a text
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含文本
- en: 'Selector: `[contains(text(), value)]`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器：`[contains(text(), value)]`。
- en: 'Example: *Filter by text* can be tricky. The text could have some space before
    or after the content. If you try to select the grid button on the page using this
    command, `$x(''//*[text()= "Grid"]'')`, you won''t get any results because the
    element has some spaces after and before the word. This `contains` function can
    help us when we have spaces before or after the word, or when the word is part
    of a larger piece of text. This is how we can use this function: `$x(''//*[contains(text(),"Grid")]'')`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：*通过文本过滤*可能很棘手。文本可能在其内容前后有一些空格。如果你尝试使用此命令选择页面上的网格按钮，`$x('//*[text()= "Grid"]')`，你将不会得到任何结果，因为该元素在单词前后有一些空格。这个`contains`函数可以帮助我们在单词前后有空格，或者当单词是更大文本的一部分时。这就是我们如何使用此函数的方式：`$x('//*[contains(text(),"Grid")]')`。
- en: There are many more functions. Mozilla has a good list of all the available
    functions ([https://www.hardkoded.com/ui-testing-with-puppeteer/xpath](https://www.hardkoded.com/ui-testing-with-puppeteer/xpath)).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多更多的函数。Mozilla 列出了所有可用的函数列表（[https://www.hardkoded.com/ui-testing-with-puppeteer/xpath](https://www.hardkoded.com/ui-testing-with-puppeteer/xpath)）。
- en: 'We get to do really complex queries with XPath. Let''s take a look our last
    example. We want all the elements with a price over $2,000:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用XPath进行非常复杂的查询。让我们看看我们的最后一个例子。我们想要所有价格超过2,000美元的元素：
- en: '`$x(''//div[@class="row"]/p[1][number(substring-after(text(), "$")) > 2000]'')`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`$x(''//div[@class="row"]/p[1][number(substring-after(text(), "$")) > 2000]'')`'
- en: 'Wow, let''s see what we are doing there:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，让我们看看我们在做什么：
- en: With `//div[@class="row"]`, we grab `DIVs` with the `row` class.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`//div[@class="row"]`，我们获取具有`row`类的`DIVs`。
- en: With `p[1]`, we take the first `p` element. We can use positional filters here.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`p[1]`，我们获取第一个`p`元素。我们在这里可以使用位置过滤器。
- en: We get the text using `text()`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`text()`获取文本。
- en: As the price begins with a dollar sign, we remove it using `substring-after`.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于价格以美元符号开头，我们使用`substring-after`将其删除。
- en: We convert that text into a number using `number`.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`number`将文本转换为数字。
- en: So then, we can check whether that number is greater than 2,000.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，我们可以检查那个数字是否大于2,000。
- en: There is one more feature that makes XPath a powerful tool. Unlike CSS selectors,
    you can select the parent element with XPath using `..`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: XPath还有一个特性使其成为一个强大的工具。与CSS选择器不同，你可以使用`..`通过XPath选择父元素。
- en: 'If we want to return the entire main `div` of the product with a price over
    $2,000, we can use the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想返回价格超过2,000美元的产品整个主`div`，我们可以使用以下方法：
- en: '`$x(''//div[@class="row"]/p[1][number(substring-after(text(), "$")) > 2000]/../..'')`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`$x(''//div[@class="row"]/p[1][number(substring-after(text(), "$")) > 2000]/../..'')`'
- en: 'How do we use XPath expressions in Puppeteer? You already know how to do it:
    We have a `$x` function.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Puppeteer中使用XPath表达式？你已经知道了如何做：我们有一个`$x`函数。
- en: 'Let''s go back to our test: *We want to test that the Macbook Pro 13.3'' Retina
    MF841LL/A has 15 items left in stock, and the price is $1,199.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的测试：*我们想要测试Macbook Pro 13.3' Retina MF841LL/A库存剩余15件，价格是1,199美元*。
- en: 'What if the only way to find that product would be with the product name? We
    could do something like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果唯一找到该产品的方法是使用产品名称呢？我们可以这样做：
- en: '[PRE5]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Remember that `$x` returns an array of elements. In this case, as we know that
    they will always return one element, we take the first one.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `$x` 返回一个元素数组。在这种情况下，我们知道它们总是会返回一个元素，所以我们取第一个。
- en: 'In the same way, we shouldn''t rely on design classes for CSS selectors. We
    should try not to rely too much on the HTML structure in XPath selectors. We are
    assuming a couple of things in this code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们不应该过分依赖设计类来使用 CSS 选择器。我们应尽量避免在 XPath 选择器中过度依赖 HTML 结构。在这段代码中，我们假设了几件事情：
- en: We assume that the stock is an `h6` element.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们假设股票是一个 `h6` 元素。
- en: We assume that the price will be the first `p` element.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们假设价格将是第一个 `p` 元素。
- en: If the design team decides that the stock will look better using `div` instead
    of `h6`, if they wrapped the price inside a `div` element to improve mobile navigation,
    your test will break.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设计团队决定使用 `div` 而不是 `h6` 来使库存看起来更好，如果他们把价格包裹在一个 `div` 元素中以提高移动导航，那么你的测试将会失败。
- en: We learned how to get elements from the page, but it's important to know that
    the `$`, `$$`, and `$x` functions don't return an element from the DOM. They return
    something called **element handles**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何从页面获取元素，但重要的是要知道，`$`、`$$` 和 `$x` 函数并不返回 DOM 中的元素。它们返回称为 **元素句柄** 的东西。
- en: Element handles are a reference to a DOM element on the page. They are a pointer
    that helps Puppeteer send commands to the browser, referencing an existing DOM
    element. They are also one of the ways we have to interact with those elements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 元素句柄是对页面上的 DOM 元素的引用。它们是一个指针，帮助 Puppeteer 向浏览器发送命令，引用现有的 DOM 元素。它们也是我们与这些元素交互的几种方式之一。
- en: Interacting with Elements
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与元素交互
- en: 'Let''s go back to our login test. We already have the three elements we need:
    The user input, the password input, and the login button. Now we need to enter
    the email and the password and click on the button.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的登录测试。我们已经有了需要的三个元素：用户输入、密码输入和登录按钮。现在我们需要输入电子邮件和密码，然后点击按钮。
- en: Typing on input elements
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在输入元素上输入
- en: The `ElementHandle` class has a function called `type`. The signature is `type(text,
    [options])`. The `options` class is not big this time. It only has a `delay` property.
    The delay is the number of milliseconds Puppeteer will wait between letters. This
    is great to emulate real user interaction.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementHandle` 类有一个名为 `type` 的函数。其签名是 `type(text, [options])`。这次 `options`
    类并不大。它只有一个 `delay` 属性。延迟是 Puppeteer 在字母之间等待的毫秒数。这对于模拟真实用户交互非常有用。'
- en: 'The first part of our test would look like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试的第一部分看起来是这样的：
- en: '[PRE6]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are looking for the email and password elements, and then emulating
    a user typing on those inputs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在寻找电子邮件和密码元素，然后模拟用户在这些输入上输入。
- en: Now, we need to click on the button.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要点击按钮。
- en: Clicking on elements
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击元素
- en: 'The `ElementHandle` class also has a function called `click`. I bet you are
    already getting the pattern. The signature is `click([options])`. You can simply
    call `click()`, and that would do the job. But we can also use the three available
    options:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementHandle` 类还有一个名为 `click` 的函数。我敢打赌你已经明白了这个模式。其签名是 `click([options])`。你可以简单地调用
    `click()`，这样就能完成任务。但我们也可以使用三种可用的选项：'
- en: '`button`: This is a string with three valid options: "left," "right," or "middle."'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`button`：这是一个包含三个有效选项的字符串：“left”、“right”或“middle”。'
- en: '`clickCount`: The default is `1`, but you could also have an impatient user
    clicking the same button many times, so you can emulate the user clicking on the
    element four times by passing `4`.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clickCount`：默认值为 `1`，但你也可以模拟一个没有耐心的用户多次点击同一个按钮，所以你可以通过传递 `4` 来模拟用户点击元素四次。'
- en: '`delay`: This delay is not the time between clicks but the time (in milliseconds)
    between the mouse down action and mouse up.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`：这个延迟不是点击之间的时间，而是鼠标按下动作和鼠标抬起之间的时间（以毫秒为单位）。'
- en: 'In our case, we don''t need to use these options:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们不需要使用这些选项：
- en: '[PRE7]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With these two lines, we can finally finish our `login` function. We find the
    login button and then we click on it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两行代码，我们终于完成了我们的 `login` 函数。我们找到了登录按钮，然后点击它。
- en: Selecting options in drop-down lists
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在下拉列表中选择选项
- en: 'The site now has a drop-down list, a `SELECT` element in HTML, to switch between
    the grid and the list view:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个网站有一个下拉列表，一个 HTML 中的 `SELECT` 元素，用于在网格视图和列表视图之间切换：
- en: '![The site with a new switch option'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![The site with a new switch option](img/Figure_4.13_B16113.jpg)'
- en: '](img/Figure_4.13_B16113.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![The site with a new switch option](img/Figure_4.13_B16113.jpg)'
- en: The site with a new switch option
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 带有新开关选项的网站
- en: As you might have guessed, the function to select an option is called `select`,
    and the signature is `select(…values)`. It's a list of values if the `select`
    element has the `multiple` attribute.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，选择选项的函数被称为`select`，其签名是`select(…values)`。如果`select`元素有`multiple`属性，它是一个值列表。
- en: 'The next thing we need to know about this function is that the value `select`
    expects is not the text you see in the `option`, but the `option` of the value.
    We can see that by inspecting the element:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解的下一个关于这个函数的信息是，`select`期望的值不是你在`option`中看到的文本，而是值的`option`。我们可以通过检查元素来看到这一点：
- en: '![Drop-down list options'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![下拉列表选项'
- en: '](img/Figure_4.14_B16113.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.14_B16113.jpg](img/Figure_4.14_B16113.jpg)'
- en: Drop-down list options
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉列表选项
- en: In this case, we are lucky as the value is almost the same as the visible text,
    but it's not the same. If we want to select the Grid item, we need to use `grid`,
    instead of `Grid`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们很幸运，因为值几乎与可见文本相同，但并不完全相同。如果我们想选择网格项，我们需要使用`grid`，而不是`Grid`。
- en: 'If we switch the `option` to list mode, we can see that a `list-group-item`
    class is added to the elements:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`option`切换到列表模式，我们可以看到元素被添加了`list-group-item`类：
- en: '![HTML in list mode'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![列表模式下的HTML'
- en: '](img/Figure_4.15_B16113.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.15_B16113.jpg](img/Figure_4.15_B16113.jpg)'
- en: HTML in list mode
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模式下的HTML
- en: 'This is how we can test this functionality:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以测试这个功能的方法：
- en: '[PRE8]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using `await` and `page.$` every time we need to interact with an element requires
    a lot of boilerplate. Imagine if we had eight inputs to fill; that would be a
    lot. That's why both `Page` and `Frame` (if you are dealing with child frames)
    have most of the functions an element handle has, but they expect a selector as
    a first argument.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们需要与元素交互时都使用`await`和`page.$`需要很多样板代码。想象一下，如果我们有八个输入要填写，那会很多。这就是为什么`Page`和`Frame`（如果你正在处理子框架）都有大多数元素处理函数，但它们期望一个选择器作为第一个参数。
- en: 'So, say we have this piece of code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设我们有一段这样的代码：
- en: '[PRE9]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It could be as simple as this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能就像这样简单：
- en: '[PRE10]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You will find functions such as `page.click(selector, [options])`, `page.type(selector,
    text, [options])`, and many other interaction functions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现诸如`page.click(selector, [options])`、`page.type(selector, text, [options])`以及许多其他交互函数。
- en: We have covered the most common user interactions. But we can go a little deeper
    and try to emulate how the user would interact with the page using their keyboard
    and mouse.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了最常见的用户交互。但我们可以更进一步，尝试模拟用户如何使用键盘和鼠标与页面交互。
- en: Keyboard and Mouse emulation
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘和鼠标模拟
- en: 'Although you will be able to test the most common scenarios by typing or clicking
    on elements, there are other scenarios where you would need to emulate how the
    users interact with a site using the keyboard and the mouse. Let''s take, for
    instance, a Google spreadsheet:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你将能够通过输入或点击元素来测试最常见的场景，但还有一些其他场景，你需要模拟用户如何使用键盘和鼠标与网站交互。让我们以Google电子表格为例：
- en: '![Google Spreadsheet'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![Google电子表格'
- en: '](img/Figure_4.16_B16113.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.16_B16113.jpg](img/Figure_4.16_B16113.jpg)'
- en: Google Spreadsheet
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Google电子表格
- en: The Google spreadsheet page has a lot of keyboard and mouse interactions. You
    can move through the cells using your keyboard arrows or copy values by doing
    drag and drop with the mouse.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Google电子表格页面有很多键盘和鼠标交互。你可以使用键盘箭头在单元格间移动，或者通过鼠标拖放来复制值。
- en: But it doesn't need to be that complicated. Let's say that you work in the QA
    team at [GitHub.com](http://GitHub.com), and you need to test the search box from
    the home page.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不必那么复杂。假设你在GitHub.com（http://GitHub.com）的QA团队工作，并且你需要测试主页上的搜索框。
- en: 'As [GitHub.com](http://GitHub.com) is for developers, and developers for some
    weird reason hate using the mouse, the development team added many shortcuts on
    the site. We want to create a test to check that those shortcuts are working as
    expected:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GitHub.com是为开发者设计的，而开发者出于某种奇怪的原因讨厌使用鼠标，开发团队在网站上添加了许多快捷键。我们想要创建一个测试来检查这些快捷键是否按预期工作：
- en: '![GitHub.com home page'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![GitHub.com首页'
- en: '](img/Figure_4.17_B16113.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.17_B16113.jpg](img/Figure_4.17_B16113.jpg)'
- en: GitHub.com home page
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub.com首页
- en: 'As we can see there, the shortcut to the search input is a **/**. So, we need
    to do the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，搜索输入的快捷键是**/**。因此，我们需要做以下操作：
- en: Press slash.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下斜杠。
- en: Type the repo name.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入仓库名称。
- en: And then press *Enter*.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后按*Enter*。
- en: We are going to use the `Keyboard` class that the `Page` class exposes as a
    property.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Page`类公开的`Keyboard`类作为属性。
- en: The first step is to press slash. To do that, we are going to use, you guessed
    it, the `press` function. The signature is `press(key, options)`. The first thing
    we need to know about press is that it's a shortcut to two other functions – `down(key,
    options)` and `up(key)`. As you can see, you can get an almost complete keyboard
    emulation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是按下斜杠。为了做到这一点，我们将使用，你猜对了，`press`函数。该函数的签名是`press(key, options)`。关于`press`的第一个需要了解的事情是，它是对两个其他函数的快捷方式——`down(key,
    options)`和`up(key)`。正如你所见，你可以得到几乎完整的键盘模拟。
- en: 'Notice that the first argument is not `text` but `key`. You will find the full
    list of supported keys here: [https://www.hardkoded.com/ui-testing-with-puppeteer/USKeyboardLayout](https://www.hardkoded.com/ui-testing-with-puppeteer/USKeyboardLayout).
    There, you will find keys such as *Enter*, *Backspace*, or *Shift*. The `press`
    function has two options available: First, if you assign the `text` property,
    Puppeteer will create an input event with that value. It would work like a macro.
    For instance, if the key is `p` and the text is `puppeteer`, when you would press
    `p`, you would get `puppeteer` in the input element. I''ve never found a usage
    for that argument, but it''s there. The `down` function also has this option.
    The second option is `delay`, which is the time between the key down and the key
    up actions.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个参数不是`text`而是`key`。你可以在这里找到支持的完整键列表：[https://www.hardkoded.com/ui-testing-with-puppeteer/USKeyboardLayout](https://www.hardkoded.com/ui-testing-with-puppeteer/USKeyboardLayout)。在那里，你可以找到诸如*Enter*、*Backspace*或*Shift*之类的键。`press`函数有两个可用选项：首先，如果你分配了`text`属性，Puppeteer将创建一个具有该值的输入事件。它将像宏一样工作。例如，如果键是`p`且文本是`puppeteer`，当你按下`p`时，你将在输入元素中得到`puppeteer`。我从未找到这个参数的用法，但它确实存在。`down`函数也有这个选项。第二个选项是`delay`，它是键按下和键释放动作之间的时间。
- en: 'The official Puppeteer documentation ([https://www.hardkoded.com/ui-testing-with-puppeteer/keyboard](https://www.hardkoded.com/ui-testing-with-puppeteer/keyboard))
    has a perfect example for this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Puppeteer文档([https://www.hardkoded.com/ui-testing-with-puppeteer/keyboard](https://www.hardkoded.com/ui-testing-with-puppeteer/keyboard))有一个完美的例子：
- en: '[PRE11]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s unpack this code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这段代码：
- en: It types **Hello World!**. The cursor is after the exclamation mark.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它输入**Hello World!**。光标在感叹号之后。
- en: It presses the left arrow key. Remember, `press` is `key down` and `key up`.
    So now the cursor is before the exclamation mark.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它按下左箭头键。记住，`press`是`key down`和`key up`。所以现在光标在感叹号之前。
- en: Then, using `down`, it presses the *Shift* key, but it doesn't release the key.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用`down`，它按下*Shift*键，但并没有释放这个键。
- en: Then, it presses the left key as many times for the cursor to get to after the
    "Hello" word. But as the *Shift* key is still pressed, the "World" text got selected.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它多次按下左键，使光标到达“Hello”单词之后。但由于*Shift*键仍然被按下，“World”文本被选中。
- en: Then, it releases the *Shift* key, using `up`.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它使用`up`释放了*Shift*键。
- en: And what happens when you press *backspace* and we have text selected? You remove
    the entire selection, leaving the text **Hello!**.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你按下*退格*键并且有文本被选中时，会发生什么？你将移除整个选择，留下文本**Hello!**。
- en: 'Now we can go and test the [GitHub.com](http://GitHub.com) home page:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以去测试[GitHub.com](http://GitHub.com)的主页：
- en: '[PRE12]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we go back to our login example, we could test that you should be able to
    log in by pressing *Enter* instead of clicking on the login button. Or if the
    navigation between controls is important, you can jump from the user input to
    the password and then to the login button by pressing *Tab*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的登录示例，我们可以测试通过按下*Enter*而不是点击登录按钮来登录。或者，如果控件之间的导航很重要，你可以通过按下*Tab*从用户输入跳转到密码，然后到登录按钮。
- en: Do you want to play tic-tac-toe? Let's play it using the mouse.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你想玩井字棋吗？让我们用鼠标来玩。
- en: 'In the `Chapter4` folder, you will find a `tictactoe.html` file with a small
    tic-tac-toe game made in **React**:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter4`文件夹中，你会找到一个`tictactoe.html`文件，其中包含一个用**React**制作的简单的井字棋游戏：
- en: '![Tic-tac-toe game'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![井字棋游戏'
- en: '](img/Figure_4.18_B16113.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.18_B16113.jpg)'
- en: Tic-tac-toe game
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋游戏
- en: If we consider the page as a canvas, where the top-left corner of the window
    is the coordinate **(0;0)** and the bottom right is the coordinate **(window width,
    window height)**, mouse interaction is about moving the mouse to an **(X;Y)**
    coordinate and clicking using one of the mouse buttons. Puppeteer offers the following
    functionalities.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将页面视为一个画布，其中窗口的左上角是坐标**(0;0**)，而右下角是坐标**(窗口宽度, 窗口高度**)，那么鼠标交互就是将鼠标移动到**(X;Y**)坐标并使用鼠标按钮之一进行点击。Puppeteer提供了以下功能。
- en: Move the mouse using `mouse.move(x, y, [options])`. The only option available
    in this `move` function is `steps`. With `steps`, you can tell Puppeteer how many
    times you want to send `mousemove` events to the page. By default, it will send
    only one event at the end of the mouse move action.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mouse.move(x, y, [options])` 移动鼠标。这个 `move` 函数中可用的唯一选项是 `steps`。使用 `steps`，你可以告诉
    Puppeteer 你希望向页面发送多少次 `mousemove` 事件。默认情况下，它将在鼠标移动动作结束时发送一个事件。
- en: In the same way as with the keyboard you have the `up`/`down` and `press` functions,
    with the mouse, you have `up`/`down` and `click`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 就像键盘一样，你有 `up`/`down` 和 `press` 函数，对于鼠标，你有 `up`/`down` 和 `click`。
- en: 'The mouse has one extra action that the keyboard doesn''t have, which is `wheel`.
    You can emulate mouse scrolling using `mouse.wheel([options])`. This option has
    two properties: `deltaX` and `deltaY`, which can be positive or negative scroll
    values expressed in CSS pixels.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标有一个键盘没有的额外动作，那就是 `wheel`。你可以使用 `mouse.wheel([options])` 来模拟鼠标滚动。这个选项有两个属性：`deltaX`
    和 `deltaY`，它们可以是正数或负数，表示 CSS 像素中的滚动值。
- en: 'Let''s go back to our tic-tac-toe game. We will do a simple test: Player 1
    will use the first row and player 2 will use the second row, so player 1 will
    win after three moves. As this is a canvas, we need to know which coordinates
    we need to click.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的井字棋游戏。我们将进行一个简单的测试：玩家1将使用第一行，玩家2将使用第二行，所以玩家1将在三步之后获胜。由于这是一个画布，我们需要知道哪些坐标需要点击。
- en: 'We can use the style section of the developer tools to get those coordinates.
    If we look at the body, we will see a 20-pixel margin that will make `(20;20)`
    the starting point:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用开发者工具的样式部分来获取这些坐标。如果我们查看 body，我们会看到一个 20 像素的边距，这将使 `(20;20)` 成为起点：
- en: '![Body margin'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![Body margin'
- en: '](img/Figure_4.19_B16113.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.19_B16113.jpg)'
- en: Body margin
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Body margin
- en: 'We also know that each square is 32 px by 32 px, so the middle of the square
    should be *delta + (32 / 2)*. Let''s test it:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道每个方块是 32 像素 x 32 像素，所以方块的中间应该是 *delta + (32 / 2)*。让我们测试一下：
- en: '[PRE13]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, here we know that the *tic-tac-toe* grid starts at the coordinate (`20`,`20`),
    and from there is simple math to find the right coordinates in our canvas. The
    first box will be clicked at the coordinate (`startingX + boxMiddle; startingY
    + boxMiddle`). If we want to click on the second row, it would be three middle
    squares, `startingX + boxMiddle * 3`, and so on until we know that we have a winner.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道井字棋网格从坐标 (`20`,`20`) 开始，从这里我们可以通过简单的数学计算找到画布中的正确坐标。第一个框将在坐标 (`startingX
    + boxMiddle; startingY + boxMiddle`) 处点击。如果我们想点击第二行，将是三个中间方块，`startingX + boxMiddle
    * 3`，以此类推，直到我们知道我们有一个赢家。
- en: Don't worry about the last `$eval`. We'll get there.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心最后的 `$eval`。我们很快就会到达那里。
- en: 'But this is not just for games. Many modern UIs might require some mouse interactions,
    for instance, hoverable dropdowns or menus. We can see one example on the *W3Schools*
    site ([https://www.w3schools.com/howto/howto_css_dropdown.asp](https://www.w3schools.com/howto/howto_css_dropdown.asp)):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不仅仅适用于游戏。许多现代 UI 可能需要一些鼠标交互，例如，可悬停下拉菜单或菜单。我们可以在 *W3Schools* 网站上看到一个例子 ([https://www.w3schools.com/howto/howto_css_dropdown.asp](https://www.w3schools.com/howto/howto_css_dropdown.asp))：
- en: '![Hoverable dropdown'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![可悬停下拉菜单'
- en: '](img/Figure_4.20_B16113.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.20_B16113.jpg)'
- en: Hoverable dropdown
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可悬停下拉菜单
- en: 'To be able to click on any item in that dropdown, we need to hover first on
    the button and then link on the option:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够点击下拉菜单中的任何项目，我们首先需要将鼠标悬停在按钮上，然后链接到选项：
- en: '[PRE14]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we don't need to guess the `boundingBox`, which returns the
    position (*x* and *y*) and the element's size (width and height).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不需要猜测 `boundingBox`，它返回位置 (*x* 和 *y*) 以及元素的大小（宽度和高）。
- en: Is there an easier way? Yes, we can simply use `await btn.hover()`, which would
    hover on the element. I wanted to give you a complete example because sometimes
    UI components are quite sensitive to the mouse position, so you need to put the
    mouse in a precise location to get the desired result.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有更简单的方法？是的，我们可以简单地使用 `await btn.hover()`，这将悬停在元素上。我想给你一个完整的例子，因为有时 UI 组件对鼠标位置非常敏感，所以你需要将鼠标放在精确的位置才能得到期望的结果。
- en: Time for a bonus track. Let's talk about debugging.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行一个附加环节了。让我们谈谈调试。
- en: Debugging tests with Visual Studio Code
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 进行调试测试
- en: Many developers consider debugging a last resort. Others would flood their code
    with `console.log` messages. I consider debugging a productivity tool.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为调试是最后的手段。其他人会在他们的代码中充满 `console.log` 消息。我认为调试是一个生产力工具。
- en: '*Debugging is trying to find bugs by running an application step by step.*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试是通过逐步运行应用程序来尝试找到错误的过程。*'
- en: 'We have two ways of launching our tests in debug mode. The first option is
    creating a **JavaScript debug terminal** from the **Terminal** tab. That will
    create a new terminal as we did before, but in this case, Visual Studio will enable
    the debugger when you run a command from that terminal:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种在调试模式下启动测试的方法。第一种选项是从 **终端** 标签创建一个 **JavaScript 调试终端**。这将创建一个新的终端，就像我们之前做的那样，但在这个情况下，当你从该终端运行命令时，Visual
    Studio 将启用调试器：
- en: '![Debugging from the terminal'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![从终端进行调试'
- en: '](img/Figure_4.21_B16113.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.21_B16113.jpg)'
- en: Debugging from the terminal
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端进行调试
- en: 'The second option is going to the `launch.json` file. You could also create
    that file manually inside the `.vscode` folder:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选项是转到 `launch.json` 文件。你也可以在 `.vscode` 文件夹内手动创建该文件：
- en: '![Create a launch.json from the run tab'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![从运行标签创建 launch.json'
- en: '](img/Figure_4.22_B16113.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.22_B16113.jpg)'
- en: Create a launch.json from the run tab
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 从运行标签创建 launch.json
- en: 'Once we have the file, we can create a new configuration so that we can run
    `npm run test` in the terminal:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了文件，我们就可以创建一个新的配置，这样我们就可以在终端中运行 `npm run test`：
- en: '[PRE15]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Which one is the best? Well, if you will work on this project for many days,
    creating the `launch.json` file is more productive; once created, you just need
    to hit *F5*, and you would be in debug mode. The terminal option is easier just
    to get running.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 哪一个最好？嗯，如果你将在这个项目上工作很多天，创建 `launch.json` 文件会更有效率；一旦创建，你只需按 *F5*，就会进入调试模式。终端选项只是更容易启动。
- en: 'Once you have everything set up, it is about creating **breakpoints** in the
    line you want the debugger to stop, and from there it is about taking advantage
    of all the tools Visual Studio Code offers:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置好了一切，就是创建你想要调试器停止的行的 **断点**，然后就是利用 Visual Studio Code 提供的所有工具：
- en: '![Visual Studio Code in debugging mode'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![Visual Studio Code 调试模式'
- en: '](img/Figure_4.23_B16113.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.23_B16113.jpg)'
- en: Visual Studio Code in debugging mode
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 调试模式
- en: 'There you will find the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，你会找到以下内容：
- en: At the left of the line numbers, you will find the breakpoints. You can create
    or remove breakpoints by clicking at the left of the line number.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行号左侧，你会找到断点。你可以通过点击行号左侧来创建或删除断点。
- en: You will find the full list of breakpoints at the bottom left of the window.
    From there, you will be able to disable breakpoints temporarily.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在窗口的左下角找到完整的断点列表。从那里，你可以暂时禁用断点。
- en: 'At the top right of the window, you will find debug actions: Pause, play, step
    in/out, and stop buttons.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在窗口的右上角，你会找到调试操作：暂停、播放、进入/退出和停止按钮。
- en: 'In the left panel, you will find two useful sections: Variables, where you
    can automatically get the values of all the variables in the current scope. The
    next panel is Watch, and you can add there the variables or expressions you want
    to look at while running your code.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧面板中，你会找到两个有用的部分：变量，你可以自动获取当前作用域中所有变量的值。下一个面板是观察，你可以添加你想要在运行代码时查看的变量或表达式。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was massive. We began the chapter with a brief but complete introduction
    to HTML, the DOM, and CSS. These concepts are crucial to create top-notch tests.
    Then, we learned a lot about XPath, which is not a very popular tool, yet it is
    extremely powerful and will help you face scenarios where CSS selectors are not
    enough.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章内容很多。我们以对 HTML、DOM 和 CSS 的简要但完整的介绍开始这一章。这些概念对于创建高质量的测试至关重要。然后，我们学习了大量的 XPath，虽然它不是一个非常流行的工具，但它非常强大，将帮助你面对
    CSS 选择器不足的情况。
- en: In the second part of this chapter, we went through the most common ways to
    interact with a page. Not only did we learn how to interact with elements but
    we also covered keyboard and mouse emulation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们介绍了与页面交互的最常见方法。我们不仅学习了如何与元素交互，还涵盖了键盘和鼠标模拟。
- en: I hope you enjoyed the tools section. Debugging with Visual Studio Code is a
    great tool to add to your toolbox.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢工具部分。使用 Visual Studio Code 进行调试是添加到你的工具箱中的好工具。
- en: In the next chapter, we are going to wait for stuff. Things take time on the
    web. Pages take time to load. Some actions on the page might trigger network calls.
    The next chapter is important because you will learn how to make your tests even
    more stable.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将等待一些事情。在网络上，事情需要时间。页面需要时间加载。页面上的某些操作可能会触发网络调用。下一章很重要，因为你将学习如何让你的测试更加稳定。
