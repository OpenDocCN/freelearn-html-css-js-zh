- en: Unleashing the Power of Type with Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用对象释放类型的力量
- en: TypeScript can be overwhelming with all the different objects. In this chapter,
    we illustrate the difference between an `object`, `Object`, `object literal`,
    and an object built with a constructor. This chapter also discusses the notion
    of a union between types that will allow an infinite combination of types for
    a single value. Furthermore, the concept of an intersection looms, giving the
    possibility of manipulating type differently. At the end of this chapter, the
    reader will be able to create complex combinations of objects that hold advanced
    structures. We will dissect how to create a dictionary with a strongly typed index
    signature, understand how type can be beneficial with a map, and learn how to
    use the right object to be as accurate as possible when defining an object that
    can have a broad reach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中有众多不同的对象，可能会让人感到不知所措。在本章中，我们将阐述 `object`、`Object`、`object literal`
    以及通过构造函数构建的对象之间的区别。本章还讨论了类型联合的概念，这将允许单个值有无限种类型的组合。此外，交集的概念也浮现出来，它为不同地操作类型提供了可能性。在本章结束时，读者将能够创建包含复杂结构的对象组合。我们将剖析如何创建具有强类型索引签名的字典，理解类型如何通过映射带来益处，以及如何使用正确的对象在定义具有广泛适用性的对象时尽可能准确。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: How to strongly type a set/dictionary with an index signature
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用索引签名将集合/字典强类型化
- en: TypeScript and map
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 与映射
- en: The difference between an index signature and a map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引签名与映射的区别
- en: The difference between `object` and `Object`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object` 与 `Object` 的区别'
- en: When to use `object`, `Object`, or any
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用 `object`、`Object` 或任何
- en: What is an `object literal`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 `object literal`
- en: How to create a constructed object
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个构造对象
- en: The difference between an explicit type or a cast
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式类型或转换的区别
- en: Variable with many types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多类型变量
- en: Combining a type with an intersection
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型与交集结合
- en: Intersecting with something other than a type
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与非类型相交
- en: Intersecting with an optional type
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与可选类型相交
- en: Merging a type with inheritance
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型与继承合并
- en: The difference between a type and an interface
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型与接口的区别
- en: Destructuring a type and an array
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构类型和数组
- en: Tuple
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: The difference between declare and `let`/`const`/`var`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declare` 与 `let`/`const`/`var` 的区别'
- en: How to strongly type a set/dictionary with an index signature
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用索引签名将集合/字典强类型化
- en: 'Besides an array, a *set* or a *dictionary* is a common structure to store
    unstructured data for quick access. In JavaScript, using the dynamic notion of
    being able to assign a member to an object creates a dictionary. Each object''s
    property becomes a key of the dictionary. TypeScript''s types above this pattern
    with *index signature*. It allows you to specify the type of the key (between
    number and string) and any type of values:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数组之外，*集合* 或 *字典* 是一种常见的结构，用于存储无结构数据以便快速访问。在 JavaScript 中，使用能够将成员分配给对象的动态概念创建字典。每个对象的属性成为字典的键。TypeScript
    在此模式之上引入了 *索引签名*。它允许你指定键的类型（在数字和字符串之间）以及任何类型的值：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Writing into the dictionary is as simple as using the square bracket and assigning
    the value that must respect the right side of the definition. In the following
    code example, the key and the value are strings:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典写入就像使用方括号并分配必须遵守定义右侧的值一样简单。在下面的代码示例中，键和值都是字符串：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'An index signature can be tricky because of historical reasons. For example,
    if the index is defined to accept a string as the key, you will be able to pass
    a string and a number as well. The other way around is not true: a key with a
    number type does not accept a string:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 索引签名可能因为历史原因而变得复杂。例如，如果索引被定义为接受字符串作为键，你将能够传递字符串和数字。反之则不成立：数字类型的键不接受字符串：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The last example illustrates more than a single issue with the type of key.
    The code uses a syntax to define a value for an index signature directly by using
    an `object literal` where all members are the keys and their value the index signature's
    value. This is the syntax to use to initialize default value, while the other
    way, with square brackets, is the way to add dynamically and access value rapidly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例展示了关于键类型的多个问题。代码使用一种语法，通过使用所有成员都是键且其值是索引签名值的 `object literal` 直接定义索引签名的值。这是初始化默认值的语法，而另一种方式，即使用方括号，是动态添加和快速访问值的方式。
- en: 'Additionally, TypeScript allows you to access a member of an object with a
    square bracket by providing the name of the member as a string. The distinction
    with index signature is that TypeScript won''t let you read or add a member if
    the index signature is not provided in your definition:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，TypeScript 允许你通过提供成员名称作为字符串来使用方括号访问对象的成员。与索引签名的区别在于，TypeScript 不允许你在定义中没有提供索引签名的情况下读取或添加成员：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another quirk with index signature is when it is combined with an object that
    has other members. The key of the index signature can be only of a string with
    members returning a string. It means that most of the time you will have to fall
    back with a key of a number. The following code does not compile:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 索引签名的一个奇怪之处在于，当它与具有其他成员的对象结合时。索引签名的键只能是一个字符串，其成员返回一个字符串。这意味着在大多数情况下，你将不得不退回到使用数字键。以下代码无法编译：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By contrast, the following code compiles but is fragile. The reason it compiles
    is that in some very rare cases, TypeScript automatically converts types back
    to a string, depending on its usage. In that case, the `number` and `Date` of
    the member `count` and `when` is accepted to be a string. However, a tiny change
    of adding a member that has an object will disrupt that rule. The two following
    blocks of code illustrate that change. This following block contains a primitive:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以下代码可以编译，但很脆弱。它之所以可以编译，是因为在某些非常罕见的情况下，TypeScript 会根据其用法自动将类型转换回字符串。在这种情况下，成员
    `count` 和 `when` 的 `number` 和 `Date` 被接受为字符串。然而，添加一个具有对象的成员的微小变化将破坏这一规则。以下两个代码块说明了这种变化。这个后续块包含了一个原始值：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This second block contains an additional object that is not allowed when an
    index signature is defined:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个后续块包含了一个在定义索引签名时不允许的额外对象：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another compilation issue you might have is to add a string key to an object
    with an index signature that has a key to a number:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的另一个编译问题是向具有数字键的索引签名的对象添加一个字符串键：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can transform the object definition by providing a member of a type number
    with a value of a string:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供一个具有字符串值的数字类型的成员来转换对象定义：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, if you want to have a string as a key you will need to change the
    type allowed as a value in your index signature to have a union of every member:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想有一个字符串作为键，你将需要将你的索引签名中允许的值类型更改为每个成员的联合：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To conclude with index signature, it is wise to have your mapping object small
    and without too many members, to allow having an index signature that can be accessed
    without requiring to narrow the type. For example, the last code example was returning
    a string or a number or a date. This means that every access to the object is
    required to check the type before consuming its properties. However, having an
    interface that has only the index signature can be used as a property of an object
    and have all the quick access without needing to narrow down. Here is the code
    that illustrates the pattern:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结索引签名，明智的做法是使你的映射对象小且成员不多，以便能够访问一个无需缩小类型的索引签名。例如，最后一个代码示例返回一个字符串、一个数字或一个日期。这意味着每次访问对象时，都需要在消费其属性之前检查其类型。然而，具有仅索引签名的接口可以用作对象的属性，并具有所有快速访问，而无需缩小。以下代码演示了这种模式：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: TypeScript and map
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 和映射
- en: We discussed creating a dictionary/set with the index signature that leverages
    the flexibility of an object. An alternative is the use of a `map` class. A `map`
    is a class that can be instantiated with or without values, and it is a type of
    object that is not unique to TypeScript. ECMAScript defines how a map is structured
    and behaves; TypeScript is providing a type on top of the class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用索引签名创建字典/集合，该索引签名利用了对象的灵活性。另一种选择是使用 `map` 类。`map` 是一个可以带或不带值实例化的类，它是一种在
    TypeScript 中不独特的对象类型。ECMAScript 定义了映射的结构和行为；TypeScript 在类之上提供了类型。
- en: 'A map has the same capability of fast access than index signature. The following
    code instantiates the `Map` with two key-values entries. The key and the value
    can be anything. What is important in the constructor is when providing a value,
    this one must be iterable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个映射具有与索引签名相同的快速访问能力。以下代码使用两个键值条目实例化了 `Map`。键和值可以是任何东西。在构造函数中重要的是，当提供值时，这个值必须是可迭代的：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous code not only created a map but also accessed a value by using
    a key of the same type as defined in the constructor. If a key does not exist
    in the map, an undefined value is returned, similar to the index signature. The
    next code example creates two maps, without providing initial values. The first
    one doesn''t use the generic definition; hence, falls back to the type `any` for
    the key and the value. However, the second line shows an initialization that specifies
    the generic type to have a key of string and a value of a number. Even if the
    map does not have values specified at the initialization, the latter still provides
    a strongly typed enforcement for a future value set by the function set:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code does not compile because the key type must be the same.
    In the code example, it has a number and a string:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A map has many functions other than get. It can *set* values, which is handy
    when you do not have all the values of the creation of the map. A map can also
    look up to see whether a key exists in the map by returning `true` or `false`.
    Finally, it is possible to remove an entry with a function instead of relying
    on the `delete` keyword for an index signature:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The differences between index signature and a map
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The differences between using a map or an index signature pattern with an object
    are slim. Here are two lists of the pros of each structure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**Object**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Can have more than just a key-value. It can have functions and other members.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object coming from JSON is automatically compatible with an index signature,
    while a map would require a manual mapping.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object pattern is faster at accessing data than the map, and uses less memory
    for a small set of data and a medium set of data. This is true with Chrome, but
    benchmarks are not consistent among browsers, as well as the overall size of the
    map/object.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Map**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: A map performs better when many add and delete. It uses a hashing function underneath.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It preserves the order when an element is added. This might be an advantage,
    since a map is naturally iterable.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A map performs better with a large set of data.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A map's key is not limited to a number or a string for a key.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between object and Object
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many object types in TypeScript. There is `Object`, `object`, `class
    object`, and `object literal`. In this section, we will cover the differences
    between an `Object` (uppercase) and an `object` (lowercase).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Object` type that starts with a capital letter, or the uppercase one,
    or with the big *O* represents something ubiquitous, a cross type that is available
    with every type and object. The capital letter Object carries a common set of
    functions. Here is the list of its available functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A huge set of types comes under the umbrella of `Object`. Assigning several
    different values to an object of type `Object` shows the flexibility of the type
    and how broad the potential range of types is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The lowercase object coverts everything that is not a number, a string, a `boolean`,
    a `null`, an `undefined`, or a `Symbol`. The lowercase `object` is a subset of
    the uppercase `Object`. It contains `object literals`, dates, functions, arrays,
    and an instance of an object created with `new` and `create`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the cases of `null` and `undefined`, they are neither `object` nor `Object`.
    They are in a special category and are a subtype of all other types. TypeScript''s
    compiler must be configured with the strict option `"strictNullCheck"`, which
    is the de-factor configuration value, meaning that even if `null` and `undefined`
    are a subset of all types, only a union of the main type and `null` or `undefined`
    will allow the assignation to either of these two special values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When to use object, Object, or any
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which type of object to use is a sub-question of the previous one that was discussing
    the differences between `object`, `Object`, and `any`. The rule of thumb is to
    always use the more conscribe type. It means to avoid using both `object` and
    `Object` as much as possible. However, in a case where you need to cover a wider
    range of types and you cannot define them with a union, the use of `object` is
    better if you do not need a primitive, because it has less potential values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `object` and `Object` are better than `any` because `any` allows accessing
    any members of any type while `object` will limit you to the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you do not know the type and need to take an object, you should use an `object`
    (lowercase) if you are not allowing a primitive. You should fallback to `Object`
    (uppercase) if you support a primitive and in the last resort use `any`. However,
    a better potential approach is, if possible, to use a generic type that allows
    avoiding doing a type check and casting, which is often a pitfall of using something
    such as `object` and `Object`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: What is an object literal?
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `object literal` is an `object` created with curly brackets. An `object literal`
    is an `Object` and an `object`. You can define the type for an `object literal`
    with `type` or `interface`. It is a quick way to have data in a structure that
    is typed. The `object literal` inherits from `Object` (uppercase).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can do a quick test with four functions and see that the `object literal`
    is accepted in all of the functions, even if the parameter''s type is different
    among all the function''s signature:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Two (or more) objects that literally have the same structure are interchangeable.
    You can define an object literal and set it in a variable that defines the same
    structure in the interface. You can also do the same if the type is anonymous
    or inferred. Here are the four ways to create a typed `object literal`. They are
    all assignable to one another because they share the same structure. This is a
    strength of TypeScript, as it is a structural language, as opposed to a nominal
    language:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to create a constructed object
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, a class object is an object defined with the keyword `class` and instantiated
    with the keyword `new`. Every class can be instantiated more than once. Every
    instantiation starts with the use of `new`, and every value set in an object remains
    in that object, with the exception of static fields, which are shared across every
    instance of the same class. We will see many features of object-oriented and object
    in a later chapter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，类对象是通过关键字`class`定义并通过关键字`new`实例化的对象。每个类都可以被实例化多次。每次实例化都始于`new`的使用，并且对象中设置的每个值都保留在该对象中，除了静态字段，这些字段在相同类的每个实例之间共享。我们将在后面的章节中看到面向对象和对象的一些特性：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The creation of the class calls the constructor. In the previous code example,
    the `console.log` will be called during the instantiation of the class into an
    object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类的调用会调用构造函数。在之前的代码示例中，`console.log`将在类实例化为对象时被调用。
- en: The differences between an explicit type and a cast
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式类型和类型转换之间的区别
- en: 'If you have an interface that you want to build, you can set the variable type
    with the colon and specify the fields. If a field misses TypeScript will not compile;
    if there is more than the definition, TypeScript won''t compile:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要构建一个接口，你可以使用冒号设置变量类型并指定字段。如果一个字段缺失，TypeScript将不会编译；如果定义的内容过多，TypeScript也不会编译：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another way is to avoid specifying the type after the colon and use `as` to
    cast:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是不在冒号后指定类型，而是使用`as`进行类型转换：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The issue is that cast coerces TypeScript to believe the object is the type
    specified even if it does not respect the contract. Casting should never be used
    to define a variable. The reason is that even if the contract is respected initially,
    if the object changes, the cast will still force the type assignation, but the
    object will not with the right structure. The following two lines compile but
    are invalid in term of logic. The first one has an additional member that is not
    in the interface, and the second line is missing one field:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于类型转换会强制TypeScript相信对象是指定的类型，即使它不遵守契约。类型转换永远不应该用来定义变量。原因是即使最初遵守契约，如果对象发生变化，转换仍然会强制类型分配，但对象的结构不会正确。以下两行代码可以编译，但在逻辑上是不合法的。第一行有一个不在接口中的额外成员，而第二行缺失了一个字段：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Variable with many types
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多类型变量
- en: 'In many situations, a variable requires having more than one field. For example,
    you can have a field that only takes a value among a few strings:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，一个变量需要拥有多个字段。例如，你可以有一个只接受几个字符串值的字段：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The creation of a type with the keyword `type` is not required but allows reusability
    of the type. The first example was creating a type with many allowed strings.
    A variable declared with the new type will only accept the strings from the list.
    However, most of the time, unions are using a more complex type, such as between
    the interface, type and primitive:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字`type`创建类型不是必需的，但允许类型的重用。第一个例子是创建一个允许多个字符串的类型。使用新类型声明的变量将只接受列表中的字符串。然而，大多数情况下，联合使用更复杂类型，例如接口、类型和原始类型之间的联合：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A function can take a union type as a parameter and return a return type as
    well. A union is often used to accept a type as well as `undefined`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受联合类型作为参数，也可以返回返回类型。联合通常用于接受类型以及`undefined`：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When using a union, only the common fields are accessible. In the following
    code, `TypeA` has two fields, `a` and `b`, and `TypeB` has `b` and `c`. The only
    common field is `b`, which means that it is the only available and accessible
    field in the function. This is true until we narrow down the type to one of a
    type in the union. We will see how type narrowing works later:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用联合时，只有共同的字段是可访问的。在以下代码中，`TypeA`有两个字段，`a`和`b`，而`TypeB`有`b`和`c`。唯一的共同字段是`b`，这意味着它是函数中唯一可用和可访问的字段。这直到我们将类型缩小到联合中的一个类型才会成立。我们将在后面看到类型缩小是如何工作的：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Combining type with intersect
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类型与交集结合
- en: 'The more you build types, the more you will need a feature to work with them.
    The intersect feature is one tool in TypeScript''s toolbox that lets you merge
    types together. The intersection symbol is the ampersand (`&`). The following
    code example shows that we are creating a third type with the combination of two
    interfaces. The common fields become one, and the difference adds up:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的类型越多，你就越需要一个功能来处理它们。交集功能是TypeScript工具箱中的一个工具，它允许你合并类型。交集符号是`&`。以下代码示例显示我们正在通过两个接口的组合创建第三个类型。共同的字段合并为一个，差异累加：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is possible to intersect generic and primitive as well. The latter is less
    used, since it is almost not pragmatic. However, the former (generic) is helpful
    to merge a custom type into a defined contract:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以相交泛型和原始类型。后者较少使用，因为它几乎不实用。然而，前者（泛型）有助于将自定义类型合并到定义的契约中：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The order of the types in the intersection does not matter. Two types created
    here are exactly the same:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 相交中类型的顺序并不重要。这里创建的两个类型完全相同：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, even if they are the same, with the same value, each initialization
    creates a unique object, meaning that comparing them will be false. Regarding
    comparing two identical types with different names, they are both of type `Object`
    and the reason is that `typeOf` is a JavaScript operator and the type is removed
    at run-time; hence, it behaves the same way at design time. To compare type we
    need a discriminator that we will discuss later:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使它们相同，具有相同的值，每次初始化都会创建一个独特的对象，这意味着比较它们将会是错误的。关于比较具有不同名称的相同类型，它们都是`Object`类型，原因是`typeOf`是JavaScript运算符，类型在运行时被移除；因此，它在设计时表现相同。要比较类型，我们需要一个将在后面讨论的判别器：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The use of parentheses does not affect the declaration of the type. The following
    code is redundant, with the union being useless. Here are four different types
    that take the same value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 括号的使用不会影响类型的声明。以下代码是多余的，因为联合是无用的。这里有四种不同的类型，它们具有相同的值：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Intersecting with something other than a type
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与非类型相交
- en: 'It is possible to intersect with a type, primitive, and an interface. Intersecting
    with primitive is useless, since a number cannot be a boolean at the same time.
    However, intersecting an interface is valid as much as intersecting with a type.
    The same rules apply for a type or an interface, with regard to intersecting:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以与类型、原始类型和接口相交。与原始类型相交是没有用的，因为一个数字不能同时是布尔值。然而，与接口相交与与类型相交一样有效。对于类型或接口，关于相交的规则是相同的：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'While the most common case of intersection touches type and interface, it is
    possible to intersect classes. Intersection with classes are rare and it creates
    a type that cannot be instantiated. Only the public fields are extracted from
    each class to create a field:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然相交最常见的案例是类型和接口，但也可以相交类。与类的相交很少见，它创建了一个不能实例化的类型。只从每个类中提取公共字段来创建字段：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Intersecting with an optional type
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与可选类型相交
- en: 'It is possible to intersect two types with cross properties that have different
    rules. A field in one type with the mention of an option member can be merged
    with a type that is not optional. The result is that the field becomes non-optional:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以相交两个具有不同规则的交叉属性的类型。一个类型中的一个字段提到了可选成员，可以与一个非可选的类型合并。结果是该字段变为非可选：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The previous code example shows the intersection and the field `m1` being required.
    If omitted or set to undefined, the code does not compile.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例显示了相交和字段`m1`是必需的。如果省略或设置为`undefined`，则代码无法编译。
- en: Merge type with inheritance
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用继承合并类型
- en: 'It is possible to merge two types if these ones are an interface or a class,
    by using `extends`. Extending an interface with another is an alternative to using
    the ampersand. In the following code example, the merged interface contains its
    own member, as well as the member of `InterfaceA` and `InterfaceB`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些类型是接口或类，则可以使用`extends`合并两个类型。使用另一个接口扩展一个接口是使用连字符的替代方案。在下面的代码示例中，合并的接口包含其自身的成员，以及`InterfaceA`和`InterfaceB`的成员：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The differences between type and interface
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型与接口之间的差异
- en: Type and interface are not exactly the same. For example, you can merge two
    interfaces together, but you cannot merge an interface with a primitive, which
    can be done with a type. You can define an interface in many definitions allowed
    future extension outside the main module. The possibility to enhance an interface
    in many areas allow many plugins or contract versioning patterns to happen. The
    technical jargon for this feature is **open-ended:**
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类型与接口并不完全相同。例如，你可以合并两个接口，但不能将接口与原始类型合并，这可以通过类型完成。你可以在许多允许未来扩展外部主模块的定义中定义一个接口。在许多领域增强接口的可能性允许许多插件或合同版本化模式发生。这个功能的术语是**开放的**：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A class can extend a type or an interface. The latter is often more seen because
    type carries some caveat. For example, a type that contains a primitive won''t
    be a sound choice for a class because the implementation will not work. TypeScript
    is smart enough to analyze the content of the type and figure out that the implementation
    cannot occur:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以扩展一个类型或一个接口。后者更常见，因为类型有一些注意事项。例如，包含原始值的类型不会是一个好的类选择，因为实现将不会工作。TypeScript足够智能，可以分析类型的内
    容并确定实现无法发生：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Type and interface can have an index signature:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 类型和接口可以有索引签名：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The rule of thumb is to rely on an interface as much as possible because of
    the open-ended feature, the reduction of confusion regarding whether the type
    can have primitive, and because they can be extended or intersected. The `type`
    keyword is used to create a union of primitive or to intersect object literals
    on the fly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 常规做法是尽可能依赖接口，因为其开放性特征，减少了关于类型是否可以具有原始值的混淆，并且因为它们可以被扩展或交叉。`type`关键字用于创建原始值的联合，或动态交叉对象字面量。
- en: Destructuring a type and an array
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构类型和数组
- en: Destructuring is a feature of JavaScript that is supported by TypeScript with
    type protection. Destructuring breaks an object into different pieces. TypeScript
    brings the type to these pieces.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是JavaScript的一个特性，TypeScript通过类型保护支持它。解构将对象分解成不同的部分。TypeScript将这些类型带到这些部分。
- en: 'A scenario is that you need to extract members from an object into a variable.
    This can be done without destructuring, but it takes several lines of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一种情况是你需要将对象成员提取到变量中。这可以不使用解构来完成，但需要几行代码：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With destructuring, it can be done in a single line. All the variables are
    from the type of the object. It means that `id` is a new variable of type number,
    `name` is of the type string, as well as `category`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解构，可以在一行内完成。所有变量都是对象的类型。这意味着`id`是类型为number的新变量，`name`是类型为string，同样`category`：
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Destructuring can use the rest operator to take the remainder of the properties
    not specified. The rest of the syntax is the three dots before the name of the
    variable that will hold the rest of the members:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 解构可以使用剩余操作符来获取未指定的属性剩余部分。剩余的语法是变量名之前的三点，该变量将持有剩余成员：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, the variable `remainingMember` has three members that are the
    three members not explicitly called out before the rest. It means that the type
    of `remainingMember` is an object literal with a member `startTime`, `stopTime` and
    `time` of `type Date`, `Date`, and `number`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，变量`remainingMember`有三个成员，这是在其余部分之前没有明确指出的三个成员。这意味着`remainingMember`的类型是一个具有`startTime`、`stopTime`和`time`成员的对象字面量，它们的类型分别是`Date`、`Date`和`number`。
- en: 'Destructuring and rest also work with an array. You can specify a variable
    name that will be of the type of the array. The rest allows creating a new array
    with the remainder of the value with the type of the initial array. In the following
    code example, the `value1` contains the number `1` (not a string but as a number).
    The `value2` contains `2`, and `value3To9` is an array with the values `3`, `4`,
    `5`, `6`, `7`, `8`, and `9`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 解构和剩余参数也可以与数组一起使用。你可以指定一个变量名，它的类型将是数组的类型。剩余参数允许创建一个新的数组，该数组包含具有初始数组类型的值的剩余部分。在下面的代码示例中，`value1`包含数字`1`（不是字符串，而是作为数字），`value2`包含`2`，而`value3To9`是一个包含值`3`、`4`、`5`、`6`、`7`、`8`和`9`的数组：
- en: '[PRE46]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It is also possible to skip position by using a comma without specifying a
    variable. In the following code example, there is a space between ` value_1` and
    `value_2`, which means that the value at the second position, which is `2`, is
    not in any individual variable (`value1` or `value2`), neither is in the variable
    `value4To9`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用逗号而不指定变量来跳过位置。在下面的代码示例中，`value_1`和`value_2`之间有一个空格，这意味着第二个位置的值`2`既不在任何单个变量（`value1`或`value2`）中，也不在变量`value4To9`中：
- en: '[PRE47]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tuple
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'A **tuple** is an alternative to an object to hold multiple values within a
    single variable. Often used to move information around by function, it leverages
    an array to carry different types. The assignation with a tuple is done by setting
    the desired value in a specific index of an array, which the consumer must know
    to retrieve the pertinent information. In JavaScript, the usage of an array is
    sufficient. However, doing so in TypeScript leads to a weak type. The following
    code shows that TypeScript will infer the type to be an array of number or string,
    which can make sense but not when the code wants to be strongly typed. The reason
    is that an array can be a number or type at any position of the array, while in
    a tuple situation we want to have a specific type for each position in the array:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**元组**是对象的一种替代方案，可以在单个变量中存储多个值。通常用于通过函数传递信息，它利用数组来携带不同类型。使用元组进行赋值是通过在数组的特定索引处设置所需值来完成的，消费者必须知道以检索相关信息。在JavaScript中，使用数组是足够的。然而，在TypeScript中这样做会导致弱类型。以下代码显示TypeScript将推断类型为数字或字符串的数组，这在某些情况下是有意义的，但不符合代码想要强类型的要求。原因是数组可以在数组的任何位置是数字或类型，而在元组的情况下，我们希望数组中的每个位置都有特定的类型：'
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To overcome the array inference, we need to specify the type for each position.
    However, even if a tuple is more specific than an array with multiple types because
    of the specification by the index of the type, this one still is not as safe as
    using an object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服数组推断，我们需要为每个位置指定类型。然而，即使元组由于通过索引指定类型而比具有多个类型的数组更具体，但这仍然不如使用对象安全：
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The previous code illustrates that during instantiation, there is a validation
    of type as well as a validation of size. It means that when assigning values,
    you must respect the type and the number of expected values. However, the last
    line of the code shows the nature of the array surface, and regardless of the
    fact that the tuple declaration specifies three positions, it is possible to add
    any type at any position after the ones defined. In the code example, the three
    first positions (index `0`, `1`, and `2`) are strongly typed but position four
    and above can be anything. Nevertheless, changing a value, with the square brackets,
    will validate the type:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码说明了在实例化过程中，既有类型的验证也有大小的验证。这意味着在赋值时，你必须尊重预期的类型和值的数量。然而，代码的最后一行显示了数组表面的本质，并且无论元组声明指定了三个位置，都可以在定义的位置之后添加任何类型的值。在代码示例中，前三个位置（索引`0`、`1`和`2`）是强类型的，但位置四及以上可以是任何类型。尽管如此，使用方括号更改值时，将验证类型：
- en: '[PRE50]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Tuple supports spread operator to deconstruct a function parameter into several
    variables. The following code example shows that a single tuple argument can be
    spread. The function `restFunction` is the equivalent of the `resultFunction`.
    The code example shows that it is possible to pass a tuple but not an array:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 元组支持扩展操作符，可以将函数参数解构为多个变量。以下代码示例显示单个元组参数可以被展开。函数`restFunction`与`resultFunction`等价。代码示例显示可以传递一个元组但不能传递一个数组：
- en: '[PRE51]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Tuple supports optional. The syntax is similar to a function with optional
    parameters or a type with optional members. Positions without value are automatically
    set to `undefined`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 元组支持可选参数。语法类似于具有可选参数的函数或具有可选成员的类型。没有值的位自动设置为`undefined`：
- en: '[PRE52]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The previous declaration is similar to the following, where optional position
    can be set to `undefined` as well:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的声明类似于以下声明，其中可选位置也可以设置为`undefined`：
- en: '[PRE53]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Setting the tuple definition in a type can be advantageous when a tuple is
    reused in several places. The syntax is identical to when defining a type with
    the keyword type:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个地方重用元组时，在类型中设置元组定义可能是有利的。语法与使用关键字`type`定义类型时相同：
- en: '[PRE54]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In conclusion, the tuple is a convenient way to pass information in a function
    and also to quickly return more than one value. However, a better alternative
    is to define a quick interface with the member desired. Not only does it not rely
    on position, but it can be reused in many situations easily by allowing extension
    and intersection. Furthermore, an object is easier to read because the assignation
    and the readability rely on a name instead of a number.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，元组是传递函数信息以及快速返回多个值的便捷方式。然而，一个更好的选择是定义一个带有所需成员的快速接口。这不仅不依赖于位置，而且可以通过允许扩展和交集在许多情况下轻松重用。此外，对象更容易阅读，因为赋值和可读性依赖于名称而不是数字。
- en: The differences between declare and let/const/var
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`declare`与`let`/`const`/`var`之间的区别'
- en: 'It is possible to use `declare` instead of one of the three declarators `let`,`const`,
    and `var`. However, `declare` won''t generate any JavaScript code during compilation
    and must be used in conjunction with `let`, `const` or `var`. The role of `declare`
    is to indicate to TypeScript''s compiler that the variable exists but is defined
    somewhere else:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能使用`declare`代替三个声明符之一`let`、`const`或`var`。然而，`declare`在编译期间不会生成任何JavaScript代码，并且必须与`let`、`const`或`var`一起使用。`declare`的作用是向TypeScript编译器指示变量存在，但定义在别处：
- en: '[PRE55]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The main role of `declare` is when signatures need to be defined. The use of
    `declare` in a definition file makes sense because it is only defining the type
    and not actually declaring the variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare`的主要作用是在需要定义签名时。在定义文件中使用`declare`是有意义的，因为它只定义类型，实际上并没有声明变量。'
- en: '`declare` can be used to declare a module. Declaring a module is used to write
    a definition file outside the actual implementation of the code, which is written
    in JavaScript or TypeScript:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare`可以用来声明一个模块。声明一个模块用于在JavaScript或TypeScript的实际代码实现之外编写定义文件：'
- en: '[PRE56]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed many ways that generic information can be stored
    with the concept of many objects. We demystified the difference between the uppercase
    and lowercase object with an object literal and an instantiated object. We clarified
    two different structures to hold quick access data with index signature and map.
    The chapter continued with how to manipulate several types with a union and an
    intersection. Finally, we saw how to destruct, and how declare is different than
    the three previous declarations mentioned in [Chapter 2](aeb84a25-e8a4-48bf-a056-76d0e060f727.xhtml),
    *Onboarding Types with Primitive*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多使用多个对象的概念来存储泛型信息的方法。我们通过对象字面量和实例化对象来消除了大写和小写对象之间的差异。我们澄清了使用索引签名和映射来存储快速访问数据的两种不同结构。章节继续讨论了如何使用联合和交集来操作几种类型。最后，我们看到了如何解构，以及`declare`与[第2章](aeb84a25-e8a4-48bf-a056-76d0e060f727.xhtml)中提到的三种先前声明（*使用原始类型进行类型注册*）的不同之处。
- en: In the next chapter, we will see how to work with `object-oriented`. The next
    chapter covers how to use inheritance, encapsulation, and static function. The
    notions of interface and how to define a constructor signature in an interface
    will be explained. The next chapter dives into the powerful world of `object-oriented`
    in TypeScript.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何与`面向对象`编程一起工作。下一章涵盖了如何使用继承、封装和静态函数。接口的概念以及如何在接口中定义构造函数签名将会被解释。下一章将深入TypeScript中强大的`面向对象`世界。
