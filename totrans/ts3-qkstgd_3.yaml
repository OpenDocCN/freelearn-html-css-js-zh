- en: Unleashing the Power of Type with Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript can be overwhelming with all the different objects. In this chapter,
    we illustrate the difference between an `object`, `Object`, `object literal`,
    and an object built with a constructor. This chapter also discusses the notion
    of a union between types that will allow an infinite combination of types for
    a single value. Furthermore, the concept of an intersection looms, giving the
    possibility of manipulating type differently. At the end of this chapter, the
    reader will be able to create complex combinations of objects that hold advanced
    structures. We will dissect how to create a dictionary with a strongly typed index
    signature, understand how type can be beneficial with a map, and learn how to
    use the right object to be as accurate as possible when defining an object that
    can have a broad reach.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to strongly type a set/dictionary with an index signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript and map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between an index signature and a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between `object` and `Object`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use `object`, `Object`, or any
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an `object literal`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a constructed object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between an explicit type or a cast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable with many types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining a type with an intersection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intersecting with something other than a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intersecting with an optional type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging a type with inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between a type and an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring a type and an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between declare and `let`/`const`/`var`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to strongly type a set/dictionary with an index signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides an array, a *set* or a *dictionary* is a common structure to store
    unstructured data for quick access. In JavaScript, using the dynamic notion of
    being able to assign a member to an object creates a dictionary. Each object''s
    property becomes a key of the dictionary. TypeScript''s types above this pattern
    with *index signature*. It allows you to specify the type of the key (between
    number and string) and any type of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing into the dictionary is as simple as using the square bracket and assigning
    the value that must respect the right side of the definition. In the following
    code example, the key and the value are strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'An index signature can be tricky because of historical reasons. For example,
    if the index is defined to accept a string as the key, you will be able to pass
    a string and a number as well. The other way around is not true: a key with a
    number type does not accept a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The last example illustrates more than a single issue with the type of key.
    The code uses a syntax to define a value for an index signature directly by using
    an `object literal` where all members are the keys and their value the index signature's
    value. This is the syntax to use to initialize default value, while the other
    way, with square brackets, is the way to add dynamically and access value rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, TypeScript allows you to access a member of an object with a
    square bracket by providing the name of the member as a string. The distinction
    with index signature is that TypeScript won''t let you read or add a member if
    the index signature is not provided in your definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another quirk with index signature is when it is combined with an object that
    has other members. The key of the index signature can be only of a string with
    members returning a string. It means that most of the time you will have to fall
    back with a key of a number. The following code does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, the following code compiles but is fragile. The reason it compiles
    is that in some very rare cases, TypeScript automatically converts types back
    to a string, depending on its usage. In that case, the `number` and `Date` of
    the member `count` and `when` is accepted to be a string. However, a tiny change
    of adding a member that has an object will disrupt that rule. The two following
    blocks of code illustrate that change. This following block contains a primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This second block contains an additional object that is not allowed when an
    index signature is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another compilation issue you might have is to add a string key to an object
    with an index signature that has a key to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can transform the object definition by providing a member of a type number
    with a value of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want to have a string as a key you will need to change the
    type allowed as a value in your index signature to have a union of every member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To conclude with index signature, it is wise to have your mapping object small
    and without too many members, to allow having an index signature that can be accessed
    without requiring to narrow the type. For example, the last code example was returning
    a string or a number or a date. This means that every access to the object is
    required to check the type before consuming its properties. However, having an
    interface that has only the index signature can be used as a property of an object
    and have all the quick access without needing to narrow down. Here is the code
    that illustrates the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript and map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed creating a dictionary/set with the index signature that leverages
    the flexibility of an object. An alternative is the use of a `map` class. A `map`
    is a class that can be instantiated with or without values, and it is a type of
    object that is not unique to TypeScript. ECMAScript defines how a map is structured
    and behaves; TypeScript is providing a type on top of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A map has the same capability of fast access than index signature. The following
    code instantiates the `Map` with two key-values entries. The key and the value
    can be anything. What is important in the constructor is when providing a value,
    this one must be iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code not only created a map but also accessed a value by using
    a key of the same type as defined in the constructor. If a key does not exist
    in the map, an undefined value is returned, similar to the index signature. The
    next code example creates two maps, without providing initial values. The first
    one doesn''t use the generic definition; hence, falls back to the type `any` for
    the key and the value. However, the second line shows an initialization that specifies
    the generic type to have a key of string and a value of a number. Even if the
    map does not have values specified at the initialization, the latter still provides
    a strongly typed enforcement for a future value set by the function set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code does not compile because the key type must be the same.
    In the code example, it has a number and a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A map has many functions other than get. It can *set* values, which is handy
    when you do not have all the values of the creation of the map. A map can also
    look up to see whether a key exists in the map by returning `true` or `false`.
    Finally, it is possible to remove an entry with a function instead of relying
    on the `delete` keyword for an index signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The differences between index signature and a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The differences between using a map or an index signature pattern with an object
    are slim. Here are two lists of the pros of each structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object**:'
  prefs: []
  type: TYPE_NORMAL
- en: Can have more than just a key-value. It can have functions and other members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object coming from JSON is automatically compatible with an index signature,
    while a map would require a manual mapping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object pattern is faster at accessing data than the map, and uses less memory
    for a small set of data and a medium set of data. This is true with Chrome, but
    benchmarks are not consistent among browsers, as well as the overall size of the
    map/object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Map**:'
  prefs: []
  type: TYPE_NORMAL
- en: A map performs better when many add and delete. It uses a hashing function underneath.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It preserves the order when an element is added. This might be an advantage,
    since a map is naturally iterable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A map performs better with a large set of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A map's key is not limited to a number or a string for a key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between object and Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many object types in TypeScript. There is `Object`, `object`, `class
    object`, and `object literal`. In this section, we will cover the differences
    between an `Object` (uppercase) and an `object` (lowercase).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Object` type that starts with a capital letter, or the uppercase one,
    or with the big *O* represents something ubiquitous, a cross type that is available
    with every type and object. The capital letter Object carries a common set of
    functions. Here is the list of its available functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A huge set of types comes under the umbrella of `Object`. Assigning several
    different values to an object of type `Object` shows the flexibility of the type
    and how broad the potential range of types is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The lowercase object coverts everything that is not a number, a string, a `boolean`,
    a `null`, an `undefined`, or a `Symbol`. The lowercase `object` is a subset of
    the uppercase `Object`. It contains `object literals`, dates, functions, arrays,
    and an instance of an object created with `new` and `create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the cases of `null` and `undefined`, they are neither `object` nor `Object`.
    They are in a special category and are a subtype of all other types. TypeScript''s
    compiler must be configured with the strict option `"strictNullCheck"`, which
    is the de-factor configuration value, meaning that even if `null` and `undefined`
    are a subset of all types, only a union of the main type and `null` or `undefined`
    will allow the assignation to either of these two special values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When to use object, Object, or any
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which type of object to use is a sub-question of the previous one that was discussing
    the differences between `object`, `Object`, and `any`. The rule of thumb is to
    always use the more conscribe type. It means to avoid using both `object` and
    `Object` as much as possible. However, in a case where you need to cover a wider
    range of types and you cannot define them with a union, the use of `object` is
    better if you do not need a primitive, because it has less potential values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `object` and `Object` are better than `any` because `any` allows accessing
    any members of any type while `object` will limit you to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you do not know the type and need to take an object, you should use an `object`
    (lowercase) if you are not allowing a primitive. You should fallback to `Object`
    (uppercase) if you support a primitive and in the last resort use `any`. However,
    a better potential approach is, if possible, to use a generic type that allows
    avoiding doing a type check and casting, which is often a pitfall of using something
    such as `object` and `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: What is an object literal?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `object literal` is an `object` created with curly brackets. An `object literal`
    is an `Object` and an `object`. You can define the type for an `object literal`
    with `type` or `interface`. It is a quick way to have data in a structure that
    is typed. The `object literal` inherits from `Object` (uppercase).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do a quick test with four functions and see that the `object literal`
    is accepted in all of the functions, even if the parameter''s type is different
    among all the function''s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Two (or more) objects that literally have the same structure are interchangeable.
    You can define an object literal and set it in a variable that defines the same
    structure in the interface. You can also do the same if the type is anonymous
    or inferred. Here are the four ways to create a typed `object literal`. They are
    all assignable to one another because they share the same structure. This is a
    strength of TypeScript, as it is a structural language, as opposed to a nominal
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to create a constructed object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, a class object is an object defined with the keyword `class` and instantiated
    with the keyword `new`. Every class can be instantiated more than once. Every
    instantiation starts with the use of `new`, and every value set in an object remains
    in that object, with the exception of static fields, which are shared across every
    instance of the same class. We will see many features of object-oriented and object
    in a later chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The creation of the class calls the constructor. In the previous code example,
    the `console.log` will be called during the instantiation of the class into an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The differences between an explicit type and a cast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have an interface that you want to build, you can set the variable type
    with the colon and specify the fields. If a field misses TypeScript will not compile;
    if there is more than the definition, TypeScript won''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to avoid specifying the type after the colon and use `as` to
    cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue is that cast coerces TypeScript to believe the object is the type
    specified even if it does not respect the contract. Casting should never be used
    to define a variable. The reason is that even if the contract is respected initially,
    if the object changes, the cast will still force the type assignation, but the
    object will not with the right structure. The following two lines compile but
    are invalid in term of logic. The first one has an additional member that is not
    in the interface, and the second line is missing one field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Variable with many types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many situations, a variable requires having more than one field. For example,
    you can have a field that only takes a value among a few strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation of a type with the keyword `type` is not required but allows reusability
    of the type. The first example was creating a type with many allowed strings.
    A variable declared with the new type will only accept the strings from the list.
    However, most of the time, unions are using a more complex type, such as between
    the interface, type and primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A function can take a union type as a parameter and return a return type as
    well. A union is often used to accept a type as well as `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When using a union, only the common fields are accessible. In the following
    code, `TypeA` has two fields, `a` and `b`, and `TypeB` has `b` and `c`. The only
    common field is `b`, which means that it is the only available and accessible
    field in the function. This is true until we narrow down the type to one of a
    type in the union. We will see how type narrowing works later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Combining type with intersect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The more you build types, the more you will need a feature to work with them.
    The intersect feature is one tool in TypeScript''s toolbox that lets you merge
    types together. The intersection symbol is the ampersand (`&`). The following
    code example shows that we are creating a third type with the combination of two
    interfaces. The common fields become one, and the difference adds up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to intersect generic and primitive as well. The latter is less
    used, since it is almost not pragmatic. However, the former (generic) is helpful
    to merge a custom type into a defined contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of the types in the intersection does not matter. Two types created
    here are exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, even if they are the same, with the same value, each initialization
    creates a unique object, meaning that comparing them will be false. Regarding
    comparing two identical types with different names, they are both of type `Object`
    and the reason is that `typeOf` is a JavaScript operator and the type is removed
    at run-time; hence, it behaves the same way at design time. To compare type we
    need a discriminator that we will discuss later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of parentheses does not affect the declaration of the type. The following
    code is redundant, with the union being useless. Here are four different types
    that take the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Intersecting with something other than a type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to intersect with a type, primitive, and an interface. Intersecting
    with primitive is useless, since a number cannot be a boolean at the same time.
    However, intersecting an interface is valid as much as intersecting with a type.
    The same rules apply for a type or an interface, with regard to intersecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'While the most common case of intersection touches type and interface, it is
    possible to intersect classes. Intersection with classes are rare and it creates
    a type that cannot be instantiated. Only the public fields are extracted from
    each class to create a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Intersecting with an optional type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to intersect two types with cross properties that have different
    rules. A field in one type with the mention of an option member can be merged
    with a type that is not optional. The result is that the field becomes non-optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example shows the intersection and the field `m1` being required.
    If omitted or set to undefined, the code does not compile.
  prefs: []
  type: TYPE_NORMAL
- en: Merge type with inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to merge two types if these ones are an interface or a class,
    by using `extends`. Extending an interface with another is an alternative to using
    the ampersand. In the following code example, the merged interface contains its
    own member, as well as the member of `InterfaceA` and `InterfaceB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The differences between type and interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type and interface are not exactly the same. For example, you can merge two
    interfaces together, but you cannot merge an interface with a primitive, which
    can be done with a type. You can define an interface in many definitions allowed
    future extension outside the main module. The possibility to enhance an interface
    in many areas allow many plugins or contract versioning patterns to happen. The
    technical jargon for this feature is **open-ended:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A class can extend a type or an interface. The latter is often more seen because
    type carries some caveat. For example, a type that contains a primitive won''t
    be a sound choice for a class because the implementation will not work. TypeScript
    is smart enough to analyze the content of the type and figure out that the implementation
    cannot occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Type and interface can have an index signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The rule of thumb is to rely on an interface as much as possible because of
    the open-ended feature, the reduction of confusion regarding whether the type
    can have primitive, and because they can be extended or intersected. The `type`
    keyword is used to create a union of primitive or to intersect object literals
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring a type and an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Destructuring is a feature of JavaScript that is supported by TypeScript with
    type protection. Destructuring breaks an object into different pieces. TypeScript
    brings the type to these pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'A scenario is that you need to extract members from an object into a variable.
    This can be done without destructuring, but it takes several lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With destructuring, it can be done in a single line. All the variables are
    from the type of the object. It means that `id` is a new variable of type number,
    `name` is of the type string, as well as `category`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructuring can use the rest operator to take the remainder of the properties
    not specified. The rest of the syntax is the three dots before the name of the
    variable that will hold the rest of the members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the variable `remainingMember` has three members that are the
    three members not explicitly called out before the rest. It means that the type
    of `remainingMember` is an object literal with a member `startTime`, `stopTime` and
    `time` of `type Date`, `Date`, and `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructuring and rest also work with an array. You can specify a variable
    name that will be of the type of the array. The rest allows creating a new array
    with the remainder of the value with the type of the initial array. In the following
    code example, the `value1` contains the number `1` (not a string but as a number).
    The `value2` contains `2`, and `value3To9` is an array with the values `3`, `4`,
    `5`, `6`, `7`, `8`, and `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to skip position by using a comma without specifying a
    variable. In the following code example, there is a space between ` value_1` and
    `value_2`, which means that the value at the second position, which is `2`, is
    not in any individual variable (`value1` or `value2`), neither is in the variable
    `value4To9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Tuple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **tuple** is an alternative to an object to hold multiple values within a
    single variable. Often used to move information around by function, it leverages
    an array to carry different types. The assignation with a tuple is done by setting
    the desired value in a specific index of an array, which the consumer must know
    to retrieve the pertinent information. In JavaScript, the usage of an array is
    sufficient. However, doing so in TypeScript leads to a weak type. The following
    code shows that TypeScript will infer the type to be an array of number or string,
    which can make sense but not when the code wants to be strongly typed. The reason
    is that an array can be a number or type at any position of the array, while in
    a tuple situation we want to have a specific type for each position in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To overcome the array inference, we need to specify the type for each position.
    However, even if a tuple is more specific than an array with multiple types because
    of the specification by the index of the type, this one still is not as safe as
    using an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code illustrates that during instantiation, there is a validation
    of type as well as a validation of size. It means that when assigning values,
    you must respect the type and the number of expected values. However, the last
    line of the code shows the nature of the array surface, and regardless of the
    fact that the tuple declaration specifies three positions, it is possible to add
    any type at any position after the ones defined. In the code example, the three
    first positions (index `0`, `1`, and `2`) are strongly typed but position four
    and above can be anything. Nevertheless, changing a value, with the square brackets,
    will validate the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuple supports spread operator to deconstruct a function parameter into several
    variables. The following code example shows that a single tuple argument can be
    spread. The function `restFunction` is the equivalent of the `resultFunction`.
    The code example shows that it is possible to pass a tuple but not an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuple supports optional. The syntax is similar to a function with optional
    parameters or a type with optional members. Positions without value are automatically
    set to `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous declaration is similar to the following, where optional position
    can be set to `undefined` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the tuple definition in a type can be advantageous when a tuple is
    reused in several places. The syntax is identical to when defining a type with
    the keyword type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, the tuple is a convenient way to pass information in a function
    and also to quickly return more than one value. However, a better alternative
    is to define a quick interface with the member desired. Not only does it not rely
    on position, but it can be reused in many situations easily by allowing extension
    and intersection. Furthermore, an object is easier to read because the assignation
    and the readability rely on a name instead of a number.
  prefs: []
  type: TYPE_NORMAL
- en: The differences between declare and let/const/var
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to use `declare` instead of one of the three declarators `let`,`const`,
    and `var`. However, `declare` won''t generate any JavaScript code during compilation
    and must be used in conjunction with `let`, `const` or `var`. The role of `declare`
    is to indicate to TypeScript''s compiler that the variable exists but is defined
    somewhere else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The main role of `declare` is when signatures need to be defined. The use of
    `declare` in a definition file makes sense because it is only defining the type
    and not actually declaring the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`declare` can be used to declare a module. Declaring a module is used to write
    a definition file outside the actual implementation of the code, which is written
    in JavaScript or TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed many ways that generic information can be stored
    with the concept of many objects. We demystified the difference between the uppercase
    and lowercase object with an object literal and an instantiated object. We clarified
    two different structures to hold quick access data with index signature and map.
    The chapter continued with how to manipulate several types with a union and an
    intersection. Finally, we saw how to destruct, and how declare is different than
    the three previous declarations mentioned in [Chapter 2](aeb84a25-e8a4-48bf-a056-76d0e060f727.xhtml),
    *Onboarding Types with Primitive*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to work with `object-oriented`. The next
    chapter covers how to use inheritance, encapsulation, and static function. The
    notions of interface and how to define a constructor signature in an interface
    will be explained. The next chapter dives into the powerful world of `object-oriented`
    in TypeScript.
  prefs: []
  type: TYPE_NORMAL
