- en: Testing, Deploying, and Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are approaching the end of this book, but we can't finish without discussing
    some aspects that are beyond coding a solution. We need to understand how you
    can test functions that run in an environment that you don't own, what is a good
    development workflow to deploy and deliver new versions of your solution, and,
    although we don't need to worry about servers when building a serverless project,
    we need to understand what is the minimal monitoring that we need to configure
    to provide a cost-efficient and reliable solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing a serverless solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining how to handle the deployment and delivery of new versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring errors, performance, and costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter, you'll have completed the book and will be prepared to build
    your next solution with serverless components or enhance an existing one benefiting
    from the serverless concept.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing a serverless project can be a challenging experience, since we rely
    on many different cloud services that are hard to emulate locally and, besides
    testing individual services, we need to test how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: However, the practices that you have already used in traditional projects can
    all be used for serverless applications. To improve the quality of your software,
    you may use **Test-Driven Development** (**TDD**), **Behavior-Driven Development**
    (**BDD**), or any other development process that fundamentally relies on automating
    tests. Although we don't have access to the machines that will execute the code,
    we can simulate many things locally and we can run integrations tests from time
    to time to assert that everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we are going to see how to create tests for the backend
    and frontend. To make this topic simpler, we are going to create tests for trivial
    functions. If you want more extensive examples, you can browse the code files
    of this chapter to see how the serverless store was tested.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since a Lambda function is defined in a common JavaScript file, you just need
    to set your testing tool to load this file and test the function locally. To simulate
    the input data that is set by the API Gateway or another trigger, you need to
    set the `event` variable of your test according to the expected input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to see how to unit test a Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new serverless project by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s modify the `serverless.yml` file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this project, we have only one Lambda function, and this `hello` function
    is defined by a `greetings.js` file inside a folder named `functions`. Consider
    the following simple implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This `hello` function is the function that we want to test. Now, let''s create
    our testing code. In the following screenshot, we show the project tree, where
    a folder named `test` was created and it contains a `mocha.opts` file, along with
    two other folders, `unit` and `integration`. Since this sample code doesn''t interact
    with any other service, we can call it a `unit` test and the file `test-greetings.js`
    is where it will be implemented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/292f8892-ccf8-47e1-b638-6efa46ddc8e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can exclude this `test` folder and all of its contents from the deployment
    package by adding an exclude rule at the end of the `serverless.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Regarding the `mocha.opts` file, it was included to configure the options for
    the Mocha test framework ([https://mochajs.org/](https://mochajs.org/)), but you
    can use any other testing tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this `mocha.opts` file, I''ve added only one line of code to specify which
    folder must be used to run tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `unit` folder will hold unit tests, which are tests that must execute in
    milliseconds so that the developer can immediately assert the state of the code
    with each modification. The `integration` folder holds tests that access external
    services and are allowed to complete in seconds/minutes. These are designed to
    execute occasionally, usually once a day, and not as frequently as unit tests.
    So, they were not included in the options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocha is installed through npm, so we need to add a `package.json` file and
    execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `package.json` file, add a `test` command with the `mocha` value in
    the `scripts` field. It will be helpful later, since you can run the `npm test`
    command to execute the unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have properly set up the test environment, we can implement the
    test file named `test-greetings.js`. To use Mocha, we need to use the `describe`
    function to list the test cases and the `it` function to implement a test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For this Lambda function, we can implement the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the tests, run `npm test`. You should receive the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/389eeef3-3b6f-443d-b14d-61c686f7bee0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a good practice, you should always *test* the test. You can do this by changing
    the expected result from `Hello, John!` to `Bye, John!`, which will obviously
    make the assert fail, resulting in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a49fc326-18c0-4f40-9688-3e49dbba583a.png)'
  prefs: []
  type: TYPE_IMG
- en: Mocking external services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you can't unit test a Lambda function directly simply because, sometimes,
    you can't consider the function as a *unit*. If the function interacts with external
    services, like sending a notification or persisting some data in a database, you
    can't consider it as a unit of logic. In this case, you can only unit test the
    function if you remove such dependencies from the test, and you do so by *mocking*
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking is the act of building an object to simulate the behavior of another
    object. When we need to test a complex service, there are many underlying behaviors
    that we may not be interested in testing. For example, if I use an external service
    to process credit card payments and I want to test whether it processes correctly
    for a given input, I don't want to handle unexpected events such as connectivity
    issues. In this case, I could create a fake object that would imitate the expected
    behavior and my test case would return success or failure if a specific condition
    is met.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to mock services, we need to separate the business logic from external
    services. With this approach, we can write unit tests and keep the solution less
    dependent of cloud services, which helps if one day you need to migrate from one
    cloud provider to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example where there **isn''t** a clear separation
    of the business logic and services. Therefore, it is harder to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example receives an order information, saves it in a database, and sends
    an e-mail notification. There are two main problems here such as the code is bound
    to the input (how it handles the `event` object) and you can't unit test the inner
    contents of the Lambda function without triggering requests to the database and
    the notification service.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better implementation is to create a separated module that will control the
    business logic, and to build this module allowing you to inject the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, this code can be unit tested since the database and notifier services are
    passed as input values, so they can be mocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the Lambda code, it becomes much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using Sinon.JS for mocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we improved the Lambda function by creating an external
    module, named `Order`, to handle all actions related to orders. This was necessary
    because we can only mock the objects that we have access to. We won't be able
    to test the Lambda function directly because we don't have access to the services
    that it uses (database and notifications), but at least we will be able to test
    the `Order` class, since it allows the services to be injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our mocking example, we are going to use Sinon.JS. It can be installed
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Sinon will be used along with Mocha. So, we will need to create a test case
    like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement this test as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example shows that you can use Sinon.JS to check whether your dependencies
    are being called as expected and with the correct parameters. You can improve
    this example, adding fake responses and testing different behaviors, but we won't
    go deeper into this subject because those features are not strictly related to
    serverless. The objective here is to show that common testing frameworks can be
    used with serverless without needing anything special to configure them.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have developed the frontend using React, so we will build a simple example
    to show how you can test it. The objective is to see if a simple component renders
    correctly and if it displays a text as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps to create this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a new React project executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create React App uses Jest as its test runner. As a convention, it will always
    looks for files that end with `.test.js` to execute the tests. In the default
    template, we have the `App.js` and `App.test.js` files. If you run `npm test`,
    Jest will execute the sample test that was created in `App.test.js` and it will
    output the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cbdf4bfd-3d05-4442-8927-ae6063c0af4e.png)'
  prefs: []
  type: TYPE_IMG
- en: After running `npm test`, Jest will be watching for changes, so you can continue
    developing your frontend and Jest will execute all test cases whenever you save
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `App.js`, we have an `App` component defined by the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And `App.test.js` is defined by the following code, which is just a smoke test
    to see if the component can be rendered without crashing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to improve this test case and we will need to install two
    helper tools such as Enzyme and react-test-renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With Enzyme, we can simplify the previous example by using the `mount` function
    instead of `ReactDOM.render`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish this example, we are going to add another test case to see if a given
    element, `<h2>Welcome to React</h2>`, was rendered within this component as we
    are expecting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Simulating AWS services locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the drawbacks of using cloud services is that they offer products that
    you can't install on your own machine. If you could install them, your development
    speed would increase because testing locally is faster them connecting to them
    through the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this limitation, there are many tools that have been created by the
    community to help you to simulate AWS services by running them locally. You can
    find some of them in the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lambda functions**: [https://github.com/lambci/docker-lambda](https://github.com/lambci/docker-lambda)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Gateway and Lambda**: [https://github.com/dherault/serverless-offline](https://github.com/dherault/serverless-offline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduled Lambda functions**: [https://github.com/ajmath/serverless-offline-scheduler](https://github.com/ajmath/serverless-offline-scheduler)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DynamoDB**: [https://github.com/mhart/dynalite](https://github.com/mhart/dynalite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some benefits and drawbacks with this strategy. Particularly, I don''t
    buy this idea and I don''t use them. You can find my view of the pros and cons
    as follows and decide for yourself if those tools may improve your development
    workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: It is faster to run locally than using the Internet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tests**: Some tools are just mocks that simulate the behavior of a real service
    without making any I/O operations, which means that you can test your services
    without changing your code. Others are similar implementations that allows you
    to debug your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Costs**: You can run them for free using your own machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: Most services need extra configuration steps. For a small project,
    you may take more time configuring and troubleshooting issues with the fake services
    than you will benefit from faster tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tests**: It is hard to feel confident in your tests if you are using only
    simulated services. You need to run integration tests with real services from
    time to time. Also, you may not be able to do some tests. For example, simulating
    IAM permissions is really hard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Costs**: You may spend more developer-hours configuring those tools than
    you will save on cloud costs. Most cloud providers have adopted a pricing schema
    where they offer a free tier that allows developers to build and test their products
    for free and the providers just start to charge money when the service is used
    intensively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the deployment of a serverless application.
    I'm not referring to just running the `serverless deploy` command, what I mean
    is that you need to know and define how to handle and manage new versions of your
    application in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Can you hit the deploy button at any time of the day? What are the implications?
    How can you create a replica of the production environment just for testing? Those
    are the kind of things that will be discussed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Development workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying a new version of a Lambda function is a simple task. We run a command
    and the framework is responsible for packaging the contents and uploading them
    to AWS. However, running the `serverless deploy` command usually takes a couple
    of minutes. The problem is not the time to upload the ZIP file, but what the framework
    needs to update using CloudFormation. A new CloudFormation template needs to be
    issued asking AWS to update all related resources of a specific zone, which takes
    time. As our codebase grows, we may need to create dozens of API Gateway endpoints,
    many different IAM roles, or other kinds of AWS resources. Managing them can be
    troublesome, as they increase the deployment time to an unpleasant duration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reducing this time can be achieved using selective deployment. If you have
    modified just a specific function, you can make a fast deploy by referencing it
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Blue-green deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blue-green deployment is a common technique to deploy a new version of software
    without generating unavailability. Consider that you're running an application
    of the 3.0 version and you want to deploy the new 3.1 version. Before you start
    updating your machines, all of them are using the 3.0 version and we say that
    they are in a *blue* state. We start by creating new machines with the updated
    code, version 3.1, and these machines are in a *green* state. The next step is
    to modify the load balancer to redirect all new connections to the new machines
    (green) while it keeps on running requests to the old machines (blue). After the
    previous calls finish running, the *blue* machines won't receive any new requests,
    and they can be shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: Blue-green is important because, in the past, as we usually had just one web
    server machine to handle an application, the common practice was to stop the web
    server, update the code, and start it again. Those few seconds of unavailability
    were acceptable in the past, but today, with automation and the possibility of
    distributing the load among multiple servers, it is not necessary anymore to disrupt
    the service for an update or maintenance routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept is equivalent in the serverless world. When you update the code
    of a Lambda function, AWS will use it to handle new incoming requests while the
    previous one will keep running with the previous code. The API Gateway will also
    handle modifications in the endpoints behaviors without causing unavailability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72c5f8ca-50f5-46d6-a1d2-335823f3dde2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, answering the previous question: can you hit the deploy button at any time
    of the day? Yes, you can deploy new versions of your application without worrying
    about availability. However, during the deployment of a new version, we can have
    different versions running simultaneously. You should pay attention to this case,
    especially regarding versions that require changes to the database model.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying new versions with a different database model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In serverless, we usually run code that executes in fractions of a second. So,
    running two different versions simultaneously may take less than a second, but
    how do we apply databases changes in a model? Renaming a column may break the
    execution of a previous version.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we would all be using NoSQL databases with flexible schemas, but that's
    not true. Some business cases are better handled by relational databases or NoSQL
    databases with a restrict schema.
  prefs: []
  type: TYPE_NORMAL
- en: When modifying a schema, there are three operations that require our attention
    such as create, rename, and drop.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new table or column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a table or a column in a pre-existing table shouldn't break any kind
    of application. However, there are some ORM tools, such as the Entity Framework
    (for .NET), that associates each schema version with a migration ID. In this case,
    when you run a migrate command to upgrade a database schema, it adds a new migration
    ID that will be checked by the application code. If you run the previous version
    of the code, the ID will not match and it will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of restriction was created as a safety measure to avoid a deprecated
    code from running in production and causing inconsistencies when the expected
    model is different. Though, if you have proper control over your deployments,
    you can disable this restriction to avoid unavailabilities while upgrading versions.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we need to pay attention when we add constraints or foreign keys. If you
    modify a table with thousands of rows to add a new foreign key, the alter table
    command may need some significant time to process. While processing, the table
    will be locked for selects and this can lead to some query timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming a table or column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you need to rename a column from name `A` to `B`. If you make this change,
    the previous code may not work properly, since it won't find the column with name
    `A` and the newest code may not work if deployed before the rename happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proposed solution here is to make this change by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a script to create a new column named `B`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a temporary trigger that will execute every time that you modify some data
    in the `A` column to apply the same modifications to the `B` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate all contents from `A` to `B`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy a new code version that is exactly like the previous one, but read/write
    using the column `B` and not `A`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait a bit to ensure that all requests are using the new Lambda code and not
    the previous one. You may need to wait for the maximum timeout of your Lambda
    functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run another script that will remove column `A` and the temporary trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy your up-to-date code that uses column `B` and adds new features to your
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dropping a table or column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dropping a table or column is a little bit easier. You just need to deploy a
    new application code that doesn't use the table or field that you want to remove.
    After waiting a little bit to ensure that the previous code has finished being
    executed, you can safely execute a script that will delete the table or remove
    the field.
  prefs: []
  type: TYPE_NORMAL
- en: Rollback a deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we deploy a new version of an application that may introduce a buggy
    feature. Depending on the error severity, you may need to rollback the application
    before starting to fix the error for a new deployment. You have two options for
    this rollback:'
  prefs: []
  type: TYPE_NORMAL
- en: Version control all deployments in tags. When you need to rollback, select the
    code from the previous tag and run `serverless deploy` again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `serverless rollback` command to change your functions to a previous
    version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AWS has a versioning system for our deployments, so using the `serverless rollback`
    command is safe and fast. This command should be used passing a `timestamp` parameter,
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the timestamp information of our last deploy, we need to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d947e54-8d26-4d11-8dd3-42d6b1edabf9.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous screenshot, we would use the value `1499216616127` for the `timestamp`
    parameter. Note that we need to select the penultimate version and not the last
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The command `serverless rollback` will rollback all functions for a previous
    deployment that was done with the command `serverless deploy`. If you used `serverless
    deploy function`, this change won't be versioned.
  prefs: []
  type: TYPE_NORMAL
- en: Creating staging environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Best practice says that we must have different environments for development
    and production. You can also add a third environment, usually named *staging*,
    for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development**: This is where you deploy code as a work in progress, testing
    that it works together with other services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staging**: This is usually necessary to validate the build by customers or
    a quality assurance team'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production**: This is where your application is visible by end users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All software that we develop is highly dependent on the environment, such as
    the operating system, runtime version, installed modules and dlls, external services,
    configuration files, and others. Therefore, it was a pretty common excuse, at
    least some years ago, for a developer to explain production errors saying that
    "it works on my machine". Mirroring the development environment with the production
    setting was a very difficult task. Sometimes, changes applied to one were not
    reflected to the other, causing strange errors.
  prefs: []
  type: TYPE_NORMAL
- en: With virtual machines, and more recently with Docker containers, this issue
    has greatly diminished, since we can now trust that we can perfectly reproduce
    production errors in our development machines and that what we build will work
    exactly as expected, regardless of the machine that executes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'With cloud providers, all of our infrastructure can be scripted. So, we can
    automate how an environment can be created through code. In this case, you just
    need to change a variable value and deploy it again to mirror your development
    code with the production code. In your `serverless.yml` file, there is an option
    under `provider` that allows you to name your current environment and easily mirror
    it to others simply by choosing a new name for the `stage` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Being careful with the production environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to easily mirror the development environment to production is a very
    powerful feature that needs to be used wisely. In my earlier days as a developer,
    I had the unfortunate habit of having the staging and production virtual machines
    open simultaneously. Which, of course, I stopped doing the day I messed with a
    production service thinking that I was changing the staging version.
  prefs: []
  type: TYPE_NORMAL
- en: What I recommend is to use the staging option to mirror the *development* environment
    with the *testing* environment. You can easily deploy a new version for your customer
    or for your quality assurance team, but you should *never* use your development
    machine to apply updates in production to avoid the associated risks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new environment is as simple as choosing a new name for the `stage`.
    So, you can name it with things like `test-2017-08-02` or `test-feature-x` to
    create new endpoints with a specific test environment.
  prefs: []
  type: TYPE_NORMAL
- en: You can designate someone in the team who will be the only person responsible
    for deploying a new production version. Restricting the responsibility to just
    one person will reduce the chance of accidents. Another option is to have one
    machine with the sole purpose of production deployments. Needing an extra step,
    which is to connect with the machine, helps because it forces you to be focused
    on the task and you won't accidentally select the wrong environment.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, I also recommend that you have two different AWS accounts, one
    for development and testing, and another one exclusively for production. Although
    it is possible to configure the IAM roles to protect your environment and prevent
    the same user from modifying both environments, it is still risky. The IAM restrictions
    may be incorrectly configured, or you could add a new resource and forget to set
    the proper access, allowing undesired changes.
  prefs: []
  type: TYPE_NORMAL
- en: Test data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have your entire infrastructure scripted, the only difference between
    the development and production environments is the associated data. The test environment
    usually has its own fabricated data, but sometimes we can't reproduce errors,
    for example, performance issues or inconsistencies, because the underlying data
    is different.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, making a backup of the production data and directly restoring a copy
    into the testing environment can be a bad practice for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Production data contains real e-mails. Running test code may send accidental
    e-mails to real people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production data contains sensitive data such as real names, e-mails, phone numbers,
    and addresses. Sharing this data with all developers is unnecessary and risky.
    The developer machine is much more unsafe and susceptible to being hacked than
    the production environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, I recommend using fabricated data for most of the tests, and when
    you need to make performance tests or analyze a specific issue, you use a production
    backup but you need to have a procedure in place to modify the content, removing
    sensitive data before sharing the data with all developers.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your functions warm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discussed in past chapters, one of the problems with serverless functions
    is the cold starts. When your Lambda function is triggered, AWS will find its
    package, unzip, and install it in a container to be executed. These steps takes
    some time (usually 5 seconds) and they delay the execution of your function.
  prefs: []
  type: TYPE_NORMAL
- en: After executing a function, AWS will keep it in a suspended state for a while.
    If a new request is done a few minutes later, it won't suffer from the cold start
    delay because the package will be readily available. After 15 minutes of inactivity,
    it will *freeze* again.
  prefs: []
  type: TYPE_NORMAL
- en: If your application needs to ensure low response times, you can deploy them
    with a configuration to keep them *warm*. There is a plugin for the Serverless
    Framework called **WarmUP** ([https://github.com/FidelLimited/serverless-plugin-warmup](https://github.com/FidelLimited/serverless-plugin-warmup))
    that will create a scheduled Lambda function that will be responsible by invoking
    the other functions from time to time (default it to 5 minutes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow the following steps to see how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new serverless project by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Create a `package.json` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the WarmUP plugin by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following reference to the end of the `serverless.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For each function that you want to keep warm, add the `warm: true` pair:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugin will invoke other functions, so we need to give it the necessary
    permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to modify the Lambda function to ignore requests created by
    this plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Monitoring the operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The serverless concept is defined as running your code without worrying about
    the infrastructure that will be responsible for supporting it. This still holds
    true, but there are some DevOps tasks that may improve your application's efficiency
    and stability. Therefore, you should not confuse serverless with NoOps. You just
    don't need to worry *that* much about the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are using AWS, we are going to use its monitoring tool: Amazon CloudWatch.
    There are some other paid and free tools that can also be used for this task,
    so feel free to compare them before selecting your own tool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use CloudWatch, open the Management Console at [https://console.aws.amazon.com/cloudwatch](https://console.aws.amazon.com/cloudwatch),
    and let''s see in the following subsections how we can monitor our Lambda functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0d1718b-80e4-409a-840d-da3bd62dc665.png)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring costs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Estimating costs in serverless is a difficult task, since it depends highly
    on usage. Also, deploying a new function may result in unexpected costs due to
    programming errors. For example, consider that you set a function with a timeout
    of 5 minutes and 1 GB of RAM. Maybe it is supposed to execute in a few milliseconds
    95% of the time, but due to an error, it may freeze every time and run indefinitely,
    just stopping after the timeout is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Another scenario is when you use a Lambda function to call another Lambda function,
    but a programming error may create an endless loop causing your Lambda functions
    to execute constantly. In fact, AWS has some limits and measures to prevent these
    kind of errors, but that's something that we should pay attention to avoiding.
  prefs: []
  type: TYPE_NORMAL
- en: You can always open your AWS Billing dashboard to track your monthly expenses,
    but when these kind of issues occur, you want to be at least warned as soon as
    possible. In this case, you can set a billing alert to send an e-mail if the monthly
    cost reaches an unexpected level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s monitor the costs by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your CloudWatch console and browse the Billing link in the left-hand side
    menu, followed by Create Alarm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/04986da6-29f8-48dc-80d5-24dd225f4392.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, select Billing Metrics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/087d4c19-bcd6-49e3-94ac-840b177937d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'CloudWatch allows you to create a billing alert for the entire account or to
    filter the alert by service. In this case, you can select the AWSLambda service
    and click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74d52908-9f99-4ad0-b034-a8abf94b97f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the last screen, you can set a threshold for the alarm and define which
    persons it should notify if it goes beyond an acceptable value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b500d879-faea-4a3e-b93c-deb69078cbb0.png)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back to the CloudWatch console home screen, click on the Browse Metrics
    button located at the center. It will redirect you to another page where you can
    select all the metrics available to your Lambda functions. You can choose to monitor
    by function name, resource, or across all functions. The available metrics are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Errors**: This is the metric of the number of times that the Lambda function
    stopped prematurely due to an error, or it has stopped after reaching the timeout
    limit. This is an important metric because, ideally, you expect to see zero errors
    in production and will want to be warned when an error is detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invocations**: This is the metric of the number of times that your Lambda
    function was invoked. If this function is executed by a schedule, you may want
    to be notified if it executes more times than expected. Also, using this metric,
    you may track when executions go out of control if the function is executed more
    times than a reasonable value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duration**: With this metric, you can track if your function is taking longer
    than expected to execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Throttles**: This metric is counted every time the function is not executed
    because the limit of concurrent Lambda functions is reached. This value can be
    increased if you open a support ticket to AWS, but the default value is 1,000
    and it can be very low for some use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these metrics are automatically monitored and you can build
    some graphs with historical data. If you want to set alarms, go back to the Console
    Home page and click on Alarms in the left-hand side menu, followed by Create Alarms,
    and configure the recipients as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving metrics with the Serverless Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the Serverless Framework to retrieve CloudWatch metrics. It can
    be a useful feature to take a quick look at the application's operation without
    browsing the CloudWatch console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the `serverless metrics` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8d5f14a-037d-4baa-aec9-69adc9cb745d.png)'
  prefs: []
  type: TYPE_IMG
- en: This command can be used to see the combined operation of all functions (`serverless
    metrics`) or the stats of just one function (`serverless metrics --function <your-function>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can filter by a date range using the arguments `--startTime` and
    `--endTime`. The following command will include only stats related to events that
    happened in the last 30 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Streaming Lambda logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an error occurs in a Lambda execution, the error message is usually insufficient.
    For example, consider the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b78b9183-cac1-472a-8997-04f807e15abf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can retrieve more details about the error message by streaming logs to
    the terminal. You can hook to a specific function and receive the history of error
    messages and live errors. For this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `--tail` argument indicates that you want to listen to new error messages.
    You can also use `--filter word` to show only messages that match the filter or
    `--startTime` to specify the range of logs that you want to see. For example,
    `--startTime 2h` shows logs from the last two hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'The log messages show the stack trace of the errors, which is much more useful
    to understand the root cause of an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf8b7e30-4d5f-46fa-bfef-c425b09b59cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function executes with errors, Lambda offers two handlers such as SNS
    and SQS. You can use them to handle events that have failed, so you may try them
    again later or retrieve additional information to understand what caused the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'SNS is used to notify on errors and SQS is used to create a queue of failed
    Lambda tasks that can be processed by another service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You should set the ARN of the SNS topic as SQS queue.
  prefs: []
  type: TYPE_NORMAL
- en: SQS is currently not supported due to a bug in the Serverless Framework v.1.18,
    but this error is already a known issue and should be fixed soon.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already discussed, you can find how long it takes for a function to execute
    through the duration metric in the CloudWatch option or by running the `serverless
    logs` command of the framework. Ideally, there is no difference if the code is
    executed during work hours, at midnight, or on weekends. AWS strives to always
    provide a constant experience at any time of the day.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this is not always true. There is no known pattern for this behavior,
    but you can expect large differences in the execution time. Without considering
    cold start delays, your function can take 50 milliseconds to execute, and 1 minute
    later, it can take 400 milliseconds to execute the same code with the same input.
    It is much more difficult to provide a constant experience in serverless sites
    than when using a traditional infrastructure. This is because your infrastructure
    is always shared between other customers.
  prefs: []
  type: TYPE_NORMAL
- en: Though you can see discrepancies, it is a good practice to monitor the duration.
    Instead of setting an alarm considering the *maximum* duration, you can set the
    *average* or *percentile*, where a percentile is a statistic unit, which means
    the percentage of observations that fall in a category. For example, a p90 of
    100 milliseconds means that you expect that 90% of the requests will take less
    than 100 milliseconds to execute and you should receive an alarm message if this
    is not true for a given period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Setting alarms is especially important when our Lambda function relies on external
    services. If the function reads data from a database table, it may take 200 milliseconds
    if the table has 10 records and 1 minute if it has 1,000,000 records. In this
    case, an alarm may be useful to alert you that it's time to clean some old data
    or improve the query.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring the efficiency means that you want to certify that you are using
    your resources in the best way possible. When you create a new Lambda function,
    there are two important options to configure such as the timeout value and the
    RAM memory to allocate.
  prefs: []
  type: TYPE_NORMAL
- en: Having a long timeout value will not impact the efficiency, but setting the
    wrong RAM memory will really affect the function performance and costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the logs of the function executed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86c851be-c6af-4a61-9fac-b45127998a62.png)'
  prefs: []
  type: TYPE_IMG
- en: It has an allocated memory size of 1,024 MB (default) while `Max Memory Used`
    was only `19 MB`. In this case, it clearly shows that you can reduce the allocated
    memory to minimize costs.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you always test your code with different memory sizes and track
    the duration time. Running with less memory than needed results in much higher
    times to process. If your Lambda function is used to answer user requests, you
    may think of paying for a little more memory to process the requests faster while,
    if it is a background task, you may use the minimum necessary to save money.
  prefs: []
  type: TYPE_NORMAL
- en: Also, when benchmarking your own code to see how fast it is for different memory
    sizes, pay attention to which scenario it is running. If your project architecture
    is a Monolith, it may be very fast to retrieve some user data using just a few
    megabytes of memory, but it may have trouble processing the sales report of a
    given period.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how you can test serverless code in the frontend
    and backend. Also, we have discussed some key concepts that you must consider
    in your deployment workflow, and showed how you can monitor serverless applications
    using Amazon CloudWatch.
  prefs: []
  type: TYPE_NORMAL
- en: Now the book has finished. I hope that you have enjoyed reading through the
    chapters and have learned enough to build your next awesome application using
    serverless. You can use the serverless store demo as a reference for your future
    projects, but don't feel limited to it. Use your own preferred tools to test,
    to develop the frontend, and to access the database. My objective with this book
    is not to define a strict pattern of how you should build a serverless application,
    but to give you an example to prove that the concept is valid and may be a good
    one for many applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I encourage you to try other cloud providers. This book focuses on
    AWS due to my own positive experiences, but there are other excellent services
    out there. When evaluating a provider, don't just pay attention to the price tag.
    Look at the tools that are offered that will make it easier for you to build your
    application. Mixing services from different providers is also viable. Good luck!
  prefs: []
  type: TYPE_NORMAL
