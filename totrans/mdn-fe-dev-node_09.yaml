- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Structuring Code in Monorepos
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单仓库中的代码结构
- en: In the previous chapter, you learned about everything to create and publish
    great libraries and tools to enhance your projects. While some packages are created
    in a bit of vacuum, most already have a consuming application in mind. In this
    case, having two separate repositories – that is, one for the application and
    one for the library – is quite some overhead. After all, any change to the library
    should be at least partially tested before the library is published. A good way
    to make this relation more efficient is to structure this code in a monorepo.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了创建和发布优秀的库和工具以增强你的项目的所有内容。虽然一些包是在一定程度上孤立的，但大多数包已经有了消费应用的概念。在这种情况下，有两个独立的仓库——即一个用于应用程序，一个用于库——会带来相当大的开销。毕竟，任何对库的更改都应该在库发布之前至少部分经过测试。使这种关系更有效的一种好方法是结构化这个代码在单仓库中。
- en: A `package.json`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `package.json`。
- en: Today, monorepos are frequently used to power some of the largest Node.js project
    code bases in the world. If you want to properly read and contribute to projects
    such as Angular, React, or Vue, you’ll need extensive knowledge about monorepos
    and the tools that make monorepos possible. For your own projects, a good structure
    – quite often provided by implementing monorepos – can also be crucial.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，单仓库经常被用来支持世界上一些最大的 Node.js 项目代码库。如果你想正确地阅读和贡献像 Angular、React 或 Vue 这样的项目，你需要对单仓库及其使单仓库成为可能的各种工具有深入的了解。对于你自己的项目，良好的结构——通常通过实现单仓库提供——也可能至关重要。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: Understanding monorepos
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单仓库
- en: Using workspaces to implement monorepos
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作区实现单仓库
- en: Working with Lerna to manage monorepos
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lerna 管理单仓库
- en: Working with Rush for larger repositories
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rush 管理大型仓库
- en: Integrating Turborepo instead of or with Lerna
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Turborepo 替代或与 Lerna 集成
- en: Managing a monorepo with Nx to enhance Lerna
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nx 增强Lerna来管理单仓库
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter09](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter09).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可在 [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter09](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter09)
    获取。
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3EjGZTL](https://bit.ly/3EjGZTL).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可在 [https://bit.ly/3EjGZTL](https://bit.ly/3EjGZTL) 访问。
- en: Understanding monorepos
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单仓库
- en: 'The structure of a dedicated repository has always been very similar; we have
    a single `package.json` in the root, a single `node_modules` folder containing
    the resolved dependencies, and a set of source and configuration files, usually
    scattered between the root and some specific folders such as `src`. A quite popular
    setup is shown in *Figure 9**.1*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 专用仓库的结构始终非常相似；我们在根目录下有一个单一的 `package.json` 文件，一个包含已解析依赖项的单一 `node_modules` 文件夹，以及一组源文件和配置文件，通常分散在根目录和一些特定文件夹（如
    `src`）之间。*图9.1* 展示了一个相当流行的设置：
- en: '![Figure 9.1 – Common setup for a repository with a single package ](img/Figure_9.1_B18989.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 单个包的仓库常见设置](img/Figure_9.1_B18989.jpg)'
- en: Figure 9.1 – Common setup for a repository with a single package
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 单个包的仓库常见设置
- en: In the common setup, we have some folders for CI/CD pipeline definitions and
    potential tools that are useful for managing the repository, as well as auxiliary
    files such as project documentation. Of course, for a Node.js project, we’ll see
    a `node_modules` directory, as well as a `package.json` file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见的设置中，我们有一些用于 CI/CD 管道定义和潜在的有用工具的文件夹，以及如项目文档之类的辅助文件。当然，对于 Node.js 项目，我们将看到一个
    `node_modules` 目录，以及一个 `package.json` 文件。
- en: 'In contrast, a monorepo will contain multiple `package.json` files with multiple
    `node_modules` (or alternative) folders. Likewise, the source files and potentially
    some of the configuration will also be scattered across multiple locations. A
    very common structure is shown in *Figure 9**.2* for the main part and *Figure
    9**.3* for the individual packages:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，单仓库将包含多个 `package.json` 文件和多个 `node_modules`（或替代）文件夹。同样，源文件以及可能的一些配置也将分散在多个位置。*图9.2*
    展示了一个非常常见的结构，用于主要部分，*图9.3* 用于单个包：
- en: '![Figure 9.2 – Common setup for a repository with multiple packages ](img/Figure_9.2_B18989.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 多个包的仓库常见设置](img/Figure_9.2_B18989.jpg)'
- en: Figure 9.2 – Common setup for a repository with multiple packages
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.2** – 包含多个包的存储库的常见设置'
- en: 'In comparison to *Figure 9**.1*, the hierarchy of the outlined folders is a
    bit more sophisticated. Now, we don’t see the source files immediately and need
    to descend into some of the directories inside the `packages` folder:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与**图9.1**相比，概述的文件夹层次结构要复杂一些。现在，我们无法立即看到源文件，需要进入`packages`文件夹内部的某些目录：
- en: '![Figure 9.3 – The contents of the individual package directories ](img/Figure_9.3_B18989.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![**图9.3** – 单个包目录的内容](img/Figure_9.3_B18989.jpg)'
- en: Figure 9.3 – The contents of the individual package directories
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.3** – 单个包目录的内容'
- en: Ideally, the packages contained in a monorepo are crafted in such a way that
    makes them rather easy to extract later on. Let’s say you have a specific library
    in your monorepo that should now be handled by another team. If your monorepo
    was created to serve as the single point of development for your current team,
    then transferring this library makes sense.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，单一代码库中包含的包应该以这种方式构建，使得它们在以后更容易提取。假设你有一个特定的库在你的单一代码库中，现在应该由另一个团队处理。如果你的单一代码库是为了作为当前团队的开发单一来源而创建的，那么转移这个库是有意义的。
- en: Quite often, common development concerns, such as the usual packages contained
    in the `devDependencies` of a `package.json` file, are concentrated in a dedicated
    `package.json` file. In many monorepos, this `package.json` file is found in the
    root directory of the monorepo. While this pattern makes sense from a maintenance
    point of view, it can also bring up challenges when it comes to library extraction.
    After all, you’ll now need to decide what dependencies to add to restore the development
    capability of the extracted library.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，常见的开发问题，例如`package.json`文件中`devDependencies`的常规包，都集中在专门的`package.json`文件中。在许多单一代码库中，这个`package.json`文件位于单一代码库的根目录。虽然从维护的角度来看，这种模式是有意义的，但它也可能在库提取时带来挑战。毕竟，你现在需要决定添加哪些依赖项以恢复提取库的开发能力。
- en: 'In general, multiple challenges make supporting monorepos a task of its own.
    Here are some of the most pressing concerns:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，多个挑战使得支持单一代码库成为一项单独的任务。以下是一些最紧迫的问题：
- en: How are dependencies efficiently shared to avoid installing the same dependencies
    over and over again?
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何有效地共享依赖项，以避免反复安装相同的依赖项？
- en: How can packages be treated as if they are dependencies installed from a registry?
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将包视为从注册表中安装的依赖项？
- en: How can common tasks such as build steps be run in a way that works consistently?
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何以一致的方式运行常见的任务，例如构建步骤？
- en: Let’s go through these one by one. For (*1*), the idea is that monorepos can
    be more efficient than just having many different directories, where you’d need
    to run `npm install` in each of them. Running `npm install` in each directory
    would be a massive overhead, duplicating not only direct dependencies but also
    indirect ones – that is, dependencies of installed dependencies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析这些问题。对于(*1*)，想法是单一代码库可以比仅仅拥有许多不同的目录更有效率，在这些目录中，你需要为每个目录运行`npm install`。在每个目录中运行`npm
    install`将是一个巨大的开销，不仅会重复直接依赖项，还会重复间接依赖项——即已安装依赖项的依赖项。
- en: While (*1*) is only a performance (installation time and disk space) concern,
    the issue with (*2*) is developer convenience. The reason for having a monorepo
    in the first place is to have packages that depend on one another in close proximity.
    This way, a bug should be visible at development time, rather than later at integration
    time when a package has already been published. The usual mechanism of npm for
    this is to use the `npm link` command, which will make a local package globally
    available for referencing. There are, however, multiple downsides to this mechanism.
    Additionally, it is not very convenient to use this command for every package.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然(*1*)只是一个性能（安装时间和磁盘空间）问题，但(*2*)的问题在于开发者的便利性。最初采用单一代码库的原因是为了让相互依赖的包靠近。这样，一个错误应该在开发时间而不是在包已经发布后的集成时间变得明显。npm处理这个问题的通常机制是使用`npm
    link`命令，这将使本地包全局可用以供引用。然而，这个机制存在多个缺点。此外，对于每个包使用此命令并不非常方便。
- en: Finally, the dependencies between the packages in a monorepo require special
    attention when running commands. In terms of (*3*), tasks such as building the
    source code need to be performed in reverse reference order. This means, that
    in the case that package *A* depends on package *B*, the build process of package
    *B* needs to be done before package *A* is built. The reason is that through the
    dependency, the content of package *A* may only build successfully if the content
    of package *B* has been fully created – that is, the package has been built. Similar
    constraints arise for testing and when publishing a package.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let’s start with one of the easiest options for implementing
    a monorepo: leveraging the workspaces feature that comes with the most popular
    npm clients.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Using workspaces to implement monorepos
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the need for monorepos grew, npm clients tried to help users by incorporating
    them. The first of the big three was *Yarn*. Already, with the first version of
    Yarn, a new concept called `workspaces` in `package.json`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Yarn workspaces require a `package.json` at the root directory of the monorepo.
    This `package.json` won’t be used for publishing and needs to have the `private`
    field set to `true`. The `workspaces` field itself is an array that contains the
    paths to the different packages. Wildcards using the `*` or `**` symbols – as
    shown here – are allowed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: With npm *v7*, the standard npm client also received a workspaces feature. The
    feature is pretty much the same as the implementation in Yarn. Here, we need to
    have a `package.json` in the root, too. Likewise, the behavior is controlled by
    a `workspaces` field.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the implementation in *pnpm* is a bit different. Here, we need a dedicated
    file called `pnpm-workspace.yaml`. This file contains the paths to the different
    packages:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: pnpm-workspace.yaml
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In contrast to the other two npm clients, with pnpm, you don’t need a `package.json`
    file in the root directory. Since the workspaces definition is in a separate file,
    this file alone is sufficient to enable the workspaces feature of pnpm.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate that, let’s create a new directory and add the preceding `pnpm-workspace.yaml`
    file to it. Then, create a `packages` subfolder. In there, add two more folders,
    `p1` and `p2`. In each of these directories, run `npm init -y`. You can now modify
    the contained `package.json` files, adding some dependencies to both.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'From the root directory with the `pnpm-workspace.yaml` file, run the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While editing the respective `package.json` file is always possible, `pnpm`
    also makes it easy to add a dependency to some contained package – or workspace
    in the terminology of pnpm.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to add `react-dom` to the `p1` workspace:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `--filter` argument allows you to select the workspaces where the dependency
    should be added. While full names are accepted, the names can also be specified
    with wildcards (`*`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Specifying dependencies in monorepos
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies on other packages contained in the same monorepo are declared just
    like any other dependency – in the corresponding `package.json` fields, such as
    `dependencies` or `devDependencies`. The specified version, however, is crucial
    here. You need to make sure to either match the version of the referenced package
    (e.g., `1.2.3` or `^1.0.0` would both correctly match a package in version `1.2.3`)
    or use the wildcard specifier `*`. Today, most package managers also support the
    special workspace protocol. With this, you can write `workspace:*` instead of
    a version to link against a package in another workspace.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一 monorepo 中包含的其他包的依赖关系声明就像任何其他依赖关系一样——在相应的 `package.json` 字段中，如 `dependencies`
    或 `devDependencies`。然而，指定的版本在这里至关重要。你需要确保匹配引用包的版本（例如，`1.2.3` 或 `^1.0.0` 都可以正确匹配版本为
    `1.2.3` 的包）或使用通配符指定符 `*`。如今，大多数包管理器也支持特殊的 workspace 协议。使用这个协议，你可以写 `workspace:*`
    而不是版本来链接到另一个 workspace 中的包。
- en: The workspaces option is certainly appealing to optimize packages and make their
    linking quite easy; however, it fails to make common monorepo tasks more approachable
    or convenient. An alternative is to use a tool such as **Lerna** on top of a workspace.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: workspaces 选项确实很有吸引力，可以优化包并使它们的链接变得相当容易；然而，它并没有使常见的 monorepo 任务更加易于接近或方便。一个替代方案是在
    workspace 之上使用像 **Lerna** 这样的工具。
- en: Working with Lerna to manage monorepos
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lerna 管理单一代码库
- en: '**Lerna** is one of the oldest tools for managing monorepos. We can even say
    to some degree that Lerna not only made monorepos manageable but also popular.
    Lerna is the backbone of some of the most important monorepos, such as Jest. It
    also was the original choice for projects such as *Babel* or *React*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lerna** 是管理单一代码库的最古老工具之一。我们甚至可以说在某种程度上，Lerna 不仅使单一代码库变得可管理，而且使其变得流行。Lerna
    是一些最重要的单一代码库（如 Jest）的支柱。它也是像 *Babel* 或 *React* 这样的项目的原始选择。'
- en: Originally, Lerna was mainly picked because it correctly installed and resolved
    all the packages. At this time, no package manager was capable of doing that intrinsically.
    However, today, Lerna is most often used together with the workspace features
    offered by the different package managers. Of course, you can still use the original
    mode of Lerna, where plain `npm` is used to install and link the different packages.
    So, how does Lerna fit into this new role when the whole installation is done
    by the chosen package manager anyway?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，选择 Lerna 主要是因为它能够正确安装和解析所有包。当时，没有任何包管理器能够内在地做到这一点。然而，如今，Lerna 最常与不同包管理器提供的
    workspace 功能一起使用。当然，你仍然可以使用 Lerna 的原始模式，其中使用 plain `npm` 来安装和链接不同的包。那么，当整个安装都由选择的包管理器完成时，Lerna
    如何适应这个新角色呢？
- en: 'It turns out that Lerna is a really great task-running layer on top of a package
    manager. For instance, running a `package.json` script such as `build` in all
    the contained packages is as straightforward as invoking the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，Lerna 是一个在包管理器之上的真正出色的任务运行层。例如，在所有包含的包中运行 `package.json` 脚本，如 `build`，就像调用以下命令一样简单：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would only run the script in the packages that contain this kind of script.
    In comparison, Yarn would actually error out if one of the packages did not have
    a `build` script.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会运行包含此类脚本的包中的脚本。相比之下，如果其中一个包没有 `build` 脚本，Yarn 实际上会出错。
- en: 'To get started with Lerna, you need to initialize the current repository as
    a Lerna monorepo. For this, the `init` command can be used:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Lerna，你需要将当前仓库初始化为 Lerna 单一代码库。为此，可以使用 `init` 命令：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once initialized, the repository should contain a `lerna.json` and a `package.json`
    file. By inspecting these files, you’ll notice that `lerna.json` contains a version
    (by default `0.0.0`), but `package.json` does not. This is intentional. Lerna
    will actually manage the version here. The default choice is uniform versioning
    – that is, all packages will always get the same version. The other option is
    independent versioning. Here, each package can have its own version number. This
    is handy if different packages have their own release cycle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化，仓库应包含一个 `lerna.json` 和一个 `package.json` 文件。通过检查这些文件，你会注意到 `lerna.json`
    包含一个版本（默认为 `0.0.0`），但 `package.json` 不包含。这是故意的。实际上，Lerna 将会管理这里的版本。默认选择是统一版本控制——也就是说，所有包都将始终获得相同的版本。另一种选择是独立版本控制。在这里，每个包都可以有自己的版本号。如果不同的包有自己的发布周期，这会很有用。
- en: 'To enable independent versioning, we can change `lerna.json`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用独立版本控制，我们可以更改 `lerna.json`：
- en: lerna.json
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: lerna.json
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Alternatively, we could also initialize the repository using the `--independent`
    flag for the `lerna` `init` command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用 `lerna init` 命令的 `--independent` 标志来初始化存储库。
- en: The `package.json` file contains the `workspaces` property. By default, this
    is configured to include all directories from the `package` directory as packages.
    In the given configuration, Lerna would use npm as a package manager. In any case,
    the whole package management is left to an actual npm client.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件包含 `workspaces` 属性。默认情况下，这被配置为包括 `package` 目录下的所有目录作为包。在给定的配置中，Lerna
    会使用 npm 作为包管理器。在任何情况下，整个包管理都留给了实际的 npm 客户端。'
- en: 'As mentioned, Lerna is really good at running tasks. What else is considered
    a strength of Lerna? The whole publishing and version management. We’ve already
    seen that Lerna knows two modes: independent and uniform versioning. In the independent
    versioning mode, Lerna will check the published versions with the current version
    that is about to be published. Only in the case of a new version will the `publish`
    command actually run.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Lerna 在运行任务方面确实很出色。Lerna 的哪些方面被认为是其优势？整个发布和版本管理。我们已经看到 Lerna 知道两种模式：独立版本控制和统一版本控制。在独立版本控制模式下，Lerna
    将检查即将发布的版本与当前版本。只有在有新版本的情况下，`publish` 命令才会实际运行。
- en: 'Let’s see how the packages from the previous example would actually be published
    with Lerna. We’ll use a local registry running Verdaccio for this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上一个示例中的包如何使用 Lerna 实际发布。为此，我们将使用运行 Verdaccio 的本地注册库：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Without additional flags, Lerna will guide us through the whole publishing process.
    As we specified independent versioning, the tool will ask us the version to pick
    for each contained package. In the case here, we selected `1.0.0` for both packages.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 没有额外的标志，Lerna 将引导我们完成整个发布过程。由于我们指定了独立的版本控制，该工具将询问每个包含的包应选择哪个版本。在这种情况下，我们为两个包都选择了
    `1.0.0`。
- en: Lerna also does a bit more than just running `npm publish` for each package.
    It is strongly related to **Git** as a version control system. It also ties the
    publish to the current commit and marks the publish via Git tags, which are automatically
    pushed to a potential origin such as **GitHub**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Lerna 还做了一些比为每个包运行 `npm publish` 更多的事情。它与 **Git** 作为版本控制系统密切相关。它还将发布与当前提交绑定，并通过
    Git 标签标记发布，这些标签会自动推送到潜在的原始存储库，如 **GitHub**。
- en: Another thing that Lerna brings to the table is extensive information about
    a monorepo. Since Lerna needs to know which packages exist and what their relations
    are quite well, it also makes sense that this information is exposed to us.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Lerna 还带来了一些关于 monorepo 的详细信息。由于 Lerna 需要知道哪些包存在以及它们之间的关系，因此将这些信息暴露给我们也是合理的。
- en: 'A great command to use to see what exists in the current monorepo is `lerna
    list`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的命令，可以用来查看当前 monorepo 中有什么是 `lerna list`：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are multiple options – all geared to fine-tune what information to include,
    exclude, and how to represent it. Ultimately, this is designed to make consumption
    in many ways possible. Independent of whether you consume this from a script or
    directly, the `lerna` tool has the right options to present the data accordingly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种选项——所有这些选项都是为了微调要包含、排除的信息以及如何表示它。最终，这是为了使以多种方式消费成为可能。无论您是从脚本中消费还是直接消费，`lerna`
    工具都有适当的选项来相应地呈现数据。
- en: Lerna has certainly been established as one of the go-to options for handling
    monorepos; however, its configuration options can be daunting, and making it efficient
    in a larger repository could be troublesome. An alternative is to use an opinionated
    tool instead. One of the best options in this category is **Rush**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Lerna 已经确立为处理 monorepos 的首选选项之一；然而，其配置选项可能令人望而生畏，在大型存储库中使其高效可能很麻烦。一个替代方案是使用一个有意见的工具。这个类别中最好的选项之一是**Rush**。
- en: Working with Rush for larger repositories
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Rush 一起处理大型存储库
- en: While Lerna provided a lot of the utility that made monorepos possible at all,
    its configuration and flexibility also posed some challenges. Furthermore, finding
    best practices proved to be difficult. Consequently, plenty of quite opinionated
    alternatives to using Lerna have been born. One of the most successful ones is
    Rush from Microsoft.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Lerna 提供了许多使 monorepos 成为可能的功能，但其配置和灵活性也带来了一些挑战。此外，寻找最佳实践也证明是困难的。因此，出现了许多对使用
    Lerna 的相当有意见的替代方案。其中最成功的一个是微软的 Rush。
- en: Rush allows a variety of npm clients to be used. Classically, Rush used to be
    npm-only. Today, Rush recommends using pnpm, which is also the default client
    when setting up a monorepo with Rush.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Rush允许使用各种npm客户端。传统上，Rush曾经只使用npm。今天，Rush推荐使用pnpm，这也是使用Rush设置单仓时默认的客户端。
- en: 'To work efficiently with Rush, a global installation of the tool is recommended:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地使用Rush，建议全局安装此工具：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After a successful installation, the `rush` command-line utility can be used.
    As with `npm`, an `init` subcommand to actually initialize a new project exists:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，可以使用`rush`命令行工具。与`npm`一样，存在一个`init`子命令来实际初始化一个新项目：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will create and update a couple of files. Most notably, you’ll find a `rush.json`
    file in the current folder. This file needs to be edited next. However, before
    you continue, make sure to remove the files you don’t need. For instance, Rush
    added a `.travis.yml`, which can be useful if you use Travis for your CI/CD pipelines.
    In case you don’t know what Travis is or you know already that you don’t want
    to use Travis, just delete that file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建和更新几个文件。最值得注意的是，你会在当前文件夹中找到一个`rush.json`文件。这个文件需要编辑。然而，在你继续之前，请确保删除你不需要的文件。例如，Rush添加了一个`.travis.yml`文件，如果你使用Travis进行CI/CD管道，这可能很有用。如果你不知道Travis是什么，或者你已经知道你不想使用Travis，只需删除该文件即可。
- en: Since with Rush, every package is added explicitly, there is no direct need
    for a `packages` subfolder. If you still prefer to group the contained packages
    in this way, you can of course do so.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Rush中每个包都是明确添加的，因此没有直接需要`packages`子文件夹。如果你仍然希望以这种方式分组包含的包，当然可以这样做。
- en: 'In order to make Rush aware of the contained packages, we need to edit the
    `rush.json` file in the root folder. In our case, we want to add two new packages:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Rush知道包含的包，我们需要编辑根目录下的`rush.json`文件。在我们的例子中，我们想要添加两个新的包：
- en: rush.json
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`rush.json`'
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the file is saved, you can run the following command – just make sure
    that the given directories really exist and contain a valid `package.json` file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，你可以运行以下命令——只需确保给定的目录确实存在并包含有效的`package.json`文件：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Among the given output, you should see some output containing messages similar
    to the ones we’ve seen when we introduced pnpm. As mentioned, under the hood,
    Rush uses `pnpm` to make package installation quite efficient.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的输出中，你应该会看到一些包含类似消息的输出。如前所述，在底层，Rush使用`pnpm`来使包安装非常高效。
- en: 'Adding or updating a dependency in a package involves running `rush add` within
    the package directory. Let’s say that we want to add `react-router` to `p1`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在包目录中运行`rush add`来添加或更新包中的依赖项。假设我们想要将`react-router`添加到`p1`中：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To run commands, Rush comes with two primitives. One is the generic `rushx`
    command, which can be seen as a wrapper around `npm run`. Let’s say the `p1` package
    defines a `hello` command as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令时，Rush提供了两个基本命令。一个是通用的`rushx`命令，它可以看作是`npm run`的包装器。假设`p1`包定义了一个`hello`命令如下：
- en: packages/p1/package.json
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`packages/p1/package.json`'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running this script can be done as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本的方式如下：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The other primitive is to use in-built commands such as `rush build` or `rush
    rebuild`. They assume that every package contains a `build` script. While the
    `rebuild` command will run all the `build` scripts, the `build` command actually
    uses a cache to enable an incremental build process – as in, reuse as much as
    possible from the output of the previous run.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基本命令是使用内置命令，如`rush build`或`rush rebuild`。它们假设每个包都包含一个`build`脚本。而`rebuild`命令会运行所有的`build`脚本，而`build`命令实际上使用缓存来启用增量构建过程——也就是说，尽可能多地重用前一次运行的结果。
- en: While Rush is very restrictive and requires taking possession of the whole repository,
    an alternative is to use a more lightweight tool such as Turborepo.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Rush 非常严格，需要掌握整个仓库，但另一种选择是使用更轻量级的工具，如Turborepo。
- en: Integrating Turborepo instead of or with Lerna
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Turborepo集成到Lerna中或替代Lerna
- en: So far, we’ve seen quite a variety of tools in this chapter. While the workspaces
    feature of modern npm clients is already more than sufficient for smaller monorepos,
    larger ones require more dedicated tools to be manageable. In cases where Lerna
    is a bit too simplistic and Rush is too opinionated, another alternative exists
    – **Turborepo**, or Turbo for short. It can be seen as a replacement for or an
    addition to Lerna.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在这个章节中已经看到了各种各样的工具。虽然现代 npm 客户端的 workspace 功能对于较小的单仓库来说已经足够，但对于较大的单仓库，则需要更多专门的工具来管理。在
    Lerna 简单而 Rush 过于固执己见的情况下，还存在另一种选择 – **Turborepo**，或简称 Turbo。它可以被视为 Lerna 的替代品或补充。
- en: 'Starting from scratch is rather easy – Turbo comes with an npm initializer:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始相当容易 – Turbo 附带一个 npm 初始化器：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will open a command-line survey and scaffold the directory with some sample
    code. In the end, you should see a couple of new files being created, such as
    a `turbo.json` or a `package.json` file. Furthermore, Turbo creates `apps` and
    `packages` directories containing some sample code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个命令行调查，并使用一些示例代码来构建目录。最后，你应该会看到创建了一些新文件，例如 `turbo.json` 或 `package.json`
    文件。此外，Turbo 还创建了包含一些示例代码的 `apps` 和 `packages` 目录。
- en: 'Let’s show the strength of Turbo by running the `build` script:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行 `build` 脚本来展示 Turbo 的强大功能：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In contrast to Lerna, this will not run the `build` script in each package
    – following the package graph. Instead, this will run one of the pipelines defined
    in `turbo.json`. In there, you can see the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Lerna 不同，它不会在每个包中运行 `build` 脚本 – 跟随包图。相反，它将运行 `turbo.json` 中定义的管道之一。在那里，你可以看到以下内容：
- en: turbo.json
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: turbo.json
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The given `pipeline` property defines a set of Turbo `build` pipelines. Every
    given key (in the definition here, `build`, `lint`, and `dev`) can then be run
    via `turbo run`. The specifics of each pipeline are specified by its given value.
    For instance, the `dev` pipeline does not use a cache, while the `lint` pipeline
    does not produce any outputs. By default, each pipeline runs a script with the
    same name in each package.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 `pipeline` 属性定义了一组 Turbo `build` 管道。然后可以通过 `turbo run` 运行每个给定的键（在这里，`build`、`lint`
    和 `dev`）。每个管道的具体细节由其给定的值指定。例如，`dev` 管道不使用缓存，而 `lint` 管道不产生任何输出。默认情况下，每个管道在每个包中运行具有相同名称的脚本。
- en: The `build` pipeline here specifies some output directories that are cached
    to perform incremental builds. It also specifies that the `build` script has to
    be run in dependencies before it can run in the current package. Therefore, if
    you have two packages, `p1` and `p2`, where `p1` depends on `p2`, the build script
    of `p2` needs to run before the build script of `p1` can be invoked.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的 `build` 管道指定了一些用于执行增量构建的输出目录。它还指定在当前包中运行之前，必须先在依赖项中运行 `build` 脚本。因此，如果你有两个包，`p1`
    和 `p2`，其中 `p1` 依赖于 `p2`，则 `p2` 的构建脚本需要在 `p1` 的构建脚本被调用之前运行。
- en: 'Besides the “in a different workspace” dependency (e.g., `^build`), you can
    also specify “in the same workspace.” For instance, if the build script depends
    on a `prebuild` script, you’d just write `prebuild`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“在不同工作区”的依赖项（例如，`^build`）之外，您还可以指定“在同一工作区”。例如，如果构建脚本依赖于一个 `prebuild` 脚本，您只需写下
    `prebuild`：
- en: turbo.json
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: turbo.json
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `turbo run` command can also invoke multiple commands at the same time:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`turbo run` 命令也可以同时调用多个命令：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result is a pretty efficient run since `lint` does not specify dependencies
    – so all linting can be done in parallel, while the build is executed hierarchically.
    The idea is illustrated in *Figure 9**.4*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `lint` 没有指定依赖项，因此运行结果相当高效，所有代码检查都可以并行进行，而构建则是按层次执行的。这一想法在 *图 9.4* 中得到了说明：
- en: '![Figure 9.4 – Task planning and execution from Turbo ](img/Figure_9.4_B18989.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – Turbo 的任务规划和执行](img/Figure_9.4_B18989.jpg)'
- en: Figure 9.4 – Task planning and execution from Turbo
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – Turbo 的任务规划和执行
- en: Turbo is not the only tool that can be used to make monorepos more efficient.
    A good alternative that goes beyond task running is Nx.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Turbo 不是唯一可以用来使单仓库更高效的工具。一个很好的替代方案是 Nx，它不仅限于任务运行。
- en: Managing a monorepo with Nx to enhance Lerna
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nx 管理单仓库以增强 Lerna
- en: Earlier in this chapter when we discussed Lerna, one thing we did not mention
    is that there is a special key in `lerna.json`, which is called `useNx` and configured
    to be `true`. This is a new addition to Lerna *5*, which is now maintained by
    the people behind Nx – another popular solution for managing monorepos. So, what
    does this actually bring and how can it enhance Lerna – or any other monorepo
    management tool?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期讨论 Lerna 时，我们没有提到的一个问题是 `lerna.json` 中有一个特殊键，称为 `useNx`，并配置为 `true`。这是
    Lerna *5* 中的一个新功能，现在由 Nx 背后的人维护——另一个流行的用于管理 monorepo 的解决方案。那么，这实际上带来了什么，以及它如何增强
    Lerna 或任何其他 monorepo 管理工具呢？
- en: With Lerna or without?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lerna 还是无需使用？
- en: Nx does not depend on Lerna and the use of Nx within Lerna is also optional.
    Therefore, the two technologies can be seen as non-exclusive – rather, they complete
    each other. In the end, it is your choice to decide which technologies you’d like
    to use. The example in this section, for instance, does not use Lerna.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 不依赖于 Lerna，并且在使用 Lerna 的情况下使用 Nx 也是可选的。因此，这两种技术可以被视为非排他性的——更确切地说，它们是互补的。最终，选择使用哪种技术由你决定。例如，本节中的示例没有使用
    Lerna。
- en: 'We start with a new repository again. This time, we’ll use the `nx-workspace`
    npm initializer provided by Nx:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从一个新的仓库开始。这次，我们将使用 Nx 提供的 `nx-workspace` npm 初始化器：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As with Turbo, we get a command-line survey. The initial preset (in this case,
    `react`) defines some of the questions that appear. There are other similarities
    to Turbo, too. For instance, running something is done via `nx`, such as the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Turbo 一样，我们得到了一个命令行调查问卷。初始预设（在这种情况下，`react`）定义了一些出现的问题。还有其他与 Turbo 相似之处。例如，通过
    `nx` 运行某些操作，如下所示：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will look for the Nx `build` task executor of the current application
    (in this case, `example`) in a given environment (by default, `production`). Here
    is an explicitly written example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在给定环境中（默认为 `production`）查找当前应用程序（在这种情况下，`example`）的 Nx `build` 任务执行器。以下是一个明确书写的示例：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The task executor is specified in the `project.json` of a package. Nx uses plugins
    to actually run these executors; in the case of our sample project with the `react`
    preset, the `@nrwl/webpack` package is used as the plugin.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 任务执行器在包的 `project.json` 中指定。Nx 使用插件来实际运行这些执行器；在我们的示例项目中，使用 `react` 预设时，使用 `@nrwl/webpack`
    包作为插件。
- en: In order for Nx to work, each package requires either a `package.json` or a
    `project.json` file. Both can be specified, too. In this case, Nx will actually
    merge them internally to get the desired configuration. Usually, you’d want a
    `package.json` if you wanted to use npm scripts. The `project.json` file contains
    Nx task executors, which are a bit more powerful, but unfortunately, are beyond
    the scope of this quick introduction.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Nx 能够工作，每个包都需要一个 `package.json` 或 `project.json` 文件。这两种文件都可以指定。在这种情况下，Nx
    实际上会内部合并它们以获得所需的配置。通常，如果你想使用 npm 脚本，你会想要一个 `package.json` 文件。`project.json` 文件包含
    Nx 任务执行器，它们功能更强大，但不幸的是，这些内容超出了本快速介绍的范畴。
- en: Let’s stop here and recap what we learned in this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里停下来，回顾一下本章所学的内容。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to organize multiple Node.js projects in a
    single repository known as a monorepo. You’ve seen different techniques and tools
    for maximizing efficiency and dealing with multiple packages and their dependencies.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在单个称为 monorepo 的仓库中组织多个 Node.js 项目。你看到了不同的技术和工具，用于最大化效率和处理多个包及其依赖项。
- en: You are now ready to deal with the largest code bases available. Independent
    of whether a code base just uses workspaces with one of the npm clients or some
    other tool such as Lerna on top of it, you are able to understand its structure,
    run commands, and add new packages in no time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好处理可用的最大代码库了。无论代码库是否仅使用 npm 客户端中的一个工作空间，或者在其之上使用 Lerna 等其他工具，你都能迅速理解其结构、运行命令和添加新包。
- en: In the next chapter, we will conclude with a look at WebAssembly, which not
    only offers a lot of flexibility for code running in the browser but can also
    be used to run arbitrary languages in Node.js.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将以对 WebAssembly 的探讨作为总结，它不仅为在浏览器中运行的代码提供了很多灵活性，还可以用于在 Node.js 中运行任意语言。
