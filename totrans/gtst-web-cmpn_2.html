<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Web Components Life Cycle Callback Methods</h1>
                </header>
            
            <article>
                
<p>In the last chapter, we talked about how to create a Web Component using vanilla JavaScript and HTML5. We discussed the specifications that are created in order to achieve the concept of Web Components. In this chapter, we will talk about life cycle events and the callback methods associated with them. A life cycle event is an event that occurs during the life cycle of a Web Component. This chapter deals with these events and how to access them with the help of callback methods.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li class="h1">Overview of life cycle callback methods</li>
<li class="h1">Life cycle callback methods currently available in Web Components</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of life cycle callback methods</h1>
                </header>
            
            <article>
                
<p>Life cycle events are events that are triggered inside a web component when it reaches a certain stage of execution. These stages reflect the overall process of creating a web component and can be controlled with the help of life cycle callback methods. Life cycle callback methods are hooks or interfaces that get called back whenever a Web Component goes through these life cycle events.</p>
<p>Let me explain this with the help of an example. Suppose you have a shoe that you would like to wear. There may be certain events associated with the life cycle of this shoe. Let's say you want to wear it. You put your foot in and tie the lace. This triggers an event called <kbd>lacesTied()</kbd>. Now, you as a user who is wearing this shoe may choose to act on it. You can write a conditional block to check whether <kbd>lacesTiedStrength &gt; 100</kbd> or whether <kbd>shoeSize &lt; requiredShoeSize</kbd>. It depends on what you want to do. Similarly, there are life cycle callback methods associated with a Web Component that help the user capture certain execution states and write code effectively.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of life cycle callback methods</h1>
                </header>
            
            <article>
                
<p>There are four life cycle callbacks available to Web Components as of now. These are as follows:</p>
<ul>
<li><kbd>connectedCallback()</kbd></li>
<li><kbd>disconnectedCallback()</kbd></li>
<li><kbd>adoptedCallback()</kbd></li>
<li><kbd>attributeChangedCallback()</kbd></li>
</ul>
<p>Let's discuss them in detail. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">connectedCallback()</h1>
                </header>
            
            <article>
                
<p>This interface/callback gets invoked every time a copy of a Web Component gets added to the DOM. This is very useful when it comes to initializing events associated with the DOM inside the component, or state management (see <span class="cdp-organizer-chapter-number"><a href="0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml">Chapter 5</a>,</span><span> </span><em><span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label">Managing States and Props</span></span></em>), or anything that needs any sort of initialization or pre-checks.</p>
<p>Let's take a look at an example. In <a href="a40f739f-c213-4862-a256-a7e76eff4370.xhtml">Chapter 1</a>, <em>Web Components Essentials and Specifications</em>, we talked about a <kbd>&lt;student-attendance-table&gt;</kbd> component, where the Web Component makes a fetch call to the file <kbd>student.json</kbd>, in order to retrieve the attendance data and then display that data in the form of a table.</p>
<p>The correct way to write that Web Component would be to add a <kbd>connectedCallback()</kbd> method to the definition of the <kbd>StudentAttendenceTable</kbd> class and then make the fetch call inside this callback. </p>
<p>This is what our code would look like:</p>
<pre>// StudentAttendanceTable.js<br/><br/>export default class StudentAttendanceTable extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>    this.innerText = this.getLoadingText();<br/>  }<br/><br/>  connectedCallback() {<br/>    // let's start our fetch call<br/>    this.getStudentList();<br/>  }<br/><br/>  getStudentList() {<br/>    // lets use fetch api<br/>    // https://developer.mozilla.org/en-US/docs/Web<br/>    // /API/Fetch_API/Using_Fetch<br/>    fetch('./student.json')<br/>    .then(response =&gt; {<br/><br/>      // converts response to json<br/>      return response.json();<br/><br/>    })<br/>    .then(jsonData =&gt; {<br/>      this.generateTable(jsonData);<br/>    })<br/>    .catch(e =&gt; {<br/><br/>      // lets set the error message for<br/>      // the user<br/>      this.innerText = this.getErrorText();<br/><br/>      // lets print out the error<br/>     // message for the devs<br/>      console.log(e);<br/>    });<br/><br/>  }<br/><br/>  generateTable(names) {<br/>    // lets loop through names<br/>    // with the help of map<br/>    let rows = names.map((data, index) =&gt; {<br/>      return this.getTableRow(index, data.name);<br/>    });<br/><br/>    // creating the table<br/>    let table = document.createElement('table');<br/>    table.innerHTML = rows.join('');<br/><br/>    // setting the table as html for this component<br/>    this.appendHTMLToShadowDOM(table);<br/>  }<br/><br/>  getTableRow(index, name) {<br/>    let tableRow = `&lt;tr&gt;<br/>        &lt;td&gt;${index + 1}&lt;/td&gt;<br/>        &lt;td&gt;${name}&lt;/td&gt;<br/>        &lt;td&gt;<br/>          &lt;input type="checkbox" name="${index}-attendance"/&gt;<br/>        &lt;/td&gt;<br/>      &lt;/tr&gt;`;<br/><br/>    return tableRow;<br/>  }<br/><br/>  appendHTMLToShadowDOM(html) {<br/>    // clearing out old html<br/>    this.innerHTML = '';<br/><br/>    let shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    // add a text node<br/>    shadowRoot.append(html);<br/>  }<br/><br/>  getLoadingText() {<br/>    return `loading..`;<br/>  }<br/><br/>  getErrorText() {<br/>    return `unable to retrieve student list.`;<br/>  }<br/>}</pre>
<p>As you can see in the code, we are now making a call to fetch the student list inside the <kbd>connectedCallback()</kbd> method. This makes sure that the code gets executed, once the Web Component is attached to the web page.</p>
<p>Another example of a place where using the <kbd>connectedCallback</kbd> is helpful is event handling. Let's say we have a Web Component that shows a custom button. And the purpose of this button is to show some text right next to it stating the number of times the button was clicked. If we try to use it without <kbd>connectedCallback</kbd>, it would look something like this:</p>
<pre>// CustomButton.js<br/><br/>export default class CustomButton extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>    // Initializing an initial state<br/>    this.timesClicked = 0;<br/><br/>    let template = `<br/>      &lt;button&gt;Click Me&lt;/button&gt;<br/>      &lt;span&gt;${this.getTimesClicked()}&lt;/span&gt;<br/>    `;<br/><br/>    this.innerHTML = template;<br/>  }<br/><br/>  connectedCallback() {<br/><br/>    // adding event handler to the button<br/>    this.querySelector('button')<br/>      .addEventListener('click', (e) =&gt; {<br/>        this.handleClick(e);<br/>      });<br/>  }<br/><br/>  handleClick() {<br/>    // updating the state<br/>    this.timesClicked++;<br/><br/>    this.querySelector('span')<br/>      .innerText = this.getTimesClicked();<br/>  }<br/><br/>  getTimesClicked() {<br/>    return `Times Clicked: ${this.timesClicked}`;<br/>  }<br/>}</pre>
<p>The associated HTML would look like this:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en" dir="ltr"&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Connected Callback Example&lt;/title&gt;<br/><br/>    &lt;!--<br/>      Notice how we use type="module"<br/>    --&gt;<br/>    &lt;script type="module"&gt;<br/><br/>      /// importing the first custom element<br/>      import CustomButton from './CustomButton.js';<br/><br/>      customElements.define('custom-button', CustomButton);<br/>    &lt;/script&gt;<br/><br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/><br/>    &lt;custom-button&gt;&lt;/custom-button&gt;<br/><br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Notice how an event listener is bound to the DOM in the <kbd>connectedCallback()</kbd> method. We will be talking about event listeners in detail in the <a href="0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml">Chapter 5</a>, <em>Managing States and Props</em>, but for now; we can use the code as an example. The preceding code makes sure that we bind a click event to the button only after the DOM is available on the page. This prevents us from creating event-related bugs, which I am sure has happened to every one of us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">disconnectedCallback()</h1>
                </header>
            
            <article>
                
<p>Just like there are certain operations that need to be performed when a Web Component is added to the DOM, there are certain operations that need to be performed after the component is removed from the DOM. The most common example of this scenario is, again, event handlers. Event handlers consume memory, and, when the DOM associated with them is removed, the event handler is still on the page, listening to events, still consuming memory. The callback, <kbd>disconnectedCallback()</kbd>, gives Web Components a way to write code that can handle these scenarios. </p>
<p>Let's take a look at the <kbd>&lt;custom-button&gt;</kbd> element and how we can use <kbd>disconnectedCallback()</kbd> to remove the attached event:</p>
<pre>// CustomButton.js<br/><br/>export default class CustomButton extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>    // Initializing an initial state<br/>    this.timesClicked = 0;<br/><br/>    let template = `<br/>      &lt;button&gt;Click Me&lt;/button&gt;<br/>      &lt;span&gt;${this.getTimesClicked()}&lt;/span&gt;<br/>    `;<br/><br/>    this.innerHTML = template;<br/>  }<br/><br/>  connectedCallback() {<br/><br/>    // adding event handler to the button<br/>    this.querySelector('button')<br/>      .addEventListener('click', this.handleClick.bind(this));<br/>  }<br/><br/>  disconnectedCallback() {<br/>    console.log('We are inside disconnectedCallback');<br/>    <br/>    // adding event handler to the button<br/>    this.querySelector('button')<br/>      .removeEventListener('click', this.handleClick);<br/>  }<br/><br/>  handleClick() {<br/>    // updating the state<br/>    this.timesClicked++;<br/><br/>    this.querySelector('span')<br/>      .innerText = this.getTimesClicked();<br/>  }<br/><br/>  getTimesClicked() {<br/>    return `Times Clicked: ${this.timesClicked}`;<br/>  }<br/>}</pre>
<p>If you look at the <kbd>disconnectedCallback()</kbd> method, we have a <kbd>console.log</kbd> statement and the code to remove the event. When you are running this Web Component on a page, you can manually remove the component and see that <kbd>disconnectedCallback()</kbd> gets called automatically. I prefer going to the <span class="packt_screen">dev</span> console and typing the following code to see it happen:</p>
<pre>document.querySelector('custom-button').remove();</pre>
<p>This will remove the first instance of <kbd>&lt;custom-button&gt;</kbd> from the page, thus triggering the <kbd>disconnectedCallback()</kbd> method.</p>
<p>Removing an event handler is only one of the uses. There can be <em>any</em> number of use cases that need to be performed before removing the Web Component from the DOM.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">adoptedCallback()</h1>
                </header>
            
            <article>
                
<p class="mce-root">This callback gets triggered when the Web Component is moved from one parent to another.</p>
<p>Just like we had <kbd>connectedCallback</kbd> and <kbd>disconnectedCallback</kbd>, we can write <kbd>adoptedCallback</kbd> in the following way:</p>
<pre>adoptedCallback() {<br/>  console.log('I am adopted');<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">attributeChangedCallback()</h1>
                </header>
            
            <article>
                
<p>Since all the custom elements act and behave like any other HTML element, they also have the ability to have attributes inside them. We will be discussing attributes in the coming chapter, but, for now, let's assume we have a custom element named <kbd>&lt;my-name&gt;</kbd>, whose purpose is to display the text <span class="packt_screen">Hello, my name is John Doe</span>.</p>
<p>So, the definition of this Web Component would become something like this:</p>
<pre>// MyName.js<br/><br/>export default class MyName extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>    this.innerText = 'Hello, my name is John Doe';<br/>  }<br/>}</pre>
<p class="mce-root">Now, let's say we want to have a different name. And for every different name, we will need to have a different definition of the custom element, making a totally different Web Component. In order to fix this problem, we can use attributes. We can pass the name in an attribute inside the HTML tag of this element, making it look like this:</p>
<pre>&lt;my-name fullname="John Doe"&gt;&lt;/my-name&gt;</pre>
<p>But, in order to make a Web Component use the attributes provided, we will first ask it to observe certain attributes, which we can provide in an array like this:</p>
<pre>static get observedAttributes() {<br/>  return ['fullname'];<br/>}</pre>
<p>Here, we are just going to observe <kbd>fullname</kbd>. You can add more as per your requirement. We will be diving into attributes in the coming chapters.</p>
<p>Once we have started observing these attributes, we can then use the <kbd>attributeChangedCallback()</kbd> to make necessary changes to custom elements as per the requirement. I am simply updating the name in the following callback: </p>
<pre>attributeChangedCallback(name, oldValue, newValue) {<br/>  if (name == 'fullname') {<br/>    this.innerText = 'Hello, my name is ' + newValue;<br/>  }<br/>}</pre>
<p>As you can see, <kbd>attributeChangedCallback()</kbd> takes in three parameters: <kbd>name</kbd>, which is the name of the attribute changed, and <kbd>oldValue</kbd> and <kbd>newValue</kbd>, which are the values before and after the change, respectively. </p>
<p>In the preceding code, we are simply checking whether the name of the attribute is <kbd>fullname</kbd> and updating the text to say the updated name.</p>
<p>The full component code looks like this:</p>
<pre>// MyName.js<br/><br/>export default class MyName extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>   this.innerText = 'Hello, my name is NO NAME';<br/>  }<br/><br/>  static get observedAttributes() {<br/>    return ['fullname'];<br/>  }<br/><br/>  attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name == 'fullname') {<br/>      this.innerText = 'Hello, my name is ' + newValue;<br/>    }<br/>  }<br/>}</pre>
<p>The <kbd>index.html</kbd> file associated with it becomes as follows:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en" dir="ltr"&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Attribute Changed Callback Example&lt;/title&gt;<br/><br/>    &lt;!--<br/>      Notice how we use type="module"<br/>    --&gt;<br/>    &lt;script type="module"&gt;<br/><br/>      /// importing the first custom element<br/>      import MyName from './MyName.js';<br/><br/>      customElements.define('my-name', MyName);<br/>    &lt;/script&gt;<br/><br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/><br/>    &lt;my-name fullname="John Doe"&gt;&lt;/my-name&gt;<br/><br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>As you can see, we are not doing anything different than what we have done in the previous sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we talked about what life cycle callback methods are and what purpose they serve. We talked about <kbd>connectedCallback()</kbd>, <kbd>disconnectedCallback()</kbd>, <kbd>adoptedCallback()</kbd>, and <kbd>attributeChangedCallback()</kbd>. We looked into various examples of how to use these callbacks and their practical uses.</p>
<p>In the next chapter, we will look into styling our Web Components with the help of CSS, and then we will talk about the gold standard checklist and its purpose.</p>


            </article>

            
        </section>
    </body></html>