<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-68" lang="en-GB"><a id="_idTextAnchor067"/>7</h1>
<h1 id="_idParaDest-69" lang="en-GB"><a id="_idTextAnchor068"/>Improving Reliability with Testing Tools</h1>
<p lang="en-GB">Now that we can actually write and build our code for the browser efficiently, it makes sense to also consider verifying the code’s output. Does it really fulfill the given requirements? Has anything changed in terms of the expected outcome? Does the code crash when unexpected values are passed in?</p>
<p lang="en-GB">What we need to answer these questions is testing. Testing can mean a lot of things – and depending on who you ask, you’ll get a different answer to the question “What should we test?” In this chapter, we’ll walk through the different options that interest us as developers. We’ll see what tools exist to automate these tests and how we can set them up and use them practically.</p>
<p lang="en-GB">We will start our journey into the testing space with a discussion on the beloved testing pyramid. We will then continue by learning about the types of test tools – most notably, pure runners and whole frameworks. Finally, we’ll cover some of the most popular tools in this space.</p>
<p lang="en-GB">By the end of this chapter, you will know which testing framework or test runner to choose for your programming needs, along with the pros and cons of each option.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Considering the testing pyramid</li>
<li lang="en-GB">Comparing test runners versus frameworks</li>
<li lang="en-GB">Using the Jest framework</li>
<li lang="en-GB">Using the Mocha framework</li>
<li lang="en-GB">Using the AVA test runner</li>
<li lang="en-GB">Using Playwright for visual tests</li>
<li lang="en-GB">Using Cypress for end-to-end testing</li>
</ul>
<h1 id="_idParaDest-70" lang="en-GB"><a id="_idTextAnchor069"/>Technical requirements</h1>
<p lang="en-GB">The complete source code for this chapter is available at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="https://bit.ly/3DW9yoV">https://bit.ly/3DW9yoV</a>.</p>
<h1 id="_idParaDest-71" lang="en-GB"><a id="_idTextAnchor070"/>Considering the testing pyramid</h1>
<p lang="en-GB">Over the years, more and more types of software testing have been identified and added to the standard repertoire of software projects and testing professionals such as quality assurance engineers. A powerful <a id="_idIndexMarker240"/>tool to categorize and order the most common types of software testing is the testing pyramid.</p>
<p lang="en-GB">The testing pyramid arranges the different types of testing by their visibility and effort. Higher layers of the pyramid require more effort but have greater visibility. Tests that are placed in the lower layers of the pyramid should be written a lot more – after all, these are the foundations of the pyramid.</p>
<p lang="en-GB">An illustration of the testing pyramid is shown in <em class="italic" lang="">Figure 7</em><em class="italic" lang="">.1</em>. The basis of the testing pyramid is formed by unit tests, which provide enough reliability to run components and integration tests on top <a id="_idIndexMarker241"/>of them later. Finally, UI tests (quite often referred to as end-to-end tests) can be run to verify that the solution works for end users:</p>
<div><div><img alt="Figure 7.1 – The testing pyramid with three layers of automatic testing " src="img/Figure_7.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The testing pyramid with three layers of automatic testing</p>
<p lang="en-GB">Usually, end-to-end tests refer to <a id="_idIndexMarker242"/>tests that use the interface as presented to the end user. In the case of a web application, this would be the actual website. By their nature, end-to-end tests are usually black-box tests. The whole system is treated as is, so with everything running as close to the production environment as possible.</p>
<p class="callout-heading" lang="en-GB">Black-box tests</p>
<p class="callout" lang="en-GB">The notion of a black box <a id="_idIndexMarker243"/>comes from the so-called black box approach. This is a common technique to analyze an open system by varying the input and measuring the output. This approach makes sense when the internal workings are either not known or not accessible. Likewise, black-box testing is also performed without changing the application’s internal workings.</p>
<p lang="en-GB">Variations of end-to-end tests focus on performance (<em class="italic" lang="">load tests</em>) or security (<em class="italic" lang="">penetration tests</em>). While the former can be quite tricky and expensive to run, the latter should be performed <a id="_idIndexMarker244"/>regularly to shield against potential attacks. One of the greatest risks for companies is to be hacked. Not only will this include the theft of precious data but it will also have a strong negative impact on the company’s brand. To help defend <a id="_idIndexMarker245"/>against scenarios like this, sometimes gray-box testing is used, which, unlike black-box tests, understands certain documented operations of the system.</p>
<p lang="en-GB">One challenge with testing is that many of the terms used, such as integration or component tests, are not universally defined. For instance, some people consider an integration test to be <a id="_idIndexMarker246"/>something very narrow – testing the integration with one external part at a time. Other people may say that an integration test should cover the integration with all the external parts. Consequently, it is quite important to carefully review and define these terms before using them in a project.</p>
<p lang="en-GB">When we refer to unit tests, we mean tests for a single unit (such as a function) of the project – only one specific <a id="_idIndexMarker247"/>part of it. Usually, this unit carries some logic that can be tested specifically. Everything that is not related to this one unit has to be controlled. While some unit tests can be written like black-box tests, most unit tests will require a detailed understanding of the internal workings. This way, the behavior of the tested unit can be controlled as required.</p>
<p lang="en-GB">Consider the following code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">pure.js</p>
<pre class="source-code" lang="en-GB">export function pickSmallestNumber(...numbers) {
  if (numbers.length &gt; 0) {
    return numbers.reduce(
      (currentMin, value) =&gt; Math.min(currentMin, value),
      Number.MAX_VALUE);
  }
  return undefined;
}</pre>
<p lang="en-GB">In the preceding code, the function is very well suited for a unit test:</p>
<ul>
<li lang="en-GB">It is exported, so we can access it from another module containing the tests.</li>
<li lang="en-GB">It does not use anything outside of the function – it’s a so-called pure function.</li>
<li lang="en-GB">The logic is sufficiently complex to test against a set of predefined test cases.</li>
</ul>
<p lang="en-GB">Unit tests for the <code>pickSmallestNumber</code> function could look as follows:</p>
<pre class="source-code" lang="en-GB">test('check if undefined is returned for no input', () =&gt; {
  const result = pickSmallestNumber();
  assert(result === undefined);
});
test('check if a single value is the smallest number',
  () =&gt; {
  const result = pickSmallestNumber(20);
  assert(result === 20);
});
test('check if 1 is smaller than 5', () =&gt; {
  const result = pickSmallestNumber(5, 1);
  assert(result === 1);
});
test('check if -1 is smaller than 0 but larger than -5',
  () =&gt; {
  const result = pickSmallestNumber(-1, -5, 0);
  assert(result === -5);
});</pre>
<p class="callout-heading" lang="en-GB">Note</p>
<p class="callout" lang="en-GB">As mentioned, the code could look like this. The functions used are defined nowhere and the preceding code would not run as presented.</p>
<p lang="en-GB">For these tests, we introduced a new function, <code>test</code>, which takes a description of the test and the code in the form of a function for running the test. We also introduced an assertion function, <code>assert</code>, which could be taken from the Node.js built into the <code>assert</code> module. The <a id="_idIndexMarker248"/>proposed <code>assert</code> function accepts a Boolean input – throwing an exception if the input is <code>false</code>. The testing tools and frameworks we’ll look at will replace these constructs with more expressive and elegant alternatives.</p>
<p lang="en-GB">Besides the actual testing and test area differences, the tooling choices also offer a few variations. One of the most crucial ones is the difference between a full testing framework and a test runner.</p>
<h1 id="_idParaDest-72" lang="en-GB"><a id="_idTextAnchor071"/>Comparing test runners versus frameworks</h1>
<p lang="en-GB">Historically, tests for JavaScript targeting web browsers could not be just written and run automatically. The <a id="_idIndexMarker249"/>main reason was that this involved dealing with a real browser. There was no way to just <em class="italic" lang="">pretend to run in the browser</em>. For this reason alone, the first tools in that space have either been scripts or whole websites evaluating JavaScript or browser automation tools. The latter actually forms its own category – being at the heart of modern end-to-end tests.</p>
<p lang="en-GB">The main driver for running the tests – historically, for starting everything that needs to be running to actually perform tests – is called a test runner. One of the first very successful test runners in the JavaScript space was <strong class="bold" lang="">Karma</strong>. The job of Karma was to spin up a server that runs <a id="_idIndexMarker250"/>a website hosting the tests, which are targeting JavaScript code that should run in a browser. Karma then opened available browsers to access the hosted website running the tests. The results were reported back to the server and shown in the console.</p>
<p lang="en-GB">If all this sounds complicated to you – you would be right, it was. The job of these runners was to make this process as reliable as possible. They also tried to be user-friendly and hide the underlying complexity as much as possible.</p>
<p lang="en-GB">Today, test runners like Karma are <a id="_idIndexMarker251"/>not really necessary. Instead, most test runners such as <strong class="bold" lang="">AVA</strong> stay in the console <a id="_idIndexMarker252"/>by leveraging Node.js. When JavaScript code requires the browser API, which is most like the DOM API, the runner just emulates these missing APIs. As a result of the emulation, the JavaScript code that is tested can run as it would in the browser, but everything remains in Node.js.</p>
<p lang="en-GB">While the part about emulating the DOM API sounds great, it is actually not within the scope of a test runner. Test <a id="_idIndexMarker253"/>runners are really only focused on running the tests. Instead, developers establish the emulation part somewhat or pick a full test framework. A full test framework should already have figured out things such as the DOM API emulation so that they can be easily added, or they are already part of the standard installation.</p>
<p lang="en-GB">A full test framework not <a id="_idIndexMarker254"/>only includes a test runner but also things <a id="_idIndexMarker255"/>such as an assertion library. So far, we’ve only used some kind of <code>assert</code> function with a proposed behavior. A full assertion library would give us a set of functions that makes the debugging process in the case of a failed assertion quite easy. Already from the test output, we would see which assertion was broken – and why.</p>
<p lang="en-GB">An example of a good assertion library is <code>should</code>, <code>expect</code>, and <code>assert</code>. The <a id="_idIndexMarker256"/>export that you see most often used in test code is <code>expect</code>.</p>
<p lang="en-GB">Using <code>expect</code> from the <code>chai</code> package, the first two test cases from our preceding unit tests could be rewritten as follows:</p>
<pre class="source-code" lang="en-GB">test('check if undefined is returned for no input', () =&gt; {
  const result = pickSmallestNumber();
  expect(result).to.be.undefined;
});
test('check if a single value is the smallest number',
  () =&gt; {
  const result = pickSmallestNumber(20);
  expect(result).to.equal(20);
});</pre>
<p lang="en-GB">The beauty of the rewritten code is that it almost reads like text. Even somebody with less experience in <a id="_idIndexMarker257"/>the testing framework, JavaScript, or Node.js could <a id="_idIndexMarker258"/>identify what the test does – and even more importantly – what it tries to verify. The chaining of the expectation using the member (<code>.</code>) operator is one of the things that makes Chai such a popular assertion library.</p>
<p lang="en-GB">Every testing framework comes with an assertion library. Some frameworks may even let the user decide which assertion library to use.</p>
<p lang="en-GB">Now that we know all the basics of testing JavaScript-based applications, we should explore some of the tools to actually implement such tests. We will start with one of the most commonly used testing utilities: the Jest test framework.</p>
<h1 id="_idParaDest-73" lang="en-GB"><a id="_idTextAnchor072"/>Using the Jest framework</h1>
<p lang="en-GB"><strong class="bold" lang="">Jest</strong> is a modern test framework <a id="_idIndexMarker259"/>that was authored by Facebook to fully leverage Node.js for running tests. It should have the power to run all the tests required at Facebook without requiring a diploma in engineering to understand, control, or modify it.</p>
<p lang="en-GB">To use Jest, you <a id="_idIndexMarker260"/>need to install the <code>jest</code> package from npm:</p>
<pre class="console" lang="en-GB">
$ npm install jest --save-dev</pre>
<p lang="en-GB">This allows you to use the <code>jest</code> command-line utility. Ideally, run it with <code>npx</code> as we did with the other tools:</p>
<pre class="console" lang="en-GB">
$ npx jest</pre>
<p lang="en-GB">Jest can be configured by providing a <code>jest.config.js</code> file. The easiest way to create this kind of file is by using the <code>jest</code> tool with the --<code>init</code> flag. This will guide us through some questions to create a suitable configuration:</p>
<pre class="console" lang="en-GB">
$ npx jest --init

The following questions will help Jest to create a suitable configuration for your project

<img alt="" src="img/014.png"/> Would you like to use Jest when running "test" script in "package.json"? … yes

<img alt="" src="img/014.png"/> Would you like to use Typescript for the configuration file? … no

<img alt="" src="img/014.png"/> Choose the test environment that will be used for testing › jsdom (browser-like)

<img alt="" src="img/014.png"/> Do you want Jest to add coverage reports? … no

<img alt="" src="img/014.png"/> Which provider should be used to instrument code for coverage? › v8

<img alt="" src="img/014.png"/> Automatically clear mock calls, instances, contexts and results before every test? … yes

<img alt="" src="img/021.png"/>  Modified /home/node/example/Chapter07/package.json

<img alt="" src="img/031.png"/>  Configuration file created at /home/node/example/Chapter07/jest.config.js</pre>
<p lang="en-GB">In this case, we’ve instructed Jest to change the <code>test</code> script in <code>package.json</code>. Now, when we run <code>npm run test</code> or just <code>npm test</code> in our terminal for the current project, Jest will start. The options <a id="_idIndexMarker261"/>for the test environment and coverage are interesting to us.</p>
<p lang="en-GB">Let’s have a look at the essential parts of the generated configuration file:</p>
<pre class="source-code" lang="en-GB">module.exports = {
  clearMocks: true,
  coverageProvider: "v8",
  testEnvironment: "jsdom",
};</pre>
<p lang="en-GB">The generated configuration file also contains a lot of comments and commented-out options. This way, you can configure Jest without having to consult the official documentation website.</p>
<p lang="en-GB">The given configuration has just one problem… The selected <code>jsdom</code> environment only works when a special package called <code>jest-environment-jsdom</code> is installed. This has been changed in version <em class="italic" lang="">28</em> of Jest and is, unfortunately, not done automatically:</p>
<pre class="console" lang="en-GB">
$ npm install jest-environment-jsdom --save-dev</pre>
<p lang="en-GB">Luckily, the error messages in Jest are usually quite good and very helpful. Even without knowing these things, we’ll get proper messages that tell us exactly what to do.</p>
<p lang="en-GB">One last thing we should consider is using Babel for code transformations. These transformations are <a id="_idIndexMarker262"/>unnecessary if we write pure Node.js-compatible code (such as by using CommonJS). Otherwise, code transformations are necessary. In general, Jest uses code transformations to make any kind of used code – not only plain JavaScript but also flavors such as TypeScript and Flow – usable without requiring special treatment upfront.</p>
<p lang="en-GB">First, let’s install the <code>babel-jest</code> plugin and the required <code>@</code><code>babel/core</code> package:</p>
<pre class="console" lang="en-GB">
$ npm install babel-jest @babel/core @babel/preset-env --save-dev</pre>
<p lang="en-GB">Now, let’s extend <code>jest.config.js</code> with the <code>transform</code> configuration section:</p>
<pre class="source-code" lang="en-GB">module.exports = {
  // as beforehand
  "transform": {
    "\\.js$": "babel-jest",
  },
};</pre>
<p lang="en-GB">The new section tells Jest to use the <code>babel-jest</code> transformer for all files ending with <code>.js</code>. Also add a <code>.babelrc</code> file as discussed in <a href="B18989_04.xhtml#_idTextAnchor042"><em class="italic" lang="">Chapter 4</em></a>, <em class="italic" lang="">Using Different Flavors </em><em class="italic" lang="">of JavaScript</em>:</p>
<pre class="source-code" lang="en-GB">{
  "presets": ["@babel/preset-env"]
}</pre>
<p lang="en-GB">With this <a id="_idIndexMarker263"/>configuration, Babel will properly transform the given files. The test code can now be written as follows:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">pure.test.js</p>
<pre class="source-code" lang="en-GB">import { pickSmallestNumber } from "./pure";
it("check if undefined is returned for no input", () =&gt; {
  const result = pickSmallestNumber();
  expect(result).toBeUndefined();
});
it("check if a single value is the smallest number", () =&gt; {
  const result = pickSmallestNumber(20);
  expect(result).toBe(20);
});
it("check if 1 is smaller than 5", () =&gt; {
  const result = pickSmallestNumber(5, 1);
  expect(result).toBe(1);
});
it("check if -1 is smaller than 0 but larger than -5",
  () =&gt; {
  const result = pickSmallestNumber(-1, -5, 0);
  expect(result).toBe(-1);
});</pre>
<p lang="en-GB">While Jest also <a id="_idIndexMarker264"/>supports a <code>test</code> function as in our pseudo implementation introduced in the <em class="italic" lang="">Considering the testing pyramid section</em>, the <code>it</code> function is much more commonly seen. Note that Jest comes with its own integrated <a id="_idIndexMarker265"/>assertion library, which uses the <code>expect</code> function. The <code>expect</code> function is also called a <strong class="bold" lang="">matcher</strong>.</p>
<p class="callout-heading" lang="en-GB">Matchers</p>
<p class="callout" lang="en-GB">For our simple example, the matcher will only have to deal with strings and numbers. In general, however, any kind <a id="_idIndexMarker266"/>of JavaScript input, such as arrays or objects, can be matched and asserted. The <code>expect</code> function has some helpers to deal with, for instance, object equality (<code>toBe</code>), as in, having the same reference, and equivalence (<code>toEqual</code>), as in, having the same content.</p>
<p lang="en-GB">Let’s run this:</p>
<pre class="console" lang="en-GB">
$ npm run test

&gt; Chapter07@1.0.0 test /home/node/example/Chapter07

&gt; jest

 PASS  src/pure.test.js

  <img alt="" src="img/014.png"/> check if undefined is returned for no input (2 ms)

  <img alt="" src="img/014.png"/> check if a single value is the smallest number (1 ms)

  <img alt="" src="img/014.png"/> check if 1 is smaller than 5

  <img alt="" src="img/014.png"/> check if -1 is smaller than 0 but larger than -5

Test Suites: 1 passed, 1 total

Tests:       4 passed, 4 total

Snapshots:   0 total

Time:        0.818 s, estimated 1 s

Ran all test suites.</pre>
<p lang="en-GB">Great – our code works. By default, Jest will look for all files ending with <code>.test.js</code>. By convention, <code>.spec.js</code> files would also work. The convention used can be changed though.</p>
<p lang="en-GB">Today, Jest is arguably <a id="_idIndexMarker267"/>the most used testing framework. However, especially older projects potentially use something else. A very solid and common occurrence here is Mocha. Like Jest, it is also a testing framework, but with a few key differences.</p>
<h1 id="_idParaDest-74" lang="en-GB"><a id="_idTextAnchor073"/>Using the Mocha framework</h1>
<p lang="en-GB"><code>jsdom</code>.</p>
<p lang="en-GB">To use Mocha, you <a id="_idIndexMarker269"/>need to install the <code>mocha</code> package from npm:</p>
<pre class="console" lang="en-GB">
$ npm install mocha --save-dev</pre>
<p lang="en-GB">This allows you to use the <code>mocha</code> command-line utility. Ideally, run it with <code>npx</code> as we did with the other tools:</p>
<pre class="console" lang="en-GB">
$ npx mocha</pre>
<p lang="en-GB">At this point, not much is working. By default, Mocha follows a different convention from Jest. Here, we need to specify a different pattern or place our tests in a folder named <code>test</code>.</p>
<p lang="en-GB">What we definitely need to do is to include Babel for code transformations. This works a bit differently than with Jest. Instead of a dedicated plugin, we only integrate the <code>@babel/register</code> package, which will automatically transform any code when a module is loaded:</p>
<pre class="console" lang="en-GB">
$ npm install --save-dev @babel/register @babel/core @babel/preset-env</pre>
<p lang="en-GB">Now, we can copy the <code>.babelrc</code> file that we used previously with Jest. For Mocha, the configuration can be placed in a file called <code>.mocharc.js</code>. Setting up the configuration file to always require the <code>@babel/register</code> package first looks like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">.mocharc.js</p>
<pre class="source-code" lang="en-GB">module.exports = {
  require: "@babel/register",
};</pre>
<p lang="en-GB">Mocha is a kind of special testing framework, as it does not come with an assertion library. Instead, it <a id="_idIndexMarker270"/>relies on other assertion libraries. As long as it throws an exception in case of a mismatch, the assertion works.</p>
<p lang="en-GB">To write tests with Mocha without using a special assertion library besides the one that already comes with Node.js, we would write our tests as follows:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">pure.test.js</p>
<pre class="source-code" lang="en-GB">import { equal } from "assert";
import { pickSmallestNumber } from "../src/pure";
it("check if undefined is returned for no input", () =&gt; {
  const result = pickSmallestNumber();
  equal(result, undefined);
});
it("check if a single value is the smallest number", () =&gt; {
  const result = pickSmallestNumber(20);
  equal(result, 20);
});
it("check if 1 is smaller than 5", () =&gt; {
  const result = pickSmallestNumber(5, 1);
  equal(result, 1);
});
it("check if -1 is smaller than 0 but larger than -5",
  () =&gt; {
  const result = pickSmallestNumber(-1, -5, 0);
  equal(result, -5);
});</pre>
<p lang="en-GB">In the <a id="_idIndexMarker271"/>preceding code, the <code>it</code> functions follow the same behavior as in Jest.</p>
<p lang="en-GB">Now, let us run <code>mocha</code> via <code>npm test</code>:</p>
<pre class="console" lang="en-GB">
$ npm run test

&gt; example02@1.0.0 test /home/node/example/Chapter07/example02

&gt; mocha

  <img alt="" src="img/014.png"/> check if undefined is returned for no input

  <img alt="" src="img/014.png"/> check if a single value is the smallest number

  <img alt="" src="img/014.png"/> check if 1 is smaller than 5

  <img alt="" src="img/014.png"/> check if -1 is smaller than 0 but larger than -5

  4 passing (3ms)</pre>
<p lang="en-GB">Compared to Jest, we get a little bit less output. Still, all the relevant information is presented and if there were an error, we would have gotten all the necessary information to identify and fix the issue. The crucial difference between Jest and Mocha is that Jest really <a id="_idIndexMarker272"/>breaks down the tests according to their associated test module, while Mocha just presents the results.</p>
<p lang="en-GB">Mocha is actually quite feature-packed and everything but lightweight. A more streamlined option is to avoid using a full testing framework and instead go for a test runner only. One option is to use AVA.</p>
<h1 id="_idParaDest-75" lang="en-GB"><a id="_idTextAnchor074"/>Using the AVA test runner</h1>
<p lang="en-GB">AVA is a modern test runner <a id="_idIndexMarker273"/>for Node.js. It stands out because of its ability to embrace new JavaScript language features and cutting-edge properties of Node.js, such as process isolation. In this way, AVA executes tests very quickly and reliably.</p>
<p lang="en-GB">To use AVA, you <a id="_idIndexMarker274"/>need to install the <code>ava</code> package from npm:</p>
<pre class="console" lang="en-GB">
$ npm install ava --save-dev</pre>
<p lang="en-GB">This allows you to use the <code>ava</code> command-line utility. Ideally, run it with <code>npx</code> as we did with the other tools:</p>
<pre class="console" lang="en-GB">
$ npx ava</pre>
<p lang="en-GB">While Mocha and Jest could also be installed globally, AVA only works in projects as a local dependency. As this is the better setup anyway, there should be no practical downside from this constraint.</p>
<p lang="en-GB">As mentioned, AVA is built quite closely on Node.js – following its conventions and rules wherever possible. In this regard, AVA also allows us quite quickly to adapt ESM instead of CommonJS. By modifying <code>package.json</code> for the project, we get immediate support for using ESM in our tests, too:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
<pre class="source-code" lang="en-GB">{
  // like beforehand
  "type": "module",
  // ...
}</pre>
<p lang="en-GB">By default, AVA looks for files that follow the same pattern as Jest. Therefore, files that end with <code>.test.js</code> and <code>.spec.js</code> will be found among others. There is no need to configure AVA or place the tests in a separate directory.</p>
<p lang="en-GB">The other thing that AVA does is to provide a function as a default export from the <code>ava</code> package. This function <a id="_idIndexMarker275"/>is needed to declare tests. Each test then receives a so-called test context as a callback parameter for its implementation. This way, AVA feels a lot more explicit and less magical than the other solutions.</p>
<p lang="en-GB">Let’s see how we can write the tests with AVA:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">pure.test.js</p>
<pre class="source-code" lang="en-GB">import test from 'ava';
import { pickSmallestNumber } from "./pure.js";
test("check if undefined is returned for no input", (t) =&gt; {
  const result = pickSmallestNumber();
  t.is(result, undefined);
});
test("check if a single value is the smallest number",
  (t) =&gt; {
  const result = pickSmallestNumber(20);
  t.is(result, 20);
});
test("check if 1 is smaller than 5", (t) =&gt; {
  const result = pickSmallestNumber(5, 1);
  t.is(result, 1);
});
test("check if -1 is smaller than 0 but larger than -5",
  (t) =&gt; {
  const result = pickSmallestNumber(-1, -5, 0);
  t.is(result, -5);
});</pre>
<p lang="en-GB">Overall, the structure is similar to the previous two full frameworks. Still, AVA is just a runner and misses things such as special assertion libraries, options for mocking, and snapshots, among other things.</p>
<p lang="en-GB">To run the tests, we <a id="_idIndexMarker276"/>can adjust the <code>test</code> script in <code>package.json</code>. Triggering the <code>ava</code> utility, a run with the AVA test runner looks like this:</p>
<pre class="console" lang="en-GB">
$ npm run test

&gt; example03@1.0.0 test /Users/node/example/Chapter07/example03

&gt; ava

  <img alt="" src="img/014.png"/> check if undefined is returned for no input

  <img alt="" src="img/014.png"/> check if a single value is the smallest number

  <img alt="" src="img/014.png"/> check if 1 is smaller than 5

  <img alt="" src="img/014.png"/> check if -1 is smaller than 0 but larger than -5

  ─

  4 tests passed</pre>
<p lang="en-GB">Now that we covered <a id="_idIndexMarker277"/>three tools to run some code-centric tests, let’s explore some options for running UI tests, too. We will start with <strong class="bold" lang="">Playwright</strong>, which is a modern library to automate the behavior of web browsers such as Google Chrome or Firefox.</p>
<h1 id="_idParaDest-76" lang="en-GB"><a id="_idTextAnchor075"/>Using Playwright for visual tests</h1>
<p lang="en-GB">Node.js is not <a id="_idIndexMarker278"/>only a great basis for running logical tests but <a id="_idIndexMarker279"/>also for verifying visuals, such as those of a website running in a browser. A modern approach for browser automation is Playwright.</p>
<p lang="en-GB">To use Playwright, you need to install the <code>playwright</code> package from npm:</p>
<pre class="console" lang="en-GB">
$ npm install playwright --save-dev</pre>
<p lang="en-GB">The <code>playwright</code> package enables you to use Playwright in an existing application, which could also be inside existing tests such as unit tests executed with Jest using the <code>jest-playwright-preset</code> package.</p>
<p lang="en-GB">An even better setup can be achieved by using the <code>@playwright/test</code> test runner package:</p>
<pre class="console" lang="en-GB">
$ npm install @playwright/test --save-dev</pre>
<p lang="en-GB">This allows you to use the <code>playwright</code> command-line utility. Ideally, run it with <code>npx</code> as we did with the other tools:</p>
<pre class="console" lang="en-GB">
$ npx playwright test</pre>
<p lang="en-GB">Running this will look for all files matching the same conventions as previously noted in the Jest and AVA sections. Every file ending with <code>.test.js</code> or <code>.spec.js</code> will be included. Additionally, the <a id="_idIndexMarker280"/>Playwright test runner is also capable of <a id="_idIndexMarker281"/>evaluating TypeScript files. The runner therefore also includes <code>.test.ts</code> and <code>.spec.ts</code> files in its default lookup.</p>
<p lang="en-GB">Let’s look at a simple test run again. We’ll run tests against a public website available at <a href="https://microfrontends.art">https://microfrontends.art</a>. The test would work against a local website running on localhost, too:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">mf.test.ts</p>
<pre class="source-code" lang="en-GB">import { test, expect } from '@playwright/test';
test('homepage has micro frontends in the title and in an
  h1', async ({ page }) =&gt; {
  await page.goto('https://microfrontends.art/');
  // Expect the title "to contain" a substring.
  await expect(page).toHaveTitle(/Micro Frontends/);
  // Grab an element ("h1")
  const h1 = page.locator('h1');
  // Expect the element to have a specific text
  await expect(h1)
    .toHaveText('The Art of Micro Frontends');
});</pre>
<p lang="en-GB">The structure feels a bit similar to AVA. As with AVA, we are using explicit imports to create the test <a id="_idIndexMarker282"/>infrastructure. We also need to use the parameter <a id="_idIndexMarker283"/>of the test’s callback to actually do something useful with the website using the <code>page</code> object.</p>
<p lang="en-GB">Let’s change the <code>test</code> script in <code>package.json</code> and run the test provided:</p>
<pre class="console" lang="en-GB">
$ npm run test

&gt; example04@1.0.0 test /Users/node/example/Chapter07/example04

&gt; playwright test

Running 1 test using 1 worker

  <img alt="" src="img/014.png"/>  1 tests/mf.test.ts:3:1 › homepage has Playwright in title and get started link linking to the intro page (491ms)

  1 passed (5s)</pre>
<p lang="en-GB">Yet another option to write end-to-end tests is Cypress. This promises to be even more convenient and also equipped to test individual components, too.</p>
<h1 id="_idParaDest-77" lang="en-GB"><a id="_idTextAnchor076"/>Using Cypress for end-to-end testing</h1>
<p lang="en-GB">Cypress is a focused, end-to-end testing <a id="_idIndexMarker284"/>framework that also comes with the ability to test individual UI components. It tries to be different by mostly avoiding browser automation. Instead, its test runner is located directly inside the browser.</p>
<p lang="en-GB">To use Cypress, you <a id="_idIndexMarker285"/>need to install the <code>cypress</code> package <a id="_idIndexMarker286"/>from npm:</p>
<pre class="console" lang="en-GB">
$ npm install cypress --save-dev</pre>
<p lang="en-GB">This allows you to use the <code>cypress</code> command-line utility. Ideally, run it with <code>npx</code> as we did with the other tools:</p>
<pre class="console" lang="en-GB">
$ npx cypress open</pre>
<p lang="en-GB">Cypress is at its heart a graphical tool. As such, we are first introduced to a small configurator that allows us to set up our project. The configurator is shown in <em class="italic" lang="">Figure 7</em><em class="italic" lang="">.2</em>. Picking <strong class="bold" lang="">E2E Testing</strong> will give you the ability to influence what files are written:</p>
<div><div><img alt="Figure 7.2 – The Cypress configurator on opening it for the first time " src="img/Figure_7.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The Cypress configurator on opening it for the first time</p>
<p lang="en-GB">The configurator also lets you pick a browser where the tests should actually be run. Right now, <strong class="bold" lang="">Chrome</strong>, <strong class="bold" lang="">Edge</strong>, <strong class="bold" lang="">Electron</strong>, and <strong class="bold" lang="">Firefox</strong> are supported.</p>
<p lang="en-GB">At this time, we can <a id="_idIndexMarker287"/>add our first test – in the context of Cypress, referred <a id="_idIndexMarker288"/>to as a spec or specification. We’ll use the same kind of test that we’ve added as an example for Playwright:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">mf.cy.js</p>
<pre class="source-code" lang="en-GB">describe("empty spec", () =&gt; {
  it("passes", () =&gt; {
    cy.visit("https://microfrontends.art");
    // Expect the title "to contain" a substring.
    cy.title().should("contain", "Micro Frontends");
    // Expect the h1 element to have a specific text.
    cy.get("h1").should("have.text",
      "The Art of Micro Frontends")
  });
});</pre>
<p lang="en-GB">As seen in the preceding small test, the whole test structure is implicit. The main downside of this is that there is no good IDE support to help with proper typing – that is, type information that can be used by TypeScript. A good way out of it is to install the <code>typescript</code> package in the project and create a <code>tsconfig.json</code> that teaches TypeScript about Cypress:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">tsconfig.json</p>
<pre class="source-code" lang="en-GB">{
  "compilerOptions": {
    "target": "es5",
    "lib": ["es5", "dom"],
    "types": ["cypress", "node"]
  },
  "include": ["**/*.ts"]
}</pre>
<p lang="en-GB">Now, you can rename the test file to end with <code>.ts</code> (in our example, <code>mf.cy.ts</code>) and enjoy improved autocompletion in most editors and IDEs.</p>
<p lang="en-GB">Running this test will yield a graphical result. In <em class="italic" lang="">Figure 7</em><em class="italic" lang="">.3</em>, you can see the output from running the <a id="_idIndexMarker289"/>test in the selected browser. This is the key point <a id="_idIndexMarker290"/>of Cypress. An end-to-end test never leaves the visual area and allows us to directly interact with the test within its visual boundaries. This makes tests written with Cypress not only very beginner-friendly but also quite easy to debug:</p>
<div><div><img alt="Figure 7.3 – Running the test directly in the browser " src="img/Figure_7.3_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Running the test directly in the browser</p>
<p lang="en-GB">If you want to <a id="_idIndexMarker291"/>run the locally available tests directly and <a id="_idIndexMarker292"/>without visual interaction, then you can also use the <code>run</code> command:</p>
<pre class="console" lang="en-GB">
$ npx cypress run</pre>
<p lang="en-GB">This is especially handy in non-local environments, such as a CI/CD pipeline for validating software builds.</p>
<p lang="en-GB">With this in mind, let’s recap what we learned in this chapter.</p>
<h1 id="_idParaDest-78" lang="en-GB"><a id="_idTextAnchor077"/>Summary</h1>
<p lang="en-GB">In this chapter, you learned about which different types of testing we can automate and how important these types are for software projects to succeed. You’ve seen the popular tools that exist to help us cover our projects. By following the testing pyramid, you should be able to decide what tests you need to focus on to make your project as reliable as possible.</p>
<p lang="en-GB">By using the power test frameworks such as Jest or Mocha or a flexible runner such as AVA, you can automate a lot of different things – from unit tests to full end-to-end tests. Dedicated end-to-end test frameworks such as Playwright or Cypress also come with their own runners – which makes sense for complex visual tests in particular. In the unit and integration testing space, Jest comes in handy. It also allows us to quickly integrate other flavors of JavaScript or customize a lot of different features.</p>
<p lang="en-GB">In the next chapter, we will finally also publish our own packages – to the public registry and other custom registries.</p>
</div>


<div><h1 id="_idParaDest-79" lang="en-GB"><a id="_idTextAnchor078"/>Part 3: Advanced Topics</h1>
<p lang="en-GB">In this part, you’ll dive into advanced topics such as publishing your own npm packages and structuring your projects into a shared code base such as a monorepo. You’ll see what options exist and how tools such as Nx, Lerna, or Turbo can help you set up projects that can scale.</p>
<p lang="en-GB">To round off your knowledge about Node.js and its ecosystem, this part will also teach you how to make use of any kind of code compiled as WebAssembly within Node.js, as well as which other runtimes can be used as the basis for web development tooling.</p>
<p lang="en-GB">This part of the book comprises the following chapters:</p>
<ul>
<li lang="en-GB"><a href="B18989_08.xhtml#_idTextAnchor079"><em class="italic" lang="">Chapter 8</em></a>, <em class="italic" lang="">Publishing npm Packages</em></li>
<li lang="en-GB"><a href="B18989_09.xhtml#_idTextAnchor088"><em class="italic" lang="">Chapter 9</em></a>, <em class="italic" lang="">Structuring Code in Monorepos</em></li>
<li lang="en-GB"><a href="B18989_10.xhtml#_idTextAnchor098"><em class="italic" lang="">Chapter 10</em></a>, <em class="italic" lang="">Integrating Native Code with WebAssembly</em></li>
<li lang="en-GB"><a href="B18989_11.xhtml#_idTextAnchor105"><em class="italic" lang="">Chapter 11</em></a><em class="italic" lang="">,</em> <em class="italic" lang="">Using Alternative Runtimes</em></li>
</ul>
</div>
<div><div></div>
</div>
</body></html>