<html><head></head><body>
<div id="_idContainer095">
<h1 class="chapter-number" id="_idParaDest-68" lang="en-GB"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-69" lang="en-GB"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.2.1">Improving Reliability with Testing Tools</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.3.1">Now that we can actually write and build our code for the browser efficiently, it makes sense to also consider verifying the code’s output. </span><span class="koboSpan" id="kobo.3.2">Does it really fulfill the given requirements? </span><span class="koboSpan" id="kobo.3.3">Has anything changed in terms of the expected outcome? </span><span class="koboSpan" id="kobo.3.4">Does the code crash when unexpected values are </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.4.1">passed in?</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.5.1">What we need to answer these questions is testing. </span><span class="koboSpan" id="kobo.5.2">Testing can mean a lot of things – and depending on who you ask, you’ll get a different answer to the question “What should we test?” </span><span class="koboSpan" id="kobo.5.3">In this chapter, we’ll walk through the different options that interest us as developers. </span><span class="koboSpan" id="kobo.5.4">We’ll see what tools exist to automate these tests and how we can set them up and use </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.6.1">them practically.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.7.1">We will start our journey into the testing space with a discussion on the beloved testing pyramid. </span><span class="koboSpan" id="kobo.7.2">We will then continue by learning about the types of test tools – most notably, pure runners and whole frameworks. </span><span class="koboSpan" id="kobo.7.3">Finally, we’ll cover some of the most popular tools in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.8.1">this space.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.9.1">By the end of this chapter, you will know which testing framework or test runner to choose for your programming needs, along with the pros and cons of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.10.1">each option.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.11.1">We will cover the following key topics in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.12.1">this chapter:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.13.1">Considering the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.14.1">testing pyramid</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.15.1">Comparing test runners </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.16.1">versus frameworks</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.17.1">Using the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.18.1">Jest framework</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.19.1">Using the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.20.1">Mocha framework</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.21.1">Using the AVA </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.22.1">test runner</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.23.1">Using Playwright for </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.24.1">visual tests</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.25.1">Using Cypress for </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.26.1">end-to-end testing</span></span></li>
</ul>
<h1 id="_idParaDest-70" lang="en-GB"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.28.1">The complete source code for this chapter is available </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.29.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.30.1">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter07</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.32.1">The CiA videos for this chapter can be accessed </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.33.1">at </span></span><a href="https://bit.ly/3DW9yoV"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.34.1">https://bit.ly/3DW9yoV</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<h1 id="_idParaDest-71" lang="en-GB"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.36.1">Considering the testing pyramid</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.37.1">Over the years, more and more types of software testing have been identified and added to the standard repertoire of software projects and testing professionals such as quality assurance engineers. </span><span class="koboSpan" id="kobo.37.2">A powerful </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.38.1">tool to categorize and order the most common types of software testing is the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.39.1">testing pyramid.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.40.1">The testing pyramid arranges the different types of testing by their visibility and effort. </span><span class="koboSpan" id="kobo.40.2">Higher layers of the pyramid require more effort but have greater visibility. </span><span class="koboSpan" id="kobo.40.3">Tests that are placed in the lower layers of the pyramid should be written a lot more – after all, these are the foundations of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.41.1">the pyramid.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.42.1">An illustration of the testing pyramid is shown in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.43.1">Figure 7</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.44.1">.1</span></em><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">The basis of the testing pyramid is formed by unit tests, which provide enough reliability to run components and integration tests on top </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.46.1">of them later. </span><span class="koboSpan" id="kobo.46.2">Finally, UI tests (quite often referred to as end-to-end tests) can be run to verify that the solution works for </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.47.1">end users:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.48.1"><img alt="Figure 7.1 – The testing pyramid with three layers of automatic testing " src="image/Figure_7.1_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.49.1">Figure 7.1 – The testing pyramid with three layers of automatic testing</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.50.1">Usually, end-to-end tests refer to </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.51.1">tests that use the interface as presented to the end user. </span><span class="koboSpan" id="kobo.51.2">In the case of a web application, this would be the actual website. </span><span class="koboSpan" id="kobo.51.3">By their nature, end-to-end tests are usually black-box tests. </span><span class="koboSpan" id="kobo.51.4">The whole system is treated as is, so with everything running as close to the production environment </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.52.1">as possible.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.53.1">Black-box tests</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.54.1">The notion of a black box </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.55.1">comes from the so-called black box approach. </span><span class="koboSpan" id="kobo.55.2">This is a common technique to analyze an open system by varying the input and measuring the output. </span><span class="koboSpan" id="kobo.55.3">This approach makes sense when the internal workings are either not known or not accessible. </span><span class="koboSpan" id="kobo.55.4">Likewise, black-box testing is also performed without changing the application’s </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.56.1">internal workings.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.57.1">Variations of end-to-end tests focus on performance (</span><em class="italic" lang=""><span class="koboSpan" id="kobo.58.1">load tests</span></em><span class="koboSpan" id="kobo.59.1">) or security (</span><em class="italic" lang=""><span class="koboSpan" id="kobo.60.1">penetration tests</span></em><span class="koboSpan" id="kobo.61.1">). </span><span class="koboSpan" id="kobo.61.2">While the former can be quite tricky and expensive to run, the latter should be performed </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.62.1">regularly to shield against potential attacks. </span><span class="koboSpan" id="kobo.62.2">One of the greatest risks for companies is to be hacked. </span><span class="koboSpan" id="kobo.62.3">Not only will this include the theft of precious data but it will also have a strong negative impact on the company’s brand. </span><span class="koboSpan" id="kobo.62.4">To help defend </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.63.1">against scenarios like this, sometimes gray-box testing is used, which, unlike black-box tests, understands certain documented operations of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.64.1">the system.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.65.1">One challenge with testing is that many of the terms used, such as integration or component tests, are not universally defined. </span><span class="koboSpan" id="kobo.65.2">For instance, some people consider an integration test to be </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.66.1">something very narrow – testing the integration with one external part at a time. </span><span class="koboSpan" id="kobo.66.2">Other people may say that an integration test should cover the integration with all the external parts. </span><span class="koboSpan" id="kobo.66.3">Consequently, it is quite important to carefully review and define these terms before using them in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.67.1">a project.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.68.1">When we refer to unit tests, we mean tests for a single unit (such as a function) of the project – only one specific </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.69.1">part of it. </span><span class="koboSpan" id="kobo.69.2">Usually, this unit carries some logic that can be tested specifically. </span><span class="koboSpan" id="kobo.69.3">Everything that is not related to this one unit has to be controlled. </span><span class="koboSpan" id="kobo.69.4">While some unit tests can be written like black-box tests, most unit tests will require a detailed understanding of the internal workings. </span><span class="koboSpan" id="kobo.69.5">This way, the behavior of the tested unit can be controlled </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.70.1">as required.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.71.1">Consider the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.72.1">following code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.73.1">pure.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.74.1">export function pickSmallestNumber(...numbers) {
  if (numbers.length &gt; 0) {
    return numbers.reduce(
      (currentMin, value) =&gt; Math.min(currentMin, value),
      Number.MAX_VALUE);
  }
  return undefined;
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.75.1">In the preceding code, the function is very well suited for a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.76.1">unit test:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.77.1">It is exported, so we can access it from another module containing </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.78.1">the tests.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.79.1">It does not use anything outside of the function – it’s a so-called </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.80.1">pure function.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.81.1">The logic is sufficiently complex to test against a set of predefined </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.82.1">test cases.</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.83.1">Unit tests for the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.84.1">pickSmallestNumber</span></strong><span class="koboSpan" id="kobo.85.1"> function could look </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.86.1">as follows:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.87.1">test('check if undefined is returned for no input', () =&gt; {
  const result = pickSmallestNumber();
  assert(result === undefined);
});
test('check if a single value is the smallest number',
  () =&gt; {
  const result = pickSmallestNumber(20);
  assert(result === 20);
});
test('check if 1 is smaller than 5', () =&gt; {
  const result = pickSmallestNumber(5, 1);
  assert(result === 1);
});
test('check if -1 is smaller than 0 but larger than -5',
  () =&gt; {
  const result = pickSmallestNumber(-1, -5, 0);
  assert(result === -5);
});</span></pre>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.88.1">Note</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.89.1">As mentioned, the code could look like this. </span><span class="koboSpan" id="kobo.89.2">The functions used are defined nowhere and the preceding code would not run </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.90.1">as presented.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.91.1">For these tests, we introduced a new function, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.92.1">test</span></strong><span class="koboSpan" id="kobo.93.1">, which takes a description of the test and the code in the form of a function for running the test. </span><span class="koboSpan" id="kobo.93.2">We also introduced an assertion function, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.94.1">assert</span></strong><span class="koboSpan" id="kobo.95.1">, which could be taken from the Node.js built into the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.96.1">assert</span></strong><span class="koboSpan" id="kobo.97.1"> module. </span><span class="koboSpan" id="kobo.97.2">The </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.98.1">proposed </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.99.1">assert</span></strong><span class="koboSpan" id="kobo.100.1"> function accepts a Boolean input – throwing an exception if the input is </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.101.1">false</span></strong><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">The testing tools and frameworks we’ll look at will replace these constructs with more expressive and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.103.1">elegant alternatives.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.104.1">Besides the actual testing and test area differences, the tooling choices also offer a few variations. </span><span class="koboSpan" id="kobo.104.2">One of the most crucial ones is the difference between a full testing framework and a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.105.1">test runner.</span></span></p>
<h1 id="_idParaDest-72" lang="en-GB"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.106.1">Comparing test runners versus frameworks</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.107.1">Historically, tests for JavaScript targeting web browsers could not be just written and run automatically. </span><span class="koboSpan" id="kobo.107.2">The </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.108.1">main reason was that this involved dealing with a real browser. </span><span class="koboSpan" id="kobo.108.2">There was no way to just </span><em class="italic" lang=""><span class="koboSpan" id="kobo.109.1">pretend to run in the browser</span></em><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">For this reason alone, the first tools in that space have either been scripts or whole websites evaluating JavaScript or browser automation tools. </span><span class="koboSpan" id="kobo.110.3">The latter actually forms its own category – being at the heart of modern </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.111.1">end-to-end tests.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.112.1">The main driver for running the tests – historically, for starting everything that needs to be running to actually perform tests – is called a test runner. </span><span class="koboSpan" id="kobo.112.2">One of the first very successful test runners in the JavaScript space was </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.113.1">Karma</span></strong><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">The job of Karma was to spin up a server that runs </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.115.1">a website hosting the tests, which are targeting JavaScript code that should run in a browser. </span><span class="koboSpan" id="kobo.115.2">Karma then opened available browsers to access the hosted website running the tests. </span><span class="koboSpan" id="kobo.115.3">The results were reported back to the server and shown in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.116.1">the console.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.117.1">If all this sounds complicated to you – you would be right, it was. </span><span class="koboSpan" id="kobo.117.2">The job of these runners was to make this process as reliable as possible. </span><span class="koboSpan" id="kobo.117.3">They also tried to be user-friendly and hide the underlying complexity as much </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.118.1">as possible.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.119.1">Today, test runners like Karma are </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.120.1">not really necessary. </span><span class="koboSpan" id="kobo.120.2">Instead, most test runners such as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.121.1">AVA</span></strong><span class="koboSpan" id="kobo.122.1"> stay in the console </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.123.1">by leveraging Node.js. </span><span class="koboSpan" id="kobo.123.2">When JavaScript code requires the browser API, which is most like the DOM API, the runner just emulates these missing APIs. </span><span class="koboSpan" id="kobo.123.3">As a result of the emulation, the JavaScript code that is tested can run as it would in the browser, but everything remains </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.124.1">in Node.js.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.125.1">While the part about emulating the DOM API sounds great, it is actually not within the scope of a test runner. </span><span class="koboSpan" id="kobo.125.2">Test </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.126.1">runners are really only focused on running the tests. </span><span class="koboSpan" id="kobo.126.2">Instead, developers establish the emulation part somewhat or pick a full test framework. </span><span class="koboSpan" id="kobo.126.3">A full test framework should already have figured out things such as the DOM API emulation so that they can be easily added, or they are already part of the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.127.1">standard installation.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.128.1">A full test framework not </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.129.1">only includes a test runner but also things </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.130.1">such as an assertion library. </span><span class="koboSpan" id="kobo.130.2">So far, we’ve only used some kind of </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.131.1">assert</span></strong><span class="koboSpan" id="kobo.132.1"> function with a proposed behavior. </span><span class="koboSpan" id="kobo.132.2">A full assertion library would give us a set of functions that makes the debugging process in the case of a failed assertion quite easy. </span><span class="koboSpan" id="kobo.132.3">Already from the test output, we would see which assertion was broken – </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.133.1">and why.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.134.1">An example of a good assertion library is </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.135.1">Chai</span></strong><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">It comes with three different exports: </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.137.1">should</span></strong><span class="koboSpan" id="kobo.138.1">, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.139.1">expect</span></strong><span class="koboSpan" id="kobo.140.1">, and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.141.1">assert</span></strong><span class="koboSpan" id="kobo.142.1">. </span><span class="koboSpan" id="kobo.142.2">The </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.143.1">export that you see most often used in test code </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.144.1">is </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.145.1">expect</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.146.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.147.1">Using </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.148.1">expect</span></strong><span class="koboSpan" id="kobo.149.1"> from the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.150.1">chai</span></strong><span class="koboSpan" id="kobo.151.1"> package, the first two test cases from our preceding unit tests could be rewritten </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.152.1">as follows:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.153.1">test('check if undefined is returned for no input', () =&gt; {
  const result = pickSmallestNumber();
  expect(result).to.be.undefined;
});
test('check if a single value is the smallest number',
  () =&gt; {
  const result = pickSmallestNumber(20);
  expect(result).to.equal(20);
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.154.1">The beauty of the rewritten code is that it almost reads like text. </span><span class="koboSpan" id="kobo.154.2">Even somebody with less experience in </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.155.1">the testing framework, JavaScript, or Node.js could </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.156.1">identify what the test does – and even more importantly – what it tries to verify. </span><span class="koboSpan" id="kobo.156.2">The chaining of the expectation using the member (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.157.1">.</span></strong><span class="koboSpan" id="kobo.158.1">) operator is one of the things that makes Chai such a popular </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.159.1">assertion library.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.160.1">Every testing framework comes with an assertion library. </span><span class="koboSpan" id="kobo.160.2">Some frameworks may even let the user decide which assertion library </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.161.1">to use.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.162.1">Now that we know all the basics of testing JavaScript-based applications, we should explore some of the tools to actually implement such tests. </span><span class="koboSpan" id="kobo.162.2">We will start with one of the most commonly used testing utilities: the Jest </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.163.1">test framework.</span></span></p>
<h1 id="_idParaDest-73" lang="en-GB"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.164.1">Using the Jest framework</span></h1>
<p lang="en-GB"><strong class="bold" lang=""><span class="koboSpan" id="kobo.165.1">Jest</span></strong><span class="koboSpan" id="kobo.166.1"> is a modern test framework </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.167.1">that was authored by Facebook to fully leverage Node.js for running tests. </span><span class="koboSpan" id="kobo.167.2">It should have the power to run all the tests required at Facebook without requiring a diploma in engineering to understand, control, or </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.168.1">modify it.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.169.1">To use Jest, you </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.170.1">need to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.171.1">jest</span></strong><span class="koboSpan" id="kobo.172.1"> package </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.173.1">from npm:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.174.1">
$ npm install jest --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.175.1">This allows you to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.176.1">jest</span></strong><span class="koboSpan" id="kobo.177.1"> command-line utility. </span><span class="koboSpan" id="kobo.177.2">Ideally, run it with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.178.1">npx</span></strong><span class="koboSpan" id="kobo.179.1"> as we did with the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.180.1">other tools:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.181.1">
$ npx jest</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.182.1">Jest can be configured by providing a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.183.1">jest.config.js</span></strong><span class="koboSpan" id="kobo.184.1"> file. </span><span class="koboSpan" id="kobo.184.2">The easiest way to create this kind of file is by using the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.185.1">jest</span></strong><span class="koboSpan" id="kobo.186.1"> tool with the --</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.187.1">init</span></strong><span class="koboSpan" id="kobo.188.1"> flag. </span><span class="koboSpan" id="kobo.188.2">This will guide us through some questions to create a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.189.1">suitable configuration:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.190.1">
$ npx jest --init

The following questions will help Jest to create a suitable configuration for your project

</span><span class="koboSpan" id="kobo.191.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.192.1"> Would you like to use Jest when running "test" script in "package.json"? </span><span class="koboSpan" id="kobo.192.2">… yes

</span><span class="koboSpan" id="kobo.193.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.194.1"> Would you like to use Typescript for the configuration file? </span><span class="koboSpan" id="kobo.194.2">… no

</span><span class="koboSpan" id="kobo.195.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.196.1"> Choose the test environment that will be used for testing › jsdom (browser-like)

</span><span class="koboSpan" id="kobo.197.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.198.1"> Do you want Jest to add coverage reports? </span><span class="koboSpan" id="kobo.198.2">… no

</span><span class="koboSpan" id="kobo.199.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.200.1"> Which provider should be used to instrument code for coverage? </span><span class="koboSpan" id="kobo.200.2">› v8

</span><span class="koboSpan" id="kobo.201.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.202.1"> Automatically clear mock calls, instances, contexts and results before every test? </span><span class="koboSpan" id="kobo.202.2">… yes

</span><span class="koboSpan" id="kobo.203.1"><img alt="" src="image/021.png"/></span><span class="koboSpan" id="kobo.204.1">  Modified /home/node/example/Chapter07/package.json

</span><span class="koboSpan" id="kobo.205.1"><img alt="" src="image/031.png"/></span><span class="koboSpan" id="kobo.206.1">  Configuration file created at /home/node/example/Chapter07/jest.config.js</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.207.1">In this case, we’ve instructed Jest to change the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.208.1">test</span></strong><span class="koboSpan" id="kobo.209.1"> script in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.210.1">package.json</span></strong><span class="koboSpan" id="kobo.211.1">. </span><span class="koboSpan" id="kobo.211.2">Now, when we run </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.212.1">npm run test</span></strong><span class="koboSpan" id="kobo.213.1"> or just </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.214.1">npm test</span></strong><span class="koboSpan" id="kobo.215.1"> in our terminal for the current project, Jest will start. </span><span class="koboSpan" id="kobo.215.2">The options </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.216.1">for the test environment and coverage are interesting </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.217.1">to us.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.218.1">Let’s have a look at the essential parts of the generated </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.219.1">configuration file:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.220.1">module.exports = {
  clearMocks: true,
  coverageProvider: "v8",
  testEnvironment: "jsdom",
};</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.221.1">The generated configuration file also contains a lot of comments and commented-out options. </span><span class="koboSpan" id="kobo.221.2">This way, you can configure Jest without having to consult the official </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.222.1">documentation website.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.223.1">The given configuration has just one problem… The selected </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.224.1">jsdom</span></strong><span class="koboSpan" id="kobo.225.1"> environment only works when a special package called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.226.1">jest-environment-jsdom</span></strong><span class="koboSpan" id="kobo.227.1"> is installed. </span><span class="koboSpan" id="kobo.227.2">This has been changed in version </span><em class="italic" lang=""><span class="koboSpan" id="kobo.228.1">28</span></em><span class="koboSpan" id="kobo.229.1"> of Jest and is, unfortunately, not </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.230.1">done automatically:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.231.1">
$ npm install jest-environment-jsdom --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.232.1">Luckily, the error messages in Jest are usually quite good and very helpful. </span><span class="koboSpan" id="kobo.232.2">Even without knowing these things, we’ll get proper messages that tell us exactly what </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.233.1">to do.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.234.1">One last thing we should consider is using Babel for code transformations. </span><span class="koboSpan" id="kobo.234.2">These transformations are </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.235.1">unnecessary if we write pure Node.js-compatible code (such as by using CommonJS). </span><span class="koboSpan" id="kobo.235.2">Otherwise, code transformations are necessary. </span><span class="koboSpan" id="kobo.235.3">In general, Jest uses code transformations to make any kind of used code – not only plain JavaScript but also flavors such as TypeScript and Flow – usable without requiring special </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.236.1">treatment upfront.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.237.1">First, let’s install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.238.1">babel-jest</span></strong><span class="koboSpan" id="kobo.239.1"> plugin and the required </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.240.1">@</span></strong><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.241.1">babel/core</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.242.1"> package:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.243.1">
$ npm install babel-jest @babel/core @babel/preset-env --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.244.1">Now, let’s extend </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.245.1">jest.config.js</span></strong><span class="koboSpan" id="kobo.246.1"> with the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.247.1">transform</span></strong> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.248.1">configuration section:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.249.1">module.exports = {
  // as beforehand
  "transform": {
    "\\.js$": "babel-jest",
  },
};</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.250.1">The new section tells Jest to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.251.1">babel-jest</span></strong><span class="koboSpan" id="kobo.252.1"> transformer for all files ending with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.253.1">.js</span></strong><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">Also add a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.255.1">.babelrc</span></strong><span class="koboSpan" id="kobo.256.1"> file as discussed in </span><a href="B18989_04.xhtml#_idTextAnchor042"><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.257.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.258.1">, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.259.1">Using Different Flavors </span></em><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.260.1">of JavaScript</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.261.1">:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.262.1">{
  "presets": ["@babel/preset-env"]
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.263.1">With this </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.264.1">configuration, Babel will properly transform the given files. </span><span class="koboSpan" id="kobo.264.2">The test code can now be written </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.265.1">as follows:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.266.1">pure.test.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.267.1">import { pickSmallestNumber } from "./pure";
it("check if undefined is returned for no input", () =&gt; {
  const result = pickSmallestNumber();
  expect(result).toBeUndefined();
});
it("check if a single value is the smallest number", () =&gt; {
  const result = pickSmallestNumber(20);
  expect(result).toBe(20);
});
it("check if 1 is smaller than 5", () =&gt; {
  const result = pickSmallestNumber(5, 1);
  expect(result).toBe(1);
});
it("check if -1 is smaller than 0 but larger than -5",
  () =&gt; {
  const result = pickSmallestNumber(-1, -5, 0);
  expect(result).toBe(-1);
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.268.1">While Jest also </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.269.1">supports a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.270.1">test</span></strong><span class="koboSpan" id="kobo.271.1"> function as in our pseudo implementation introduced in the </span><em class="italic" lang=""><span class="koboSpan" id="kobo.272.1">Considering the testing pyramid section</span></em><span class="koboSpan" id="kobo.273.1">, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.274.1">it</span></strong><span class="koboSpan" id="kobo.275.1"> function is much more commonly seen. </span><span class="koboSpan" id="kobo.275.2">Note that Jest comes with its own integrated </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.276.1">assertion library, which uses the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.277.1">expect</span></strong><span class="koboSpan" id="kobo.278.1"> function. </span><span class="koboSpan" id="kobo.278.2">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.279.1">expect</span></strong><span class="koboSpan" id="kobo.280.1"> function is also called </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.281.1">a </span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.282.1">matcher</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.283.1">.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.284.1">Matchers</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.285.1">For our simple example, the matcher will only have to deal with strings and numbers. </span><span class="koboSpan" id="kobo.285.2">In general, however, any kind </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.286.1">of JavaScript input, such as arrays or objects, can be matched and asserted. </span><span class="koboSpan" id="kobo.286.2">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.287.1">expect</span></strong><span class="koboSpan" id="kobo.288.1"> function has some helpers to deal with, for instance, object equality (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.289.1">toBe</span></strong><span class="koboSpan" id="kobo.290.1">), as in, having the same reference, and equivalence (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.291.1">toEqual</span></strong><span class="koboSpan" id="kobo.292.1">), as in, having the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.293.1">same content.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.294.1">Let’s </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.295.1">run this:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.296.1">
$ npm run test

&gt; Chapter07@1.0.0 test /home/node/example/Chapter07

&gt; jest

 PASS  src/pure.test.js

  </span><span class="koboSpan" id="kobo.297.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.298.1"> check if undefined is returned for no input (2 ms)

  </span><span class="koboSpan" id="kobo.299.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.300.1"> check if a single value is the smallest number (1 ms)

  </span><span class="koboSpan" id="kobo.301.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.302.1"> check if 1 is smaller than 5

  </span><span class="koboSpan" id="kobo.303.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.304.1"> check if -1 is smaller than 0 but larger than -5

Test Suites: 1 passed, 1 total

Tests:       4 passed, 4 total

Snapshots:   0 total

Time:        0.818 s, estimated 1 s

Ran all test suites.</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.305.1">Great – our code works. </span><span class="koboSpan" id="kobo.305.2">By default, Jest will look for all files ending with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.306.1">.test.js</span></strong><span class="koboSpan" id="kobo.307.1">. </span><span class="koboSpan" id="kobo.307.2">By convention, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.308.1">.spec.js</span></strong><span class="koboSpan" id="kobo.309.1"> files would also work. </span><span class="koboSpan" id="kobo.309.2">The convention used can be </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.310.1">changed though.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.311.1">Today, Jest is arguably </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.312.1">the most used testing framework. </span><span class="koboSpan" id="kobo.312.2">However, especially older projects potentially use something else. </span><span class="koboSpan" id="kobo.312.3">A very solid and common occurrence here is Mocha. </span><span class="koboSpan" id="kobo.312.4">Like Jest, it is also a testing framework, but with a few </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.313.1">key differences.</span></span></p>
<h1 id="_idParaDest-74" lang="en-GB"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.314.1">Using the Mocha framework</span></h1>
<p lang="en-GB"><strong class="bold" lang=""><span class="koboSpan" id="kobo.315.1">Mocha</span></strong><span class="koboSpan" id="kobo.316.1"> is an older but feature-rich testing </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.317.1">framework that runs in Node.js and also the browser. </span><span class="koboSpan" id="kobo.317.2">In this section, we’ll exclusively use Mocha in Node.js. </span><span class="koboSpan" id="kobo.317.3">Unlike Jest, the notion of an environment does not exist. </span><span class="koboSpan" id="kobo.317.4">Nevertheless, a similar setup can be achieved, where browser APIs would be emulated by some npm package such </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.318.1">as </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.319.1">jsdom</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.320.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.321.1">To use Mocha, you </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.322.1">need to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.323.1">mocha</span></strong><span class="koboSpan" id="kobo.324.1"> package </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.325.1">from npm:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.326.1">
$ npm install mocha --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.327.1">This allows you to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.328.1">mocha</span></strong><span class="koboSpan" id="kobo.329.1"> command-line utility. </span><span class="koboSpan" id="kobo.329.2">Ideally, run it with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.330.1">npx</span></strong><span class="koboSpan" id="kobo.331.1"> as we did with the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.332.1">other tools:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.333.1">
$ npx mocha</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.334.1">At this point, not much is working. </span><span class="koboSpan" id="kobo.334.2">By default, Mocha follows a different convention from Jest. </span><span class="koboSpan" id="kobo.334.3">Here, we need to specify a different pattern or place our tests in a folder </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.335.1">named </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.336.1">test</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.337.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.338.1">What we definitely need to do is to include Babel for code transformations. </span><span class="koboSpan" id="kobo.338.2">This works a bit differently than with Jest. </span><span class="koboSpan" id="kobo.338.3">Instead of a dedicated plugin, we only integrate the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.339.1">@babel/register</span></strong><span class="koboSpan" id="kobo.340.1"> package, which will automatically transform any code when a module </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.341.1">is loaded:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.342.1">
$ npm install --save-dev @babel/register @babel/core @babel/preset-env</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.343.1">Now, we can copy the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.344.1">.babelrc</span></strong><span class="koboSpan" id="kobo.345.1"> file that we used previously with Jest. </span><span class="koboSpan" id="kobo.345.2">For Mocha, the configuration can be placed in a file called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.346.1">.mocharc.js</span></strong><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">Setting up the configuration file to always require the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.348.1">@babel/register</span></strong><span class="koboSpan" id="kobo.349.1"> package first looks </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.350.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.351.1">.mocharc.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.352.1">module.exports = {
  require: "@babel/register",
};</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.353.1">Mocha is a kind of special testing framework, as it does not come with an assertion library. </span><span class="koboSpan" id="kobo.353.2">Instead, it </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.354.1">relies on other assertion libraries. </span><span class="koboSpan" id="kobo.354.2">As long as it throws an exception in case of a mismatch, the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.355.1">assertion works.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.356.1">To write tests with Mocha without using a special assertion library besides the one that already comes with Node.js, we would write our tests </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.357.1">as follows:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.358.1">pure.test.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.359.1">import { equal } from "assert";
import { pickSmallestNumber } from "../src/pure";
it("check if undefined is returned for no input", () =&gt; {
  const result = pickSmallestNumber();
  equal(result, undefined);
});
it("check if a single value is the smallest number", () =&gt; {
  const result = pickSmallestNumber(20);
  equal(result, 20);
});
it("check if 1 is smaller than 5", () =&gt; {
  const result = pickSmallestNumber(5, 1);
  equal(result, 1);
});
it("check if -1 is smaller than 0 but larger than -5",
  () =&gt; {
  const result = pickSmallestNumber(-1, -5, 0);
  equal(result, -5);
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.360.1">In the </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.361.1">preceding code, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.362.1">it</span></strong><span class="koboSpan" id="kobo.363.1"> functions follow the same behavior as </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.364.1">in Jest.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.365.1">Now, let us run </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.366.1">mocha</span></strong><span class="koboSpan" id="kobo.367.1"> via </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.368.1">npm test</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.369.1">:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.370.1">
$ npm run test

&gt; example02@1.0.0 test /home/node/example/Chapter07/example02

&gt; mocha

  </span><span class="koboSpan" id="kobo.371.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.372.1"> check if undefined is returned for no input

  </span><span class="koboSpan" id="kobo.373.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.374.1"> check if a single value is the smallest number

  </span><span class="koboSpan" id="kobo.375.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.376.1"> check if 1 is smaller than 5

  </span><span class="koboSpan" id="kobo.377.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.378.1"> check if -1 is smaller than 0 but larger than -5

  4 passing (3ms)</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.379.1">Compared to Jest, we get a little bit less output. </span><span class="koboSpan" id="kobo.379.2">Still, all the relevant information is presented and if there were an error, we would have gotten all the necessary information to identify and fix the issue. </span><span class="koboSpan" id="kobo.379.3">The crucial difference between Jest and Mocha is that Jest really </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.380.1">breaks down the tests according to their associated test module, while Mocha just presents </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.381.1">the results.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.382.1">Mocha is actually quite feature-packed and everything but lightweight. </span><span class="koboSpan" id="kobo.382.2">A more streamlined option is to avoid using a full testing framework and instead go for a test runner only. </span><span class="koboSpan" id="kobo.382.3">One option is to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.383.1">use AVA.</span></span></p>
<h1 id="_idParaDest-75" lang="en-GB"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.384.1">Using the AVA test runner</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.385.1">AVA is a modern test runner </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.386.1">for Node.js. </span><span class="koboSpan" id="kobo.386.2">It stands out because of its ability to embrace new JavaScript language features and cutting-edge properties of Node.js, such as process isolation. </span><span class="koboSpan" id="kobo.386.3">In this way, AVA executes tests very quickly </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.387.1">and reliably.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.388.1">To use AVA, you </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.389.1">need to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.390.1">ava</span></strong><span class="koboSpan" id="kobo.391.1"> package </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.392.1">from npm:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.393.1">
$ npm install ava --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.394.1">This allows you to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.395.1">ava</span></strong><span class="koboSpan" id="kobo.396.1"> command-line utility. </span><span class="koboSpan" id="kobo.396.2">Ideally, run it with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.397.1">npx</span></strong><span class="koboSpan" id="kobo.398.1"> as we did with the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.399.1">other tools:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.400.1">
$ npx ava</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.401.1">While Mocha and Jest could also be installed globally, AVA only works in projects as a local dependency. </span><span class="koboSpan" id="kobo.401.2">As this is the better setup anyway, there should be no practical downside from </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.402.1">this constraint.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.403.1">As mentioned, AVA is built quite closely on Node.js – following its conventions and rules wherever possible. </span><span class="koboSpan" id="kobo.403.2">In this regard, AVA also allows us quite quickly to adapt ESM instead of CommonJS. </span><span class="koboSpan" id="kobo.403.3">By modifying </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.404.1">package.json</span></strong><span class="koboSpan" id="kobo.405.1"> for the project, we get immediate support for using ESM in our </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.406.1">tests, too:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.407.1">package.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.408.1">{
  // like beforehand
  "type": "module",
  // ...
</span><span class="koboSpan" id="kobo.408.2">}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.409.1">By default, AVA looks for files that follow the same pattern as Jest. </span><span class="koboSpan" id="kobo.409.2">Therefore, files that end with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.410.1">.test.js</span></strong><span class="koboSpan" id="kobo.411.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.412.1">.spec.js</span></strong><span class="koboSpan" id="kobo.413.1"> will be found among others. </span><span class="koboSpan" id="kobo.413.2">There is no need to configure AVA or place the tests in a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.414.1">separate directory.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.415.1">The other thing that AVA does is to provide a function as a default export from the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.416.1">ava</span></strong><span class="koboSpan" id="kobo.417.1"> package. </span><span class="koboSpan" id="kobo.417.2">This function </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.418.1">is needed to declare tests. </span><span class="koboSpan" id="kobo.418.2">Each test then receives a so-called test context as a callback parameter for its implementation. </span><span class="koboSpan" id="kobo.418.3">This way, AVA feels a lot more explicit and less magical than the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.419.1">other solutions.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.420.1">Let’s see how we can write the tests </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.421.1">with AVA:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.422.1">pure.test.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.423.1">import test from 'ava';
import { pickSmallestNumber } from "./pure.js";
test("check if undefined is returned for no input", (t) =&gt; {
  const result = pickSmallestNumber();
  t.is(result, undefined);
});
test("check if a single value is the smallest number",
  (t) =&gt; {
  const result = pickSmallestNumber(20);
  t.is(result, 20);
});
test("check if 1 is smaller than 5", (t) =&gt; {
  const result = pickSmallestNumber(5, 1);
  t.is(result, 1);
});
test("check if -1 is smaller than 0 but larger than -5",
  (t) =&gt; {
  const result = pickSmallestNumber(-1, -5, 0);
  t.is(result, -5);
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.424.1">Overall, the structure is similar to the previous two full frameworks. </span><span class="koboSpan" id="kobo.424.2">Still, AVA is just a runner and misses things such as special assertion libraries, options for mocking, and snapshots, among </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.425.1">other things.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.426.1">To run the tests, we </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.427.1">can adjust the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.428.1">test</span></strong><span class="koboSpan" id="kobo.429.1"> script in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.430.1">package.json</span></strong><span class="koboSpan" id="kobo.431.1">. </span><span class="koboSpan" id="kobo.431.2">Triggering the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.432.1">ava</span></strong><span class="koboSpan" id="kobo.433.1"> utility, a run with the AVA test runner looks </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.434.1">like this:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.435.1">
$ npm run test

&gt; example03@1.0.0 test /Users/node/example/Chapter07/example03

&gt; ava

  </span><span class="koboSpan" id="kobo.436.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.437.1"> check if undefined is returned for no input

  </span><span class="koboSpan" id="kobo.438.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.439.1"> check if a single value is the smallest number

  </span><span class="koboSpan" id="kobo.440.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.441.1"> check if 1 is smaller than 5

  </span><span class="koboSpan" id="kobo.442.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.443.1"> check if -1 is smaller than 0 but larger than -5

  ─

  4 tests passed</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.444.1">Now that we covered </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.445.1">three tools to run some code-centric tests, let’s explore some options for running UI tests, too. </span><span class="koboSpan" id="kobo.445.2">We will start with </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.446.1">Playwright</span></strong><span class="koboSpan" id="kobo.447.1">, which is a modern library to automate the behavior of web browsers such as Google Chrome </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.448.1">or Firefox.</span></span></p>
<h1 id="_idParaDest-76" lang="en-GB"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.449.1">Using Playwright for visual tests</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.450.1">Node.js is not </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.451.1">only a great basis for running logical tests but </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.452.1">also for verifying visuals, such as those of a website running in a browser. </span><span class="koboSpan" id="kobo.452.2">A modern approach for browser automation </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.453.1">is Playwright.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.454.1">To use Playwright, you need to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.455.1">playwright</span></strong><span class="koboSpan" id="kobo.456.1"> package </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.457.1">from npm:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.458.1">
$ npm install playwright --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.459.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.460.1">playwright</span></strong><span class="koboSpan" id="kobo.461.1"> package enables you to use Playwright in an existing application, which could also be inside existing tests such as unit tests executed with Jest using the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.462.1">jest-playwright-preset</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.463.1"> package.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.464.1">An even better setup can be achieved by using the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.465.1">@playwright/test</span></strong><span class="koboSpan" id="kobo.466.1"> test </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.467.1">runner package:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.468.1">
$ npm install @playwright/test --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.469.1">This allows you to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.470.1">playwright</span></strong><span class="koboSpan" id="kobo.471.1"> command-line utility. </span><span class="koboSpan" id="kobo.471.2">Ideally, run it with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.472.1">npx</span></strong><span class="koboSpan" id="kobo.473.1"> as we did with the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.474.1">other tools:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.475.1">
$ npx playwright test</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.476.1">Running this will look for all files matching the same conventions as previously noted in the Jest and AVA sections. </span><span class="koboSpan" id="kobo.476.2">Every file ending with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.477.1">.test.js</span></strong><span class="koboSpan" id="kobo.478.1"> or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.479.1">.spec.js</span></strong><span class="koboSpan" id="kobo.480.1"> will be included. </span><span class="koboSpan" id="kobo.480.2">Additionally, the </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.481.1">Playwright test runner is also capable of </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.482.1">evaluating TypeScript files. </span><span class="koboSpan" id="kobo.482.2">The runner therefore also includes </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.483.1">.test.ts</span></strong><span class="koboSpan" id="kobo.484.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.485.1">.spec.ts</span></strong><span class="koboSpan" id="kobo.486.1"> files in its </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.487.1">default lookup.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.488.1">Let’s look at a simple test run again. </span><span class="koboSpan" id="kobo.488.2">We’ll run tests against a public website available at </span><a href="https://microfrontends.art"><span class="koboSpan" id="kobo.489.1">https://microfrontends.art</span></a><span class="koboSpan" id="kobo.490.1">. </span><span class="koboSpan" id="kobo.490.2">The test would work against a local website running on </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.491.1">localhost, too:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.492.1">mf.test.ts</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.493.1">import { test, expect } from '@playwright/test';
test('homepage has micro frontends in the title and in an
  h1', async ({ page }) =&gt; {
  await page.goto('https://microfrontends.art/');
  // Expect the title "to contain" a substring.
</span><span class="koboSpan" id="kobo.493.2">  await expect(page).toHaveTitle(/Micro Frontends/);
  // Grab an element ("h1")
  const h1 = page.locator('h1');
  // Expect the element to have a specific text
  await expect(h1)
    .toHaveText('The Art of Micro Frontends');
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.494.1">The structure feels a bit similar to AVA. </span><span class="koboSpan" id="kobo.494.2">As with AVA, we are using explicit imports to create the test </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.495.1">infrastructure. </span><span class="koboSpan" id="kobo.495.2">We also need to use the parameter </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.496.1">of the test’s callback to actually do something useful with the website using the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.497.1">page</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.498.1"> object.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.499.1">Let’s change the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.500.1">test</span></strong><span class="koboSpan" id="kobo.501.1"> script in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.502.1">package.json</span></strong><span class="koboSpan" id="kobo.503.1"> and run the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.504.1">test provided:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.505.1">
$ npm run test

&gt; example04@1.0.0 test /Users/node/example/Chapter07/example04

&gt; playwright test

Running 1 test using 1 worker

  </span><span class="koboSpan" id="kobo.506.1"><img alt="" src="image/014.png"/></span><span class="koboSpan" id="kobo.507.1">  1 tests/mf.test.ts:3:1 › homepage has Playwright in title and get started link linking to the intro page (491ms)

  1 passed (5s)</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.508.1">Yet another option to write end-to-end tests is Cypress. </span><span class="koboSpan" id="kobo.508.2">This promises to be even more convenient and also equipped to test individual </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.509.1">components, too.</span></span></p>
<h1 id="_idParaDest-77" lang="en-GB"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.510.1">Using Cypress for end-to-end testing</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.511.1">Cypress is a focused, end-to-end testing </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.512.1">framework that also comes with the ability to test individual UI components. </span><span class="koboSpan" id="kobo.512.2">It tries to be different by mostly avoiding browser automation. </span><span class="koboSpan" id="kobo.512.3">Instead, its test runner is located directly inside </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.513.1">the browser.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.514.1">To use Cypress, you </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.515.1">need to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.516.1">cypress</span></strong><span class="koboSpan" id="kobo.517.1"> package </span><a id="_idIndexMarker286"/><span class="No-Break" lang=""><span class="koboSpan" id="kobo.518.1">from npm:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.519.1">
$ npm install cypress --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.520.1">This allows you to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.521.1">cypress</span></strong><span class="koboSpan" id="kobo.522.1"> command-line utility. </span><span class="koboSpan" id="kobo.522.2">Ideally, run it with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.523.1">npx</span></strong><span class="koboSpan" id="kobo.524.1"> as we did with the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.525.1">other tools:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.526.1">
$ npx cypress open</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.527.1">Cypress is at its heart a graphical tool. </span><span class="koboSpan" id="kobo.527.2">As such, we are first introduced to a small configurator that allows us to set up our project. </span><span class="koboSpan" id="kobo.527.3">The configurator is shown in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.528.1">Figure 7</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.529.1">.2</span></em><span class="koboSpan" id="kobo.530.1">. </span><span class="koboSpan" id="kobo.530.2">Picking </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.531.1">E2E Testing</span></strong><span class="koboSpan" id="kobo.532.1"> will give you the ability to influence what files </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.533.1">are written:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.534.1"><img alt="Figure 7.2 – The Cypress configurator on opening it for the first time " src="image/Figure_7.2_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.535.1">Figure 7.2 – The Cypress configurator on opening it for the first time</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.536.1">The configurator also lets you pick a browser where the tests should actually be run. </span><span class="koboSpan" id="kobo.536.2">Right now, </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.537.1">Chrome</span></strong><span class="koboSpan" id="kobo.538.1">, </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.539.1">Edge</span></strong><span class="koboSpan" id="kobo.540.1">, </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.541.1">Electron</span></strong><span class="koboSpan" id="kobo.542.1">, and </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.543.1">Firefox</span></strong> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.544.1">are supported.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.545.1">At this time, we can </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.546.1">add our first test – in the context of Cypress, referred </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.547.1">to as a spec or specification. </span><span class="koboSpan" id="kobo.547.2">We’ll use the same kind of test that we’ve added as an example </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.548.1">for Playwright:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.549.1">mf.cy.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.550.1">describe("empty spec", () =&gt; {
  it("passes", () =&gt; {
    cy.visit("https://microfrontends.art");
    // Expect the title "to contain" a substring.
</span><span class="koboSpan" id="kobo.550.2">    cy.title().should("contain", "Micro Frontends");
    // Expect the h1 element to have a specific text.
</span><span class="koboSpan" id="kobo.550.3">    cy.get("h1").should("have.text",
      "The Art of Micro Frontends")
  });
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.551.1">As seen in the preceding small test, the whole test structure is implicit. </span><span class="koboSpan" id="kobo.551.2">The main downside of this is that there is no good IDE support to help with proper typing – that is, type information that can be used by TypeScript. </span><span class="koboSpan" id="kobo.551.3">A good way out of it is to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.552.1">typescript</span></strong><span class="koboSpan" id="kobo.553.1"> package in the project and create a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.554.1">tsconfig.json</span></strong><span class="koboSpan" id="kobo.555.1"> that teaches TypeScript </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.556.1">about Cypress:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.557.1">tsconfig.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.558.1">{
  "compilerOptions": {
    "target": "es5",
    "lib": ["es5", "dom"],
    "types": ["cypress", "node"]
  },
  "include": ["**/*.ts"]
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.559.1">Now, you can rename the test file to end with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.560.1">.ts</span></strong><span class="koboSpan" id="kobo.561.1"> (in our example, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.562.1">mf.cy.ts</span></strong><span class="koboSpan" id="kobo.563.1">) and enjoy improved autocompletion in most editors </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.564.1">and IDEs.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.565.1">Running this test will yield a graphical result. </span><span class="koboSpan" id="kobo.565.2">In </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.566.1">Figure 7</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.567.1">.3</span></em><span class="koboSpan" id="kobo.568.1">, you can see the output from running the </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.569.1">test in the selected browser. </span><span class="koboSpan" id="kobo.569.2">This is the key point </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.570.1">of Cypress. </span><span class="koboSpan" id="kobo.570.2">An end-to-end test never leaves the visual area and allows us to directly interact with the test within its visual boundaries. </span><span class="koboSpan" id="kobo.570.3">This makes tests written with Cypress not only very beginner-friendly but also quite easy </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.571.1">to debug:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.572.1"><img alt="Figure 7.3 – Running the test directly in the browser " src="image/Figure_7.3_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.573.1">Figure 7.3 – Running the test directly in the browser</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.574.1">If you want to </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.575.1">run the locally available tests directly and </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.576.1">without visual interaction, then you can also use the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.577.1">run</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.578.1"> command:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.579.1">
$ npx cypress run</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.580.1">This is especially handy in non-local environments, such as a CI/CD pipeline for validating </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.581.1">software builds.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.582.1">With this in mind, let’s recap what we learned in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.583.1">this chapter.</span></span></p>
<h1 id="_idParaDest-78" lang="en-GB"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.584.1">Summary</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.585.1">In this chapter, you learned about which different types of testing we can automate and how important these types are for software projects to succeed. </span><span class="koboSpan" id="kobo.585.2">You’ve seen the popular tools that exist to help us cover our projects. </span><span class="koboSpan" id="kobo.585.3">By following the testing pyramid, you should be able to decide what tests you need to focus on to make your project as reliable </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.586.1">as possible.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.587.1">By using the power test frameworks such as Jest or Mocha or a flexible runner such as AVA, you can automate a lot of different things – from unit tests to full end-to-end tests. </span><span class="koboSpan" id="kobo.587.2">Dedicated end-to-end test frameworks such as Playwright or Cypress also come with their own runners – which makes sense for complex visual tests in particular. </span><span class="koboSpan" id="kobo.587.3">In the unit and integration testing space, Jest comes in handy. </span><span class="koboSpan" id="kobo.587.4">It also allows us to quickly integrate other flavors of JavaScript or customize a lot of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.588.1">different features.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.589.1">In the next chapter, we will finally also publish our own packages – to the public registry and other </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.590.1">custom registries.</span></span></p>
</div>


<div class="Content" id="_idContainer096">
<h1 id="_idParaDest-79" lang="en-GB"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.1.1">Part 3: Advanced Topics</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.2.1">In this part, you’ll dive into advanced topics such as publishing your own npm packages and structuring your projects into a shared code base such as a monorepo. </span><span class="koboSpan" id="kobo.2.2">You’ll see what options exist and how tools such as Nx, Lerna, or Turbo can help you set up projects that </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.3.1">can scale.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.4.1">To round off your knowledge about Node.js and its ecosystem, this part will also teach you how to make use of any kind of code compiled as WebAssembly within Node.js, as well as which other runtimes can be used as the basis for web </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.5.1">development tooling.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.6.1">This part of the book comprises the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.7.1">following chapters:</span></span></p>
<ul>
<li lang="en-GB"><a href="B18989_08.xhtml#_idTextAnchor079"><em class="italic" lang=""><span class="koboSpan" id="kobo.8.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.10.1">Publishing npm Packages</span></em></li>
<li lang="en-GB"><a href="B18989_09.xhtml#_idTextAnchor088"><em class="italic" lang=""><span class="koboSpan" id="kobo.11.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.13.1">Structuring Code in Monorepos</span></em></li>
<li lang="en-GB"><a href="B18989_10.xhtml#_idTextAnchor098"><em class="italic" lang=""><span class="koboSpan" id="kobo.14.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.15.1">, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.16.1">Integrating Native Code with WebAssembly</span></em></li>
<li lang="en-GB"><a href="B18989_11.xhtml#_idTextAnchor105"><em class="italic" lang=""><span class="koboSpan" id="kobo.17.1">Chapter 11</span></em></a><em class="italic" lang=""><span class="koboSpan" id="kobo.18.1">,</span></em> <em class="italic" lang=""><span class="koboSpan" id="kobo.19.1">Using Alternative Runtimes</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer097">
</div>
</div>
</body></html>