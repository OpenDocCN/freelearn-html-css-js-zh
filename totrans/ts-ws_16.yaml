- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: 1\. TypeScript Fundamentals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. TypeScript 基础
- en: 'Activity 1.01: Creating a Library for Working with Strings'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一.01：创建字符串操作库
- en: '**Solution:**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: Here are the steps that will help you create all the functions listed in the
    activity problem statement.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是帮助你创建活动问题陈述中列出的所有函数的步骤。
- en: toTitleCase
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: toTitleCase
- en: The `toTitleCase` function will process a string and capitalize the first letter
    of each word, but will make all the other letters lowercase.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`toTitleCase` 函数将处理一个字符串，并将每个单词的首字母转换为大写，但将所有其他字母转换为小写。'
- en: 'Test cases for this function are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的测试用例如下：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are the steps to help you write this function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是帮助你编写这个函数的步骤：
- en: 'This function will take a single parameter that is a string and return a string
    as well:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数将接受一个字符串参数并返回一个字符串：
- en: '[PRE1]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First off, we will split the input into an array of strings using the split
    string method. We''ll split on every space character:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用字符串分割方法将输入分割成字符串数组。我们将根据每个空格字符进行分割：
- en: '[PRE2]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will define a new array that will hold each word as we transform it
    into title case, and use a for..of loop to loop through the array of words:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个新的数组，用于存储我们将要转换为大写形式的每个单词，并使用 for..of 循环遍历单词数组：
- en: '[PRE3]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For each word we will extract the first character and the rest of the characters
    using the slice string method. We will transform the initial to uppercase, and
    the rest of the characters to lowercase. Next, we''ll join them back together
    to form a complete word and push the result to the holding array:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个单词，我们将使用字符串切片方法提取第一个字符和其余字符。我们将首字母转换为大写，其余字符转换为小写。然后，我们将它们重新组合成一个完整的单词，并将结果推送到存储数组中：
- en: '[PRE4]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At last, we will join all the processed words together, with a separating space,
    and we have our result:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所有处理过的单词连接起来，用空格分隔，我们就得到了结果：
- en: '[PRE5]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we can test whether the function gives the expected results for the given
    test inputs:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以测试该函数是否对给定的测试输入给出了预期的结果：
- en: '[PRE6]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We should receive the results:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该收到以下结果：
- en: '[PRE7]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: countWords
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: countWords
- en: 'Here are the steps to help you write this function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是帮助你编写这个函数的步骤：
- en: 'The countWords function will count the number of separate words within a string.
    Words are delimited by spaces, dashes (-), or underscores (_). Test cases for
    this function are as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`countWords` 函数将计算字符串中不同单词的数量。单词由空格、破折号（-）或下划线（_）分隔。此函数的测试用例如下：'
- en: '[PRE8]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create the `countWords` function using the following code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建 `countWords` 函数：
- en: '[PRE9]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Split the words using a regex that will match any occurrence of a space, underscore,
    or dash character:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用匹配空格、下划线或破折号字符的正则表达式分割单词：
- en: '[PRE10]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Return the length of the array that is the result of the split:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回分割结果数组的长度：
- en: '[PRE11]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Test the function and console out the results:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试该函数并输出控制台结果：
- en: '[PRE12]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: toWords
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: toWords
- en: The `toWords` function will return all the words that are within a string. Words
    are delimited by spaces, dashes (`-`), or underscores (`_`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`toWords` 函数将返回字符串中的所有单词。单词由空格、破折号（`-`）或下划线（`_`）分隔。'
- en: 'Test cases for this function are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的测试用例如下：
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function is very similar to the previous one we developed. The significant
    difference is that we need to return not only the number of words but also the
    actual words themselves. So, instead of a number, this function will return an
    array of strings:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数与我们之前开发的函数非常相似。主要区别是我们需要返回的不仅是单词的数量，还有实际的单词本身。因此，此函数将返回一个字符串数组，而不是一个数字：
- en: 'Here is the code to create this function:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是创建此函数的代码：
- en: '[PRE14]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once more, we will need to split the input into an array of strings using the
    split string method, using the [ _-] regular expression. Split the words using
    a regular expression that will match any occurrence of a space, underscore, or
    dash character:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们需要使用字符串分割方法将输入分割成字符串数组，使用正则表达式 `[ _-]`。使用匹配空格、下划线或破折号字符的正则表达式分割单词：
- en: '[PRE15]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we have the words, we can just return them:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了单词，我们就可以直接返回它们：
- en: '[PRE16]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we can test whether the function gives the expected results for the given
    test inputs:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以测试该函数是否对给定的测试输入给出了预期的结果：
- en: '[PRE17]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We should receive the results:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该收到以下结果：
- en: '[PRE18]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: repeat
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: repeat
- en: '`repeat` will take a string and a number and return that same string repeated
    that number of times.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat` 将接受一个字符串和一个数字，并返回该字符串重复指定次数的结果。'
- en: 'Test cases for this function are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的测试用例如下：
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here are the steps to help you write this function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些步骤可以帮助你编写这个函数：
- en: 'This function will take two parameters, one that is a string and a second one
    that is a number, and return a string as well:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数将接受两个参数，一个是字符串，另一个是数字，并返回一个字符串：
- en: '[PRE20]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are many ways to implement this function, and we''ll illustrate one approach.
    We can create an array with the required number of elements, and then use the
    array''s `fill` method to fill it with the value of the string. In that way, we
    will have an array of `times` elements, and each element will have the `input`
    value:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现这个函数有很多种方法，我们将展示一种方法。我们可以创建一个具有所需元素数量的数组，然后使用数组的 `fill` 方法用字符串的值填充它。这样，我们将有一个包含
    `times` 个元素的数组，每个元素都将具有 `input` 值：
- en: '[PRE21]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we just need to join all the instances, using an empty string as the
    delimiter. That way, we''re making sure that no spaces or commas are inserted
    between the strings:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需要使用空字符串作为分隔符，将所有实例连接起来。这样，我们确保字符串之间没有插入空格或逗号：
- en: '[PRE22]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we can test whether the function gives the expected results for the given
    test inputs:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以测试该函数对于给定的测试输入是否给出预期的结果：
- en: '[PRE23]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We should receive the following results:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该收到以下结果：
- en: '[PRE24]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: isAlpha
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isAlpha
- en: '`isAlpha` returns `true` if the string only has alpha characters (that is, letters).
    Test cases for this function are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`isAlpha` 如果字符串只包含字母字符（即字母），则返回 `true`。这个函数的测试用例如下：'
- en: '[PRE25]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here are the steps to help you write this function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些步骤可以帮助你编写这个函数：
- en: 'This function will take a single parameter that is a string and return a Boolean:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数将接受一个字符串参数并返回一个布尔值：
- en: '[PRE26]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For this function to work, we need to check whether each character is a lower-
    or uppercase letter. One of the best ways to determine that is to use a regular
    expression that checks it. In particular, the character group [a-z] will check
    for a single character and if we use the star quantifier (*), we can tell the
    regular expression to check for all the characters. We can add the i modifier
    to the regular expression to make the match case-insensitive, so we don''t need
    to worry about letter casing:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个函数工作，我们需要检查每个字符是下划线还是大写字母。确定这一点的一个最好的方法就是使用检查它的正则表达式。特别是，字符组 [a-z] 将检查单个字符，如果我们使用星号量词
    (*)，我们可以告诉正则表达式检查所有字符。我们可以添加 i 修饰符到正则表达式，使其匹配不区分大小写，这样我们就不必担心字母的大小写：
- en: '[PRE27]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we need to actually test our input. Since we only need to know whether
    the string matches, we can use the test method of the regular expression and return
    its result:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实际测试我们的输入。由于我们只需要知道字符串是否匹配，我们可以使用正则表达式的测试方法并返回其结果：
- en: '[PRE28]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we can test whether the function gives the expected results for the given
    test inputs:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以测试该函数对于给定的测试输入是否给出预期的结果：
- en: '[PRE29]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We should receive the results:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该收到以下结果：
- en: '[PRE30]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: isBlank
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isBlank
- en: '`isBlank` returns `true` if the string is blank, that is, it consists only
    of whitespace characters.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`isBlank` 如果字符串为空白，即只包含空白字符，则返回 `true`。'
- en: 'Test cases for this function are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的测试用例如下：
- en: '[PRE31]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here are the steps to help you write this function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些步骤可以帮助你编写这个函数：
- en: 'This function will take a single parameter that is a string and return a Boolean:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数将接受一个字符串参数并返回一个布尔值：
- en: '[PRE32]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For this function to work, we need to check whether each character in the string
    is a whitespace character. We can use a regular expression to determine that,
    or we can use some kind of looping construct that will iterate through the string.
    One approach would be to test whether the first character is a space, and if it
    is, slice it off:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个函数工作，我们需要检查字符串中的每个字符是否为空白字符。我们可以使用正则表达式来确定这一点，或者我们可以使用某种循环结构来遍历字符串。一种方法就是测试第一个字符是否为空格，如果是，就将其切掉：
- en: '[PRE33]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This loop will execute until it reaches a non-whitespace character. If it does
    not encounter one, it will only stop when there is no first element of the string,
    that is, when the string is the empty string. If that''s the case, our original
    input only contained whitespace, and we can return true. Otherwise, we should
    return false:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个循环将一直执行，直到遇到一个非空白字符。如果没有遇到，它将仅在字符串没有第一个元素时停止，也就是说，当字符串为空字符串时。如果是这种情况，我们的原始输入只包含空白字符，我们可以返回
    true。否则，我们应该返回 false：
- en: '[PRE34]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we can test whether the function gives the expected results for the given
    test inputs:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以测试该函数对于给定的测试输入是否给出预期的结果：
- en: '[PRE35]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We should receive the following results:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该收到以下结果：
- en: '[PRE36]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that there are multiple ways to implement all the preceding functions.
    The code shown is just one way to implement them, and these implementations are
    mostly for illustrative purposes. For example, a proper string utility library
    will need to have much more robust and extensive test suites.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，实现所有前面的函数有多种方式。显示的代码只是实现它们的一种方式，这些实现主要是为了说明目的。例如，一个合适的字符串实用程序库将需要更强大和广泛的测试套件。
- en: 2\. Declaration Files
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 声明文件
- en: 'Activity 2.01: Building a Heat Map Declaration File'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 2.01：构建热图声明文件
- en: '**Solution:**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'In this activity, we''ll be building a TypeScript application named `heat map
    log system` that will track the baseball pitch data and ensure the integrity of
    the data. Perform the following steps to implement this activity:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个名为 `heat map log system` 的 TypeScript 应用程序，该程序将跟踪棒球投球数据并确保数据的完整性。按照以下步骤实现此活动：
- en: Visit the following GitHub repository at [https://packt.link/dqDPk](https://packt.link/dqDPk)
    and download the activity project containing the specs and configuration elements.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问以下 GitHub 仓库 [https://packt.link/dqDPk]，下载包含规范和配置元素的作业项目。
- en: Open the Visual Studio Code editor and then open the terminal.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code 编辑器，然后打开终端。
- en: 'Change to the `activity-starter` directory in the terminal or command prompt
    by writing the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端或命令提示符中切换到 `activity-starter` 目录，编写以下命令：
- en: '[PRE37]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the following command to install the dependencies:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来安装依赖项：
- en: '[PRE38]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You will now see the following files in the `activity-starter` directory:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在将在 `activity-starter` 目录中看到以下文件：
- en: '![Figure 2.19: Starter project files'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.19：启动项目文件'
- en: '](img/B14508_02_19.jpg)'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_02_19.jpg)'
- en: 'Figure 2.19: Starter project files'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.19：启动项目文件
- en: 'Open the `HeatMapTypes.d.ts` declaration file in the `types/` directory, define
    a module called `HeatMapTypes`, and export the interface named `Pitcher`. Define
    three attributes for the `Pitcher``batterHotZones`, `pitcherHotZones`, and `coordinateMap`.
    The data structures should be the same for all three attributes, `Array<Array<number>>`,
    but `coordinateMap` should be optional. Write the following code to accomplish
    this:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `types/` 目录中的 `HeatMapTypes.d.ts` 声明文件中，定义一个名为 `HeatMapTypes` 的模块，并导出一个名为
    `Pitcher` 的接口。为 `Pitcher` 定义三个属性：`batterHotZones`、`pitcherHotZones` 和 `coordinateMap`。所有三个属性的数据结构应该相同，为
    `Array<Array<number>>`，但 `coordinateMap` 应该是可选的。编写以下代码来完成此操作：
- en: '[PRE39]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code in the editor looks like this:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑器中前面的代码看起来是这样的：
- en: '![Figure 2.20: Creating a pitcher interface'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.20：创建投手界面'
- en: '](img/B14508_02_20.jpg)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_02_20.jpg)'
- en: 'Figure 2.20: Creating a pitcher interface'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.20：创建投手界面
- en: 'Open `heat_map_data.ts` and import the declaration files. Create and export
    a `let` variable called `data` and assign it to the `Pitcher` type. You will need
    to import the `lodash` library, which was installed when you initially ran `npm
    install`. Write the following code to do this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `heat_map_data.ts` 并导入声明文件。创建并导出一个名为 `data` 的 `let` 变量，并将其分配给 `Pitcher` 类型。你需要导入在最初运行
    `npm install` 时安装的 `lodash` 库。编写以下代码来完成此操作：
- en: '[PRE40]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add values to the `data` variable that adhere to the declaration rules. Assign
    nested arrays as values to both the `batterHotZones` and `pitcherHotZones` attributes.
    Add the following code to do this:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将符合声明规则的值添加到 `data` 变量中。将嵌套数组作为值分配给 `batterHotZones` 和 `pitcherHotZones` 属性。添加以下代码来完成此操作：
- en: '[PRE41]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a new function named `findMatch()` that takes in both the `batterHotZones`
    and `pitcherHotZones` arrays and utilize the `lodash` function, `intersectionWith()`,
    to return the identical nested array. Finally, store the value of the `findMatch()`
    function in the `coordinateMap` attribute that was defined in the declaration
    file. Write the following code to do this:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `findMatch()` 的新函数，该函数接受 `batterHotZones` 和 `pitcherHotZones` 数组，并使用
    `lodash` 函数 `intersectionWith()` 返回相同的嵌套数组。最后，将 `findMatch()` 函数的值存储在声明文件中定义的
    `coordinateMap` 属性中。编写以下代码来完成此操作：
- en: '[PRE42]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, in the terminal, type the following commands to generate the JavaScript
    code and run it:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中，键入以下命令以生成 JavaScript 代码并运行它：
- en: '[PRE43]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once we run the preceding commands, the following output is displayed in the terminal:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们运行前面的命令，终端会显示以下输出：
- en: '[PRE44]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding output, the common values from both the attributes are fetched
    and then printed. In this case, the common values are `[3, 2]`.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的输出中，从两个属性中获取了公共值，然后打印出来。在这种情况下，公共值是 `[3, 2]`。
- en: 'Now, change the values of both the attributes. Write the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更改这两个属性的值。编写以下代码：
- en: '[PRE45]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, in the terminal, type the following commands to generate the JavaScript
    code and run it:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中输入以下命令以生成 JavaScript 代码并运行：
- en: '[PRE46]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once we run the preceding commands, the following output is displayed in the terminal:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的命令后，终端显示以下输出：
- en: '[PRE47]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding output, the common values are `[10.2, -5]` and `[3, 2]`. Finally,
    we built a heat map log system that will track the baseball pitch data and ensure
    the integrity of the data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，公共值是 `[10.2, -5]` 和 `[3, 2]`。最后，我们构建了一个热图日志系统，该系统将跟踪棒球投球数据并确保数据的完整性。
- en: 3\. Functions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 函数
- en: 'Activity 3.01: Building a Flight Booking System with Functions'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 3.01：使用函数构建航班预订系统
- en: '**Solution:**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Start with the stubs provided in code samples. We have three files: `index.ts`,
    `bookings.ts`, and `flights.ts`. The `index.ts` file is a bit abstract and will
    just represent some of the transactions we push into our system. `bookings.ts`
    handles the user-facing activities of managing a booking, and `flights.ts` is
    the back office of filling up flights and making sure that everybody has a seat.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码示例中提供的存根开始。我们有三个文件：`index.ts`、`bookings.ts` 和 `flights.ts`。`index.ts` 文件相对抽象，将仅代表我们推入系统的一些交易。`bookings.ts`
    处理用户界面的预订管理活动，而 `flights.ts` 是后台，负责填充航班并确保每个人都有座位。
- en: 'The `index.ts` file won''t change unless you feel like changing it and adding
    some new scenarios. Let''s run it without adding any code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非你想修改它并添加一些新场景，否则 `index.ts` 文件不会发生变化。让我们不加任何代码运行它：
- en: '[PRE48]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So we have work to do. Several functions are not yet implemented. Let's start
    by looking at `flights.ts`. There is a partial implementation there as we have
    an interface called `Flights` that describes the attributes of a flight, a list
    of available flights implementing that interface, and even a method to fetch the
    flights, called `getDestinations`. We need to implement logic to check to see
    whether the number of seats we want to book are still available, logic that can
    hold seats while we confirm a reservation, and logic that converts those seats
    held into reserved seats once our payment has been processed.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此我们还有工作要做。几个函数尚未实现。让我们先看看 `flights.ts`。那里有一个部分实现，因为我们有一个名为 `Flights` 的接口，它描述了航班的属性，一个实现了该接口的可用航班列表，甚至还有一个名为
    `getDestinations` 的获取航班的方法。我们需要实现逻辑来检查我们想要预订的座位是否仍然可用，在确认预订时保留座位，以及在我们处理付款后，将这些保留的座位转换为已预订座位。
- en: 'To check availability, we should see whether the number of seats we''re requesting
    exceeds the number of remaining seats while holding any held seats in reserve.
    We can express this as `seatsRequested <= seatsRemaining - seatsHeld`, which is
    a Boolean expression that can be returned by the function. This can be written
    as an arrow function in the `flights.ts` file:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查可用性，我们应该查看我们请求的座位数量是否超过了剩余座位数量，同时保留任何已保留的座位。我们可以将这个表达式表示为 `seatsRequested
    <= seatsRemaining - seatsHeld`，这是一个布尔表达式，可以由函数返回。这可以在 `flights.ts` 文件中写成箭头函数：
- en: '[PRE49]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `holdSeats` function should confirm that the requested seats are available
    and hold them if they are. If there aren''t enough seats remaining, we need to
    throw an error and interrupt the flow:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`holdSeats` 函数应该确认请求的座位是否可用，如果可用则保留它们。如果剩余座位不足，我们需要抛出一个错误并中断流程：'
- en: '[PRE50]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To round out `flights.ts`, we have `reserveSeats`. This function operates similarly
    to `holdSeats`, but it confirms that the seats we wish to reserve have been held,
    and then converts them into reserved seats by increasing the `seatsHeld` property
    and reducing the `seatsRemaining` property by the same amount:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完善 `flights.ts`，我们有 `reserveSeats` 函数。这个函数与 `holdSeats` 函数类似，但它确认我们想要预留的座位已被保留，然后通过增加
    `seatsHeld` 属性并减少相同数量的 `seatsRemaining` 属性，将它们转换为已预订座位：
- en: '[PRE51]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That should do it for `flights.ts`. However, our program still won't run until
    we implement `bookings.ts`.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样 `flights.ts` 就完成了。然而，我们的程序仍然无法运行，直到我们实现了 `bookings.ts`。
- en: 'First of all, we''re going to use a factory pattern for creating bookings.
    That means we''ll have a function that returns a function to create bookings.
    We''ll employ currying to create a closure so that we can initialize the `createBooking`
    function with `bookingNumber` in order to give each booking a unique identifier.
    The factory could look like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用工厂模式来创建预订。这意味着我们将有一个返回函数以创建预订的函数。我们将使用柯里化来创建闭包，以便我们可以用 `bookingNumber`
    初始化 `createBooking` 函数，从而为每个预订提供一个唯一的标识符。工厂可能看起来像这样：
- en: '[PRE52]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our factory takes `bookingNumber` as an argument to initialize this value and
    then increments the number each time it creates a new booking. We assign some
    default values to the booking to confirm to the `Booking` interface already provided
    in the module.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的工厂接受 `bookingNumber` 作为参数来初始化这个值，然后在每次创建新的预订时增加这个数字。我们为预订分配一些默认值，以符合模块中已经提供的
    `Booking` 接口。
- en: 'To call the factory and get a `createBooking` function with `bookingNumber`
    already curried into it, we can simply write the following:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调用工厂并获取一个已经将 `bookingNumber` 预先柯里化的 `createBooking` 函数，我们可以简单地写出以下代码：
- en: '[PRE53]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We have yet to write functions to start the booking process, handle the payment,
    and complete the booking, thereby reserving the seats on a flight. To begin the
    booking, we need to check availability on the flight we''ve chosen based on the
    number of seats we''re requesting. If that is successful, we can create the booking
    and hold the seats. Otherwise, we can raise an error to alert the user to the
    fact that the booking cannot be completed:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还没有编写开始预订过程、处理支付和完成预订的函数，因此还没有预订座位。要开始预订，我们需要根据我们请求的座位数检查我们选择航班的可用性。如果这成功了，我们可以创建预订并保留座位。否则，我们可以抛出一个错误来提醒用户预订无法完成：
- en: '[PRE54]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In order to check flight availability and hold seats, we need to import these
    functions from `flights.ts`. This has already been done at the top of the `bookings.ts`
    module. The `export` keyword is used throughout these modules to make functions
    available to other modules. Some functions lack the `export` keyword, and so can
    only be invoked from within the module, effectively making them private.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查航班可用性和保留座位，我们需要从 `flights.ts` 中导入这些函数。这已经在 `bookings.ts` 模块的顶部完成。这些模块中使用了
    `export` 关键字，以便将函数提供给其他模块。一些函数缺少 `export` 关键字，因此只能在模块内部调用，实际上使它们成为私有的。
- en: 'We''ll cheat a little with our `processPayment` function since we aren''t implementing
    a payment system. We will just mark the booking as paid and return it:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们还没有实现支付系统，我们的 `processPayment` 函数会有一点欺骗性。我们只是将预订标记为已支付并返回它：
- en: '[PRE55]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To complete the booking, we call `reserveSeats` in the `flights` module and
    then update our counts:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成预订，我们在 `flights` 模块中调用 `reserveSeats`，然后更新我们的计数：
- en: '[PRE56]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'With all the functions implemented, we can invoke our program again and see
    the output:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有函数实现之后，我们可以再次调用我们的程序并查看输出：
- en: '[PRE57]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Activity 3.02: Writing Unit Tests'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动三.02：编写单元测试
- en: '**Solution:**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'In the `describe` block, fetch the destinations for this scenario and then
    cache the first one as `flight`. Now, we can write a simple test to test that
    the correct number of destinations were returned:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `describe` 块中，获取此场景的目的地，并将第一个目的地缓存为 `flight`。现在，我们可以编写一个简单的测试来测试是否返回了正确数量的目的地：
- en: '[PRE58]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We could test each of the individual destinations and their properties as well.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以测试每个单独的目的地及其属性。
- en: 'Check the availability of several of the destinations. We can introduce all
    sorts of scenarios. Here are a few:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查几个目的地的可用性。我们可以引入各种场景。以下是一些例子：
- en: '[PRE59]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The first destination has at least three seats available. The second does not
    have five available, and so on.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个目的地至少有三个座位可用。第二个目的地没有五个座位可用，以此类推。
- en: 'Try holding some seats in the next test. We should test both success and failure scenarios:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个测试中尝试保留一些座位。我们应该测试成功和失败的场景：
- en: '[PRE60]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that in order to ensure that the `catch` block was reached, we're expecting
    three assertions in this test. Without that, the test would still turn green even
    if, for some reason, the last call to `holdSeats` didn't throw an error.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，为了确保 `catch` 块被到达，我们在这个测试中期望有三个断言。如果没有这些断言，即使由于某种原因 `holdSeats` 的最后调用没有抛出错误，测试仍然会变成绿色。
- en: 'Finish up the flights test with a unit test to reserve seats:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单元测试完成航班测试以预订座位：
- en: '[PRE61]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This test runs through a few scenarios, including another error condition. In
    some cases, it might be appropriate to put error conditions in separate tests.
    A good rule of thumb for this is that each of your tests should be easy to comprehend
    and maintain. If any module or function gets to be too big, just break it up.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此测试运行了几个场景，包括另一个错误条件。在某些情况下，将错误条件放在单独的测试中可能是合适的。这个规则的一个好方法是，每个测试都应该易于理解和维护。如果任何模块或函数变得太大，只需将其拆分。
- en: 'Now, write some tests for bookings using the same principles:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用相同的原则为预订编写一些测试：
- en: '[PRE62]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s now try running the tests and see how things look:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们尝试运行测试，看看结果如何：
- en: '[PRE63]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The tests passed! But we haven''t hit 100% line coverage yet. We can actually
    open up the coverage report, which will be inside the `coverage/lcov-report` directory
    in the root of our project. The coverage tool (Istanbul) that comes bundled with
    Jest will produce an HTML report that we can open in any browser. This will show
    us the exact piece of code that hasn''t been covered:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试通过了！但我们还没有达到 100% 的行覆盖率。实际上，我们可以打开覆盖率报告，该报告位于项目根目录下的 `coverage/lcov-report`
    目录中。与 Jest 一起捆绑的覆盖率工具（Istanbul）将生成一个 HTML 报告，我们可以在任何浏览器中打开它。这将显示未覆盖的确切代码片段：
- en: '![Figure 3.2: HTML report produced by the tool'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 3.2：由工具生成的 HTML 报告'
- en: '](img/B14508_03_02.jpg)'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14508_03_02.jpg]'
- en: 'Figure 3.2: HTML report produced by the tool'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.2：由工具生成的 HTML 报告
- en: 'We''ve missed one error scenario. Let''s add that as a new `describe` block
    to avoid further complicating the tests we''ve already written:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遗漏了一个错误场景。让我们添加一个新的 `describe` 块以避免进一步复杂化我们已编写的测试：
- en: '[PRE64]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's no particular need to have a new `describe` block, but in this case,
    it might make the code a bit cleaner. Use `describe` and test blocks for readability
    and maintenance.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有特别需要一个新的 `describe` 块，但在这个情况下，它可能会使代码更整洁。使用 `describe` 和测试块来提高可读性和维护性。
- en: 'Let''s now run the tests again:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们再次运行测试：
- en: '[PRE65]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We've hit our goal of 100% line coverage!
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们达到了 100% 行覆盖率的目标！
- en: 4\. Classes and Objects
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 类和对象
- en: 'Activity 4.01: Creating a User Model Using Classes, Objects, and Interfaces'
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动四.01：使用类、对象和接口创建用户模型
- en: '**Solution:**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'In this activity, we''ll be building a user authentication system that will
    pass login data to a backend API to register and sign users into our baseball
    scorecard application. Perform the following steps to implement this activity:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个用户认证系统，该系统将登录数据传递到后端 API 以注册和登录我们的棒球比分卡应用程序。按照以下步骤实现此活动：
- en: 'Visit the following GitHub repository and download the activity project containing
    the specs and configuration elements: [https://packt.link/oaWbW](https://packt.link/oaWbW).'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问以下 GitHub 仓库并下载包含规范和配置元素的活动项目：[https://packt.link/oaWbW](https://packt.link/oaWbW)。
- en: The `activity-solution` directory contains the completed solution code, and
    the `activity-starter` directory provides the basic start code to work with.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`activity-solution` 目录包含完成后的解决方案代码，而 `activity-starter` 目录提供了基本起始代码以供工作使用。'
- en: 'Open the Visual Studio Code editor and then open the terminal. Change into
    the `activity-starter` directory in the terminal or command prompt and run the
    following command to install the dependencies:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code 编辑器，然后打开终端。在终端或命令提示符中切换到 `activity-starter` 目录，并运行以下命令来安装依赖项：
- en: '[PRE66]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You will now see the following files in the `activity-starter` directory:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您现在将在 `activity-starter` 目录中看到以下文件：
- en: '![Figure 4.10: Activity project files'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 4.10：活动项目文件'
- en: '](img/B14508_04_10.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14508_04_10.jpg]'
- en: 'Figure 4.10: Activity project files'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.10：活动项目文件
- en: 'Open the `auth.ts` file inside the `activity-starter` folder and create an
    interface named `ILogin` containing two string attributes, namely, `email` and
    `password`. Write the following code to accomplish this:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity-starter` 文件夹内的 `auth.ts` 文件，创建一个名为 `ILogin` 的接口，包含两个字符串属性，即 `email`
    和 `password`。编写以下代码来完成此操作：
- en: '[PRE67]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a `Login` class that takes in an object that contains the string attributes
    of `email` and `password`. Also, pass the `ILogin` interface as a parameter to
    the `constructor` function inside the `Login` class:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Login` 类，它接受一个包含字符串属性 `email` 和 `password` 的对象。同时，将 `ILogin` 接口作为参数传递给
    `Login` 类内部的 `constructor` 函数：
- en: '[PRE68]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create an interface named `IAuth` containing two attributes, `user` and `source`.
    Here, the `user` attribute will be of the `Login` type, and the `source` attribute
    will be of the `string` type. Write the following code to implement this:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `IAuth` 的接口，包含两个属性，`user` 和 `source`。在这里，`user` 属性的类型将是 `Login`，而 `source`
    属性的类型将是 `string`。编写以下代码以实现此功能：
- en: '[PRE69]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create an `Auth` class that takes in an object containing the attributes of
    `user` and `source`. Also, create a `constructor` function that will take the
    `IAuth` interface as a parameter. Write the following code to accomplish this:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Auth` 类，它接受一个包含 `user` 和 `source` 属性的对象。同时，创建一个 `constructor` 函数，它将 `IAuth`
    接口作为参数。编写以下代码以完成此操作：
- en: '[PRE70]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we''ll add a `validUser()` method to the `Auth` class, which returns
    a string stating that the user is authenticated if `email` is equal to `admin@example.com`,
    and if `password` is equal to `secret123`. If either of those values doesn''t
    match, the function will return a string stating that the user is not authenticated.
    Write the following code to define this function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `Auth` 类中添加一个 `validUser()` 方法，该方法在 `email` 等于 `admin@example.com`
    且 `password` 等于 `secret123` 时返回表示用户已认证的字符串。如果这些值中的任何一个不匹配，函数将返回表示用户未认证的字符串。编写以下代码以定义此函数：
- en: '[PRE71]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create two objects of the `Login` class, namely, `goodUser` and `badUser`.
    For the `goodUser` object, set the `email` value to `admin@example.com` and `password`
    to `secret123`. For the `badUser` object, set the `email` value to `admin@example.com`
    and `password` to `whoops`. Write the following code to accomplish this:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个 `Login` 类的实例，分别命名为 `goodUser` 和 `badUser`。对于 `goodUser` 对象，将 `email` 值设置为
    `admin@example.com`，将 `password` 设置为 `secret123`。对于 `badUser` 对象，将 `email` 值设置为
    `admin@example.com`，将 `password` 设置为 `whoops`。编写以下代码以完成此操作：
- en: '[PRE72]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create two objects of the `Auth` class, namely, `authAttemptFromGoodUser` and
    `authAttemptFromBadUser`. For the first object, assign the `goodUser` object of
    the `Login` class to the `user` attribute and `Google` to the `source` attribute.
    For the second object, assign the `badUser` object of the `Login` class to the
    `user` attribute and `Google` to the `source` attribute. Once both objects are
    created, call the `validUser()` function of the `Auth` class and print the results
    in the terminal. Write the following code to accomplish this:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个 `Auth` 类的实例，分别命名为 `authAttemptFromGoodUser` 和 `authAttemptFromBadUser`。对于第一个对象，将
    `Login` 类的 `goodUser` 对象分配给 `user` 属性，将 `Google` 分配给 `source` 属性。对于第二个对象，将 `Login`
    类的 `badUser` 对象分配给 `user` 属性，将 `Google` 分配给 `source` 属性。一旦创建了这两个对象，就调用 `Auth`
    类的 `validUser()` 函数，并在终端中打印结果。编写以下代码以完成此操作：
- en: '[PRE73]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, in the terminal, type the following commands to generate the JavaScript
    code and run it:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中输入以下命令以生成 JavaScript 代码并运行它：
- en: '[PRE74]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Once we run the preceding commands, the following output is displayed in the terminal:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行前面的命令，终端将显示以下输出：
- en: '[PRE75]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the preceding output, the `validUser()` function returns a `true` value when
    the correct details of `user` and `password` are passed. When incorrect details
    are passed, the function returns a `false` value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，当传递正确的 `user` 和 `password` 详细信息时，`validUser()` 函数返回 `true` 值。当传递错误的信息时，函数返回
    `false` 值。
- en: 5\. Interfaces and Inheritance
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 接口和继承
- en: 'Activity 5.01: Building a User Management Component Using Interfaces'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.01：使用接口构建用户管理组件
- en: '**Solution:**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Create a user object interface with the following properties: `email : string`,
    `loginAt : number`, and `token : string`. Make `loginAt` and `token` optional:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个具有以下属性的用户对象接口：`email : string`，`loginAt : number` 和 `token : string`。将
    `loginAt` 和 `token` 设置为可选：'
- en: '[PRE76]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Build a class interface with a global property user and use the interface created
    in *Step 1* to apply user object rules. You need to define a `getUser` method
    that returns the user object. Use the interface to ensure that the return object
    is a user object. Finally, define a `login` method that takes a `user` object
    and `password(type string)` as arguments. Use the user object interface as the
    `user` argument type:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个具有全局属性 `user` 的类接口，并使用在 *步骤 1* 中创建的接口应用用户对象规则。你需要定义一个 `getUser` 方法，该方法返回用户对象。使用接口确保返回的对象是用户对象。最后，定义一个
    `login` 方法，该方法接受一个 `user` 对象和 `password(type string)` 作为参数。使用用户对象接口作为 `user` 参数类型：
- en: '[PRE77]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Declare a class called `UserClass` that implements the class interface from
    *Step 2*. Your login method should assign the local function''s `user` argument
    to the global user property and return the global user. The `getUser` method should
    return the global user:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`UserClass`的类，该类实现了*步骤2*中的类接口。你的登录方法应将本地函数的`user`参数分配给全局用户属性并返回全局用户。`getUser`方法应返回全局用户：
- en: '[PRE78]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create an instance of your class, as declared in *Step 2*:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实例，如*步骤2*中声明的类：
- en: '[PRE79]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create a user object instance:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用户对象实例：
- en: '[PRE80]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Console out our methods to ensure that they are working as expected:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出我们的方法以确保它们按预期工作：
- en: '[PRE81]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The expected output is as follows:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE82]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This user management class is a central location where you can isolate all your
    application's user-related functions and rules. The rules you have crafted by
    using interfaces to implement your code will ensure that your code is better supported,
    easier to work with, and bug-free.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个用户管理类是一个中心位置，你可以将所有应用程序的用户相关功能和规则隔离在这里。通过使用接口实现你的代码所制定的规则将确保你的代码得到更好的支持，更容易操作，并且无错误。
- en: 'Activity 5.02: Creating a Prototype Web Application for a Vehicle Showroom
    Using Inheritance'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.02：使用继承在TypeScript中创建一个用于车辆展示厅的原型Web应用程序
- en: '**Solution:**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Create a parent class that will hold all common methods and properties for
    a base vehicle, define a constructor method that allows you to initialize the
    base properties of this class, and add a method that returns your properties as
    an object. If necessary, add an access modifier to properties and class methods
    you want to control access to:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所有基础车辆公共方法和属性的父类，定义一个构造函数，允许你初始化这个类的基属性，并添加一个返回你的属性作为对象的方法。如果需要，添加访问修饰符来控制对属性和类方法的访问：
- en: '[PRE83]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Derive two child classes from your parent class that are types of vehicles,
    for example, `Car` and `Truck`. Override your constructor to add some unique properties
    to your child classes based on the type of vehicles:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的父类派生两个子类，它们是车辆类型，例如`Car`和`Truck`。覆盖你的构造函数，根据车辆类型向子类添加一些独特的属性：
- en: '[PRE84]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Derive a class from one of the child classes created in *Step 3*, for example,
    `Suv`, which will have some of the things a truck might have, so it would be logical
    to extend `Truck`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤3*中创建的子类之一派生一个类，例如`Suv`，它将具有卡车可能具有的一些东西，因此扩展`Truck`是合理的：
- en: '[PRE85]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Instantiate your child class:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化你的子类：
- en: '[PRE86]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Console out our child class instance:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出我们的子类实例：
- en: '[PRE87]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You will obtain the following output:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '[PRE88]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In this activity, you created the bare minimum classes that we require for the
    web application. We have shown how we can build complexity, reuse, and extend
    application code with inheritance in TypeScript.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个活动中，你创建了我们需要用于Web应用程序的最基本的类。我们已经展示了如何使用TypeScript中的继承来构建复杂性、重用和扩展应用程序代码。
- en: 6\. Advanced Types
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 高级类型
- en: 'Activity 6.01: Intersection Type'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：交集类型
- en: '**Solution:**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Create a `Motor` type, which will house some common properties you may reuse
    on their own or in combination with other types to describe a vehicle object.
    You can use the following properties as a starting point: `color`, `doors`, `wheels`,
    and `fourWheelDrive`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Motor`类型，它将包含一些你可以单独或与其他类型组合使用的常见属性，以描述车辆对象。你可以使用以下属性作为起点：`color`、`doors`、`wheels`和`fourWheelDrive`：
- en: '[PRE89]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create a `Truck` type with properties common to a truck, for example, `doubleCab`
    and `winch`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有卡车常见属性的`Truck`类型，例如`doubleCab`和`winch`：
- en: '[PRE90]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Intersect the two types to create a `PickUpTruck` type:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交集这两个类型以创建一个`PickUpTruck`类型：
- en: '[PRE91]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Build a `TruckBuilder` function that returns our `PickUpTruck` type and also
    takes `PickUpTruck` as an argument:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`TruckBuilder`函数，它返回我们的`PickUpTruck`类型，并接受`PickUpTruck`作为参数：
- en: '[PRE92]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Console out the function return:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出函数返回值：
- en: '[PRE93]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You should see the following output once you run the file:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行文件，你应该看到以下输出：
- en: '[PRE94]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Activity 6.02: Union Type'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.02：联合类型
- en: '**Solution:**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Build a `LandPack` and an `AirPack` type. Make sure to have a literal to identify
    the package type:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`LandPack`和`AirPack`类型。确保有一个文字来识别包裹类型：
- en: '[PRE95]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Construct a union type, `ComboPack`, which can be `LandPack` or `AirPack`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个联合类型`ComboPack`，可以是`LandPack`或`AirPack`：
- en: '[PRE96]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Make a `Shipping` class to process your packages. Make sure to use your literal
    to identify your package types and modify your package with the correct label
    for its type:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Shipping`类来处理你的包裹。确保使用你的文字来识别你的包裹类型，并使用正确的标签修改你的包裹类型：
- en: '[PRE97]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Create two package objects of the `AirPack` and `LandPack` types. Then, instantiate
    your `Shipping` class, process your new objects, and console out the modified
    objects:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个 `AirPack` 和 `LandPack` 类型的包装对象。然后，实例化您的 `Shipping` 类，处理您的新对象，并输出修改后的对象：
- en: '[PRE98]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Once you run the file, you will obtain the following output:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行文件，您将获得以下输出：
- en: '[PRE99]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Activity 6.03: Index Type'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.03：索引类型
- en: '**Solution:**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Build your `PackageStatus` index type using an interface with a `status` property
    of the `string` type and a value of the `Boolean` type:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用具有 `status` 属性为 `string` 类型、值为 `Boolean` 类型的接口构建 `PackageStatus` 索引类型：
- en: '[PRE100]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create a `Package` type that includes a property of the `PackageStatus` type
    and some common properties of a typical package:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 `PackageStatus` 类型属性和一些典型包装的常见属性的 `Package` 类型：
- en: '[PRE101]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Make a class to process your `Package` type, which takes the `Package` type
    on initialization, has a method to return your `packageStatus` property, and a
    method that updates and returns the `packageStatus` property:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个处理 `Package` 类型的类，该类在初始化时接受 `Package` 类型，有一个返回 `packageStatus` 属性的方法，以及一个更新并返回
    `packageStatus` 属性的方法：
- en: '[PRE102]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create a `Package` object called `pack`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pack` 的 `Package` 对象：
- en: '[PRE103]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Instantiate your `PackageProcess` class with your new `pack` object:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您新的 `pack` 对象实例化您的 `PackageProcess` 类：
- en: '[PRE104]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Console out your `pack` status:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出您的 `pack` 状态：
- en: '[PRE105]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Update your `pack` status and console out your new `pack` status:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的 `pack` 状态，并输出您的新 `pack` 状态：
- en: '[PRE106]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Once you run the file, you should obtain the following output:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行文件，你应该获得以下输出：
- en: '[PRE107]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The first line in the preceding output displays the original `pack` status,
    whereas the second line displays the updated `pack` status.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的输出中的第一行显示原始的 `pack` 状态，而第二行显示更新的 `pack` 状态。
- en: 7\. Decorator
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 装饰器
- en: 'Activity 7.01: Creating Decorators for Call Counting'
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动七.01：创建用于调用计数的装饰器
- en: '**Solution:**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: Create a class called `Person` with the public properties `firstName`, `lastName`,
    and `birthday`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Person` 的类，具有公共属性 `firstName`、`lastName` 和 `birthday`。
- en: 'Add a constructor that initializes the properties via the constructor parameters:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个构造函数，通过构造函数参数初始化属性：
- en: '[PRE108]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Add a private field called `_title` and expose it via a `getter` and `setter`
    as a property called `title`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `_title` 的私有字段，并通过 `getter` 和 `setter` 作为名为 `title` 的属性公开它：
- en: '[PRE109]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Add a method called `getFullName` that will return the full name of person:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `getFullName` 的方法，该方法将返回人的全名：
- en: '[PRE110]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Add a method called `getAge` that will return the current age of the person
    (by subtracting the birthday from the current year):'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `getAge` 的方法，该方法将返回人的当前年龄（通过从当前年份减去生日）：
- en: '[PRE111]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Create a global object called `count` and initialize it to the empty object:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `count` 的全局对象，并将其初始化为空对象：
- en: '[PRE112]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Create a constructor wrapping decorator factory called `CountClass` that will
    take a string parameter called `counterName`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `CountClass` 的构造函数包装装饰器工厂，该工厂将接受一个名为 `counterName` 的字符串参数：
- en: '[PRE113]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Inside the wrapping code, increase the `count` object''s property defined in
    the `counterName` parameter by 1 and then set the prototype chain of the wrapped
    constructor:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包装代码内部，将 `count` 对象的 `counterName` 参数定义的属性增加 1，然后设置包装构造函数的原型链：
- en: '[PRE114]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Create a method wrapping decorator factory called `CountMethod` that will take
    a string parameter called `counterName`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `CountMethod` 的方法包装装饰器工厂，该工厂将接受一个名为 `counterName` 的字符串参数：
- en: '[PRE115]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Add checks for whether the descriptor parameter has `value`, `get`, and `set` properties:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对描述符参数是否具有 `value`、`get` 和 `set` 属性的检查：
- en: '[PRE116]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In each respective branch, add code that wraps the method:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个相应的分支中，添加包装方法的代码：
- en: '[PRE117]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Inside the wrapping code, increase the `count` object''s property defined in
    the `counterName` parameter by 1:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包装代码内部，将 `count` 对象的 `counterName` 参数定义的属性增加 1：
- en: '[PRE118]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Decorate the class using the `CountClass` decorator, with a `person` parameter:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `CountClass` 装饰器装饰类，使用 `person` 参数：
- en: '[PRE119]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Decorate `getFullName`, `getAge`, and the `title` property getter with the
    `CountMethod` decorator, with the `person-full-name`, `person-age`, and `person-title`
    parameters, respectively:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `CountMethod` 装饰器装饰 `getFullName`、`getAge` 和 `title` 属性获取器，分别使用 `person-full-name`、`person-age`
    和 `person-title` 参数：
- en: '[PRE120]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Write code outside the class that will instantiate three `person` objects:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类外部编写代码，实例化三个 `person` 对象：
- en: '[PRE121]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Write code that will call the `getFullName` and `getAge` methods on the objects:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以调用对象的 `getFullName` 和 `getAge` 方法：
- en: '[PRE122]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Write code that will check whether the `title` property is empty and set it
    to something if it is:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码检查 `title` 属性是否为空，如果为空则设置它：
- en: '[PRE123]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Write code that will log the `count` object to the console:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码将 `count` 对象记录到控制台：
- en: '[PRE124]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Once you run the file, you will obtain the following output on the console:'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行文件，你将在控制台获得以下输出：
- en: '[PRE125]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Activity 7.02: Using Decorators to Apply Cross-Cutting Concerns'
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 7.02：使用装饰器应用横切关注点
- en: '**Solution:**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Create the code for the `BasketBallGame` class:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `BasketBallGame` 类的代码：
- en: '[PRE126]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Create a class decorator factory called `Authenticate` that will take a `permission`
    parameter and return a class decorator with constructor wrapping. The class decorator
    should load the `permissions` metadata property (array of `strings`), then check
    if the passed parameter is an element of the array. If the passed parameter is
    not an element of the array, the class decorator should throw an error, and if
    present, it should continue with the class creation:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Authenticate` 的类装饰器工厂，它将接受一个 `permission` 参数并返回一个具有构造函数包装的类装饰器。类装饰器应加载
    `permissions` 元数据属性（字符串数组），然后检查传递的参数是否为数组的元素。如果传递的参数不是数组的元素，则类装饰器应抛出错误；如果存在，则应继续进行类创建：
- en: '[PRE127]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Define a metadata property of the `BasketballGame` class called `permissions`
    with the value ["`canUpdateScore`"]:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '定义 `BasketBallGame` 类的一个名为 `permissions` 的元数据属性，其值为 ["`canUpdateScore`"]:'
- en: '[PRE128]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Apply the class decorator factory on the `BasketballGame` class with a parameter
    value of "`canUpdateScore"`:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `BasketBallGame` 类上应用类装饰器工厂，参数值为 "`canUpdateScore`":'
- en: '[PRE129]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Create a method decorator called `MeasureDuration` that will use method wrapping
    to start a timer before the method body is executed and stop it after it''s done.
    You need to calculate the duration and push it to a metadata property called `durations`
    for the method:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MeasureDuration` 的方法装饰器，它将使用方法包装在方法体执行前启动计时器，并在完成后停止。你需要计算持续时间并将其推送到名为
    `durations` 的方法元数据属性中：
- en: '[PRE130]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Apply the `MeasureDuration` method decorator on the `updateScore` method:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `updateScore` 方法上应用 `MeasureDuration` 方法装饰器：
- en: '[PRE131]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Create a method decorator factory called `Audit` that will take a message parameter
    and return a method decorator. The method decorator should use method wrapping
    to get the arguments and the return value of the method. After the successful
    execution of the original method, it should display the audit log to the console:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Audit` 的方法装饰器工厂，它将接受一个消息参数并返回一个方法装饰器。该方法装饰器应使用方法包装来获取方法的参数和返回值。在原始方法成功执行后，它应在控制台显示审计日志：
- en: '[PRE132]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Apply the `Audit` method decorator factory on the `updateScore` method, with
    a parameter value of `Updated score`:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `updateScore` 方法上应用 `Audit` 方法装饰器工厂，参数值为 `Updated score`：
- en: '[PRE133]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Create a parameter decorator called `OneTwoThree` that will add the decorated
    parameter in the `one-two-three` metadata property:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `OneTwoThree` 的参数装饰器，它将添加到 `one-two-three` 元数据属性中：
- en: '[PRE134]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Create a method decorator called `Validate` that will use method wrapping to
    load all values for the `one-two-three` metadata property, and for all marked
    parameters, check their value. If the value is 1, 2, or 3, you should continue
    the execution of the original method. If not, you should stop the execution with
    an error:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Validate` 的方法装饰器，它将使用方法包装来加载 `one-two-three` 元数据属性的所有值，并检查所有标记参数的值。如果值为
    1、2 或 3，则应继续执行原始方法。如果不是，则应停止执行并显示错误：
- en: '[PRE135]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Apply the `OneTwoThree` decorator to the `byPoints` parameter of `updateScore`
    and apply the `Validate` decorator to the `updateScore` method.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OneTwoThree` 装饰器应用于 `updateScore` 的 `byPoints` 参数，并将 `Validate` 装饰器应用于 `updateScore`
    方法。
- en: '[PRE136]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Create a `game` object and update its score a few times:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `game` 对象并更新其分数几次：
- en: '[PRE137]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'When you run the file, the console should reflect the application of all decorators:'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你运行文件时，控制台应反映所有装饰器的应用：
- en: '[PRE138]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 8\. Dependency Injection in TypeScript
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. TypeScript 中的依赖注入
- en: 'Activity 8.01: DI-Based Calculator'
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.01：基于 DI 的计算器
- en: '**Solution:**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'In this activity, we will build a basic calculator that utilizes DI to evaluate
    mathematical expressions, as well as logging its output to either the console
    or a file:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个基本的计算器，该计算器利用依赖注入（DI）来评估数学表达式，并将输出记录到控制台或文件中：
- en: 'To start things off, define the basic building block of our calculator – an
    operator. This is defined via an interface, which actual implementations can rely
    on:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义我们计算器的基本构建块——一个操作符。这是通过一个接口定义的，实际的实现可以依赖于它：
- en: '[PRE139]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: You need to create this file in the `src/interfaces` folder and save it as `operator.interface.ts`.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要在`src/interfaces`文件夹中创建这个文件，并将其保存为`operator.interface.ts`。
- en: 'Next, implement the first operator – the addition operator. This will be a
    class that implements the `Operator` interface:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现第一个操作符——加法操作符。这将是一个实现`Operator`接口的类：
- en: '[PRE140]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The preceding code needs to be written in a file called `add.operator.ts` in
    `src\operators`.
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码需要在一个名为`add.operator.ts`的文件中编写，位于`src\operators`文件夹中。
- en: 'Make this operator available for injection by InversifyJS by adding the `@injectable`
    decorator to the class:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在类中添加`@injectable`装饰器，使这个操作符可供InversifyJS注入：
- en: '[PRE141]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Next, since interfaces don''t exist at runtime, we need to create some runtime
    representation of our abstraction for `AddOperator`. This is usually done using
    symbols, and will be used by InversifyJS at runtime to understand what needs to
    be injected. We''ll define it under a `TYPES` constant, which we''ll be able to
    add other symbols for later:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，由于接口在运行时不存在，我们需要为`AddOperator`的抽象创建一些运行时表示。这通常是通过符号完成的，并将由InversifyJS在运行时用来理解需要注入的内容。我们将在`TYPES`常量下定义它，我们将在以后添加其他符号：
- en: '[PRE142]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This code needs to be written in a new file saved in the `src\types\` folder.
    We have named this file `index.ts`.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码需要在一个新的文件中编写，并保存到`src\types\`文件夹中。我们给这个文件命名为`index.ts`。
- en: 'Now, build a first draft for our calculator, which will use `AddOperator`,
    via DI:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为我们的计算器构建一个初步草案，它将使用`AddOperator`通过DI：
- en: '[PRE143]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Here, we implement a `Calculator` class that has a single method – `evaluate`,
    which takes in an expression as a string, and returns the result for that expression.
    This code needs to be written in a new file called `index.ts`, saved in the `src/calculator`
    folder.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们实现一个`Calculator`类，它只有一个方法——`evaluate`，该方法接收一个字符串形式的表达式，并返回该表达式的结果。这段代码需要在一个名为`index.ts`的新文件中编写，并保存在`src/calculator`文件夹中。
- en: Note
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The current implementation only supports expressions in the form of X+Y (where
    X and Y can be any numbers). We'll fix that later in the activity.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当前实现仅支持X+Y形式的表达式（其中X和Y可以是任何数字）。我们将在活动后期修复这个问题。
- en: Calculator gets `AddOperator` in DI, and in order to evaluate the expression,
    it first runs through a regular expression to split it by numbers, and then it
    *destructures* the result array. Lastly, it uses the `evaluate` method of `AddOperator`
    to perform the final expression evaluation.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算器通过DI获取`AddOperator`，为了评估表达式，它首先通过正则表达式按数字分割它，然后*解构*结果数组。最后，它使用`AddOperator`的`evaluate`方法执行最终的表达式评估。
- en: This means that the calculator's responsibility is only to destructure the expression
    into its individual parts, and then pass it off to `AddOperator` to handle the
    math evaluation logic. This demonstrates how using DI helps to retain the single
    responsibility principle of SOLID.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着计算器的职责仅仅是将表达式解构为其各个部分，然后将其传递给`AddOperator`来处理数学评估逻辑。这展示了使用DI如何帮助保持SOLID原则中的单一职责原则。
- en: 'Configure the IoC container (in the `src/ioc.config.ts` file) so that `Calculator`
    can receive `AddOperator` when it asks for `TYPES.AddOperator`:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置IoC容器（在`src/ioc.config.ts`文件中），以便当`Calculator`请求`TYPES.AddOperator`时，可以接收`AddOperator`：
- en: '[PRE144]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Finally, our main file (`src/main.ts`), which will kick things off when we
    run the application, is as follows:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的主文件（`src/main.ts`），当运行应用程序时启动，如下所示：
- en: '[PRE145]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: This is just using our previously defined IoC container and asking it for a
    `Calculator` instance. This is how we ask for instances of symbols explicitly
    in InversifyJS in an imperative API, which we need here, since we want to kick
    things off. Since InversifyJS is the one creating `Calculator`, it also looks
    at its constructor and sees that we've asked for a `TYPES.AddOperator`, which
    it then looks up in the IoC container again to resolve and gives that to the calculator's
    constructor.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是使用我们之前定义的IoC容器并请求一个`Calculator`实例。这是我们如何在InversifyJS的命令式API中显式请求符号实例的方式，在这里我们需要这样做，因为我们想启动一些事情。由于InversifyJS是创建`Calculator`的，它也会查看其构造函数，并看到我们请求了`TYPES.AddOperator`，然后它再次在IoC容器中查找以解析，并将其提供给`Calculator`的构造函数。
- en: 'Once you run this file, you should obtain the following output:'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行此文件，您应该获得以下输出：
- en: '[PRE146]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Note that you can either run the code by executing `npm start` in the `activity-starter`
    folder or by executing `npx ts-node main.ts` in the `src` folder.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，您可以通过在`activity-starter`文件夹中执行`npm start`或通过在`src`文件夹中执行`npx ts-node main.ts`来运行代码。
- en: Note
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If the `AddOperator` class were also to require dependencies using `@inject`,
    the same process described above would be repeated again to get them, and so on
    recursively until all dependencies have been resolved.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `AddOperator` 类也需要使用 `@inject` 来依赖注入，那么上述过程将再次重复以获取它们，依此类推，直到所有依赖项都得到解决。
- en: 'Next, we can implement the other operators, similar to how we did with `AddOperator`
    – just replace the symbol with the relevant one (`-`, `*`, `/`) and the evaluate
    method''s implementation with the relevant math operation:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以实现其他操作符，类似于我们实现 `AddOperator` 的方式——只需将符号替换为相关的符号（`-`、`*`、`/`）并将评估方法的实现替换为相关的数学运算：
- en: 'Here is the code for `SubtractOperator` (`subtract.operator.ts`):'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '下面是 `SubtractOperator` 的代码 (`subtract.operator.ts`):'
- en: '[PRE147]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Here is the code for `MultiplyOperator` (`multiply.operator.ts`):'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '下面是 `MultiplyOperator` 的代码 (`multiply.operator.ts`):'
- en: '[PRE148]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Here is the code for `DivideOperator` (`divide.operator.ts`):'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '下面是 `DivideOperator` 的代码 (`divide.operator.ts`):'
- en: '[PRE149]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Now, instead of creating an injection token for each `Operator`, injecting each
    one into `Calculator`, and then acting on each, we can create a more generic implementation
    of `Calculator` with the help of the `@multiInject` decorator. This decorator
    allows an injection token to be specified and an array of all implementations
    registered for that token to be obtained. This way, `Calculator` is not even coupled
    to an abstraction for any specific operator and only gets a dynamic list of operators,
    which can have any implementation as long as it conforms to the `Operator` interface.
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们不再为每个 `Operator` 创建一个注入令牌，将每个注入到 `Calculator` 中，然后对每个进行操作，而是可以借助 `@multiInject`
    装饰器创建一个更通用的 `Calculator` 实现。这个装饰器允许指定一个注入令牌，并获取为该令牌注册的所有实现数组。这样，`Calculator` 就不再耦合到任何特定操作符的抽象，而只得到一个动态的操作符列表，只要它们符合
    `Operator` 接口，就可以有任意的实现。
- en: 'Update the `types/index.ts` file with the following code:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `types/index.ts` 文件，代码如下：
- en: '[PRE150]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This replaces our `AddOperator` symbol from earlier with a more generic one.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将替换我们之前使用的 `AddOperator` 符号，使用一个更通用的符号。
- en: 'Update the calculator app code (`src/calculator/index.ts`):'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '更新计算器应用程序代码 (`src/calculator/index.ts`):'
- en: '[PRE151]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Update the `ioc.config.ts` file:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `ioc.config.ts` 文件：
- en: '[PRE152]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Next, fix the naïve `evaluate` method of `Calculator` to be more generic, too.
    First, instead of relying on a specific token, `tryParseNumberString` and `tryParseOperatorSymbol`
    yourself. However, you can refer to `utils/math.ts` to help you complete this
    step.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修复 `Calculator` 的简单 `evaluate` 方法，使其更加通用。首先，不再依赖于特定的标记，而是自己实现 `tryParseNumberString`
    和 `tryParseOperatorSymbol`。然而，你可以参考 `utils/math.ts` 来帮助你完成这一步。
- en: 'Then, reduce this array to get our final result:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，减少这个数组以获得我们的最终结果：
- en: '[PRE153]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Simplify the code in the `ioc.config.ts` file even further by leveraging barrels.
    Create `operator/index.ts` with the following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过利用 barrels 进一步简化 `ioc.config.ts` 文件中的代码。创建 `operator/index.ts`，代码如下：
- en: '[PRE154]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Update the `ioc.config.ts` file:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `ioc.config.ts` 文件：
- en: '[PRE155]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: This means we now import an `Operators` object from the barrel file, which includes
    everything that's exposed there. We take the values of that barrel object and
    bind each one to `TYPES.Operator`, generically.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们现在从 barrel 文件中导入一个 `Operators` 对象，它包含了那里暴露的所有内容。我们取这个 barrel 对象的值，并将每个值绑定到
    `TYPES.Operator`，实现通用化。
- en: This means that adding another `Operator` object only requires us to create
    a new class that implements the `Operator` interface and add it to our `operators/index.ts`
    file. The rest of the code should work without any changes.
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着添加另一个 `Operator` 对象只需要我们创建一个新的类来实现 `Operator` 接口，并将其添加到我们的 `operators/index.ts`
    文件中。其余的代码应该无需任何更改即可正常工作。
- en: 'Our `main.ts` file is changed to a slightly more complicated expression:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `main.ts` 文件被修改为一个稍微复杂一些的表达式：
- en: '[PRE156]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'When you run the `main.ts` file (using `npx ts-node main.ts`), you should obtain
    the following output:'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你运行 `main.ts` 文件（使用 `npx ts-node main.ts`）时，你应该获得以下输出：
- en: '[PRE157]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '**Bonus:**'
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Bonus:**'
- en: 'As a bonus, let''s say that we want some reporting on the operations performed
    in the calculator. We can add logging pretty easily without too many changes.
    We''ll create two reporting implementations, one to the console and another to
    a filesystem:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为奖励，假设我们想要对计算器中执行的操作进行一些报告。我们可以非常容易地添加日志记录，而无需太多更改。我们将创建两个报告实现，一个输出到控制台，另一个输出到文件系统：
- en: Note
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The filesystem implementation will only work in a Node.js environment, since
    it will use some modules only available to it.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件系统实现仅在 Node.js 环境中工作，因为它将使用仅对该环境可用的某些模块。
- en: 'Define the `Logger` interface:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `Logger` 接口：
- en: '[PRE158]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: This will serve as the public API that the consumers wanting a logger can use,
    and that our implementations will need to adhere to.
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将作为想要使用日志记录器的消费者可以使用的公共API，并且我们的实现需要遵循。
- en: 'Create the console-based implementation of `Logger` first:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建基于控制台的`Logger`实现：
- en: '[PRE159]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: This is a simple wrapper class around the `console` object that's built into
    browser engines and Node.js. It adheres to our `Logger` interface, and so allows
    consumers to depend on it. For the example, we've also added the type of the message
    to the beginning of the actual output.
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个围绕浏览器引擎和Node.js中内置的`console`对象构建的简单包装类。它遵循我们的`Logger`接口，因此允许消费者依赖它。为了示例，我们还将在实际输出的开头添加消息类型。
- en: 'Next, create an injection token for it, and register it in our container. The
    updated code for the `types/index.ts` file is as follows:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为它创建一个注入令牌，并在我们的容器中注册它。`types/index.ts`文件的更新代码如下：
- en: '[PRE160]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The updated code for the `src/ioc.config.ts` file is as follows:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`src/ioc.config.ts`文件的更新代码如下：'
- en: '[PRE161]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Finally, use the logger in our `Calculator` class:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的`Calculator`类中使用该日志记录器：
- en: '[PRE162]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Notice that we use the `@optional` decorator to indicate to InversifyJS that
    `Calculator` doesn't *require* a `Logger` to operate, but if it has one it can
    inject, `Calculator` can use it. This is also why it's marked as an optional argument
    in the constructor, and why we need to check whether it exists before calling
    the `log` method.
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用`@optional`装饰器来告知InversifyJS，`Calculator`不需要`Logger`来操作，但如果它有一个可以注入的`Logger`，`Calculator`可以使用它。这也是为什么它被标记为构造函数中的可选参数，以及为什么我们需要在调用`log`方法之前检查它是否存在。
- en: 'The output to the console when running it should be as follows:'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行时的控制台输出应如下所示：
- en: '[PRE163]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Now, let's say we want to replace our console-based logger with a file-based
    one, which will persist across runs so that we can track the calculator's evaluation history.
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，假设我们想要将我们的基于控制台的日志记录器替换为基于文件的，这样它就可以在运行之间持久化，以便我们可以跟踪计算器的评估历史。
- en: 'Create a `FileLogger` class that implements `Logger`:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现`Logger`的`FileLogger`类：
- en: '[PRE164]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: And finally, all we need to do in order to replace our console-based logger
    with a file-based one is a single-line change in our IoC container configuration.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了将我们的基于控制台的日志记录器替换为基于文件的，我们只需要在IoC容器配置中进行单行更改。
- en: 'For console-based logging, use this command:'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于基于控制台的日志记录，使用以下命令：
- en: '[PRE165]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'For file-based logging, use this command:'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于基于文件的日志记录，使用以下命令：
- en: '[PRE166]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Make sure to import this logger correctly in the `ioc.config.ts` file.
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保在`ioc.config.ts`文件中正确导入此日志记录器。
- en: 'The final output to the file is as follows:'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的文件输出如下：
- en: '![Figure 8.8: Final output of the file-based logger in activity-starter/src//tmp/calculator.log,
    after changing the app to use it'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.8：在activity-starter/src//tmp/calculator.log中基于文件的日志记录器的最终输出，在将应用程序更改为使用它之后'
- en: '](img/B14508_08_08.jpg)'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_08_08.jpg)'
- en: 'Figure 8.8: Final output of the file-based logger in activity-starter/src//tmp/calculator.log,
    after changing the app to use it'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：在activity-starter/src//tmp/calculator.log中基于文件的日志记录器的最终输出，在将应用程序更改为使用它之后
- en: 9\. Generics and Conditional Types
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 泛型和条件类型
- en: 'Activity 9.01: Creating a DeepPartial<T> Type'
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动9.01：创建DeepPartial<T>类型
- en: '**Solution:**'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Let''s build this type up, step by step:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步构建这个类型：
- en: 'First, let''s create a `PartialPrimitive` type:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个`PartialPrimitive`类型：
- en: '[PRE167]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Then, let''s start by defining a basic `DeepPartial<T>` type:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们首先定义一个基本的`DeepPartial<T>`类型：
- en: '[PRE168]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Next, we need to handle more complex structures – such as arrays, sets, and
    maps. These require using the `infer` keyword, and in addition to that, require
    some more "manual wiring" for each of these types.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理更复杂的数据结构，例如数组、集合和映射。这些需要使用`infer`关键字，并且对于这些类型中的每一个，还需要进行一些“手动连接”。
- en: 'Let''s start with adding handling for the `Array` type:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从添加对`Array`类型的处理开始：
- en: '[PRE169]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'This would''ve worked, but due to current limitations in TypeScript at the
    time of writing, this doesn''t compile, since `DeepPartial<T>` circularly references itself:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这本来可以工作，但由于在编写时TypeScript的限制，由于`DeepPartial<T>`循环引用自身，因此无法编译：
- en: '![Figure 9.17: Current TypeScript version limitation not allowing generic'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.17：当前TypeScript版本的限制不允许使用泛型'
- en: types to reference themselves
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型可以引用自身
- en: '](img/B14508_09_17.jpg)'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_09_17.jpg)'
- en: '[PRE170]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This works around the problem and compiles fine.
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这解决了问题，并且编译良好。
- en: 'Next, to support a `Set`, a similar approach to what we did in the previous
    step is needed, so we''ll create an `interface` to serve as a "middle-man" for
    building the entire generic type:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Similarly to arrays and sets, maps also need the approach wherein we need create
    an `interface` to serve as a "middle-man" for building the entire generic type:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Note
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This workaround is no longer needed as of TypeScript 3.7.
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lastly, let''s make our `DeepPartial<T>` type support objects too:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: This completes the `DeepPartial<T>` implementation.
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A great use case for the `DeepPartial<T>` type is in a server-side `PATCH`
    method handler, which updates a given resource with new data. In `PATCH` requests,
    all fields are usually optional:'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Notice that we use `DeepPartial<User>` to correctly type the body of the request,
    before passing it in the `update` method:'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.18: The correctly typed request body'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_09_18.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.18: The correctly typed request body'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the preceding figure, due to the usage of `DeepPartial<T>`,
    the request's body is typed correctly, such that all fields are optional, including
    nested ones.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Event Loop and Asynchronous Behavior
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 10.01: Movie Browser Using XHR and Callbacks'
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: In the `script.ts` file, locate the `search` function and verify that it takes
    a single string parameter and that its body is empty.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct a new `XMLHttpRequest` object:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Construct a new string for the search result URL using the `getSearchUrl` method:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Call the `open` and `send` methods of the `xhr` object:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Add an event handler for the `xhr` object''s `onload` event. Take the response
    and parse it as a JSON object. Store the result in a variable of the `SearchResultApi`
    interface. This data will have the results of our search in a `results` field.
    If we get no results, this means that our search failed:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'If the search returned no results, call the `clearResults` method:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'If the search returned some results, just take the first one and store it in
    a variable, ignoring the other ones:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Inside the `onload` handler, in the successful search branch, create a new
    `XMLHttpRequest` object:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Construct a new string for the search result URL using the `getMovieUrl` method:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Call the `open` and `send` method of the constructed `xhr` object:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Add an event handler for the `xhr` object''s `onload` event. Take the response
    and parse it as a JSON object. Store the result in a variable of the `MovieResultApi`
    interface. This response will have the general data for our movie, specifically,
    everything except the people who were involved in the movie. We will need to have
    another call to the API to get the data about the people:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Inside the `onload` handler, create a new `XMLHttpRequest` object:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Construct a new string for the search result URL using the `getPeopleUrl` method:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Call the `open` and `send` method of the constructed `xhr` object:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Add an event handler for the `xhr` object''s `onload` event. Take the response,
    and parse it as a JSON object. Store the result in a variable of the `PeopleResultApi`
    interface. This response will have data about the people who were involved in
    the movie:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`xhr`对象的`onload`事件添加事件处理器。获取响应，并将其解析为JSON对象。将结果存储在`PeopleResultApi`接口的变量中。此响应将包含有关参与电影的人员的数据：
- en: '[PRE188]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Now we actually have all the data we need, so we can actually create our own
    object, inside the people `onload` handler, which is inside the movie `onload`
    handler, which is inside the search `onload` handler.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们实际上已经拥有了所有需要的数据，因此我们可以在人员`onload`处理器中创建自己的对象，该处理器位于电影`onload`处理器中，而电影`onload`处理器又位于搜索`onload`处理器中。
- en: 'The people data has `cast` and `crew` properties. We''ll only take the first
    six cast members, so first sort the `cast` property according to the `order` property
    of the cast members. Then slice off the first six cast members into a new array:'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 人员数据具有`cast`和`crew`属性。我们只取前六个演员，所以首先根据演员的`order`属性对`cast`属性进行排序。然后从第一个六个演员中切出新的数组：
- en: '[PRE189]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Transform the cast data (which is `CastResultApi` objects) into your own `Character`
    objects. We need to map the `character` field of `CastResultApi` to the `name`
    field of `Character`, the `name` field to the `actor` name, and the `profile_path`
    field to the `image` property:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将演员数据（`CastResultApi`对象）转换为您的`Character`对象。我们需要将`CastResultApi`的`character`字段映射到`Character`的`name`字段，将`name`字段映射到演员名字，将`profile_path`字段映射到`image`属性：
- en: '[PRE190]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'From the `crew` property of the people data, we''ll only need the director
    and the writer. Since there can be multiple directors and writers, we''ll get
    the names of all directors and writers and concatenate them, respectively. For
    the directors, from the `crew` property, filter the people who have a `department`
    of `Directing` and a `job` of `Director`. For those objects, take the `name` property,
    and `join` it together with an `&` in between:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从人员数据的`crew`属性中，我们只需要导演和编剧。由于可能有多个导演和编剧，我们将分别获取所有导演和编剧的名字并将它们连接起来。对于导演，从`crew`属性中筛选出具有`Directing`部门和`Director`职位的员工。对于这些对象，取`name`属性，并用`&`连接起来：
- en: '[PRE191]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'For the writers, from the `crew` property, filter the people who have a `department`
    of `Writing` and a `job` of `Writer`. For those objects, take the `name` property,
    and `join` it together with an `&` in between:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于编剧，从`crew`属性中筛选出具有`Writing`部门和`Writer`职位的员工。对于这些对象，取`name`属性，并用`&`连接起来：
- en: '[PRE192]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Create a new `Movie` object (using object literal syntax). Fill in all the
    properties of the `Movie` object using the data from the movie and people responses
    we''ve prepared so far:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Movie`对象（使用对象字面量语法）。使用我们迄今为止准备的电影和人员响应中的数据填写`Movie`对象的全部属性：
- en: '[PRE193]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Call the `showResults` function with the movie we constructed:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们构建的电影调用`showResults`函数：
- en: '[PRE194]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: In your parent directory (`Activity01` in this case), install dependencies with
    `npm i`.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的父目录（在这种情况下为`Activity01`）中，使用`npm i`安装依赖项。
- en: Compile the program using `tsc ./script.ts ./interfaces.ts ./display.ts`.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tsc ./script.ts ./interfaces.ts ./display.ts`编译程序。
- en: Verify that the compilation ended successfully.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功结束。
- en: Open `index.html` using the browser of your choice.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的浏览器打开`index.html`。
- en: 'You should see the following in your browser:'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该在浏览器中看到以下内容：
- en: '![Figure 10.5: The final web page'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5：最终网页'
- en: '](img/B14508_10_04.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_10_04.jpg](img/B14508_10_04.jpg)'
- en: 'Figure 10.5: The final web page'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：最终网页
- en: 'Activity 10.02: Movie Browser Using fetch and Promises'
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十.02：使用fetch和Promises的影片浏览器
- en: '**Solution:**'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: In the `script.ts` file, locate the `search` function and verify that it takes
    a single string parameter and that its body is empty.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`script.ts`文件中，找到`search`函数并验证它接受一个字符串参数，并且其主体为空。
- en: 'Above the `search` function, create a helper function called `getJsonData`.
    This function will use the `fetch` API to get data from an endpoint and format
    it as JSON. It should take a single string called `url` as a parameter, and it
    should return a promise:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`search`函数上方创建一个名为`getJsonData`的辅助函数。此函数将使用`fetch` API从端点获取数据并将其格式化为JSON。它应接受一个名为`url`的单个字符串参数，并且它应该返回一个promise：
- en: '[PRE195]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'In the body of the `getJsonData` function, add code that calls the `fetch`
    function with the `url` parameter, and `then` call the `json` method on the returned
    response:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getJsonData`函数的主体中，添加调用带有`url`参数的`fetch`函数的代码，然后调用返回响应的`json`方法：
- en: '[PRE196]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'In the `search` method, construct a new string for the search result URL using
    the `getSearchUrl` method:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `search` 方法中，使用 `getSearchUrl` 方法为搜索结果 URL 构造一个新的字符串：
- en: '[PRE197]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Call the `getJsonData` function with `searchUrl` as a parameter:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `searchUrl` 作为参数调用 `getJsonData` 函数：
- en: '[PRE198]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Add a `then` handler to the promise returned from `getJsonData`. The handler
    takes a single parameter of the type `SearchResultApi`:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从 `getJsonData` 返回的承诺中添加一个 `then` 处理器。该处理器接受一个类型为 `SearchResultApi` 的单个参数：
- en: '[PRE199]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'In the body of the handler, check whether we have any results and if we don''t,
    throw an error. If we do have results, return the first item. Note that the handler
    returns an object with `id` and `title` properties, but the `then` method actually
    returns a promise of that data. This means that after the handler, we can chain
    other `then` calls:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理器的主体中，检查是否有任何结果，如果没有，则抛出错误。如果有结果，则返回第一个项目。请注意，处理器返回一个具有 `id` 和 `title` 属性的对象，但实际上
    `then` 方法返回的是该数据的承诺。这意味着在处理器之后，我们可以链式调用其他 `then` 调用：
- en: '[PRE200]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Add another `then` call to the previous handler. This handler will take a `movieResult`
    parameter that contains the `id` and `title` of the movie. Use the `id` property
    to call the `getMovieUrl` and `getPeopleUrl` methods to, respectively, get the
    correct URLs for the movie details and for the cast and crew:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在先前的处理器中添加另一个 `then` 调用。这个处理器将接受一个包含电影 `id` 和 `title` 的 `movieResult` 参数。使用
    `id` 属性调用 `getMovieUrl` 和 `getPeopleUrl` 方法，分别获取电影详情和演员阵容及制作团队的正确 URL：
- en: '[PRE201]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'After getting the URLs, call the `getJsonData` function with both of them,
    and assign the resulting values to variables. Note that the `getJsonData(movieUrl)`
    call will return a promise of `MovieResultApi`, and `getJsonData(peopleUrl)` will
    return a promise of `PeopleResultApi`. Assign those result values to variables
    called `dataPromise` and `peoplePromise`:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取到 URL 之后，使用这两个 URL 调用 `getJsonData` 函数，并将结果值赋给变量。请注意，`getJsonData(movieUrl)`
    调用将返回 `MovieResultApi` 的承诺，而 `getJsonData(peopleUrl)` 将返回 `PeopleResultApi` 的承诺。将这些结果值赋给名为
    `dataPromise` 和 `peoplePromise` 的变量：
- en: '[PRE202]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Call the static `Promise.all` method with `dataPromise` and `peoplePromise`
    as parameters. This will create another promise based on those two values, and
    this promise will be resolved successfully if and only if both (that is, all)
    promises that are contained within resolve successfully. Its return value will
    be a promise of an array of results:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dataPromise` 和 `peoplePromise` 作为参数调用静态 `Promise.all` 方法。这将基于这两个值创建另一个承诺，并且只有当包含在内的所有承诺都成功解决时，这个承诺才会成功解决。它的返回值将是一个包含结果的数组承诺：
- en: '[PRE203]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Return the promise generated by the `Promise.all` call from the handler:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从处理器返回由 `Promise.all` 调用生成的承诺：
- en: '[PRE204]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Add another `then` handler to the chain. This handler will take the array returned
    from `Promise.all` as a single parameter:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链中添加另一个 `then` 处理器。这个处理器将接受 `Promise.all` 返回的数组作为单个参数：
- en: '[PRE205]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Deconstruct the parameter into two variables. The first element of the array
    should be the `movieData` variable of type `MovieResultApi`, and the second element
    of the array should be the `peopleData` variable of type `PeopleResultApi`:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数解构为两个变量。数组中的第一个元素应该是 `movieData` 变量，其类型为 `MovieResultApi`，而数组的第二个元素应该是 `peopleData`
    变量，其类型为 `PeopleResultApi`：
- en: '[PRE206]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The people data has `cast` and `crew` properties. We''ll only take the first
    six cast members, so first sort the `cast` property according to the `order` property
    of the cast members. Then slice off the first six cast members into a new array:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人物数据有 `cast` 和 `crew` 属性。我们只取前六个演员，所以首先根据演员成员的 `order` 属性对 `cast` 属性进行排序。然后从数组中截取前六个演员成员到一个新的数组中：
- en: '[PRE207]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Transform the cast data (which is `CastResultApi` objects) into our own `Character`
    objects. We need to map the `character` field of `CastResultApi` to the `name`
    field of `Character`, the `name` field to the `actor` name, and the `profile_path`
    field to the `image` property:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将演员数据（即 `CastResultApi` 对象）转换为我们自己的 `Character` 对象。我们需要将 `CastResultApi` 的 `character`
    字段映射到 `Character` 的 `name` 字段，将 `name` 字段映射到演员名字，将 `profile_path` 字段映射到 `image`
    属性：
- en: '[PRE208]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'From the `crew` property of the people data, we''ll only need the director
    and the writer. Since there can be multiple directors and writers, we''ll get
    the names of all directors and writers and concatenate them, respectively. For
    the directors, from the `crew` property, filter the people who have a `department`
    of `Directing` and a `job` of `Director`. For those objects, take the `name` property,
    and `join` it together with an `&` in between:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从人员数据的`crew`属性中，我们只需要导演和编剧。由于可能有多个导演和编剧，我们将分别获取所有导演和编剧的名字并将它们连接起来。对于导演，从`crew`属性中筛选出具有`department`为`Directing`和`job`为`Director`的人员。对于这些对象，取其`name`属性，并用`&`连接起来：
- en: '[PRE209]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'For the writers, from the `crew` property, filter the people who have a `department`
    of `Writing` and a `job` of `Writer`. For those objects, take the `name` property,
    and `join` it together with an `&` in between:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于编剧，从`crew`属性中筛选出具有`department`为`Writing`和`job`为`Writer`的人员。对于这些对象，取其`name`属性，并用`&`连接起来：
- en: '[PRE210]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Create a new `Movie` object (using object literal syntax). Fill in all the
    properties of the `Movie` object using the data from the movie and people responses
    we''ve prepared so far:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Movie`对象（使用对象字面量语法）。使用到目前为止我们从电影和人员响应中准备的数据填写`Movie`对象的全部属性：
- en: '[PRE211]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Return the `Movie` object from the handler:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从处理程序中返回`Movie`对象：
- en: '[PRE212]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Note that we did not do any UI interactions in our code. We just received a
    string, did some promise calls, and returned a value. The UI work can now be done
    in UI-oriented code. In this case, that''s in the `click` event handler of the
    `search` button. We should simply add a `then` handler to the `search` call that
    will call the `showResults` method, and a `catch` handler that will call the `clearResults`
    method:'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在我们的代码中我们没有进行任何UI交互。我们只是接收了一个字符串，进行了一些promise调用，并返回了一个值。现在可以在面向UI的代码中完成UI工作。在这种情况下，那就是在`search`按钮的`click`事件处理程序中。我们应该简单地向`search`调用添加一个`then`处理程序，该处理程序将调用`showResults`方法，并添加一个`catch`处理程序，该处理程序将调用`clearResults`方法：
- en: '[PRE213]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: The output should be the same as the previous activity.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该与上一个活动相同。
- en: 'Activity 10.03: Movie Browser Using fetch and async/await'
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十点零三：使用fetch和async/await的影片浏览器
- en: '**Solution:**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'In the `script.ts` file, locate the `search` function and verify that it takes
    a single string parameter and that its body is empty. Note that this function
    is now marked with the `async` keyword, which allows us to use the `await` operator:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`script.ts`文件中，定位到`search`函数并验证它是否接受一个字符串参数，并且其主体为空。注意，这个函数现在被标记为`async`关键字，这允许我们使用`await`运算符：
- en: '[PRE214]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'In the body of the `getJsonData` function, add code that calls and `await`s
    the `fetch` function with the `url` parameter, and then call calls the `json`
    method on the returned response:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getJsonData`函数的主体中，添加调用并`await``fetch`函数的`url`参数的代码，然后调用返回响应的`json`方法：
- en: '[PRE215]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'In the `search` method, construct a new string for the search result URL using
    the `getSearchUrl` method:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`search`方法中，使用`getSearchUrl`方法构造一个新的搜索结果URL字符串：
- en: '[PRE216]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Call the `getJsonData` function with the `searchUrl` as a parameter, and `await`
    the result. Place the result in the `SearchResultApi` variable:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`searchUrl`作为参数调用`getJsonData`函数，并`await`结果。将结果放置在`SearchResultApi`变量中：
- en: '[PRE217]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Check whether we have any results and if we don''t, throw an error. If we do
    have results, set the first item of the `result` property in a variable called
    `movieResult`. This object will contain the `id` and `title` properties of the movie:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有任何结果，如果没有，则抛出错误。如果有结果，将`result`属性中的第一个项目设置到一个名为`movieResult`的变量中。这个对象将包含电影的`id`和`title`属性：
- en: '[PRE218]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Use the `id` property to call the `getMovieUrl` and `getPeopleUrl` methods
    to, respectively, get the correct URLs for the movie details and for the cast
    and crew:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`id`属性调用`getMovieUrl`和`getPeopleUrl`方法，分别获取电影详情和演员及工作人员的正确URL：
- en: '[PRE219]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'After getting the URLs, call the `getJsonData` function with both and assign
    the resulting values to variables. Note that the `getJsonData(movieUrl)` call
    will return a promise of `MovieResultApi`, and `getJsonData(peopleUrl)` will return
    a promise of `PeopleResultApi`. Assign those result values to variables called
    `dataPromise` and `peoplePromise`:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取到URL后，调用`getJsonData`函数并将它们作为参数传递，并将结果值分配给变量。注意，`getJsonData(movieUrl)`调用将返回一个`MovieResultApi`的promise，而`getJsonData(peopleUrl)`将返回一个`PeopleResultApi`的promise。将这些结果值分配给名为`dataPromise`和`peoplePromise`的变量：
- en: '[PRE220]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Call the static `Promise.all` method with `dataPromise` and `peoplePromise`
    as parameters. This will create another promise based on those two values, and
    this promise will be resolved successfully if and only if both (that is, all)
    promises that are contained within resolve successfully. Its return value will
    be a promise of an array of results. `await` this promise, and place its result
    in a variable of type array:'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dataPromise` 和 `peoplePromise` 作为参数调用静态的 `Promise.all` 方法。这将基于这两个值创建另一个基于它们的承诺，并且只有当包含在内的所有承诺都成功解决时，这个承诺才会成功解决。它的返回值将是一个包含结果的数组承诺。`await`
    这个承诺，并将其结果放入一个数组类型的变量中：
- en: '[PRE221]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Deconstruct that array into two variables. The first element of the array should
    be the `movieData` variable of type `MovieResultApi`, and the second element of
    the array should be the `peopleData` variable of type `PeopleResultApi`:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组拆分为两个变量。数组中的第一个元素应该是 `movieData` 变量，其类型为 `MovieResultApi`，第二个元素是 `peopleData`
    变量，其类型为 `PeopleResultApi`：
- en: '[PRE222]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The people data has `cast` and `crew` properties. We''ll only take the first
    six cast members, so first sort the `cast` property according to the `order` property
    of the cast members. Then slice off the first six cast members into a new array:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人物数据有 `cast` 和 `crew` 属性。我们只取前六个演员，所以首先根据演员的 `order` 属性对 `cast` 属性进行排序。然后从第一个六位演员中切出一个新的数组：
- en: '[PRE223]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Transform the cast data (which is `CastResultApi` objects) into our own `Character`
    objects. We need to map the `character` field of `CastResultApi` to the `name`
    field of `Character`, the `name` field to the `actor` name, and the `profile_path`
    field to the `image` property:'
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将演员数据（`CastResultApi` 对象）转换为我们的 `Character` 对象。我们需要将 `CastResultApi` 的 `character`
    字段映射到 `Character` 的 `name` 字段，将 `name` 字段映射到演员名字，将 `profile_path` 字段映射到 `image`
    属性：
- en: '[PRE224]'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'From the `crew` property of the people data, we''ll only need the director
    and the writer. Since there can be multiple directors and writers, we''ll get
    the names of all directors and writers, and concatenate them, respectively. For
    the directors, from the `crew` property, filter the people who have a `department`
    of `Directing` and a `job` of `Director`. For those objects, take the `name` property,
    and `join` it together with an `&` in between:'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从人物数据的 `crew` 属性中，我们只需要导演和编剧。由于可能有多个导演和编剧，我们将获取所有导演和编剧的名字，并分别连接它们。对于导演，从 `crew`
    属性中，过滤出具有 `Directing` 部门和 `Director` 职位的个人。对于这些对象，取 `name` 属性，并用 `&` 连接起来：
- en: '[PRE225]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'For the writers, from the `crew` property, filter the people who have a `department`
    of `Writing` and a `job` of `Writer`. For those objects, take the `name` property,
    and `join` it together with an `&` in between:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于编剧，从 `crew` 属性中，过滤出具有 `Writing` 部门和 `Writer` 职位的个人。对于这些对象，取 `name` 属性，并用 `&`
    连接起来：
- en: '[PRE226]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Create a new `Movie` object (using object literal syntax). Fill in all the
    properties of the `Movie` object using the data from the movie and people responses
    we''ve prepared so far:'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Movie` 对象（使用对象字面量语法）。使用我们迄今为止准备的电影和人物响应数据，填写 `Movie` 对象的所有属性：
- en: '[PRE227]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'Return the `Movie` object from the function:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数中返回 `Movie` 对象：
- en: '[PRE228]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Note that we did not do any UI interactions in our code. We just received a
    string, did some promise calls, and returned a value. The UI work can now be done
    in UI-oriented code. In this case, that''s in the `click` event handler of the
    `search` button. We should simply `await` the result of the `search` call and
    then call the `showResults` method with it. We can use a standard `catch` expression
    to handle any errors:'
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们在代码中没有进行任何 UI 交互。我们只接收了一个字符串，进行了一些承诺调用，并返回了一个值。现在可以在面向 UI 的代码中完成 UI 工作。在这种情况下，是在
    `search` 按钮的 `click` 事件处理器中。我们应该简单地 `await` `search` 调用的结果，然后用它调用 `showResults`
    方法。我们可以使用标准的 `catch` 表达式来处理任何错误：
- en: '[PRE229]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The output should be the same as the previous activity.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该与上一个活动相同。
- en: 11\. Higher-Order Functions and Callbacks
  id: totrans-623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 高阶函数和回调
- en: 'Activity 11.01: Higher-Order Pipe Function'
  id: totrans-624
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01：高阶管道函数
- en: '**Solution:**'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'In this activity, we''ll build a higher-order `pipe` function that accepts
    functions as arguments, and composes them from left to right, returning a function
    that accepts the arguments of the first function, and returns the type of the
    last function. When the returned function is run, it iterates over the given functions,
    feeding the return value of each function to the next one:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个高阶 `pipe` 函数，它接受函数作为参数，并从左到右组合它们，返回一个接受第一个函数参数并返回最后一个函数类型的函数。当返回的函数运行时，它遍历给定的函数，将每个函数的返回值传递给下一个函数：
- en: 'Let''s start by defining a type definition for the supported functions to compose,
    a function that accepts one argument of type `T` and returns one of type `R`:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先定义一个类型定义，用于组合支持的函数，一个接受类型为 `T` 的一个参数并返回类型为 `R` 的函数：
- en: '[PRE230]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: As mentioned, we'll only support functions accepting up to one argument, for simplicity.
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，我们将只支持接受最多一个参数的函数，以简化问题。
- en: Note that in order to deal with the special case of 0 arguments, we need to
    check whether `T extends void` and returns a parameterless function.
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，为了处理0个参数的特殊情况，我们需要检查 `T extends void` 并返回一个无参数函数。
- en: 'Next, let''s start by writing a simple implementation of the `pipe` function,
    one that supports only a single function, making it essentially an identity function:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们先编写一个简单的 `pipe` 函数实现，它只支持单个函数，使其本质上是一个恒等函数：
- en: '[PRE231]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Note that we require two overloads for the function, one for the special case
    of no parameters, and another for a single-parameter function.
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们需要为函数提供两个重载，一个用于没有参数的特殊情况，另一个用于单参数函数。
- en: 'Let''s expand this to support two functions by adding another overload:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加另一个重载来扩展这个功能，以支持两个函数：
- en: '[PRE232]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: The previous implementation no longer works, since we need to support both a
    single function, as well as multiple functions, so we can no longer just return
    `fn`. We'll add a naïve implementation for now and expand it to a more generic
    solution in the next steps.
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个实现不再有效，因为我们需要同时支持单个函数和多个函数，所以我们不能再只返回 `fn`。我们将现在添加一个简单的实现，并在下一步扩展到一个更通用的解决方案。
- en: 'The naïve implementation for supporting two functions is to simply check whether
    `fn2` is `undefined` – if it is, we only have a single function at hand, and can
    simply return `fn1`. Otherwise, we need to return a function that composes `fn1`
    and `fn2` on the given argument:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持两个函数的简单实现是简单地检查 `fn2` 是否为 `undefined` – 如果是，我们只有一个函数在手，可以简单地返回 `fn1`。否则，我们需要返回一个函数，该函数在给定的参数上组合
    `fn1` 和 `fn2`：
- en: '[PRE233]'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'We can persist with the preceding approach, but it is tedious, and supporting
    more functions means changing the implementation. Instead, we can make the actual
    implementation accept an array of functions and reduce them, starting with `arg`
    as the initial value, and running the current function, `fn`, on the accumulator
    (the previous result). Let''s do that, while still only supporting up to two functions:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以继续使用前面的方法，但这很繁琐，支持更多函数意味着要改变实现。相反，我们可以让实际实现接受一个函数数组并对其进行归约，从 `arg` 作为初始值开始，并在累加器（前一个结果）上运行当前函数
    `fn`。让我们这样做，同时仍然只支持最多两个函数：
- en: '[PRE234]'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'Lastly, we can expand our support for more functions by only needing to change
    the function declaration by adding another overload with the correct type:'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过仅通过添加另一个具有正确类型的重载来更改函数声明来扩展我们对更多函数的支持：
- en: 'In the case of three functions:'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在三个函数的情况下：
- en: '[PRE235]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'In the case of four functions:'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在四个函数的情况下：
- en: '[PRE236]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'In the case of five functions:'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在五个函数的情况下：
- en: '[PRE237]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: In each overload, we have the first generic as `T` – this is the type of argument
    that the returned function will have, and `R` – the return type of the returned
    function. Between them we have `A`, `B`, `C,` and so on, as the interim return
    type/argument type of the second…second to last functions. For all the preceding
    steps, make sure to export the functions by adding `export` before the `function`
    keyword.
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每个重载中，我们都有第一个泛型 `T` – 这是返回函数将具有的参数类型，以及 `R` – 返回函数的返回类型。它们之间是 `A`、`B`、`C` 等等，作为第二、第二到最后一个函数的中间返回类型/参数类型。对于所有前面的步骤，确保通过在
    `function` 关键字之前添加 `export` 来导出函数。
- en: 'Finally, we can use our `pipe` function to compose any functions we want, while
    staying completely type-safe:'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们可以使用我们的 `pipe` 函数来组合任何我们想要的函数，同时保持完全的类型安全：
- en: '[PRE238]'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Running the this code should result in the following output:'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此代码应产生以下输出：
- en: '[PRE239]'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 12\. Guide to Promises in TypeScript
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. TypeScript 中 Promise 的指南
- en: 'Activity 12.01: Building a Promise App'
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get started the same way we started building our API from the sample
    from GitHub:'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'The only dependencies we''re using here are `http-server` to power our web
    application and `typescript` to transpile our code. Now that our project is set
    up, let''s quickly create an `index.html` file:'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'And then a `styles.css` file:'
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Now we will create an `app.ts` file and create a very rough client library that
    implements a `fetch` abstraction similar to what we created in *Chapter 3, Functions*.
    Because TypeScript doesn't run natively in a web browser, we will need to use
    `tsc` to transpile our TypeScript code into JavaScript. There are some advanced
    tools such as webpack and Parcel that can help with this, but those are out of
    scope for this chapter so we will keep this simple and just use a single `app.ts`
    file.
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ll use our `PromiseModel` interface again in our web app and create a `fetchClient`
    function using currying:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Building on the model of curried `fetch` functions, let''s create some resources:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'These functions handle invoking the resources and updating page elements:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Finally, we''ll do some ugly HTML manipulation to update the UI:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Altogether, the `app.ts` file looks like this:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: It's not hard to see why view frameworks are popular; however, this should do
    the trick for putting together a full-stack application.
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s compile and run our web application. In one Command Prompt window,
    enter the following:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: This will transpile the TypeScript code in watch mode so that it restarts when
    changes are made.
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the HTTP server in another window with `npx http-server . -c-1` as we
    did in *Exercise 12.03, Promise.allSettled*.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now navigate a web browser to `http://localhost:8080/`. You should see a form
    like the one that follows:'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.10: Initial load'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14508_12_10.jpg)'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.10: Initial load'
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you don't see "Promise Delete" then it could be that your API from Exercise
    6, Implementing a RESTful API backed by sqlite isn't running. Return to that exercise
    and follow the steps there.
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can add and delete promises. Here are some examples:'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the promise `Always lint my code` and save it. You should see the following:![Figure
    12.11: One promise made'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14508_12_11.jpg)'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.11: One promise made'
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the promise `Never block the event loop` and save it:![Figure 12.12: Text
    entered'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14508_12_12.jpg)'
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.12: Text entered'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following promise saved:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: Text saved'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_12_13.jpg)'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.13: Text saved'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12.14* and *Figure 12.15* show some more examples:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14: Another promise saved'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_12_14.jpg)'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.14: Another promise saved'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15: Another promise saved'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_12_15.jpg)'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.15: Another promise saved'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Try to add to the application and make use of the API to get a single promise
    or update promises.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Async/Await in TypeScript
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 13.01: Refactoring Chained Promises to Use await'
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Let''s go over what needed to change in order to make this work:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下为了使这个工作需要更改的内容：
- en: 'First of all, the `await` keyword can only be used inside an `async` function,
    so we must add that keyword to the function declaration:'
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`await` 关键字只能用于 `async` 函数中，因此我们必须将此关键字添加到函数声明中：
- en: '[PRE249]'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Now we have to replace `then` with `await`. Let's look again at what the `render`
    function does. In our simple case, it just returns a promise that resolves to
    a string, but in the real world, it would render something in a web browser and
    then resolve to a string. Since we want to log out that string, we can actually
    resolve the promise inside a `console.log` statement. Even though `console.log`
    is a synchronous operation, putting `await` inside it will cause the function
    to print out the resolved promise value, exactly as we would hope.
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须将 `then` 替换为 `await`。让我们再次看看 `render` 函数做了什么。在我们的简单情况下，它只是返回一个解析为字符串的承诺，但在现实世界中，它会在网页浏览器中渲染某些内容，然后解析为字符串。由于我们想要记录这个字符串，我们实际上可以在
    `console.log` 语句中解析承诺。尽管 `console.log` 是一个同步操作，但在其中放置 `await` 将导致函数打印出解析的承诺值，正如我们所希望的那样。
- en: 'The refactored program is six lines shorter and eliminates nesting:'
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 优化后的程序比原来短六行，并消除了嵌套：
- en: '[PRE250]'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Run the file using `npx` `ts-node` `refactor.ts`. You should get the following output:'
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npx` `ts-node` `refactor.ts` 运行文件。你应该得到以下输出：
- en: '[PRE251]'
  id: totrans-713
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 14\. TypeScript and React
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. TypeScript和React
- en: 'Activity 14.01: The Blog'
  id: totrans-715
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十四点零一：博客
- en: '**Solution:**'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: Create a new React application as outlined earlier in this chapter.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章前面概述的步骤创建一个新的React应用程序。
- en: Prepare a Firestore database with authentication on Firebase as outlined in
    *Exercise 14.04, Getting Started with Firebase*.
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据第14.04节“在Firebase中入门”中概述的步骤，在Firebase上准备一个具有身份验证的Firestore数据库。
- en: Install the Firebase client with `npm i firebase`. Firebase includes typings
    so we won't need to install those separately.
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm i firebase` 安装Firebase客户端。Firebase包含类型定义，因此我们不需要单独安装它们。
- en: 'Create a directory called `services` under `src` and a file called `firebase.ts`
    there. The Firebase integration can be pretty basic:'
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 目录下创建一个名为 `services` 的目录，并在其中创建一个名为 `firebase.ts` 的文件。Firebase集成可以相当基础：
- en: '[PRE252]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Make sure to use the values from the Firebase dashboard. This will expose Firebase's
    authentication and database capabilities to the rest of your application.
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保使用Firebase仪表板中的值。这将使Firebase的身份验证和数据库功能暴露给应用程序的其他部分。
- en: 'Set up two providers under `src/providers` called `StoriesProvider.ts` and
    `UserProvider.ts`. Now, `UserProvider.ts` will be simpler, so let''s do that one
    first. Like *Exercise 14.03*, *React Context*, we''ll employ `createContext` and
    `useState`, but we''ll also need `useEffect`:'
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/providers` 下设置两个提供者，分别命名为 `StoriesProvider.ts` 和 `UserProvider.ts`。现在，`UserProvider.ts`
    将更简单，所以让我们先做这个。像第14.03节“React Context”中的练习一样，我们将使用 `createContext` 和 `useState`，但我们还需要
    `useEffect`：
- en: '[PRE253]'
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '`StoriesProvider.ts` is responsible for persisting stories (the blog links)
    and comments on the stories. To make this work, start by creating interfaces for
    comments and stories. Comments should belong to stories. Here''s a sample of how
    that could be done:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StoriesProvider.ts` 负责持久化故事（博客链接）和故事上的评论。为了实现这一点，首先为评论和故事创建接口。评论应属于故事。以下是一个示例，说明如何实现：'
- en: '[PRE254]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'With those interfaces created, we need to implement some methods in our provider,
    namely methods for adding comments and stories as well as a method that will fetch
    all the stories. To do that, we''ll need to access a collection in our database.
    This can be done with a single line of code:'
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建了这些接口后，我们需要在我们的提供者中实现一些方法，即添加评论和故事的方法以及一个将获取所有故事的方法。为此，我们需要访问数据库中的集合。这可以通过一行代码完成：
- en: '[PRE255]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: This code will create the collection if it doesn't exist. The `storiesDB` object
    we created has methods for fetching, adding, and updating documents from the collection.
    With those methods implemented, we add our stories data and the methods that handle
    the data to our provider value. This means that components that use `StoriesContext`
    will be able to call those methods or access that data.
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将在不存在的情况下创建集合。我们创建的 `storiesDB` 对象具有从集合中获取、添加和更新文档的方法。实现这些方法后，我们将我们的故事数据和处理数据的方法添加到我们的提供者值中。这意味着使用
    `StoriesContext` 的组件将能够调用这些方法或访问这些数据。
- en: Again, the solution to this somewhat complicated provider is available on GitHub.
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，这个相对复杂的提供者的解决方案可以在GitHub上找到。
- en: Raw document data is a bit difficult to work with, but Firebase has the concept
    of a converter that we can create, which will tell it how to map document fields
    to our TypeScript objects. Create and export a converter implementing the `fromFirestore`
    and `toFirestore` methods. Using those should eliminate some type errors and avoid
    us needing to use `any`.
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始文档数据有点难以处理，但 Firebase 有一个我们可以创建的转换器概念，这将告诉它如何将文档字段映射到我们的 TypeScript 对象。创建并导出一个实现
    `fromFirestore` 和 `toFirestore` 方法的转换器。使用这些应该可以消除一些类型错误，并避免我们使用 `any`。
- en: Install React Router (`react-dom` and `react-router-dom`). Set the default route
    to a home page. Then, create `Add`, `Signin`, and `Signup` pages. Put the pages
    under `src/pages`. Just put some text on them in a basic function component to
    verify routing is working as expected.
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 React Router (`react-dom` 和 `react-router-dom`)。设置默认路由为主页。然后创建 `Add`、`Signin`
    和 `Signup` 页面。将这些页面放在 `src/pages` 下。只需在基本函数组件上放置一些文本以验证路由是否按预期工作。
- en: Build out the `Signup` page first as it's hard to sign in without having signed
    up. Now we'll use Material-UI. Install `@material-ui/core` and `@material-ui/icons`
    and we can start building components.
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先构建 `Signup` 页面，因为没有注册就无法登录。现在我们将使用 Material-UI。安装 `@material-ui/core` 和 `@material-ui/icons`，然后我们可以开始构建组件。
- en: Our `Signup` page can be created using `Container`, `TextField`, and `Button`,
    which are all available components in Material-UI. How your page ultimately looks
    is up to you, but you will need two `TextField` components. One of those should
    have both a `type` and `name` of `"email"` and the other should have `"password"`
    for both of those props.
  id: totrans-734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `Signup` 页面可以使用 `Container`、`TextField` 和 `Button` 创建，这些都是 Material-UI 中的可用组件。页面最终的外观取决于你，但你需要两个
    `TextField` 组件。其中一个应该有 `type` 和 `name` 都为 `"email"` 的属性，另一个应该为这两个属性都设置 `"password"`。
- en: We'll track the state of both the email and password fields using `useState`
    and an `onChange` event.
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用 `useState` 和 `onChange` 事件跟踪电子邮件和密码字段的状态。
- en: When the button is clicked, we should call a method on the `auth` object we
    exported from our Firebase service earlier to create a new user using the given
    email address and password.
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当按钮被点击时，我们应该调用我们之前从 Firebase 服务中导出的 `auth` 对象上的一个方法，使用给定的电子邮件地址和密码创建一个新用户。
- en: Upon successfully signing in, let's send the user back to the home page with
    the `useHistory` React Hook.
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录成功后，让我们使用 `useHistory` React 钩子将用户送回主页。
- en: The `Signin` page will be a lot like the `Signup` page. It also needs to capture
    the user's email address and password and have a button to submit the form. This
    time we should call a method on `auth` to sign the user in via an email and password.
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Signin` 页面将与 `Signup` 页面非常相似。它也需要捕获用户的电子邮件地址和密码，并有一个提交表单的按钮。这次我们应该在 `auth`
    上调用一个方法，通过电子邮件和密码来登录用户。'
- en: Our `Add` page creates new posts to the blog. We'll capture the title of the
    post and a link. Add additional fields if you like. This will work similarly to
    the prior two pages, but now we will use `StoriesContext` instead of `UserContext`
    to expose the method to add stories.
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `Add` 页面为博客创建新帖子。我们将捕获帖子的标题和链接。如果你喜欢，可以添加额外的字段。这将与前面的两个页面类似，但现在我们将使用 `StoriesContext`
    而不是 `UserContext` 来公开添加故事的方法。
- en: For the home page, we can just load up all the stories and display them as a
    Material-UI `List`. It's possible to just output the `story` object and wrap it
    in HTML tags to make it look presentable, but a better solution is to create a
    `Story` component that can better encapsulate the object. Add a `Story` component
    to `src/components` and use that for your story display.
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于主页，我们可以加载所有故事并将其作为 Material-UI 的 `List` 显示。直接输出 `story` 对象并用 HTML 标签包裹以使其看起来更美观是可能的，但更好的解决方案是创建一个
    `Story` 组件，它可以更好地封装对象。将 `Story` 组件添加到 `src/components` 中，并用于故事显示。
- en: To manage comments, each story should have its own comments. It's a good idea
    to create this as a separate component that each story will contain. The `Comments`
    component can contain a list of each individual comments (another component!)
    as well as controls for grabbing that method to add comments from `StoriesContext`.
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了管理评论，每个故事都应该有自己的评论。创建一个单独的组件，每个故事都将包含它是个好主意。`Comments` 组件可以包含每个单独评论的列表（另一个组件！）以及从
    `StoriesContext` 获取添加评论方法的控件。
- en: At this point, everything is working quite well, but we should add some navigation
    elements so users don't have to key in the different routes. We can use the `AppBar`,
    `Toolbar`, `Menu`, `MenuItem`, and `Button` components from Material-UI to create
    some attractive navigation options. Navigation itself can be performed via the
    `useHistory` React Hook.
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，一切运行得相当顺利，但我们应该添加一些导航元素，这样用户就不必输入不同的路由。我们可以使用Material-UI中的`AppBar`、`Toolbar`、`Menu`、`MenuItem`和`Button`组件来创建一些吸引人的导航选项。导航本身可以通过`useHistory`
    React Hook来实现。
- en: '![](img/Author_Page1.png)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Author_Page1.png)'
- en: Hey!
  id: totrans-744
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嘿！
- en: We're Ben Grynhaus, Jordan Hudgens, Rayon Hunte, Matt Morgan, and Wekoslav Stefanovski,
    the authors of this book. We really hope you enjoyed reading our book and found
    it useful for learning TypeScript.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是本书的作者本·格里豪斯（Ben Grynhaus）、乔丹·哈丁斯（Jordan Hudgens）、雷昂·亨特（Rayon Hunte）、马特·摩根（Matt
    Morgan）和韦科斯拉夫·斯坦福夫斯基（Wekoslav Stefanovski）。我们真心希望您喜欢阅读我们的书籍，并觉得它对学习TypeScript很有帮助。
- en: It would really help us (and other potential readers!) if you could leave a
    review on Amazon sharing your thoughts on *The TypeScript Workshop*.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能在Amazon上留下对《TypeScript Workshop》的评论，分享您的想法，这将对我们（以及其他潜在读者！）非常有帮助。
- en: Go to the link https://packt.link/r/1838828494.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 访问链接 https://packt.link/r/1838828494。
- en: OR
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: Scan the QR code to leave your review.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码留下您的评论。
- en: '![Barcode](img/qr-code-https___packt.link_r_1838828494.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![Barcode](img/qr-code-https___packt.link_r_1838828494.jpg)'
- en: Your review will help us to understand what's worked well in this book and what
    could be improved upon for future editions, so it really is appreciated.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评论将帮助我们了解本书哪些地方做得好，哪些地方可以改进以供未来版本使用，所以这真的非常感谢。
- en: Best wishes,
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 祝好，
- en: Ben Grynhaus, Jordan Hudgens, Rayon Hunte, Matt Morgan, and Wekoslav Stefanovski
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 本·格里豪斯、乔丹·哈丁斯、雷昂·亨特、马特·摩根和韦科斯拉夫·斯坦福夫斯基
- en: '![Packt Logo](img/Packt_Logo.png)'
  id: totrans-754
  prefs: []
  type: TYPE_IMG
  zh: '![Packt Logo](img/Packt_Logo.png)'
