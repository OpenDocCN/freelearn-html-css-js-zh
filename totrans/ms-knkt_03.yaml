- en: Chapter 3. Extending Knockout with Preprocessors and Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we looked at adding custom binding handlers to Knockout
    in order to add features and integrate them with third-party tools. This capability
    was part of Knockout when it was first released, and it allows for powerful extensions
    to Knockout''s functionality. In this chapter, we are going to look at some more
    advanced techniques for extending, or even changing, Knockout binding behaviors.
    You will learn how to create:'
  prefs: []
  type: TYPE_NORMAL
- en: Binding handler preprocessors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node preprocessors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we cover this, we will take a look at the Knockout Punches library, which
    is a collection of preprocessors and extensions by Knockout developer Michael
    Best.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the handler preprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have looked at two properties of binding handlers: the `init` and
    `update` functions. Binding handlers have another optional function, which is
    `preprocess`, that is run before the `init` function. A preprocessor''s purpose
    is to modify the `data-binding` attribute before Knockout determines what bindings
    are to be applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Preprocessors don''t deal with elements or binding contexts; they just deal
    with the strings that the binding will evaluate. For example, if we had a preprocessor
    that converts all text bindings to uppercase, then the following `span` element
    will be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This `span` element would be processed as if it was written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you were to inspect the HTML after this, you will still see the original
    `data-bind` attribute. This is because preprocessors don't actually deal with
    elements; they just modify the binding strings before the normal binding handler
    is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Creating preprocessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a preprocessor is as simple as adding a `preprocess` property to the
    binding handler, just like we added the `init` and `update` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The three parameters of the `preprocess` function are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: This is the expression given to the binding handler. For example,
    in `text: name`, the value is `name`; for `text: title() + ''. '' + name()`, the
    value is `"title() + ''. '' + name()"`. This value is always a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is the name of the binding handler, for example, `text` or `click`.
    This can be useful in cases where a single `preprocess` function is used by multiple
    binding handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addBinding`: This is a callback function that takes the `name` and `value`
    string parameters, just like the previous ones. It will add the pair as a binding
    on the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value from the preprocessor will be the new value used for the entire
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: The uppercase preprocessor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Knockout documentation provides an example for this preprocessor that,
    at the time of writing this, returns `value + ".toUpperCase()"`. The full preprocessor
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would work, for example, at the beginning of this section
    when it took a string directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of our preprocessor will be `text: ''That Guy''.toUpperCase()` and
    the text binding will handle this without any error. Unfortunately, this will
    break in the normal case of binding against observable properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Knockout''s normal binding process unwraps the expression it gets so that observables
    don''t need parentheses. Preprocessors, on the other hand, just output strings
    that are directly consumed by the binding handler. Our uppercase binding will
    produce an illegal result here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will fail, as `firstName` is an observable and not a string, and observables
    don't have a `toUpperCase` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the solution to this is simple. Our preprocessor can safely handle
    all value expressions by applying an `unwrap` function to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that any value—whether a primitive type, observable, or inline
    expression—is correctly evaluated by the binding handler.
  prefs: []
  type: TYPE_NORMAL
- en: You can see an example of this preprocessor in the `cp3-uppercase` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping existing bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because Knockout provides default bindings for most standard scenarios, it's
    common to want for a custom binding to build on top of them. Preprocessors make
    wrapping other bindings very easy.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we wanted a binding that caused an element to flash when a property
    was updated in addition to providing a `value` binding on it. Normally, you might
    want to divide these into two separate bindings, but if you are doing this a lot,
    a single binding will save time and keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `value` binding already exists, we can just use a preprocessor to add
    the binding with the `addBinding` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `addBinding` callback takes care of generating the `value` binding as if
    it had been applied normally, which includes running the preprocessor for the
    new binding (if it has one).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important that we still return the original value after adding the `value`
    binding. If nothing is returned from the `preprocess` function, then the original
    binding is removed. After this, the rest of the binding handler is business as
    usual: add an `init` and `update` function (as required) and write your custom
    behavior. There is an example of this binding in the `cp3-wrap` branch.'
  prefs: []
  type: TYPE_NORMAL
- en: That's really all there is to creating binding handler preprocessors. For the
    extensibility they allow, they are simple and straightforward to use. We will
    look at some more real-world possibilities for binding preprocessors when we look
    at `Knockout.Punches` in the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Node preprocessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binding handler preprocessors are attached to individual binding handlers and
    work by modifying the binding string. They only apply to nodes of their respective
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Node preprocessors, on the other hand, are called on every DOM node. They run
    when the UI is first bound and when it is modified by bindings such as `foreach`
    or `template`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of a node preprocessor is to modify the DOM before data-binding
    occurs, as opposed to a binding preprocessor that only modifies the `data-bind`
    attribute. A node preprocessor is defined by adding a `preprocessNode` function
    to the binding provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A preprocessor is called once for each node. If no changes need to be made,
    it should return nothing. Otherwise, it can use the standard DOM API to insert
    new nodes or remove the current node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'New nodes should be inserted before the current node by using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replacement can be done with:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Removal can be done with:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Any nodes that are added need to be returned from `preprocessNode`; otherwise,
    Knockout will not apply bindings to them. As you do not have the binding context
    inside `preprocessNode` (you only have the current node), it is not possible to
    apply bindings yourself, unless they are applied to constant or global values.
    This is not recommended, though, as it creates a new binding context outside of
    the current context's hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Closing virtual template nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Knockout documentation provides a handy node preprocessor that self-closes
    virtual template bindings. Normally, when writing a containerless template binding,
    you would need two comment nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As a template binding never contains content when referencing an external template,
    the closing comment node feels unnecessary. A `preprocess` function will allow
    you to use a template without the closing tag so that you can write the binding
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Knockout requires a closing comment tag, which is `<!-- /ko -->`, for virtual
    bindings. We can provide this comment node automatically with a preprocessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This sample uses regex to identify template comments and extract the expression
    from the binding. Then, it replaces the original comment with the standard open/close
    pair of comments for a virtual template binding. Finally, it returns the new comment
    nodes, allowing Knockout to bind them; this will apply the template to the virtual
    container created by the comment nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting alternate syntaxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example should have given you an idea of how node preprocessors
    work. However, the real power of node preprocessors comes from letting us extend
    the data binding syntax itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not uncommon to see a series of text bindings like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We want to list out several properties, but these virtual elements are pretty
    verbose. On top of the property name, they add 29 characters, including spaces.
    We can also use `span` elements, of course, but they are about the same size,
    considering that they need the `data-bind` attributes in addition to the binding
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve ever used AngularJS or Handlebars, you''ll probably appreciate the
    minimal requirement of using curly braces to access values as strings. The preceding
    example will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Look how much shorter and easier to read this is! These Handlebars guys have
    the right idea. I'm sure you know where we are going with this. A node preprocessor
    will allow us to take this same HTML and replace it with the HTML from the first
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is long, so we are going to break it up a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we have a regex pattern that finds these double curly brace chunks. As
    text nodes will contain any content up to the first real element they encounter,
    its possible that multiple curly brace chunks might be in a single node, so it
    needs to match globally. Then, the `preprocess` function starts out by checking
    for the text node type.
  prefs: []
  type: TYPE_NORMAL
- en: I've omitted the section that actually scans the node to create new ones for
    now; we will come back to that in just a bit.
  prefs: []
  type: TYPE_NORMAL
- en: If we have any nodes that need to be added, they get inserted, and then the
    original node is removed. Finally, the nodes we inserted are returned so that
    Knockout can bind them.
  prefs: []
  type: TYPE_NORMAL
- en: This is almost boilerplate code for node preprocessors, and it's a very good
    pattern to follow. Check for a type, create any new nodes, replace the original
    nodes if there are any, and return the new nodes. If you are creating a node preprocessor,
    this is a good template to start with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s get to the meat. To assign `newNodes`, we need to check the node
    for our regex pattern and build a pair of virtual text bindings for each match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are calling `replaceExpressionsInText` and passing the node''s contents,
    our regex pattern, and a callback that builds the correct replacements with the
    expression found by our regex. Then, we just need the actual search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The search function loops on the regex pattern and pulls out the first match.
    It sends the match to the callback function and keeps the result, along with any
    leading or trailing spaces. When it's finished matching, it returns them.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. Now, our Handlebars code will be converted to virtual text bindings.
    You can see this example in the `cp3-interpolate` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code is adapted from the `StringInterpolatingBindingProvider` demo at [http://blog.stevensanderson.com/2013/07/09/](http://blog.stevensanderson.com/2013/07/09/).
  prefs: []
  type: TYPE_NORMAL
- en: Multiple syntaxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we wanted to push this example a bit farther, we could support additional
    interpolation syntaxes. `replaceExpressionsInText` is already set up to take regex
    input, and as it uses a callback, we can even construct nodes differently for
    different regex patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the embedded Ruby syntax interpolation, which uses `<%= expression
    %>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we are replacing a `span` element instead of a virtual text element
    so that we can tell the resulting HTML apart. As this preprocessor can support
    both syntaxes, you can bind against a mixed syntax template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting HTML will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can see this example in the `cp3-interpolate2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Binding providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a binding preprocessor, we have access to the binding expression and can
    modify it before the evaluation of bindings. With a node preprocessor, we have
    access to the node and can modify the DOM before bindings are applied. Both of
    these just transform things into the normal Knockout syntax. They are also limited
    to operating on the DOM, and they do not have access to the binding context.
  prefs: []
  type: TYPE_NORMAL
- en: Knockout binding providers are objects that receive both the DOM node and the
    binding context and determine which bindings handlers will be applied and what
    `valueAccessor` properties those bindings receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'A binding provider is expected to provide the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nodeHasBindings(node)`: This function should return a Boolean that indicates
    whether or not the node has any bindings defined on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getBindingAccessors(node, bindingContext)`: This function should return an
    object with a property for each binding to be applied whose value is a function
    that evaluates the binding expression. This function is used as the `valueAccessor`
    property in binding handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are targeting 2.x, you will need to support `getBindings`, which returns
    an object whose property values are the final binding values. This function was
    deprecated with Knockout 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: The default binding provider operates by looking for `data-bind` attributes
    on an element or a comment node that starts with `ko`. If it does, `nodeHasBindings`
    will return `true`. When `getBindingAccessors` is called, it returns the bindings
    by evaluating the `data-bind` attribute and getting the `valueAccessors` property
    from the binding context.
  prefs: []
  type: TYPE_NORMAL
- en: Custom binding providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already seen how we can use preprocessors to allow for different syntaxes
    to be used for data binding. So, to get a better understanding of the capability
    of binding providers, we are going to look at something preprocessors can''t do:
    choosing bindings based on the data type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Knockout plugin `Knockout.BindingConventions` ([https://github.com/AndersMalmgren/Knockout.BindingConventions](https://github.com/AndersMalmgren/Knockout.BindingConventions))
    creates a binding provider that provides bindings on the `data-name` attribute
    by looking at the binding context for clues on the bindings that are to be used,
    which makes it a great example for a custom provider. As this is a big change
    from how Knockout works, let''s compare this to a standard viewmodel and binding
    setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Binding to this with standard Knockout bindings might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We've got three bound elements and four bindings. The first input is a `value`
    that is binding to `name`, the `select` element is binding to `options` on `locations`
    and `value` on `selectedLocation`, and the last input is binding `checked` to
    `isAdmin`. A simple case, such as having to specify that the binding on an input
    is a value, might seem verbose; in most cases, an input will be binding against
    the value, or in the case of a checkbox, binding against `checked`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The convention-over-configuration philosophy aims to remove the need to specify
    what is happening in a conventional scenario. In other words, perform the standard
    action unless otherwise specified. Here is how the previous DOM would look using
    the `BindingConventions` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, `BindingConventions` is doing all the work of figuring out the bindings.
    The `name` input is a string observable on our viewmodel, and it's on an input
    node, so it gets the `value` binding. The `isAdmin` input is a Boolean observable
    on our viewmodel, so the input node is converted into a checkbox, and it receives
    the `checked` binding. The `locations` property is an array on our viewmodel,
    so the `select` element gets an `options` binding. However, this is not all! Our
    viewmodel has a `selectedLocations` observable, which `BindingConventions` determines
    should get a `value` binding for the `select` element, as singularizing an array
    name and prepending `selected` is a binding convention.
  prefs: []
  type: TYPE_NORMAL
- en: That last one might seem like magic, and personally, I think it's a bit too
    non-obvious, but it has a certain appeal to it. If you are following conventions,
    you can really simplify your bindings. You can see this example in action in the
    `cp3-provider` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can see what this binding provider is doing, let's look at how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be looking at a simplified version of the binding provider in the `BindingConventions`
    plugin. The real provider supports more conventions and allows for custom conventions
    to be added. This sample is only meant to illustrate the type detection concept
    and the basics of creating a custom provider.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that needs to be decided when creating a custom binding provider
    is whether you need to extend the default binding provider or replace it. The
    `BindingConventions` provider will support the `data-name` attribute. In this
    case, it makes sense to extend the default provider, as they do not conflict with
    each other and we will need the standard `data-bind` support for scenarios that
    are nonconventional (such as binding our select value to a `favoriteLocation`
    property).
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to do this is to store a reference to the original binding
    provider and call it in our custom provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is basically boilerplate for a binding provider that extends the default
    one. It stores the original provider and implements the `nodeHasBindings` and
    `getBindingAccessors` functions by calling the default provider first, calling
    its own implementation if the default provider returns nothing. If you want your
    provider to check for bindings before the default one, you can switch the order
    of the calls. Finally, you can combine the two by appending binding handlers to
    the result of the default provider.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the required functions, `ko.bindingProvider.instance` is replaced
    with the new custom provider. It's important to note that this must all be done
    prior to `ko.applyBindings` being called, as the binding provider is only constructed
    once for the root binding context.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, all we have to do is provide the methods that check for bindings
    and create them. Checking for bindings just requires you to check for the `data-name`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the value from the binding context is a bit more work. Knockout has
    utility methods that can parse expressions under the `ko.expressionRewriting`
    object, which can read any of the supported Knockout binding syntaxes. The `BindingConventions`
    plugin does not support anything other than property references, but it does support
    deep references such as `person.firstName`. For simplicity''s sake, I am not going
    to cover this, but if you are interested in this, you can look at `getDataFromComplexObjectQuery`
    in the plugin''s source code. For now, we will assume that all `data-name` attributes
    refer directly to a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the name of the viewmodel property from the `data-name` attribute,
    and then we perform a sanity check to make sure that it's there to bind against.
    Then, we get the data with `ko.utils.peekObservable` and check its type. All observables
    have a `peek` function that returns the underlying value without triggering dependency
    detection. The `peekObservable` function will call `peek` if the first parameter
    is observable; otherwise, it will just return the first parameter. It's a safety
    utility that is similar to `ko.uwrap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have these two bits of information, we can build the binding object
    we need to return. Remember, this binding object should have a property named
    after the binding to be applied, whose value is the `valueAccessor` object for
    the binding. The bindings are returned to the binding provider''s `getBindingAccessors`
    function. To construct the bindings, we will loop over a set of conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will look through the `conventionBinders` array and check the rules for
    each one in order to find a match for the current node, data, and data type. If
    all of the rules for a convention handler pass, then we call `apply` for that
    convention and stop checking—only one convention should apply per node. The `apply`
    function gets all of the information we've collected so far as well as a `valueAccessor`
    property that can be used for the binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example is only using two conventions, which are `options` and `input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The options have just one rule: the element must be a `select` element, and
    the data needs to be an array (which is being checked by looking for a `push`
    function).'
  prefs: []
  type: TYPE_NORMAL
- en: The `apply` function sets the options binding directly to the `valueAccessor`
    property. Then, it tries to find a property that matches the `'selected' + getPascalCased(singularized)`
    convention on the context. The `singularize` and `getPascalCased` functions are
    not included here, but you can see them in the example branch in the following
    code. Predictably, they find a singular conjugation of a word and capitalize the
    first letter. If a match is found, a `value` binding is added to the `bindings`
    object that was passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `input` handler is much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `input` handler's rules don't check the data type; it's just that the node
    is either `input` or `textarea`. The `apply` function will use a `value` binding
    if the type is not `Boolean`; otherwise, it sets the `checkbox` property on the
    node and uses the `checked` binding.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. This binding provider will allow binding to occur with the `data-name`
    attribute, requiring only a view model property as the value, and it intelligently
    sets up bindings for the conventional scenario. If we need more control, the regular
    `data-bind` attributes can still be used to apply bindings.
  prefs: []
  type: TYPE_NORMAL
- en: This simplified implementation of the `BindingConventions` binding provider
    can be seen in the `cp3-provider2` branch. The `client/app` directory in the branch
    contains both the simplified implementation discussed here as well as the full
    implementation from the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: None of this would be possible with a binding or node preprocessor, as it relies
    on the type of data from the binding context. Hopefully, this will give you a
    good idea of what is possible with custom binding providers and the flexibility
    of the overall binding system.
  prefs: []
  type: TYPE_NORMAL
- en: Knockout punches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you are familiar with the techniques that are used to modify the binding
    syntax and the general use of preprocessors, we are going to look at the popular
    Knockout plugin `Knockout.Punches (get it?)`. Punches is written by Michael Best,
    who is a Knockout developer and the creator of the Knockout preprocessor functionality
    and some of the best real-world use cases for preprocessors. We are going to look
    at some of them and dig in to see how they work. This section is not going to
    cover everything in Knockout Punches; if you want to learn more about it, you
    can check out the documentation online.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The documentation for `Knockout.Punches` can be found at [http://mbest.github.io/knockout.punches](http://mbest.github.io/knockout.punches),
    which includes an API reference and the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded text bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Embedded text bindings offer the same syntax that we created with the preprocessor
    in the *Supporting alternate syntaxes* section—converting curly braces into virtual
    text nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The method Knockout Punches uses is more performant than the one we looked
    at, but it still offers the same customizability we used. If you want to use something
    besides virtual text nodes as the interpolation replacement, you can provide your
    own `node-array` returning function as a replacement for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Namespaced bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Knockout Punches offers a shorthand binding syntax that expands `x.y: value`
    to `x : { y: value }`. By default, this namespace syntax is available for the
    `event`, `attr`, `style`, and `css` bindings. Using it on the `style` binding
    will cause the following to expand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will expand to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This works by overriding the standard `ko.getBindingHandler` function, which
    just returns the binding handler normally. It is replaced by one that looks for
    a dot in the name of the binding with a matching `getNamespacedHandler` property
    and returns that one instead.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic namespaced bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because `ko.getBindingHandler` is overridden like this, it is possible to create
    your own binding namespaces by adding a `getNamespacedHandler` property to a binding
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `binding` argument is the name of the binding; for `style.color`, it will
    be `color`. The function returns the binding handler to be used. This allows you
    to provide a single dynamic handler for all bindings in a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to create a binding namespace for the Twitter Bootstrap
    tooltip plugin. We need to supply the text contents and the direction of the tooltip.
    Normally, we might write a binding that took each of these as options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could bind on it with an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This works fine, but we can rewrite this using a namespaced binding handler
    in order to get the dot syntax for the placement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces a much shorter binding attribute, which I think is easier to
    read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: An example of this can be seen in the `cp3-namespace` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Binding filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s pretty common to perform filtering on viewmodel properties. The usual
    practice is to have a computed property on the viewmodel perform the filtering,
    but this can become verbose, especially if you have several different filtered
    properties. Knockout Punches provides syntax that applies filter expressions inside
    of bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Filters are pipe-delimited, and multiple arguments are separated by colons.
    For example, `fit` takes up to three arguments, which can be specified with `fit:20:'…':'middle'`.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that `name` does not include the observable parentheses in
    the preceding example. While the entire binding with the filters is a single expression,
    which would normally require the parentheses, Knockout Punches intelligently handles
    each section by calling `ko.unwrap` on it. This means that the binding value and
    each filter are treated as their own expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filtering is accomplished with a binding preprocessor that parses the expression
    and recursively unwraps the piped sections into a call to the filter. The preceding
    example will end up returning the following from the `preprocess` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Writing custom filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding your own filters is very similar to adding binding handlers. Just add
    a function to the `ko.filters` object that takes a value and any number of arguments
    and returns a modified value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the current value that is to be processed. All other arguments
    are those that are given to the filter in the binding expression.
  prefs: []
  type: TYPE_NORMAL
- en: Filters can have zero arguments—as in the `uppercase` example—or optional arguments—as
    in the `fit` example. The filter preprocessor does not check the filter to see
    whether the number of arguments it's sending make sense; it just calls the filter
    with everything in the binding expression.
  prefs: []
  type: TYPE_NORMAL
- en: The filter preprocessor is simple to extend, and it offers considerable power.
    I think it is one of the best examples anywhere of the potential of binding preprocessors.
  prefs: []
  type: TYPE_NORMAL
- en: Filters on other bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, filters are enabled for the `text`, `attr`, and `html` bindings,
    but additional bindings can use filters by calling `ko.punches.textFilter.enableForBinding(<binding>)`.
    This can be useful if you wanted to take advantage of filters on a custom binding.
  prefs: []
  type: TYPE_NORMAL
- en: Filters cannot be used in two-way bindings, such as the binding value, as they
    always produce inline expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional preprocessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Knockout Punches provides two utility methods in order to add additional binding
    and node preprocessors that can be accessed from `ko.punches.utils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addBindingPreprocessor(bindingKeyOrHandler, preprocessFn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addNodePreprocessor(preprocessFn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you call either of these multiple times, the respective preprocessors will
    be chained together, with each new preprocessor being called at the end of the
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: The binding preprocessors will run until one of them removes the binding or
    until the end of the chain is reached. This stops the chain from trying to process
    a binding that no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: The node preprocessors will run until one of them returns new nodes to add or
    until the end of the chain is reached. This stops the chain from trying to process
    a node that has already been modified. The new nodes will not be walked by the
    node preprocessors, so they should be added to the DOM and be made ready for data
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter was all about how to extend Knockout''s binding process and modify
    its syntax. We covered three ways of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binding Preprocessors**: This is used to modify binding strings before binding
    handlers run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node Preprocessors**: This is used to modify the DOM before the binding starts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binding Providers**: This is used to control what bindings are applied to
    each DOM node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we looked at the `Knockout.Punches` plugin to see some real-world Knockout
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover Knockout's web component features, which
    let you tie view and viewmodel together into reusable controls.
  prefs: []
  type: TYPE_NORMAL
