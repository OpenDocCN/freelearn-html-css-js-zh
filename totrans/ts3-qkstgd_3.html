<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Unleashing the Power of Type with Objects</h1>
                </header>
            
            <article>
                
<p><span>TypeScript can be overwhelming with all the different objects. In this chapter, we illustrate the difference between an <kbd>object</kbd>, <kbd>Object</kbd>, <kbd>object literal</kbd>, and an object built with a constructor. This chapter also discusses the notion of a union between types that will allow an infinite combination of types for a single value. Furthermore, the concept of an intersection looms, giving the possibility of manipulating type differently. At the end of this chapter, the reader will be able to create complex combinations of objects that hold advanced structures. We will dissect how to create a dictionary with a strongly typed index signature, understand how type can be beneficial with a map, and learn how to use the right object to be as accurate as possible when defining an object that can have a broad reach.</span></p>
<p><span>This chapter covers the following topics:</span></p>
<ul>
<li class="h1">How to strongly type a set/dictionary with an index signature</li>
<li class="h1">TypeScript and map</li>
<li class="h1">The difference between an index signature and a map</li>
<li class="h1">The difference between <kbd>object</kbd> and <kbd>Object</kbd></li>
<li class="h1">When to use <kbd>object</kbd>, <kbd>Object</kbd>, or any</li>
<li class="h1">What is an <kbd>object literal</kbd></li>
<li class="h1">How to create a constructed object</li>
<li class="h1">The difference between an explicit type or a cast</li>
<li class="h1">Variable with many types</li>
<li class="h1">Combining a type with an intersection</li>
<li class="h1">Intersecting with something other than a type</li>
<li class="h1">Intersecting with an optional type</li>
<li class="h1">Merging a type with inheritance</li>
<li class="h1">The difference between a type and an interface</li>
<li class="h1">Destructuring a type and an array</li>
<li class="h1">Tuple</li>
<li class="h1">The difference between declare and <kbd>let</kbd>/<kbd>const</kbd>/<kbd>var</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to strongly type a set/dictionary with an index signature</h1>
                </header>
            
            <article>
                
<p>Besides an array, a <em>set</em> or a <em>dictionary</em> is a common structure to store unstructured data for quick access. In JavaScript, using the dynamic notion of being able to assign a member to an object creates a dictionary. Each object's property becomes a key of the dictionary. TypeScript's types above this pattern with <em>index signature</em>. It allows you to specify the type of the key (between number and string) and any type of values:</p>
<pre>interface Person {<br/> [id: string]: string;<br/>}</pre>
<p>Writing into the dictionary is as simple as using the square bracket and assigning the value that must respect the right side of the definition. In the following code example, the key and the value are strings:</p>
<pre>const p: Person = {};<br/><br/>p["id-1"] = "Name1";<br/>p["string-2"] = "Name12";<br/><br/>console.log(p["string-2"]); // Name12 </pre>
<p>An index signature can be tricky because of historical reasons. For example, if the index is defined to accept a string as the key, you will be able to pass a string and a number as well. The other way around is not true: a key with a number type does not accept a string:</p>
<pre>const c: Person = {<br/>  "test": "compile", <br/>  123: "compile too" // Key is number even if Person requires string: it compiles<br/>};<br/><br/>interface NotAPerson {<br/>  [id: number]: string;<br/>}</pre>
<pre><br/>// DOES NOT COMPILE:<br/>const c2: NotAPerson = {<br/>  "test": "compile", // THIS LINE DOES NOT COMPILE<br/>  123: "compile too"<br/>};</pre>
<p>The last example illustrates more than a single issue with the type of key. The code uses a syntax to define a value for an index signature directly by using an <kbd>object literal</kbd> where all members are the keys and their value the index signature's value. This is the syntax to use to initialize default value, while the other way, with square brackets, is the way to add dynamically and access value rapidly.</p>
<p>Additionally, TypeScript allows you to access a member of an object with a square bracket by providing the name of the member as a string. The distinction with index signature is that TypeScript won't let you read or add a member if the index signature is not provided in your definition:</p>
<pre>interface NotIndexSignatureObject {<br/>    name: string;<br/>    count: number;<br/>}<br/><br/>const obj: NotIndexSignatureObject = {<br/>    name: "My Name",<br/>    count: 123<br/>};<br/><br/>console.log(obj["doesNotExist"]); // Does not compile<br/>console.log(obj["name"]); // Compile</pre>
<p>Another quirk with index signature is when it is combined with an object that has other members. The key of the index signature can be only of a string with members returning a string. It means that most of the time you will have to fall back with a key of a number. The following code does not compile:</p>
<pre> interface ObjWithMembersAndIndexSignature {<br/>    name: string;<br/>    count: number;<br/>    when: Date;<br/>    [id: string]: string; // DOES NOT COMPILE<br/>}</pre>
<p>By contrast, the following code compiles but is fragile. The reason it compiles is that in some very rare cases, TypeScript automatically converts types back to a string, depending on its usage. In that case, the <kbd>number</kbd> and <kbd>Date</kbd> of the member <kbd>count</kbd> and <kbd>when</kbd> is accepted to be a string. However, a tiny change of adding a member that has an object will disrupt that rule. The two following blocks of code illustrate that change. This following block contains a primitive:</p>
<pre>interface ObjWithMembersAndIndexSignature {<br/> name: string;<br/> count: number;<br/> when: Date;<br/> [id: number]: string; // COMPILE<br/>}</pre>
<p><span>This second block contains an additional object that is not allowed when an index signature is defined:</span></p>
<pre class="mce-root">interface ObjWithMembersAndIndexSignature2 {<br/> name: string;<br/> count: number;<br/> when: Date;<br/> obj: { s: string }; // DOES NOT COMPILE<br/> [id: number]: string | number | Date;<br/>}</pre>
<p>Another compilation issue you might have is to add a string key to an object with an index signature that has a key to a number:</p>
<pre>const obj2: ObjWithMembersAndIndexSignature = {<br/>    name: "My Name",<br/>    count: 123,<br/>    when: new Date(),<br/>    "more": "nooo" // DOES NOT COMPILE<br/>};</pre>
<p>You can transform the object definition by providing a member of a type number with a value of a string:</p>
<pre>  const obj3: ObjWithMembersAndIndexSignature = {<br/>    name: "My Name",<br/>    count: 123,<br/>    when: new Date(),<br/>    12: "string only" // Good if number-&gt;string<br/>};</pre>
<p>However, if you want to have a string as a key you will need to change the type allowed as a value in your index signature to have a union of every member:</p>
<pre>  interface ObjWithMembersAndIndexSignature2 {<br/>    name: string;<br/>    count: number;<br/>    when: Date;<br/>    [id: string]: string | number | Date;<br/>}</pre>
<p>To conclude with index signature, it is wise to have your mapping object small and without too many members, to allow having an index signature that can be accessed without requiring to narrow the type. For example, the last code example was returning a string or a number or a date. This means that every access to the object is required to check the type before consuming its properties. However, having an interface that has only the index signature can be used as a property of an object and have all the quick access without needing to narrow down. Here is the code that illustrates the pattern:</p>
<pre>interface MyMap&lt;T&gt; {<br/>    [index: string]: T;<br/>}<br/><br/>interface YourBusinessLogicObject {<br/>    oneProps: string;<br/>    secondProps: number;<br/>    thirdProps: Date;<br/>    yourDictionary: MyMap&lt;string&gt;;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TypeScript and map</h1>
                </header>
            
            <article>
                
<p>We discussed creating a dictionary/set with the index signature that leverages the flexibility of an object. An alternative is the use of a <kbd>map</kbd> class. A <kbd>map</kbd> is a class that can be instantiated with or without values, and it is a type of object that is not unique to TypeScript. ECMAScript defines how a map is structured and behaves; TypeScript is providing a type on top of the class.</p>
<p>A map has the same capability of fast access than index signature. The following code instantiates the <kbd>Map</kbd> with two key-values entries. The key and the value can be anything. What is important in the constructor is when providing a value, this one must be iterable:</p>
<pre>let map = new Map([["key1", "value1"], ["key2", "value2"]]);<br/><br/>let value1: string | undefined = map.get("key1");</pre>
<p><span>The previous code not only created a map but also accessed a value by using a key of the same type as defined in the constructor. If a key does not exist in the map, an undefined value is returned, similar to the index signature. The next code example creates two maps, without providing initial values. The first one doesn't use the generic definition; hence, falls back to the type <kbd>any</kbd> for the key and the value. However, the second line shows an initialization that specifies the generic type to have a key of string and a value of a number. Even if the map does not have values specified at the initialization, the latter still provides a strongly typed enforcement for a future value set by the function</span> set:</p>
<pre>let map2 = new Map(); // Key any, value any<br/>let map3 = new Map&lt;string, number&gt;(); // Key string, value number</pre>
<p>The following code does not compile because the key type must be the same. In the code example, it has a number and a string:</p>
<div>
<pre><span>let map4 = new Map([[1, "value1"], ["key2", "value2"]]); // Doesn't compile</span></pre></div>
<p>A map has many functions other than get. It can <em>set</em> values, which is handy when you do not have all the values of the creation of the map. A map can also look up to see whether a key exists in the map by returning <kbd>true</kbd> or <kbd>false</kbd>. Finally, it is possible to remove an entry with a function instead of relying on the <kbd>delete</kbd> keyword for an index signature:</p>
<pre>map.set("key3", "value3");<br/>map.has("key1");<br/>map.delete("key1"); // Similar to delete obj.key1 (index signature)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The differences between index signature and a map</h1>
                </header>
            
            <article>
                
<p>The differences between using a map or an index signature pattern with an object are slim. Here are two lists of the pros of each structure:</p>
<p><strong>Object</strong>:</p>
<ul>
<li>Can have more than just a key-value. It can have functions and other members.</li>
<li>An object coming from JSON is automatically compatible with an index signature, while a map would require a manual mapping.</li>
<li>An object pattern is faster at accessing data than the map, and uses less memory for a small set of data and a medium set of data. This is true with Chrome, but benchmarks are not consistent among browsers, as well as the overall size of the map/object.</li>
</ul>
<p><strong>Map</strong>:</p>
<ul>
<li>A map performs better when many add and delete. It uses a hashing function underneath.</li>
<li>It preserves the order when an element is added. This might be an advantage, since a map is naturally iterable.</li>
<li>A map performs better with a large set of data.</li>
<li>A map's key is not limited to a number or a string for a key.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The differences between object and Object</h1>
                </header>
            
            <article>
                
<p>There are many object types in TypeScript. There is <kbd>Object</kbd>, <kbd>object</kbd>, <kbd>class object</kbd>, and <kbd>object literal</kbd>. In this section, we will cover the differences between an <kbd>Object</kbd> (uppercase) and an <kbd>object</kbd> (lowercase).</p>
<p>The <kbd>Object</kbd> type that starts with a capital letter, or the uppercase one, or with the big <em>O</em> represents something ubiquitous, a cross type that is available with every type and object. The capital letter Object carries a common set of functions. Here is the list of its available functions:</p>
<pre>toString(): string;<br/>toLocaleString(): string;<br/>valueOf(): Object;<br/>hasOwnProperty(v: string): boolean;<br/>isPrototypeOf(v: Object): boolean;<br/>propertyIsEnumerable(v: string): boolean;</pre>
<p>A huge set of types comes under the umbrella of <kbd>Object</kbd>. Assigning several different values to an object of type <kbd>Object</kbd> shows the flexibility of the type and how broad the potential range of types is:</p>
<pre>let bigObject: Object;<br/>bigObject = 1;<br/>bigObject = "1";<br/>bigObject = true;<br/>bigObject = Symbol("123");<br/>bigObject = { a: "test" };<br/>bigObject = () =&gt; { };<br/>bigObject = [1, 2, 3];<br/>bigObject = new Date();<br/>bigObject = new MyClass();<br/>bigObject = Object.create({});</pre>
<p>The lowercase object coverts everything that is not a number, a string, a <kbd>boolean</kbd>, a <kbd>null</kbd>, an <kbd>undefined</kbd>, or a <kbd>Symbol</kbd>. The lowercase <kbd>object</kbd> is a subset of the uppercase <kbd>Object</kbd>. It contains <kbd>object literals</kbd>, dates, functions, arrays, and an instance of an object created with <kbd>new</kbd> and <kbd>create</kbd>:</p>
<pre>let littleObject: object;<br/><br/>littleObject = { a: "test" };<br/>littleObject = new Date();<br/>littleObject = () =&gt; { };<br/>littleObject = [1, 2, 3];<br/>littleObject = new MyClass();<br/>littleObject = Object.create({});</pre>
<p>In the cases of <kbd>null</kbd> and <kbd>undefined</kbd>, they are neither <kbd>object</kbd> nor <kbd>Object</kbd>. They are in a special category and are a subtype of all other types. TypeScript's compiler must be configured with the strict option <kbd>"strictNullCheck"</kbd>, which is the de-factor configuration value, meaning that even if <kbd>null</kbd> and <kbd>undefined</kbd> are a subset of all types, only a union of the main type and <kbd>null</kbd> or <kbd>undefined</kbd> will allow the assignation to either of these two special values:</p>
<pre>let acceptNull: number | null = null;<br/>acceptNull = 1;<br/><br/>let acceptUndefined: number | undefined = 1;<br/>acceptUndefined = null;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to use object, Object, or any</h1>
                </header>
            
            <article>
                
<p>Which type of object to use is a sub-question of the previous one that was discussing the differences between <kbd>object</kbd>, <kbd>Object</kbd>, and <kbd>any</kbd>. The rule of thumb is to always use the more conscribe type. It means to avoid using both <kbd>object</kbd> and <kbd>Object</kbd> as much as possible. However, in a case where you need to cover a wider range of types and you cannot define them with a union, the use of <kbd>object</kbd> is better if you do not need a primitive, because it has less potential values.</p>
<p>Both <kbd>object</kbd> and <kbd>Object</kbd> are better than <kbd>any</kbd> because <kbd>any</kbd> allows accessing any members of any type while <kbd>object</kbd> will limit you to the following:</p>
<pre>let obj1: Object = {};<br/>let obj2: object = {};<br/>let obj3: {} = {};<br/>let obj4: any = {};<br/><br/>obj1.test = "2"; // Does not compile<br/>obj2.test = "2"; // Does not compile<br/>obj3.test = "2"; // Does not compile<br/>obj4.test = "2";<br/><br/>obj1.toString();<br/>obj2.toString();<br/>obj3.toString();<br/>obj4.toString();</pre>
<p>If you do not know the type and need to take an object, you should use an <kbd>object</kbd> (lowercase) if you are not allowing a primitive. You should fallback to <kbd>Object</kbd> (uppercase) if you support a primitive and in the last resort use <kbd>any</kbd>. However, a better potential approach is, if possible, to use a generic type that allows avoiding doing a type check and casting, which is often a pitfall of using something such as <kbd>object</kbd> and <kbd>Object</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is an object literal?</h1>
                </header>
            
            <article>
                
<p>An <kbd>object literal</kbd> is an <kbd>object</kbd> created with curly brackets. An <kbd>object literal</kbd> is an <kbd>Object</kbd> and an <kbd>object</kbd>. You can define the type for an <kbd>object literal</kbd> with <kbd>type</kbd> or <kbd>interface</kbd>. It is a quick way to have data in a structure that is typed. The <kbd>object literal</kbd> inherits from <kbd>Object</kbd> (uppercase).</p>
<pre>type ObjLiteralType = { x: number, y: number };<br/>interface ObjLiteralType2 {<br/>  x: number;<br/>  y: number;<br/>}</pre>
<p class="mce-root">We can do a quick test with four functions and see that the <kbd>object literal</kbd> is accepted in all of the functions, even if the parameter's type is different among all the function's signature:</p>
<pre>function uppercaseObject(obj: Object): void { }<br/>function lowercaseObject(obj: object): void { }<br/>function anyObject(obj: any): void { }<br/>function objectLiteral(obj: {}): void { }<br/><br/>uppercaseObject({ x: 1 });<br/>lowercaseObject({ x: 1 });<br/>anyObject({ x: 1 });<br/>objectLiteral({ x: 1 });</pre>
<p>Two (or more) objects that literally have the same structure are interchangeable. You can define an object literal and set it in a variable that defines the same structure in the interface. You can also do the same if the type is anonymous or inferred. Here are the four ways to create a typed <kbd>object literal</kbd>. They are all assignable to one another because they share the same structure. This is a strength of TypeScript, as it is a structural language, as opposed to a nominal language: </p>
<pre>let literalObject: ObjLiteralType = { x: 1, y: 2 };<br/>let literalObject2: ObjLiteralType2 = { x: 1, y: 2 };<br/>let literalObject3: { x: number, y: number } = { x: 1, y: 2 };<br/>let literalObject4 = { x: 1, y: 2 };<br/><br/>literalObject = literalObject2 = literalObject3 = literalObject4;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to create a constructed object</h1>
                </header>
            
            <article>
                
<p>Finally, a class object is an object defined with the keyword <kbd>class</kbd> and instantiated with the keyword <kbd>new</kbd>. Every class can be instantiated more than once. Every instantiation starts with the use of <kbd>new</kbd>, and every value set in an object remains in that object, with the exception of static fields, which are shared across every instance of the same class. We will see many features of object-oriented and object in a later chapter:</p>
<pre>class ClassWithConstructor {<br/>    constructor(){<br/>        console.log("Object instantiated");<br/>    }<br/>}<br/>const cwc = new ClassWithConstructor();</pre>
<p>The creation of the class calls the constructor. In the previous code example, the <kbd>console.log</kbd> will be called during the instantiation of the class into an object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The differences between an explicit type and a cast</h1>
                </header>
            
            <article>
                
<p>If you have an interface that you want to build, you can set the variable type with the colon and specify the fields. If a field misses TypeScript will not compile; if there is more than the definition, TypeScript won't compile:</p>
<pre>interface MyObject {<br/>    a: number;<br/>    b: string;<br/>}<br/>const newObject1: MyObject = { a: 1, b: "2" };</pre>
<p>Another way is to avoid specifying the type after the colon and use <kbd>as</kbd> to cast:</p>
<pre>  const newObject2 = { a: 1, b: "2" } as MyObject;</pre>
<p>The issue is that cast coerces TypeScript to believe the object is the type specified even if it does not respect the contract. Casting should never be used to define a variable. The reason is that even if the contract is respected initially, if the object changes, the cast will still force the type assignation, but the object will not with the right structure. The following two lines compile but are invalid in term of logic. The first one has an additional member that is not in the interface, and the second line is missing one field:</p>
<pre>const newObject3 = { a: 1, b: "2", c: "OH NO" } as MyObject;<br/>const newObject4 = { a: 1 } as MyObject;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variable with many types</h1>
                </header>
            
            <article>
                
<p>In many situations, a variable requires having more than one field. For example, you can have a field that only takes a value among a few strings:</p>
<pre>type MyType = "a" | "b" | "c";<br/>const m1: MyType = "a";<br/>const m2: MyType = "no"; // Doesn’t compile</pre>
<p>The creation of a type with the keyword <kbd>type</kbd> is not required but allows reusability of the type. The first example was creating a type with many allowed strings. A variable declared with the new type will only accept the strings from the list. However, most of the time, unions are using a more complex type, such as between the interface, type and primitive:</p>
<pre>type AcceptedOption = number | string | { option1: string, option2: number };<br/>const myOption1: AcceptedOption = "run";<br/>const myOption2: AcceptedOption = 123;<br/>const myOption3: AcceptedOption = { option1: "run", option2: 123 };</pre>
<p>A function can take a union type as a parameter and return a return type as well. A union is often used to accept a type as well as <kbd>undefined</kbd>:</p>
<pre>function functWithUnion(p: boolean | undefined): undefined | null{<br/>      return undefined;<br/>}</pre>
<p>When using a union, only the common fields are accessible. In the following code, <kbd>TypeA</kbd> has two fields, <kbd>a</kbd> and <kbd>b</kbd>, and <kbd>TypeB</kbd> has <kbd>b</kbd> and <kbd>c</kbd>. The only common field is <kbd>b</kbd>, which means that it is the only available and accessible field in the function. This is true until we narrow down the type to one of a type in the union. We will see how type narrowing works later:</p>
<pre>interface TypeA {<br/>    a: string;<br/>    b: string;<br/>}<br/><br/>interface TypeB {<br/>    b: string;<br/>    c: string;<br/>}<br/><br/>function functionWithUnion(param1: TypeA | TypeB): void {<br/>    console.log(param1.b);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Combining type with intersect</h1>
                </header>
            
            <article>
                
<p>The more you build types, the more you will need a feature to work with them. The intersect feature is one tool in TypeScript's toolbox that lets you merge types together. The intersection symbol is the ampersand (<kbd>&amp;</kbd>). The following code example shows that we are creating a third type with the combination of two interfaces. The common fields become one, and the difference adds up:</p>
<pre>interface TypeA {<br/>    a: string;<br/>    b: string;<br/>}<br/>interface TypeB {<br/>    b: string;<br/>    c: string;<br/>}<br/><br/>type TypeC = TypeA &amp; TypeB;<br/>const m: TypeC = {<br/>    a: "A",<br/>    b: "B",<br/>    c: "C",<br/>};</pre>
<p>It is possible to intersect generic and primitive as well. The latter is less used, since it is almost not pragmatic. However, the former (generic) is helpful to merge a custom type into a defined contract:</p>
<pre>interface TypeA {<br/>    a: string;<br/>    b: string;<br/>}<br/>function intersectGeneric&lt;TT1&gt;(t1: TT1): TT1 &amp; TypeA {<br/>    const x: TypeA = { a: "a", b: "b" };<br/>    return (&lt;any&gt;Object).assign({}, x, t1);<br/>}<br/><br/>const result = intersectGeneric({ c: "c" });<br/>console.log(result); // { a: 'a', b: 'b', c: 'c' }</pre>
<p>The order of the types in the intersection does not matter. Two types created here are exactly the same:</p>
<pre>type TypeD1 = TypeA &amp; TypeB;<br/>type TypeD2 = TypeB &amp; TypeA;</pre>
<p>However, even if they are the same, with the same value, each initialization creates a unique object, meaning that comparing them will be false. Regarding comparing two identical types with different names, they are both of type <kbd>Object</kbd> and the reason is that <kbd>typeOf</kbd> is a JavaScript operator and the type is removed at run-time; hence, it behaves the same way at design time. To compare type we need a discriminator that we will discuss later:</p>
<pre> let d1: TypeD1 = { a: "a", b: "b", c: "c" };<br/> let d2: TypeD2 = { a: "a", b: "b", c: "c" };<br/><br/> console.log(typeof d1); // Object<br/> console.log(typeof d2); // Object<br/> console.log(d1 === d2); // False<br/><br/> d2 = d1;<br/> console.log(d1 === d2); // True</pre>
<p>The use of parentheses does not affect the declaration of the type. The following code is redundant, with the union being useless. Here are four different types that take the same value:</p>
<pre>type TypeD3 = (TypeA &amp; TypeB) | (TypeB &amp; TypeA);<br/>type TypeD4 = TypeA &amp; TypeB | TypeB &amp; TypeA;<br/>type TypeD5 = (TypeA &amp; TypeB);<br/><br/>type TypeD6 = TypeA &amp; TypeB;<br/><br/>let d3: TypeD3 = { a: "a", b: "b", c: "c" };<br/>let d4: TypeD4 = { a: "a", b: "b", c: "c" };<br/>let d5: TypeD5 = { a: "a", b: "b", c: "c" };<br/>let d6: TypeD6 = { a: "a", b: "b", c: "c" };</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Intersecting with something other than a type</h1>
                </header>
            
            <article>
                
<p>It is possible to intersect with a type, primitive, and an interface. Intersecting with primitive is useless, since a number cannot be a boolean at the same time. However, intersecting an interface is valid as much as intersecting with a type. The same rules apply for a type or an interface, with regard to intersecting:</p>
<pre>interface InterfaceA {<br/> m1: string;<br/>}<br/><br/>interface InterfaceB {<br/> m2: string;<br/>}<br/><br/>type TypeAB = InterfaceA &amp; InterfaceB;</pre>
<p>While the most common case of intersection touches type and interface, it is possible to intersect classes. Intersection with classes are rare and it creates a type that cannot be instantiated. Only the public fields are extracted from each class to create a field:</p>
<pre>type ClassAb = ClassA &amp; ClassB;<br/>const classAb: ClassAb = { m1: "test", m2: "test2" };</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Intersecting with an optional type</h1>
                </header>
            
            <article>
                
<p>It is possible to intersect two types with cross properties that have different rules. A field in one type with the mention of an option member can be merged with a type that is not optional. The result is that the field becomes non-optional:</p>
<pre> interface InterfaceSameField1 {<br/>    m1: string;<br/> }<br/><br/> interface InterfaceSameField2 {<br/>    m1?: string;<br/> }<br/><br/> type Same = InterfaceSameField1 &amp; InterfaceSameField2;<br/> let same: Same = { m1: "This is required" };</pre>
<p>The previous code example shows the intersection and the field <kbd>m1</kbd> being required. If omitted or set to undefined, the code does not compile.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merge type with inheritance</h1>
                </header>
            
            <article>
                
<p>It is possible to merge two types if these ones are an interface or a class, by using <kbd>extends</kbd>. Extending an interface with another is an alternative to using the ampersand. In the following code example, the merged interface contains its own member, as well as the member of <kbd>InterfaceA</kbd> and <kbd>InterfaceB</kbd>:</p>
<pre>interface InterfaceA {<br/>  m1: string;<br/>}<br/><br/>interface InterfaceB {<br/>  m2: string;<br/>}<br/><br/>interface InterfaceMergeAB extends InterfaceA, InterfaceB {<br/>  m3: string;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The differences between type and interface</h1>
                </header>
            
            <article>
                
<p>Type and interface are not exactly the same. For example, you can merge two interfaces together, but you cannot merge an interface with a primitive, which can be done with a type. You can define an interface in many definitions allowed future extension outside the main module. The possibility to enhance an interface in many areas allow many plugins or contract versioning patterns to happen. The technical jargon for this feature is <strong>open-ended:</strong></p>
<pre>interface IA {<br/>  m1: string;<br/>}<br/><br/>interface IA {</pre>
<pre><br/>  m2: string;<br/>}<br/><br/>const ia: IA = { m1: "m1", m2: "m2" };</pre>
<p>A class can extend a type or an interface. The latter is often more seen because type carries some caveat. For example, a type that contains a primitive won't be a sound choice for a class because the implementation will not work. TypeScript is smart enough to analyze the content of the type and figure out that the implementation cannot occur:</p>
<pre>type TPrimitive1 = string;<br/>type TPrimitive2 = { m1: string };<br/><br/>class ExtendPrimitiv1 implements TPrimitive1 { // Does not compile<br/>}<br/><br/>class ExtendPrimitiv2 implements TPrimitive2 { // Compile<br/> public m1: string = "Compile";<br/>}</pre>
<div>
<p>Type and interface can have an index signature:</p>
<pre>type TypeWithIndex = {<br/>  [key: string]: string;<br/>  m1: string;<br/>}<br/><br/>const c: TypeWithIndex = {<br/>  m1: "m1"<br/>};<br/><br/>c["m2"] = "m2";</pre></div>
<p>The rule of thumb is to rely on an interface as much as possible because of the open-ended feature, the reduction of confusion regarding whether the type can have primitive, and because they can be extended or intersected. The <kbd>type</kbd> keyword is used to create a union of primitive or to intersect object literals on the fly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring a type and an array</h1>
                </header>
            
            <article>
                
<p>Destructuring is a feature of JavaScript that is supported by TypeScript with type protection. Destructuring breaks an object into different pieces. TypeScript brings the type to these pieces.</p>
<p>A scenario is that you need to extract members from an object into a variable. This can be done without destructuring, but it takes several lines of code:</p>
<pre>interface MyObject {<br/>  id: number;<br/>  time: number;<br/>  name: string;<br/>  startTime: Date;<br/>  stopTime: Date;<br/>  category: string;<br/>}<br/><br/>const obj: MyObject = {<br/>  id: 1,<br/>  time: 100,<br/>  name: "MyName",<br/>  startTime: new Date(),<br/>  stopTime: new Date(),<br/>  category: "Cat5"<br/>};<br/><br/>const id = obj.id;<br/>const name = obj.name;<br/>const category = obj.category;</pre>
<p>With destructuring, it can be done in a single line. All the variables are from the type of the object. It means that <kbd>id</kbd> is a new variable of type number, <kbd>name</kbd> is of the type string, as well as <kbd>category</kbd>:</p>
<pre>const { id, name, category } = obj;</pre>
<p>Destructuring can use the rest operator to take the remainder of the properties not specified. The rest of the syntax is the three dots before the name of the variable that will hold the rest of the members:</p>
<pre>const { id, name, category, ...remainingMembers } = obj;<br/><br/>remainingMembers.startTime;<br/>remainingMembers.stopTime;<br/>remainingMembers.time;</pre>
<p>As you can see, the variable <kbd>remainingMember</kbd> has three members that are the three members not explicitly called out before the rest. It means that the type of <kbd>remainingMember</kbd> is an object literal with a member <kbd>startTime</kbd>, <kbd>stopTime</kbd><span> </span>and <kbd>time</kbd> of <kbd>type Date</kbd>, <kbd>Date</kbd>, and <kbd>number</kbd>.</p>
<p>Destructuring and rest also work with an array. You can specify a variable name that will be of the type of the array. The rest allows creating a new array with the remainder of the value with the type of the initial array. In the following code example, the <kbd>value1</kbd> contains the number <kbd>1</kbd> (not a string but as a number). The <kbd>value2</kbd> contains <kbd>2</kbd>, and <kbd>value3To9</kbd> is an array with the values <kbd>3</kbd>, <kbd>4</kbd>, <kbd>5</kbd>, <kbd>6</kbd>, <kbd>7</kbd>, <kbd>8</kbd>, and <kbd>9</kbd>:</p>
<pre> const values = [1, 2, 3, 4, 5, 6, 7, 8, 9];<br/> const [value1, value2, ...value3To9] = values;</pre>
<p>It is also possible to skip position by using a comma without specifying a variable. In the following code example, there is a space between <kbd> value_1</kbd> and <kbd>value_2</kbd>, which means that the value at the second position, which is <kbd>2</kbd>, is not in any individual variable (<kbd>value1</kbd> or <kbd>value2</kbd>), neither is in the variable <kbd>value4To9</kbd>:</p>
<pre>const values = [1, 2, 3, 4, 5, 6, 7, 8, 9];<br/>const [value1, value2, ...value3To9] = values;<br/>const [value_1, , value_3, ...value4To9] = values;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuple</h1>
                </header>
            
            <article>
                
<p>A <strong>tuple</strong> is an alternative to an object to hold multiple values within a single variable. Often used to move information around by function, it leverages an array to carry different types. The assignation with a tuple is done by setting the desired value in a specific index of an array, which the consumer must know to retrieve the pertinent information. In JavaScript, the usage of an array is sufficient. However, doing so in TypeScript leads to a weak type. The following code shows that TypeScript will infer the type to be an array of number or string, which can make sense but not when the code wants to be strongly typed. The reason is that an array can be a number or type at any position of the array, while in a tuple situation we want to have a specific type for each position in the array:</p>
<pre>let tuple1 = ["First name", "Last Name", 1980]; // Infered as (string | number)[]<br/>tuple1[2] = "Not a number";<br/>let tuple2: [string, string, number] = ["First name", "Last Name", 1980]; // Tuple<br/>tuple2[2] = "Not a number"; // Does not compile</pre>
<p>To overcome the array inference, we need to specify the type for each position. However, even if a tuple is more specific than an array with multiple types because of the specification by the index of the type, this one still is not as safe as using an object:</p>
<pre>let tuple3: [string, string, number]<br/>tuple3 = ["Only One"]; // Does not compile<br/>tuple3 = ["One", "Two", 3, "four"]; // Does not compile<br/>tuple3[5] = "12"; // Compile</pre>
<p>The previous code illustrates that during instantiation, there is a validation of type as well as a validation of size. It means that when assigning values, you must respect the type and the number of expected values. However, the last line of the code shows the nature of the array surface, and regardless of the fact that the tuple declaration specifies three positions, it is possible to add any type at any position after the ones defined. In the code example, the three first positions (index <kbd>0</kbd>, <kbd>1</kbd>, and <kbd>2</kbd>) are strongly typed but position four and above can be anything. Nevertheless, <span>changing a value, </span>with the square brackets, will validate the type:</p>
<pre>tuple3[5] = "12"; // Compile, do not mind the type<br/>tuple3[1]= 2; // Does not compile, require to be a string</pre>
<p>Tuple supports spread operator to deconstruct a function parameter into several variables. The following code example shows that a single tuple argument can be spread. The function <kbd>restFunction</kbd> is the equivalent of the <kbd>resultFunction</kbd>. The code example shows that it is possible to pass a tuple but not an array:</p>
<pre>function restFunction(...args: [number, string, boolean]): void{<br/> const p1:number = args[0];<br/> const p2:string = args[1];<br/> const p3:boolean = args[2];<br/> // Code<br/>}<br/><br/>function resultFunction(p1: number, p2: string, p3: boolean): void{<br/> // Code<br/>}<br/><br/>let tuple4: [number, string, boolean] = [0, "one", false];<br/>let array4: (number | string | boolean )[] = [0, "one", false];<br/><br/>restFunction(...tuple4);<br/>restFunction(...array4); // Doesn't compile<br/><br/>restFunction(tuple4[0],tuple4[1],tuple4[2]);<br/>restFunction(array4[0],array4[1],array4[2]); // Does not compile</pre>
<p>Tuple supports optional. The syntax is similar to a function with optional parameters or a type with optional members. Positions without value are automatically set to <kbd>undefined</kbd>: </p>
<pre>let tuple5: [number, string?, boolean?];<br/>tuple5 = [1];<br/>tuple5 = [1, "two"];<br/>tuple5 = [1, "two", false];</pre>
<p><span class="mtk5">The previous declaration is similar to the following, where optional position can be set to</span> <kbd>undefined</kbd> <span class="mtk5">as well:</span></p>
<pre><span class="mtk5">let</span><span class="mtk1"> </span><span class="mtk13">tuple5</span><span class="mtk17">:</span><span class="mtk1"> [</span><span class="mtk11">number</span><span class="mtk1">, (</span><span class="mtk11">string</span><span class="mtk1"> </span><span class="mtk17">|</span><span class="mtk1"> </span><span class="mtk11">undefined</span><span class="mtk1">)</span><span class="mtk17">?</span><span class="mtk1">, (</span><span class="mtk11">boolean</span><span class="mtk1"> </span><span class="mtk17">|</span><span class="mtk1"> </span><span class="mtk11">undefined</span><span class="mtk1">)</span><span class="mtk17">?</span><span class="mtk1">]</span></pre>
<p>Setting the tuple definition in a type can be advantageous when a tuple is reused in several places. The syntax is identical to when defining a type with the keyword type:</p>
<pre>type MyTuple = [number, string];<br/>let tuple6:MyTuple = [1, "Test"];</pre>
<p><span>In conclusion, the tuple is a convenient way to pass information in a function and also to quickly return more than one value. However, a better alternative is to define a quick interface with the member desired. Not only does it not rely on position, but it can be reused in many situations easily by allowing extension and intersection. Furthermore, an object is easier to read because the assignation and the readability rely on a name instead of a number.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The differences between declare and let/const/var</h1>
                </header>
            
            <article>
                
<p>It is possible to use <kbd>declare</kbd> instead of one of the three declarators <kbd>let</kbd>,<kbd>const</kbd>, and <kbd>var</kbd>. However, <kbd>declare</kbd> won't generate any JavaScript code during compilation and must be used in conjunction with <kbd>let</kbd>, <kbd>const</kbd> or <kbd>var</kbd>. The role of <kbd>declare</kbd> is to indicate to TypeScript's compiler that the variable exists but is defined somewhere else:</p>
<pre>declare let myVariable: string;</pre>
<p>The main role of <kbd>declare</kbd> is when signatures need to be defined. The use of <kbd>declare</kbd> in a definition file makes sense because it is only defining the type and not actually declaring the variable.</p>
<p><kbd>declare</kbd> can be used to declare a module. Declaring a module is used to write a definition file outside the actual implementation of the code, which is written in JavaScript or TypeScript:</p>
<pre>declare module "messageformat" {<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed many ways that generic information can be stored with the concept of many objects. We demystified the difference between the uppercase and lowercase object with an object literal and an instantiated object. We clarified two different structures to hold quick access data with index signature and map. The chapter continued with how to manipulate several types with a union and an intersection. Finally, we saw how to destruct, and how declare is different than the three previous declarations mentioned in <a href="aeb84a25-e8a4-48bf-a056-76d0e060f727.xhtml" target="_blank">Chapter 2</a>, <em>Onboarding Types with Primitive</em>.</p>
<p>In the next chapter, we will see how to work with <kbd>object-oriented</kbd>. The next chapter covers how to use inheritance, encapsulation, and static function. The notions of interface and how to define a constructor signature in an interface will be explained. The next chapter dives into the powerful world of <kbd>object-oriented</kbd> in TypeScript.</p>


            </article>

            
        </section>
    </body></html>