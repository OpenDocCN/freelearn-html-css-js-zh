<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Review of Important JavaScript OOP Concepts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Review of Important JavaScript OOP Concepts</h1></div></div></div><p>Before we start creating and using our modules in JavaScript, it is important to have a good grasp of important <span class="strong"><strong>Object Oriented Programming</strong></span> (<span class="strong"><strong>OOP</strong></span>) concepts in JavaScript. We will <a id="id16" class="indexterm"/>rely on such concepts to design and implement our application modules in later chapter.</p><p>While my intent in this chapter is not to explore such conceptes in great depth, I will try to provide a good overview of some of the most important related topics.</p><p>If you feel that you are quite familiar with these concepts in JavaScript, you could skip this chapter and move on to the next one.</p><p>However, if you are not very familiar with OOP in JavaScript, even if you are familiar with similar concepts in classical object oriented languages, I encourage you to follow along as things are a little different in JavaScript. I think it will be worthwhile for you to have a look at these concepts in the realm of JavaScript.</p><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JavaScript objects and their constructors</li><li class="listitem" style="list-style-type: disc">What <code class="literal">this</code> keyword is and how it behaves in different contexts</li><li class="listitem" style="list-style-type: disc">Closure and its uses</li><li class="listitem" style="list-style-type: disc">Inheritance in JavaScript</li><li class="listitem" style="list-style-type: disc">Prototype chaining</li></ul></div><p>And other related topics.</p><div class="section" title="JavaScript objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>JavaScript objects</h1></div></div></div><p>If you<a id="id17" class="indexterm"/> have programmed in JavaScript before (as I'm sure you have, since this book is intended for intermediate to advanced JavaScript programmers), you will certainly have used objects, even if you have not been aware of their inner workings.</p><p>If you<a id="id18" class="indexterm"/> are familiar with other more classical object oriented languages (such as C++, C#, or Java), you'll be surprised to know that there is no formal syntax for defining classes in JavaScript (at least till <span class="strong"><strong>ECMAScript 6</strong></span>). I think you'll be <a id="id19" class="indexterm"/>even more surprised to find out that, without having a formal syntax, you are still able to create classes in JavaScript and harness the full power of object oriented design and architecture (and one could even argue in a more flexible way).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>
<span class="strong"><strong>Formal class definition in JavaScript</strong></span>
</p><p>In the <a id="id20" class="indexterm"/>newer version of JavaScript (ES6), new syntax allows you to define classes in a more formal and structured way.</p><p>For more information visit the following link:</p><p>
<a class="ulink" href="http://es6-features.org/">http://es6-features.org/</a>
</p></div></div><p>You can create objects in JavaScript in many different ways but we will focus on three of these approaches for creating objects in this chapter. These approaches are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using native object type constructors</li><li class="listitem" style="list-style-type: disc">Using object literal notation</li><li class="listitem" style="list-style-type: disc">Using constructor functions</li></ul></div><div class="section" title="Object type constructors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec06"/>Object type constructors</h2></div></div></div><p>Probably<a id="id21" class="indexterm"/> the easiest way to create objects in JavaScript is to create an instance of the Object type and then augment it with properties that we need.</p><p>As you might know, the Object type is the top level object (the root object) in JavaScript that all other objects are created from behind the scenes. This object has many properties which have been defined for it by default. Every object created based on this type will inherit these default properties such as <code class="literal">toString</code>, <code class="literal">valueOf</code>, <code class="literal">hasOwnProperty</code>, and so on.</p><p>Have a look at the following syntax as it shows the creation of an object using the <code class="literal">Object</code> constructor and augmenting it with custom properties:</p><div class="informalexample"><pre class="programlisting">var myObj = new Object();

  myObj.value = "my first value";
  myObj.method = function(){
  return this.value;
};

console.log(myObj.method()); // displays "my first value"</pre></div><p>This<a id="id22" class="indexterm"/> syntax for creating objects was very popular at one point. However, it is no longer used as much, since using other methods of creating objects allows for a better conceptual view of how the object properties are packaged. Also, using an object constructor is not as optimized, since the interpreter needs to do a scope resolution to determine whether there is a local constructor with the same name or not, in order to create the scope chain properly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>
<span class="strong"><strong>Regarding scope chains</strong></span>
</p><p>A <span class="strong"><strong>scope chain</strong></span> is<a id="id23" class="indexterm"/> a chain of objects whose properties are looked for when looking for the existence and value of a property.</p><p>For <a id="id24" class="indexterm"/>more information visit the following link:</p><p>
<a class="ulink" href="https://blogs.msdn.microsoft.com/jscript/2007/07/26/scope-chain-of-jscript-fu">https://blogs.msdn.microsoft.com/jscript/2007/07/26/scope-chain-of-jscript-fu</a>
</p></div></div></div><div class="section" title="Object literal notation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Object literal notation</h2></div></div></div><p>Creating <a id="id25" class="indexterm"/>objects using <span class="strong"><strong>object literal notation</strong></span> allows for a good conceptual view of the object and all of its properties.</p><p>This <a id="id26" class="indexterm"/>approach is also very popular for passing multiple parameters to functions instead of passing one parameter at a time. This method of passing parameters allows us to package all the parameters neatly into an object (usually as an anonymous object) and pass it as one parameter into the function.</p><p>Using this syntax, an object in JavaScript can be created as simply as shown here:</p><div class="informalexample"><pre class="programlisting">var obj = {};</pre></div><p>Of course, this object does not do anything and is completely useless, but nonetheless it is a valid object (<span class="strong"><strong>Singleton</strong></span>).</p><p>Let's create another object using this approach, as shown here:</p><div class="informalexample"><pre class="programlisting">var MyFirstObj = {
  myFirstValue : 2,
  mySecondValue : 5,
  
  addValues: function(){
    return this.myFirstValue + this.mySecondValue ;
  }
};</pre></div><p>In the code above, we have created a variable that has been initialized with an object. Our object here consists of two value properties and a simple method (method property) to add these value properties.</p><p>To<a id="id27" class="indexterm"/> interact with the object in the preceding<a id="id28" class="indexterm"/> code, we can use the variable that holds (references) the object <code class="literal">MyfirstObj</code> and access its members using the dot notation, as follows:</p><div class="informalexample"><pre class="programlisting">console.log( MyFirstObj.addValues()); // displays 7</pre></div></div><div class="section" title="Function objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Function objects</h2></div></div></div><p>In <a id="id29" class="indexterm"/>JavaScript, functions are considered first class objects. In fact, anytime <a id="id30" class="indexterm"/>you are dealing with a function, you are dealing with an object.</p><p>We do not always use functions as objects in JavaScript but, when are used as objects, we can use them as constructors to create other objects.</p><div class="section" title="Functions as object constructors (classes)"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Functions as object constructors (classes)</h3></div></div></div><p>Let's <a id="id31" class="indexterm"/>mimic the object definition in the previous section, which was written as an object literal, and create a constructor function to achieve the same functionality. Consider the following:</p><div class="informalexample"><pre class="programlisting">function MyObjDefinition(){
  var myFirstValue = 2;
  var mySecondValue = 5;

  this.addValues = function(){
    return myFirstValue + mySecondValue;
  };
}

var myFirstObj = new MyObjDefinition();

console.log( myFirstObj.addValues()); // displays 7 </pre></div><p>Notice that I have created a function and called it <code class="literal">MyObjDefinition</code>. I named the function as such to indicate that this function is going to be used as a definition (class) to create other objects from.</p><p>Using the <code class="literal">new</code> keyword, we can create an instance of this object and assign it to the <code class="literal">myFirstObj</code> variable.</p><p>If you are not used to using function objects as constructors, at this point you might wonder if <code class="literal">MyObjDefinition</code> is a function, a class, or an object?</p><p>Well, <code class="literal">MyObjDefinition</code> is <a id="id32" class="indexterm"/>all of those! I will explain this in more depth shortly.</p></div><div class="section" title="Functions as static objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Functions as static objects</h3></div></div></div><p>Let's <a id="id33" class="indexterm"/>modify the preceding code so we can see how <code class="literal">MyObjDefinition</code> can be better thought of as an object.</p><div class="informalexample"><pre class="programlisting">// defining an object
function MyObjDefinition(){
  MyObjDefinition.myFirstValue = 2;
  MyObjDefinition.mySecondValue = 5; 
}

// adding a property to the object
MyObjDefinition.addValues = function(){

  return this.myFirstValue + this.mySecondValue;
};

// initializing the object by calling it as a function
MyObjDefinition();</pre></div><p>As you can see, we have moved our inner <code class="literal">addValues</code> method to the outside of the object definition and used the dot notation to add it to <code class="literal">MyObjDefinition</code> object as a property.</p><p>The reason that we can use such syntax is because JavaScript considers <code class="literal">MyObjDefinition</code> function as both a function and an object. Since we can assign properties to objects dynamically in JavaScript, we are able to assign the <code class="literal">addValues</code> function as a property to this object, using the dot notation.</p><p>Note that we have called our object definition as a regular function to initialize the default values for the <code class="literal">myFirstValue</code> and <code class="literal">mySecondValue</code> properties. Of course, we can do this because <code class="literal">MyObjDefinition</code> is also a function.</p><p>We also have changed the <code class="literal">myFirstValue</code> and <code class="literal">mySecondValue</code> variables inside the function definition to <code class="literal">MyObjDefinition.myFirstValue</code> and <code class="literal">MyObjDefinition.mySecondValue</code>, respectively. This is so <code class="literal">MyObjDefinition.addValues</code> can access them from outside the function definition. If you are not sure what <code class="literal">this</code> keyword is, do not be concerned as we will talk about it shortly.</p><p>To add the two values, we can still use the same syntax as before:</p><div class="informalexample"><pre class="programlisting">console.log( MyObjDefinition.addValues()); // displays 7</pre></div><p>Notice that we are not able to use <code class="literal">MyObjDefinition</code> as a constructor function as we did before, since now it is acting as a static object. So the following will produce an error:</p><div class="informalexample"><pre class="programlisting">var anotherObj = new MyObjDefinition();
anotherObj.addValues(); // error</pre></div><p>In this scenario, while we are creating an object using the <code class="literal">new</code> keyword, the created object does not have the properties of the <code class="literal">MyObjDefinition</code> function.</p><p>This<a id="id34" class="indexterm"/> exercise in re-factoring of our code shows how functions can act as function as well as objects in JavaScript, depending on the usage.</p><p>I like the flexibility that JavaScript offers in how objects can be defined, as well as how dynamic properties can be added to objects as needed. However, I can see why some programmers with a background in more classical object oriented languages might find the approach a little confusing.</p><p>My take on the subject is that JavaScript has its own realm and it is best to understand it within its realm, as opposed to trying to see it in the context of classical object oriented languages.</p></div></div><div class="section" title="Object literal notation versus function objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Object literal notation versus function objects</h2></div></div></div><p>While <a id="id35" class="indexterm"/>both object<a id="id36" class="indexterm"/> literal notation and function object<a id="id37" class="indexterm"/> syntax can be used to create objects, there are situations when one approach is better suited than the other.</p><p>In JavaScript, after the script is parsed, all the function declarations in the program are hoisted to the beginning of the script. That is why you can call a function before its actual definition in the code, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var firstPerson = CreatePerson("Tom", "Software Developer");

function CreatePerson(personName, personJob){
  // creating an object instance, using object type
  var person = new Object();
  // we can also use an object literal instead as below
  // var person = {};
  person.name = personName;
  person.job = personJob;

  return person;
}

console.log(firstPerson.name); // displays "Tom" </pre></div><p>In the preceding code, every time <code class="literal">CreatePerson</code> function is called a new object is created, augmented, and then returned. This approach is also known as the <span class="strong"><strong>Object Factory</strong></span> design <a id="id38" class="indexterm"/>pattern.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>
<span class="strong"><strong>Design patterns in JavaScript</strong></span>
</p><p>If you are not familiar with design patterns in general or would like to become more familiar with design patterns in JavaScript, I highly recommend the following resource:</p><p>
<span class="emphasis"><em>Mastering JavaScript Design Patterns</em></span>, <span class="emphasis"><em>Simon Timms</em></span>.</p></div></div><p>Notice <a id="id39" class="indexterm"/>that the call to the <code class="literal">CreatePerson</code> function is taking place before the actual function definition. This code<a id="id40" class="indexterm"/> will not generate an error when<a id="id41" class="indexterm"/> it is run because of function hoisting. Behind the scenes, the function <code class="literal">CreatePerson</code> has been hoisted to the top of the script so when the call is made to this function, the declaration has already been encountered by the interpreter.</p><p>Because of this mechanism, you don't have to worry if the call to the function takes place before the function declaration or not.</p><p>This does not apply to object literals since there are no function declarations and, thus, no hoisting involved. Therefore, all the calls to such objects need to happen AFTER the object definition.</p><p>Consider the following example:</p><div class="informalexample"><pre class="programlisting">var Tom = {
  name: "Tom"
};
Tom.job = "SoftWare Developer";

console.log(Tom.job); // displays "Software Developer"
console.log(Tom.name); //  displays "Tom" </pre></div><p>Here, we are first defining an object, using object literal notation, and then adding a property to it. Everything works fine and as expected.</p><p>However, if we try to add a property to this object before the object definition, as follows:</p><div class="informalexample"><pre class="programlisting">Tom.job = "SoftWare Developer"; // "TypeError: Cannot set property 'job' of undefined"

var Tom = {
  name: "Tom"
};</pre></div><p>We will encounter an error.</p><p>You may also have noticed that, in the case of constructor functions, the <code class="literal">Person</code> function in our example, we can pass arguments to the constructor and create different instances of <code class="literal">Person</code> with different names and different job titles. However, this cannot be done when using object literal notation to create objects.</p><p>As you can tell by now, these different approaches for creating objects are suited for different purposes. Most of the time, we use constructor functions when we need to create multiple instances of an object but use object literal notation to package parameters (data) that need to be passed to different parts of the application.</p><p>Objects <a id="id42" class="indexterm"/>created using <a id="id43" class="indexterm"/>object literal notation are also best <a id="id44" class="indexterm"/>suited for creating modular code, which we will see a whole lot more of later in the upcoming chapters.</p><p>Let's make things a little more interesting and re-factor the preceding code so we can use both approaches to creating objects together.</p><p>Have a look at the following:</p><div class="informalexample"><pre class="programlisting">function CreatePerson(personData){
  var person = {}; // using Object literal
  person.name = personData.Name;
  person.job = personData.Job;

  return person;
}

var personData = {
  Name: "Tom",
  Job: "Software Developer"
};

var firstPerson = new CreatePerson(personData); 

console.log(firstPerson.name); // displays "Tom"</pre></div><p>Here, we are using object literal notation to create a person data object (<code class="literal">personData</code>) and then pass this data object as a package to the <code class="literal">CreatePerson</code> constructor to create our <code class="literal">firstPerson</code> instance.</p><p>In the chapters ahead, we will be using both of these object creation approaches to create our modules.</p></div><div class="section" title="The &quot;this&quot; keyword"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>The "this" keyword</h2></div></div></div><p>You <a id="id45" class="indexterm"/>saw an example of using the <code class="literal">this</code> keyword when<a id="id46" class="indexterm"/> we looked at our static object in this chapter. We will now spend some time on <code class="literal">this</code> to understand what it is and how it can help us write better code.</p><p>The <code class="literal">this</code> keyword is simply a reference to an object. However, that reference can point to different objects at different times, depending on the code execution context.</p><p>To see what that means, let's start by creating a simple constructor function:</p><div class="informalexample"><pre class="programlisting">function Person(){
  this.name = "Tom";
  this.job = "Software Developer";
}</pre></div><p>In the preceding code, the <code class="literal">this</code> keyword has a global context. So inside the <code class="literal">Person</code> function, <code class="literal">this</code> refers to the <code class="literal">window</code> object (if the code is run in a browser). In fact, if we execute the following:</p><div class="informalexample"><pre class="programlisting">Person();</pre></div><p>We have now created two properties for the <code class="literal">window</code> object, called <code class="literal">name</code> and <code class="literal">job</code>. We can prove this by running the following:</p><div class="informalexample"><pre class="programlisting">console.log(window.name); // displays "Tom";
console.log(window.job); // displays "Software Developer";</pre></div><p>Keep in mind that adding properties to the global context (the <code class="literal">window</code> object) is not a good idea and will pollute the global context as well as creating a high possibility of naming collisions. This could result in unexpected behavior in the code and strange bugs that are hard to track.</p><p>But the <code class="literal">this</code> keyword can take a whole new context and reference a totally different object, when used as the following:</p><div class="informalexample"><pre class="programlisting">function CreatePerson(personData){
  this.name = personData.Name;
  this.job = personData.Job;
}

var personOneData = {
  Name: "Tom",
  Job: "Software Developer"
};

var firstPerson = new CreatePerson(personOneData);

console.log(firstPerson.name);// displays "Tom"
console.log(firstPerson.job); // displays "Software Developer" </pre></div><p>Here, we are creating a new person object using our <code class="literal">CreatePerson</code> constructor. By using the <code class="literal">new</code> keyword, an instance of person is created and the variable <code class="literal">firstPerson</code> now holds a reference to this instance. This person instance has its <code class="literal">name</code> property set to <code class="literal">Tom</code> and its <code class="literal">job</code> property to <code class="literal">Software Developer</code>.</p><p>Note that the <code class="literal">this</code> keyword inside this object now refers to the instance.</p><p>Let's create another person object definition as below:</p><div class="informalexample"><pre class="programlisting">var personTwoData = {
  Name: "John",
  Job: "Software Architect"
};</pre></div><p>And use<a id="id47" class="indexterm"/> our constructor function to create an instance<a id="id48" class="indexterm"/> of this second person.</p><p>Once the following code is executed, <code class="literal">this</code> will refer to the instance of this second person.</p><div class="informalexample"><pre class="programlisting">var secondPerson = new CreatePerson(personTwoData); </pre></div><p>We can examine the properties of the second person, as follows:</p><div class="informalexample"><pre class="programlisting">console.log(secondPerson.name); // displays "John";
console.log(secondPerson.job); // displays "Software Architect"  </pre></div><p>Things can get a little more interesting at times and a bit harder to figure out what the context of <code class="literal">this</code> can be in different circumstances.</p><p>Consider the following example:</p><div class="informalexample"><pre class="programlisting">var name = "The window global";

var myOwnObject = {

  name: "my Own Object",

  getName: function(){
    return this.name; 
  }
};</pre></div><p>As you can see in this example, we have defined an object using object literal notation. This object is assigned to the <code class="literal">myOwnObject</code> variable and its <code class="literal">getName</code> method returns the value of the <code class="literal">name</code> property in the object. So, as you might expect, <code class="literal">this</code> in this context refers to the context of <code class="literal">myOwnObject</code>:</p><div class="informalexample"><pre class="programlisting">console.log(myOwnObject.getName()); // displays "my Own Object" </pre></div><p>However, if we make an assignment such as:</p><div class="informalexample"><pre class="programlisting">// displays "The Window global"
console.log((myOwnObject.getName = myOwnObject.getName)()); </pre></div><p>This will produce the result: <span class="strong"><strong>The window global</strong></span>. This result is rather confusing.</p><p>When we make the above assignment, only the function gets assigned from the left side of the expression to the right side of the expression and now <code class="literal">this</code> refers to the global object. Note that, in this scenario, <code class="literal">myOwnObject.getName</code> is just a function and as explained before <code class="literal">this</code> inside a function (not an instance of an object) always refers to the global context, which produces the result, <span class="strong"><strong>The window global</strong></span>, when executed in the browser.</p><p>Let's<a id="id49" class="indexterm"/> consider another object definition and create an<a id="id50" class="indexterm"/> inner function (a <span class="strong"><strong>Closure</strong></span>, which we will talk about shortly) inside this object. The context of <code class="literal">this</code> may not be what you expect in this scenario.</p><div class="informalexample"><pre class="programlisting">var name = "The window global";
var myOwnObject = {

  name: "my Own Object",
  getName: function(){
    return function(){
      return this.name; 
    };
  }
};

console.log(myOwnObject.getName()()); // displays "The window global"</pre></div><p>Since the innermost function is an anonymous function inside another anonymous function, the context of the innermost function is different from the object that is hosting it. Therefore, <code class="literal">this</code> in this context is referencing the global context.</p><p>In order to preserve the context of <code class="literal">myOwnObject</code>, we can create a context in the first inner function and let the innermost function access this context. So we can rewrite our object definition as:</p><div class="informalexample"><pre class="programlisting">var name = "The window global";
var myOwnObject = {

  name: "My Own Object",

  getName: function(){
    var that = this;
    return function(){
      return that.name; 
    };
  }
};

console.log(myOwnObject.getName()()); // displays "My Own Object"</pre></div><p>Using this approach, we create a context inside the first inner function which references our object and then the innermost function can access this context, which is defined in its container (the first anonymous function). This results in the innermost anonymous function accessing the context of <code class="literal">myOwnObject</code> object.</p><p>As shown, it <a id="id51" class="indexterm"/>can be a little challenging to figure out what <a id="id52" class="indexterm"/>context <code class="literal">this</code> refers to at times but with practice and more experience you will become better at it. However, till then, don't take the context of <code class="literal">this</code> for granted and make sure that the context which you think <code class="literal">this</code> refers to is in fact the context that has been set for <code class="literal">this</code> in the code.</p></div><div class="section" title="Closures"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Closures</h2></div></div></div><p>Now<a id="id53" class="indexterm"/> that we have had a brief discussion regarding execution<a id="id54" class="indexterm"/> context as it relates to <code class="literal">this</code>, it is time to talk about Closures. If you don't have a lot of experience with JavaScript, or if you are coming from more classical object oriented languages such as C++, you might find the concept of Closures a bit confusing in the beginning. In this section, I will try to take the mystery out of this concept and explain why Closures can be very useful in our code.</p><p>The main idea behind Closures is about preserving context and (mostly) how an inner function can keep the context of its containing parent.</p><p>Consider the following simple example:</p><div class="informalexample"><pre class="programlisting">function setTestValue(value){

  var firstNum = value || 2;

  return function(secondNum){
    if(firstNum &gt; secondNum){
      return firstNum;
    }else if(firstNum &lt; secondNum){
      return secondNum;
    }else{
      return "=";
    } 
  };
}

var theNumberExaminer = setTestValue(6);
var result = theNumberExaminer(2); 
console.log(result); // displays 6</pre></div><p>As you can see, innermost function <code class="literal">setTestValue</code> takes a number as a parameter and sets it as the starting value to be used for comparison later.</p><p>When this function is executed, it also returns an anonymous function whose reference will be stored in the <code class="literal">theNumberExaminer</code> variable. This anonymous function is then used to compare a value passed to it with the value that was set as the starting value (<code class="literal">firstNum</code>) in the <code class="literal">setTestValue</code> function.</p><p>Note that we only pass one value <code class="literal">(2)</code> to <code class="literal">theNumberExaminer</code> to be compared against the starting number.</p><p>The<a id="id55" class="indexterm"/> question is: how does <code class="literal">theNumberExaminer</code> have access <a id="id56" class="indexterm"/>to the previous value passed to the <code class="literal">setTestValue</code> function?</p><p>Normally, when a function is returned, its execution context is removed and thus all the values related to that function's execution context are destroyed. However, with <span class="strong"><strong>Closures</strong></span>, things work a little differently.</p><p>Here, the inner anonymous function is returned from the <code class="literal">setTestValue</code> function call (<code class="literal">setTestValue(6)</code>) and, with it, the execution context of its parent function. This allows the anonymous function to have access to the value of <code class="literal">firstNum</code>.</p><p>This relationship will hold as long as the inner function (the anonymous function) is not destroyed. The context of the parent object remains in memory because there is still a reference to the inner function.</p><p>The most important point is that Closures allow for inner functions to have access to the execution context of their parent functions (objects) as part of their scope chain. As values in the scope of the outer function change, the inner function can have access to the most recent values.</p><p>One advantage of creating and using Closures can be shown in the following example:</p><div class="informalexample"><pre class="programlisting">function myClosedObject (){
  var privateValue = 5;

  function privateFunc (){
    privateValue *= 2;
    return privateValue ;
  }

  // privileged method 
  this.publicFunc = function(){

    return privateFunc();
  };
} 

var firstObj = new myClosedObject ();
console.log(firstObj.publicFunc()); // displays 10
console.log(firstObj.publicFunc()); // displays 20</pre></div><p>In the preceding code, we first create an instance of <code class="literal">myClosedObject</code> and then we execute the <code class="literal">publicFunc</code> of this instance. This call changes the value of <code class="literal">privateValue</code> from <code class="literal">5</code> to <code class="literal">10</code>.</p><p>When<a id="id57" class="indexterm"/> we call this method one more time, the value of <code class="literal">privateValue</code> will <a id="id58" class="indexterm"/>change to <code class="literal">20</code>. This is because after the first call to <code class="literal">publicFunc</code> the value of <code class="literal">privateValue</code> has been preserved (thanks to the created Closure). The second call to <code class="literal">publicFunc</code>, uses the most up to date value of <code class="literal">privateValue</code> (which is 10) to do its calculation, thus resulting in the value <code class="literal">20</code> being returned.</p></div><div class="section" title="Encapsulation and scoping"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Encapsulation and scoping</h2></div></div></div><p>As you<a id="id59" class="indexterm"/> may know, in JavaScript the idea of encapsulation <a id="id60" class="indexterm"/>is handled a little differently from most classical<a id="id61" class="indexterm"/> object oriented languages, since we really don't have a<a id="id62" class="indexterm"/> formal definition for classes (ECMAScript 6 introduces formal class definition).</p><p>When we create a variable inside a function using the keyword <code class="literal">var</code>, we are creating a <span class="strong"><strong>private</strong></span> variable<a id="id63" class="indexterm"/> inside of that function, thus the scope of the variable is contained within the function. This also means that, if we use the function as a constructor function, such variables are not copied to the instances created using this constructor function.</p><p>Also, JavaScript does not have the concept of block scopes; instead it has function scope, so all the variables declared inside a function are accessible throughout the function block (ECMAScript 6 introduced block scopes).</p><p>Let's consider the following function declaration:</p><div class="informalexample"><pre class="programlisting">function simpleFunc (){
  var firstValue = 1;
  var secondValue = 2;
  this.instanceValue = 100;

  for(var i =0; i&lt;50; i++){
    var thirdValue = firstValue + secondValue + i;
  }

  // displays "The final value of thirdValue is:52" 
  console.log("The final value of thirdValue is:" + thirdValue);
}

simpleFunc();</pre></div><p>As you can see, the <code class="literal">thirdValue</code> variable has been defined within the <code class="literal">for</code> loop block, but we can access it after the end of the <code class="literal">for</code> loop, since in JavaScript the scope of variables is bound to the scope of the container function and not the container block.</p><p>Of course, code external to this function cannot access such variables, as shown:</p><div class="informalexample"><pre class="programlisting">console.log(simpleFunc.firstValue); // displays undefined</pre></div><p>As expected, the above code will produce <code class="literal">undefined</code> in the console.</p><p>We <a id="id64" class="indexterm"/>also cannot get access to <code class="literal">this.instanceValue</code> since<a id="id65" class="indexterm"/> inside a function <code class="literal">this</code> references the window object, as shown:</p><div class="informalexample"><pre class="programlisting">console.log(simpleFunc.instanceValue); // displays undefined</pre></div><p>What happens if we use the preceding function as a constructor function and create an instance of the <code class="literal">simpleFunc</code> object?</p><p>Consider<a id="id66" class="indexterm"/> the following:</p><div class="informalexample"><pre class="programlisting">var testObj = new simpleFunc();
console.log(testObj.firstValue);   // displays undefined
console.log(testObj.instanceValue); // displays 100 </pre></div><p>As you <a id="id67" class="indexterm"/>know, when we define a variable with the <code class="literal">this</code> keyword, it is copied to the instances of the object and hence <code class="literal">testObj</code> has a copy of it and we can access it from the outside code.</p><p>However, if we take this a step further and create a private scope (<span class="strong"><strong>namespace</strong></span>) inside the constructor function, then even the inner functions of the constructor function will not have access to it.</p><p>Consider the following:</p><div class="informalexample"><pre class="programlisting">function simpleFunc(){
  var firstValue = 1;
  (function(){
    var secondValue = 2;
    this.instanceValue = 100;
    console.log(firstValue); // shows 1

  })();

  //console.log(secondValue); //produces an error

}</pre></div><p>The code above shows an immediately invoked anonymous function (also known as <span class="strong"><strong>IIFE</strong></span>) inside our <code class="literal">simpleFunc</code> function, and even though this function has access to the <a id="id68" class="indexterm"/>execution context of its containing function, the containing function (<code class="literal">simpleFunc</code>) cannot access the variables and methods inside this inner function.</p><p>In fact, we have created a private namespace inside our <code class="literal">simpleFunc</code> that is completely hidden from the outside world.</p><p>The same is also true for when we create an instance of <code class="literal">simpleFunc</code> and try to access <code class="literal">this.inastanceValue</code>, since this variable is only accessible from inside the scope of the inner anonymous function.</p><p>This is shown here:</p><div class="informalexample"><pre class="programlisting">var testObj = new simpleFunc();
console.log(testObj.instanceValue); // displays undefined </pre></div><p>As you <a id="id69" class="indexterm"/>can see, while JavaScript may not have the<a id="id70" class="indexterm"/> same form of encapsulation as classical object oriented <a id="id71" class="indexterm"/>languages, we can still create private scopes, and define<a id="id72" class="indexterm"/> variables and methods inside that scope that are not accessible from the outside code.</p><p>We will be re-visiting this concept and its usages a lot more when we design our application modules in future chapters.</p><p>You may also be asking yourself, "What if I want to create a constructor function which provides public methods, so I can access private members of the constructor function using these public methods?"</p><p>Let's consider the following constructor function:</p><div class="informalexample"><pre class="programlisting">function simpleFunc (){
  var privateValue = 1;
  this.readPrivateValue = function(){

    return privateValue;
  }; 
}

var testObj = new simpleFunc();
console.log(testObj.readPrivateValue());// displays 1</pre></div><p>In this constructor, we have created a private member <code class="literal">privateValue</code> that is not accessible from the outside world. However, we have created a public method <code class="literal">this.readPrivateValue</code>, which can be accessed by the external code and can access the value of this private member.</p><p>So here, we have achieved two goals. First, we have kept our private member protected, and second, we have still provided read access to such private member through our public method.</p><p>The <a id="id73" class="indexterm"/>method <code class="literal">this.readPrivateValue</code> can be considered a <span class="strong"><strong>privileged method</strong></span>, which <a id="id74" class="indexterm"/>means this public member has access <a id="id75" class="indexterm"/>to private members of the object.</p></div><div class="section" title="Inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Inheritance</h2></div></div></div><p>If you <a id="id76" class="indexterm"/>have a background in classical object oriented <a id="id77" class="indexterm"/>languages such as C++, C#, or Java, you will be quite familiar with the concept of inheritance. In such languages, there are two types of inheritance: <span class="strong"><strong>interface inheritance</strong></span> and <span class="strong"><strong>implementation inheritance</strong></span>.</p><p>JavaScript <a id="id78" class="indexterm"/>however, only supports implementation inheritance, as<a id="id79" class="indexterm"/> there is no concept of function signature which is required for interface inheritance.</p><p>There are various ways of implanting inheritance in JavaScript and they all have their pros and cons. In this section, I will cover a few ways of implementing such relationship among objects and will briefly explain the advantages and disadvantages of each approach.</p><div class="section" title="Prototype chaining"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Prototype chaining</h3></div></div></div><p>Let's<a id="id80" class="indexterm"/> start by creating two different constructor functions <a id="id81" class="indexterm"/>and an inheritance relationship between them.</p><p>Consider the following two function objects:</p><div class="informalexample"><pre class="programlisting">function BaseType (){
  this.baseValue = 2;
}

BaseType.prototype.getBaseValue = function(){
  return this.baseValue;
};

function ChildType (){
  this.childTypeValue = 50;
}
// creating inheritance relationship
ChildType.prototype = new BaseType();

ChildType.prototype.getChildTypeValue = function(){
  return this.childTypeValue;
};

var childInstance = new ChildType();

console.log(childInstance.getBaseValue()); // displays 2
console.log(childInstance.getChildTypeValue()); // displays 50</pre></div><p>In the <a id="id82" class="indexterm"/>preceding code, we have created two extremely <a id="id83" class="indexterm"/>simple constructor functions. As you can see, we have defined a simple property for each one of them which are methods related to each object. However, we have created these simple methods as properties of the <code class="literal">prototype</code> object for each function as opposed to directly creating them on the constructor functions.</p><p>If you are familiar with the <code class="literal">prototype</code> property, you know that every function has this property by default. The value of this property is an object that is shared with all the instances that are created using the constructor function.</p><p>The advantage of creating methods (properties) on <code class="literal">prototype</code> object as opposed to on the constructor function itself is that by doing so, all the instances that are created using the constructor share these methods. Therefore, these instances do not have to have their own copy of these properties, thus optimizing our code's performance and memory usage.</p><p>In the preceding code, in the case of <code class="literal">BaseType</code>, we simply augmented the <code class="literal">prototype</code> object of this constructor with a method called <code class="literal">getBaseValue</code>, but for <code class="literal">ChildType</code>, we did something a little different.</p><p>We first created an instance of <code class="literal">BaseType</code> and then we assigned it to <code class="literal">ChildType</code> using the following expression:</p><div class="informalexample"><pre class="programlisting">ChildType.prototype = new BaseType(); </pre></div><p>After the above assignment, the <code class="literal">ChildType.prototype</code> value becomes an instance of <code class="literal">BaseType</code>. This means that this <code class="literal">prototype</code> object has access to two properties now, <code class="literal">baseValue</code> and <code class="literal">getBaseValue</code>.</p><p>The end result is that there are two properties that instances of <code class="literal">ChildType</code> have access to but didn't need to create them.</p><p>When we run the following line of code:</p><div class="informalexample"><pre class="programlisting">console.log(childInstance.getBaseValue()); //displays 2</pre></div><p>The <code class="literal">childInstance</code> variable can return the value of the <code class="literal">baseValue</code> variable, using <code class="literal">getBaseValue</code> method.</p><p>Of course, <code class="literal">childInstance</code> also has access to its own variable <code class="literal">childTypeValue</code>. If we run the following code, <code class="literal">50</code> will be displayed.</p><div class="informalexample"><pre class="programlisting">console.log(childInstance.getChildTypeValue()); // displays 50</pre></div><div class="section" title="Property look up in prototype chaining"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec01"/>Property look up in prototype chaining</h4></div></div></div><p>Let's<a id="id84" class="indexterm"/> examine how <code class="literal">ChildInstance</code> gets access to the properties of <code class="literal">BaseType</code> in a little more depth.</p><p>When we try to access a property on <code class="literal">ChildInstance</code>, behind the scenes, a search is conducted on the instance itself to see if that property is available. If the property is not found, then the search continues to the <code class="literal">prototype</code> object of the <code class="literal">ChildInstance</code> object. Since an instance of <code class="literal">BaseType</code> is the value of the <code class="literal">prototype</code> object belonging to <code class="literal">ChildInstance</code>, the search is continued in <code class="literal">BaseType</code>.</p><p>But there is more, the instance of <code class="literal">BaseType</code> (which is the value of the <code class="literal">prototype</code> object belonging to <code class="literal">ChildType</code>) itself has a <code class="literal">prototype</code> object and our <code class="literal">ChildType</code> prototype has a link to this <code class="literal">prototype</code> object. That prototype object has a property called <code class="literal">getBaseValue</code>. Since this method has access to the <code class="literal">BaseType</code> properties, it can return the value of <code class="literal">baseValue</code>.</p><p>You can think of how this lookup is conducted as shown here:</p><div class="mediaobject"><img src="graphics/B04910_02_01.jpg" alt="Property look up in prototype chaining"/></div><p>As you can see, there is quite a bit of searching taking place in order to find the instance property. Also, keep in mind that if the property was not found in the <code class="literal">prototype</code> of <code class="literal">BaseType</code>, the search would have continued to the <code class="literal">prototype</code> object of the parent of all objects in JavaScript, the <code class="literal">Object</code> type. Let's talk about how that works.</p><p>Remember that every function has a <code class="literal">prototype</code> property which its value is an object. This <code class="literal">prototype</code> object itself has a <code class="literal">prototype</code> property which its value is the <code class="literal">prototype</code> object of the <code class="literal">Object</code> type.</p><p>That is why, when we call the <code class="literal">BaseType.toString</code> method, even though we have not defined this method on <code class="literal">BaseType</code> or its <code class="literal">prototype</code> object, the call still succeeds and produces the string value of the object. The <code class="literal">toString</code> method is defined on the <code class="literal">prototype</code> object of <code class="literal">Object</code> type, and thus is available to all the children of <code class="literal">Object</code> type.</p><p>It is very important to keep in mind that the search is ceased and will not continue any further in the chain of <code class="literal">protoypes</code>, as soon as the property that the search is being conducted for is found.</p><p>To<a id="id85" class="indexterm"/> make it a little more clear, let's modify our <code class="literal">ChildType</code> to have a property (method) called <code class="literal">getBaseValue</code>. Doing so will <a id="id86" class="indexterm"/>result in what is known as <span class="strong"><strong>shadowing</strong></span> (or masking) of this property on <code class="literal">BaseType</code>.</p><p>So, if we modify the code for <code class="literal">ChildType</code> as below:</p><div class="informalexample"><pre class="programlisting">function ChildType (){
  this.childTypeValue = 50;
}
// creating inheritance relationship
ChildType.prototype = new BaseType();

ChildType.prototype.getChildTypeValue = function(){
  return this.childTypeValue;
};
ChildType.prototype.getBaseValue = function(){
  return this.childTypeValue;
};
var childInstance = new ChildType();
console.log(childInstance.getBaseValue()); // displays 50 </pre></div><p>The call to <code class="literal">childInstance.getBaseValue</code> will now return the value <code class="literal">50</code> instead of <code class="literal">2</code>. This is because as soon as the search for the <code class="literal">getBaseValue</code> method (property) finds this method on <code class="literal">ChildType</code>, it will not search any further and will execute this method. This of course, will return the value of the <code class="literal">childTypeValue</code> property.</p><p>One other thing that we need to keep in mind, is the fact that because of the relationship that has been created among all these reference types, the following instance check will return <code class="literal">true</code> for all of them.</p><div class="informalexample"><pre class="programlisting">console.log(childInstance instanceof Object);    // displays true
console.log(childInstance instanceof BaseType);  // displays true
console.log(childInstance instanceof ChildType); // displays true </pre></div><p>You can use this test to see if one reference type is inheriting properties from another reference type.</p><p>While prototype chaining has many advantages and allows us to create inheritance among our base objects and our child objects, it has the disadvantage that any changes to the base object's reference type properties are reflected in all the instances of the child classes. This at times may not be a desirable effect and you need to be aware of it.</p></div><div class="section" title="Resetting the constructor property"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec02"/>Resetting the constructor property</h4></div></div></div><p>Every <code class="literal">prototype</code> object has a <code class="literal">constructor</code> property. This property always refers back to the <a id="id87" class="indexterm"/>constructor function itself. When we overwrite the <code class="literal">prototype</code> property completely as we did in the previous code by setting it like so:</p><div class="informalexample"><pre class="programlisting">ChildType.prototype = new BaseType();</pre></div><p>The <code class="literal">constructor</code> property of the <code class="literal">prototype</code> object will be referencing the parent object. This can be examined as below:</p><div class="informalexample"><pre class="programlisting">console.log(childInstance.constructor);</pre></div><p>Which displays:</p><div class="informalexample"><pre class="programlisting">function BaseType(){
  this.baseValue = 2;
}</pre></div><p>It is always a good idea to reset the <code class="literal">constructor</code> property of the <code class="literal">prototype</code> object after it has been completely replaced, as follows:</p><div class="informalexample"><pre class="programlisting">ChildType.prototype.constructor = ChildType;</pre></div><p>This is so the <code class="literal">prototype</code> object can correctly point back to the correct constructor object.</p><p>The reset enables us to correctly find the constructor object of the instance as shown:</p><div class="informalexample"><pre class="programlisting">console.log(childInstance.constructor);</pre></div><p>Which now correctly reports the following:</p><div class="informalexample"><pre class="programlisting">function ChildType(){
  this.childTypeValue = 50;
}</pre></div><p>We will discuss the <code class="literal">constructor</code> property some more, later in this chapter.</p></div></div><div class="section" title="Constructor stealing"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Constructor stealing</h3></div></div></div><p>Another<a id="id88" class="indexterm"/> approach to creating inheritance in JavaScript is <a id="id89" class="indexterm"/>using a technique known as <span class="strong"><strong>constructor stealing</strong></span>, which is similar to classical inheritance in other object oriented languages.</p><p>Consider the following:</p><div class="informalexample"><pre class="programlisting">function BaseType(){
  this.baseValue = 2;
}
function ChildType(){
  BaseType.call(this);
}
ChildType.prototype.getBaseTypeValue = function(){
  return this.baseValue;
};
var instanceObj = new ChildType();

console.log(instanceObj.getBaseTypeValue());  // displays 2</pre></div><p>In the above code, we are using the <code class="literal">call</code> method to execute <code class="literal">BaseType</code> in the context of <code class="literal">ChildType</code>. This results in <code class="literal">ChildType</code> instances getting a copy of all the properties of <code class="literal">BaseType</code>. Since each instance of <code class="literal">ChildType</code> now has its own copy of the properties, modifying the properties of <code class="literal">BaseType</code> is not reflected in the child instances.</p><p>This <a id="id90" class="indexterm"/>approach, however, has its own issues. The main issue<a id="id91" class="indexterm"/> is that since we are not assigning an instance of <code class="literal">BaseType</code> to the <code class="literal">prototype</code> object of <code class="literal">ChildType</code>, the properties defined on the <code class="literal">prototype</code> object of <code class="literal">BaseType</code> are not shared among the instances of <code class="literal">ChildType</code>. This will no result in the most efficient approach in implementing inheritance and does not allow for code sharing of the parent's <code class="literal">prototype</code> object properties among child instances.</p></div><div class="section" title="Parasitic combination inheritance"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Parasitic combination inheritance</h3></div></div></div><p>Another<a id="id92" class="indexterm"/> way to create inheritance relationships among reference types is to use a combination of the techniques that we have already discussed, while eliminating their inefficiencies. This is also my favorite technique for creating inheritance.</p><p>Let's modify the code that we have already seen, so we can implement this approach:</p><div class="informalexample"><pre class="programlisting">function BaseType (){

  this.baseValue = 2;
  this.secondBaseValue = 99;
}

BaseType.prototype.getBaseValue = function(){
  return this.baseValue;
};

function ChildType (){
  BaseType.call(this);
  this.childTypeValue = 50;
}

// creating inheritance relationship
ChildType.prototype = BaseType.prototype;

ChildType.prototype.getChildTypeValue = function(){
  return this.childTypeValue;
};

var childInstance1 = new ChildType();
var childInstance2 = new ChildType();
childInstance1.baseValue = 100;
childInstance2.baseValue = 55;

console.log(childInstance1.getBaseValue()); //displays 100 
console.log(childInstance1.getChildTypeValue()); //displays 50
console.log(childInstance1.secondBaseValue); //displays 99

console.log(childInstance2.getBaseValue()); //displays 55 
console.log(childInstance2.getChildTypeValue()); //displays 50
console.log(childInstance2.secondBaseValue); // displays 99 </pre></div><p>In this <a id="id93" class="indexterm"/>latest implementation, we are using the <code class="literal">call</code> method in the <code class="literal">ChildType</code> constructor to copy all the properties of <code class="literal">BaseType</code>. This provides the child object instance with the ability to modify the properties of <code class="literal">BaseType</code>, which only affects that particular instance of <code class="literal">ChildType</code> and does not get reflected in other instances of <code class="literal">ChildType</code>.</p><p>In our example, this type of inheritance is initiated in the following statement in the <code class="literal">ChildType</code> constructor:</p><div class="informalexample"><pre class="programlisting">BaseType.call(this); </pre></div><p>We also have assigned the <code class="literal">prototype</code> of <code class="literal">BaseType</code> to <code class="literal">ChildType</code>, as shown:</p><div class="informalexample"><pre class="programlisting">ChildType.prototype = BaseType.prototype;</pre></div><p>Note that we have assigned only the <code class="literal">prototype</code> object of <code class="literal">BaseType</code> to the <code class="literal">prototype</code> object of <code class="literal">ChildType</code>, thus eliminating the second call to the <code class="literal">BaseType</code> constructor, resulting in more efficient code.</p><p>This approach also has the advantage of allowing us to share all the properties that have been defined on the <code class="literal">prototype</code> object of <code class="literal">BaseType</code> among all the instances of the child object. Therefore, not every child object instance will have its own copy of such properties, which in turn leads to better code efficiency and memory management.</p><p>Once we create an instance of <code class="literal">ChildType</code>, this instance has access to copied properties from <code class="literal">BaseType</code> as well as all the shared properties defined on the <code class="literal">prototype</code> object of <code class="literal">BaseType</code>. Of course, each instance also has access to all of its own properties defined on the <code class="literal">ChildType</code> constructor and on the <code class="literal">ChildType</code> prototype object.</p><a id="id94" class="indexterm"/><p>
<span class="strong"><strong>Parasitic combination inheritance</strong></span> provides <a id="id95" class="indexterm"/>us<a id="id96" class="indexterm"/> with the best of both previously discussed techniques (<span class="strong"><strong>prototype chaining</strong></span> and <span class="strong"><strong>constructor stealing</strong></span>) and it is widely used by many experienced JavaScript developers.</p></div></div><div class="section" title="Constructor property"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Constructor property</h2></div></div></div><p>Every <a id="id97" class="indexterm"/>object in JavaScript has a <code class="literal">constructor</code> property that references the constructor object that was used to create the instance of<a id="id98" class="indexterm"/> that object.</p><p>For instance, in all functions, the <code class="literal">constructor</code> property has a reference to the <code class="literal">Function</code> type constructor. We could verify this by executing the following statement:</p><div class="informalexample"><pre class="programlisting">console.log(ChildType.constructor); // references Function type constructor </pre></div><p>Since <code class="literal">prototype</code> property's value is an object too, it also has a <code class="literal">constructor</code> property. However, this <code class="literal">constructor</code> property references the object (function) itself. So if we examine this property <span class="strong"><strong>before</strong></span> we assign the <code class="literal">BaseType.prototype</code> object to <code class="literal">ChildType.prototype</code>, as follows:</p><div class="informalexample"><pre class="programlisting">console.log(ChildType.prototype.constructor); // 
  references ChildType </pre></div><p>We can see that this property is referencing the object that <code class="literal">prototype</code> belongs to, which in this case is <code class="literal">ChildType</code>.</p><p>As mentioned previously, if we completely replace the <code class="literal">prototype</code> object , as in the case of the following statement, which was used in implementing our previous inheritance:</p><div class="informalexample"><pre class="programlisting">ChildType.prototype = BaseType.prototype; </pre></div><p>We overwrite the value of the <code class="literal">constructor</code> property on the <code class="literal">prototype</code> object of <code class="literal">Childtype</code>.</p><p>If we examine the <code class="literal">constructor</code> property of the <code class="literal">prototype</code> object now, it will be referencing <code class="literal">BaseType</code>, instead of <code class="literal">Childtype</code>.</p><div class="informalexample"><pre class="programlisting">console.log(ChildType.prototype.constructor) // references BaseType </pre></div><p>As seen before, we need to reset the <code class="literal">constructor</code> property of the <code class="literal">prototype</code> object as shown:</p><div class="informalexample"><pre class="programlisting">ChildType.prototype.constructor = ChildType; </pre></div><p>Keep in mind that resetting the <code class="literal">constructor</code> property needs to happen after the <code class="literal">prototype</code> object has been re-written and not before. Otherwise, the re-write will completely remove the <code class="literal">constructor</code> property.</p><p>The following is an example of how this should be done:</p><div class="informalexample"><pre class="programlisting">ChildType.prototype = BaseType.prototype;
ChildType.prototype.constructor = ChildType; </pre></div><p>I encourage you to examine all the code discussed in this section closely to understand how all the pieces are tied together and how inheritance works among objects.</p></div><div class="section" title="Native support for inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Native support for inheritance</h2></div></div></div><p>Now<a id="id99" class="indexterm"/> that we have had a look at different techniques for creating inheritance among constructor functions, it is a good idea to consider native support for creating such relationships in JavaScript.</p><p>ECMAScript 5 <a id="id100" class="indexterm"/>provides <span class="strong"><strong>prototypal inheritance</strong></span> by way of <code class="literal">Object.create()</code> method.</p><p>This method accepts two parameters. The first parameter is the object to be used as the <code class="literal">prototype</code> (base object) for the new object. The second parameter is optional and is used to add additional properties to the new object.</p><p>Consider the following code:</p><div class="informalexample"><pre class="programlisting">var BaseType = {
  firstValue: 20,
  secondValue: [3,4]
};
var ChildType1 = Object.create(BaseType);

ChildType1.secondValue.push(5);

ChildType1.getBaseTypeFirstValue = function(){
  return this.firstValue ;
};

var ChildType2 = Object.create(BaseType);
ChildType2.newProperty = 50; 

console.log(ChildType1.getBaseTypeFirstValue()); // displays 20
console.log(ChildType1.secondValue); // displays [3, 4, 5]

console.log(ChildType2.secondValue); // displays [3, 4, 5]
console.log(BaseType.secondValue); // displays [3, 4, 5] </pre></div><p>There are some interesting points that you need to keep in mind regarding the preceding code. As you can see, we have used the <code class="literal">BaseType</code> constructor and have passed it to the <code class="literal">Object.create</code> method to create an instance of our <code class="literal">BaseType</code> object and assign it to the <code class="literal">ChildType1</code> variable.</p><p>We then have added a new value to the property <code class="literal">secondValue</code> array of this new object (<code class="literal">ChildType1</code>). In the next line, we have also added a new method, <code class="literal">getBaseTypeFirstValue</code> to this instance.</p><p>When we create a second object <code class="literal">ChildType2</code> using the method <code class="literal">Object.create</code>, and examine the value of the <code class="literal">secondValue</code> array, we see that the value is as shown below:</p><div class="informalexample"><pre class="programlisting">console.log(ChildType2.secondValue); // displays [3, 4, 5]</pre></div><p>This is because the modified property <code class="literal">secondValue</code> is shared among all the instances that have inheritance relationships with the base object <code class="literal">BaseType</code>. Thus, all the changes done to the properties of the base object by one child instance are reflected in all the instances, as well as in the base object, <code class="literal">BaseType</code> itself. This is shown here:</p><div class="informalexample"><pre class="programlisting">console.log(BaseType.secondValue); // displays [3, 4, 5]</pre></div><p>This is an important point to keep in mind.</p><p>As previously mentioned, we could also use the second optional parameter of the <code class="literal">Object.create</code> method to add new properties to the child instance at the same time that we create the inheritance relationship between the base and the child object.</p><p>Consider the following:</p><div class="informalexample"><pre class="programlisting">var BaseType = {
  firstValue: 20,
  secondValue: [3,4]
};
var ChildType = Object.create(BaseType, {
  optionalObject:{
    value: 50
  }
});

console.log(ChildType.optionalObject); // displays 50
console.log(ChildType.firstValue); // displays 20 </pre></div><p>The <code class="literal">ChildType</code> object has now inherited all the properties of the <code class="literal">BaseType</code> object and has a new property <code class="literal">optionalObject</code>, which is specific to this instance of the child object.</p><p>Even<a id="id101" class="indexterm"/> though this is a native way for creating inheritance among objects in ECMAScript 5, I have found this technique to not be as popular as parasitic combination inheritance.</p><p>I personally find this approach to be a little too verbose in comparison to the other approaches that we covered in this chapter for implementing inheritance but it allows us to define attributes of the new property exactly as we like.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>You<a id="id102" class="indexterm"/> can refer to the following online resource for more information regarding the <code class="literal">Object.create</code> method:</p><p>
<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a>
</p></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>The goal of this chapter was to provide a quick overview of some OOP concepts in JavaScript. Having a good understanding of these concepts is important as we will be using them in implementing our modular architecture in the following chapters.</p><p>In this chapter, we looked at various ways of creating objects as well as concepts such as closure, encapsulation, and inheritance.</p><p>The assumption that I made was that you likely have a fairly good experience with JavaScript and are probably familiar with at least some of these concepts.</p><p>My intent was to provide "just enough" of a review of JavaScript OOP concepts to get you ready for future chapters.</p><p>There are many good resources available that can help you extend your knowledge of Object Oriented JavaScript principles further.</p><p>Two of my personal favorites on this topic are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Object-Oriented JavaScript</em></span>, <span class="emphasis"><em>Stoyan Stefanov</em></span>, <span class="emphasis"><em>Kumar Chetan Sharma</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Professional JavaScript for Web Developers</em></span>, <span class="emphasis"><em>Nicholas C. Zakas</em></span></li></ul></div><p>In the next chapter, we will start focusing on a popular design pattern known as <span class="strong"><strong>Module Design Pattern</strong></span> to get us ready for creating simple modules in our application.</p></div></body></html>