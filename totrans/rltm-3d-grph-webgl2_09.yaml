- en: Putting It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered framebuffers, renderbuffers, and the steps
    required to interact with a 3D application using picking. In this chapter, we
    will bring together all of the concepts we've learned so far to build a 3D virtual
    car showroom. In the development of this demo application, we will use models,
    lights, cameras, animation, colors, textures, and more. We will also learn how
    to integrate these elements with a simple yet effective graphical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Put together all of the architecture we've developed throughout this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a 3D virtual car showroom application using our architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import car models from Blender into a WebGL scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up several light sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create robust shaders to handle multiple materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the OBJ and MTL file formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program the camera to fly through the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a WebGL Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we've covered the basic topics required to create a WebGL application.
    These topics have been implemented in the framework that we've iteratively built
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml), *Getting Started*,
    we introduced WebGL and learned how to use it in our browser. We learned that
    the WebGL context behaves as a state machine. As a result, we can query the different
    state variables using `gl.getParameter`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we studied how objects in a WebGL scene are defined by vertices. We saw
    how we can use indices to label vertices so that the WebGL rendering pipeline
    can quickly rasterize to render an object. We studied the functions that manipulate
    buffers and the two main functions to render primitives: `drawArrays` (no indices)
    and `drawElements` (with indices). We learned about using JSON to represent geometries
    and how we can download models from a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we studied how to illuminate our 3D scene. We learned about normal vectors,
    the physics of light reflection, and the 3D math required to implement illumination.
    We also learned how to implement different lighting models using shaders in ESSL.
  prefs: []
  type: TYPE_NORMAL
- en: Then*, *we implemented our own custom cameras since WebGL does not have cameras.
    We studied the Camera matrix and demonstrated how it's actually the inverse of
    the Model-View matrix. In other words, rotation, translation, and scaling in world
    space produces the inverse operations in camera space.
  prefs: []
  type: TYPE_NORMAL
- en: Following cameras and matrices, we covered the basics of animation. We discussed
    useful techniques for animations, such as the matrix stack with `push` and `pop`
    operations to represent local and global transformations, and we analyzed how
    to establish an animation cycle that is independent of the rendering cycle. Our
    animations covered different types of interpolation techniques, with examples
    showcasing various animation styles.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we investigated color representation with WebGL and how we can use colors
    in objects, lights, and the overall scene. In doing so, we also studied blending
    and the creation of translucent and transparent effects. After colors and blending,
    we covered textures for adding more detail to our scene. Then, we saw how users
    can interact with our 3D application with picking.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will leverage all of these concepts to create an impressive
    3D application. Reasonably enough, we will use all of the components we have developed
    so far. Let's quickly review them.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following components are present in the architecture that has been built
    throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Axis.js`: Auxiliary object that represents the center of the scene with visual
    helpers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Camera.js`: Contains a camera representation from the two types of camera
    we have developed: orbiting and tracking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clock.js`: A requestAnimationFrame-based timer to synchronize our entire application
    from a single source of truth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Controls.js`: Listens for mouse and keyboard events on the HTML5 `canvas`.
    It interprets these events and then transforms them into camera actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventEmitter.js`: A simple class that provides a pub-sub approach for managing
    interactions between components in our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Floor.js`: Auxiliary object that appears like a rectangular mesh and provides
    the floor reference for the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Light.js`: Simplifies the creation and managing of lights in the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Picker.js`: Provides color-based object picking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program.js`: Composes the functions that handle programs, shaders, and the
    mapping between JavaScript values and ESSL uniforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scene.js`: Contains a list of objects to be rendered by WebGL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Texture.js`: A class for the creation and managing of WebGL textures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Transforms.js`: Contains the matrices discussed in this book, that is, the
    Model-View matrix, the Camera matrix, the uProjectionMatrix, and the Normal matrix.
    It implements the matrix stack with the `push` and `pop` operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`utils.js`: Contains auxiliary functions, such as `getGLContext`, which helps
    create a WebGL context for a given HTML5 `canvas`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application hook functions, which are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init`: This function initializes the application and is only called when the
    document has loaded via `window.onload = init;`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configure`: This function creates and configures dependencies, such as the
    program, cameras, lights, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load`: This function requests objects from the web server by calling `scene.load`.
    We can also add locally generated geometry (such as the `Floor`) by calling `scene.add`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw`: This function is called when the rendering timer goes off. Here, we
    retrieve objects from the `scene` and render them appropriately by ensuring their
    location (for example, applying local transforms using the matrix stack) and their
    properties (for example, passing the respective uniforms to the `program`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's bring all of these concepts together and create a 3D virtual car
    showroom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: 3D Virtual Car Showroom'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Leveraging the WebGL skills and infrastructure code we have developed thus
    far, we will create an application that visualizes different 3D car models. The
    final result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6108a8ab-27d9-45e3-b67c-6825b27431f7.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we'll start by defining the **graphical user interface (GUI**) of our
    application. Then, we'll add WebGL support by creating a `canvas` element and
    obtaining a WebGL context. After obtaining a valid WebGL context, we will define
    and implement the vertex and fragment shader using ESSL. Then, we will implement
    the three functions that hook into the life cycle of our application: `configure`, `load`,
    and `draw`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started, let's consider some of the fundamentals of our virtual
    showroom application.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity of the Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-world applications are, generally, much more complex than PoC (proof of
    concept) demos. This is especially true with 3D applications, since 3D assets,
    such as models, are much more complex than simple spheres, cones, and other primitive
    geometric figures. Models in large 3D applications tend to have lots of vertices
    with complicated configurations that provide the level of detail and realism users
    expect. Apart from the pure geometrical representation of these models, they often
    come with several textures. As expected, creating geometries and textures *manually* with
    JSON files is nothing short of daunting.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can use various industry proved 3D design software to create
    and import models into a WebGL scene. For our 3D virtual car showroom, we will
    use models that have been created with **Blender**, a widely used, open source
    3D tool.
  prefs: []
  type: TYPE_NORMAL
- en: Blender
  prefs: []
  type: TYPE_NORMAL
- en: Blender is an open source 3D computer graphics software that allows you to create
    animations, games, and other interactive applications. Blender provides numerous
    features so that you can create complex models. You can check out the official
    Blender website for more information: [https://www.blender.org](https://www.blender.org/).
  prefs: []
  type: TYPE_NORMAL
- en: We will use Blender to import car models into our WebGL scene. First, we will
    export the models to an intermediary file format called **OBJ** and then parse
    them into consumable JSON files. We will cover more on these concepts later.
  prefs: []
  type: TYPE_NORMAL
- en: Shader Quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will be using complex models, such as cars, we'll need to develop shaders
    that can render the different materials of our models. This should be relatively
    simple, since the shaders we've developed already handle diffuse, specular, and
    ambient components for materials. In Blender, we will select the option to export
    materials when generating the OBJ files. Blender will then generate a second file
    known as the **Material Template Library** (**MTL**). For the best results, our
    shaders will use Phong shading and Phong lighting, with support for multiple lights.
  prefs: []
  type: TYPE_NORMAL
- en: Network Delays and Bandwidth Consumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to WebGL applications with large 3D assets, we generally download
    geometries and textures from a web server. As expected, this can take some time
    depending on the quality of the network connection and the amount of data that
    needs to be transferred. There are, however, several strategies for optimizing
    this process, such as compression and 3D asset optimizations, which will be covered
    in a later chapter. We will use AJAX to provide users with a great user experience
    by downloading these large assets in the background.
  prefs: []
  type: TYPE_NORMAL
- en: With these considerations in mind, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Designing Our GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will define a very simple layout for our application. First, we will define
    our HTML document and include all of the necessary dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''ve included the following libraries that are required for
    our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`normalize.css`: A set of styles that makes browsers render all elements more
    consistently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dat.gui.js`: A lightweight graphical user interface for changing variables
    in JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl-matrix.js`: A JavaScript matrix and vector library for high performance
    applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've included the required libraries, we will include the various
    components we've covered throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Adding canvas Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the shell for our application, let''s add the `canvas` that''s
    required for our WebGL application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `canvas` element with the `webgl-canvas` ID goes between the `body` of our
    HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Shader Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s include the two shaders that we''ll need for our application by
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These `scripts` are placed inside the `head` of our document.
  prefs: []
  type: TYPE_NORMAL
- en: Adding WebGL Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the basic boilerplate for our application, let''s initialize
    our WebGL application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This `script` tag goes after the shader scripts to ensure that we can reference
    them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cover this code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define the various global variables that we''ll be setting and using
    throughout the application. As in all of our previous exercises, we need to define
    the entry point for the application. We do this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init` function is called once our document has loaded via `window.onload`.
    In the `init` function, we set up our application by calling `configure` and using
    the `clock` instance to call `draw` on every `tick`—that is, every `requestAnimationFrame`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize and set our `canvas` with the ID of `webgl-canvas`. Then, we
    pass the `canvas` instance to our utility function for full screen and auto resizing
    capabilities. This function is useful because it automatically updates the size
    of the `canvas` to the available window space without hardcoding the size of the
    `canvas`. Then, we initialize `gl`, `scene`, `clock`, and `program` using the
    provided shaders. Finally, we set the `gl` context with the basic configurations,
    such as a clear color, depth testing, and blending functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `draw` function is simple, as it simply sets the viewport and clears the
    `canvas`. You can find this source code inside the `ch09_scaffolding.html` file
    for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run `ch09_scaffolding.html` in your browser, you will see that
    the `canvas` resizes according to the size of the browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/051f60b1-b25d-42d8-b850-5006343b2158.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our shaders, we will implement **Phong shading** and the **Phong reflection** model.
    Remember that Phong shading interpolates vertex normals and creates a normal for
    every fragment–the processing happens in the fragment shader. The Phong reflection
    model describes illumination as the addition of ambient, diffuse, and specular
    interaction of the object with the light sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be consistent with the Material Template Library (MTL) format, we’ll follow
    some typical conventions to set out uniform names that refer to material properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Material** **Uniform** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `uKa` | Ambient property. |'
  prefs: []
  type: TYPE_TB
- en: '| `uKd` | Diffuse property. |'
  prefs: []
  type: TYPE_TB
- en: '| `uKs` | Specular property. |'
  prefs: []
  type: TYPE_TB
- en: '| `uNi` | Optical density. We will not use this feature, but you will see it
    in the MTL file. |'
  prefs: []
  type: TYPE_TB
- en: '| `uNs` | Specular exponent. A high exponent results in a tight, concentrated
    highlight. `Ns` values normally range from `0` to `1000`. |'
  prefs: []
  type: TYPE_TB
- en: '| `uD` | Transparency (alpha channel). |'
  prefs: []
  type: TYPE_TB
- en: '| `uIllum` | Determines the illumination model for the object being rendered.
    Unlike previous chapters where we had one model for all objects, we let objects
    describe their reflective properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the MTL file format specification, **illum** can be any of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Color on and Ambient off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color on and Ambient on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlight on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection on and Ray trace on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transparency: Glass on, Reflection: Ray trace on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reflection: Fresnel on and Ray trace on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transparency: Refraction on, Reflection: Fresnel off and Ray trace on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transparency: Refraction on, Reflection: Fresnel on and Ray trace on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection on and Ray trace off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transparency: Glass on, Reflection: Ray trace off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casts shadows onto invisible surfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Wavefro**nt .obj** file**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on OBJ and MTL file specifications, please refer to the
    following link: [https://en.wikipedia.org/wiki/Wavefront_.obj_file](https://en.wikipedia.org/wiki/Wavefront_.obj_file).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our shaders will also support multiple lights by using uniform arrays, as described
    in earlier chapters. The number of lights is defined by a constant in both the
    vertex and fragment shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the following uniform arrays to work with lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Light ****Uniform Array** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `uLa[numLights]` | Ambient property. |'
  prefs: []
  type: TYPE_TB
- en: '| `uLd[numLights]` | Diffuse property. |'
  prefs: []
  type: TYPE_TB
- en: '| `uLs[numLights]` | Specular property. |'
  prefs: []
  type: TYPE_TB
- en: '**Source code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to `ch09_02_showroom.html` if you wish to explore the source code
    for the shaders in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the corresponding fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the vertex and fragment shaders borrow concepts from earlier chapters
    covered in this book, except for `uIllum`. As described earlier, the `illum` property
    determines the illumination model for the object being rendered. We could default
    to a simpler fragment shader (such as `uIllum == 2`), but a simple example has
    been provided for educational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will configure the three main functions that hook into the life cycle
    of our WebGL application. These are the `configure`, `load`, and `render` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can set up the scene by defining some global variables for our application
    and writing the code for the `configure` function. Let''s analyze this line by
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, we want to set some of the WebGL properties, such as the clear
    color and the depth test. Then, we need to create a camera and set its initial
    position and orientation. We also need to create a camera controls instance so
    that we can update the position of the camera during scene interactions. Finally,
    we need to define the JavaScript variables that will be mapped to the shaders.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish these tasks, we will use `Camera.js`, `Controls.js`, `Program.js`,
    and `Transforms.js` from our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring WebGL Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to initialize and configure our `canvas` and `gl` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to initialize `scene`, `clock`, and `program`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These core components are defined globally so that we can reference them throughout
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to set the background color and the depth test properties,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To keep things simple, the `camera` variable will be global so that we can
    access it from the GUI controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Camera Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to instantiate a `Controls` instance that will bind mouse gestures
    to `camera` actions. The first argument is the `camera` we are controlling, and
    the second argument is a reference to our `canvas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Scene Transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have a `camera`, we can use it to create a new `Tranforms` instance,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `transforms` variable is also declared globally, so we can use it in the
    `draw` function to retrieve the current matrix transformations and pass them to
    the shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create four lights by using the `Light` class from our framework with
    the following configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4c541c3-f8d5-47eb-ab5e-bfbf38bb8078.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we instantiate a `LightsManager` instance to manage our lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create four light positions for each light and iterate over each position
    to uniquely position each light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since every light has the same diffuse, ambient, and specular properties, we
    only set a dynamic position by using the `lightPositions` data.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Program Attributes and Uniforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, inside the `configure` function, we map the JavaScript values to the attributes
    and uniforms inside of our shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the program `instance` from earlier, we will set up the values to map
    attributes and uniforms to the shaders. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When creating shaders, make sure that the shader attributes and uniforms are
    properly mapped to JavaScript values. This mapping step allows us to refer to
    attributes and uniforms effortlessly. Check out the `setAttributeLocations` and `setUniformLocations` methods
    inside of `Program.js`, which are called by `program.load`.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After mapping the variables, we can initialize shader uniforms, such as lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The default material properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will create a `floor` instance that we will use later. We will also
    structure the data that describes the car model that we''ll be loading later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Although we have only described one car model here, we'll leverage this data
    format so that we can add other car models later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the final `configure` function, which you can find in the `ch09_02_showroom.html`
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have finished setting up the scene. Next, we'll implement the `load` function.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the Cars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside of the `load` function, we will download some assets in the background
    that we can load into our application.
  prefs: []
  type: TYPE_NORMAL
- en: When the JSON files that describe the cars are available, we just use the `scene`
    instance to load these files. Keep in mind that it's uncommon to have ready-to-use
    JSON files. In such situations, there are specialized design tools, such as Blender,
    which can significantly help create and convert consumable models.
  prefs: []
  type: TYPE_NORMAL
- en: That said, we will use the pre-built models that are available on [blendswap.org.](http://www.blendswap.org/) All
    of these models are publicly available, and are free of charge to use and distribute.
    Before we can use these models, we need to export them to an intermediate file
    format from where we can extract the geometry and material properties to create the
    appropriate JSON files. The file format we are going to use is **Wavefront OBJ**.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the Blender Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the assets for this exercise are provided in this book's source code. However,
    if you want to go through the steps of converting the models, here are the steps. For
    this exercise, we will be using Blender (v2.6).
  prefs: []
  type: TYPE_NORMAL
- en: '**Blender** If you do not have Blender, you can download it for your operating
    system from [https://www.blender.org/download/](https://www.blender.org/download/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have loaded the car into Blender, you need to export it as an OBJ
    file. To do so, go to **File** | **Export** | **Wavefront (.obj)**, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d1a3104-bd09-4bc9-beb2-917541d6e04e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Export OBJ** panel, make sure that the following options are active:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apply Modifiers**: This will write the vertices in the scene that are the
    result of a mathematical operation instead of direct modeling. If you do not check
    this option, the model may appear incomplete in the WebGL scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write Materials**: Blender will create the matching Material Template Library
    (MTL) file. We''ll cover more on this in the following section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Triangulate Faces**: Blender will write the indices as triangles. This is
    ideal for WebGL rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity as OBJ Objects**: This configuration will identify every object in
    the Blender scene as an object in the OBJ file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material Groups**: If an object in the Blender scene has several materials,
    for example, a car tire that can be made of aluminum and rubber, then the object
    will be subdivided into groups, one per material in the OBJ file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OBJ file. Then, click on Export. Once you have checked these export parameters,
    select the directory and name for your
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OBJ Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several types of definitions in an OBJ file. Let''s cover them line-by-line
    with a simple example. We are going to dissect a sample `square.obj` file that
    we will export from the Blender file called `square.blend`. This file represents
    a square divided into two parts, one painted red and the other painted blue, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36b9625a-a092-47cd-8aca-3a21aba8b6ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we export Blender models to an OBJ format, the resulting file normally
    starts with a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These are comments, and they are denoted with a hash `#` symbol at the beginning
    of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will usually find a line referring to the Material Template Library
    that this OBJ file is using. This line will begin with the keyword `mtllib`, followed
    by the name of the material''s file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways that geometries can be grouped into entities in an OBJ
    file. We can find lines starting with the prefix `o`, followed by the object name,
    or by the prefix `g`, followed by the group name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After object declaration, the following lines will refer to vertices, `v`,
    optionally to vertex normals, `vn`, and texture coordinates, `vt`. It’s important
    to note that vertices are shared by all groups in an object in the OBJ format.
    That is, you will not find lines referring to vertices when defining a group,
    because it''s assumed that all vertex data was defined when the object was defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we have instructed Blender to export group materials. This means
    that each part of the object that has a different set of material properties will
    appear in the OBJ file as a group. In this example, we are defining an object
    with two groups (`squares_mesh_blue` and `squares_mesh_red`) and two corresponding
    materials (blue and red):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If materials are being used, the line after the group declaration will be the
    material that''s being used for that group. In this case, only the name of the
    material is required. It''s assumed that the material properties for this material
    are defined in the MTL file that was declared at the beginning of the OBJ file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines that begin with the prefix `s` refer to smooth shading across polygons.
    Although mentioned here, we will not be using this definition when parsing the
    OBJ files into JSON files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The lines that start with `f` refer to faces. There are different ways to represent
    faces. Let's see them.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration, every face element corresponds to a vertex index. Depending
    on the number of indices per face, you could have triangular, rectangular, or
    polygonal faces. However, we have instructed Blender to use triangular faces to
    create the OBJ file. Otherwise, we would need to decompose the polygons into triangles
    before we could call `drawElements`.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex/Texture Coordinate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this combination, every vertex index appears to be followed by a forward
    slash and texture coordinate index. You will normally find this combination when
    texture coordinates are defined at the object level with `vt`.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex/Texture Coordinate/Normal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here is a normal index that has been added as the third element in the configuration.
    If both texture coordinates and vertex normals are defined at the object level,
    you will most likely see this configuration at the group level.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex//Normal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There can also be cases where normals are defined but texture coordinates are
    not. In this case, the second part of the face configuration is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the case for `square.obj`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that faces are defined using indices. In our example, we have defined a
    square divided into two parts. Here, we can see that all of the vertices share
    the same normal, which has been identified with index `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining lines in this file represent the red group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned previously, groups belonging to the same object share indices.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the OBJ Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After exporting our cars into OBJ format, the next step is to parse the OBJ
    files to create JSON files that we can load into our scene. We have included the
    parser that we developed for this step in `common/models/obj-parser.py`. This
    parser has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s written in Python (quite common for OBJ parsers) and can be called in
    the command line with the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `arg1` is the name of the OBJ file to parse and `arg2` is the name of
    the MTL. The file extension is needed in both cases. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It creates one JSON file per OBJ group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It searches into the Material Template Library (if defined) for the material
    properties for each group and adds them to the corresponding JSON file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will calculate the appropriate indices for each group. Remember that OBJ
    groups share indices. Since we are creating one independent WebGL object per group,
    each object needs to have indices starting with `0`. The parser takes care of
    this for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have Python installed in your system, you can get it from [http://www.python.org/](http://www.python.org/) or[ https://anaconda.org/anaconda/python](https://anaconda.org/anaconda/python).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the procedure needed to create JSON files
    from Blender scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fd36821-62f5-4642-9ad0-00e36299aa13.png)'
  prefs: []
  type: TYPE_IMG
- en: Loading Cars into Our WebGL Scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have cars stored as JSON files, they are ready to be used in our
    WebGL scene. First, we have to let the user choose which car to visualize. That
    said, it''s still a good idea to load one by default. To do so, we will write
    the following code inside the `load` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We call `goHome`, a helper function, that sets the `camera` position to a particular
    point in our scene. This is defined as a function, since we''ll later use it as
    a way to reset our `camera` location, as needed. Then, we call `loadCar`, which
    is where we supply the `key` of the car (for example, `BMW i8`) we want to load
    from the `carModelData` that we defined inside of `configure`. Let''s see what
    `loadCar` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This function clears all of the objects in our `scene`, adds the already created
    `floor` instance, and extracts the necessary data from the `carModelData` object,
    such as the `path` to the model and the number of parts to load.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a step back and assess the big picture. We previously mentioned that,
    in our architecture, we have defined three main functions that define the life
    cycle of our WebGL application. These functions are `configure`, `load`, and `draw`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far, we''ve set up the scene by writing the code for the `configure` function.
    After that, we created our JSON cars and loaded them by writing the code for the `load` function.
    Now, we will implement the code for the third function: the `draw` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The code is pretty standard and almost identical to the `draw` functions that
    we've written in previous chapters. As the following code demonstrates, we set
    and clear the area that we are going to draw. Then, we check the camera's perspective
    and process every object in `scene`.
  prefs: []
  type: TYPE_NORMAL
- en: One important consideration is that we need to ensure that we are correctly
    mapping the material properties defined in our JSON objects to the appropriate
    shader uniforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start implementing the `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we set our viewport and clear the scene, followed by applying the perspective
    update by using the `transforms` instance we initialized inside of `configure`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we move to the objects in our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It may be helpful to take a look at the list of uniforms that was defined in
    the earlier section on shaders. We need to make sure that all of the shader uniforms
    are paired with object attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the process that occurs inside the `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a1f1a48-9965-4484-a37d-50314abaa617.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each car part is a different JSON file. The `draw` function iterates through
    all of these parts inside the `scene`. For each part, the material properties
    are passed as uniforms to the shaders and the geometry is passed as attributes
    (reading data from the respective VBOs). Finally, the draw call (`drawElements`)
    is executed. The result looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03a50b25-f2e1-4daa-9aad-795f45a63e3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the final JavaScript source code that can be found in `ch09_02_showroom.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for the vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the application code with the appropriate global variable
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the configuration step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for loading the required assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code states where we draw our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization of our application after the document has loaded is performed
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We have covered a demo that uses many of the elements we've discussed throughout
    this book. We used the infrastructure code that we developed throughout the previous
    chapters and implemented the three main functions: `configure`, `load`, and `draw`.
    As we've seen, these functions define the life cycle of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Have a Go: Interactive Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s leverage **dat.GUI** to add more interactivity and customization to
    our application. Go ahead and try and add the following functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a dropdown so that you can select from the following car models provided
    in the `common/models/` directory: `bmw-i8`, `audi-r8`, `ford-mustang`, and `lamborghini-gallardo`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint** You can leverage `carModelData` to declaratively describe the car
    models and use the already created `loadCar` function with the appropriate information.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a color picker to change the color of the loaded car.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint** By inspecting the car data files, you will find various indicators
    that signify which parts are body panels. These are described as `paintAlias`
    in `carModelData`,  which can be used to change the `Kd` property of each individual
    item in the scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a slider to change the shininess of the selected car.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint** You can use `paintAlias` once again and update the `Ks` property of
    each individual item in the scene.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functionality has been implemented in `ch09_03_showroom-controls.html`,
    along with controls for each individual light, the background color, floor visibility,
    and so forth:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d32ccc1d-cd9d-4f90-90bc-4a8e70d2ee2f.png)`utils.configureControls`'
  prefs: []
  type: TYPE_NORMAL
- en: The `utils.configureControls` method is a simple abstraction on top of the dat.GUI
    interface to remove repetition and provide a more declarative way for describing
    our controls widget. You can use dat.GUI directly or build upon this simple helper
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Bonus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You made it! How awesome is that?! As a bonus, a few additional examples have
    been provided for you in the source code under the `ch10` directory. The bonus
    examples use the virtual car showroom as a base to showcase a few more advanced
    features for you to leverage in your future ventures in building compelling 3D
    experiences. Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s summarize what we’ve learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We've reviewed concepts, architecture, and code that has been developed throughout
    this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We built a 3D virtual car showroom application showcasing how all of these elements
    fit together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've learned that designing complex models requires specialized tools, such
    as Blender.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered how most of the current 3D graphics formats require the definition
    of vertices, indices, normals, and texture coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We studied how to obtain required elements from a Blender model to parse them
    into JSON files that we can load into a WebGL scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to add a controls widget to provide customization functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will get a sneak peek at some of the advanced techniques
    commonly used in 3D computer graphic systems, including games, simulations, and
    other 3D applications. After addressing these topics, we will also learn how to
    implement them in WebGL.
  prefs: []
  type: TYPE_NORMAL
