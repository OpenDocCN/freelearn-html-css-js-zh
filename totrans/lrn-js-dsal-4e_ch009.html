<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning JavaScript Data Structures and Algorithms - Fourth Edition</title>


</head>
<body>
<div><div><h1 data-number="9">8 Dictionaries and Hashes</h1>
<p><strong>Before you begin: Join our book community on Discord</strong></p>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p>
<img style="width:10rem;" src="img/file0.png" width="200" height="200"/>
</p>
<a href="https://packt.link/EarlyAccess/">https://packt.link/EarlyAccess/</a>
<p>In the previous chapter, we delved into the world of sets, focusing on their ability to efficiently store unique values. Building upon this foundation, we will now explore two more data structures designed for storing distinct elements: dictionaries and hashes.</p>
<p>While sets prioritize the value itself as the primary element, dictionaries and hashes take a different approach. Both structures store data as key-value pairs, allowing us to associate a unique key with a corresponding value. This pairing is fundamental to how dictionaries and hashes work.</p>
<p>However, there is a subtle yet important distinction in implementation. Dictionaries, as we will soon discover, adhere to a strict rule of one value per key. Hashes, on the other hand, offer some flexibility in handling multiple values associated with the same key, opening up additional possibilities for data organization and retrieval.</p>
<p>In this chapter, we will cover:</p>
<ul>
<li>The dictionary data structure</li>
<li>The hash table data structure</li>
<li>Handling collisions in hash tables</li>
<li>The JavaScript native <code>Map</code>, <code>WeakMap</code>, and <code>WeakSet</code> classes</li>
</ul>

<h2 data-number="9.1">The dictionary data structure</h2>
<p>As we have explored, a set is a collection of unique elements, ensuring that no duplicates exist within the structure. In contrast, a <strong>dictionary</strong> is designed to store pairs of keys and values. This pairing enables us to utilize keys as identifiers to efficiently locate specific elements.</p>
<p>While dictionaries share similarities with sets, there is a crucial distinction in the type of data they store. Sets maintain a collection of key-key pairs, where both elements of the pair are identical. Dictionaries, on the other hand, house key-value pairs, associating each unique key with a corresponding value.</p>
<p>It is worth noting that dictionaries are known by various names in different contexts, including <strong>maps</strong>, <strong>symbol tables</strong>, and <strong>associative arrays</strong>. These terms highlight the fundamental purpose of dictionaries: to establish associations between keys and values, facilitating efficient data retrieval and organization.</p>
<p>In computer science, dictionaries are frequently employed to store the reference addresses of objects. These addresses serve as unique identifiers for objects residing in memory. To visualize this concept, consider opening the <em>Chrome Developer Tools</em> and navigating to the <strong>Memory</strong> tab. Running a snapshot will reveal a list of objects along with their respective address references, typically displayed in the format <em>@&lt;number&gt;</em>. The following screenshot illustrates how dictionaries can be used to associate keys with these memory addresses, enabling efficient object retrieval and manipulation.</p>
<figure>
<img src="img/file59.png" alt="Memory tab of a browser displaying the memory allocation for address references" width="1210" height="471"/><figcaption aria-hidden="true">Memory tab of a browser displaying the memory allocation for address references</figcaption>
</figure>
<p>In this chapter, we will also cover some examples of how to use the dictionary data structure in real world projects.</p>


<h2 data-number="9.2">Creating the Dictionary class</h2>
<p>In addition to the <code>Set</code> class, <strong>ECMAScript 2015</strong> (ES6) introduced the <code>Map</code> class, a fundamental data structure often referred to as a dictionary in programming. This native implementation serves as the basis for the custom dictionary class we will develop in this chapter.</p>
<p>The <code>Dictionary</code> class we will construct draws heavily from the design principles of the JavaScript Map implementation. As we explore its structure and functionality, you will observe striking similarities to the <code>Set</code> class. However, a key distinction lies in the data storage mechanism. Instead of storing only values, as in a Set, our dictionary class will accommodate key-value pairs. This modification allows us to associate unique keys with their corresponding values, thereby unlocking the full power and versatility of dictionaries as a data structure.</p>
<p>Our implementation will reside in the src/08-dictionary-hash/dictionary.js file. We will start by defining the <code>Dictionary</code> class:</p>
<div><pre><code>class Dictionary {
  #items = {};
  #size = 0;
}</code></pre>
</div>
<p>We utilize an object (<code>{}</code>) to store elements within the <code>#items</code> private property. The keys of this object represent the unique keys, while the corresponding values can be anything. We will also keep track of the number of elements in the set with the property <code>size</code>.</p>
<p>In an ideal scenario, a dictionary would seamlessly store keys of the string type alongside values of any type, whether they are primitive values like numbers or strings, or more complex objects. However, JavaScript's dynamically typed nature introduces a potential challenge. Since we cannot guarantee that keys will consistently be strings, we must implement a mechanism to transform any object passed as a key into a string format. This transformation simplifies the process of searching for and retrieving values within our Dictionary class, enhancing its overall functionality. The same logic can also be applied to the Set class we explored in the previous chapter.</p>
<blockquote>
<p>Note that we do not have this issue in the TypeScript implementation, as we can define the type of the key as string.</p>
</blockquote>
<p>To achieve this key transformation, we require a function that can reliably convert objects into strings. As a default option, we will leverage the <code>#elementToString</code> method we have defined earlier this book in previous data structures. This function provides a reusable solution for stringifying keys, making it adaptable to any data structure we create:</p>
<div><pre><code>#elementToString(data) {
  if (typeof data === 'object' &amp;&amp; data !== null) {
    return JSON.stringify(data);
  } else {
    return data.toString();
  }
}</code></pre>
</div>
<p>This method efficiently converts data into a string representation. If the data is a complex object (excluding <code>null</code>), it utilizes <code>JSON.stringify()</code> to produce a <strong>JSON</strong> string. Otherwise, it leverages the <code>toString</code> method to ensure a string conversion for any other data type.</p>
<p>Now, let's define the methods that will empower our dictionary/map data structure:</p>
<ul>
<li><code>set(key, value)</code>: inserts a new key-value pair into the dictionary. If the specified key already exists, its associated value will be updated with the new value.</li>
<li><code>remove(key)</code>: removes the entry corresponding to the provided key from the dictionary.</li>
<li><code>hasKey(key)</code>: determines whether a given key is present in the dictionary, returning <code>true</code> if it exists and <code>false</code> otherwise.</li>
<li><code>get(key)</code>: retrieves the value associated with the specified key.</li>
<li><code>clear()</code>: empties the dictionary, removing all key-value pairs.</li>
<li><code>size()</code>: returns the count of key-value pairs currently stored in the dictionary, similar to the length property of an array.</li>
<li><code>isEmpty()</code>: checks if the dictionary is empty, returning <code>true</code> if the size is zero and <code>false</code> otherwise.</li>
<li><code>keys()</code>: generates an array containing all the keys present in the dictionary.</li>
<li><code>values()</code>: produces an array containing all the values stored in the dictionary.</li>
<li><code>forEach(callbackFn)</code>: iterates over each key-value pair in the dictionary. The <code>callbackFn</code> function, which accepts a key and a value as parameters, is executed for each entry. This iteration process can be terminated if the callback function returns <code>false</code>, mirroring the behavior of the <code>every</code> method in the <code>Array</code> class.</li>
</ul>
<p>We will implement each of these methods in detail in the following sections.</p>

<h3 data-number="9.2.1">Verifying whether a key exists in the dictionary</h3>
<p>The first method we will implement is the <code>hasKey(key)</code> method. This method is fundamental, as it will be utilized in other methods like <code>set</code> and <code>remove</code>. Let's examine its implementation:</p>
<div><pre><code>hasKey(key) {
  return this.#items[this.#elementToString(key)] != null;
}</code></pre>
</div>
<p>In JavaScript, object keys are inherently strings. Therefore, if a complex object is provided as a key, we must convert it to a string representation. To achieve this, the <code>#elementToString</code> method is invoked consistently, ensuring that keys are always treated as strings within our dictionary.</p>
<p>The <code>hasKey</code> method checks if there is a value associated with the given key within the items table (the underlying storage for our dictionary). If the corresponding position in the table is not <code>null</code> or <code>undefined</code>, indicating the presence of a value, the method returns <code>true</code>. Otherwise, if no value is found, the method returns <code>false</code>.</p>
<p>And now that we have this method, we can proceed with the implementation of the methods for adding and removing values.</p>


<h3 data-number="9.2.2">Setting a key and value in the dictionary</h3>
<p>Next, we will implement the <code>set</code> method in our <code>Dictionary</code> class. The <code>set</code> method serves a dual purpose: it can both add a new key-value pair to the dictionary and update the value of an existing key:</p>
<div><pre><code>set(key, value) {
  if (key != null &amp;&amp; value != null) {
    const tableKey = this.#elementToString(key);
    this.#items[tableKey] = value;
    this.#size++;
    return true;
  }
  return false;
}</code></pre>
</div>
<p>This method accepts a <code>key</code> and a <code>value</code> as input. If both the key and value are valid (not <code>null</code> or <code>undefined</code>), the method proceeds to convert the key into a string representation. This is a crucial step because JavaScript object keys can only be strings. This conversion is handled internally by the private <code>#elementToString</code> method, ensuring consistency and reliability across all key types. With the key in string form, the method then stores the value within the dictionary's internal storage (<code>#items</code>).</p>
<p>Finally, the method communicates its success by returning <code>true</code>, signaling that the key-value pair was successfully inserted or updated and we increment its size. If either the key or value is invalid (<code>null</code> or <code>undefined</code>), the method returns <code>false</code>, signaling that the insertion or update operation failed.</p>


<h3 data-number="9.2.3">Removing and clearing all values from the dictionary</h3>
<p>The delete method's primary function is to remove a key-value pair from the dictionary based on the provided key. It ensures the integrity of the dictionary by checking for the key's existence before attempting removal and updating the size accordingly:</p>
<div><pre><code>delete(value) {
  if (this.has(value)) {
    delete this.#items[value];
    this.#size--;
    return true;
  }
  return false;
}</code></pre>
</div>
<p>We start by verifying if the provided key exists within the dictionary. This is achieved by calling the <code>has</code> method, which checks the dictionary's underlying storage for the presence of the specified key. This check is crucial to prevent errors that might arise from trying to delete a non-existent entry.</p>
<p>If the key is found, the <code>delete</code> operator in JavaScript is employed to remove the corresponding key-value pair from the dictionary's internal data structure (<code>#items</code>). Following the successful removal of the entry, the dictionary's internal size counter (<code>#size</code>) is decremented by one to accurately reflect the change in the number of stored elements.</p>
<p>As a last step, the method signals the outcome of the operation by returning <code>true</code> to indicate that the key existed and was successfully deleted, and <code>false</code> to indicate that the key was not found and no deletion occurred.</p>
<p>And if we want to remove all the elements from the set, we can use the <code>clear</code> method, as follows:</p>
<div><pre><code>clear() {
  this.#items = {};
  this.#size = 0;
}</code></pre>
</div>
<p>This effectively discards all previous key-value pairs and creates a fresh, empty container for future additions. And we also reset the <code>#size</code> property back to 0 to accurately reflect that the set now contains no elements.</p>


<h3 data-number="9.2.4">Retrieving the size and checking if it is empty</h3>
<p>The next method we will implement is the size method as follows:</p>
<div><pre><code>  get size() {
    return this.#size;
  }</code></pre>
</div>
<p>This method simply returns the size property we are using to keep count.</p>
<p>And to determine if the dictionary is empty, we implement the <code>isEmpty()</code> method, following a pattern consistent with other data structures we have covered in this book:</p>
<div><pre><code>isEmpty() {
  return this.#size === 0;
}</code></pre>
</div>
<p>This method directly compares the private <code>#size</code> property to 0. The property <code>#size</code> is meticulously maintained to always reflect the number of elements in the set.</p>


<h3 data-number="9.2.5">Retrieving a value from the dictionary</h3>
<p>To search for a specific key within our dictionary and retrieve its associated value, we utilize the <code>get</code> method. This method streamlines the process of accessing stored data by encapsulating the necessary logic and is presented as follows:</p>
<div><pre><code>  get(key) {
  return this.#items[this.#elementToString(key)];
}</code></pre>
</div>
<p>Upon receiving a <code>key</code> as input, the <code>get</code> method first transforms it into a string representation using the private <code>#elementToString</code> function. Next, the method directly accesses the corresponding value from the dictionary's internal storage (<code>#items</code>). This is achieved by using the stringified key to index into the #items object, which presumably holds the key-value pairs. The value associated with the given key, if found, is then returned by the method.</p>


<h3 data-number="9.2.6">Retrieving all the values and all the keys from the dictionary</h3>
<p>Let's explore how to retrieve all values and keys from our custom dictionary class in JavaScript. We will start by declaring the method <code>values</code>, which will retrieve all the values stored in the Dictionary class as follows:</p>
<div><pre><code>values() {
  return Object.values(this.#items);
}</code></pre>
</div>
<p>This method is quite straightforward. It leverages the built-in <code>Object.values()</code> function, which takes an object (in this case, our private <code>#items</code> storage) and returns an array containing all of its values.</p>
<p>Next, we have the <code>keys</code> method:</p>
<div><pre><code>keys() {
  return Object.keys(this.#items);
}</code></pre>
</div>
<p>Similarly, the <code>keys</code> method uses the <code>Object.keys()</code> function. This function, when given an object, returns an array of all the string-based keys (property names) in that object. Since we ensure that all keys are strings in our dictionary implementation, this works perfectly.</p>
<p>In most cases, these methods have good performance. However, for exceptionally large dictionaries, iterating directly over the <code>#items</code> object might be slightly more efficient in some JavaScript engines. Let's see how we can achieve this in the next topic.</p>


<h3 data-number="9.2.7">Iterating each value-pair of the dictionary with forEach</h3>
<p>Thus far, we have not implemented a method that facilitates iteration through each value stored within our data structures. We will now introduce the <code>forEach</code> method for the <code>Dictionary</code> class, with the added benefit that this behavior can also be applied to other data structures we have previously constructed.</p>
<p>Here is the <code>forEach</code> method:</p>
<div><pre><code>forEach(callbackFn) {
  for (const key in this.#items) {
    if (this.#items.hasOwnProperty(key)) {
      callbackFn(this.#items[key], key);
    }
  }
}</code></pre>
</div>
<p>The <code>forEach</code> method is designed to iterate over every key-value pair within our dictionary, applying a provided callback function to each entry. For each key-value pair, the provided <code>callbackFn</code> function is executed, receiving the value and key as arguments.</p>
<p>We use a <code>for...in</code> loop for iterating over object properties. However, to ensure that we only process the dictionary's own properties (and not inherited ones from its prototype chain), a safeguard is employed. The <code>hasOwnProperty</code> method checks whether a property belongs directly to the object. In this case, it verifies if the current <code>key</code> in the loop is an actual key within the <code>#items</code> object, the dictionary's underlying storage. Then, we apply the provided callback function to each entry, retrieving the value from the dictionary and passing the key as an argument to the callback.</p>
<p>Now that we have our data structure, let's test it!</p>


<h3 data-number="9.2.8">Using the Dictionary class</h3>
<p>Imagine we are building a simple language learning program. We want to store translations for frequently-used words and phrases to help users quickly look up meanings in different languages.</p>
<p>The source code for this example can be found in the file <code>src/08-dictionary-hash/01-using-dictionary-class.js</code>. Let's start by creating the dictionary and adding some values:</p>
<div><pre><code>const translations = new Dictionary();
// Add some translations - English to Portuguese
translations.set("hello", "olá");
translations.set("thank you", "obrigado");
translations.set("book", "livro"); 
translations.set("cat", "gato");
translations.set("computer", "computador");</code></pre>
</div>
<p>We use <code>set</code> to populate the dictionary with key-value pairs representing word translations. The keys are words in English, and the values are their Portuguese translations.</p>
<p>Next, we will create a function so the user can interact with it to retrieve the translation of a particular word or phrase:</p>
<div><pre><code>function translateWord(word) {
  if (translations.hasKey(word)) {
    const translation = translations.get(word);
    console.log(`The translation of "${word}" is "${translation}"`);
  } else {
    console.log(`Sorry, no translation found for "${word}"`);
  }
}</code></pre>
</div>
<p>The <code>translateWord</code> function takes a <code>word</code> as input. It uses <code>hasKey</code> to check if the word exists in the dictionary. If the word is found, it retrieves the translation using the <code>get</code> method and prints it. If not found, it displays a "no translation found" message.</p>
<p>We can try this function with the following code:</p>
<div><pre><code>translateWord("hello"); // Output: The translation of "hello" is "olá"
translateWord("dog");  // Output: Sorry, no translation found for "dog"</code></pre>
</div>
<p>We can also check all translations available:</p>
<div><pre><code>console.log("All translations:", translations.values());
// All translations: [ 'olá', 'obrigado', 'livro', 'gato', 'computador' ]</code></pre>
</div>
<p>And alls words we have transactions available:</p>
<div><pre><code>console.log("All words:", translations.keys());
// All words: [ 'hello', 'thank you', 'book', 'cat', 'computer' ]</code></pre>
</div>
<p>And in case we would like to print the dictionary, we can use the <code>forEach</code> method as follows:</p>
<div><pre><code>translations.forEach((value, key) =&gt; {
  console.log(`${key}: ${value}`);
});</code></pre>
</div>
<p>We will get the following output:</p>
<div><pre><code>hello: olá
thank you: obrigado
book: livro
cat: gato
computer: computador</code></pre>
</div>
<p>So, now that we have a very similar implementation of the native JavaScript Map class,</p>



<h2 data-number="9.3">The JavaScript Map class</h2>
<p>ECMAScript 2015 introduced a Map class as part of the JavaScript API. We developed our Dictionary class based on the ES2015 Map class.</p>
<p>At its core, a Map is a collection of key-value pairs, similar to a dictionary or hash table in other programming languages. However, unlike plain JavaScript objects, a Map offers several key advantages as follows:</p>
<ul>
<li>The Map class allows keys of any data type, including objects, functions, or even other Map objects. In contrast, object keys are automatically converted to strings.</li>
<li>The Map class maintains the order in which key-value pairs were inserted, making iteration predictable.</li>
<li>We can easily get the number of entries using the size property, whereas with objects, we typically need to use <code>Object.keys(obj).length</code>.</li>
<li>The Map class natively supports iteration using <code>for...of</code> loops, making it more convenient to work with.</li>
</ul>
<p>Now, let's take a look at the methods and features available in the native Map class:</p>
<ul>
<li><code>set(key, value)</code>: adds or updates a key-value pair.</li>
<li><code>get(key)</code>: retrieves the value associated with the key.</li>
<li><code>has(key)</code>: checks if a key exists.</li>
<li><code>delete(key)</code>: removes a key-value pair.</li>
<li><code>size</code>: returns the number of entries.</li>
<li><code>clear()</code>: removes all entries.</li>
<li><code>forEach(callbackFn)</code>: iterates over all entries.</li>
</ul>
<p>If we would like to rewrite our translation application example, can we simply replace <code>Dictionary</code> with <code>Map</code> and the code would still work as follows:</p>
<div><pre><code>const translations = new Map();
translations.set("hello", "olá");
translations.set("thank you", "obrigado");
translations.set("book", "livro"); 
translations.set("cat", "gato");
translations.set("computer", "computador");</code></pre>
</div>
<p>The other methods, such as <code>get</code>, check the <code>size</code>, <code>has</code>, <code>values</code> and <code>forEach</code> would also work as expected.</p>
<p>Constructing our custom <code>Dictionary</code> class has proven to be an enlightening educational endeavor, granting us a deeper understanding of the inner mechanisms of map data structures. While the built-in JavaScript Map class offers efficiency and convenience for most everyday scenarios, the experience of creating our own dictionary equips us with valuable knowledge.</p>
<p>JavaScript also supports a weak version of the Map and Set classes: <code>WeakMap</code> and <code>WeakSet</code>. Let's briefly take a look at them.</p>

<h3 data-number="9.3.1">The JavaScript WeakMap and WeakSet classes</h3>
<p>In addition to the standard <code>Map</code> and <code>Set</code> classes, JavaScript offers two specialized collection types known as <code>WeakMap</code> and <code>WeakSet</code>. These classes provide a unique way to manage object references and can be particularly useful in scenarios where memory management is a concern.</p>
<p>Similar to a <code>Map</code>, a <code>WeakMap</code> stores key-value pairs. However, the keys in a <code>WeakMap</code> <em>must</em> be <em>objects</em>, and the references to these keys are weak. This means that if the only reference to an object is its presence as a key in a <code>WeakMap</code>, the JavaScript garbage collector can remove that object from memory.</p>
<p>A <code>WeakSet</code> functions like a <code>Set</code>, storing a collection of unique values. However, it can only store <code>objects</code>, and the references to these objects are weak. Similar to <code>WeakMap</code>, if an object's only reference is its presence in a <code>WeakSet</code>, it can be garbage collected.</p>
<p><code>WeakMap</code> and <code>WeakSet</code> also have fewer methods than their regular counterparts. They lack <code>size</code>, <code>clear</code>, and iteration methods (like <code>forEach</code> and <code>keys()</code>).</p>
<p>Let's review a real-world scenario where we would use these classes. Imagine we are designing a program that provides a Person class. We want to store some sensitive private data associated with each person instance, like their social security number (or tax id) or medical records. However, we do not want to clutter the object itself with these properties, and we want to ensure they can be garbage collected when the Person object is no longer needed. Here is the code to exemplify this scenario:</p>
<div><pre><code>const privateData = new WeakMap();
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
    privateData.set(this, { ssn: 'XXX-XX-XXXX', medicalHistory: [] });
  }
  getSSN() {
    return privateData.get(this)?.ssn;
  }
}</code></pre>
</div>
<p>A <code>WeakMap</code> is created to store the private data. The key is the <code>Person</code> object itself (<code>this</code>). Inside the <code>Person</code> <code>constructor</code>, we use <code>privateData.set(this, { ... })</code> to associate private data with the newly created person object (<code>this</code>). The <code>getSSN</code> method retrieves the private SSN data using <code>privateData.get(this)</code>. Note the <strong>optional chaining</strong> (<code>?.</code>) to safely handle cases where the <code>Person</code> object might no longer exist (and this way we do not get a <em>null pointer</em> error).</p>
<p>Why use a <code>WeakMap</code> instead of a <code>Map</code> here? When a Person object becomes inaccessible (no references to it remain), the garbage collector can remove the reference of the object and the associated private data in the <code>WeakMap</code>, preventing memory leaks. This can be considered a good practice for managing sensitive or temporary data that does not need to outlive the objects it is associated with.</p>
<blockquote>
<p>This pattern also could be used to implement private properties in JavaScript classes before the hash (#) notation was introduced to JavaScript private properties.</p>
</blockquote>
<p>Now that we understand the map or dictionary data structure, let's take it to the next level with hash tables.</p>



<h2 data-number="9.4">The hash table data structure</h2>
<p>The <strong>hash table</strong> data structure, also known as <strong>hash map</strong>, is a hash implementation of the dictionary or map data structures. A hash table is also a collection of key-value pairs. The key is a unique identifier, and the value is the data you want to associate with that key. Hash tables achieve their speed by using a <strong>hash function</strong>.</p>
<p>This is how hash tables work:</p>
<ul>
<li><em>Hash Function</em>: a hash function takes a key as input and produces a unique numerical value called a <strong>hash code</strong> (or <strong>hash value</strong>). This hash code is like a fingerprint of the key.</li>
<li><em>Storage (buckets/slots)</em>: the hash table internally consists of an array (or similar structure like a linked list) with fixed-size buckets or slots. Each bucket can store one or more key-value pairs.</li>
<li><em>Insertion</em>: when you insert a key-value pair:
<ul>
<li>The hash function is applied to the key to get its hash code.</li>
<li>The hash code is used to determine the index (bucket) where the key-value pair should be stored.</li>
<li>The pair is placed in that bucket.</li>
</ul></li>
<li><em>Retrieval</em>: when you want to retrieve a value, you provide and key and:
<ul>
<li>The hash function is applied to the key again, producing the same hash code.</li>
<li>The hash code is used to directly access the bucket where the value should be stored.</li>
<li>The value is found (hopefully) in that bucket.</li>
</ul></li>
</ul>
<p>Hash tables are present in many different places. For example:</p>
<ul>
<li>Databases: used for indexing data for fast retrieval.</li>
<li>Caches: store recently accessed data for quick lookups.</li>
<li>Symbol Tables: in compilers, used to store information about variables and functions.</li>
</ul>
<p>One of the most classical examples for a hash table is an email address book. For example, whenever we want to send an email, we look up the person's name and retrieve their email address. The following image exemplifies this process:</p>
<figure>
<img src="img/file60.png" alt="A hash table used to store email addresses based on the contact name" width="1209" height="473"/><figcaption aria-hidden="true">A hash table used to store email addresses based on the contact name</figcaption>
</figure>
<p>For this example, we will use a hash function which will simply sum up the ASCII values of each character of the key length. This is called a <strong>lose-lose hash</strong> function, which is very simple function that can lead into different issues that we will explore in the next sections.</p>
<p>Let's translate this diagram into a source code by creating a <code>HashTable</code> class in the new topic so we can dive into this concept.</p>


<h2 data-number="9.5">Creating the HashTable class</h2>
<p>Our hash table implementation will be located in the <code>src/08-dictionary-hash/hash-table.js</code> file. We begin by defining the <code>HashTable</code> class:</p>
<div><pre><code>class HashTable {
  #table = [];
}</code></pre>
</div>
<p>This initial step simply initializes the private <code>#table</code> array, which will serve as the underlying storage for our key-value pairs.</p>
<p>Next, we will equip our <code>HashTable</code> class with three essential methods:</p>
<ol>
<li><code>put(key, value)</code>: this method either adds a new key-value pair to the hash table or updates the value associated with an existing key.</li>
<li><code>remove(key)</code>: this method removes the value and its corresponding key from the hash table based on the provided key.</li>
<li><code>get(key)</code>: this method retrieves the value associated with a specific key from the hash table.</li>
</ol>
<p>To enable the functionality of these methods, we also need to create a crucial component: the hash function. This function will play a vital role in determining the storage location of each key-value pair within the hash table, making it a cornerstone of our implementation.</p>

<h3 data-number="9.5.1">Creating the lose-lose hash function</h3>
<p>Before implementing the core <code>put</code>, <code>remove</code>, and <code>get</code> methods, we must first establish a <code>hash</code> method. This method is fundamental, as it will determine the storage location of key-value pairs within the hash table. The code is presented as follows:</p>
<div><pre><code>hash(key) {
  return this.#loseLoseHashCode(key);
}</code></pre>
</div>
<p>The <code>hash</code> method acts as a wrapper around the <code>loseLoseHashCode</code> method, forwarding the provided <code>key</code> as its parameter. This wrapper design serves a strategic purpose: it allows for future flexibility in modifying the hash function without impacting other areas of our code that utilize the hash code. The <code>loseLoseHashCode</code> method is where the actual hash calculation takes place:</p>
<div><pre><code>#loseLoseHashCode(key) {
  if (typeof key !== 'string') {
    key = this.#elementToString(key);
  }
  const calcASCIIValue = (acc, char) =&gt; acc + char.charCodeAt(0);
  const hash = key.split('').reduce((acc, char) =&gt; calcASCIIValue, 0);
  return hash % 37; // mod to reduce the hash code
}</code></pre>
</div>
<p>Within <code>loseLoseHashCode</code>, we begin by checking if the key is already a string. If not, we convert it into a string using the <code>#elementToString</code> method we created in previous chapters to ensure consistent handling of keys.</p>
<p>Next, we calculate a hash value by summing the ASCII values of each character in the key string. It leverages two powerful array methods, <code>split</code> and <code>reduce</code>, to achieve this efficiently. It first splits the string into an array of individual characters. Then, it uses the reduce method to iterate over these characters, accumulating their ASCII values into a single hash value. For each character, we retrieve its ASCII value using the <code>charCodeAt</code> method and add it to the hash variable.</p>
<p>Finally, to avoid working with potentially large numbers that might not fit within a numeric variable, we apply a <em>modulo</em> operation (the remainder after dividing one number by another) to the hash value using an arbitrary divisor (in this case, 37). This ensures that the resulting hash code falls within a manageable range, optimizing storage and retrieval within the hash table.</p>
<p>Now that we have our hash function, we can start diving into the next methods.</p>


<h3 data-number="9.5.2">Putting a key and a value in the hash table</h3>
<p>Having established our <code>hash</code> function, we can now proceed to implement the <code>put</code> method. This method mirrors the functionality of the <code>set</code> method in the <code>Dictionary</code> class, with a slight difference in naming convention to align with customary practice in other programming languages. The <code>put</code> method is presented as follows:</p>
<div><pre><code>put(key, value) {
  if (key == null &amp;&amp; value == null)  {
    return false;
  }
  const index = this.hash(key);
  this.#table[index] = value;
  return true;
}</code></pre>
</div>
<p>The <code>put</code> method facilitates the insertion or updating of key-value pairs within the hash table. It first validates the provided key and value, ensuring that neither is <code>null</code> or <code>undefined</code>. This check prevents the storage of incomplete or meaningless data within the hash table.</p>
<p>If both the <code>key</code> and value are deemed valid, we proceed to calculate the hash code for the given key. This hash code, determined by the <code>hash</code> function, will serve as the index for storing the value in the underlying <code>#table</code> array.</p>
<p>Finally, the put method returns <code>true</code> to indicate that the key-value pair was successfully inserted or updated. Conversely, if either the key or value is invalid, the method returns <code>false</code>, signifying that the operation was not successful.</p>
<p>Once a value is present in the table, we can try to retrieve it.</p>


<h3 data-number="9.5.3">Retrieving a value from the hash table</h3>
<p>Retrieving a value from the <code>HashTable</code> instance is a straightforward process, facilitated by the <code>get</code> method. This method enables us to efficiently access data stored within the hash table based on its associated key:</p>
<div><pre><code>get(key) {
  if (key == null) {
    return undefined;
  }
  const index = this.hash(key);
  return this.#table[index];
}</code></pre>
</div>
<p>We start by validating the input key, ensuring it is not <code>null</code> or <code>undefined</code>. If the key is indeed valid, we proceed to determine its position within the hash table using the previously defined <code>hash</code> function. This function transforms the key into a numerical hash code, which directly corresponds to the index of the value in the underlying array.</p>
<p>Leveraging this calculated index, the method accesses the corresponding element in the table array and returns its value. This provides a seamless way to retrieve data from the hash table, as the <code>hash</code> function eliminates the need for linear search and directly points to the desired value's location.</p>
<blockquote>
<p>It is worth noting that in our <code>HashTable</code> implementation, we have included input validation to ensure the provided keys and values are not invalid (<code>null</code> or <code>undefined</code>). This is a recommended practice that can be applied to all data structures we have developed thus far in this book. By proactively validating inputs, we enhance the robustness and reliability of our data structures, preventing errors and unexpected behavior caused by incorrect or incomplete data.</p>
</blockquote>
<p>Finally, let's turn our attention to the remaining method in our class: the <code>remove</code> method.</p>


<h3 data-number="9.5.4">Removing a value from the hash table</h3>
<p>The final method we will implement for our <code>HashTable</code> is the <code>remove</code> method, designed to eliminate a key-value pair based on the provided key. This method is essential for maintaining a dynamic and adaptable hash table structure:</p>
<div><pre><code>remove(key) {
  if (key == null) {
    return false;
  }
  const index = this.hash(key);
  if (this.#table[index]) {
    delete this.#table[index];
    return true;
  }
  return false;
}</code></pre>
</div>
<p>To successfully remove a value, we first need to identify its location within the hash table. This is achieved by obtaining the hash code corresponding to the given key using the <code>hash</code> function.</p>
<p>Next, we retrieve the value pair stored at the calculated hash position. If this value pair is not <code>null</code> or <code>undefined</code>, indicating that the key exists within the hash table, we proceed to remove it. This is accomplished by utilizing the JavaScript <code>delete</code> operator, which effectively eliminates the key-value pair from the hash table's internal storage.</p>
<p>To provide feedback on the operation's success, we return <code>true</code> if the removal was successful (meaning the key existed and was deleted) and <code>false</code> if the key was not found in the hash table.</p>
<p>It is worth noting that, as an alternative to using the delete operator, we could also assign <code>null</code> or <code>undefined</code> to the corresponding hash position to indicate its vacancy. This approach would still effectively remove the key-value association from the hash table while potentially offering a different strategy for managing empty slots within the array.</p>
<p>Now that the implementation of our class is complete, let's see it in action.</p>


<h3 data-number="9.5.5">Using the HashTable class</h3>
<p>Let's illustrate how our <code>HashTable</code> class can be employed to create an email address book:</p>
<div><pre><code>const addressBook = new HashTable();
// Add contacts
addressBook.put('Gandalf', 'gandalf@email.com');
addressBook.put('John', 'johnsnow@email.com');
addressBook.put('Tyrion', 'tyrion@email.com');</code></pre>
</div>
<p>We can gain insights into the internal structure of our hash table by inspecting the hash codes generated for specific keys. For instance, we can observe the hash values calculated for "Gandalf," "John," and "Tyrion" using the hash method:</p>
<div><pre><code>console.log(addressBook.hash('Gandalf')); // 19
console.log(addressBook.hash('John')); // 29
console.log(addressBook.hash('Tyrion')); // 16</code></pre>
</div>
<p>The resulting hash codes (19, 29, and 16, respectively) reveal how the hash table distributes these keys into different positions within its underlying array. This distribution is crucial for efficient storage and retrieval of values.</p>
<p>The following diagram represents the <code>HashTable</code> data structure with these values in it:</p>
<figure>
<img src="img/file61.png" alt="A hash table with three contacts" width="788" height="496"/><figcaption aria-hidden="true">A hash table with three contacts</figcaption>
</figure>
<p>Now let's put our <code>get</code> method to the test. By executing the following code, we can verify its behavior:</p>
<div><pre><code>console.log(addressBook.get('Gandalf')); // gandalf@email.com
console.log(addressBook.get('Loiane')); // undefined</code></pre>
</div>
<p>Since "Gandalf" is a key that exists within our <code>HashTable</code>, the get method successfully retrieves and outputs its associated value, "gandalf@email.com". However, when we attempt to retrieve a value for "Loiane," a non-existent key, the <code>get</code> method returns undefined, indicating that the key is not present in the hash table.</p>
<p>Next, let's remove "Gandalf" from the <code>HashTable</code> using the <code>remove</code> method:</p>
<div><pre><code>console.log(addressBook.remove('Gandalf')); // true
console.log(addressBook.get('Gandalf')); // undefined</code></pre>
</div>
<p>After removing "Gandalf," calling <code>hash.get('Gandalf')</code> now results in <code>undefined</code>. This confirms that the entry has been successfully deleted, and the key no longer exists within the hash table.</p>
<p>Occasionally, different keys can result in identical hash values, a phenomenon known as a <strong>collision</strong>. Let's delve into how we can effectively manage collisions within our hash table.</p>


<h3 data-number="9.5.6">Collisions between keys in a hash table</h3>
<p>In certain scenarios, distinct keys may produce identical hash values. We refer to this phenomenon as a collision, as it leads to attempts to store multiple key-value pairs at the same index within the hash table.</p>
<p>For example, let's review at the following email address book:</p>
<div><pre><code>const addressBook = new HashTable();
addressBook.put('Ygritte', 'ygritte@email.com');
addressBook.put('Jonathan', 'jonathan@email.com');
addressBook.put('Jamie', 'jamie@email.com');
addressBook.put('Jack', 'jack@email.com');
addressBook.put('Jasmine', 'jasmine@email.com');
addressBook.put('Jake', 'jake@email.com');
addressBook.put('Nathan', 'nathan@email.com');
addressBook.put('Athelstan', 'athelstan@email.com');
addressBook.put('Sue', 'sue@email.com');
addressBook.put('Aethelwulf', 'aethelwulf@email.com');
addressBook.put('Sargeras', 'sargeras@email.com');</code></pre>
</div>
<p>To illustrate the collision concept, let's examine the output generated by evoking the <code>addressBook.hash</code> method for each name mentioned:</p>
<div><pre><code>4 - Ygritte
5 - Jonathan
5 - Jamie
7 - Jack
8 - Jasmine
9 - Jake
10 - Nathan
7 - Athelstan
5 - Sue
5 - Aethelwulf
10 - Sargeras</code></pre>
</div>
<p>Notice that multiple keys share the same hash values:</p>
<ul>
<li>Nathan and Sargeras both have a hash value of 10.</li>
<li>Jack and Athelstan both have a hash value of 7.</li>
<li>Jonathan, Jamie, Sue, and Aethelwulf all share a hash value of 5.</li>
</ul>
<p>What happens within the hash table after adding all the contacts? Which values are ultimately retained? To answer these questions, let's introduce a <code>toString</code> method to inspect the hash table's contents:</p>
<div><pre><code>toString() {
  const keys = Object.keys(this.#table);
  let objString = `{${keys[0]} =&gt; ${this.#table[keys[0]].toString()}}`;
  for (let i = 1; i &lt; keys.length; i++) {
    const value = this.#elementToString(this.#table[keys[i]]).toString();
    objString = `${objString}\n{${keys[i]} =&gt; ${value}}`;
  }
  return objString;
}</code></pre>
</div>
<p>The <code>toString</code> method provides a string representation of the hash table's contents. Since we cannot directly determine which positions in the underlying array contain values, we utilize <code>Object.keys</code> to retrieve an array of keys from the <code>#table</code> object. We then iterate through these keys, constructing a formatted string that displays each key-value pair.</p>
<p>Upon invoking <code>console.log(hashTable.toString())</code>, we observe the following output:</p>
<div><pre><code>{4 =&gt; ygritte@email.com}
{5 =&gt; aethelwulf@email.com}
{7 =&gt; athelstan@email.com}
{8 =&gt; jasmine@email.com}
{9 =&gt; jake@email.com}
{10 =&gt; sargeras@email.com}</code></pre>
</div>
<p>In his example, Jonathan, Jamie, Sue, and Aethelwulf all share the same hash value of 5. Due to the nature of our current hash table implementation, Aethelwulf, being the last added, occupies position 5. The values for Jonathan, Jamie, and Sue have been overwritten. Similar overwriting occurs for keys with other colliding hash values.</p>
<p>Losing values due to collisions is undesirable in a hash table. The purpose of this data structure is to preserve all key-value pairs. To address this issue, we need collision resolution techniques. There are several approaches, including <strong>separate chaining</strong>, <strong>linear probing</strong>, and <strong>double hashing</strong>, we will explore the first two in detail.</p>


<h3 data-number="9.5.7">Handling collisions with separate chaining technique</h3>
<p>Separate chaining is a widely used technique to handle collisions in hash tables. Instead of storing a single value at each index (bucket) of the hash table, separate chaining allows each bucket to hold a <em>linked list</em> (or another similar data structure) of values. When a collision occurs (multiple keys hash to the same index), the new key-value pair is simply appended to the linked list at that index.</p>
<p>To visualize this concept, let's consider the code used for testing in the previous section. If we were to apply separate chaining and represent the resulting structure diagrammatically, the output would resemble the following:</p>
<figure>
<img src="img/file62.png" alt="A hash table with separate chaining technique" width="1209" height="591"/><figcaption aria-hidden="true">A hash table with separate chaining technique</figcaption>
</figure>
<p>In this representation, position 5 would contain a linked list with four elements, while positions 7 and 10 would each hold linked lists with two elements. Positions 4, 8, and 9 would each house linked lists with a single element. This illustrates how separate chaining effectively handles collisions by storing multiple key-value pairs in linked lists within the same bucket.</p>
<p>There are some advantages of using the separate chaining technique:</p>
<ul>
<li>Handles collisions gracefully by not overwriting data when collisions occur.</li>
<li>The implementation is relatively straightforward to code compared to other collision resolution techniques.</li>
<li>Linked lists have dynamic size and can grow as needed, accommodating more collisions without requiring a hash table resize.</li>
<li>As long as the chains (linked lists) remain relatively short, search, insertion, and deletion operations remain efficient (close to <em>O(1)</em> in the average case), meaning it has satisfactory performance.</li>
</ul>
<p>And as any technique, it also has some drawbacks:</p>
<ul>
<li>Extra memory overhead as linked lists require additional memory.</li>
<li>In the worst case, if many keys hash to the same index, the linked list could become long, impacting performance.</li>
</ul>
<p>To demonstrate the practical application of separate chaining, let's create a new data structure called <code>HashTableSeparateChaining</code>. This implementation will focus primarily on the put, get, and remove methods, showcasing how separate chaining enhances collision handling within a hash table. To implement separate chaining in our hash table, we begin with the following code, housed within the <code>src/08-dictionary-hash/hash-table-separate-chaining.js</code> file:</p>
<div><pre><code>const LinkedList = require('../06-linked-list/linked-list');
class HashTableSeparateChaining {
  #table = [];
} </code></pre>
</div>
<p>This initial code snippet accomplishes two key tasks:</p>
<ol>
<li>It imports the <code>LinkedList</code> class from another file (<code>../06-linked-list/linked-list.js</code>) we previously created in <em>Chapter 6, Linked Lists</em>.</li>
<li>It also defines the <code>HashTableSeparateChaining</code> class, which will encapsulate our hash table functionality. The class has a private property <code>#table</code>, initialized as an empty array. This array will serve as the backbone of our hash table, with each element acting as a bucket that can potentially store a linked list of key-value pairs.</li>
</ol>
<p>The subsequent steps will involve filling in the core methods (<code>put</code>, <code>get</code>, and <code>remove</code>) that leverage linked lists to efficiently handle collisions and manage key-value pairs within the hash table.</p>

<h4 data-number="9.5.7.1">Putting a key and a value with separate chaining technique</h4>
<p>Let's implement the first method, the put method using the separate chaining technique as follows:</p>
<div><pre><code>put(key, value) {
  if (key != null &amp;&amp; value != null) {
    const index = this.hash(key);
    if (this.#table[index] == null) {
      this.#table[index] = new LinkedList();
    }
    this.#table[index].append({key, value});
    return true;
  }
  return false;
}</code></pre>
</div>
<p>The put method in our <code>HashTableSeparateChaining</code> class is responsible for inserting or updating key-value pairs. Its first step is to validate the input, ensuring both the key and value are not <code>null</code> or <code>undefined</code>.</p>
<p>Next, we compute the hash code (index) using the hash function. This index determines the bucket where the key-value pair should be stored.</p>
<p>We then check if the bucket at the calculated index is empty. If it is, a new <code>LinkedList</code> is created to store values at this index. This is the core of separate chaining: using linked lists to accommodate multiple values that hash to the same index.</p>
<p>Finally, the key-value pair, encapsulated as an object <code>{key, value}</code>, is appended to the linked list at the specified index. If the key already exists in the linked list, its associated value is updated. The method returns <code>true</code> upon successful insertion or update, and <code>false</code> if the key or value is invalid.</p>


<h4 data-number="9.5.7.2">Retrieving a value with separate chaining technique</h4>
<p>Now, let's implement the get method to retrieve a value from our <code>HashTableSeparateChaining</code> class based on a given key:</p>
<div><pre><code>get(key) {
  const index = this.hash(key);
  const linkedList = this.#table[index];
  if (linkedList != null) {
    linkedList.forEach((element) =&gt; {
      if (element.key === key) {
        return element.value;
      }
    });
  }
  return undefined; // key not found
}</code></pre>
</div>
<p>In this method, we first hash the provided key to determine its corresponding index in the hash table. We then access the linked list stored at that index.</p>
<p>If there is a linked (<code>linkedList != null</code>), we iterate through its elements using a <code>forEach</code> loop, passing a callback. For each element in the linked list, we compare its key property to the input key. If we find a match, we return the corresponding value property of that element.</p>
<p>If the key is not found within the linked list, or if the linked list at the calculated index is empty, the method returns <code>undefined</code> to indicate that the key was not present in the hash table.</p>
<p>By incorporating the linked list structure and traversal, this <code>get</code> method effectively handles potential collisions caused by multiple keys hashing to the same index, ensuring that we retrieve the correct value even in the presence of collisions.</p>

<h5 data-number="9.5.7.2.1">The LinkedList forEach method</h5>
<p>Since our previous <code>LinkedList</code> class lacked a <code>forEach</code> method, we will need to add it for the efficient traversal required in the <code>HashTableSeparateChaining</code> class's get method.</p>
<p>Here is the implementation of the <code>forEach</code> method for the <code>LinkedList</code> class:</p>
<div><pre><code>forEach(callback) {
  let current = this.#head;
  let index = 0;
  while (current) {
    callback(current.data, index);
    current = current.next;
    index++;
  }
}</code></pre>
</div>
<p>The <code>current</code> variable keeps track of the current node in the list. It starts at the head of the list (<code>this.#head</code>). The loop continues as long as there are nodes left to process (<code>current is not null</code>). In each iteration, the provided <code>callback</code> function is called, passing the element stored in the current node and its index as arguments. The <code>current</code> variable is updated to the next node in the list, moving the iteration forward.</p>



<h4 data-number="9.5.7.3">Removing a value with separate chaining technique</h4>
<p>Removing a value from the <code>HashTableSeparateChaining</code> instance presents a slight variation compared to the previous <code>remove</code> method we implemented. Due to the utilization of linked lists, we now need to specifically target and remove the element from the relevant linked list within the hash table.</p>
<p>Let's analyze the implementation of the <code>remove</code> method:</p>
<div><pre><code>remove(key) {
  const index = this.hash(key);
  const linkedList = this.#table[index];
  if (linkedList != null) {
    const compareFunction = (a, b) =&gt; a.key === b.key;
    const toBeRemovedIndex = linkedList.indexOf({key}, compareFunction);
    if (toBeRemovedIndex &gt;= 0) {
      linkedList.removeAt(toBeRemovedIndex);
      if (linkedList.isEmpty()) {
        this.#table[index] = undefined;
      }
      return true;
    }
  }
  return false; // key not found
}</code></pre>
</div>
<p>We begin by calculating the hash code (<code>index</code>) for the given key, similar to the <code>get</code> method. It then retrieves the linked list stored at that index. If the linked list exists (<code>linkedList != null</code>), we define a comparison function (<code>compareFunction</code>) that will be used to identify the element to be removed. This function compares the keys of two objects (<code>a</code> and <code>b</code>).</p>
<p>Next, we use the <code>indexOf</code> method of the linked list to find the index of the element we want to remove. The <code>indexOf</code> method takes the element to search for (<code>{key}</code>) and the comparison function as arguments. If the element is found, <code>indexOf</code> returns its index; otherwise, it returns -1.</p>
<p>If the element is found (<code>toBeRemovedIndex &gt;= 0</code>), we remove it from the linked list using the <code>removeAt</code> method, which removes the element at the specified index.</p>
<p>After removing the element, we check if the linked list is now empty. If it is, we set the corresponding bucket in the hash table (<code>this.#table[index]</code>) to <code>undefined</code>, effectively removing the empty linked list. Finally, we return <code>true</code> to indicate successful removal.</p>
<p>If the key is not found within the linked list, or if the linked list at the calculated index is empty, we return <code>false</code>, signaling that the key was not present in the hash table.</p>
<p>By incorporating linked list removal logic, this enhanced <code>remove</code> method seamlessly integrates with the separate chaining approach, enabling efficient removal of key-value pairs even in the presence of collisions. Next, let's delve into a different technique to handle collisions.</p>



<h3 data-number="9.5.8">Handling collisions with the linear probing technique</h3>
<p>Linear Probing is another technique to handle collisions in hash tables, differing from separate chaining in its approach to storing multiple key-value pairs with the same hash code.</p>
<p>Instead of using linked lists, linear probing directly stores all key-value pairs in the hash table array itself. When a collision occurs, linear probing sequentially searches for the next available empty slot in the array, starting from the original hash index.</p>
<p>The following diagram demonstrates this process:</p>
<figure>
<img src="img/file63.png" alt="A hash table with linear probing technique" width="774" height="529"/><figcaption aria-hidden="true">A hash table with linear probing technique</figcaption>
</figure>
<p>Let's consider a scenario where our hash table already contains several values. When adding a new key-value pair, we calculate the hash for the new key. If the corresponding position in the table is vacant, we can directly insert the value at that index. However, if the position is occupied, we initiate a <em>linear probe</em>. We increment the index by one and check the next position. This process continues until we find an available slot or determine that the table is full.</p>
<p>Linear probing offers a simple and space-efficient collision resolution mechanism. However, it can lead to clustering, where consecutive occupied slots decrease performance as the table fills up.</p>
<p>To illustrate linear probing in practice, we will develop a new data structure called <code>HashTableLinearProbing</code>. This class will reside in the <code>src/08-dictionary-hash/hash-table-linear-probing.js</code> file. We begin by defining the basic structure:</p>
<div><pre><code>class HashTableLinearProbing {
  #table = [];
} </code></pre>
</div>
<p>This initial structure mirrors the <code>HashTable</code> class, with a private property <code>#table</code> initialized as an empty array to store key-value pairs. However, we will override the <code>put</code>, <code>get</code>, and <code>remove</code> methods to incorporate the linear probing technique for collision resolution. This modification will fundamentally alter how the hash table handles situations where multiple keys hash to the same index, demonstrating a distinct approach compared to separate chaining.</p>

<h4 data-number="9.5.8.1">Putting a key and a value with linear probing technique</h4>
<p>Now, let's implement the first of our three core methods: the <code>put</code> method. This method is responsible for inserting or updating key-value pairs within the hash table, incorporating the linear probing technique for collision resolution:</p>
<div><pre><code>put(key, value) {
  if (key != null &amp;&amp; value != null) {
    let index = this.hash(key);
    // linear probing to find an empty slot
    while (this.#table[index] != null) {
      if (this.#table[index].key === key) {
        this.#table[index].value = value;
        return true;
      }
      index++;
      index %= this.#table.length;
    }
    this.#table[index] = {key, value};
    return true;
  }
  return false;
}</code></pre>
</div>
<p>We start by ensuring that both the key and value are valid (not <code>null</code>). We then calculate the hash code for the key, which determines the initial position where the value should be stored.</p>
<p>However, if the initial position is already occupied, the linear probing process begins. The method enters a while loop that continues if the current index is occupied by a value. Inside the loop, it first checks if the <code>key</code> at the current index matches the provided <code>key</code>. If so, the value is updated, and <code>true</code> is returned. Otherwise, the index is incremented, and the process wraps around to the beginning of the table if necessary, continuing the search for an empty slot.</p>
<p>Once an empty slot is found, the key-value pair is stored at that index, and <code>true</code> is returned to indicate a successful insertion. If either the key or value is invalid, the method returns <code>false</code>.</p>
<blockquote>
<p>In some programming languages, we need to define the size of the array. One of the concerns of using linear probing is when the array is out of unoccupied positions. When the algorithm reaches the end of the array, it needs to loop back to its beginning and continue iterating its elements - and if necessary, we also need to create a new bigger array and copy the elements to the new array. In JavaScript, we benefit from the dynamic nature of arrays, which can grow automatically as needed. Therefore, we do not have to explicitly manage the table's size or worry about running out of space. This simplifies our implementation and allows the hash table to adapt to the amount of data being stored.</p>
</blockquote>
<p>Let's simulate the insertion process within our hash table using linear probing to handle collisions:</p>
<ol>
<li><strong><em>Ygritte</em></strong>: the hash value for "Ygritte" is 4. Since the hash table is initially empty, we can directly insert it at position 4.</li>
<li><strong><em>Jonathan</em></strong>: the hash value is 5, and position 5 is available, so we insert "Jonathan" there.</li>
<li><strong><em>Jamie</em></strong>: this also hashes to 5, but position 5 is now occupied. We probe to position 6 (5 + 1), which is empty, and insert "Jamie" there.</li>
<li><strong><em>Jack</em></strong>: the hash value is 7, and position 7 is empty, so we insert "Jack" without any collisions.</li>
<li><strong><em>Jasmine</em></strong>: the hash value is 8, and position 8 is available, so "Jasmine" is inserted.</li>
<li>Jake: The hash value is 9, and position 9 is open, allowing us to insert "Jake" without collision.</li>
<li><strong><em>Nathan</em></strong>: with a hash value of 10 and an empty position 10, "Nathan" is inserted smoothly.</li>
<li><strong><em>Athelstan</em></strong>: this also hashes to 7, but position 7 is occupied by "Jack." We probe linearly to positions 8, 9, 10 (all occupied), and finally insert "Athelstan" at the first available position, 11.</li>
<li><strong><em>Sue</em></strong>: hashing to 5, we find positions 5 through 11 occupied. We continue probing and insert "Sue" at position 12.</li>
<li><strong><em>Aethelwulf</em></strong>: similarly hashing to 5, we probe past occupied positions and insert "Aethelwulf" at position 13.</li>
<li><strong><em>Sargeras</em></strong>: the hash value is 10, and positions 10 to 13 are occupied. We probe further and insert "Sargeras" at position 14.</li>
</ol>
<p>This simulation highlights how linear probing resolves collisions by systematically searching for the next available slot in the hash table array. While effective, it is important to note that linear probing can lead to clustering, which can potentially impact the performance of subsequent insertions and retrievals.</p>
<p>Next, let's review how to retrieve a value.</p>


<h4 data-number="9.5.8.2">Retrieving a value with linear probing technique</h4>
<p>Now that our hash table contains elements, let's implement the get method to retrieve values based on their corresponding keys:</p>
<div><pre><code>get(key) {
  let index = this.hash(key);
  while (this.#table[index] != null) {
    if (this.#table[index].key === key) {
      return this.#table[index].value;
    }
    index++;
    index %= this.#table.length;
  }
  return undefined;
}</code></pre>
</div>
<p>To retrieve a value, we first need to determine its location within the hash table. We use the hash function to calculate the initial index for the given key. If the key exists within the hash table, its value should be located either at the initial index or somewhere further along due to potential collisions.</p>
<p>If the initial index is not empty (<code>this.#table[index] != null</code>), we need to verify whether the element at that position matches the key we are searching for. If the keys match, we return the corresponding value immediately.</p>
<p>However, if the keys do not match, it is possible that the desired value has been displaced due to linear probing. We enter a <code>while</code> loop to iterate through subsequent positions in the table, incrementing the index and wrapping around if necessary. The loop continues until either the key is found, or an empty slot is encountered, signaling that the key does not exist.</p>
<p>If, after iterating through the table, the index points to an empty slot (<code>undefined</code> or <code>null</code>), it means the key was not found, and the method returns <code>undefined</code>.</p>
<p>Next, let's review how to remove values using the linear probing technique.</p>


<h4 data-number="9.5.8.3">Removing a value with linear probing technique</h4>
<p>Removing a value from a hash table using linear probing presents a unique challenge compared to other data structures. In linear probing, elements are not necessarily stored at the index directly calculated from their hash value due to potential collisions. Simply deleting the element at the hash index could disrupt the probing sequence and render other elements inaccessible.</p>
<p>To address this, we need a strategy that maintains the integrity of the probe sequence while still removing the desired key-value pair. There are two primary approaches:</p>
<ol>
<li>Soft deletion, also known as tombstone marking.</li>
<li>Hard deletion and rehashing the table.</li>
</ol>
<p>In the soft deletion method, instead of physically removing the element, we mark it as <em>deleted</em> using a special value (often called a tombstone or flag). This value indicates that the slot was previously occupied but is now available for reuse. This method is simple to implement, however, this will gradually deteriorate the hash table's efficiency, as searching for key-values will become slower over time. This method also requires additional logic to handle tombstones during insertion and search operations. The following diagram demonstrates the process of the search operation with soft deletion method:</p>
<figure>
<img src="img/file64.png" alt="Linear probing removal with soft deletion" width="981" height="584"/><figcaption aria-hidden="true">Linear probing removal with soft deletion</figcaption>
</figure>
<p>The second approach, hard deletion, involves physically removing the deleted element and then rehashing all subsequent elements in the probe sequence. This ensures that the probe sequence remains intact for future searches. In this method, there are no wasted spaces due to tombstones and it maintains an optimal probe sequence. However, it can be computationally expensive, especially for large hash tables or frequent deletions. This implementation is also more complex than soft deletion. When searching for a key, this approach prevents finding an empty spot, but if it is necessary to move elements, this means we will need to shift key-values within the hash table. The following diagram exemplifies this process:</p>
<figure>
<img src="img/file65.png" alt="Linear probing removal with rehashing" width="370" height="575"/><figcaption aria-hidden="true">Linear probing removal with rehashing</figcaption>
</figure>
<blockquote>
<p>Both approaches have their pros and cons. For this chapter, we will implement the second approach (rehashing: move one or more elements to a backward position). To check the implementation of the lazy deletion approach (<code>HashTableLinearProbingLazy</code> class), please refer to the source code of this book. The download link for the source code is mentioned in the Preface of the book, or it can also be accessed at <a href="http://github.com/loiane/javascript-datastructures-algorithms">http://github.com/loiane/javascript-datastructures-algorithms</a>.</p>
</blockquote>
<p>Let's see the code for the remove method next.</p>

<h5 data-number="9.5.8.3.1">Implementing the remove method with rehashing</h5>
<p>The <code>remove</code> method in our hash table closely resembles the <code>get</code> method but with a crucial difference. Instead of simply retrieving the value, it deletes the entire key-value pair:</p>
<div><pre><code>remove(key) {
  let index = this.hash(key);
  while (this.#table[index] != null) {
    if (this.#table[index].key === key) {
      delete this.#table[index];
      this.#verifyRemoveSideEffect(key, index);
      return true;
    }
    index++;
    index %= this.#table.length;
  }
  return false;
}</code></pre>
</div>
<p>In the <code>get</code> method, upon finding the key, we returned its value. However, in <code>remove</code>, we use the <code>delete</code> operator to eliminate the element from the hash table. This could be at the original hash position or a different one due to previous collisions.</p>
<p>The challenge arises because we do not know if other elements with the same hash value were placed elsewhere due to a collision. If we simply delete the found element, we might leave gaps in the probe sequence, leading to errors when searching for those displaced elements. To address this, we introduce a helper method, <code>#verifyRemoveSideEffect</code>. This method is responsible for managing the potential side effects of removing an element. Its purpose is to move any collided elements backward in the probe sequence to fill the newly created empty spot, ensuring the integrity of the hash table's structure. This process is also known as rehashing:</p>
<div><pre><code>#verifyRemoveSideEffect(key, removedPosition) {
  const size = this.#table.length;
  let index = removedPosition + 1;
  while (this.#table[index] != null) {
    const currentKey = this.#table[index].key;
    const currentHash = this.hash(currentKey);
    // check if the element should be repositioned
    if (currentHash &lt;= removedPosition) {
      this.#table[removedPosition] = this.#table[index];
      delete this.#table[index];
      removedPosition = index;
    }
    index++;
    index %= size;
  }
}</code></pre>
</div>
<p>We begin by initializing several variables: the <code>key</code> to be removed, the <code>removedPosition</code> where the key-value pair was located, the <code>size</code> of the hash table array, and an <code>index</code> variable to iterate through the table. The index starts at the position immediately after the removed element (<code>removedPosition + 1</code>).</p>
<p>The core of the method lies in a <code>while</code> loop that continues as long as there are elements in the table to examine. In each iteration, the <code>key</code> and its hash value are extracted from the element at the current <code>index</code>.</p>
<p>A crucial condition, <code>currentHash &lt;= removedPosition</code>, is then evaluated. This checks if the element's original hash value (before linear probing) falls within the range of indices from the start of the table up to the <code>removedPosition</code>. If this condition holds <code>true</code>, it implies that the element was originally placed further down the probe sequence due to a collision with the removed element. To rectify this, the element at the current <code>index</code> is moved back to the now-empty <code>removedPosition</code>. Its original position is then cleared, and the <code>removedPosition</code> is updated to the current <code>index</code>. This ensures that subsequent elements in the probe sequence are also considered for repositioning.</p>
<p>The process repeats, incrementing the index and wrapping around if the end of the table is reached, until all potentially affected elements have been checked and repositioned if necessary. By meticulously evaluating the hash values and repositioning elements, we guarantee that the probe sequence remains intact after a removal, ensuring the continued functionality and efficiency of the hash table.</p>
<blockquote>
<p>This is a simplified implementation, as we could add validations for edge cases and optimize the performance. However, this code demonstrates the core logic of how to manage the side effects of removing an element in a hash table with linear probing.</p>
</blockquote>
<p>Let's simulate the removal of "Jonathan" from the hash table we created earlier to demonstrate the process of linear probing with deletion and the subsequent side effect verification.</p>
<ol>
<li><strong><em>Locating and removing Jonathan</em></strong>: we find "Jonathan" at position 5 (hash value 5) and remove it, leaving position 5 empty. Now, we need to assess the side effects of this removal.</li>
<li><strong><em>Evaluating Jamie</em></strong>: we move to position 6, where "Jamie" (also with hash value 5) is stored. Since Jamie's hash value is less than or equal to the removed position (5), we recognize that Jamie was originally placed here due to a collision. We copy Jamie to position 5 and delete the entry at position 6.</li>
<li><strong><em>Skipping Jack and Jasmine</em></strong>: we continue to positions 7 and 8, where "Jack" (hash value 7) and "Jasmine" (hash value 8) are stored. Since their hash values are greater than both the removed position (5) and the current position (6), we determine that they were not affected by Jonathan's removal and should remain in their current positions.</li>
<li>We repeat this evaluation for positions 9 through 11, finding no elements that need repositioning.</li>
<li><strong><em>Repositioning Sue</em></strong>: at position 12, we find "Sue" (hash value 5). Since the hash value is less than or equal to the removed position (5), we copy Sue to position 6 (the originally vacated position) and delete the entry at position 12.</li>
<li><strong><em>Repositioning Aethelwulf and Sargeras</em></strong>: we continue this process for positions 13 and 14, finding that both "Aethelwulf" (hash value 5) and "Sargeras" (hash value 10) need to be moved back. Aethelwulf is copied to position 12, and Sargeras is copied to position 13.</li>
</ol>
<p>By following these steps, the remove method, along with the <code>#verifyRemoveSideEffect</code> helper function, ensures that the removal of "Jonathan" does not leave any gaps in the probe sequence. All elements are repositioned as necessary to maintain the integrity and searchability of the hash table.</p>
<p>In our examples, we deliberately employed the lose-lose hash function to highlight the occurrence of collisions and illustrate the mechanisms for resolving them. However, in practical scenarios, it is crucial to utilize more robust hash functions to minimize collisions and optimize hash table performance. We will delve into better hash function options in the next section.</p>




<h3 data-number="9.5.9">Creating better hash functions</h3>
<p>A well-designed hash function strikes a balance between performance and collision avoidance. It should be fast to calculate for efficient insertion and retrieval of elements, while also minimizing the likelihood of collisions, where different keys produce the same hash code. While numerous implementations exist online, we can also craft our own custom hash function to suit specific needs.</p>
<p>One alternative to the lose-lose hash function is the <code>djb2</code> hash function, known for its simplicity and relatively good performance. Here is its implementation:</p>
<div><pre><code>#djb2HashCode(key) {
  if (typeof key !== 'string') {
    key = this.#elementToString(key);
  }
  const calcASCIIValue = (acc, char) =&gt; (acc * 33) + char.charCodeAt(0);
  const hash = key.split('').reduce((acc, char) =&gt; calcASCIIValue, 5381);
  return hash % 1013;
}</code></pre>
</div>
<p>After transforming the <code>key</code> to a string, the key string is split into an array of individual characters. The <code>reduce</code> method is then employed to iterate over these characters, accumulating their ASCII values. Starting with an initial value of 5381 (a prime number that is the most common found in this algorithm), the reducer multiplies the accumulator by 33 (used as a magical number) and sums the result with the ASCII code of each character, effectively generating a sum of these codes.</p>
<p>Finally, we will use the remainder of the division of the total by another random prime number (1013), greater than the size we think the hash table instance can have. In our scenario, let's consider 1000 as the size.</p>
<p>Let's revisit the insertion scenario from the linear probing section, but this time using the <code>djb2HashCode</code> function instead of <code>loseloseHashCode</code>. The resulting hash codes for the same set of keys would be:</p>
<ul>
<li>807 - Ygritte</li>
<li>288 - Jonathan</li>
<li>962 - Jamie</li>
<li>619 - Jack</li>
<li>275 - Jasmine</li>
<li>877 - Jake</li>
<li>223 - Nathan</li>
<li>925 - Athelstan</li>
<li>502 - Sue</li>
<li>149 - Aethelwulf</li>
<li>711 - Sargeras</li>
</ul>
<p>Notably, we observe no collisions in this scenario. This is due to the improved distribution of hash values provided by the <code>djb2HashCode</code> function compared to the simplistic <code>loseloseHashCode</code>.</p>
<p>While not the absolute best hash function available, <code>djb2HashCode</code> is widely recognized and recommended within the programming community for its simplicity, effectiveness, and relatively good performance in many use cases. Its ability to significantly reduce collisions in this example underscores the importance of selecting an appropriate hash function for your specific data and application requirements.</p>
<p>Now that we have a solid grasp of hash tables, let's revisit the concept of sets and explore how we can leverage hashing to enhance their implementation and create a powerful data structure known as a <strong>hash set</strong>.</p>



<h2 data-number="9.6">The hash set data structure</h2>
<p>A <strong>hash set</strong> is a collection of unique values (no duplicates allowed). It combines the characteristics of a mathematical set with the efficiency of hash tables. Like hash tables, hash sets use a hash function to calculate a hash code for each element (value) we want to store. This hash code determines the index (bucket) where the value should be placed in an underlying array.</p>
<p>We can reuse the code we created in this chapter to create the hash set data structure as well, but with one important detail: we would need to check for duplicate values before the insertion operation.</p>
<p>The benefits of using hash sets are that it is guaranteed that all values in the set are unique. In JavaScript, the native Set class is considered a hash set data structure as well. For example, we could use a hash set to store all the English words (without their definitions).</p>


<h2 data-number="9.7">Maps and TypeScript</h2>
<p>Implementing data structures like maps or hash maps in TypeScript can significantly benefit from the language's static typing capabilities. By explicitly defining types for variables and method parameters, we enhance code clarity, reduce the risk of runtime errors, and enable better tooling support.</p>
<p>Let's examine the TypeScript signature for our <code>HashTable</code> class:</p>
<div><pre><code>class HashTable&lt;V&gt; {
  private table: V[] = [];
  private loseLoseHashCode(key: string): number { }
  hash(key: string): number { }
  put(key: string, value: V): boolean { }
  get(key: string): V { }
  remove(key: string): boolean { }
}</code></pre>
</div>
<p>In this TypeScript implementation, we introduce a generic type parameter <code>&lt;V&gt;</code> to represent the type of values stored in the hash table. This allows us to create hash tables that hold values of any specific type (for example: <code>HashTable&lt;string&gt;</code>, <code>HashTable&lt;number&gt;</code>, and so on). The <code>table</code> property is typed as an array of the generic type <code>V[]</code>, indicating that it stores an array of values of the specified type.</p>
<p>A significant advantage of using TypeScript becomes evident in the <code>loseLoseHashCode</code> method. Since the <code>key</code> parameter is explicitly typed as a <code>string</code>, we no longer need to check its type within the method. The type system guarantees that only strings will be passed as keys, eliminating the need for redundant checks, and streamlining the code:</p>
<div><pre><code>privaye loseLoseHashCode(key: string) {
  const calcASCIIValue = (acc, char) =&gt; acc + char.charCodeAt(0);
  const hash = key.split('').reduce(calcASCIIValue, 0);
  return hash % 37;
}</code></pre>
</div>
<p>By leveraging TypeScript's type system, we enhance the robustness, maintainability, and readability of our hash table implementation, making it easier to reason about and work within larger projects.</p>


<h2 data-number="9.8">Reviewing the efficiency of maps and hash maps</h2>
<p>Let's review the efficiency of each method by reviewing the Big O notation in terms of time of execution:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Dictionary</strong></td>
<td><strong>Hash Table</strong></td>
<td><strong>Separate Chaining</strong></td>
<td><strong>Linear Probing</strong></td>
</tr>
<tr class="even">
<td><code>put(key, value)</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td><em>O(1)*</em></td>
<td><em>O(1)*</em></td>
</tr>
<tr class="odd">
<td><code>get(key)</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td><em>O(1)*</em></td>
<td><em>O(1)*</em></td>
</tr>
<tr class="even">
<td><code>remove(key)</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td><em>O(1)*</em></td>
<td><em>O(1)*</em></td>
</tr>
</tbody>
</table>
<p>For the <code>Dictionary</code> class, all operations are generally <em>O(1)</em> in the average case due to direct access to the underlying object using the stringified key.</p>
<p>For the <code>HashMap</code> class, similar to the dictionary, all operations are typically <em>O(1)</em> in the average case, assuming a good hash function. However, it lacks collision handling, so collisions will cause data loss or overwrite existing entries.</p>
<p>For the <code>HashTableSeparateChaining</code>, in the average case, all operations are still <em>O(1)</em>. Separate chaining effectively handles collisions, so even with some collisions, the linked lists at each index are likely to remain short. In the worst case (all keys hash to the same index), the performance degrades to <em>O(n)</em> as you need to traverse the entire linked list.</p>
<p>Finally, for the <code>HashTableLinearProbing</code>, the average case complexity is also <em>O(1)</em> if the hash table is sparsely populated (low load factor). However, as the load factor increases and collisions become more frequent, linear probing can lead to clustering, where multiple keys are placed in consecutive slots. This can degrade the worst-case performance to <em>O(n)</em>.</p>
<p>Reviewing the execution time, the quality of the hash function significantly affects performance. A good hash function minimizes collisions, keeping performance closer to <em>O(1)</em>. In often cases, separate chaining tends to handle collisions more gracefully than linear probing, especially at higher load factors. In a hash table, the <strong>load factor</strong> is a crucial metric that measures how full the table is. It is defined as:</p>
<p><em>Load Factor = (Number of Elements in the Table) / (Total Number of Buckets)</em></p>
<p>Next, let's review the space complexity of each data structure:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Data Structure</strong></td>
<td><strong>Space Complexity</strong></td>
<td><strong>Explanation</strong></td>
</tr>
<tr class="even">
<td>Dictionary</td>
<td><em>O(n)</em></td>
<td>The space used grows linearly with the number of key-value pairs stored. Each pair occupies space in the underlying object.</td>
</tr>
<tr class="odd">
<td>HashTable</td>
<td><em>O(n)</em></td>
<td>The array has a fixed size, but you still need space for each stored key-value pair. Unused slots also consume space, especially if there are few collisions.</td>
</tr>
<tr class="even">
<td>Separate Chaining</td>
<td><em>O(n + m)</em></td>
<td><em>n</em> is the number of elements, and <em>m</em> is the number of buckets. In addition to the space for elements, each bucket holds a linked list, which adds memory overhead.</td>
</tr>
<tr class="odd">
<td>Linear Probing</td>
<td><em>O(n)</em></td>
<td>Similar to the simple hash table, but linear probing tends to use space more efficiently than separate chaining as there are no linked lists.</td>
</tr>
</tbody>
</table>
<p>Which data structure should we use?</p>
<p>If we store 100 elements in a hash table with 150 buckets:</p>
<ul>
<li><strong><em>Dictionary</em></strong>: space usage is proportional to 100 elements.</li>
<li><strong><em>HashTable</em></strong> (no collision handling): space usage is still for 100 elements, plus potentially wasted space in the remaining 50 empty buckets.</li>
<li><strong><em>HashTableSeparateChaining</em></strong>: space usage is for 100 elements, plus the overhead of the linked lists in each bucket (which could vary depending on how many collisions there are).</li>
<li><strong><em>HashTableLinearProbing</em></strong>: space usage is likely closer to 100 elements, as it tries to fill the array more densely.</li>
</ul>
<p>At the end of the day, it all depends on the scenario we are working with.</p>
<p>Let's put our knowledge into practice with some exercises.</p>


<h2 data-number="9.9">Exercises</h2>
<p>We will resolve one exercise from <strong>LeetCode</strong> using the map data structure to transform integer numbers to roman numbers.</p>
<p>However, there are many fun exercises available in LeetCode that we should be able to resolve with the concepts we learned in this chapter. Below are some additional suggestions you can try to resolve, and you can also find the solution along with the explanation within the source code from this book:</p>
<ul>
<li>1. Two Sum: given an array of integers, find two numbers that add up to a target sum. This is a classic problem that introduces you to using a hash map to store complements and quickly find matches.</li>
<li>242. Valid Anagram: determine if two strings are anagrams of each other (contain the same characters but in a different order). Hash maps are useful for counting character frequencies.</li>
<li>705. Design HashSet: implement the hash set data structure.</li>
<li>706. Design HashMap: implement the hash map data structure.</li>
<li>13. Roman to Integer: similar to the problem we will resolve, but the other way around.</li>
</ul>

<h3 data-number="9.9.1">Integer to Roman</h3>
<p>The exercise we will resolve the is the <em>12. Integer to Roman</em> problem available at <a href="https://leetcode.com/problems/integer-to-roman/description/">https://leetcode.com/problems/integer-to-roman/description/</a>.</p>
<p>When resolving the problem using JavaScript or TypeScript, we will need to add our logic inside the function function intToRoman(num: number): string, which receives a numerical input and returns its corresponding Roman numeral representation as a string.</p>
<p>Let's explore a solution using a map data structure to facilitate the conversion process:</p>
<div><pre><code>function intToRoman(num: number): string {
  const romanMap = {
    M:1000, CM:900, D:500, CD:400, C:100, XC:90,
    L:50, XL:40, X:10, IX:9, V:5, IV:4, I:1
  };
  let result = '';
  for(let romanNum in romanMap){
    while (num &gt;= romanMap[romanNum]) {
      result += romanNum;
      num -= romanMap[romanNum];
    }
  }
  return result;
}</code></pre>
</div>
<p>At the heart of this function lies the <code>romanMap</code>, which acts as a dictionary, associating Roman numeral symbols with their corresponding integer values. This map includes both standard Roman numerals (M, D, C) and special combinations for subtraction (CM, XC). The arrangement of keys in descending order of value is crucial for the greedy algorithm employed in the conversion process so we do not need to sort the data structure before the conversion process.</p>
<p>Next, we initialize an empty string, <code>result</code>, to accumulate the Roman numeral characters. It then enters a loop that iterates through the keys of the <code>romanMap</code>.</p>
<p>Within the loop, a nested <code>while</code> loop repeatedly checks if the input number (<code>num</code>) is greater than or equal to the integer value of the current Roman numeral. If so, the Roman numeral is appended to the <code>result</code> string, and its integer value is subtracted from <code>num</code>. This process continues until <code>num</code> becomes smaller than the value of the Roman numeral, indicating that we need to move on to the next smaller numeral in the map.</p>
<p>By iteratively selecting the largest possible Roman numeral that fits the remaining input value, the function constructs the Roman numeral representation in a <em>greedy</em> manner. Once the entire <code>romanMap</code> has been traversed, the function returns the completed result string, which now holds the accurate Roman numeral equivalent of the original input integer.</p>
<p>The time complexity of this function is <em>O(1)</em>. It iterates over a fixed set of Roman numeral symbols (13 symbols in total). For each symbol, it performs a series of subtractions and concatenations. The number of operations is bounded by the number of symbols and the maximum value of the input number, but since the set of symbols and their values are constant, the operations do not scale with the input size.</p>
<p>The space complexity is also <em>O(1)</em>. The <code>romanMap</code> object is a constant and its size does not change with the input, so it contributes a constant space overhead. The result string grows based on the number of Roman numeral characters needed to represent the input number. However, since the maximum number of characters needed to represent any integer in Roman numerals is fixed (for example: 3999 is MMMCMXCIX), this also contributes a constant space overhead. No additional data structures are used that scale with the input size.</p>
<p>We could also use the native <code>Map</code> class to store the <code>romanMap</code> key-value pairs, however, in the <code>for</code> loop, we would need to extract they keys and sort them first. The <code>Map</code> class does not guarantee the order of keys, so we would need to extract and sort the keys before iterating, which adds overhead. So, in this case, the simplest data structure works in our favour for a more performant solution.</p>



<h2 data-number="9.10">Summary</h2>
<p>In this chapter, we explored the world of dictionaries, mastering the techniques to add, remove, and retrieve elements, while also understanding how they differ from sets. We delved into the concept of hashing, learning how to construct hash tables (or hash maps) and implement fundamental operations like insertion, deletion, and retrieval. Moreover, we learned how to craft hash functions and examined two distinct techniques for handling collisions: separate chaining and linear probing.</p>
<p>We also explored JavaScript's built-in <code>Map</code> class, as well as the specialized <code>WeakMap</code> and <code>WeakSet</code> classes, which offer unique capabilities for memory management. Through a variety of practical examples and a LeetCode exercise, we solidified our understanding of these data structures and their applications.</p>
<p>Equipped with this knowledge, we are now prepared to tackle the concept of <strong>recursion</strong> in the next chapter, paving the way for our exploration of another essential data structure: <strong>trees</strong>.</p>


</div>
</div>
</body>
</html>