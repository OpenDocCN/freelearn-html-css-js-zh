<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Reducing Boilerplate with Plugin Development</h1></div></div></div><div><blockquote class="blockquote"><p>"When working on a web application that involves a lot of JavaScript, one of the first things you learn is to stop tying your data to the DOM. It's all too easy to create JavaScript applications that end up as tangled piles of jQuery selectors and callbacks, all trying frantically to keep data in sync between the HTML UI, your JavaScript logic, and the database on your server. For rich client-side applications, a more structured approach is often helpful."</p></blockquote></div><p>The previous excerpt from <a class="ulink" href="http://backbonejs.org">http://backbonejs.org</a> precisely specifies the problem that Backbone.js solves. Backbone.js<a id="id0" class="indexterm"/> provides a way to simplify the JavaScript application structure, which was clearly a nightmare, even a few years ago. Today, we have moved a long way from tightly coupled jQuery-based applications to heavy frontend applications, and a major portion of the application logic now relies on the UI part. This means organizing the application structure is now one of the most significant aspects of application development, and should take care of the reusability, modularity, and testability of the components of an application.</p><p>Being an extremely lightweight library, Backbone.js, along with the utility library Underscore.js, provides a set of tools that help to organize your code and makes it easier to develop single-page web applications. Backbone delivers a minimalistic solution to separate the concerns of your application; features include RESTful operations, persistent strategies, models, views with logic, event-driven component communication, templating, and routing facilities. Its simplistic nature, excellent documentation, and a large community of developers make it easy to learn how to use this library.</p><p>However, to develop a robust system, we do not depend only on the basic functional components of the framework; we have to use many other libraries, plugins, and reusable add-ons to support the core system as well. While Backbone.js with its core components provides a way to structure your application at the base level, it is really not enough until we either develop our own or use other open source extensions, plugins, and useful patterns. In order to create solid, software architecture, we need to make the best use of existing components and follow proper design patterns. This is what we intend to deliver in this book.</p><p>This is not a general introduction book, and we expect our readers to have a basic understanding of the Backbone.js framework. If you are a beginner and looking for good resources to start with Backbone.js, we will recommend you to refer <a class="link" href="apa.html" title="Appendix A. Books, Tutorials, and References">Appendix A</a>, <em>Books, Tutorials, and References</em>, of this book, where we listed a number of useful resources to help you master Backbone.js.</p><p>We will start with an understanding of how we can re-use our code and reduce a boilerplate by developing custom extensions, plugins, and mixins. In the latter chapters, we will start discussing the common problems, tips, patterns, best practices, and open source plugins for each Backbone.js component. We will also see how we can use Backbone.js to structure and architect complex web applications, and understand the basics of unit testing in JavaScript-based applications. In addition, instead of developing a single application spanning all the chapters, we have tried to provide simple and complete examples on each topic separately throughout this book. In this chapter, we will learn a few important topics with examples. These topics and concepts will be used many times in rest of the chapters. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Basic components of Backbone.js</strong>: This consists of a brief discussion about the definitions of the Backbone components</li><li class="listitem" style="list-style-type: disc"><strong>Use of Underscore.js</strong>: This consists of a brief discussion about Underscore.js and the utility of using this library for JavaScript-based projects</li><li class="listitem" style="list-style-type: disc"><strong>Re-use code with extensions</strong>: This consists of reusing the Backbone code by moving common code blocks to parent-level classes</li><li class="listitem" style="list-style-type: disc"><strong>Backbone mixins</strong>: This consists of an explanation of what mixin is, and how and where to use mixins with Backbone</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Basic components of Backbone.js</h1></div></div></div><p>We will <a id="id1" class="indexterm"/>look into some basic concepts of Backbone.js and Underscore.js before moving to the plugin development section. Backbone.js is a client-side MV* framework that provides a set of tools and building blocks required to structure a JavaScript application. Important tools that Backbone.js offers are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Backbone.Model</code>: Models <a id="id2" class="indexterm"/>are the entity of an application that store data and contain some logic around data such as validation, conversion, and data interaction.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Backbone.View</code>: Views <a id="id3" class="indexterm"/>present an idea of organizing your <strong>Document Object Model</strong> (<strong>DOM</strong>) interface into logical blocks, and represent the model and collection data in them. Views are excellent tools to organize all the JavaScript event handlers and to add dynamic HTML content in your application via optional use of JavaScript templates. As Backbone follows an MV* pattern, Backbone views mostly work as presenters and take care of the major portion of application functionality.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Backbone.Collection</code>: A collection<a id="id4" class="indexterm"/> is a group of models. A collection includes a lot of functionality as well as Underscore utility methods to help you work on multiple data models.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Backbone.Router</code>: A router<a id="id5" class="indexterm"/> provides methods for routing client-side pages and acts subsequently whenever there is a change in the browser's URL. A router maintains the application state as per the URL change.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Backbone.Events</code>: Events<a id="id6" class="indexterm"/> are an important concept in Backbone, since they provide a mechanism to use the PubSub pattern and decouple your application components.</li></ul></div><p>Apart from these, there are other tools such as <code class="literal">Backbone.History</code>, which manages the browser history and the back/forward buttons in accordance with the routers. Also, we have <code class="literal">Backbone.Sync</code>, which is a single method that provides a nice abstraction to the network access through Backbone models and collections.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Using Underscore.js</h1></div></div></div><p>Underscore.js <a id="id7" class="indexterm"/>(<a class="ulink" href="http://underscorejs.org/">http://underscorejs.org/</a>) is<a id="id8" class="indexterm"/> a powerful utility library that provides a lot of functional programming support for your JavaScript code. In general, JavaScript comes up with a very low number of utility methods on its own, and most of the time we need to either develop our own functions or depend on another library for these methods. Underscore comes up with a bagful of highly efficient utility methods, which makes it an excellent tool for your JavaScript projects. The functions<a id="id9" class="indexterm"/> it provides can be grouped into the following sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collections (Array or Object)</li><li class="listitem" style="list-style-type: disc">Arrays</li><li class="listitem" style="list-style-type: disc">Functions</li><li class="listitem" style="list-style-type: disc">Objects</li><li class="listitem" style="list-style-type: disc">Utility</li><li class="listitem" style="list-style-type: disc">Chaining</li></ul></div><p>These include functions for iterations, sorting, filtering, conversions, templating, comparisons, scope binding, and many more. The main benefits<a id="id10" class="indexterm"/> of using this small library are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It helps you to make the JavaScript code more intuitive and concise.</li><li class="listitem" style="list-style-type: disc">In addition to the convenient methods, Underscore also implements cross-browser versions of newer JavaScript functions, which are only available in modern browsers. Underscore will detect whether the browser supports the method, and will use the native implementation if it is present. This boosts the function's performance to a great extent.</li><li class="listitem" style="list-style-type: disc">The minified and<a id="id11" class="indexterm"/> gzipped version of the library weighs only 4.9 KB, which leaves little excuse for not taking advantages of this library.</li><li class="listitem" style="list-style-type: disc">The library is completely DOM-free—so you can use it for your server-side JavaScript code as well.</li><li class="listitem" style="list-style-type: disc">Excellent documentation similar to Backbone.js with examples is available at <a class="ulink" href="http://underscorejs.org/">http://underscorejs.org/</a>.</li></ul></div><p>Backbone.js has a hard dependency on Underscore.js, and you are bound to use it if you are developing your applications with Backbone.js. However, even when you are not using Backbone, we encourage you to use Underscore.js for your JavaScript projects. It adds no overhead, integrates easily, and makes your code more robust even when you are not aware of all the underlying engineering principles employed by this library.</p><p>There is another library <a id="id12" class="indexterm"/>named <code class="literal">Lo-dash</code> (<a class="ulink" href="http://lodash.com">http://lodash.com</a>), which <a id="id13" class="indexterm"/>provides an Underscore built to perform drop-in replacement of the Underscore.js library. It is said to have a slightly better performance than Underscore.js. You can try either of them to achieve the same result.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Re-using code with extensions</h1></div></div></div><p>Backbone is <a id="id14" class="indexterm"/>quite a small library in comparison with other libraries. Any complex application can be structured and developed with Backbone, but the framework itself doesn't come with prebuilt widgets or reusable UI components. In this section, we will talk about some Backbone and JavaScript techniques that will help you build a reusable interface library.</p><p>For simple and small applications, code reusability doesn't always seem much of a necessity. But as you proceed to create an application with multiple views, models, and collections, you find that a certain portion of your code gets repeated several times. Creating reusable extensions and plugins in such cases improves the performance of the application by enhancing modularity and reducing the code size. Let's create a simple Backbone view to understand how we can create an extension, shown in the following code snippet:</p><div><pre class="programlisting">var User = Backbone.Model.extend({
  defaults: {
    name: 'John Doe'
  }
});

var UserItemView = Backbone.View.extend({
  template: '&lt;span&gt;&lt;%= name %&gt;&lt;/span&gt;',
  render: function () {
    var tpl = _.template(this.template),
      html = tpl(this.model.toJSON());

    this.$el.html(html);
    return this;
  }
});

// Create a view instance passing a new model instance
var userItem = new UserItemView({
  model: new User
});

$(document.body).append(userItem.render().el);</pre></div><p>The view <a id="id15" class="indexterm"/>named <code class="literal">UserItemView</code> is a simple Backbone view where we want to display our model data inside a template and append this view element to the DOM. This is a fundamental functionality of Backbone where the primary requirement is to display a model's data as a view. If we have another similar view with a model, and this has the same functionality, the <code class="literal">render()</code> function will also be identical. That said, won't it be beneficial if we move the common code to a base class and extend that class to inherit the functionality? The answer is yes. Let's see how we can do that in the example in the following section.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Creating a base class</h2></div></div></div><p>We<a id="id16" class="indexterm"/> create a <code class="literal">BaseView</code> class where common functionality such as the <code class="literal">render()</code> method is added. Then all other view classes can extend from this base class, and eventually inherit the rendering functionality. The following is the <code class="literal">BaseView</code> class with minimal rendering functionality:</p><div><pre class="programlisting">// Parent view which has the render function
var BaseView = Backbone.View.extend({
  render: function () {
    var tpl = _.template(this.template),
      data = (this.model) ? this.model.toJSON() : {},
      html = tpl(data);

    this.$el.html(html);
    return this;
  }
});</pre></div><p>Now, <code class="literal">UserItemView</code> will look much better. We will extend the <code class="literal">BaseView</code> class and will provide only the template as follows:</p><div><pre class="programlisting">// A simpler view class
var UserItemView = BaseView.extend({
  template: '&lt;span&gt;&lt;%= name %&gt;&lt;/span&gt;'
});</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>If you wish to add some extra functionality such as calling another function in your view's <code class="literal">render()</code> method, you can override the render method of the base class. Check the following example:</p><div><pre class="programlisting">var UserItemView = BaseView.extend({
  tagName: 'div',
  template: '&lt;span&gt;&lt;%= name %&gt;&lt;/span&gt;',
  render: function () {
    // Call the parent view's render function
    BaseView.prototype.render.apply(this, arguments);

    // Add your code here
    this.anotherFn();
    return this;
  },

  anotherFn: function () {}
});</pre></div><p>There are a <a id="id17" class="indexterm"/>number of functionalities that you can move to your base class depending on your requirements. For example, in a non-trivial application, we often need to replace a view with another, destroy the old view by removing it from DOM, and clean up other dependencies. So, we can add a <code class="literal">close()</code> method to <code class="literal">BaseView</code> (as shown in the following code) that can take care of every view removal mechanism.</p><div><pre class="programlisting">var BaseView = Backbone.View.extend({
  render: function () {
    var tpl = _.template(this.template),
      data = (this.model) ? this.model.toJSON() : {},
      html = tpl(data);

    this.$el.html(html);
    return this;
  },

  close: function () {
    // Extra stuff goes here

    // Remove the view
    this.remove();
  }
});
// This is not production-ready code, but it clearly gives you the concept of using custom widgets to reduce boilerplate in your code. It will not always be necessary to extend a Backbone class to create a plugin.</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Developing plugins without extending base classes</h2></div></div></div><p>Sometimes<a id="id18" class="indexterm"/> we find that creating a constructor function and adding methods to its prototype can be a better choice than extending the Backbone base classes. For example, in the <code class="literal">Pagination</code> plugin in the following code, instead of creating a <code class="literal">PaginationCollection</code> class by extending <code class="literal">Backbone.Collection</code>, we will prefer to go for a simpler class—a constructor function that accepts two arguments: a collection and the number of the items to be shown in a page.</p><div><pre class="programlisting">// Pagination constructor function
var Pagination = function (collection, noOfItemsInPage) {
  if (!collection) {
    throw "No collection is passed";
  }
  this.currentPage = 1;
  this.noOfItemsInPage = noOfItemsInPage || 10;
  this.collection = collection;
}

// Use Underscore's extend method to add properties to your plugin
_.extend(Pagination.prototype, {
  nextPage: function () {},
  prevPage: function () {}
});

var User = Backbone.Model.extend({
  defaults: {
    name: 'John Doe'
  }
});

var Users = Backbone.Collection.extend({
  model: User
});

var paging1 = new Pagination(10, new Users());
var paging2 = new Pagination(20, new Users());</pre></div><p>We didn't add the actual functionality, but just showed a skeleton of how the <code class="literal">Pagination</code> class may look. The benefit can be observed when you already have a collection and you <a id="id19" class="indexterm"/>want to implement pagination without extending a parent collection class. We added the member variables in constructor function so that individual instances of this class can have their own set of variables. On the other hand, the methods are added to the prototype of the class so that they are shared by all instances of the class.</p><p>This mechanism can be useful when you need a custom plugin that is not a type of Backbone view, model, or collection.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Understanding JavaScript mixins</h1></div></div></div><p>In the previous <a id="id20" class="indexterm"/>section, we saw that inheriting properties from a parent class prototype provides a great deal of reusability. In some cases, we may want to re-use similar methods in multiple views, models, or collections. This can be achieved by creating a parent class that they can extend; however, it is not always a good practice as it creates some unnecessary layers and meaningless subtypes.</p><p>For example, assume that you want the view element of <code class="literal">UserItemView</code>, which already extends <code class="literal">BaseView</code>, to be draggable. So you include a <code class="literal">DraggableView</code> class that extends the <code class="literal">BaseView</code> class, and your <code class="literal">UserItemView</code> extends <code class="literal">DraggableView</code>. Now there is a sudden change in the requirement and you are asked to make the view named <code class="literal">UserItemView</code> a sortable view as well. Will you introduce another new class, <code class="literal">SortableView</code>, and put it somewhere in the chain? If yes, then this multitiered inheritance will surely create a logic that is absolutely unmanageable and frustrating. Look at the following figure that describes the situation in a better way:</p><div><img src="img/3576_01_01.jpg" alt="Understanding JavaScript mixins"/></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>What is a mixin?</h2></div></div></div><p>Fortunately, there is a feasible alternative in JavaScript, which is called <strong>m</strong>
<strong>ixin</strong>. In general computer science, a mixin<a id="id21" class="indexterm"/> is a class that provides a set of functions relating to a particular type. These mixin classes are not instantiated, but their functions are just copied to the main class to achieve a similar inheriting behavior without entering into the inheritance chain. Look at the following figure to understand the concept:</p><div><img src="img/3576_01_02.jpg" alt="What is a mixin?"/></div><p>We have a <code class="literal">ListItemView</code> class<a id="id22" class="indexterm"/> that extends the <code class="literal">BaseView</code> class and represents an individual item of a list. Now we want these items to be draggable. How we can achieve this? How about adding a few methods in the <code class="literal">ListItemView</code> class that will take care of the dragging functionality? This approach will work, but what if we have few more components that need to be draggable too? Then we have to make a reusable object with these methods and use that object in all the required classes. This is what the mixin concept is—a collection of methods that will be copied to the class that wants this functionality.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Creating classic mixins</h2></div></div></div><p>The <a id="id23" class="indexterm"/>most <a id="id24" class="indexterm"/>basic mixin definition will be a simple object with some properties such as the following code snippet:</p><div><pre class="programlisting">// A simple object with some methods
var DraggableMixin = {
  startDrag: function () {
    // It will have the context of the main class 
    console.log('Context = ', this);
  },
  onDrag: function () {}
}

// UserItemView already extends BaseView
var UserItemView = BaseView.extend({
  tagName: 'div',
  template: '&lt;%= name %&gt;'
});</pre></div><p>We will <a id="id25" class="indexterm"/>use the Underscore method, <code class="literal">_.extend()</code>, to copy the mixin properties to the main class's prototype:</p><div><pre class="programlisting">// We just copy the Mixin's properties into the View
_.extend(UserItemView.prototype, DraggableMixin, {
  otherFn: function () {}
});

var itemView = new UserItemView();

// Call the mixin's method
itemView.startDrag();</pre></div><p>Note that<a id="id26" class="indexterm"/> the drag-related methods are now copied from <code class="literal">DraggableMixin</code> to its prototype. Similarly, we can use the same <code class="literal">_.extend()</code> method to copy the methods of <code class="literal">SortableMixin</code> to implement the sortable behavior without creating any multilayered inheritance.</p><p>Sometimes <a id="id27" class="indexterm"/>you may not want to copy all the methods of a mixin in your class. In that case, simply create a property in your class and copy the required function from the mixin in that property:</p><div><pre class="programlisting">UserItemView.prototype.startDrag = DraggableMixin.startDrag;</pre></div><p>This is helpful when you need only a part of the functionality from the mixin.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Creating functional mixins</h2></div></div></div><p>There<a id="id28" class="indexterm"/> are<a id="id29" class="indexterm"/> some other ways of defining a mixin too. The following is an example of a functional pattern:</p><div><pre class="programlisting">// Functional mixin
var DraggableMixin = function (config) {
  this.startDrag = function () {};
  this.onDrag = function () {};

  return this;
}

// DraggableMixin method is called passing the config object 
DraggableMixin.call(UserItemView.prototype, {
  foo: 'bar'
});
// SortableMixin.call(UserItemView.prototype);

new UserItemView().startDrag();</pre></div><p>The mixin here <a id="id30" class="indexterm"/>works as a verb, and this <a id="id31" class="indexterm"/>functional approach is well accepted in the community. The <code class="literal">this</code> function always refers to the receiver, that is, <code class="literal">UserItemView</code>. The functionality is exactly same but with a major difference—the <code class="literal">_.extend()</code> method is no longer needed and the mixin methods are not copied this time but are cloned instead. This is not a major problem—just the functions are redefined every time the mixin is used. However, this can also be minimized by caching the functions within the mixin. Let's see how we can achieve that in the next section.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Caching mixin functions</h3></div></div></div><p>We can <a id="id32" class="indexterm"/>cache the initial function definitions by wrapping up the mixin in a closure:</p><div><pre class="programlisting">// Functional mixin with cache
var DraggableMixin = (function () {
  var startDrag = function () {};
  var onDrag = function () {};

  return function (config) {
    this.startDrag = startDrag;
    this.onDrag = onDrag;

    return this;
  };
})(); </pre></div><p>The closure executes only once to define the methods even if the mixin is called several times. However, it raises another concern—inside the mixin methods, how are we going to use the <code class="literal">config</code> object that we are passing? This issue can be resolved by using an interesting pattern named <code class="literal">curry</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Using curry to combine a function and arguments</h3></div></div></div><p>As described by <em>Douglas Crockford</em> in his book <em>Javascript: The Good Parts</em>:</p><div><blockquote class="blockquote"><p>"Currying allows us to produce a new function by combining a function and an argument."</p></blockquote></div><p>Assume that you <a id="id33" class="indexterm"/>have a function and a set of arguments. You want these arguments to be combined with the function someway, so that when you will call that function without passing anything, the arguments will still be available to the function. See the following example:</p><div><pre class="programlisting">// Simple function
function foo(){
  console.log(arguments);
}


// We want this bar object to be available in the foo() function
var bar = {
  name: 'Saswata Guha'
};

// Calling foo() without passing anything. Using curry, the 
// function will have the bar object in its scope
foo();  </pre></div><p>The <code class="literal">curry()</code> pattern's definition<a id="id34" class="indexterm"/> is quite simple where this method is added to the function prototype, so when it is called on any function, it merges the arguments passed to itself with the arguments of the main function, as shown in the following code snippet:</p><div><pre class="programlisting">// Definition of curry
Function.prototype.curry = function () {
  var slice = Array.prototype.slice,
    args = slice.apply(arguments),
    that = this;
  return function () {
    return that.apply(null, args.concat(slice.apply(arguments)));
  };
};</pre></div><p>Now let's see how we can apply <code class="literal">curry</code> to our <code class="literal">DraggableMixin</code> function, so that the <code class="literal">config</code> object is available to all its methods, as shown in the following code snippet:</p><div><pre class="programlisting">// Functional mixin with cache
var DraggableMixin = (function () {
  var startDrag = function (options) {
    console.log('Options = ', options);
  };
  var onDrag = function () {};

  return function (config) {
    this.startDrag = startDrag.curry(config);
    this.onDrag = onDrag;

    return this;
  };
})();

DraggableMixin.call(UserItemView.prototype, {
  foo: 'bar'
});</pre></div><p>So, when we call <code class="literal">curry</code> on the <code class="literal">startDrag()</code> method<a id="id35" class="indexterm"/>, we pass the <code class="literal">config</code> object that we received while applying mixin, and it becomes available to <code class="literal">startDrag</code> as an argument. You can use either the classic or functional approaches for defining a mixin, though I personally prefer the latter.</p><p>Mixin is an <a id="id36" class="indexterm"/>important concept that many popular JavaScript libraries such as Sencha and Dojo follow. While the concept is quite easy, finding a proper context in an application to use a mixin is bit difficult. However, once you are aware of its use, you may soon find it beneficial to enforce reusability in your application.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>If you ever checked the annotated source code (<a class="ulink" href="http://backbonejs.org/docs/backbone.html">http://backbonejs.org/docs/backbone.html</a>) of Backbone, you might have found that the library footprint is very small (the production file is only 6.4 KB at v1.1.0). Its sole purpose is to improve the structure and maintainability of your code with the least complexity. So, once you start using Backbone, you will find that in every step of the development, you need to write custom widgets and plugins. In this chapter, we learned the basics of Backbone.js and the utility of using Underscore.js with Backbone.js. We also saw how developing reusable components and custom pugins can reduce boilerplate from our code. In the end, we understood the concept of JavaScript plugins and discussed different approaches for defining mixins. We are going to use all these concepts several times in the following chapters.</p><p>In the next chapter, we will discuss different problems associated with Backbone views and possible solutions to them. We will also see how custom-view plugins or mixins can solve most of the problems.</p></div></body></html>