- en: Securing Cloud-Native Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Securing your cloud account
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a federated identity pool
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing sign up, sign in, and sign out
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing an API Gateway with OpenID Connect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom authorizer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorizing a GraphQL-based service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a JWT filter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using envelope encryption
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SSL certificate for encryption in transit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a web application firewall
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating the data lake for disaster recovery
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security in the cloud is based on the shared responsibility model. Below a certain
    line in the stack is the responsibility of the cloud provider and above that line
    is the responsibility of the cloud consumer. Cloud-native and serverless computing
    push that line higher and higher. This allows teams to focus their efforts on
    what they know best—their business domains. With the security mechanisms provided
    by the cloud, teams can practice *security-by-design* and concentrate on *defense-in-depth*
    techniques to secure their data. In each recipe, so far, we have seen how serverless
    computing requires us to define security policies between components at each layer
    in the stack. The recipes in this chapter will cover securing our cloud accounts,
    securing our applications with OAuth 2.0/Open ID Connect, securing our data at
    rest, and creating a perimeter around our cloud-native systems by delegating aspects
    of security to the edge of the cloud.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Securing your cloud account
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything we do to secure our cloud-native systems is all for nothing if we
    do not endeavor to secure our cloud accounts as well. There is a set of best practices
    that we must put in place for every cloud account we create. As we strive to create
    autonomous services, we should leverage the natural bulkhead between cloud accounts
    by grouping related services into more, fine-grained accounts instead of fewer,
    coarse-grained accounts. In this recipe, we will see how treating accounts as
    code enables us to manage many accounts easily by applying the same infrastructure-as-code
    practices we employ to manage our many autonomous services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Navigate to the `cncb-account-as-code` directory with `cd cncb-account-as-code`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Update `accountNumber` in `serverless.yml`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the dependencies with `npm install`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncomment `cfnRole` and then deploy again with the `force` flag with `npm run
    dp:lcl -- -s $MY_STAGE --force`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every account I create starts off with the same essential security settings
    using a `serverless.yml`, such as the one in this recipe. I create no other stacks
    in the account until this account-scoped stack is created. All further changes,
    other than creating users, are delivered as changes to this stack. The first responsibility
    of this stack is to turn on `CloudTrail`. In [Chapter 7](64a4c0f7-3b2d-4638-a52c-f72953ff66d9.xhtml),
    *Optimizing Observability*, we will see how we can use this audit trail to monitor
    and alert about unexpected changes to security policies. `AuditBucket` is also
    a candidate for replicating to the recovery account as discussed in the *Replicating
    the data lake for disaster recovery* recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建的每个账户都使用`serverless.yml`文件开始，例如本食谱中的文件。在创建此账户范围堆栈之前，我不会在账户中创建其他堆栈。除创建用户之外的所有进一步更改都作为对此堆栈的更改交付。此堆栈的首要责任是启用`CloudTrail`。在第7章*优化可观察性*中，我们将看到如何使用此审计跟踪来监控和警报关于安全策略意外更改的情况。"AuditBucket"也是复制到恢复账户的候选者，如*复制数据湖以进行灾难恢复*食谱中讨论的那样。
- en: Next, the stack creates the user groups that will be used for granting permissions
    to all users of the account. The `AdminUserGroup`, `PowerUserGroup`, and `ReadOnlyUserGroup` groups
    are a good starting point, along with using the managed policies provided by AWS.
    As the usage of the account matures, these groups will evolve using the same approach
    discussed in [Chapter 6](390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml), *Building
    a Continuous Deployment Pipeline*. However, only the security policies are codified.
    The assignment of users to groups is a manual process that should follow an appropriate
    approval process. The stack includes the `MfaOrHqRequired`, policy to require
    **Multi-Factor Authentication** (**MFA**) and whitelist the corporate IP addresses,
    but it is disabled initially. It should certainly be enabled for all production
    accounts. In a development account, most developers are assigned to the power
    user group, so that they can freely experiment with cloud services. The power
    user group has no IAM permissions, so an optional `ManageAccessKey` policy is
    included to allow power users to manage their access keys. Note, it is very important
    to control the usage of access keys and frequently rotate them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，堆栈创建用于授予所有账户用户权限的用户组。`AdminUserGroup`、`PowerUserGroup`和`ReadOnlyUserGroup`组是一个良好的起点，同时使用AWS提供的托管策略。随着账户使用的成熟，这些组将使用第6章中讨论的相同方法进行演变，即*构建持续部署管道*。然而，只有安全策略被编码化。用户到组的分配是一个手动过程，应该遵循适当的审批流程。堆栈包括`MfaOrHqRequired`策略，要求**多因素认证**（**MFA**）并允许企业IP地址白名单，但最初是禁用的。对于所有生产账户，肯定应该启用它。在开发账户中，大多数开发者被分配到高级用户组，这样他们可以自由地实验云服务。高级用户组没有IAM权限，因此包含一个可选的`ManageAccessKey`策略，允许高级用户管理他们的访问密钥。请注意，控制访问密钥的使用并频繁轮换它们非常重要。
- en: When executing a `serverless.yml` file, we need an access key. As an added security
    measure, CloudFormation supports the use of a service role that allows CloudFormation
    to assume a specific role with temporary credentials. Using the `cfnRole` attribute
    in a `serverless.yml` file enables this feature. This stack creates an initial
    `CloudFormationServiceRole` that should be used by all stacks. As the account
    matures, this role should be tuned to the least possible privileges. The `ExecuteCloudFormationPolicy`
    included only has enough permissions to execute a `serverless.yml` file. This
    policy will be used by `CiCdUser`, which we will use in [Chapter 6](390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml),
    *Building a Continuous Deployment Pipeline*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`serverless.yml`文件时，我们需要一个访问密钥。作为额外的安全措施，CloudFormation支持使用服务角色，允许CloudFormation假定具有临时凭证的特定角色。使用`serverless.yml`文件中的`cfnRole`属性启用此功能。此堆栈创建一个初始的`CloudFormationServiceRole`，所有堆栈都应使用此角色。随着账户的成熟，此角色应调整到尽可能少的权限。包含的`ExecuteCloudFormationPolicy`只有足够的权限来执行`serverless.yml`文件。此策略将由`CiCdUser`使用，我们将在第6章*构建持续部署管道*中使用它。
- en: Creating a federated identity pool
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建联合身份池
- en: Managing users is a requirement of virtually every system. Over a long career,
    I can certainly attest to creating identity management functionality over and
    over again. Fortunately, we can now get this functionality as a service from many
    providers, including our cloud providers. And because there are so many options
    available, we need a federated solution that delegates to many other identity
    management systems while presenting a single, unified model to our cloud-native
    system. In this recipe, we will show how to create an *AWS Cognito user pool*,
    which we will then use in other recipes to secure our services.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Navigate to the `cncb-cognito-pool` directory with `cd cncb-cognito-pool`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Install the dependencies with `npm install`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access `loginURL` from the stack output to verify that the user pool was created
    successfully.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be referencing this user pool in other recipes in this chapter, so remove
    this stack after you are finished with this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe simply codifies the creation of an AWS Cognito user pool. Like any
    other infrastructure resource, we want to treat it as code and manage it in a
    continuous delivery pipeline. For this recipe, we define the bare essentials.
    You will want to define any additional attributes that you want the pool to manage.
    For this recipe, we just specify the `email` attribute.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that these attributes cannot be changed via CloudFormation
    without creating a new user pool, which has a ripple effect on any resources that
    are dependent on the user pool. So, expect to focus some effort on experimenting
    upfront with the right combination of attributes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: For each application that will rely on this user pool, we need to define a `UserPoolClient`.
    Each application would typically define the client in a stack that it manages.
    However, it is important not to overuse a single user pool. Once again this is
    a question of autonomy. If the pool of users and the applications used by those
    users are truly independent, then they should be managed in separate Cognito user
    pools, even if that requires some duplication of effort. For example, if you find
    yourself writing complicated logic using Cognito user groups to segregate users unnaturally,
    then you may be better off with multiple user pools. An example of misuse is mixing
    employees and customers in the same user pool.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation, as of the writing of this chapter, does not have full support
    for the Cognito API. Therefore a plugin is used for the additional settings on
    the `UserPoolClient`, such as `domain`, `callbackUrls`, and `allowedOAuthFlows`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Implementing sign up, sign in, and sign out
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing sign up, sign in, and sign out over and over again is not very
    lean. Implementing this logic in a single-page application is also not desirable.
    In this recipe, we will see how to implement the *OpenID Connect Implicit Flow*
    in a single-page application to authenticate users with the *AWS Cognito Hosted
    UI*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Navigate to the `cncb-cognito-signin` directory with `cd cncb-cognito-signin`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `src/App.js` with the following content and update the
    `clientId` and `domain` fields with the values from the `userPool` stack output
    in the previous recipe:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Review the file named `src/Home.js` with the following content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Install the dependencies with `npm install`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app locally with `npm start`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to `http://localhost:3000`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Sign Up` link and follow the instructions.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Sign Out` link and then `Sign In` again.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the `idToken` displayed on the page.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use these screens to create a valid `idToken` in the authorization recipes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding sign up, sign in, and sign out to a single-page app is very straightforward.
    We include some additional libraries, initialize them with the proper configurations,
    and decorate the existing code. In this recipe, we make these changes to our simple
    example React application. AWS provides the `amazon-cognito-auth-js` library to
    simplify this task and we wrap it in some React components in `src/authenticate`
    folder. First, we initialize the `CognitoSecurity` component in the `src/App.js`.
    Next, we set up `SecureRoute` for the `Home` component that will redirect to the
    *Cognito hosted UI* if the user is not authenticated. The `ImpicitCallback` component
    will handle the redirect after the user logs in. Finally, we add the `withAuth`
    decorator to the `Home` component. In more elaborate applications, we would just
    be decorating more routes and components. The framework handles everything else,
    such as saving the **JSON Web Token** (**JWT**) to local storage and making it
    available for use in the `auth` property. For example, the `Home` component displays
    the tokens (`auth.getSession()`) and provides a logout button (`auth.logout`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Securing an API Gateway with OpenID Connect
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using an API Gateway is that we are pushing security
    concerns, such as authorization, to the perimeter of our system and away from
    our internal resources. This simplifies the internal code and improves scalability.
    In this recipe, we will configure an *AWS API Gateway* to authorize against an
    *AWS Cognito user pool*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Navigate to the `cncb-cognito-authorizer` directory with `cd cncb-cognito-authorizer`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Install the dependencies with `npm install`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to attempt
    to access the service without an `Authorization` token:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use the app in the previous recipe to sign in and generate `idToken`, and then
    export `idToken` with the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to access the
    service successfully with an `Authorization` token:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The combination of the AWS API Gateway, AWS Cognito, and the Serverless Framework
    make securing a service with OpenID Connect extremely straightforward. The AWS
    API Gateway can use authorizer functions to control access to a service. These
    functions verify the JWT passed in the `Authorization` header and return an IAM
    policy. We will delve into these details in the *Implementing a custom authorizer*
    recipe. AWS Cognito provides an authorizer function that verifies the JWTs generated
    by a specific user pool. In the `serverless.yml` file, we simply need to set `authorizer`
    to the `userPoolArn` of the specific Cognito user pool. Once authorized, the API
    Gateway passes the decode `claims` from the JWT along to the lambda function in
    the `requestContext`, so this data can be used in the business logic, if needs
    be.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom authorizer
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Securing an API Gateway with OpenID Connect* recipe, we leveraged the
    Cognito authorizer that is provided by AWS. This is one of the advantages of using
    Cognito. However, this is not the only option. Sometimes we may want more control
    over the policy that is returned. In other cases, we may need to use a third-party
    tool such as *Auth0* or *Okta*. In this recipe, we will show how to support these
    scenarios by implementing a custom authorizer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Navigate to the `cncb-custom-authorizer` directory with `cd cncb-custom-authorizer`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Review the file named `handler.js` with the following content:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Install the dependencies with `npm install`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to attempt
    to access the service without an `Authorization` token:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the app in the *Implementing sign up, sign in, and sign out* recipe to
    sign in and generate `idToken`, and then export `idToken` with the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to access the
    service successfully with an `Authorization` token:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process for connecting a custom authorizer to the API Gateway is the same
    as with the Cognito authorizer. We can implement the `authorizer` function in
    the same project, as we have in this recipe, or it can be implemented in another
    stack so that it can be shared across services. The `jwks-rsa` and `jsonwebtoken`
    open source libraries implement the bulk of the logic. First, we assert the presence
    of the token and `decode` it. Next, we use the key ID (`kid`) that is present
    in the decoded token to retrieve the `.well-known/jwks.json` public key for the
    issuer. Then, we verify the signature of the token against the key and assert
    that the audience (`aud`) and issuer (`iss`) are as expected. Finally, the function
    returns an IAM policy that grants access to the service based on the path. The
    `claims` of the token are also returned in the `context` field so that they can
    be forwarded to the backend function. If any validations fail then we return an
    `Unauthorized` error.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The claims object must be flattened, otherwise `AuthorizerConfigurationException`
    is thrown.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing a GraphQL-based service
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use a *JWT* to authorize access to services. In addition
    to this coarse-grained access control, we can also leverage the claims in the
    JWT to perform fine-grained, role-based access control. In this recipe, we will
    show how to use directives to create annotations that are used to define role-based
    permissions declaratively in a GraphQL schema.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
    You will need to assign the `Author` group, via the Cognito Console, to the user
    that you will use in this recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Navigate to the `cncb-graphql-jwt` directory with `cd cncb-graphql-jwt`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Review the `index.js`, `schema/thing/typedefs.js`, and `directives.js` files
    with the following content:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Install the dependencies with `npm install`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the app in the *Implementing sign up, sign in, and sign out* recipe to
    sign in and generate `idToken`, and then export `idToken` with the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Invoke the following `curl` commands, after updating `<API-ID>`, to successfully
    access the service with an `Authorization` token:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service is configured with a Cognito `authorizer` that verifies the token
    and forwards `claims`. These `claims` include the `groups` that the user is a
    member of. At design time, we want to define the roles declaratively that are
    required to access privileged actions. In GraphQL, we can annotate a `schema`
    using `directives`. In this recipe, we define a `hasRole` directive and implement
    a `resolver` that checks the allowed `roles` defined in the annotation against `groups`
    present in the claims, and then it either allows or denies access. The `resolver`
    logic is decoupled from `schema` and the annotations in `schema` are straightforward
    and clean.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a JWT filter
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use a JWT to authorize access to services and how we can
    use the claims in the token to perform fine-grained, role-based authorization
    on actions within a service. We usually need to control access at the data instance
    level as well. For example, a customer should only have access to his or her data,
    or an employee should only have access to the data for a specific division. To
    accomplish this, we typically adorn filters to queries based on the user's entitlements.
    In a RESTful API, this information is usually included in the URL as path parameters
    as well. It is typical to use path parameters to perform queries.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: However, we want to use the claims in the JWT to perform filters instead, because
    the values in the token are asserted by the authenticity of the token signature.
    In this recipe, we will demonstrate how to use the claims in the JWT to create
    query filters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Navigate to the `cncb-jwt-filter` directory with `cd cncb-jwt-filter`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Review the file named `handler.js` with the following content:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Install the dependencies with `npm install`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the app in the *Implementing sign up, sign in, and sign out* recipe to
    sign in and generate `idToken`, and then export `idToken` with the following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Invoke the following `curl` commands, after updating `<API-ID>`, to access
    data successfully within the restrictions of the  `Authorization` token:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Take a look at the logs:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client of an API can use any values to formulate a URL, but it cannot tamper
    with the content of the JWT token because the issuer has signed the token. Therefore,
    we need to override any request values with the values from the token. In this
    recipe, we are saving and retrieving data for a specific user as determined by
    the subject or subclaim in the user's token. The service is configured with an
    `authorizer` that verifies the token and forwards `claims`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the example, the subject is used as the `HASH` key and the data
    `uuid` as the `RANGE` key. When the data is retrieved, we assert the query parameter
    against the value in the token and return a `401` `statusCode` if they do not
    match. If they match, we use the value from the token in the actual query to guard
    against any bugs in the assertion logic that could inadvertently return unauthorized
    data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Using envelope encryption
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting data at rest is critical for most systems. We must ensure the privacy
    of our customer's data and of our corporate data. Unfortunately, we all too often
    turn on disk-based encryption and then check off the requirement as complete.
    However, this only protects the data when the disk is disconnected from the system.
    When the disk is connected, then the data is automatically decrypted when it is
    read from disk. For example, create a DynamoDB table with server-side encryption
    enabled and then create some data and view it in the console. So long as you have
    permission, you will be able to see the data in clear text. To truly ensure the
    privacy of data at rest, we must encrypt data at the application level and effectively
    redact all sensitive information. In this recipe, we use the AWS **Key Management
    Service** (**KMS**) and a technique called *envelope encryption* to secure data
    at rest in a DynamoDB table.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Navigate to the `cncb-envelope-encryption` directory with `cd cncb-envelope-encryption`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Review the file named `handler.js` with the following content:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Install the dependencies with `npm install`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following `curl` commands, after updating `<API-ID>`, to encrypt
    and decrypt data:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Review the encrypted data in the DynamoDB Console.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the logs:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: KMS is not included in the AWS free tier.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Envelope encryption is, in essence, the practice of encrypting one key with
    another key; sensitive data is encrypted with a data key and then the data key
    is encrypted with a master key. In this recipe, the `save` function encrypts the
    data before saving it to DynamoDB, and the `get` function decrypts the data after
    retrieving it from DynamoDB and before returning the data to the caller. In the
    `serverless.yml` file, we define a KMS `MasterKey` and a `MasterKeyAlias`. The
    alias facilitates the rotation of the master key. The `save` function calls `kms.generateDataKey`
    to create a data key for the object. Each object gets its own data key and a new
    key is generated each time the object is saved. Again, this practice facilitates
    key rotation. Following the *security-by-design* practice, we identify which fields
    are sensitive as we design and develop a service. In this recipe, we encrypt all of the
    fields individually. The data key is used to encrypt each field locally using
    an `AES` encryption library. The data key was also encrypted by the master key
    and returned to the `CyphertextBlob` field when the data key was generated. The
    encrypted data key is stored alongside the data so that it can be decrypted by
    the `get` function. The `get` function has direct access to the encrypted data
    key once the data has been retrieved from the database. The `get` function has
    been granted permission to call `kms.decrypt` to decrypt the data key. This piece
    of the puzzle is crucial. Access to the master key must be restricted as per the
    least privilege principle. The fields are decrypted locally using an AES encryption
    library so that they can be returned to the caller.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SSL certificate for encryption in transit
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting data in transit is critical for systems with sensitive data, which
    accounts for most systems these days. Fully managed cloud services, such as function-as-a-service,
    cloud-native databases, and API Gateways, encrypt data in transit as a matter
    of course. This helps ensure that our data in motion is secured across the full
    stack, with little to no effort on our part. However, we ultimately want to expose
    our cloud-native resources via custom domain names. To do this and support SSL,
    we must provide our own SSL certificates. This process can be tedious and we must
    ensure that we rotate certificates in a timely manner before they expire and cause
    a system outage. Fortunately, more and more cloud providers are offering fully
    managed certificates that are automatically rotated. In the recipe, we will use
    the *AWS Certificate Manager* to create a certificate and associate it with a
    *CloudFront* distribution.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a registered domain name and a Route 53 hosted zone that you can
    use in this recipe to create a subdomain for the site that will be deployed, and
    you will need authority to approve the creation of the certificate or access to
    someone with the authority.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Navigate to the `cncb-ssl-cert` directory with `cd cncb-ssl-cert`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Update the `serverless.yml` file with your `hostedZoneId` and  `validationDomain`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the dependencies with `npm install`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To complete this step, an authorized person is needed to receive the certificate
    approval request email and approve the creation of the certificate. The CloudFormation
    stack will appear to pause until the certificate is approved.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Review the stack and resources in the AWS Console.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following `curl` command with the `WebsiteURL` from the stack output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the resources section of the `serverless.yml` file, we define the `WildcardCertificate`
    resource to instruct the AWS Certificate Manager to create the desired certificate.
    We create a wildcard certificate so that it can be used by many services. It is
    important to specify the correct `validationDomain`, because this will be used
    to request approval before creating the certificate. You must also provide `hostedZoneId`
    for the top-level domain name. Everything else is handled by the `serverless-spa-config`
    plugin. The recipe deploys a simple site consisting of an `index.html` page. The
    `endpoint` for the site is used to create a Route 53 record set in the hosted
    zone and is assigned as the alias of the site's CloudFront distribution. The wildcard
    certificate matches the endpoint and its `acmCertificateArn` is assigned to the
    distribution. Ultimately, we can access `WebsiteURL` with the `https` protocol
    and the custom domain name.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a web application firewall
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **web application firewall** (**WAF**) is an important tool for controlling
    the traffic of a cloud-native system. A WAF protects the system by blocking traffic
    from common exploits such as bad bots, SQL injection, **Cross-Site Scripting**
    (**XSS**), HTTP floods, and known attackers. We effectively create a perimeter
    around the system that blocks traffic at the edge of the cloud before it can impact
    system resources. We can use many of the techniques in this book to monitor internal
    and external resources and dynamically update the firewall rules as the flow of
    traffic changes. Managed rules are also available on the market, so we can leverage
    the extensive security expertise of third parties. In this recipe, we will demonstrate
    how the pieces fit together by creating a rule to block traffic from outside a
    corporate network and associate the WAF with a *CloudFront* distribution.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Navigate to the `cncb-waf` directory with `cd cncb-waf`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Determine your corporate external public IP address by logging in to your VPN
    and then executing the following command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过登录VPN并执行以下命令来确定您的企业外部公共IP地址：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Update `WhitelistIPSet` in the `serverless.yml` file with your IP address followed
    by `/32`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`serverless.yml`文件中更新`WhitelistIPSet`，后跟你的IP地址和`/32`。
- en: Install the dependencies with `npm install`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装依赖项。
- en: Run the tests with `npm test`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test`运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看在`.serverless`目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署堆栈：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中查看堆栈和资源。
- en: Browse to the `WebsiteDistributionURL` listed in the stack outputs while connecting
    to your VPN and you will be able to access the page.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接VPN的同时浏览堆栈输出中列出的`WebsiteDistributionURL`，您将能够访问该页面。
- en: Now, disconnect from the VPN and you will be denied access to the page once
    the cache has cleared.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，断开VPN连接，一旦缓存清除，您将无法访问页面。
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成使用`npm run rm:lcl -- -s $MY_STAGE`后，请移除堆栈。
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing to note is that usage of the AWS WAF is predicated on using
    CloudFront. The `serverless-spa-config` plugin creates the CloudFront distribution
    and assigns `webACLId`. For this recipe, we are securing a simple `index.html`
    page. We create a static `WebACL` to block everything except a single IP address.
    We define the `WhitelistIPSet` for the single address and associate it with `WhitelistRule`.
    Then, we associate the rule with an **access control list** (**ACL**) and define
    the default action to `BLOCK` all access, and then an action to `ALLOW` access
    based on `WhitelistRule`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，使用AWS WAF的前提是使用CloudFront。`serverless-spa-config`插件创建CloudFront分布并分配`webACLId`。对于这个配方，我们正在保护一个简单的`index.html`页面。我们创建一个静态的`WebACL`来阻止除单个IP地址之外的所有内容。我们为单个地址定义`WhitelistIPSet`并将其与`WhitelistRule`关联。然后，我们将规则与访问控制列表（ACL）关联，并将默认操作定义为`BLOCK`所有访问，然后基于`WhitelistRule`定义一个允许访问的操作。
- en: This example is useful, but it only scratches the surface of what is possible.
    For example, we could uncomment the logging configuration for the CloudFront distribution
    and then process the access logs and dynamically create rules based on suspicious
    activity. On a daily basis, we can retrieve public reputation lists and update
    the rule sets as well. Defining and maintaining effective rules can be a full-time
    effort, therefore the fully managed rules that are available on the AWS marketplace
    are an attractive alternative for, or companion to, custom rules.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例很有用，但它只是触及了可能性的表面。例如，我们可以取消注释CloudFront分布的日志配置，然后根据可疑活动处理访问日志并动态创建规则。在日常生活中，我们还可以检索公共声誉列表并更新规则集。定义和维护有效的规则可能是一项全职工作，因此AWS市场上可用的完全管理的规则是自定义规则的有吸引力的替代品或补充。
- en: Replicating the data lake for disaster recovery
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制数据湖以进行灾难恢复
- en: When I first read this story about Code Spaces ([https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html](https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html)),
    I was a bit horrified until I realized that this company perished so that we could all learn
    from its experience. Code Spaces was a company that used AWS and their account
    was hijacked and held to ransom. They fought back and the entire contents of their
    account were deleted, including their backups, and they simply went out of business.
    Proper use of MFA and proper access key hygiene is critical to ward off such attacks.
    It is also crucial to maintain backups as an entirely separate and disconnected
    account, so that the breach of a single account does not spell disaster for an
    entire system and company. In this recipe, we will use the S3 replication feature
    to replicate buckets to a dedicated recovery account. At a minimum, this technique
    should be used to replicate the contents of the data lake, since the events in
    the data lake can be replayed to recreate the system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the source and recovery projects from the following templates:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Navigate to the `cncb-dr-recovery-account` directory with `cd cncb-dr-recovery-account`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Install the dependencies with `npm install`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Navigate to the `cncb-dr-src1-account` directory with `cd cncb-dr-src1-account`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Install the dependencies with `npm install`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Review the stacks and buckets in the AWS Console.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following command to load data:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Review the contents of both buckets to see that the data has replicated.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove each stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS S3 does all the heavy lifting of replicating the contents of one bucket
    to another. We just have to define what and where we want to replicate and set
    up all the permissions correctly. It is important to replicate to a separate account
    that is completely disconnected from any other accounts to ensure that a breach
    in another account does not impact the recovery account. To simplify this recipe,
    we will use a single account, but this does not change the CloudFormation templates
    other than the account number value. It is also a good idea to replicate into
    a region that you are not otherwise using, so that an outage in one of your regions
    does not also mean there is an outage in your recovery region. Next, we need to
    create a corresponding bucket in the recovery account for every source bucket
    that we want to replicate. It is a good idea to use a naming convention with prefixes
    and/or suffixes to differentiate the source bucket easily from the destination
    bucket. All of the buckets must turn on versioning to support replication. The
    source buckets grant permission to the S3 service to perform the replication,
    and the destination buckets grant permission to the source account to write to
    the recovery account. We also transfer ownership of the replicated contents to
    the recovery account. Ultimately, if the contents are completely deleted from
    the source bucket, the destination bucket will still contain the contents along
    with the deletion marker.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: AWS S3负责将一个存储桶的内容复制到另一个存储桶的所有繁重工作。我们只需定义要复制的内容和位置，并正确设置所有权限即可。将数据复制到完全与任何其他账户断开连接的单独账户中非常重要，以确保另一个账户的漏洞不会影响恢复账户。为了简化这个流程，我们将使用单个账户，但这并不会改变除了账户编号值之外的CloudFormation模板。将数据复制到您通常不使用的区域也是一个好主意，这样您某个区域的故障就不会导致您的恢复区域也出现故障。接下来，我们需要为每个要复制的源存储桶在恢复账户中创建相应的存储桶。使用前缀和/或后缀的命名约定来轻松区分源存储桶和目标存储桶是一个好主意。所有存储桶都必须开启版本控制以支持复制。源存储桶授予S3服务执行复制的权限，而目标存储桶授予源账户向恢复账户写入的权限。我们还把复制的文件内容的所有权转让给恢复账户。最终，如果源存储桶中的内容被完全删除，目标存储桶仍然会包含这些内容以及删除标记。
