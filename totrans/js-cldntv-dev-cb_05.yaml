- en: Securing Cloud-Native Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing your cloud account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a federated identity pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing sign up, sign in, and sign out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing an API Gateway with OpenID Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom authorizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorizing a GraphQL-based service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a JWT filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using envelope encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SSL certificate for encryption in transit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a web application firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating the data lake for disaster recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security in the cloud is based on the shared responsibility model. Below a certain
    line in the stack is the responsibility of the cloud provider and above that line
    is the responsibility of the cloud consumer. Cloud-native and serverless computing
    push that line higher and higher. This allows teams to focus their efforts on
    what they know best—their business domains. With the security mechanisms provided
    by the cloud, teams can practice *security-by-design* and concentrate on *defense-in-depth*
    techniques to secure their data. In each recipe, so far, we have seen how serverless
    computing requires us to define security policies between components at each layer
    in the stack. The recipes in this chapter will cover securing our cloud accounts,
    securing our applications with OAuth 2.0/Open ID Connect, securing our data at
    rest, and creating a perimeter around our cloud-native systems by delegating aspects
    of security to the edge of the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your cloud account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything we do to secure our cloud-native systems is all for nothing if we
    do not endeavor to secure our cloud accounts as well. There is a set of best practices
    that we must put in place for every cloud account we create. As we strive to create
    autonomous services, we should leverage the natural bulkhead between cloud accounts
    by grouping related services into more, fine-grained accounts instead of fewer,
    coarse-grained accounts. In this recipe, we will see how treating accounts as
    code enables us to manage many accounts easily by applying the same infrastructure-as-code
    practices we employ to manage our many autonomous services.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-account-as-code` directory with `cd cncb-account-as-code`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Update `accountNumber` in `serverless.yml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Review the stack and resources in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncomment `cfnRole` and then deploy again with the `force` flag with `npm run
    dp:lcl -- -s $MY_STAGE --force`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every account I create starts off with the same essential security settings
    using a `serverless.yml`, such as the one in this recipe. I create no other stacks
    in the account until this account-scoped stack is created. All further changes,
    other than creating users, are delivered as changes to this stack. The first responsibility
    of this stack is to turn on `CloudTrail`. In [Chapter 7](64a4c0f7-3b2d-4638-a52c-f72953ff66d9.xhtml),
    *Optimizing Observability*, we will see how we can use this audit trail to monitor
    and alert about unexpected changes to security policies. `AuditBucket` is also
    a candidate for replicating to the recovery account as discussed in the *Replicating
    the data lake for disaster recovery* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the stack creates the user groups that will be used for granting permissions
    to all users of the account. The `AdminUserGroup`, `PowerUserGroup`, and `ReadOnlyUserGroup` groups
    are a good starting point, along with using the managed policies provided by AWS.
    As the usage of the account matures, these groups will evolve using the same approach
    discussed in [Chapter 6](390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml), *Building
    a Continuous Deployment Pipeline*. However, only the security policies are codified.
    The assignment of users to groups is a manual process that should follow an appropriate
    approval process. The stack includes the `MfaOrHqRequired`, policy to require
    **Multi-Factor Authentication** (**MFA**) and whitelist the corporate IP addresses,
    but it is disabled initially. It should certainly be enabled for all production
    accounts. In a development account, most developers are assigned to the power
    user group, so that they can freely experiment with cloud services. The power
    user group has no IAM permissions, so an optional `ManageAccessKey` policy is
    included to allow power users to manage their access keys. Note, it is very important
    to control the usage of access keys and frequently rotate them.
  prefs: []
  type: TYPE_NORMAL
- en: When executing a `serverless.yml` file, we need an access key. As an added security
    measure, CloudFormation supports the use of a service role that allows CloudFormation
    to assume a specific role with temporary credentials. Using the `cfnRole` attribute
    in a `serverless.yml` file enables this feature. This stack creates an initial
    `CloudFormationServiceRole` that should be used by all stacks. As the account
    matures, this role should be tuned to the least possible privileges. The `ExecuteCloudFormationPolicy`
    included only has enough permissions to execute a `serverless.yml` file. This
    policy will be used by `CiCdUser`, which we will use in [Chapter 6](390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml),
    *Building a Continuous Deployment Pipeline*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a federated identity pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing users is a requirement of virtually every system. Over a long career,
    I can certainly attest to creating identity management functionality over and
    over again. Fortunately, we can now get this functionality as a service from many
    providers, including our cloud providers. And because there are so many options
    available, we need a federated solution that delegates to many other identity
    management systems while presenting a single, unified model to our cloud-native
    system. In this recipe, we will show how to create an *AWS Cognito user pool*,
    which we will then use in other recipes to secure our services.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-cognito-pool` directory with `cd cncb-cognito-pool`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Review the stack and resources in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access `loginURL` from the stack output to verify that the user pool was created
    successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be referencing this user pool in other recipes in this chapter, so remove
    this stack after you are finished with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe simply codifies the creation of an AWS Cognito user pool. Like any
    other infrastructure resource, we want to treat it as code and manage it in a
    continuous delivery pipeline. For this recipe, we define the bare essentials.
    You will want to define any additional attributes that you want the pool to manage.
    For this recipe, we just specify the `email` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that these attributes cannot be changed via CloudFormation
    without creating a new user pool, which has a ripple effect on any resources that
    are dependent on the user pool. So, expect to focus some effort on experimenting
    upfront with the right combination of attributes.
  prefs: []
  type: TYPE_NORMAL
- en: For each application that will rely on this user pool, we need to define a `UserPoolClient`.
    Each application would typically define the client in a stack that it manages.
    However, it is important not to overuse a single user pool. Once again this is
    a question of autonomy. If the pool of users and the applications used by those
    users are truly independent, then they should be managed in separate Cognito user
    pools, even if that requires some duplication of effort. For example, if you find
    yourself writing complicated logic using Cognito user groups to segregate users unnaturally,
    then you may be better off with multiple user pools. An example of misuse is mixing
    employees and customers in the same user pool.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation, as of the writing of this chapter, does not have full support
    for the Cognito API. Therefore a plugin is used for the additional settings on
    the `UserPoolClient`, such as `domain`, `callbackUrls`, and `allowedOAuthFlows`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing sign up, sign in, and sign out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing sign up, sign in, and sign out over and over again is not very
    lean. Implementing this logic in a single-page application is also not desirable.
    In this recipe, we will see how to implement the *OpenID Connect Implicit Flow*
    in a single-page application to authenticate users with the *AWS Cognito Hosted
    UI*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-cognito-signin` directory with `cd cncb-cognito-signin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `src/App.js` with the following content and update the
    `clientId` and `domain` fields with the values from the `userPool` stack output
    in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the file named `src/Home.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app locally with `npm start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to `http://localhost:3000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Sign Up` link and follow the instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Sign Out` link and then `Sign In` again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the `idToken` displayed on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use these screens to create a valid `idToken` in the authorization recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding sign up, sign in, and sign out to a single-page app is very straightforward.
    We include some additional libraries, initialize them with the proper configurations,
    and decorate the existing code. In this recipe, we make these changes to our simple
    example React application. AWS provides the `amazon-cognito-auth-js` library to
    simplify this task and we wrap it in some React components in `src/authenticate`
    folder. First, we initialize the `CognitoSecurity` component in the `src/App.js`.
    Next, we set up `SecureRoute` for the `Home` component that will redirect to the
    *Cognito hosted UI* if the user is not authenticated. The `ImpicitCallback` component
    will handle the redirect after the user logs in. Finally, we add the `withAuth`
    decorator to the `Home` component. In more elaborate applications, we would just
    be decorating more routes and components. The framework handles everything else,
    such as saving the **JSON Web Token** (**JWT**) to local storage and making it
    available for use in the `auth` property. For example, the `Home` component displays
    the tokens (`auth.getSession()`) and provides a logout button (`auth.logout`).
  prefs: []
  type: TYPE_NORMAL
- en: Securing an API Gateway with OpenID Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using an API Gateway is that we are pushing security
    concerns, such as authorization, to the perimeter of our system and away from
    our internal resources. This simplifies the internal code and improves scalability.
    In this recipe, we will configure an *AWS API Gateway* to authorize against an
    *AWS Cognito user pool*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-cognito-authorizer` directory with `cd cncb-cognito-authorizer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Review the stack and resources in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to attempt
    to access the service without an `Authorization` token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the app in the previous recipe to sign in and generate `idToken`, and then
    export `idToken` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to access the
    service successfully with an `Authorization` token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The combination of the AWS API Gateway, AWS Cognito, and the Serverless Framework
    make securing a service with OpenID Connect extremely straightforward. The AWS
    API Gateway can use authorizer functions to control access to a service. These
    functions verify the JWT passed in the `Authorization` header and return an IAM
    policy. We will delve into these details in the *Implementing a custom authorizer*
    recipe. AWS Cognito provides an authorizer function that verifies the JWTs generated
    by a specific user pool. In the `serverless.yml` file, we simply need to set `authorizer`
    to the `userPoolArn` of the specific Cognito user pool. Once authorized, the API
    Gateway passes the decode `claims` from the JWT along to the lambda function in
    the `requestContext`, so this data can be used in the business logic, if needs
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom authorizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Securing an API Gateway with OpenID Connect* recipe, we leveraged the
    Cognito authorizer that is provided by AWS. This is one of the advantages of using
    Cognito. However, this is not the only option. Sometimes we may want more control
    over the policy that is returned. In other cases, we may need to use a third-party
    tool such as *Auth0* or *Okta*. In this recipe, we will show how to support these
    scenarios by implementing a custom authorizer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-custom-authorizer` directory with `cd cncb-custom-authorizer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the file named `handler.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Review the stack and resources in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to attempt
    to access the service without an `Authorization` token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the app in the *Implementing sign up, sign in, and sign out* recipe to
    sign in and generate `idToken`, and then export `idToken` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to access the
    service successfully with an `Authorization` token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process for connecting a custom authorizer to the API Gateway is the same
    as with the Cognito authorizer. We can implement the `authorizer` function in
    the same project, as we have in this recipe, or it can be implemented in another
    stack so that it can be shared across services. The `jwks-rsa` and `jsonwebtoken`
    open source libraries implement the bulk of the logic. First, we assert the presence
    of the token and `decode` it. Next, we use the key ID (`kid`) that is present
    in the decoded token to retrieve the `.well-known/jwks.json` public key for the
    issuer. Then, we verify the signature of the token against the key and assert
    that the audience (`aud`) and issuer (`iss`) are as expected. Finally, the function
    returns an IAM policy that grants access to the service based on the path. The
    `claims` of the token are also returned in the `context` field so that they can
    be forwarded to the backend function. If any validations fail then we return an
    `Unauthorized` error.
  prefs: []
  type: TYPE_NORMAL
- en: The claims object must be flattened, otherwise `AuthorizerConfigurationException`
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing a GraphQL-based service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use a *JWT* to authorize access to services. In addition
    to this coarse-grained access control, we can also leverage the claims in the
    JWT to perform fine-grained, role-based access control. In this recipe, we will
    show how to use directives to create annotations that are used to define role-based
    permissions declaratively in a GraphQL schema.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
    You will need to assign the `Author` group, via the Cognito Console, to the user
    that you will use in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-graphql-jwt` directory with `cd cncb-graphql-jwt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the `index.js`, `schema/thing/typedefs.js`, and `directives.js` files
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Review the stack and resources in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the app in the *Implementing sign up, sign in, and sign out* recipe to
    sign in and generate `idToken`, and then export `idToken` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the following `curl` commands, after updating `<API-ID>`, to successfully
    access the service with an `Authorization` token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service is configured with a Cognito `authorizer` that verifies the token
    and forwards `claims`. These `claims` include the `groups` that the user is a
    member of. At design time, we want to define the roles declaratively that are
    required to access privileged actions. In GraphQL, we can annotate a `schema`
    using `directives`. In this recipe, we define a `hasRole` directive and implement
    a `resolver` that checks the allowed `roles` defined in the annotation against `groups`
    present in the claims, and then it either allows or denies access. The `resolver`
    logic is decoupled from `schema` and the annotations in `schema` are straightforward
    and clean.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a JWT filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use a JWT to authorize access to services and how we can
    use the claims in the token to perform fine-grained, role-based authorization
    on actions within a service. We usually need to control access at the data instance
    level as well. For example, a customer should only have access to his or her data,
    or an employee should only have access to the data for a specific division. To
    accomplish this, we typically adorn filters to queries based on the user's entitlements.
    In a RESTful API, this information is usually included in the URL as path parameters
    as well. It is typical to use path parameters to perform queries.
  prefs: []
  type: TYPE_NORMAL
- en: However, we want to use the claims in the JWT to perform filters instead, because
    the values in the token are asserted by the authenticity of the token signature.
    In this recipe, we will demonstrate how to use the claims in the JWT to create
    query filters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-jwt-filter` directory with `cd cncb-jwt-filter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the file named `handler.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Review the stack and resources in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the app in the *Implementing sign up, sign in, and sign out* recipe to
    sign in and generate `idToken`, and then export `idToken` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the following `curl` commands, after updating `<API-ID>`, to access
    data successfully within the restrictions of the  `Authorization` token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client of an API can use any values to formulate a URL, but it cannot tamper
    with the content of the JWT token because the issuer has signed the token. Therefore,
    we need to override any request values with the values from the token. In this
    recipe, we are saving and retrieving data for a specific user as determined by
    the subject or subclaim in the user's token. The service is configured with an
    `authorizer` that verifies the token and forwards `claims`.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the example, the subject is used as the `HASH` key and the data
    `uuid` as the `RANGE` key. When the data is retrieved, we assert the query parameter
    against the value in the token and return a `401` `statusCode` if they do not
    match. If they match, we use the value from the token in the actual query to guard
    against any bugs in the assertion logic that could inadvertently return unauthorized
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Using envelope encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting data at rest is critical for most systems. We must ensure the privacy
    of our customer's data and of our corporate data. Unfortunately, we all too often
    turn on disk-based encryption and then check off the requirement as complete.
    However, this only protects the data when the disk is disconnected from the system.
    When the disk is connected, then the data is automatically decrypted when it is
    read from disk. For example, create a DynamoDB table with server-side encryption
    enabled and then create some data and view it in the console. So long as you have
    permission, you will be able to see the data in clear text. To truly ensure the
    privacy of data at rest, we must encrypt data at the application level and effectively
    redact all sensitive information. In this recipe, we use the AWS **Key Management
    Service** (**KMS**) and a technique called *envelope encryption* to secure data
    at rest in a DynamoDB table.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-envelope-encryption` directory with `cd cncb-envelope-encryption`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the file named `handler.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Review the stack and resources in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following `curl` commands, after updating `<API-ID>`, to encrypt
    and decrypt data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Review the encrypted data in the DynamoDB Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: KMS is not included in the AWS free tier.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Envelope encryption is, in essence, the practice of encrypting one key with
    another key; sensitive data is encrypted with a data key and then the data key
    is encrypted with a master key. In this recipe, the `save` function encrypts the
    data before saving it to DynamoDB, and the `get` function decrypts the data after
    retrieving it from DynamoDB and before returning the data to the caller. In the
    `serverless.yml` file, we define a KMS `MasterKey` and a `MasterKeyAlias`. The
    alias facilitates the rotation of the master key. The `save` function calls `kms.generateDataKey`
    to create a data key for the object. Each object gets its own data key and a new
    key is generated each time the object is saved. Again, this practice facilitates
    key rotation. Following the *security-by-design* practice, we identify which fields
    are sensitive as we design and develop a service. In this recipe, we encrypt all of the
    fields individually. The data key is used to encrypt each field locally using
    an `AES` encryption library. The data key was also encrypted by the master key
    and returned to the `CyphertextBlob` field when the data key was generated. The
    encrypted data key is stored alongside the data so that it can be decrypted by
    the `get` function. The `get` function has direct access to the encrypted data
    key once the data has been retrieved from the database. The `get` function has
    been granted permission to call `kms.decrypt` to decrypt the data key. This piece
    of the puzzle is crucial. Access to the master key must be restricted as per the
    least privilege principle. The fields are decrypted locally using an AES encryption
    library so that they can be returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SSL certificate for encryption in transit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting data in transit is critical for systems with sensitive data, which
    accounts for most systems these days. Fully managed cloud services, such as function-as-a-service,
    cloud-native databases, and API Gateways, encrypt data in transit as a matter
    of course. This helps ensure that our data in motion is secured across the full
    stack, with little to no effort on our part. However, we ultimately want to expose
    our cloud-native resources via custom domain names. To do this and support SSL,
    we must provide our own SSL certificates. This process can be tedious and we must
    ensure that we rotate certificates in a timely manner before they expire and cause
    a system outage. Fortunately, more and more cloud providers are offering fully
    managed certificates that are automatically rotated. In the recipe, we will use
    the *AWS Certificate Manager* to create a certificate and associate it with a
    *CloudFront* distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a registered domain name and a Route 53 hosted zone that you can
    use in this recipe to create a subdomain for the site that will be deployed, and
    you will need authority to approve the creation of the certificate or access to
    someone with the authority.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-ssl-cert` directory with `cd cncb-ssl-cert`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Update the `serverless.yml` file with your `hostedZoneId` and  `validationDomain`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: To complete this step, an authorized person is needed to receive the certificate
    approval request email and approve the creation of the certificate. The CloudFormation
    stack will appear to pause until the certificate is approved.
  prefs: []
  type: TYPE_NORMAL
- en: Review the stack and resources in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following `curl` command with the `WebsiteURL` from the stack output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the resources section of the `serverless.yml` file, we define the `WildcardCertificate`
    resource to instruct the AWS Certificate Manager to create the desired certificate.
    We create a wildcard certificate so that it can be used by many services. It is
    important to specify the correct `validationDomain`, because this will be used
    to request approval before creating the certificate. You must also provide `hostedZoneId`
    for the top-level domain name. Everything else is handled by the `serverless-spa-config`
    plugin. The recipe deploys a simple site consisting of an `index.html` page. The
    `endpoint` for the site is used to create a Route 53 record set in the hosted
    zone and is assigned as the alias of the site's CloudFront distribution. The wildcard
    certificate matches the endpoint and its `acmCertificateArn` is assigned to the
    distribution. Ultimately, we can access `WebsiteURL` with the `https` protocol
    and the custom domain name.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a web application firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **web application firewall** (**WAF**) is an important tool for controlling
    the traffic of a cloud-native system. A WAF protects the system by blocking traffic
    from common exploits such as bad bots, SQL injection, **Cross-Site Scripting**
    (**XSS**), HTTP floods, and known attackers. We effectively create a perimeter
    around the system that blocks traffic at the edge of the cloud before it can impact
    system resources. We can use many of the techniques in this book to monitor internal
    and external resources and dynamically update the firewall rules as the flow of
    traffic changes. Managed rules are also available on the market, so we can leverage
    the extensive security expertise of third parties. In this recipe, we will demonstrate
    how the pieces fit together by creating a rule to block traffic from outside a
    corporate network and associate the WAF with a *CloudFront* distribution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the project from the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-waf` directory with `cd cncb-waf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Determine your corporate external public IP address by logging in to your VPN
    and then executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Update `WhitelistIPSet` in the `serverless.yml` file with your IP address followed
    by `/32`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Review the stack and resources in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to the `WebsiteDistributionURL` listed in the stack outputs while connecting
    to your VPN and you will be able to access the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, disconnect from the VPN and you will be denied access to the page once
    the cache has cleared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to note is that usage of the AWS WAF is predicated on using
    CloudFront. The `serverless-spa-config` plugin creates the CloudFront distribution
    and assigns `webACLId`. For this recipe, we are securing a simple `index.html`
    page. We create a static `WebACL` to block everything except a single IP address.
    We define the `WhitelistIPSet` for the single address and associate it with `WhitelistRule`.
    Then, we associate the rule with an **access control list** (**ACL**) and define
    the default action to `BLOCK` all access, and then an action to `ALLOW` access
    based on `WhitelistRule`.
  prefs: []
  type: TYPE_NORMAL
- en: This example is useful, but it only scratches the surface of what is possible.
    For example, we could uncomment the logging configuration for the CloudFront distribution
    and then process the access logs and dynamically create rules based on suspicious
    activity. On a daily basis, we can retrieve public reputation lists and update
    the rule sets as well. Defining and maintaining effective rules can be a full-time
    effort, therefore the fully managed rules that are available on the AWS marketplace
    are an attractive alternative for, or companion to, custom rules.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating the data lake for disaster recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first read this story about Code Spaces ([https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html](https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html)),
    I was a bit horrified until I realized that this company perished so that we could all learn
    from its experience. Code Spaces was a company that used AWS and their account
    was hijacked and held to ransom. They fought back and the entire contents of their
    account were deleted, including their backups, and they simply went out of business.
    Proper use of MFA and proper access key hygiene is critical to ward off such attacks.
    It is also crucial to maintain backups as an entirely separate and disconnected
    account, so that the breach of a single account does not spell disaster for an
    entire system and company. In this recipe, we will use the S3 replication feature
    to replicate buckets to a dedicated recovery account. At a minimum, this technique
    should be used to replicate the contents of the data lake, since the events in
    the data lake can be replayed to recreate the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the source and recovery projects from the following templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-dr-recovery-account` directory with `cd cncb-dr-recovery-account`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `cncb-dr-src1-account` directory with `cd cncb-dr-src1-account`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the file named `serverless.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with `npm test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the contents generated in the `.serverless` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Review the stacks and buckets in the AWS Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the following command to load data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Review the contents of both buckets to see that the data has replicated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove each stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS S3 does all the heavy lifting of replicating the contents of one bucket
    to another. We just have to define what and where we want to replicate and set
    up all the permissions correctly. It is important to replicate to a separate account
    that is completely disconnected from any other accounts to ensure that a breach
    in another account does not impact the recovery account. To simplify this recipe,
    we will use a single account, but this does not change the CloudFormation templates
    other than the account number value. It is also a good idea to replicate into
    a region that you are not otherwise using, so that an outage in one of your regions
    does not also mean there is an outage in your recovery region. Next, we need to
    create a corresponding bucket in the recovery account for every source bucket
    that we want to replicate. It is a good idea to use a naming convention with prefixes
    and/or suffixes to differentiate the source bucket easily from the destination
    bucket. All of the buckets must turn on versioning to support replication. The
    source buckets grant permission to the S3 service to perform the replication,
    and the destination buckets grant permission to the source account to write to
    the recovery account. We also transfer ownership of the replicated contents to
    the recovery account. Ultimately, if the contents are completely deleted from
    the source bucket, the destination bucket will still contain the contents along
    with the deletion marker.
  prefs: []
  type: TYPE_NORMAL
