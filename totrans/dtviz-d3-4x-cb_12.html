<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Knowing Your Map</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Projecting the US map</li><li class="listitem" style="list-style-type: disc">Projecting the world map</li><li class="listitem" style="list-style-type: disc">Building a choropleth map</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec82"/>Introduction</h1></div></div></div><p>The ability to project and correlate data points to geographic regions is crucial in many types of visualizations. Geographic visualization is a complex topic with many competing standards emerging and maturing for today's web technology. D3 provides a few different ways to visualize geographic and cartographic data. In this chapter, we will introduce basic D3 cartographic visualization techniques and how to implement a fully-functional choropleth map (a special purpose colored map) in D3.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec83"/>Projecting the US map</h1></div></div></div><p>In this recipe we are going to start with projecting the US map using D3 GEO API, while also getting familiar with a few different JSON data formats for describing geographic data. Let's first take a look at how geographic data are typically presented and consumed in JavaScript.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec250"/>GeoJSON</h2></div></div></div><p>The first standard JavaScript geographic data format we are going to touch upon is called <strong>GeoJSON</strong>. GeoJSON format was originally written and maintained by an Internet working group of developers. Later it was standardized by the <strong>Internet Engineering Task Force</strong> (<strong>IETF</strong>) with RFC 7946 and published in August 2016.</p><div><blockquote class="blockquote"><p>
<em>GeoJSON is a format for encoding a variety of geographic data structures. GeoJSON supports the following geometry types: Point, LineString, Polygon, MultiPoint, MultiLineString, and MultiPolygon. Geometric objects with additional properties are Feature objects. Sets of features are contained by FeatureCollection objects.</em>
</p></blockquote></div><div><blockquote class="blockquote"><p>
<em>Source: <a class="ulink" href="http://www.geojson.org/">http://www.geojson.org/</a>
</em>
</p></blockquote></div><p>GeoJSON format is a very popular standard for encoding GIS information and is supported by numerous open source as well as commercial software. GeoJSON format uses latitude and longitude points as its coordinates; therefore, it requires any software, including D3, to find the proper projection, scale and translation method in order to visualize its data. The following GeoJSON data describes the state of Alabama in feature coordinates:</p><pre class="programlisting">{ 
  "type":"FeatureCollection", 
  "features":[{ 
    "type":"Feature", 
    "id":"01", 
    "properties":{"name":"AL"}, 
    "geometry":{ 
      "type":"Polygon", 
      "coordinates":[[ 
        [-87.359296,35.00118], 
        [-85.606675,34.984749], 
        [-85.431413,34.124869], 
        [-85.184951,32.859696], 
        ... 
        [-88.202745,34.995703], 
        [-87.359296,35.00118] 
      ]] 
  }] 
} 
</pre><p>GeoJSON is currently the de facto GIS information standard for JavaScript project and is well supported by D3; however, before we jump right into D3 geographic visualization using this data format, we want to also introduce you to another emerging technology closely related to GeoJSON.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec29"/>TopoJSON</h3></div></div></div><div><blockquote class="blockquote"><p>
<em>TopoJSON is an extension of GeoJSON that encodes topology. Rather than representing geometries discretely, geometries in TopoJSON files are stitched together from shared line segments called arcs. This technique is similar to Matt Bloch's MapShaper and the Arc/Info Export format, .e00.</em>
</p></blockquote></div><div><blockquote class="blockquote"><p>
<em>TopoJSON Wiki <a class="ulink" href="https://github.com/topojson/topojson">https://github.com/topojson/topojson</a>
</em>
</p></blockquote></div><p>TopoJSON was created by D3's author <em>Mike Bostock</em> originally and designed to overcome some of the drawbacks in GeoJSON while providing a similar feature set when describing geographic information. In most cases concerning cartographic visualization TopoJSON can be a drop-in replacement for GeoJSON with much smaller footprint and better performance. Therefore, in this chapter, we will use TopoJSON instead of GeoJSON. Nevertheless, all techniques discussed in this chapter will work perfectly fine with GeoJSON as well. We will not list TopoJSON example here since its arcs-based format is not very human readable. However, you can easily convert your <strong>shapefiles</strong> (popular open source geographic vector format file) into TopoJSON using ogr2ogr command line tool provided by GDAL (<a class="ulink" href="http://www.gdal.org/ogr2ogr.html">http://www.gdal.org/ogr2ogr.html
</a>).</p><p>Now equipped with this background information let's see how we can make a map in D3.</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec251"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser hosted on your local HTTP server:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter12/usa.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter12/usa.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec252"/>How to do it...</h2></div></div></div><p>In this recipe we will load US TopoJSON data and render them using D3 Geo API. Here is the code sample:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 960, 
            height = 500; 
 
    var projection = d3.geoAlbersUsa(); 
 
    var path = d3.geoPath() 
            .projection(projection); 
 
    var svg = d3.select("body").append("svg") 
            .attr("width", width) 
            .attr("height", height); 
 
    var g = svg.append('g') 
            .call(d3.zoom() 
                    .scaleExtent([1, 10]) 
                    .on("zoom", zoomHandler)); 
 
 
    d3.json("../../data/us.json", function (error, us) { // &lt;- A 
        g.insert("path") 
                .datum(topojson.feature(us, us.objects.land)) 
                .attr("class", "land") 
                .attr("d", path); 
 
        g.selectAll("path.state") 
                    .data(topojson.feature(us,  
                          us.objects.states).features) 
                .enter() 
                    .append("path") 
                    .attr("class", "state") 
                    .attr("d", path); 
    }); 
 
    function zoomHandler() { 
        var transform = d3.event.transform; 
 
        g.attr("transform", "translate(" 
                + transform.x + "," + transform.y 
                + ")scale(" + transform.k + ")"); 
    } 
&lt;/script&gt; 
</pre><p>This recipe projects US map with Albers USA mode:</p><p>
</p><div><img src="img/image_12_001.jpg" alt="How to do it..."/></div><p>
</p><p>US map projected with Albers USA mode</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec253"/>How it works...</h2></div></div></div><p>As you can see, the code required to project a US map using TopoJSON and D3 is quite short, especially the part concerning map projection. This is because both D3 geographic API and TopoJSON library are built explicitly to make this kind of job as easy as possible for developers. To make a map, first you need to load the TopoJSON data file (line <code class="literal">A</code>). The following screenshot shows what the topology data looks like once loaded:</p><p>
</p><div><img src="img/image_12_002.jpg" alt="How it works..."/></div><p>
</p><p>Topology data from TopoJSON</p><p>Once the topology data is loaded, all we have to do is to use the TopoJSON library <code class="literal">topojson.feature</code> function to convert topology arcs into coordinates similar to what GeoJSON format provides as shown in the following screenshot:</p><p>
</p><div><img src="img/5530_12_03_new.jpg" alt="How it works..."/></div><p>
</p><p>Feature collection converted using topojson.feature function</p><p>Then <code class="literal">d3.geo.path</code> will automatically recognize and use the coordinates to generate <code class="literal">svg:path</code> highlighted in the following code snippet:</p><pre class="programlisting">var path = d3.geoPath() // &lt;- A 
            .projection(d3.geoAlbersUsa()); 
... 
g.insert("path") // &lt;-B 
                .datum(topojson.feature(us, us.objects.land)) 
                .attr("class", "land") 
                .attr("d", path); 
 
        g.selectAll("path.state")                        
                 .data(topojson.feature(us, 
                      us.objects.states).features) // &lt;-C 
                .enter() 
                    .append("path") 
                    .attr("class", "state") 
                    .attr("d", path); 
</pre><p>On line <code class="literal">A</code>, we first create a D3 GEO path object configured with Albers USA projection mode. Then we insert a <code class="literal">svg:path</code> that describe the outline of US, since this can be achieved by a single <code class="literal">svg:path</code> element (on line <code class="literal">B</code>). For the outline of each states we use the feature collection generated on line <code class="literal">C</code> to create one <code class="literal">svg:path</code> for each state that allow us to highlight the state on hover. With separate SVG element representing the states will also allow you to respond user interaction like click and touch.</p><p>That's it! This is all you need to do to project a map in D3 using TopoJSON. Additionally, we have also attached a zoom handler to the parent <code class="literal">svg:g</code> element:</p><pre class="programlisting">var g = svg.append('g') 
            .call(d3.zoom() 
                    .scaleExtent([1, 10]) 
                    .on("zoom", zoomHandler)); 
</pre><p>This allows the user to perform simple geometric zoom on our map.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec254"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">GeoJSON v1.0 specification: <a class="ulink" href="http://geojson.org/geojson-spec.html">http://geojson.org/geojson-spec.html</a></li><li class="listitem" style="list-style-type: disc">TopoJSON Wiki: <a class="ulink" href="https://github.com/topojson/topojson/wiki">https://github.com/topojson/topojson/wiki</a></li><li class="listitem" style="list-style-type: disc"><a class="link" href="ch03.html" title="Chapter 3. Dealing with Data">Chapter 3</a>, <em>Dealing with Data</em>, for more information on asynchronous data loading</li><li class="listitem" style="list-style-type: disc"><a class="link" href="ch10.html" title="Chapter 10. Interacting with Your Visualization">Chapter 10</a>, <em>Interacting with Your Visualization</em>, for more information on how to implement zooming</li><li class="listitem" style="list-style-type: disc">Mike Bostock's post on Albers USA projection on which this recipe is based <a class="ulink" href="http://bl.ocks.org/mbostock/4090848">http://bl.ocks.org/mbostock/4090848</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec84"/>Projecting the world map</h1></div></div></div><p>What if our visualization project is not just about US, but rather concerns the whole world? No worries, D3 comes with various built-in projection modes that work well with the world map that we will explore in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec255"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser hosted on your local HTTP server:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter12/world.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter12/world.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec256"/>How to do it...</h2></div></div></div><p>In this recipe we will project the world map using various different D3 built-in projection modes. Here is the code sample:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 300, 
        height = 300, 
        translate = [width / 2, height / 2]; 
 
    var projections = [ // &lt;-A 
        {name: 'geoAzimuthalEqualArea', fn: d3.geoAzimuthalEqualArea() 
                .scale(50) 
                .translate(translate)}, 
        {name: 'geoConicEquidistant', fn: d3.geoConicEquidistant() 
                .scale(35) 
                .translate(translate)}, 
        {name: 'geoEquirectangular', fn: d3.geoEquirectangular() 
                .scale(50) 
                .translate(translate)}, 
        {name: 'geoMercator', fn: d3.geoMercator() 
                .scale(50) 
                .translate(translate)}, 
        {name: 'geoOrthographic', fn: d3.geoOrthographic() 
                        .scale(90) 
                        .translate(translate)}, 
        {name: 'geoStereographic', fn: d3.geoStereographic() 
                                .scale(35) 
                                .translate(translate)} 
    ]; 
 
d3.json("../../data/world-50m.json",  
           function (error, world) { // &lt;-B 
        projections.forEach(function (projection) { 
            var path = d3.geoPath() // &lt;-C 
                    .projection(projection.fn); 
 
            var div = d3.select("body") 
                    .append("div") 
                    .attr("class", "map"); 
 
            var svg = div 
                    .append("svg") 
                    .attr("width", width) 
                    .attr("height", height); 
 
            svg.append("path") // &lt;-D 
                    .datum(topojson.feature(world,  
                             world.objects.land)) 
                    .attr("class", "land") 
                    .attr("d", path); 
 
            svg.append("path") // &lt;-E 
                    .datum(topojson.mesh(world,  
                             world.objects.countries)) 
                    .attr("class", "boundary") 
                    .attr("d", path); 
 
            div.append("h3").text(projection.name); 
        }); 
    }); 
&lt;/script&gt; 
</pre><p>This recipe generates world maps with different projection modes as shown in the following screenshot:</p><p>
</p><div><img src="img/image_12_004.jpg" alt="How to do it..."/></div><p>
</p><p>World map projection</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec257"/>How it works...</h2></div></div></div><p>In this recipe, we first define an array containing six different D3 projection modes on line <code class="literal">A</code>. A world topology data was loaded on line <code class="literal">B</code>. Similar to the previous recipe we have a <code class="literal">d3.geoPath</code> generator defined on line <code class="literal">C</code>. We also customized the projection mode for geo path generator calling its <code class="literal">projection</code> function. The rest of the recipe is almost identical to what we have done in the previous recipe. The <code class="literal">topojson.feature</code> function was used to convert topology data into geographic coordinates so <code class="literal">d3.geoPath</code> can generate <code class="literal">svg:path</code> required for map rendering (line <code class="literal">D</code>). On line <code class="literal">E</code>, one new function <code class="literal">mesh</code> from TopoJSON was used worth mentioning here. <code class="literal">topojson.mesh</code> function returns the GeoJSON <code class="literal">MultiLineString</code> geometry object representing complicated topology. This is a very compact way to render complex geometric shapes since all shared arcs are only included once. In our case since we don't really need to visualize country outline on each continent separately and they are share their borders therefore this is the most efficient option in rendering.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec258"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">D3 wiki Geo Projection page (<a class="ulink" href="https://github.com/d3/d3-geo/blob/master/README.md#projections">https://github.com/d3/d3-geo/blob/master/README.md#projections
</a>) for more information on different projection modes as well as on how raw custom projection can be implemented</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec85"/>Building a choropleth map</h1></div></div></div><p>Choropleth map is a thematic map, in other words, a specially designed map not a general purpose one, which is designed to show measurement of statistical variable on the map using different color shades or patterns; or sometimes referred as geographic heat-map in simpler terms. We have already seen in the previous two recipes that geographic projection in D3 consists of a group of <code class="literal">svg:path</code> elements, therefore, they can be manipulated as any other <code class="literal">svg</code> elements including coloring. We will explore this feature in geo-projection and implement a Choropleth map in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec259"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser hosted on your local HTTP server:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter12/choropleth.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter12/choropleth.html</a>.
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec260"/>How to do it...</h2></div></div></div><p>In a choropleth map different geographic regions are colored according to their corresponding variables, in this case based on 2008 unemployment rate in US by county. Now, let's see how to do it in code:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 960, 
            height = 500; 
 
    var color = d3.scaleThreshold() 
            .domain([.02, .04, .06, .08, .10]) // &lt;-A 
            .range(["#f2f0f7", "#dadaeb", "#bcbddc", 
                    "#9e9ac8", "#756bb1", "#54278f"]); 
 
    var projection = d3.geoAlbersUsa(); 
 
    var path = d3.geoPath() 
            .projection(projection); 
 
    var svg = d3.select("body").append("svg") 
            .attr("width", width) 
            .attr("height", height); 
 
    var g = svg.append("g") 
            .call(d3.zoom() 
            .scaleExtent([1, 10]) 
            .on("zoom", zoomHandler)); 
 
    d3.json("../../data/us.json", function (error, us) { // &lt;-B 
        d3.tsv("../../data/unemployment.tsv", 
                function (error, unemployment) { 
            var rateById = {}; 
 
            unemployment.forEach(function (d) { // &lt;-C 
                rateById[d.id] = +d.rate; 
            }); 
 
            g.append("g") 
                    .attr("class", "counties") 
                    .selectAll("path") 
                    .data(topojson.feature(us, 
                            us.objects.counties).features) 
                    .enter().append("path") 
                    .attr("d", path) 
                    .style("fill", function (d) { 
                        return color(rateById[d.id]); // &lt;-D 
                    }); 
 
            g.append("path") 
                    .datum(topojson.mesh(us, // &lt;-E 
                            us.objects.states, 
                             function(a, b) {  
                                 return a !== b;  
                     }))  
                    .attr("class", "states") 
                    .attr("d", path); 
        }); 
    }); 
 
    function zoomHandler() { 
        var transform = d3.event.transform; 
 
        g.attr("transform", "translate(" 
                + transform.x + "," + transform.y 
                + ")scale(" + transform.k + ")"); 
    } 
&lt;/script&gt; 
</pre><p>This recipe generates the following choropleth map:</p><p>
</p><div><img src="img/image_12_005.jpg" alt="How to do it..."/></div><p>
</p><p>Choropleth Map of 2008 Unemployment Rate</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec261"/>How it works...</h2></div></div></div><p>In this recipe we loaded two different data sets: one for the US topology and the other containing unemployment rate by county in 2008 (line <code class="literal">B</code>). This technique is generally considered as layering and is not necessarily limited to only two layers. The unemployment data are stitched to counties by their ID (line <code class="literal">B</code> and <code class="literal">C</code>). Region coloring is achieved by using a threshold scale defined on line <code class="literal">A</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec262"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">TopoJSON Wiki for more information on mesh function: <a class="ulink" href="https://github.com/topojson/topojson-client#mesh">https://github.com/topojson/topojson-client#mesh
</a></li><li class="listitem" style="list-style-type: disc">D3 Wiki for more information on threshold scale: <a class="ulink" href="https://github.com/d3/d3-scale/blob/master/README.md#scaleThreshold">https://github.com/d3/d3-scale/blob/master/README.md#scaleThreshold
</a></li><li class="listitem" style="list-style-type: disc">Mike Bostock's post on choropleth map which this recipe is based on: <a class="ulink" href="http://bl.ocks.org/mbostock/4090848">http://bl.ocks.org/mbostock/4090848
</a></li></ul></div></div></div></div></div></body></html>