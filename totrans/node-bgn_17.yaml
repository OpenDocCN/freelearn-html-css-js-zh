- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dockerizing a Node.js Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to deploy our application to the public internet
    using Docker. We will explore how we can use GitHub Actions to ensure that our
    Docker images are working well in the **continuous integration** (**CI**) pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to Dockerize the application and publish the image to Docker
    Hub for better portability so we can download our images in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will discuss how to do a proper domain setup and how to add a **Secure
    Sockets Layer** (**SSL**) certificate to the application using Cloudflare. We
    will also explore the Twelve-Factor App principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use GitHub Actions for CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use DigitalOcean Droplet to host the Docker application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Docker to build the application and publish the image to Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do a proper domain setup and add an SSL certificate to the application
    using Cloudflare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the Twelve-Factor App principles and how can they help you grow?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start working on this chapter, we need to continue with the code that we
    uploaded to GitHub in the previous chapter. If you haven’t completed the previous
    chapter you can download the project from [https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip](https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip)
    and access the `step5` folder as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to create accounts with the following providers in order to follow
    the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Hub: [https://hub.docker.com/signup](https://hub.docker.com/signup)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloudflare: [https://www.cloudflare.com/](https://www.cloudflare.com/) (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Checkout the code in action video for this chapter on [https://youtu.be/VWBuF_Q3KPY](https://youtu.be/VWBuF_Q3KPY)
  prefs: []
  type: TYPE_NORMAL
- en: Containers and cloud-native solutions with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using a VM is a good option, it is not the best option for many applications.
    Currently, containers are the most popular way to deploy applications. Containers
    are lightweight, portable, and easy to use. In this section, we will learn how
    to deploy a Node.js application using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the basics of Docker in previous chapters and we have been using
    Docker and Docker Compose to run the MongoDB database. We now need to learn how
    to create a Docker image for our application and how to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Docker lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to have a clear understanding of the Docker lifecycle to use it properly.
    Let’s start with a brief introduction. In the following figure, we can see the
    Docker lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Docker lifecycle diagram](img/B21678_17_ForCEing_FS_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – Docker lifecycle diagram
  prefs: []
  type: TYPE_NORMAL
- en: We need to start with a `Dockerfile,` which is a file that contains the instructions
    to build the image. Then, we can build the image with the `docker build` command.
    We can then run the container with the `docker` `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to share the image with other people, we can push the image to a
    registry with the `docker push` command. Then, other people can pull the image
    from the registry with the `docker pull` command. This last step is quite similar
    to `npm publish` but, instead of sharing the code, we are sharing the image.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are clear on the theory, let’s Dockerize our application in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerizing the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your local machine, using Docker Desktop 1.18, you can run `docker init`
    in the project root folder (where `package.json` is located) to create a `Dockerfile`
    (see [https://docs.docker.com/engine/reference/commandline/init/](https://docs.docker.com/engine/reference/commandline/init/)).
    So, we can create the files automatically with an interactive process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This tool will create the following files: `.dockerignore`, `dockerfile`, and
    `compose.yaml`. We will use `dockerfile` to build the image and we will use `compose.yaml`
    to run the container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a `Dockerfile` that sets up a Node.js environment inside a Docker container.
    It starts by specifying the Node.js version to use (`20.11.0`) and uses the Alpine
    version of the Node.js image for a smaller footprint. It sets the `NODE_ENV` environment
    variable to `production`. It then sets the working directory inside the container
    to `/usr/src/app`. The `RUN` command mounts the `package.json` and `package-lock.json`
    files from the host to the container and also sets up a cache for `npm` modules.
    It then runs `npm ci --omit=dev` to install the `production` dependencies only.
    It changes the user to `node` for security reasons, copies all files from the
    current directory on the host to the current directory in the container, exposes
    port `3000` for the application to be accessible, and finally, sets the command
    to start the application to `npm start`.
  prefs: []
  type: TYPE_NORMAL
- en: For our current application, we can remove the `compose.yaml` file as we don’t
    need it. It is important to review the content in the `.dockerignore` file as
    it excludes some files from the build process when we execute the `COPY . .` command
    in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: We have all the files needed to properly use Docker to manage our application,
    so in the next section, we will cover that in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the application with Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we used PM2 to manage the application. This time,
    we will use Docker. We can build the image with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can run the container with the following command, which will expose
    port `3000` and will use specific environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will need to replace `mongodb+srv://<username>:<password>@<cluster-url>/test?retryWrites=true&w=majority`
    with the connection string of your MongoDB Atlas cluster.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the browser and access [http://localhost:3000](http://localhost:3000),
    you will see the application running as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know that the Dockerized application is working fine, we can add
    a step in the CI to ensure that the Docker image is properly generated.
  prefs: []
  type: TYPE_NORMAL
- en: Adding docker build to the CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can add the `docker build` step to the CI process to ensure that the image
    is built correctly. We can add the following step to the CI process in `.github/workflows/ci.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you commit these changes, you can check the status of the workflow in
    the `Build Docker` `image` step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – Checking the workflow status](img/B21678_17_ForCEing_FS_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – Checking the workflow status
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 17**.2*, we successfully built the Docker image. In
    the next section, we will learn how to make this image public.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the image to Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to create a new repository in Docker Hub: [https://hub.docker.com/repositories/new](https://hub.docker.com/repositories/new).
    In my case, I created a private repository called `nodejs-for-beginners`, as you
    can see in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – Creating a new repository](img/B21678_17_ForCEing_FS_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.3 – Creating a new repository
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you create a **Public** image but if you want to create a **Private**
    image, then you will need to log in to Docker Hub using the Docker CLI in your
    target machine (DigitalOcean Droplet or an alternative).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, from your local machine, you need to log in to Docker Hub using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then build the image with the name of the repository with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You will need to replace `YOUR-USER/YOUR-PROJECT` with your user and project
    name. In my case, I used `ulisesgascon/nodejs-for-beginners`.
  prefs: []
  type: TYPE_NORMAL
- en: This command will print a lot of logs but, at the end, you should not see any
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you need to push the image to Docker Hub with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be something like this, using the default `latest` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you go to the Docker Hub repository, you will see that the image has been
    pushed and is ready to be used in other machines with the `docker pull` `YOUR-USER/YOUR-PROJECT:latest`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following figure, the image is available in the Docker
    Hub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4 – The image in the Docker Hub repository](img/B21678_17_ForCEing_FS_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.4 – The image in the Docker Hub repository
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the image with GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an alternative way to push the image to Docker Hub, we can publish the image
    directly with GitHub Actions. This is a great way to automate the process, avoiding
    the need to install Docker on our local machine and ensuring that the image is
    built correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'I invite you to achieve this by yourself as the last challenge of this book.
    Here are some hints to help you:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub guide to publishing Docker images: [https://docs.github.com/en/actions/guides/publishing-docker-images](https://docs.github.com/en/actions/guides/publishing-docker-images)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A pipeline reference from the `simple-api` project: [https://github.com/UlisesGascon/simple-api/blob/main/.github/workflows/release.yml#L58](https://github.com/UlisesGascon/simple-api/blob/main/.github/workflows/release.yml#L58)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use Docker to run the project in the
    DigitalOcean Droplet.
  prefs: []
  type: TYPE_NORMAL
- en: Running the containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we used PM2 to manage the lifecycle of our application.
    This time, we will do it differently: we will use Docker directly.'
  prefs: []
  type: TYPE_NORMAL
- en: Our first step will be to install Docker on our target machine using SSH. Follow
    the installation guide ([https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/))
    and then run `docker run hello-world`. The command will run without generating
    any error, this was a simple test to check whether the Docker engine was properly
    set up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please check that you stopped the PM2 application before we move to the next
    step as only one service can control port `3000`. Then, our last step will be
    to run the container but, this time, we won’t need to build the container as we
    are pulling directly the image from Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You will need to replace `mongodb+srv://<username>:<password>@<cluster-url>/test?retryWrites=true&w=majority`
    with the connection string of your MongoDB Atlas cluster, and `YOUR-USER/YOUR-PROJECT`
    with your user and project name. In my case, I used `ulisesgascon/nodejs-for-beginners`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the application running as expected using the same IP address and
    port as when running PM2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 – Application running using the Droplet external IP](img/B21678_17_ForCEing_FS_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.5 – Application running using the Droplet external IP
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will learn how to use Cloudflare to handle domains
    and certificates so your users won’t need to remember your server’s IP address
    to access it. If you are using a local machine, then your setup will be different
    as you probably won’t have a static IP address so I suggest you follow this tutorial:
    [https://www.youtube.com/watch?v=DCxt9SAnkyc](https://www.youtube.com/watch?v=DCxt9SAnkyc).
    That way, your project will be accessible from the internet using ngrok ([https://ngrok.com/](https://ngrok.com/)).
    This will generate a connection tunnel to your machine and will expose your service
    as `https://xxxxsxx.ngrok.io` without worrying about network setup. Take into
    account that self-hosting applications that are open to internet traffic require
    a solid knowledge of security ([https://www.youtube.com/watch?v=URWlY3Qr9l8](https://www.youtube.com/watch?v=URWlY3Qr9l8)),
    especially if you plan to use this approach for a long time.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are having issues running the project in this chapter while following
    the steps, or you tried an alternative approach, you can use the `step6` folder
    from the source code that you downloaded at the beginning of the chapter to compare
    and fix possible bugs more easily.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how to do a proper domain setup and how
    to add an SSL certificate to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cloudflare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application is running in the DigitalOcean Droplet but is accessible only
    by IP address and port. So, we need to do a proper domain setup and add an SSL
    certificate to the application. Acquiring a domain has a financial cost associated
    with it. Depending on the domain register, this cost may vary, and some domains
    are more expensive than others. SSL, together with **Transport Layer Security**
    (**TLS**), acts as a mechanism that we can add to our web project that will allow
    encryption between the clients and the server. In plain English, this will be
    the difference between accessing your website using http: //myproject. com or
    https: //myproject. com.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many browsers today will prevent access to websites that are not using `https://`.
    We can use Cloudflare to enable both (`http` and `https`) and it is free for the
    basic features, so these are the steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new domain in Cloudflare: [https://www.youtube.com/watch?v=7hY3gp_-9EU](https://www.youtube.com/watch?v=7hY3gp_-9EU).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new DNS record in Cloudflare: [https://www.youtube.com/watch?v=PYSIt3fEEoI](https://www.youtube.com/watch?v=PYSIt3fEEoI).
    In our case, we will add an `A` record with the domain name or subdomain and the
    IP address of the Droplet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to wait for the DNS propagation; this can take a while.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the DNS propagation is finished, you can access the application using
    the domain name. In my case, I can access the application using the domain name
    `https://demo.ulisesgascon.com`. In the following figure, you can see the domain
    set up in Cloudflare:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.6 – Domain settings in Cloudflare](img/B21678_17_ForCEing_FS_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.6 – Domain settings in Cloudflare
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to specify the port in the URL, you can run the application
    in port `443` (the default for `https`) or `80` (the default for `http`) instead
    of port `3000`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished with the domain setup, we can think of more advanced
    topics. In the next section, we will explore the Twelve-Factor App principles.
  prefs: []
  type: TYPE_NORMAL
- en: Next level – Twelve-Factor App principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A great way to continue learning is to follow the Twelve-Factor App principles.
    This is a methodology to build modern, scalable, maintainable, and portable applications,
    and it is structured in 12 principles. The following are the 12 principles along
    with their definitions, taken from [https://12factor.net](https://12factor.net):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Codebase*: One codebase tracked in revision control, many deploys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dependencies*: Explicitly declare and isolate dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Config*: Store config in the environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Backing services*: Treat backing services as attached resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Build, release, run*: Strictly separate build and run stages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Processes*: Execute the app as one or more stateless processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Port binding*: Export services via port binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concurrency*: Scale out via the process model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Disposability*: Maximize robustness with fast startup and graceful shutdown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dev/prod parity*: Keep development, staging, and production as similar as
    possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Logs*: Treat logs as event streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Admin processes*: Run admin/management tasks as one-off processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many principles that we already covered in this book, such as configuration
    management, but there are some that we haven’t covered yet. As an example, we
    don’t have a staging environment and we haven’t covered the admin processes. We
    built and deployed a simple app that is not designed to be used by real users
    or to handle real traffic, but if you want to build and deploy actual projects,
    it is highly recommended to follow these principles.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this is a great way to continue learning and getting a deeper understanding
    of the topic while improving the application that we just built together in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review the steps to clean up the resources that
    we used in this chapter just in case you don’t need them anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are done with the application, we can clean up the resources that we
    used in this chapter as we won’t need them in the near future. Most of the resources
    are free but I highly recommend deleting the resources that you don’t need anymore,
    especially if you are paying for any of those.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the resources that you can delete:'
  prefs: []
  type: TYPE_NORMAL
- en: DigitalOcean Droplet(s) created in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB Atlas cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Hub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloudflare domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub repository (although I recommend you keep it as you can use it as a reference
    in the future)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You can get additional hard drive space in your local environment by deleting
    the Docker images that you don’t need anymore or the `node_modules` folders that
    you created while following along with the book.
  prefs: []
  type: TYPE_NORMAL
- en: This cleaning-up process was the last step for us in this journey. Before you
    move to the final section, I recommend you organize the notes you have taken during
    this journey and properly store them so you can access them in the future. In
    the next section, we will summarize this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to deploy our application to the public internet
    using Docker and how to use GitHub Actions for CI with our Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to use Docker to build the application and how to publish the
    image to Docker Hub, and we discussed how to do a proper domain setup and how
    to add an SSL certificate to the application using Cloudflare. We looked at the
    Twelve-Factor App principles and we reviewed the steps to clean up the resources
    that we used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you made it! This is the end of the journey. I hope that you
    enjoyed it and that you learned a lot. I hope that you will continue learning
    and improving your skills and that you will continue building amazing applications
    with Node.js. I will be very happy to hear from you and to know what you think
    about the book. You can reach me on X/Twitter ([https://twitter.com/kom_256](https://twitter.com/kom_256))
    or LinkedIn ([https://www.linkedin.com/in/ulisesgascon/](https://www.linkedin.com/in/ulisesgascon/)).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Twelve-Factor App principles: [https://12factor.net/](https://12factor.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So what is Cloudflare?: [https://www.cloudflare.com/learning/what-is-cloudflare/](https://www.cloudflare.com/learning/what-is-cloudflare/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What 19th century railroad wars can teach us about building a future-ready*
    *cloud*: [https://cloud.google.com/blog/transform/what-19th-century-railroad-wars-can-teach-us-about-cloud-containers](https://cloud.google.com/blog/transform/what-19th-century-railroad-wars-can-teach-us-about-cloud-containers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
