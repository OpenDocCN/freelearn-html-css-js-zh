["```js\n<form data-newsletter-form>\n  <h3>Subscribe to the newsletter!</h3>\n  <div>\n    <label for=\"email\">Email</label>\n    <input\n      id=\"email\"\n      type=\"email\"\n      name=\"email\"\n      placeholder=\"test@example.com\"\n    />\n  </div>\n  <button type=\"submit\">Submit</button>\n</form>\n```", "```js\n<script>\n  document.addEventListener('click', (event) => {\n    switch (event.target.tagName?.toLowerCase()) {\n    }\n  });\n</script>\n```", "```js\n<script>\n  document.addEventListener('click', (event) => {\n    switch (event.target.tagName?.toLowerCase()) {\n      case 'button': {\n        const form = event.target.closest('form');\n        if (\n          form &&\n          event.target.type === 'submit' &&\n          'newsletterForm' in form.dataset\n        ) {\n          event.preventDefault();\n          const formValues = new FormData(form);\n          event.target.innerText = 'Submitting';\n          event.target.setAttribute('disabled',\n            'disabled');\n          const email = formValues.get('email');\n          return;\n        }\n      }\n    }\n  });\n</script>\n```", "```js\n<script>\n  async function submitNewsletterSubscription(email) {\n    const res = await fetch\n      ('https://jsonplaceholder.typicode.com/users', {\n      method: 'POST',\n      body: JSON.stringify({\n        email,\n      }),\n      headers: {\n        'Content-type': 'application/json; charset=UTF-8',\n      },\n    });\n    return res.json();\n  }\n  // no change to the document \"click\" event listener\n</script>\n```", "```js\n<script>\n  document.addEventListener('click', (event) => {\n    switch (event.target.tagName?.toLowerCase()) {\n      case 'button': {\n        const form = event.target.closest('form');\n        if (\n          form &&\n          event.target.type === 'submit' &&\n          'newsletterForm' in form.dataset\n        ) {\n          // no change to existing logic\n          const email = formValues.get('email');\n          submitNewsletterSubscription(email).then((result) => {\n            event.target.innerText = 'Submit';\n            event.target.removeAttribute('disabled');\n          });\n        }\n        return;\n      }\n    }\n  });\n</script>\n```", "```js\n<div style=\"height: 300px; overflow: scroll\">\n  <h3>API Request/Response Log</h3>\n  <pre><code></code></pre>\n</div>\n<script>\n  // no change to other functionality\n  function storeLogEvent(value) {\n    $requestLog = document.querySelector('pre code');\n    $requestLog.innerText += value;\n    $logParent = $requestLog.closest('div');\n    $logParent.scrollTo({ top: $logParent.scrollTopMax,\n      behavior: 'smooth' });\n  }\n</script>\n```", "```js\n// -> inside the listener\n// -> switch\n// -> case 'button'\n// -> if (form in ancestors && button type === submit &&\n   form has data-newsletter-form)\nconst email = formValues.get('email');\nstoreLogEvent(`Request: ${email}`);\nsubmitNewsletterSubscription(email).then((result) => {\n  storeLogEvent(`\\nResponse: ${JSON.stringify(result,\n    null, 2)}\\n\\n`);\n  event.target.innerText = 'Submit';\n  event.target.removeAttribute('disabled');\n});\n```", "```js\ndata-add-form attribute by adding if ('addForm' in event.target.dataset). For now, we’ll return early to prevent any further handling code from executing:\n\n```", "```js\n\n We want to implement the add form functionality, and we want to find a `data-newsletter-form` element and clone it using `.cloneNode(true)`.\nWe’ll append a random number inside the heading so we can identify when new forms are added and reset the email input. Finally, we append the new node to the `document.body` element using `.appendChild`:\n\n```", "```js\n\n With no changes to the handling of the newsletter form submission, the cloned form functions just as the initial one does.\n![Figure 8.5: The effect of submit on multiple forms, one of which was added with an Add a form! button](img/B19109_08_5.jpg)\n\nFigure 8.5: The effect of submit on multiple forms, one of which was added with an Add a form! button\nWe’ve now seen how to implement event delegation to prevent having to add event listeners manually to dynamically added DOM nodes. Next, we’ll look at patterns that use the `postMessage` interface between iframes.\nPatterns for secure frame/native WebView bridge messaging\nGaining a deep understanding of messaging patterns with `postMessage` in JavaScript is crucial for working in a variety of contexts. `postMessage` is defined on the following Web API objects: `Window`, `MessagePort`, `Worker`, `Client`, `ServiceWorker`, and `BroadcastChannel`.\nIn other words, `postMessage`-based messaging is useful for document-to-iframe, iframe-to-iframe, document-to-worker, and service worker-to-document communication and that’s only the Web APIs. Due to how widespread the `postMessage` API is, it’s also adopted in non-standard APIs for handling multiple JavaScript contexts. For example, web extensions for Chrome and Firefox contain multiple JavaScript contexts: the devtools panel, proxy, backend, and background script. The `postMessage` API is also used for Android and iOS communication between the native code and WebViews.\nThe scenario that we’ll go through is about iframes and how they communicate. A common e-commerce use-case is integrating a third-party payment service provider’s hosted card capture form into their e-commerce website. By using a payment service provider and not knowing the customer’s card payment details, the e-commerce vendor can meet **Payment Card Industry Data Security Standard** (**PCI DSS**) compliance more easily.\nThe container or parent document will be a checkout form, inside of which we’ll iframe a hosted card capture document. The two documents will communicate with `postMessage`. The container document will not read the card details in cleartext. Instead, it will receive a public-key encrypted payload (which can only be decrypted via the paired private key).\nWithout being careful, it’s possible for `iframe` initialization to cause race conditions. To work around this, we’ll implement the following initialization scheme.\nInitially, we’ll load a container document with an `iframe` that has no `src`. Only after we’ve added important event listeners to the `iframe` element, will we add `src`. This means that the `iframe` can’t load before our listeners are attached.\n![Figure 8.6: Sequence diagram of initialization messaging](img/B19109_08_6.jpg)\n\nFigure 8.6: Sequence diagram of initialization messaging\nWe need two files, one at `frame-parent.html` (which will be our application shell) and one at `frame-content.html` (which will represent our iframe’s contents).\nSome payment service provider integrations won’t require a fully custom `iframe` (sometimes, a JavaScript SDK is provided that helps manage the `iframe` part of it), but the important thing is that the `iframe` is loaded from an origin (server) that is owned by the payment service provider. We won’t be able to represent this since we’re working locally.\nOur `frame-parent.html` HTML looks as follows: a few headings, a `form`, an `input type=email`, an `iframe`, and a submit button. Note that the `iframe` element doesn’t have a `src` attribute. We’ll add that via JavaScript to prevent race conditions:\n\n```", "```js\n\n To prevent race conditions when loading the `iframe`, we haven’t set the `src` in the HTML. We want to prevent situations where the `iframe` could load before we’ve attached a `load` event handler to it.\nWe start by adding a `message` event listener to the container window:\n\n```", "```js\n\n Next, we’ll select the payment capture `iframe` and add a `load` event listener to the iframe element. Our handler will send an `init` message with some data to the `iframe` element’s `contentWindow`:\n\n```", "```js\n\n Finally, we can set the `iframe` element’s `src` attribute so that it loads:\n\n```", "```js\n\n We now need to implement the `frame-content.html` file to receive the message we sent. Our `iframe`, again is mostly a heading and a form with multiple fields. We have `type=hidden` inputs for the price and currency, as well as text inputs for the card number, expiry date, and `Messages` section to illustrate which messages are being sent and received by the iframe:\n\n```", "```js\n\n In order to handle messages from the parent frame, we’ll add a `message` event listener. It stores all received messages in the `pre code` element we defined earlier.\nIf the `event.data.type` is `init`, we set the value of our `price` and `currency` inputs:\n\n```", "```js\n\n Finally, we send an `init` message when our script finished running. We use `window.parent.postMessage` to achieve this:\n\n```", "```js\n\n With this code in place, when we load the `frame-parent.html` file in a browser, we see the following. The `iframe` has sent an `init` message and received one as well.\n![Figure 8.7: Container and iframe contents in their initial state](img/B19109_08_7.jpg)\n\nFigure 8.7: Container and iframe contents in their initial state\nWhen we submit the container, we’ll want to ensure the card details are retrieved by the `iframe` and passed back to the container. These details will be encrypted by the `iframe` (which, in our scenario, will be served from a domain from the payment service provider) before being sent to the parent document.\nThe following diagram details the expected interactions.\n![Figure 8.8: Container and iframe communication sequence diagram during user interaction](img/B19109_08_8.jpg)\n\nFigure 8.8: Container and iframe communication sequence diagram during user interaction\nThe key change we have to make to the container is to listen for a submit event on the `form` element. We then send a message with `type=\"submit\"` to the iframe:\n\n```", "```js\n\n The `iframe` receives the message and we’ll need to extend our `message` event handler to react to the `submit` message:\n\n```", "```js\n\n Now that we’ve implemented a new `iframe` to container “validation error” message, we need to handle that message type in `frame-parent.html`. In this case, we’ve already done everything that’s necessary in the `submit` form event handler (which calls `preventDefault()`), so we’ll simply log out the message contents:\n\n```", "```js\n\n We can now attempt to click `validation-error` message as received by the frame parent.\n![Figure 8.9: If you click Pay with the card number and expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card number field](img/B19109_08_9.jpg)\n\nFigure 8.9: If you click Pay with the card number and expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card number field\nIf we then enter the card number but still don’t enter the expiry date, then the second `validation-error` message only contains the `cardexpiry` field:\n![Figure 8.10: If you click Pay with the card number entered and the expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card expiry field](img/B19109_08_10.jpg)\n\nFigure 8.10: If you click Pay with the card number entered and the expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card expiry field\nWe need a function to take a string (in our case containing a JSON-encoded JavaScript object) and turn it into a base64-encoded ciphertext (encrypted string in base64 format). The payment service provider usually would manage this encryption, so we wouldn’t need this function or to fetch `public-key.json` to enable RSA-OAEP (asymmetric) encryption in the browser.\nThe code will convert the string to a Uint8Array, fetch a public key, and import it in order to use it with `crypto.subtle.encrypt`. We encrypt the message string (that was converted to a Uint8Array). This yields an `ArrayBuffer` that we encode to base64 by creating a `Uint8Array` object with our data, converting it back to an array and for each character, looking up the relevant character code. Once we have a string containing the character codes, we base64-encode it:\n\n```", "```js\n\n We can now use the `encryptToBase64` function in our `type=submit` message-handling code. Once the validation passes, we’ll serialize the data using `FormData`, `FormData().entries()`, and `Object.fromEntries`. We stringify it before encrypting it to a base64 ciphertext.\nFinally, we send a `type=submit-reponse` message to the container document with the encrypted string as the payload:\n\n```", "```js\n\n We now need to handle the `type=submit-response` message in `iframe-parent.html`. Again, we’re just extending our `switch(type)` statement with an additional case for `submit-response`. We’ll log some messages, including the `event.data` and extract the values from the container `form` element using `FormData().entries()` and `Object.fromEntries()`. At this point, we could send the `event.data` and the container form data to a backend endpoint to complete the transaction:\n\n```", "```js\n\n We can see this in action when we fill out the customer email and the payment details form and click **Pay**:\n![Figure 8.11: When the form is complete and Pay has been clicked, the iframe receives the submit message and sends back a submit-response message with an encrypted base64 string, which the container page receives](img/B19109_08_11.jpg)\n\nFigure 8.11: When the form is complete and Pay has been clicked, the iframe receives the submit message and sends back a submit-response message with an encrypted base64 string, which the container page receives\nIn order to avoid untrusted frames from sending arbitrary messages, we should check `event.origin` against an allowlist.\nWe’ll add this as a guard clause in the `window.addEventListener` in both `frame-parent.html` and `frame-content.html`. We’ll check the message origins against our allowlist. If the `event.origin` is not in the allowlist, we log a warning and discard the message by doing an early return.\nIn the case of local development, the origin will be `'http://127.0.0.1:8000'` for both interactions. As throughout this section, in a production use case, the allowed origin for receiving messages in the container window (`frame-parent.html`) would be a domain managed by the payment service provider. The `frame-content.html` equivalent would be what the payment service provider hosts, so the allowed domain would be the URL of the container application:\n\n```", "```js\n\n We’ve now seen how to implement secure messaging between an iframe and the page that contains it. Next, we’ll recap on event listener performance anti-patterns.\nEvent listener performance antipatterns\nEvent listener performance antipatterns change over time. For example, when Internet Explorer support was broadly required due to its market share, adding event listeners to DOM nodes and subsequently deleting the nodes would not clean up the event listeners, causing memory leaks. This doesn’t occur anymore in modern browsers.\nAn event listener antipattern that is often caught by the Lighthouse page performance auditing tool is `scroll` event listeners that aren’t set to be passive. Passive event listeners are more performant because `event.preventDefault()` doesn’t intercept and stop the event’s default behavior. This allows browsers to set the event listener to be non-blocking since the listener can’t act on the event.\nMaking an event listener passive simply involves passing `{ passive: true }` as the third parameter to `addEventListener()`:\n\n```", "```js\n\n Another antipattern is to forgo using debounce or throttle on the event listener handler for high-volume events (scroll is a good example). We covered how to implement debounce and throttle in [*Chapter 7*](B19109_07.xhtml#_idTextAnchor238)*, Asynchronous Programming Performance Patterns*, in the *Throttling, debouncing and batching asynchronous* *operations* section.\nThe final antipattern is solved by event delegation. At some amount of DOM nodes and event listeners, adding one event listener per potential target starts causing performance implications. Luckily, event delegation solves this problem. It allows us to attach one event listener per event type while maintaining the ability to handle each target differently.\nWe’ve now covered event listener performance antipatterns to keep an eye out for and how to remediate them.\nSummary\nIn this chapter, we’ve covered advanced event-driven programming patterns to keep a JavaScript code base performant and secure when handling large numbers of events and event listeners.\nEvent delegation is useful to ensure that the number of event listeners doesn’t grow with the number of DOM nodes in a client-side application where elements are inserted and removed dynamically.\nPatterns for secure frame messaging mean we’re able to orchestrate `iframe` initialization and bidirectional communication between an `iframe` and its parent document.\nFinally, we covered common event listener performance antipatterns to avoid the common pitfalls of event listener-heavy code bases.\nNow that we’re familiar with advanced event-driven programming patterns in JavaScript, in the next chapter, we’ll cover lazy-loading and code-splitting to maximize the performance of JavaScript applications.\n\n```"]