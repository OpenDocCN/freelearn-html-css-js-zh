<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Materials and Textures"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Materials and Textures</h1></div></div></div><p>In this chapter, we'll cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding depth to a mesh with a bump map</li><li class="listitem" style="list-style-type: disc">Adding depth to a mesh with a normal map</li><li class="listitem" style="list-style-type: disc">Using HTML canvas as a texture</li><li class="listitem" style="list-style-type: disc">Using HTML video as a texture</li><li class="listitem" style="list-style-type: disc">Creating a mesh with multiple materials</li><li class="listitem" style="list-style-type: disc">Using separate materials for faces</li><li class="listitem" style="list-style-type: disc">Setting up repeating textures</li><li class="listitem" style="list-style-type: disc">Making part of an object transparent</li><li class="listitem" style="list-style-type: disc">Using a cubemap to create reflective materials</li><li class="listitem" style="list-style-type: disc">Using a dynamic cubemap to create reflective materials</li><li class="listitem" style="list-style-type: disc">Using Blender to create custom UV mapping</li><li class="listitem" style="list-style-type: disc">Configuring blend modes</li><li class="listitem" style="list-style-type: disc">Using a shadow map for fixed shadows</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec53"/>Introduction</h1></div></div></div><p>Three.js offers a large number of different materials and supports many different types of textures. These textures provide a great way to create interesting effects and graphics. In this chapter, we'll show you recipes that allow you to get the most out of these components provided by Three.js.</p></div></div>
<div class="section" title="Adding depth to a mesh with a bump map"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec54"/>Adding depth to a mesh with a bump map</h1></div></div></div><p>For<a id="id281" class="indexterm"/> detailed models, you require geometries <a id="id282" class="indexterm"/>with a large number of vertices and faces. If a geometry contains a very large number of vertices, loading the geometry and rendering it will take more time than it would take for a simple model. If you've got a scene with a large number of models, it is a good idea to try and minimize the number <a id="id283" class="indexterm"/>of vertices for better performance. There are a number of different techniques that you can use for this. In this recipe, we'll<a id="id284" class="indexterm"/> show you how you can use a bump map texture to add the illusion of depth to your model.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec165"/>Getting ready</h2></div></div></div><p>To get ready for this recipe, we need to get the textures that we want to use on our geometries. For this recipe, we require two textures: a color map, which is a standard texture, and a bump map, which describes the depth associated with the standard texture. The following screenshot shows you the color map that we will use (you can find these textures in the <code class="literal">assets/textures</code> folder in the sources provided with this book):</p><div class="mediaobject"><img src="graphics/1182OS_04_01.jpg" alt="Getting ready"/></div><p>As you can see, this is a simple color map of a stone wall. Besides this texture, we also require the bump map. A bump map is a grayscale image, where the intensity of each pixel determines the height:</p><div class="mediaobject"><img src="graphics/1182OS_04_02.jpg" alt="Getting ready"/></div><p>From<a id="id285" class="indexterm"/> the preceding screenshot, you can see that<a id="id286" class="indexterm"/> the parts between the stones and the mortar has less height, as it is a dark color, as compared to the stones themselves, which have a lighter color. You can see the result you end up with at the end of this recipe by opening up the <code class="literal">04.01-add-depth-to-mesh-with-bump-map.html</code> example in your browser.</p><div class="mediaobject"><img src="graphics/1182OS_04_03.jpg" alt="Getting ready"/></div><p>From <a id="id287" class="indexterm"/>the preceding screenshot, you can see<a id="id288" class="indexterm"/> two cubes. The cube on the left-hand side is rendered without a bump map, and the cube on the right-hand side is rendered with a bump map. As you can see, the right-hand side cube shows much more depth and detail than the cube on the left-hand side.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec166"/>How to do it...</h2></div></div></div><p>When you've got textures, using them to add depth to a model is very straightforward:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create the geometry you want to use together with the bump map:<div class="informalexample"><pre class="programlisting">var cubeGeometry = new THREE.BoxGeometry(15, 15, 15);</pre></div><p>In this recipe, we create <code class="literal">THREE.BoxGeometry</code>, but you can use a bump map with any kind of geometry.</p></li><li class="listitem">The next step is to create the material on which we define the bump map:<div class="informalexample"><pre class="programlisting">var cubeBumpMaterial = new THREE.MeshPhongMaterial();

cubeBumpMaterial.map = THREE.ImageUtils.loadTexture(
                    "../assets/textures/Brick-2399.jpg");
cubeBumpMaterial.bumpMap = THREE.ImageUtils.loadTexture(
            "../assets/textures/Brick-2399-bump-map.jpg");</pre></div><p>Here, we create <code class="literal">THREE.MeshPhongMaterial</code> and set its <code class="literal">map</code> and <code class="literal">bumpMap</code> properties. The <code class="literal">map</code> property points to the color map texture, and <a id="id289" class="indexterm"/>the <code class="literal">bumpMap</code> property point to the grayscale bump map texture.</p></li><li class="listitem">Now you can just create <code class="literal">THREE.Mesh</code> and add it to scene:<div class="informalexample"><pre class="programlisting">var bumpCube = new THREE.Mesh(cubeGeometry,
                              cubeBumpMaterial);
scene.add(bumpCube);</pre></div></li></ol></div><p>With<a id="id290" class="indexterm"/> these three simple steps, you've created <a id="id291" class="indexterm"/>a cube that uses a bump map for added depth.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec167"/>How it works...</h2></div></div></div><p>The values of each pixel in the bump map determine the height associated with that part of the texture. When rendering the scene, Three.js uses this information to determine how light affects the final color of the pixel it is rendering. The result is that without defining a very detailed model, we can add the illusion of extra depth. If you want to know more details about <a id="id292" class="indexterm"/>how bump mapping works, look at this site for a very detailed explanation: <a class="ulink" href="http://www.tweak3d.net/articles/bumpmapping/">http://www.tweak3d.net/articles/bumpmapping/</a>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec168"/>There's more…</h2></div></div></div><p>In this recipe, we showed you the default way to define a bump map. There is, however, one additional property that you can use to tune bump mapping. The material we used in this recipe, <code class="literal">cubeBumpMaterial</code>, also has a <code class="literal">bumpScale</code> property. With this property, you can set the amount by which the bump map affects the depth. If this value is very small, you'll see some added depth, and if this value is higher, you'll see a more pronounced depth effect. You can set this property in the example for this cookbook (<code class="literal">04.01-add-depth-to-mesh-with-bump-map.html</code>).</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec169"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is an additional way to add detail and depth to your meshes. In the <span class="emphasis"><em>Add depth to a mesh with a normal map</em></span> recipe, we show how to add depth and detail with a normal map instead of a bump map. In the <span class="emphasis"><em>Creating geometries from height maps</em></span> recipe, of <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <span class="emphasis"><em>Geometries and Meshes</em></span>, we showed you a different way to use bump maps by creating <code class="literal">THREE.Geometry</code> from it.</li></ul></div></div></div>
<div class="section" title="Adding depth to a mesh with a normal map"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec55"/>Adding depth to a mesh with a normal map</h1></div></div></div><p>With a<a id="id293" class="indexterm"/> bump map, we showed in the <span class="emphasis"><em>Add depth to a mesh with a bump map</em></span> recipe, how to add depth and detail to a mesh using<a id="id294" class="indexterm"/> a specific texture. In this recipe, we provide another way to add even more depth and details without increasing the vertex count of the geometry. To do this, we will use a normal map. A normal map describes the normal vector for each pixel, which should be used to calculate how light affects the material used in the geometry.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec170"/>Getting ready</h2></div></div></div><p>To use normal maps, we first need to get a color map and a normal map. For this recipe, we've used two screenshots. The first is the color map:</p><div class="mediaobject"><img src="graphics/1182OS_04_05.jpg" alt="Getting ready"/></div><p>The next screenshot is the normal map:</p><div class="mediaobject"><img src="graphics/1182OS_04_06.jpg" alt="Getting ready"/></div><p>Now <a id="id295" class="indexterm"/>that we've got the two images, let's first <a id="id296" class="indexterm"/>look at how this would look in practice. To see a normal map in action, open the <code class="literal">04.02-add-depth-to-mesh-with-normal-map.html</code> example:</p><div class="mediaobject"><img src="graphics/1182OS_04_07.jpg" alt="Getting ready"/></div><p>In this<a id="id297" class="indexterm"/> example, you can see a standard rendered<a id="id298" class="indexterm"/> cube on the left-hand side and one where a normal map is added to on the right-hand side. You can directly see that the face of the right-hand side cube looks much more detailed than the face of the left-hand side cube.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec171"/>How to do it...</h2></div></div></div><p>Adding a normal map is actually very easy:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create the geometry that we want to render:<div class="informalexample"><pre class="programlisting">var cubeGeometry = new THREE.BoxGeometry(15, 15, 15);</pre></div><p>For this recipe, we use a simple <code class="literal">THREE.BoxGeometry</code> object, but you can use whichever geometry you want.</p></li><li class="listitem">Now that we've got a geometry, we create the material and configure the properties:<div class="informalexample"><pre class="programlisting">var cubeNormalMaterial = new THREE.MeshPhongMaterial();
cubeNormalMaterial.map = THREE.ImageUtils.loadTexture(
                  "../assets/textures/chesterfield.png");
cubeNormalMaterial.normalMap = THREE.ImageUtils.loadTexture(
           "../assets/textures/chesterfield-normal.png");</pre></div><p>The <code class="literal">map</code> properties contain the standard texture, and the <code class="literal">normalMap</code> properties contain the normal texture, which we showed you in the <span class="emphasis"><em>Getting ready</em></span> section of this recipe.</p></li><li class="listitem">All that is left to do now is to create a <code class="literal">THREE.Mesh</code> object and add it to the scene like this:<div class="informalexample"><pre class="programlisting">var normalCube = new THREE.Mesh(
                     cubeGeometry, cubeNormalMaterial);
scene.add(normalCube);</pre></div></li></ol></div><p>As you can see from these steps, using a normal map is very simple.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec172"/>How it works...</h2></div></div></div><p>In 3D <a id="id299" class="indexterm"/>modeling, a couple of mathematical <a id="id300" class="indexterm"/>concepts are important to understand. One<a id="id301" class="indexterm"/> of these concepts is a <span class="strong"><strong>normal</strong></span> vector. A normal is the vector that stands perpendicular to the surface of the face of a geometry. This is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_04_08.jpg" alt="How it works..."/></div><p>Each blue line represents the normal vector, which is the vector that is perpendicular to the surface of that face. In a normal map, the direction of these vectors are shown as RGB values. When you apply a normal map to a specific face, Three.js uses the information from this normal map and the normal of the face to add depth to that face without adding additional <a id="id302" class="indexterm"/>vertices. For more information<a id="id303" class="indexterm"/> on how normal maps are used, refer<a id="id304" class="indexterm"/> to the site at <a class="ulink" href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/">http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/</a>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec173"/>There's more…</h2></div></div></div><p>You can fine-tune the height and direction in which the information from the normal map is applied to the face of geometry. For this, you can use the <code class="literal">normalScale</code> property like this:</p><div class="informalexample"><pre class="programlisting">normalCube.material.normalScale.x = 1;
normalCube.material.normalScale.y = 1;</pre></div><p>To see this effect in action, look at the example for this recipe, <code class="literal">04.02-add-depth-to-mesh-with-normal-map.html</code>, where you can use the menu in the top-right section to change this value.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec174"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An alternative for normal maps is bump maps. In the <span class="emphasis"><em>Add depth to a mesh with a bump map</em></span> recipe, we show you how to use such a map instead of a normal map</li></ul></div></div></div>
<div class="section" title="Using HTML canvas as a texture"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec56"/>Using HTML canvas as a texture</h1></div></div></div><p>Most<a id="id305" class="indexterm"/> often when you use textures, you use static images. With <a id="id306" class="indexterm"/>Three.js, however, it is also possible to create interactive textures. In this recipe, we will show you how you can use an HTML5 canvas element as an input for your texture. Any change to this canvas is automatically reflected after you inform Three.js about this change in the texture used on the geometry.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec175"/>Getting ready</h2></div></div></div><p>For this recipe, we need an HTML5 canvas element that can be displayed as a texture. We can create one ourselves and add some output, but for this recipe, we've chosen something else. We will use a simple JavaScript library, which outputs a clock to a canvas element. The resulting mesh will look like this (see the <code class="literal">04.03-use-html-canvas-as-texture.html</code> example):</p><div class="mediaobject"><img src="graphics/1182OS_04_09.jpg" alt="Getting ready"/></div><p>The<a id="id307" class="indexterm"/> JavaScript used to render the clock was based on <a id="id308" class="indexterm"/>the code from this site: <a class="ulink" href="http://saturnboy.com/2013/10/html5-canvas-clock/">http://saturnboy.com/2013/10/html5-canvas-clock/</a>. To include the code that renders the clock in our page, we need to add the following to the <code class="literal">head</code> element:</p><div class="informalexample"><pre class="programlisting">&lt;script src="../libs/clock.js"&gt;&lt;/script&gt;</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec176"/>How to do it...</h2></div></div></div><p>To use a canvas as a texture, we need to perform a couple of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create the canvas element:<div class="informalexample"><pre class="programlisting">var canvas = document.createElement('canvas');
canvas.width=512;
canvas.height=512;</pre></div><p>Here, we create an HTML canvas element programmatically and define a fixed width.</p></li><li class="listitem">Now that we've got a canvas, we need to render the clock that we use as the input for this recipe on it. The library is very easy to use; all you have to do is pass in the canvas element we just created:<div class="informalexample"><pre class="programlisting">clock(canvas);</pre></div></li><li class="listitem">At this point, we've got a canvas that renders and updates an image of a clock. What we need to do now is create a geometry and a material and use this canvas element as a texture for this material:<div class="informalexample"><pre class="programlisting">var cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
var cubeMaterial = new THREE.MeshLambertMaterial();
cubeMaterial.map = new THREE.Texture(canvas);
var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);</pre></div><p>To create a texture from a canvas element, all we need to do is create a new instance of <code class="literal">THREE.Texture</code> and pass in the <code class="literal">canvas</code> element we created in step 1. We assign this texture to the <code class="literal">cubeMaterial.map</code> property, and that's it.</p></li><li class="listitem">If you <a id="id309" class="indexterm"/>run the recipe at this step, you might <a id="id310" class="indexterm"/>see the clock rendered on the sides of the cubes. However, the clock won't update itself. We need to tell Three.js that the canvas element has been changed. We do this by adding the following to the rendering loop:<div class="informalexample"><pre class="programlisting">cubeMaterial.map.needsUpdate = true;</pre></div><p>This informs Three.js that our canvas texture has changed and needs to be updated the next time the scene is rendered.</p></li></ol></div><p>With these four simple steps, you can easily create interactive textures and use everything you can create on a canvas element as a texture in Three.js.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec177"/>How it works...</h2></div></div></div><p>How this works is actually pretty simple. Three.js uses WebGL to render scenes and apply textures. WebGL has native support for using HTML canvas element as textures, so Three.js just passes on the provided canvas element to WebGL and it is processed as any other texture.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec178"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Besides using images and canvas elements as textures, we can also use a video element as a texture. In the <span class="emphasis"><em>Using HTML video as a texture</em></span> recipe, we show you how to use a HTML video element as the input for a texture.</li></ul></div></div></div>
<div class="section" title="Using HTML video as a texture"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec57"/>Using HTML video as a texture</h1></div></div></div><p>Modern <a id="id311" class="indexterm"/>browsers have great support for playing video <a id="id312" class="indexterm"/>without requiring any plugins. With Three.js, we can even use this video as the input for our textures. In this recipe, we'll show you the steps you need to take to output a video on a side of a cube.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec179"/>Getting ready</h2></div></div></div><p>For this recipe, we need a video to play, of course. We used the trailer for the Blender-made <a id="id313" class="indexterm"/>movie <span class="emphasis"><em>Sintel</em></span> (<a class="ulink" href="http://www.sintel.org/">http://www.sintel.org/</a>), which is freely available. To view the result <a id="id314" class="indexterm"/>of this recipe, open <code class="literal">04.04-use-html-video-as-texture.html</code> in your browser.</p><div class="mediaobject"><img src="graphics/1182OS_04_10.jpg" alt="Getting ready"/></div><p>When <a id="id315" class="indexterm"/>you run this example, you can see that the video is being played at the side of a cube and keeps updating even when the cube is rotating.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec180"/>How to do it...</h2></div></div></div><p>To accomplish this effect, we need to define an HTML video element as the source for a texture. To do this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need is a way to play the video. For this, we add the following HTML element to the <code class="literal">body</code> element of the page:<div class="informalexample"><pre class="programlisting">&lt;video id="video" autoplay loop style="display:none"&gt;
    &lt;source src="../assets/video/sintel_trailer-480p.mp4" type='video/mp4'&gt;
    &lt;source src="../assets/video/sintel_trailer-480p.webm" type='video/webm'&gt;
    &lt;source src="../assets/video/sintel_trailer-480p.ogv" type='video/ogg'&gt;
&lt;/video&gt;</pre></div><p>With this piece of HTML, we'll load the video and play it looped once it is loaded using the <code class="literal">autoplay</code> and <code class="literal">loop</code> properties. As we've set <code class="literal">display:none</code>, this <code class="literal">video</code> element won't show up on the page.</p></li><li class="listitem">Now that we've got a video playing, we can get a reference to this element and use it to create a texture:<div class="informalexample"><pre class="programlisting">var video = document.getElementById( 'video' );

videoTexture = new THREE.Texture( video );
videoTexture.minFilter = THREE.LinearFilter;
videoTexture.magFilter = THREE.LinearFilter;
videoTexture.format = THREE.RGBFormat;
videoTexture.generateMipmaps = false;</pre></div><p>The <code class="literal">minFilter</code>, <code class="literal">magFilter</code>, <code class="literal">format</code>, and <code class="literal">generateMipmaps</code> properties used here provide the best result and performance when using a video as a texture.</p></li><li class="listitem">At this<a id="id316" class="indexterm"/> point, we've got a texture that we <a id="id317" class="indexterm"/>can use like any other texture:<div class="informalexample"><pre class="programlisting">var cubeGeometry = new THREE.BoxGeometry(1,9,20);
var cubeMaterial = new THREE.MeshBasicMaterial({map:videoTexture});</pre></div><p>Here, we set the <code class="literal">map</code> property of the material to the video texture. So, any <code class="literal">THREE.Mesh</code> object we create that uses this material will show the video.</p></li><li class="listitem">To finish the recipe, create <code class="literal">THREE.Mesh</code> object and add it to the scene:<div class="informalexample"><pre class="programlisting">var cube = new THREE.Mesh(cubeGeometry, 
                          cubeMaterial);
scene.add(cube);</pre></div></li><li class="listitem">Three.js normally caches textures as they usually don't change that often. In this recipe, though, the texture changes continuously. To inform Three.js that the texture has changed, we need to add the following to the render loop:<div class="informalexample"><pre class="programlisting">function render() {
   ...
   videoTexture.needsUpdate = true;
   ...
}</pre></div></li></ol></div><p>You can use this approach with any video that can be played in the browser.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec181"/>How it works...</h2></div></div></div><p>WebGL, which is used by Three.js to render the scenes, has native support to use video elements as input for the textures. Three.js just passes the video element to WebGL and doesn't need<a id="id318" class="indexterm"/> to do any preprocessing. In the WebGL <a id="id319" class="indexterm"/>code, the current image shown by the video is converted to a texture. Whenever we set <code class="literal">videoTexture.needsUpdate</code> to <code class="literal">true</code>, the texture is updated in WebGL.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec182"/>There's more…</h2></div></div></div><p>One thing to remember when working with the video element is that the different browsers have varying support for video formats. A good up-to-date overview of what format is supported by which browser can be found on Wikipedia at <a class="ulink" href="http://en.wikipedia.org/wiki/HTML5_video#Browser_support">http://en.wikipedia.org/wiki/HTML5_video#Browser_support</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec183"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An alternative way to easily create changing textures is explained in the <span class="emphasis"><em>Using HTML canvas as a texture</em></span> recipe. In this recipe, we explain how you can use the HTML <code class="literal">canvas</code> element as the input for a texture.</li></ul></div></div></div>
<div class="section" title="Creating a mesh with multiple materials"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec58"/>Creating a mesh with multiple materials</h1></div></div></div><p>When <a id="id320" class="indexterm"/>you create <code class="literal">THREE.Mesh</code>, you can only<a id="id321" class="indexterm"/> specify a single material that can be used for that mesh. In most scenarios, this will be sufficient. However, there are also cases where you want to combine multiple materials. For instance, you might want to combine <code class="literal">THREE.MeshLambertMaterial</code> with a material that shows you the wireframe of the geometry. In this recipe, we'll show you the required steps to create a mesh that uses multiple materials.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec184"/>Getting ready</h2></div></div></div><p>For this recipe, we don't require additional resources or libraries. If you want to look at the result of this recipe, open up the <code class="literal">04.05-create-a-mesh-with-multiple-materials.html</code> example in your browser.</p><div class="mediaobject"><img src="graphics/1182OS_04_11.jpg" alt="Getting ready"/></div><p>In the <a id="id322" class="indexterm"/>preceding screenshot, you can see a cylinder. This<a id="id323" class="indexterm"/> cylinder is rendered with two materials. In the next section, we'll show you the steps you need to take to create this.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec185"/>How to do it...</h2></div></div></div><p>To create a multimaterial mesh, Three.js provides a helper function. You can use <code class="literal">THREE.SceneUtils</code> for this, as is shown in the next couple of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing you need to do is create the geometry you want to use. For this recipe, we use a simple <code class="literal">THREE.CylinderGeometry</code> object:<div class="informalexample"><pre class="programlisting">var cylinderGeometry = new THREE.CylinderGeometry(
                           3, 5, 10,20);</pre></div></li><li class="listitem">After the geometry, we can create the materials. You can use as many as you want, but in this recipe, we'll just use two:<div class="informalexample"><pre class="programlisting">var material1 = new THREE.MeshLambertMaterial(
     {color:0xff0000, 
      transparent: true, 
      opacity: 0.7});

var material2 = new THREE.MeshBasicMaterial(
                           {wireframe:true});</pre></div><p>As you can see, we create a transparent <code class="literal">THREE.MeshLambertMaterial</code> object and <code class="literal">THREE.MeshBasicMaterial</code> object, which only renders a wireframe.</p></li><li class="listitem">Now, we<a id="id324" class="indexterm"/> can create the object<a id="id325" class="indexterm"/> that can be added to the scene. Instead of instantiating <code class="literal">THREE.Mesh</code>, we use the <code class="literal">createMultiMaterialObject</code> function provided by the <code class="literal">THREE.SceneUtils</code> object:<div class="informalexample"><pre class="programlisting">var cylinder = THREE.SceneUtils.createMultiMaterialObject(
                           cylinderGeometry,
                           [material1, material2]);</pre></div><p>You can add the result from this function to the scene:</p><div class="informalexample"><pre class="programlisting">scene.add(cylinder);</pre></div></li></ol></div><p>One thing to take into account is that the object we create here isn't <code class="literal">THREE.Mesh</code> but <code class="literal">THREE.Object3D</code>. Why a different object is created is explained in the next section.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec186"/>How it works...</h2></div></div></div><p>What happens when you call the <code class="literal">createMultiMaterialObject</code> function is that Three.js simply creates multiple meshes and groups them together. If you open the Three.js file and look up this function, you'll see the following code:</p><div class="informalexample"><pre class="programlisting">function createMultiMaterialObject( geometry, materials ) {
var group = new THREE.Object3D();
for ( var i = 0, l = materials.length; i &lt; l; i ++ ) {
group.add( new THREE.Mesh( geometry, materials[ i ] ) );
}
return group;
}</pre></div><p>In this function, Three.js iterates over the materials that are provided, and for each material, a new <code class="literal">THREE.Mesh</code> object is created. Because all the created meshes are added to group, the result looks like a single mesh that's created with multiple materials.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec187"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When you use the approach from this recipe to create a material that uses multiple materials, the materials are applied to the complete geometry. In the <span class="emphasis"><em>Using separate materials for faces</em></span> recipe, we show you how to use a different material for each specific face of a geometry.</li></ul></div></div></div>
<div class="section" title="Using separate materials for faces"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec59"/>Using separate materials for faces</h1></div></div></div><p>Each geometry in Three.js consists of a number of vertices and faces. In most cases, when<a id="id326" class="indexterm"/> you define a material that can be used together <a id="id327" class="indexterm"/>with a geometry, you use a single material. With Three.js, however, it is also possible to define a unique material for each of the faces of your geometry. You could, for instance, use this to apply different textures to each side of a model of a house. In this recipe, we will explain how to set up the materials so that you can use different textures for individual faces.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec188"/>Getting ready</h2></div></div></div><p>In this recipe, we won't use any external textures or libraries. It is good, however, to look at the final result that we'll be creating in this recipe. For this, open the <code class="literal">04.06-use-separate-materials-for-faces.html</code> example in your browser.</p><div class="mediaobject"><img src="graphics/1182OS_04_12.jpg" alt="Getting ready"/></div><p>In the preceeding screenshot, you can see a rotating sphere, where each face is rendered with a different color and half of the faces have been made transparent. In the following section, we'll show you the steps you need to take to recreate this.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec189"/>How to do it...</h2></div></div></div><p>To define <a id="id328" class="indexterm"/>specific materials for each face, we need to<a id="id329" class="indexterm"/> perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create the geometry. For this recipe, we use <code class="literal">THREE.SphereGeometry</code>, but these steps can also be applied to other geometries:<div class="informalexample"><pre class="programlisting">var sphereGeometry = new THREE.SphereGeometry(3, 10, 10);</pre></div></li><li class="listitem">When we create the material in step 3, we provide an array of materials that we want to use. Additionally, we need to specify on each face the material from the array we'll use. You can do this with the following code:<div class="informalexample"><pre class="programlisting">var materials = [];
var count = 0;
sphereGeometry.faces.forEach(function(face) {
    face.materialIndex = count++;
    var material = new THREE.MeshBasicMaterial(
        {color:Math.abs(Math.sin(count/70))*0xff0000});
    material.side = THREE.DoubleSide;
    if (count % 2 == 0) {
        material.transparent = true;
        material.opacity = 0.4;
    }
    materials.push(material);
});</pre></div><p>In this code snippet, we traverse all the faces of the geometry we created. For each face, we set the <code class="literal">materialIndex</code> property to the index of the material we want to use. We also create a unique <code class="literal">material</code> object for each face in this code snippet, make half of them transparent, and finally, push the materials we create into the materials array.</p></li><li class="listitem">At this point, the materials array contains a unique material for each face of the geometry, and for all the faces, the <code class="literal">materialIndex</code> property points to one of the materials in that array. Now, we can create <code class="literal">THREE.MeshFaceMaterial</code> object and together with the geometry, we can create <code class="literal">THREE.Mesh</code>:<div class="informalexample"><pre class="programlisting">  var sphere = new THREE.Mesh(
    sphereGeometry, new THREE.MeshFaceMaterial(materials));
  scene.add(sphere);</pre></div></li></ol></div><p>That's it. Each face of the geometry will use the material it points to.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec190"/>How it works...</h2></div></div></div><p>Because we specify <code class="literal">materialIndex</code> on each <code class="literal">THREE.Face</code> object, Three.js knows which material from the provided array it should use when it wants to render a specific face. One<a id="id330" class="indexterm"/> thing you need to take into account is that<a id="id331" class="indexterm"/> this can affect the performance of your scene, as each of the materials needs to be managed by Three.js; however, the performance is better than using separate meshes but worse than combining the textures into one.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec191"/>There's more…</h2></div></div></div><p>Some of the geometries Three.js provides already set a <code class="literal">materialIndex</code> property when you instantiate them. For instance, when you create <code class="literal">THREE.BoxGeometry</code>, the first two faces are mapped to <code class="literal">materialIndex 1</code>, the next two are mapped to <code class="literal">materialIndex 2</code>, and so on. So, if you want to style the sides of a box, you just have to provide an array with six materials.</p><p>Another interesting use of using materials for specific faces is that you can easily create interesting patterns, for instance, when you can very easily create a checked layout like this:</p><div class="mediaobject"><img src="graphics/1182OS_04_13.jpg" alt="There's more…"/></div><p>All you need is some small change to how you assign the <code class="literal">materialIndex</code> properties like this:</p><div class="informalexample"><pre class="programlisting">var plane = new THREE.PlaneGeometry(10, 10, 9, 9);

var materials = [];
var material_1 = new THREE.MeshBasicMaterial(
     {color:Math.random()*0xff0000, side: THREE.DoubleSide});
var material_2 = new THREE.MeshBasicMaterial(
      {color:Math.random()*0xff0000, side: THREE.DoubleSide});

materials.push(material_1);
materials.push(material_2);

var index = 0;
for (var i = 0 ; i &lt; plane.faces.length-1 ; i+=2) {
    var face = plane.faces[i];
    var nextFace = plane.faces[i+1];
    face.materialIndex = index;
    nextFace.materialIndex = index;

    if (index === 0) {
        index = 1;
    } else {
        index = 0;
    }
}</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec192"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you <a id="id332" class="indexterm"/>don't want to style specific faces<a id="id333" class="indexterm"/> but apply multiple materials to a complete geometry, you can look at the <span class="emphasis"><em>Creating a mesh with multiple materials</em></span> recipe, where we explain how to do just that</li></ul></div></div></div>
<div class="section" title="Setting up repeating textures"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec60"/>Setting up repeating textures</h1></div></div></div><p>Sometimes, when <a id="id334" class="indexterm"/>you've found a texture you want to apply, you might want to repeat it. For instance, if you've got a large ground plane on which you want to apply a seamless wood texture, you don't want the texture to be applied as a single image for the whole plane. Three.js allows you to define the manner in which a texture is repeated when it is used on a geometry. In this recipe, we'll explain the steps you need to take to accomplish this.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec193"/>Getting ready</h2></div></div></div><p>The first thing we need is the image that we'll use for a texture. For the best effect, you should use seamless textures. A seamless texture can be repeated without showing the seam between<a id="id335" class="indexterm"/> two textures next to each other. For this recipe, we'll use the <code class="literal">webtreats_metal_6-512px.jpg</code> texture, which you can find in the <code class="literal">asset/textures</code> folder that you can find in the sources for this book.</p><div class="mediaobject"><img src="graphics/1182OS_04_30.jpg" alt="Getting ready"/></div><p>To see the repeat effect in practice, you can open the <code class="literal">04.12-setup-repeating-textures.html</code> example in your browser.</p><div class="mediaobject"><img src="graphics/1182OS_04_31.jpg" alt="Getting ready"/></div><p>With the<a id="id336" class="indexterm"/> menu in the top-right corner, you can define how often the texture is repeated along its <span class="emphasis"><em>x</em></span> axis and <span class="emphasis"><em>y</em></span> axis.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec194"/>How to do it...</h2></div></div></div><p>To set up a repeating texture is very simple and only requires a couple of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create the geometry and the material:<div class="informalexample"><pre class="programlisting">var cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
var cubeMaterial = new THREE.MeshPhongMaterial();</pre></div><p>In this recipe, we use <code class="literal">THREE.MeshPhongMaterial</code>, but you can use this recipe for all the materials that allow you use textures.</p></li><li class="listitem">Next, we load the texture and set it on <code class="literal">cubeMaterial</code>:<div class="informalexample"><pre class="programlisting">cubeMaterial.map = THREE.ImageUtils.loadTexture
       ("../assets/textures/webtreats_metal_6-512px.jpg");</pre></div></li><li class="listitem">The next step is to set the <code class="literal">wrapS</code> and <code class="literal">wrapT</code> properties on the texture:<div class="informalexample"><pre class="programlisting">cubeMaterial.map.wrapS = cubeMaterial.map.wrapT 
                       = THREE.RepeatWrapping; </pre></div><p>These properties define whether Three.js should stretch the texture to the side (<code class="literal">THREE.ClampToEdgeWrapping</code>) or repeat the texture with <code class="literal">THREE.RepeatWrapping</code>.</p></li><li class="listitem">The final step is to set how often to repeat the texture along the <span class="emphasis"><em>x</em></span> axis and <span class="emphasis"><em>y</em></span> axis:<div class="informalexample"><pre class="programlisting">cubeMaterial.map.repeat.set( 2, 2 );</pre></div><p>In this case, we repeat the texture along both its axis twice.</p></li><li class="listitem">An interesting thing to know is that by providing negative values to the <code class="literal">map.repeat.set</code> function, you can also mirror the texture.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec195"/>How it works...</h2></div></div></div><p>Each <a id="id337" class="indexterm"/>face within a geometry has a UV mapping that defines which part of a texture should be used for that face. When you configure a repeat wrapping, Three.js changes this UV mapping according to the values that have been set on the <code class="literal">map.repeat</code> property. As we also define that we want to use <code class="literal">THREE.RepeatWrapping</code>, WebGL knows how to interpret these changed UV values.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec196"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Repeating textures works by changing the UV mapping according to the repeat property. You can also configure a UV mapping by hand, as shown in the <span class="emphasis"><em>Using Blender to create custom UV mapping</em></span> recipe.</li></ul></div></div></div>
<div class="section" title="Making part of an object transparent"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec61"/>Making part of an object transparent</h1></div></div></div><p>You can create a lot of interesting visualizations using the various materials available with Three.js. In this recipe, we'll look at how you can use the materials available with Three.js to make part of an object transparent. This will allow you to create complex-looking geometries with relative ease.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec197"/>Getting ready</h2></div></div></div><p>Before we <a id="id338" class="indexterm"/>dive into the required steps in Three.js, we first need to have the texture that we will use to make an object partially transparent. For this recipe, we will use the following texture, which was created in Photoshop:</p><div class="mediaobject"><img src="graphics/1182OS_04_14.jpg" alt="Getting ready"/></div><p>You don't have<a id="id339" class="indexterm"/> to use Photoshop; the only thing you need to keep in mind is that you use an image with a transparent background. Using this texture, in this recipe, we'll show you how you can create the following (<code class="literal">04.08-make-part-of-object-transparent.html</code>):</p><div class="mediaobject"><img src="graphics/1182OS_04_15.jpg" alt="Getting ready"/></div><p>As you<a id="id340" class="indexterm"/> can see in the preceeding, only part of the sphere is visible, and you can look through the sphere to see the back at the other side of the sphere.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec198"/>How to do it...</h2></div></div></div><p>Let's look at the steps you need to take to accomplish this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we do is create the geometry. For this recipe, we use <code class="literal">THREE.SphereGeometry</code>:<div class="informalexample"><pre class="programlisting">var sphereGeometry = new THREE.SphereGeometry(6, 20, 20);</pre></div><p>Just like all the other recipes, you can use whatever geometry you want.</p></li><li class="listitem">In the second step, we create the material:<div class="informalexample"><pre class="programlisting">var mat = new THREE.MeshPhongMaterial();
mat.map = new THREE.ImageUtils.loadTexture(
         "../assets/textures/partial-transparency.png");
mat.transparent = true;
mat.side = THREE.DoubleSide;
mat.depthWrite = false;
mat.color = new THREE.Color(0xff0000);</pre></div><p>As you can see in this fragment, we create <code class="literal">THREE.MeshPhongMaterial</code> and load the texture we saw in the <span class="emphasis"><em>Getting ready</em></span> section of this recipe. To render this correctly, we also need to set the side property to <code class="literal">THREE.DoubleSide</code> so that the inside of the sphere is also rendered, and we need to set the <code class="literal">depthWrite</code> property to false. This will tell WebGL that we still want to test our vertices against the WebGL depth buffer, but we don't write to it. Often, you need to set this to false when working with more complex transparent objects or particles.</p></li><li class="listitem">Finally, add the sphere to the scene:<div class="informalexample"><pre class="programlisting">var sphere = new THREE.Mesh(sphereGeometry, mat);
scene.add(sphere);</pre></div></li></ol></div><p>With these <a id="id341" class="indexterm"/>simple steps, you can create really interesting effects by just experimenting with textures and geometries.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec199"/>There's more…</h2></div></div></div><p>With Three.js, it is possible to repeat textures (refer to the <span class="emphasis"><em>Setup repeating textures</em></span> recipe). You can use this to create interesting-looking objects such as this:</p><div class="mediaobject"><img src="graphics/1182OS_04_16.jpg" alt="There's more…"/></div><p>The code required to set a texture to repeat is the following:</p><div class="informalexample"><pre class="programlisting">var mat = new THREE.MeshPhongMaterial();
mat.map = new THREE.ImageUtils.loadTexture(
               "../assets/textures/partial-transparency.png");
mat.transparent = true;
mat.map.wrapS = mat.map.wrapT = THREE.RepeatWrapping;
mat.map.repeat.set( 4, 4 );
mat.depthWrite = false;
mat.color = new THREE.Color(0x00ff00);</pre></div><p>By changing the <code class="literal">mat.map.repeat.set</code> values, you define how often the texture is repeated.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec200"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There <a id="id342" class="indexterm"/>are two alternative ways of making part of an object transparent. You could divide the object into multiple geometries and group them, or you could make individual faces transparent like we did in the <span class="emphasis"><em>Using separate materials for faces</em></span> recipe.</li></ul></div></div></div>
<div class="section" title="Using a cubemap to create reflective materials"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec62"/>Using a cubemap to create reflective materials</h1></div></div></div><p>With <a id="id343" class="indexterm"/>the approach Three.js uses to render<a id="id344" class="indexterm"/> scenes in real time, it is difficult and very computationally intensive to create reflective materials. Three.js, however, provides a way you can cheat and approximate reflectivity. For this, Three.js uses cubemaps. In this recipe, we'll explain how to create cubemaps and use them to create reflective materials.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec201"/>Getting ready</h2></div></div></div><p>A cubemap is a set of six images that can be mapped to the inside of a cube. They can be created from a panorama picture and look something like this:</p><div class="mediaobject"><img src="graphics/1182OS_04_17.jpg" alt="Getting ready"/></div><p>In <a id="id345" class="indexterm"/>Three.js, we map such a map on the <a id="id346" class="indexterm"/>inside of a cube or sphere and use that information to calculate reflections. The following screenshot (example <code class="literal">04.10-use-reflections.html</code>) shows what this looks like when rendered in Three.js:</p><div class="mediaobject"><img src="graphics/1182OS_04_18.jpg" alt="Getting ready"/></div><p>As you can see in the preceeding screenshot, the objects in the center of the scene reflect the environment they are in. This is something often called a skybox. To get ready, the first thing we need to do is<a id="id347" class="indexterm"/> get a cubemap. If you search on <a id="id348" class="indexterm"/>the Internet, you can find some ready-to-use cubemaps, but it is also very easy to create one yourself. For this, go to <a class="ulink" href="http://gonchar.me/panorama/">http://gonchar.me/panorama/</a>. On this page, you can upload a panoramic picture and it will be converted to a set of pictures you can use as a cubemap. For this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, get a 360 degrees panoramic picture. Once you have one, upload it to the <a class="ulink" href="http://gonchar.me/panorama/">http://gonchar.me/panorama/</a> website by clicking on the large <span class="strong"><strong>OPEN</strong></span> button:<div class="mediaobject"><img src="graphics/1182OS_04_19.jpg" alt="Getting ready"/></div></li><li class="listitem">Once uploaded, the tool will convert the panorama picture to a cubemap as shown in the following screenshot:<div class="mediaobject"><img src="graphics/1182OS_04_20.jpg" alt="Getting ready"/></div></li><li class="listitem">When <a id="id349" class="indexterm"/>the conversion is done, you<a id="id350" class="indexterm"/> can download the various cube map sites. The recipe in this book uses the naming convention provided by <span class="strong"><strong>Cube map sides</strong></span> option, so download them. You'll end up with six images with names such as <code class="literal">right.png</code>, <code class="literal">left.png</code>, <code class="literal">top.png</code>, <code class="literal">bottom.png</code>, <code class="literal">front.png</code>, and <code class="literal">back.png</code>.</li></ol></div><p>Once you've got the sides of the cubemap, you're ready to perform the steps in the recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec202"/>How to do it...</h2></div></div></div><p>To use the cubemap we created in the previous section and create reflecting material,we need to perform a fair number of steps, but it isn't that complex:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing you need to do is create an array from the cubemap images you downloaded:<div class="informalexample"><pre class="programlisting">var urls = [
    '../assets/cubemap/flowers/right.png',
    '../assets/cubemap/flowers/left.png',
    '../assets/cubemap/flowers/top.png',
    '../assets/cubemap/flowers/bottom.png',
    '../assets/cubemap/flowers/front.png',
    '../assets/cubemap/flowers/back.png'
];</pre></div></li><li class="listitem">With this array, we can create a cubemap texture like this:<div class="informalexample"><pre class="programlisting">var cubemap = THREE.ImageUtils.loadTextureCube(urls);
cubemap.format = THREE.RGBFormat;</pre></div></li><li class="listitem">From this cubemap, we can use <code class="literal">THREE.BoxGeometry</code> and a custom <code class="literal">THREE.ShaderMaterial</code> object to create a skybox (the environment surrounding<a id="id351" class="indexterm"/> our meshes):<div class="informalexample"><pre class="programlisting">var shader = THREE.ShaderLib[ "cube" ];
shader.uniforms[ "tCube" ].value = cubemap;

var material = new THREE.ShaderMaterial( {

    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: shader.uniforms,
    depthWrite: false,
    side: THREE.DoubleSide

});

// create the skybox
var skybox = new THREE.Mesh( new THREE.BoxGeometry( 10000, 10000, 10000 ), material );
scene.add(skybox);</pre></div><p>Three.js provides a custom shader (a piece of WebGL code) that we can use for this. As you can see in the code snippet, to use this WebGL code, we need to define a <code class="literal">THREE.ShaderMaterial</code> object. With this material, we create a giant <code class="literal">THREE.BoxGeometry</code> object that we add to scene.</p></li><li class="listitem">Now<a id="id352" class="indexterm"/> that we've created the skybox, we can define the reflecting objects:<div class="informalexample"><pre class="programlisting">var sphereGeometry = new THREE.SphereGeometry(4,15,15);
var envMaterial = new THREE.MeshBasicMaterial(
                                 {envMap:cubemap});
var sphere = new THREE.Mesh(sphereGeometry, envMaterial);</pre></div><p>As you can see, we also pass in the cubemap we created as a property (<code class="literal">envmap</code>) to the material. This informs Three.js that this object is positioned inside a skybox, defined by the images that make up <code class="literal">cubemap</code>.</p></li><li class="listitem">The last step is to add the object to the scene, and that's it:<div class="informalexample"><pre class="programlisting">scene.add(sphere);</pre></div></li></ol></div><p>In the example in the beginning of this recipe, you saw three geometries. You can use this approach with all different types of geometries. Three.js will determine how to render the reflective area.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec203"/>How it works...</h2></div></div></div><p>Three.js itself doesn't really do that much to render the <code class="literal">cubemap</code> object. It relies on a standard functionality provided by WebGL. In WebGL, there is a construct called <code class="literal">samplerCube</code>. With <code class="literal">samplerCube</code>, you can sample, based on a specific direction, which color<a id="id353" class="indexterm"/> matches the <code class="literal">cubemap</code> object. Three.js uses this to determine the color value for each part of the geometry. The result is<a id="id354" class="indexterm"/> that on each mesh, you can see a reflection of the surrounding cubemap using the WebGL <code class="literal">textureCube</code> function. In Three.js, this results in the following call (taken from the WebGL shader in GLSL):</p><div class="informalexample"><pre class="programlisting">vec4 cubeColor = textureCube( tCube, 
                 vec3( -vReflect.x, vReflect.yz ) );</pre></div><p>A more <a id="id355" class="indexterm"/>in-depth explanation on how this works can be found at <a class="ulink" href="http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/#cubemap-lookup">http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/#cubemap-lookup</a>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec204"/>There's more...</h2></div></div></div><p>In this recipe, we created the <code class="literal">cubemap</code> object by providing six separate images. There is, however, an alternative way to create the <code class="literal">cubemap</code> object. If you've got a 360 degrees panoramic image, you can use the following code to directly create a <code class="literal">cubemap</code> object from that image:</p><div class="informalexample"><pre class="programlisting">var texture = THREE.ImageUtils.loadTexture( 360-degrees.png',
              new THREE.UVMapping());</pre></div><p>Normally when you create a <code class="literal">cubemap</code> object, you use the code shown in this recipe to map it to a skybox. This usually gives the best results but requires some extra code. You can also use <code class="literal">THREE.SphereGeometry</code> to create a skybox like this:</p><div class="informalexample"><pre class="programlisting">var mesh = new THREE.Mesh( 
          new THREE.SphereGeometry( 500, 60, 40 ), 
          new THREE.MeshBasicMaterial( { map: texture }));
mesh.scale.x = -1;</pre></div><p>This applies the texture to a sphere and with <code class="literal">mesh.scale</code>, turns this sphere inside out.</p><p>Besides reflection, you can also use a <code class="literal">cubemap</code> object for refraction (think about light bending through water drops or glass objects):</p><div class="mediaobject"><img src="graphics/1182OS_04_21.jpg" alt="There's more..."/></div><p>All you <a id="id356" class="indexterm"/>have to do to make a refractive<a id="id357" class="indexterm"/> material is load the <code class="literal">cubemap</code> object like this:</p><div class="informalexample"><pre class="programlisting">var cubemap = THREE.ImageUtils.loadTextureCube(urls, new THREE.CubeRefractionMapping());</pre></div><p>And define the material in the following way:</p><div class="informalexample"><pre class="programlisting">var envMaterial = new THREE.MeshBasicMaterial({envMap:cubemap});
envMaterial.refractionRatio = 0.95;</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec205"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you look closely at the example shown at the beginning of this recipe, you might notice that you don't see the reflections of the individual objects on each other. You only see the reflection of the skybox. In the <span class="emphasis"><em>Using a dynamic cubemap to create reflective materials</em></span> recipe, we show you how you can make the <code class="literal">cubemap</code> object dynamic so that other rendered meshes are reflected.</li></ul></div></div></div>
<div class="section" title="Using a dynamic cubemap to create reflective materials"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec63"/>Using a dynamic cubemap to create reflective materials</h1></div></div></div><p>In the <span class="emphasis"><em>Using a cubemap to create reflective materials</em></span> recipe, we showed how you can create<a id="id358" class="indexterm"/> a material that reflects its<a id="id359" class="indexterm"/> environment. The only caveat was that other meshes rendered in the scene didn't show up in the reflection; only the cubemap was shown. In this recipe, we will show you how you can create a dynamic cubemap that also reflects other meshes in the scene.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec206"/>Getting ready</h2></div></div></div><p>To get ready for this recipe, you need to follow the steps explained in the <span class="emphasis"><em>Getting ready</em></span> section for the <span class="emphasis"><em>Using a cubemap to create reflective materials</em></span> recipe. For this recipe, we provide a separate example that you can display by opening <code class="literal">04.11-use-reflections-dynamically.html</code> in your browser.</p><div class="mediaobject"><img src="graphics/1182OS_04_22.jpg" alt="Getting ready"/></div><p>If you look closely at the central sphere in the preceding, you can see that it not only reflects the environment, but also reflects the cylinder, and if you rotate the scene, you can also see the cube reflection.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec207"/>How to do it...</h2></div></div></div><p>To accomplish this, we first need to perform a couple of the same steps, like we did in the <span class="emphasis"><em>Using a cubemap to create reflective materials</em></span> recipe. So, before you start with the steps in this recipe, take the first three steps from that recipe. After these three steps, you can continue<a id="id360" class="indexterm"/> with these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To<a id="id361" class="indexterm"/> create a dynamic cubemap, we need to use <code class="literal">THREE.CubeCamera</code>:<div class="informalexample"><pre class="programlisting">cubeCamera = new THREE.CubeCamera( 0.1, 20000, 256 );
cubeCamera.renderTarget.minFilter = THREE.LinearMipMapLinearFilter;
scene.add( cubeCamera );</pre></div><p>With <code class="literal">THREE.CubeCamera</code>, we can take a snapshot of the environment and use it as the <code class="literal">cubemap</code> object in our materials. For the best result, you should position <code class="literal">THREE.CubeCamera</code> at the same location as the mesh on which you want to use the dynamic <code class="literal">cubemap</code> object. In this recipe, we use it on the central sphere, which is located at this position: 0, 0, 0. So, we don't need to set the position of <code class="literal">cubeCamera</code>.</p></li><li class="listitem">For this recipe, we use three geometries:<div class="informalexample"><pre class="programlisting">var sphereGeometry = new THREE.SphereGeometry(4,15,15);
var cubeGeometry = new THREE.BoxGeometry(5,5,5);
var cylinderGeometry = new THREE.CylinderGeometry(2,4,10,20, false);</pre></div></li><li class="listitem">Next, we're going to define the materials. We use the following two materials:<div class="informalexample"><pre class="programlisting">var dynamicEnvMaterial = new THREE.MeshBasicMaterial({envMap: cubeCamera.renderTarget });
var envMaterial = new THREE.MeshBasicMaterial({envMap: cubemap });</pre></div><p>The first one is the material that uses the output from <code class="literal">cubeCamera</code> as its cubemap, and the second material uses a static <code class="literal">cubemap</code> object.</p></li><li class="listitem">With these two materials, we can create the meshes and add them to the scene:<div class="informalexample"><pre class="programlisting">var sphere = new THREE.Mesh(sphereGeometry, dynamicEnvMaterial);
sphere.name='sphere';
scene.add(sphere);

var cylinder = new THREE.Mesh(cylinderGeometry, envMaterial);
cylinder.name='cylinder';
scene.add(cylinder);
cylinder.position.set(10,0,0);

var cube = new THREE.Mesh(cubeGeometry, envMaterial);
cube.name='cube';
scene.add(cube);
cube.position.set(-10,0,0);</pre></div></li><li class="listitem">The last step we need to take is that in the <code class="literal">render</code> loop, we update <code class="literal">cubeCamera</code> like this:<div class="informalexample"><pre class="programlisting">function render() {
    sphere.visible = false;
    cubeCamera.updateCubeMap( renderer, scene );
    sphere.visible = true;
    renderer.render(scene, camera);
    ...
    requestAnimationFrame(render);
}</pre></div></li></ol></div><p>When<a id="id362" class="indexterm"/> you've taken all these<a id="id363" class="indexterm"/> steps, you'll end up with a sphere in the middle of the scene that not only reflects the environment, but also the other objects in the scene.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec208"/>How it works...</h2></div></div></div><p>In the <span class="emphasis"><em>Using a cubemap to create reflective materials</em></span> recipe we explained how a cubemap is used to create reflective objects. The same principle also applies to this recipe, so if you haven't read the <span class="emphasis"><em>How it works…</em></span> section from the <span class="emphasis"><em>Using a cubemap to create reflective materials</em></span> recipe, please do that first. The main difference is that for this recipe, we create a cubemap on the fly with <code class="literal">THREE.CubeCamera</code> instead of using a static one. When you instantiate <code class="literal">THREE.CubeCamera</code>, you're really creating six <code class="literal">THREE.PerspectiveCamera</code> objects—one for each side of the cubemap. Whenever you call <code class="literal">updateCubeMap</code>, as we do in this recipe in the <code class="literal">render</code> loop, Three.js just renders the scene using these six cameras and uses the render results as the cubemap to be used.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec209"/>There's more…</h2></div></div></div><p>In this recipe, we showed you how to make one mesh reflect the complete scene. If you create separate <code class="literal">THREE.CubeCamera</code> objects for each of the meshes in the scene, you can create a dynamic cubemap for all the objects. Keep in mind, though, that this is a rather computationally-intensive process. Instead of rendering the scene once, you incur six additional <a id="id364" class="indexterm"/>render passes for each cube camera you use.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec210"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a static cubemap, you can use the steps explained in the previous recipe,which is the <span class="emphasis"><em>Using a cubemap to create reflective materials</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Using Blender to create custom UV mapping"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec64"/>Using Blender to create custom UV mapping</h1></div></div></div><p>If you <a id="id365" class="indexterm"/>want to apply a texture (a 2D image) to <a id="id366" class="indexterm"/>a geometry, you need to tell Three.js which part of the texture should be used for a specific <code class="literal">THREE.face</code> object. The definition of how a texture maps to the individual faces of a geometry is called a UV mapping. A UV mapping, for example, tells Three.js how to map a 2D map of the earth to a 3D sphere geometry. When you're working with simple shapes, or the basic geometries provided with Three.js, the standard UV mapping that's provided is often enough. However, when shapes become more complex or you have some specific texture mapping requirements, you need to change how each face of a geometry is mapped to part of a texture. One option is to do this by hand, but for larger geometries, this is very difficult and time-consuming. In this recipe, we will show you how you can create a custom mapping with Blender.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec211"/>Getting ready</h2></div></div></div><p>For this recipe, you need to have Blender installed; if you haven't installed Blender yet, look at the <span class="emphasis"><em>Getting ready</em></span> section of the <span class="emphasis"><em>Creating and exporting a model from Blender</em></span> recipe from <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <span class="emphasis"><em>Geometries and Meshes</em></span>. Once you've installed Blender, start it and you're presented with a screen similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/1182OS_04_23.jpg" alt="Getting ready"/></div><p>In<a id="id367" class="indexterm"/> the following section, we'll show you<a id="id368" class="indexterm"/> the steps you need to take to create a custom UV mapping for this cube.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec212"/>How to do it...</h2></div></div></div><p>The following steps explain how to create a custom UV mapping in Blender and use it in Three.js:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing to do is switch to edit mode. To do this, hover the mouse over the cube and hit <span class="strong"><strong>tab</strong></span>. You should see something like this:<div class="mediaobject"><img src="graphics/1182OS_04_24.jpg" alt="How to do it..."/></div><p>If the cube isn't highlighted, hover over it with the mouse and push a. This will select all the vertices and faces.</p></li><li class="listitem">Now, let's<a id="id369" class="indexterm"/> create a standard<a id="id370" class="indexterm"/> UV mapping for this cube. To do this, navigate to <span class="strong"><strong>Mesh</strong></span> | <span class="strong"><strong>Uv Unwrap</strong></span> | <span class="strong"><strong>Unwrap</strong></span>. Now, split the active view and open the <span class="strong"><strong>UV/Image editor</strong></span> view.<div class="mediaobject"><img src="graphics/1182OS_04_25.jpg" alt="How to do it..."/></div><p>In the left part of the Blender window, we now see how all the selected faces and vertices are mapped to a texture.</p></li><li class="listitem">In <a id="id371" class="indexterm"/>the right-hand side <a id="id372" class="indexterm"/>view, select the front face, and you can immediately see how that face is mapped to the texture:<div class="mediaobject"><img src="graphics/1182OS_04_26.jpg" alt="How to do it..."/></div><p>Now, we can change the mapping of this face by moving the vertices on the left-hand side side of the screen. Before we do that, though, we first load a texture image.</p></li><li class="listitem">With<a id="id373" class="indexterm"/> your mouse on top<a id="id374" class="indexterm"/> of the left part of the screen, hit <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>O</em></span> to select an image. For this recipe, it is easiest to use the <code class="literal">debug.png</code> texture you can find in the <code class="literal">assets/textures</code> directory. Once you open the image, the screen will look like this:<div class="mediaobject"><img src="graphics/1182OS_04_27.jpg" alt="How to do it..."/></div></li><li class="listitem">By dragging the corners in the left view, we change the UV mapping of the selected face. Move these corners around to create something like this:<div class="mediaobject"><img src="graphics/1182OS_04_28.jpg" alt="How to do it..."/></div><p>As you can see, we changed the UV mapping for this face from the whole texture to just the top-left corner.</p></li><li class="listitem">The <a id="id375" class="indexterm"/>next step is to export <a id="id376" class="indexterm"/>this geometry, load it in Three.js, and see whether the mapping has really changed for the face we changed. To export the model, we'll use the <code class="literal">OBJ</code> format in this recipe. So, navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Export</strong></span> | <span class="strong"><strong>Wavefront</strong></span> and save the model.</li><li class="listitem">To load the model, we first need to include the <code class="literal">OBJLoader</code> JavaScript file on the header of the page:<div class="informalexample"><pre class="programlisting">&lt;script src="../libs/OBJLoader.js"&gt;&lt;/script&gt;</pre></div></li><li class="listitem">Now, we can use the loader to load the model and add it to the scene:<div class="informalexample"><pre class="programlisting">var loader = new THREE.OBJLoader();
loader.load("../assets/models/blender/uvmap.obj", function(model) {
    model.children[0].material.map = THREE.ImageUtils
         .loadTexture("../assets/textures/debug.png");
    scene.add(model);
});</pre></div><p>In this example, we explicitly set the texture we want to use, as we didn't use <code class="literal">OBJMTLLoader</code>.</p></li><li class="listitem">As a final step, let's look at the result. We provided an example, <code class="literal">04.14-create-custom-uv-mapping.html</code>, that shows the result of these steps.<div class="mediaobject"><img src="graphics/1182OS_04_29.jpg" alt="How to do it..."/></div></li></ol></div><p>As you<a id="id377" class="indexterm"/> can see from the preceding screenshot, the front face for which we <a id="id378" class="indexterm"/>changed the UV mapping shows only part of the texture, while the other sides show the complete texture.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec213"/>There's more…</h2></div></div></div><p>We've only touched upon a very small part of how Blender can help in creating UV mappings. A <a id="id379" class="indexterm"/>good starting point to learn more about UV mapping in Blender are the following two sites:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/UV_Map_Basics">http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/UV_Map_Basics</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://wiki.blender.org/index.php/Doc:2.6/Manual/Textures/Mapping/UV">http://wiki.blender.org/index.php/Doc:2.6/Manual/Textures/
Mapping/UV</a></li></ul></div><p>
</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec214"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information on how to integrate Three.js with Blender, you can have a look at the <span class="emphasis"><em>Creating and exporting a model from Blender</em></span> recipe, from <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <span class="emphasis"><em>Geometries and Meshes</em></span> where we show how to install the Three.js plugin for Blender and how you can load a model and its material directly in Three.js.</li></ul></div></div></div>
<div class="section" title="Configuring blend modes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec65"/>Configuring blend modes</h1></div></div></div><p>When<a id="id380" class="indexterm"/> an object is rendered on top of another object in Three.js, you can configure how to blend in the colors from the objects behind it. In this recipe, we show you the steps you need to take to set a specific blend mode. You can compare this with the way the various blending layers in Photoshop work.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec215"/>Getting ready</h2></div></div></div><p>Understanding the results of a specific blend mode is difficult. To help in understanding the different available blend modes, we provide a simple web page that shows you the blend modes and allows you to switch between them. You can see this example by opening <code class="literal">04.13-configuring-blend-modes.html</code> in your browser.</p><div class="mediaobject"><img src="graphics/1182OS_04_32.jpg" alt="Getting ready"/></div><p>With the<a id="id381" class="indexterm"/> menu in the top-right section of the preceding screenshot, you can see what the result of each blend mode is.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec216"/>How to do it...</h2></div></div></div><p>Setting a blend mode is easy:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create a geometry and a material:<div class="informalexample"><pre class="programlisting">var cubeGeometry = new THREE.BoxGeometry(10, 4, 10);
var cubeMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture("../assets/textures/debug.png")});</pre></div></li><li class="listitem">Next, set the <code class="literal">blending</code> property to the blend mode you want to use:<div class="informalexample"><pre class="programlisting">cubeMaterial.blending = THREE.SubtractiveBlending;</pre></div></li><li class="listitem">Then, set the <code class="literal">transparent</code> property to <code class="literal">true</code>:<div class="informalexample"><pre class="programlisting">cubeMaterial.transparent = true;</pre></div><p>You can find an overview of the available, standard blend modes by looking at the Three.js sources:</p><div class="informalexample"><pre class="programlisting">THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec217"/>How it works...</h2></div></div></div><p>As we've<a id="id382" class="indexterm"/> seen, Three.js uses WebGL to render the scenes. The blend modes you define on the material for Three.js are used internally by WebGL to determine how to blend the background color with the foreground color.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec218"/>There's more…</h2></div></div></div><p>Besides the blend modes we've shown in this recipe, it is also possible to define your own custom blend modes. You can do this by setting the <code class="literal">blending</code> property to <code class="literal">THREE.CustomBlending</code>. Use these three material properties to define how the foreground is blended with the background: <code class="literal">blendSrc</code>, <code class="literal">blendDst</code>, and <code class="literal">blendEquation</code>. For <code class="literal">blendSrc</code>, you can use the following values:</p><div class="informalexample"><pre class="programlisting">THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;</pre></div><p>For <code class="literal">blendDst</code>, you can use these values:</p><div class="informalexample"><pre class="programlisting">THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;</pre></div><p>For the <code class="literal">blendEquation</code>, WebGL supports the following set:</p><div class="informalexample"><pre class="programlisting">THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;</pre></div><p>A very good<a id="id383" class="indexterm"/> example that shows many of these settings can be found on the Three.js examples site at <a class="ulink" href="http://threejs.org/examples/#webgl_materials_blending_custom">http://threejs.org/examples/#webgl_materials_blending_custom</a>.</p></div></div>
<div class="section" title="Using a shadow map for fixed shadows"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec66"/>Using a shadow map for fixed shadows</h1></div></div></div><p>In <a class="link" href="ch05.html" title="Chapter 5. Lights and Custom Shaders">Chapter 5</a>, <span class="emphasis"><em>Lights and Custom Shaders</em></span> we will show you a number of recipes that deal with <a id="id384" class="indexterm"/>lights and shadows. It is, however, also <a id="id385" class="indexterm"/>possible to fake shadows using a texture. This kind of texture is called a shadow map or a light map. In this recipe, we explain how you can use such a texture in Three.js.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec219"/>Getting ready</h2></div></div></div><p>For this recipe, we first need a shadow map. There are different ways to create shadow maps, but that is outside the scope of this recipe. If you're interested in creating your own shadow maps, you<a id="id386" class="indexterm"/> can follow this tutorial from the Blender site: <a class="ulink" href="http://wiki.blender.org/index.php/Doc:2.4/Tutorials/Game_Engine/YoFrankie/Baking_Shadow_Maps">http://wiki.blender.org/index.php/Doc:2.4/Tutorials/Game_Engine/YoFrankie/Baking_Shadow_Maps</a>.</p><p>In the sources for this book, in the <code class="literal">assets/textures</code> folder, you can find a <code class="literal">shadow-map.png</code> file that we'll use in this recipe.</p><div class="mediaobject"><img src="graphics/1182OS_04_33.jpg" alt="Getting ready"/></div><p>In the preceding figure, you can see what a shadow map looks like. As you can see, a shadow map contains the shadows of a scene prerendered in the target geometry, in this case, a<a id="id387" class="indexterm"/> plane. If we use this image as a shadow<a id="id388" class="indexterm"/> map, we can easily view the following scene:</p><div class="mediaobject"><img src="graphics/1182OS_04_34.jpg" alt="Getting ready"/></div><p>In this scene, we use the shadow map to create shadows for the ground plane.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec220"/>How to do it...</h2></div></div></div><p>Using a shadow map is very easy. Before we look at the steps, make sure that you've got a geometry and a material. In the following steps, we have <code class="literal">THREE.Mesh</code> with the name floor:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A UV mapping defines how a face maps to a specific part of a texture. The UV mapping in a geometry is stored in the <code class="literal">faceVertexUvs</code> property of a geometry. The first element of this array contains the UV mappings used for the other kinds of textures, and the second element contains the UV mapping for the shadow map. As this value isn't filled by default, we point it to the first element in the <code class="literal">faceVertexUvs</code> array:<div class="informalexample"><pre class="programlisting">floor.geometry.faceVertexUvs[1] = floor.geometry.faceVertexUvs[0];</pre></div></li><li class="listitem">Next, you need to set the shadow map to the <code class="literal">lightmap</code> property of the material:<div class="informalexample"><pre class="programlisting">floor.material.lightMap = THREE.ImageUtils.loadTexture("../assets/textures/shadow-map-soft.png");</pre></div></li><li class="listitem">Finally, you add the other textures you might want to use:<div class="informalexample"><pre class="programlisting">floor.material.map = THREE.ImageUtils.loadTexture ("../assets/textures/tiles.jpg");</pre></div></li></ol></div><p>That's<a id="id389" class="indexterm"/> all you need to do. This works great, especially<a id="id390" class="indexterm"/> when you've got scenes with static meshes and fixed lights, and this is a great boost to performance.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec221"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you require dynamic shadows that update based on animated lighting or objects in the scene, you need something else (or in addition to) than shadow maps. In <a class="link" href="ch05.html" title="Chapter 5. Lights and Custom Shaders">Chapter 5</a>, <span class="emphasis"><em>Lights and Custom Shaders</em></span> in the <span class="emphasis"><em>Creating shadows with Three.SpotLight</em></span> recipe, we explain how to create dynamic shadows.</li></ul></div></div></div></body></html>