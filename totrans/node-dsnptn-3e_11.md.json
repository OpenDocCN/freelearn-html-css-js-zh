["```js\nimport { EventEmitter } from 'events'\nclass DB extends EventEmitter {\n  connected = false\n  connect () {\n    // simulate the delay of the connection\n    setTimeout(() => {\n      this.connected = true\n      this.emit('connected')\n    }, 500)\n  }\n  async query (queryString) {\n    if (!this.connected) {\n      throw new Error('Not connected yet')\n    }\n    console.log(`Query executed: ${queryString}`)\n  }\n}\nexport const db = new DB() \n```", "```js\nimport { once } from 'events'\nimport { db } from './db.js'\ndb.connect()\nasync function updateLastAccess () {\n  if (!db.connected) {\n    await once(db, 'connected')\n  }\n  await db.query(`INSERT (${Date.now()}) INTO \"LastAccesses\"`)\n}\nupdateLastAccess()\nsetTimeout(() => {\n  updateLastAccess()\n}, 600) \n```", "```js\nimport { db } from './db.js'\nimport { once } from 'events'\nasync function initialize () {\n  db.connect()\n  await once(db, 'connected')\n}\nasync function updateLastAccess () {\n  await db.query(`INSERT (${Date.now()}) INTO \"LastAccesses\"`)\n}\ninitialize()\n  .then(() => {\n    updateLastAccess()\n    setTimeout(() => {\n      updateLastAccess()\n    }, 600)\n  }) \n```", "```js\nimport { EventEmitter } from 'events'\nclass DB extends EventEmitter {\n  connected = false\n  commandsQueue = []\n  async query (queryString) {\n    if (!this.connected) {\n      console.log(`Request queued: ${queryString}`)\n      return new Promise((resolve, reject) => {            // (1)\n        const command = () => {\n          this.query(queryString)\n            .then(resolve, reject)\n        }\n        this.commandsQueue.push(command)\n      })\n    }\n    console.log(`Query executed: ${queryString}`)\n  }\n  connect () {\n    // simulate the delay of the connection\n    setTimeout(() => {\n      this.connected = true\n      this.emit('connected')\n      this.commandsQueue.forEach(command => command())     // (2)\n      this.commandsQueue = []\n    }, 500)\n  }\n}\nexport const db = new DB() \n```", "```js\nclass InitializedState {\n  async query (queryString) {\n    console.log(`Query executed: ${queryString}`)\n  }\n} \n```", "```js\nconst METHODS_REQUIRING_CONNECTION = ['query']\nconst deactivate = Symbol('deactivate')\nclass QueuingState {\n  constructor (db) {\n    this.db = db\n    this.commandsQueue = []\n    METHODS_REQUIRING_CONNECTION.forEach(methodName => {\n      this[methodName] = function (...args) {\n        console.log('Command queued:', methodName, args)\n        return new Promise((resolve, reject) => {\n          const command = () => {\n            db[methodName](...args)\n              .then(resolve, reject)\n          }\n          this.commandsQueue.push(command)\n        })\n      }\n    })\n  }\n  [deactivate] () {\n    this.commandsQueue.forEach(command => command())\n    this.commandsQueue = []\n  }\n} \n```", "```js\nclass DB extends EventEmitter {\n  constructor () {\n    super()\n    this.state = new QueuingState(this)                    // (1)\n  }\n  async query (queryString) {\n    return this.state.query(queryString)                   // (2)\n  }\n  connect () {\n    // simulate the delay of the connection\n    setTimeout(() => {\n      this.connected = true\n      this.emit('connected')\n      const oldState = this.state                          // (3)\n      this.state = new InitializedState(this)\n      oldState[deactivate] && oldState[deactivate]()\n    }, 500)\n  }\n}\nexport const db = new DB() \n```", "```js\ntransactionId {amount, product} \n```", "```js\nimport level from 'level'\nimport sublevel from 'subleveldown'\nconst db = level('example-db')\nconst salesDb = sublevel(db, 'sales', { valueEncoding: 'json' })\nexport async function totalSales (product) {\n  const now = Date.now()\n  let sum = 0\n  for await (const transaction of salesDb.createValueStream()) {\n    if (!product || transaction.product === product) {\n      sum += transaction.amount\n    }\n  }\n  console.log(`totalSales() took: ${Date.now() - now}ms`)\n  return sum\n} \n```", "```js\nimport { createServer } from 'http'\nimport { totalSales } from './totalSales.js'\ncreateServer(async (req, res) => {\n  const url = new URL(req.url, 'http://localhost')\n  const product = url.searchParams.get('product')\n  console.log(`Processing query: ${url.search}`)\n  const sum = await totalSales(product)\n  res.setHeader('Content-Type', 'application/json')\n  res.writeHead(200)\n  res.end(JSON.stringify({\n    product,\n    sum\n  }))\n}).listen(8000, () => console.log('Server started')) \n```", "```js\nnode populateDb.js \n```", "```js\nnode server.js \n```", "```js\nhttp://localhost:8000?product=book \n```", "```js\nnode loadTest.js \n```", "```js\nimport { totalSales as totalSalesRaw } from './totalSales.js'\nconst runningRequests = new Map()\nexport function totalSales (product) {\n  if (runningRequests.has(product)) {                      // (1)\n    console.log('Batching')\n    return runningRequests.get(product)\n  }\n  const resultPromise = totalSalesRaw(product)             // (2)\n  runningRequests.set(product, resultPromise)\n  resultPromise.finally(() => {\n    runningRequests.delete(product)\n  })\n  return resultPromise\n} \n```", "```js\n// import { totalSales } from './totalSales.js'\n**import** **{ totalSales }** **from****'./totalSalesBatch.js'**\ncreateServer(async (req, res) => {\n  // ... \n```", "```js\nimport { totalSales as totalSalesRaw } from './totalSales.js'\nconst CACHE_TTL = 30 * 1000 // 30 seconds TTL\nconst cache = new Map()\nexport function totalSales (product) {\n  if (cache.has(product)) {\n    console.log('Cache hit')\n    return cache.get(product)\n  }\n  const resultPromise = totalSalesRaw(product)\n  cache.set(product, resultPromise)\n  **resultPromise.then(****() =>** **{**\n    **setTimeout****(****() =>** **{**\n      **cache.delete(product)**\n    **}, CACHE_TTL)**\n  **},** **err** **=>** **{**\n    **cache.delete(product)**\n    **throw** **err**\n  **})**\n  return resultPromise\n} \n```", "```js\n// import { totalSales } from './totalSales.js'\n// import { totalSales } from './totalSalesBatch.js'\n**import** **{ totalSales }** **from****'./totalSalesCache.js'**\ncreateServer(async (req, res) => {\n  // ... \n```", "```js\nimport { asyncRoutine } from './asyncRoutine.js'\nimport { CancelError } from './cancelError.js'\nasync function cancelable (cancelObj) {\n  const resA = await asyncRoutine('A')\n  console.log(resA)\n  **if** **(cancelObj.cancelRequested) {**\n    **throw****new** **CancelError()**\n  **}**\n  const resB = await asyncRoutine('B')\n  console.log(resB)\n  **if** **(cancelObj.cancelRequested) {**\n    **throw****new** **CancelError()**\n  **}**\n  const resC = await asyncRoutine('C')\n  console.log(resC)\n} \n```", "```js\nconst cancelObj = { cancelRequested: false }\ncancelable(cancelObj)\n  .catch(err => {\n    if (err instanceof CancelError) {\n      console.log('Function canceled')\n    } else {\n      console.error(err)\n    }\n  })\nsetTimeout(() => {\n  cancelObj.cancelRequested = true\n}, 100) \n```", "```js\nimport { CancelError } from './cancelError.js'\nexport function createCancelWrapper () {\n  let cancelRequested = false\n  function cancel () {\n    cancelRequested = true\n  }\n  function cancelWrapper (func, ...args) {\n    if (cancelRequested) {\n      return Promise.reject(new CancelError())\n    }\n    return func(...args)\n  }\n  return { cancelWrapper, cancel }\n} \n```", "```js\nimport { asyncRoutine } from './asyncRoutine.js'\nimport { createCancelWrapper } from './cancelWrapper.js'\nimport { CancelError } from './cancelError.js'\nasync function cancelable (cancelWrapper) {\n  const resA = await cancelWrapper(asyncRoutine, 'A')\n  console.log(resA)\n  const resB = await cancelWrapper(asyncRoutine, 'B')\n  console.log(resB)\n  const resC = await cancelWrapper(asyncRoutine, 'C')\n  console.log(resC)\n}\nconst { cancelWrapper, cancel } = createCancelWrapper()\ncancelable(cancelWrapper)\n  .catch(err => {\n    if (err instanceof CancelError) {\n      console.log('Function canceled')\n    } else {\n      console.error(err)\n    }\n  })\nsetTimeout(() => {\n  cancel()\n}, 100) \n```", "```js\nimport { CancelError } from './cancelError.js'\nexport function createAsyncCancelable (generatorFunction) {   // (1)\n  return function asyncCancelable (...args) {\n    const generatorObject = generatorFunction(...args)        // (3)\n    let cancelRequested = false\n    function cancel () {\n      cancelRequested = true\n    }\n    const promise = new Promise((resolve, reject) => {\n      async function nextStep (prevResult) {                  // (4)\n        if (cancelRequested) {\n          return reject(new CancelError())\n        }\n        if (prevResult.done) {\n          return resolve(prevResult.value)\n        }\n        try {                                                 // (5)\n          nextStep(generatorObject.next(await prevResult.value))\n        } catch (err) {\n          try {                                               // (6)\n            nextStep(generatorObject.throw(err))\n          } catch (err2) {\n            reject(err2)\n          }\n        }\n      }\n      nextStep({})\n    })\n    return { promise, cancel }                                // (2)\n  }\n} \n```", "```js\nimport { asyncRoutine } from './asyncRoutine.js'\nimport { createAsyncCancelable } from './createAsyncCancelable.js'\nimport { CancelError } from './cancelError.js'\nconst cancelable = createAsyncCancelable(function * () {\n  const resA = yield asyncRoutine('A')\n  console.log(resA)\n  const resB = yield asyncRoutine('B')\n  console.log(resB)\n  const resC = yield asyncRoutine('C')\n  console.log(resC)\n})\nconst { promise, cancel } = cancelable()\npromise.catch(err => {\n  if (err instanceof CancelError) {\n    console.log('Function canceled')\n  } else {\n    console.error(err)\n  }\n})\nsetTimeout(() => {\n  cancel()\n}, 100) \n```", "```js\nexport class SubsetSum extends EventEmitter {\n  constructor (sum, set) {\n    super()\n    this.sum = sum\n    this.set = set\n    this.totalSubsets = 0\n  }\n//... \n```", "```js\n_combine (set, subset) {\n  for (let i = 0; i < set.length; i++) {\n    const newSubset = subset.concat(set[i])\n    this._combine(set.slice(i + 1), newSubset)\n    this._processSubset(newSubset)\n  }\n} \n```", "```js\n_processSubset (subset) {\n  console.log('Subset', ++this.totalSubsets, subset)\n  const res = subset.reduce((prev, item) => (prev + item), 0)\n  if (res === this.sum) {\n    this.emit('match', subset)\n  }\n} \n```", "```js\nstart () {\n  this._combine(this.set, [])\n  this.emit('end')\n} \n```", "```js\nimport { createServer } from 'http'\nimport { SubsetSum } from './subsetSum.js'\ncreateServer((req, res) => {\n  const url = new URL(req.url, 'http://localhost')\n  if (url.pathname !== '/subsetSum') {\n    res.writeHead(200)\n    return res.end('I\\'m alive!\\n')\n  }\n  const data = JSON.parse(url.searchParams.get('data'))\n  const sum = JSON.parse(url.searchParams.get('sum'))\n  res.writeHead(200)\n  const subsetSum = new SubsetSum(sum, data)\n  subsetSum.on('match', match => {\n    res.write(`Match: ${JSON.stringify(match)}\\n`)\n  })\n  subsetSum.on('end', () => res.end())\n  subsetSum.start()\n}).listen(8000, () => console.log('Server started')) \n```", "```js\nnode index.js \n```", "```js\ncurl -G http://localhost:8000/subsetSum --data-urlencode \"data=[16, 19,1,1,-16,9,1,-5,-2,17,-15,-97,19,-16,-4,-5,15]\" --data-urlencode \"sum=0\" \n```", "```js\ncurl -G http://localhost:8000 \n```", "```js\n_combineInterleaved (set, subset) {\n  this.runningCombine++\n  setImmediate(() => {\n    this._combine(set, subset)\n    if (--this.runningCombine === 0) {\n      this.emit('end')\n    }\n  })\n} \n```", "```js\n_combine (set, subset) {\n  for (let i = 0; i < set.length; i++) {\n    const newSubset = subset.concat(set[i])\n    **this****._combineInterleaved(set.slice(i +** **1****), newSubset)**\n    this._processSubset(newSubset)\n  }\n} \n```", "```js\nstart () {\n  this.runningCombine = 0\n  this._combineInterleaved(this.set, [])\n} \n```", "```js\nimport { createServer } from 'http'\n// import { SubsetSum } from './subsetSum.js'\n**import** **{ SubsetSum }** **from****'./subsetSumDefer.js'**\ncreateServer((req, res) => {\n  // ... \n```", "```js\ncurl -G http://localhost:8000/subsetSum --data-urlencode \"data=[16, 19,1,1,-16,9,1,-5,-2,17,-15,-97,19,-16,-4,-5,15]\" --data-urlencode \"sum=0\" \n```", "```js\ncurl -G http://localhost:8000 \n```", "```js\nimport { fork } from 'child_process'\nexport class ProcessPool {\n  constructor (file, poolMax) {\n    this.file = file\n    this.poolMax = poolMax\n    this.pool = []\n    this.active = []\n    this.waiting = []\n  }\n//... \n```", "```js\nacquire () {\n  return new Promise((resolve, reject) => {\n    let worker\n    if (this.pool.length > 0) {                            // (1)\n      worker = this.pool.pop()\n      this.active.push(worker)\n      return resolve(worker)\n    }\n    if (this.active.length >= this.poolMax) {              // (2)\n      return this.waiting.push({ resolve, reject })\n    }\n    worker = fork(this.file)                               // (3)\n    worker.once('message', message => {\n      if (message === 'ready') {\n        this.active.push(worker)\n        return resolve(worker)\n      }\n      worker.kill()\n      reject(new Error('Improper process start'))\n    })\n    worker.once('exit', code => {\n      console.log(`Worker exited with code ${code}`)\n      this.active = this.active.filter(w => worker !== w)\n      this.pool = this.pool.filter(w => worker !== w)\n    })\n  })\n} \n```", "```js\nrelease (worker) {\n  if (this.waiting.length > 0) {                           // (1)\n    const { resolve } = this.waiting.shift()\n    return resolve(worker)\n  }\n  this.active = this.active.filter(w => worker !== w)      // (2)\n  this.pool.push(worker)\n} \n```", "```js\nimport { EventEmitter } from 'events'\nimport { dirname, join } from 'path'\nimport { fileURLToPath } from 'url'\nimport { ProcessPool } from './processPool.js'\nconst __dirname = dirname(fileURLToPath(import.meta.url))\nconst workerFile = join(__dirname,\n  'workers', 'subsetSumProcessWorker.js')\nconst workers = new ProcessPool(workerFile, 2)\nexport class SubsetSum extends EventEmitter {\n  constructor (sum, set) {\n    super()\n    this.sum = sum\n    this.set = set\n  }\n  async start () {\n    const worker = await workers.acquire()                 // (1)\n    worker.send({ sum: this.sum, set: this.set })\n    const onMessage = msg => {\n      if (msg.event === 'end') {                           // (3)\n        worker.removeListener('message', onMessage)\n        workers.release(worker)\n      }\n      this.emit(msg.event, msg.data)                       // (4)\n    }\n    worker.on('message', onMessage)                        // (2)\n  }\n} \n```", "```js\nimport { SubsetSum } from '../subsetSum.js'\nprocess.on('message', msg => {                             // (1)\n  const subsetSum = new SubsetSum(msg.sum, msg.set)\n  subsetSum.on('match', data => {                          // (2)\n    process.send({ event: 'match', data: data })\n  })\n  subsetSum.on('end', data => {\n    process.send({ event: 'end', data: data })\n  })\n  subsetSum.start()\n})\nprocess.send('ready') \n```", "```js\nimport { createServer } from 'http'\n// import { SubsetSum } from './subsetSum.js'\n// import { SubsetSum } from './subsetSumDefer.js'\n**import** **{ SubsetSum }** **from****'./subsetSumFork.js'**\ncreateServer((req, res) => {\n//... \n```", "```js\ncurl -G http://localhost:8000/subsetSum --data-urlencode \"data=[16, 19,1,1,-16,9,1,-5,-2,17,-15,-97,19,-16,-4,-5,15]\" --data-urlencode \"sum=0\" \n```", "```js\ncurl -G http://localhost:8000 \n```", "```js\nimport { Worker } from 'worker_threads'\nexport class ThreadPool {\n  // ...\n  acquire () {\n    return new Promise((resolve, reject) => {\n      let worker\n      if (this.pool.length > 0) {\n        worker = this.pool.pop()\n        this.active.push(worker)\n        return resolve(worker)\n      }\n      if (this.active.length >= this.poolMax) {\n        return this.waiting.push({ resolve, reject })\n      }\n      **worker =** **new** **Worker(****this****.file)**\n      **worker.once(****'online'****,** **()** **=>** **{**\n        **this****.active.push(worker)**\n        **resolve(worker)**\n      **})**\n      worker.once('exit', code => {\n        console.log(`Worker exited with code ${code}`)\n        this.active = this.active.filter(w => worker !== w)\n        this.pool = this.pool.filter(w => worker !== w)\n      })\n    })\n  }\n  //...\n} \n```", "```js\nimport { parentPort } from 'worker_threads'\nimport { SubsetSum } from '../subsetSum.js'\nparentPort.on('message', msg => {\n  const subsetSum = new SubsetSum(msg.sum, msg.set)\n  subsetSum.on('match', data => {\n    parentPort.postMessage({ event: 'match', data: data })\n  })\n  subsetSum.on('end', data => {\n    parentPort.postMessage({ event: 'end', data: data })\n  })\n  subsetSum.start()\n}) \n```", "```js\nimport { EventEmitter } from 'events'\nimport { dirname, join } from 'path'\nimport { fileURLToPath } from 'url'\n**import** **{ ThreadPool }** **from****'./threadPool.js'**\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n**const** **workerFile = join(__dirname,**\n  **'workers'****,** **'subsetSumThreadWorker.js'****)**\n**const** **workers =** **new** **ThreadPool(workerFile,** **2****)**\nexport class SubsetSum extends EventEmitter {\n  constructor (sum, set) {\n    super()\n    this.sum = sum\n    this.set = set\n  }\n  async start () {\n    const worker = await workers.acquire()\n    **worker.postMessage({** **sum****:** **this****.sum,** **set****:** **this****.set })**\n    const onMessage = msg => {\n      if (msg.event === 'end') {\n        worker.removeListener('message', onMessage)\n        workers.release(worker)\n      }\n      this.emit(msg.event, msg.data)\n    }\n    worker.on('message', onMessage)\n  }\n} \n```", "```js\nimport { createServer } from 'http'\n// import { SubsetSum } from './subsetSum.js'\n// import { SubsetSum } from './subsetSumDefer.js'\n// import { SubsetSum } from './subsetSumFork.js'\n**import** **{ SubsetSum }** **from****'./subsetSumThreads.js'**\ncreateServer((req, res) => {\n  // ... \n```"]