- en: Chapter 7. Threads, Queues, and Message Passing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 线程、队列和消息传递
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Queuing multiple downloads
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列多个下载
- en: Launching one app from another
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个应用启动另一个应用
- en: Cross-platform URL schemes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台URL方案
- en: Opening your Android app on BOOT_COMPLETED
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在BOOT_COMPLETED时打开您的Android应用
- en: iOS multithreading using Web Workers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web Workers进行iOS多线程
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Size, complexity, and volume are common issues encountered in developing and
    maintaining enterprise apps. Titanium provides support for several common patterns
    used to separate operational responsibility patterns.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大小、复杂性和体积是开发和维护企业应用时常见的问题。Titanium提供了对几种常见模式的支持，用于分离操作责任模式。
- en: This chapter discusses how to use message passing, queuing, and multithreaded
    capabilities in Titanium. These step-by-step recipes can then be used to incorporate
    these design principles into your existing Titanium enterprise application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了如何在Titanium中使用消息传递、队列和多线程功能。然后可以使用这些分步菜谱将这些设计原则融入现有的Titanium企业应用中。
- en: Queuing multiple downloads
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列多个下载
- en: It is commonplace for enterprise apps to require the need to download documents
    and content from your organization's file servers. Use of queuing is helpful in
    this scenario to ensure order and delivery while avoiding pitfalls often associated
    with spawning multiple asynchronous requests. This recipe uses the `Ti.Queue`
    CommonJS module to create a persistent, named queue to perform file downloads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业应用来说，需要从组织的文件服务器下载文档和内容是很常见的。在这种情况下使用队列有助于确保顺序和交付，同时避免与生成多个异步请求相关的常见陷阱。此菜谱使用`Ti.Queue`
    CommonJS模块来创建一个持久、命名的队列以执行文件下载。
- en: To demonstrate how to implement a persistent queue, this recipe will download
    to your device 5 MB sample files from Github. The following screenshots illustrate
    what this recipe looks like while running on both the iPhone and Android devices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何实现持久队列，此菜谱将从Github下载5 MB的样本文件到您的设备。以下截图显示了此菜谱在iPhone和Android设备上运行时的样子。
- en: '![Queuing multiple downloads](img/5343_07_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![队列多个下载](img/5343_07_01.jpg)'
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'This recipe uses the `Ti.Queue` CommonJS module. This module and other code
    assets can be downloaded from the source provided by the book, or individually
    through the links provided in the *See also* section at the end of this recipe.
    Installing these in your project is straightforward. Simply copy the `Ti.Queue.js`
    file into your project as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱使用`Ti.Queue` CommonJS模块。此模块和其他代码资源可以从本书提供的源代码下载，或者通过此菜谱末尾的“另请参阅”部分提供的链接单独下载。将这些安装到您的项目中很简单。只需将`Ti.Queue.js`文件复制到您的项目中，如下面的截图所示：
- en: '![Getting ready](img/5343_07_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/5343_07_02.jpg)'
- en: Network connection
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络连接
- en: This recipe requires a network connection to download files from Github. Please
    make sure the device or simulator has proper network connectivity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱需要网络连接以从Github下载文件。请确保设备或模拟器有适当的网络连接性。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once you have added the `Ti.Queue` module to your project, you need to create
    your application namespace in the `app.js` file and use `require` to import the
    module into your code as the following code snippet demonstrates:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`Ti.Queue`模块添加到您的项目中，您需要在`app.js`文件中创建您的应用程序命名空间，并使用`require`将模块导入到您的代码中，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating the recipe's UI
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建菜谱的UI
- en: 'The following steps outline how to create the UI used in this recipe:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何创建此菜谱中使用的UI：
- en: First, a `Ti.UI.Window` is created to attach all UI elements.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`Ti.UI.Window`以附加所有UI元素。
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, a `Ti.UI.ProgressBar` is added to the `Ti.UI.Window`. This will be used
    to display the status of the queue.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向`Ti.UI.Window`添加一个`Ti.UI.ProgressBar`。这将用于显示队列的状态。
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `show` method is called immediately on our `Ti.UI.ProgressBar` so that it
    will be displayed on the `Ti.UI.Window` correctly.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立即调用我们的`Ti.UI.ProgressBar`的`show`方法，以确保它正确地显示在`Ti.UI.Window`上。
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, a `Ti.UI.Button` is added to the `Ti.UI.Window`. This control will be
    used to trigger the queue download logic.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向`Ti.UI.Window`添加一个`Ti.UI.Button`。此控件将用于触发队列下载逻辑。
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a queue
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建队列
- en: The next step in the recipe is to create a named queue as demonstrated in the
    following code snippet. By default, any named queue is persistent and will store
    all jobs between sessions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱的下一步是创建一个命名队列，如下面的代码片段所示。默认情况下，任何命名队列都是持久的，将在会话之间存储所有作业。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a name is not provided when creating a new queue, the queue will not save
    jobs between app restarts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建新队列时没有提供名称，则队列不会在应用程序重启之间保存任务。
- en: Adding jobs to the queue
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将任务添加到队列
- en: After the queue has been created, the next step is to create a series of jobs
    for the queue to manage. The following code block creates three download jobs
    for the queue to manage.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建队列之后，下一步是为队列创建一系列任务以进行管理。以下代码块为队列创建了三个下载任务。
- en: The first job is created to download a ZIP file from Github. A timestamp is
    used to provide a unique name.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建的第一个任务是下载来自 Github 的 ZIP 文件。使用时间戳提供唯一的名称。
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, a second job is created to download a ZIP file from Github. A timestamp
    is used to provide a unique name.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，创建第二个任务以从 Github 下载 ZIP 文件。使用时间戳提供唯一的名称。
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, a third job is created to download a ZIP file from Github. A timestamp
    is used to provide a unique name.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，创建第三个任务以从 Github 下载 ZIP 文件。使用时间戳提供唯一的名称。
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Recipe's assistant functions
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜谱的辅助函数
- en: 'The `assist` object is used to manage the download process. The following is
    a discussion on how the `assist` object works and can be leveraged within your
    app:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`assist` 对象用于管理下载过程。以下是对 `assist` 对象如何工作以及如何在您的应用程序中利用它的讨论：'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `progressSetup` method is used to restart the progress bar when a new download
    system has been initialized.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`progressSetup` 方法用于在初始化新的下载系统时重启进度条。'
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `updateProcess` method is used to update the progress bar information and
    alert the user to the status of the overall download job.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`updateProcess` 方法用于更新进度条信息并提醒用户整体下载任务的状态。'
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `whenFinished` method is called after all `Ti.Queue` jobs have finished
    or generated errors. This method is used to update UI to alert the user about
    the queued job which has been processed.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 `Ti.Queue` 任务完成或生成错误后，调用 `whenFinished` 方法。此方法用于更新 UI 以提醒用户已处理队列中的任务。
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `next` method is used to process the next job in the `Ti.Queue`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`next` 方法用于处理 `Ti.Queue` 中的下一个任务。'
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This step in the `next` method is to check if there are any jobs available.
    This is done by calling the `getLength` method on the queue to retrieve the number
    of jobs currently stored in the queue.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `next` 方法中的此步骤是检查是否有任何任务可用。这是通过在队列上调用 `getLength` 方法来完成的，以检索队列中当前存储的任务数量。
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If there are no jobs remaining in the queue, the `whenFinish` method is called
    and the download process is exited.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果队列中没有剩余的任务，则调用 `whenFinish` 方法并退出下载过程。
- en: '[PRE15]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If a job is available in the queue, the next step is to update the `progressValue`
    to show the current processing status as shown in the following code snippet.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果队列中有可用的任务，下一步是更新 `progressValue` 以显示当前处理状态，如下面的代码片段所示。
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The next step is to call the `peek` method on the queue. This allows us to fetch
    the next item in the queue without popping it from the queue itself. This is used
    to write the information to the Titanium Studio console for debugging purposes.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是调用队列上的 `peek` 方法。这允许我们获取队列中的下一个项目，而不将其从队列本身中弹出。这用于将信息写入 Titanium Studio
    控制台进行调试。
- en: '[PRE17]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The next step is to call the `dequeue` method on the queue. This function pops
    the next item from the queue and returns the item. In the following code snippet,
    the `dequeue` method is called to provide the next queue job to the `item` variable.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是调用队列上的 `dequeue` 方法。此函数从队列中弹出下一个项目并返回该项目。在下面的代码片段中，调用 `dequeue` 方法将下一个队列任务提供给
    `item` 变量。
- en: '[PRE18]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `updateProgress` method is then called to alert the user to the download
    progress.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用 `updateProgress` 方法以提醒用户下载进度。
- en: '[PRE19]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next the `download` method is called to start the download process. To create
    a recursive function, the `next` method is provided as a callback argument to
    the `download` method.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来调用 `download` 方法以启动下载过程。为了创建递归函数，将 `next` 方法作为回调参数传递给 `download` 方法。
- en: '[PRE20]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `download` method contains all logic needed to download the queued job from
    Github.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`download` 方法包含从 Github 下载队列中任务所需的所有逻辑。'
- en: '[PRE21]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first step in downloading the file from Github is to create `Ti.Network.HTTPClient`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Github 下载文件的第一步是创建 `Ti.Network.HTTPClient`。
- en: '[PRE22]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `onload` callback is fired when the `Ti.Network.HTTPClient` receives a successful
    response.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `Ti.Network.HTTPClient` 收到成功响应时，触发 `onload` 回调。
- en: '[PRE23]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the response does not provide a `200` status code, an error is generated.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应没有提供 `200` 状态码，则生成错误。
- en: '[PRE24]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If the proper status code is returned, a `Ti.Filesytem` object is then created
    and the `responseData` is saved to the provided output path.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果返回了适当的状态代码，则创建一个`Ti.Filesytem`对象，并将`responseData`保存到提供的输出路径。
- en: '[PRE25]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After the `responseData` has been persisted to the filesystem, the callback
    method is triggered. This allows for the recipe to recursively loop through the
    queue.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`responseData`被持久化到文件系统后，回调方法被触发。这允许配方递归地遍历队列。
- en: '[PRE26]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `onerror` callback is triggered when the `Ti.Network.HTTPClient` receives
    an error.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Ti.Network.HTTPClient`收到错误时，触发`onerror`回调。
- en: '[PRE27]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When an error is received, the provided job is requeued for another attempt,
    by calling the `requeue` method on the `assist` object.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当收到错误时，通过在`assist`对象上调用`requeue`方法，将提供的作业重新排队以进行另一次尝试。
- en: '[PRE28]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The download progress is started by calling the `open` and `send` methods on
    the `Ti.Network.HTTPClient` using the queue item''s `url` details as demonstrated
    in the following code snippet:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`Ti.Network.HTTPClient`上调用`open`和`send`方法，并使用队列项目的`url`详细信息，开始下载进度，如下代码片段所示：
- en: '[PRE29]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `requeue` method is used to add an item back into the queue. The recipe
    is designed to provide three attempts at downloading before the job is considered
    a permanent error.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`requeue`方法将项目重新添加到队列中。该配方旨在在将工作视为永久性错误之前提供三次下载尝试。
- en: '[PRE30]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The item's `attempt` property is checked to determine if the job has been attempted
    more than three times.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该项目的`attempt`属性被检查以确定工作是否尝试了超过三次。
- en: '[PRE31]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the job has been attempted more than three times, the item is not readded
    to the queue.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果工作尝试次数超过三次，则项目不会被重新添加到队列中。
- en: '[PRE32]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the job has errored, less than three times, the `attempts` property is incremented
    and the item is added to the queue again.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果工作出错次数少于三次，则增加`attempts`属性，并将项目再次添加到队列中。
- en: '[PRE33]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally the `callback` method is fired, moving the download process to the next
    step in its lifecycle.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，触发`callback`方法，将下载过程移动到其生命周期的下一个步骤。
- en: '[PRE34]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Start downloading
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始下载
- en: When the `downloadButton` is pressed the recipe begins to process the queued
    jobs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下`downloadButton`时，配方开始处理队列中的工作。
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first step in the download process is to check if the recipe has a network
    connection. If the network is not available, the recipe will alert the user to
    exit the process.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载过程的第一步是检查配方是否有网络连接。如果网络不可用，配方将提醒用户退出进程。
- en: '[PRE36]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The next step in the download process is to disable the `downloadButton`. This
    avoids the user from processing the button again, once the job has started.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载过程的下一步是禁用`downloadButton`。这避免了用户在作业开始后再次处理按钮。
- en: '[PRE37]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `my.jobInfo` object is then updated with the current count and status information.
    This will be used to track the overall download status.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`my.jobInfo`对象被更新为当前的计数和状态信息。这将用于跟踪整体下载状态。
- en: '[PRE38]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next the `processSetup` method is called to initialize the `Ti.UI.ProgressBar`
    with the correct `min` and `max` values.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来调用`processSetup`方法，使用正确的`min`和`max`值初始化`Ti.UI.ProgressBar`。
- en: '[PRE39]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, the `next` method is called on the `assist` object. This begins the
    download process and creates a recursive loop that will run until the queue is
    empty.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`assist`对象上调用`next`方法。这开始下载过程并创建一个递归循环，直到队列空为止。
- en: '[PRE40]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about the `Ti.Queue` module used in this recipe, please visit
    [https://github.com/benbahrenburg/Ti.Queue](https://github.com/benbahrenburg/Ti.Queue).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于在此配方中使用的`Ti.Queue`模块的信息，请访问[https://github.com/benbahrenburg/Ti.Queue](https://github.com/benbahrenburg/Ti.Queue)。
- en: Launching one app from another
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个应用启动另一个应用
- en: A majority of mobile enterprise apps are designed around a specific task such
    as time reporting. Through the use of URL schemes or Android intent filters you
    can open and communicate between different apps on the user's device. For example,
    you can provide an option for your organization's time-reporting app to open the
    expense app when an employee is traveling and needs to record additional information.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数移动企业应用都是围绕特定任务设计的，例如时间报告。通过使用URL方案或Android意图过滤器，您可以在用户的设备上打开并通信不同的应用。例如，您可以为组织的时间报告应用提供一个选项，当员工出差并需要记录额外信息时，打开费用应用。
- en: 'This recipe demonstrates how to launch different apps using the native platform''s
    integration pattern. The following screenshot illustrates this recipe running
    on both an iOS and Android device:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方演示了如何使用原生平台的集成模式启动不同的应用。以下屏幕截图显示了该配方在iOS和Android设备上运行的情况：
- en: .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: '![Launching one app from another](img/5343_07_03.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![从一个应用启动另一个应用](img/5343_07_03.jpg)'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe must be run on a device to fully experience all features. A device
    is required as the simulator or emulator do not allow apps from the different
    app stores to be run.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱必须在设备上运行，才能完全体验所有功能。需要设备，因为模拟器或仿真器不允许运行来自不同应用商店的应用。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe uses the `schemeList` CommonJS module. This module and other code
    assets can be downloaded from the source provided by the book. Installing these
    in your project is straightforward. Simply copy the `schemeList.js` file into
    your project as shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱使用`schemeList` CommonJS模块。此模块和其他代码资源可以从本书提供的源代码中下载。在项目中安装这些资源很简单。只需将`schemeList.js`文件复制到您的项目中，如下面的截图所示：
- en: '![Getting ready](img/5343_07_04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/5343_07_04.jpg)'
- en: Network connection
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络连接
- en: 'This recipe requires that the following apps are installed on your device:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱要求在您的设备上安装以下应用：
- en: LinkedIn
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LinkedIn
- en: Evernote
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Evernote
- en: Google Maps (on iOS and Android)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Maps（在iOS和Android上）
- en: The URL Scheme example recipe discussed later in this chapter
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章后面将讨论的URL Scheme示例
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'After adding the `schemaList` module, you will need to create your application
    namespace in the `app.js` file and use `require` to import the module into your
    code as the following code snippet demonstrates:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`schemaList`模块后，您需要在`app.js`文件中创建您的应用程序命名空间，并使用`require`将模块导入到您的代码中，如下面的代码片段所示：
- en: '[PRE41]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: iOS updating tiapp.xml
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iOS更新tiapp.xml
- en: Adding the ability to allow other iOS apps to launch your apps is straightforward.
    The following code snippet demonstrates how to add a custom scheme named, `bencoding-linkLauncher`
    to this recipe. This allows any iOS app to launch this sample in a similar fashion
    as discussed later in this recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 添加允许其他iOS应用启动您的应用的功能很简单。以下代码片段演示了如何将名为`bencoding-linkLauncher`的自定义方案添加到此菜谱中。这允许任何iOS应用以类似的方式启动此示例，正如本菜谱后面所讨论的。
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `CFBundleURLlTypes` node is an array of dictionaries describing the URL
    schemes supported by the bundle. Under this node, you will list all of the URL
    and scheme names your app will respond to.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFBundleURLlTypes`节点是一个字典数组，描述了该包支持的URL方案。在此节点下，您将列出您的应用将响应的所有URL和方案名称。'
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `CFBundleURLName` is the key that contains the abstract name for this URL
    type. This is the main way to refer to a particular type. To ensure uniqueness,
    it is recommended that you use a Java-package style identifier.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFBundleURLName`是包含此URL类型抽象名称的键。这是引用特定类型的主要方式。为确保唯一性，建议您使用Java包风格的标识符。'
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `CFBundleURLSchemes` is the key that contains an array of strings, each
    of which identifies a URL scheme handled by this type.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFBundleURLSchemes`是包含字符串数组的键，每个字符串都标识由该类型处理的URL方案。'
- en: '[PRE45]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Creating an app launch list
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建应用启动列表
- en: The `schemeList` CommonJS module, added to the `my.scheme` property provides
    a list of iOS and Android scheme examples. The following sections describe how
    schemes are created on both platforms.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`schemeList` CommonJS模块，添加到`my.scheme`属性中，提供了iOS和Android方案示例列表。以下几节将描述如何在两个平台上创建方案。'
- en: iOS scheme list
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iOS方案列表
- en: On iOS, a URL scheme works just like a URL on the web. The only difference is
    the app's registered URL scheme is used as the protocol. The following steps provide
    detailed examples of the specific URL formats available.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，URL方案就像网页上的URL一样工作。唯一的区别是应用注册的URL方案用作协议。以下步骤提供了具体URL格式的详细示例。
- en: The `getiOSList` provides an array of objects designed to be bound to a `Ti.UI.TableView`
    and later used to launch other apps.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getiOSList`提供了一个对象数组，设计用于绑定到`Ti.UI.TableView`，并随后用于启动其他应用。'
- en: '[PRE46]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The most basic type of URL scheme is simply the `CFBundleURLName` of the app.
    This is shown in the following examples for Evernote and LinkedIn.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最基本的URL方案类型仅仅是应用的`CFBundleURLName`。以下示例展示了Evernote和LinkedIn的此属性。
- en: '[PRE47]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: More complex URL schemes can be used, such as the following example showing
    a URL scheme including the `about` route.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更复杂的URL方案可以使用，如下面的示例所示，它包括`about`路由的URL方案。
- en: '[PRE48]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'URL schemes can also include query parameters similar to a web page, as demonstrated
    in the following code snippet:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL方案也可以包含类似于网页的查询参数，如下面的代码片段所示：
- en: '[PRE49]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Android scheme list
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Android方案列表
- en: Android has the ability to launch applications in a variety of ways. This recipe
    focuses on how to use a URL scheme similar to iOS and intents for app integration.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Android 有能力以多种方式启动应用。本食谱侧重于如何使用类似于 iOS 的 URL 方案和意图来实现应用集成。
- en: The `getAndroidList` provides an array of objects designed to be bound to a
    `Ti.UI.TableView` and later used to launch other apps.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAndroidList` 提供了一个对象数组，这些对象旨在绑定到 `Ti.UI.TableView` 并用于稍后启动其他应用。'
- en: '[PRE50]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Similar to iOS apps, you can use a route base URL to launch a third-party app.
    The following code snippet shows how to construct a URL with an `about` route.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 iOS 应用类似，您可以使用基于路由的 URL 来启动第三方应用。以下代码片段展示了如何构建一个带有 `about` 路由的 URL。
- en: '[PRE51]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Just as with web pages, you can build more complex URLs with query string parameters.
    The following snippet demonstrates how to call a login screen while passing query
    string information.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像网页一样，您可以使用查询字符串参数构建更复杂的 URL。以下代码片段演示了如何在传递查询字符串信息的同时调用登录界面。
- en: '[PRE52]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A more preferred way to launch apps on Android is to use intents. The following
    example shows how to create an intent to launch the LinkedIn app.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android 上启动应用的一个更受欢迎的方式是使用意图。以下示例展示了如何创建一个意图以启动 LinkedIn 应用。
- en: '[PRE53]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Once the LinkedIn intent has been created, it is added to the app's array with
    a type of intent. This will later be used to launch the LinkedIn app.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了 LinkedIn 意图，它将以意图类型添加到应用的数组中。这将被用于稍后启动 LinkedIn 应用。
- en: '[PRE54]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The LinkedIn app must be installed on the user's device in order to have the
    intent launch the app. If the app is not installed, an exception will be generated.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让意图启动应用，LinkedIn 应用必须在用户的设备上安装。如果应用未安装，将会生成一个异常。
- en: A more preferred way to launch apps on Android is to use intents. The following
    example shows how to create an intent to launch the Evernote app.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android 上启动应用的一个更受欢迎的方式是使用意图。以下示例展示了如何创建一个意图以启动 Evernote 应用。
- en: '[PRE55]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Evernote app must be installed on the user's device in order to have the
    intent launch the app. If the app is not installed, an exception will be generated.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让意图启动应用，Evernote 应用必须在用户的设备上安装。如果应用未安装，将会生成一个异常。
- en: Once the Evernote intent has been created, it is added to the app's array with
    a type of intent. This will later be used to launch the Evernote app.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了 Evernote 意图，它将以意图类型添加到应用的数组中。这将被用于稍后启动 Evernote 应用。
- en: '[PRE56]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The recipe's UI
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 食谱的 UI
- en: This section of the recipe is the UI used to launch the third-party apps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的这一部分是用于启动第三方应用的 UI。
- en: First, a `Ti.UI.Window` is created to attach all UI elements.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 `Ti.UI.Window` 来附加所有 UI 元素。
- en: '[PRE57]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Next the `schemeList` CommonJS module is called to return a list of the applications
    to launch.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来调用 `schemeList` CommonJS 模块以返回要启动的应用列表。
- en: '[PRE58]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `schemaData` object is then formatted and bound to a `Ti.UI.TableView` for
    display.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `schemaData` 对象格式化并绑定到 `Ti.UI.TableView` 以进行显示。
- en: '[PRE59]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The final section of this recipe demonstrates how to launch third-party apps
    using the list displayed in the `Ti.UI.TableView`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的最后一部分演示了如何使用在 `Ti.UI.TableView` 中显示的列表来启动第三方应用。
- en: A `click` event is added to the `Ti.UI.TableView`. This event will be fired
    when the user taps on a row in the `Ti.UI.TableView`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Ti.UI.TableView` 上添加了一个 `click` 事件。当用户在 `Ti.UI.TableView` 中的某一行上点击时，此事件将被触发。
- en: '[PRE60]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Once the event is fired, the first step is to check the platform on which the
    recipe is running.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件触发后，第一步是检查食谱正在运行的平台。
- en: '[PRE61]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If running under Android, a check must be performed to determine if the launch
    type is an intent or URL.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在 Android 下运行，必须执行检查以确定启动类型是意图还是 URL。
- en: '[PRE62]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If the launch type is an intent, `Ti.Android.currentActivity.startActivity`
    is called using the provided intent as shown in the following snippet. This will
    launch the third-party app if it is installed on the user's device.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果启动类型是意图，则使用提供的意图调用 `Ti.Android.currentActivity.startActivity`，如下面的代码片段所示。如果第三方应用已安装在用户的设备上，这将启动该应用。
- en: '[PRE63]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the launch type is a URL, the `Ti.Platform.openURL` method is used to open
    the app using the provided `url` property as shown in the following snippet. This
    will launch the third-party app if it is installed on the user's device.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果启动类型是 URL，则使用 `Ti.Platform.openURL` 方法通过提供的 `url` 属性打开应用，如下面的代码片段所示。如果第三方应用已安装在用户的设备上，这将启动该应用。
- en: '[PRE64]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the app is not installed, an exception will be generated.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果应用未安装，将会生成一个异常。
- en: 'The iOS platform launches third-party apps using a URL scheme similar to how
    web pages are loaded using the `Ti.Platform.openURL` method. The following snippet
    demonstrates how to launch a third-party app using the `url` property provided
    by the `schemeList` CommonJS module:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: iOS平台通过类似于使用`Ti.Platform.openURL`方法加载网页的方式，使用URL方案启动第三方应用。以下代码片段展示了如何使用`schemeList`
    CommonJS模块提供的`url`属性启动第三方应用：
- en: '[PRE65]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: See also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about using Android intents in Titanium, visit *Forging Titanium
    Episode 9* at [http://developer.appcelerator.com/blog/2011/10/forging-titanium-episode-9-android-intent-cookbook.html](http://developer.appcelerator.com/blog/2011/10/forging-titanium-episode-9-android-intent-cookbook.html).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于在Titanium中使用Android意图的信息，请访问[Forging Titanium 第9集](http://developer.appcelerator.com/blog/2011/10/forging-titanium-episode-9-android-intent-cookbook.html)。
- en: Cross-platform URL schemes
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台URL方案
- en: URL schemes on iOS and intent filters on Android provide an open integration
    point for you to expose functionality in your apps to others. This is particularly
    helpful if you are building a suite of enterprise apps such as a separate mileage
    and expense app and want to allow for integration points between them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: iOS上的URL方案和Android上的意图过滤器为你提供了一个开放集成点，让你可以将你的应用功能暴露给他人。如果你正在构建一套企业应用，如单独的里程和费用应用，并希望允许它们之间有集成点，这将特别有帮助。
- en: This recipe demonstrates how to create a cross-platform URL scheme within your
    Titanium Enterprise app. We will illustrate how to use this open integration point
    to access functionality within your Titanium app.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方演示了如何在Titanium企业应用中创建跨平台URL方案。我们将展示如何使用这个开放集成点来访问Titanium应用中的功能。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'This recipe uses the `demoUI` and `Ti.SchemeTools` CommonJS libraries to help
    manage and demonstrate how to create cross-platform URL schemes. This module and
    other code assets can be downloaded from the source provided by the book. To install
    these modules, simply copy them to the `Resources` folder of your Titanium project
    as demonstrated in the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用`demoUI`和`Ti.SchemeTools` CommonJS库来帮助管理和演示如何创建跨平台URL方案。此模块和其他代码资源可以从书中提供的源代码下载。要安装这些模块，只需将它们复制到Titanium项目的`Resources`文件夹中，如下截图所示：
- en: '![Getting ready](img/5343_07_05.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/5343_07_05.jpg)'
- en: AppLauncher requirement
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AppLauncher要求
- en: Another requirement of this recipe is the AppLauncher app, which was created
    in the *Launching one app from another* recipe discussed earlier in this chapter.
    This app will be used to launch the different URL examples contained within this
    recipe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的另一个要求是AppLauncher应用，该应用是在本章前面讨论的*从一个应用启动另一个应用*配方中创建的。此应用将用于启动此配方中包含的不同URL示例。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'After adding the `demoUI` and `Ti.SchemeTools` modules, you will need to create
    your application namespaces and use `require` to import the module into your `app.js`
    as the following code snippet demonstrates:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了`demoUI`和`Ti.SchemeTools`模块之后，你需要创建你的应用程序命名空间，并使用`require`将模块导入到你的`app.js`中，如下代码片段所示：
- en: '[PRE66]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: iOS updating tiapp.xml
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iOS更新tiapp.xml
- en: 'To add the ability for other apps to launch this recipe, you must make a few
    updates to the `tiapp.xml` file. The following steps discuss how to create the
    `bencoding-linkrecipe` custom URL scheme:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其他应用能够启动此配方，你必须对`tiapp.xml`文件进行一些更新。以下步骤讨论了如何创建`bencoding-linkrecipe`自定义URL方案：
- en: 'First, open your project''s `tiapp.xml` file and make the following changes
    to the `ios` node:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开你的项目`tiapp.xml`文件，并对`ios`节点进行以下修改：
- en: '[PRE67]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Next, add the `CFBundleURLTypes` node. This is an array of dictionaries describing
    the URL schemes supported by the bundle. Under this node, you will list all of
    the URL and scheme names your app will respond to.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`CFBundleURLTypes`节点。这是一个描述应用程序支持的URL方案的字典数组。在此节点下，你将列出你的应用将响应的所有URL和方案名称。
- en: '[PRE68]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Then add the `CFBundleURLName` key. This key contains the abstract name for
    this URL type. This is the main way to refer to a particular app. To ensure uniqueness,
    it is recommended that you use a Java-package style identifier.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加`CFBundleURLName`键。此键包含此URL类型的抽象名称。这是引用特定应用的主要方式。为确保唯一性，建议使用Java包风格的标识符。
- en: '[PRE69]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, add the `CFBundleURLSchemes` keys. These keys contain an array of
    strings, each of which identifies a URL scheme handled by this type. The following
    snippet shows URLs for the login, about, and root activities of the app:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加`CFBundleURLSchemes`键。这些键包含一个字符串数组，每个字符串都标识由该类型处理的URL方案。以下代码片段显示了应用的登录、关于和根活动的URL：
- en: '[PRE70]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Android updating tiapp.xml
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android更新tiapp.xml
- en: To create a custom URL scheme on Android, you will need to edit the `tiapp.xml`
    file to add an intent filter to listen for the specific `android:scheme` and `android:host`
    to be initialized.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android上创建自定义URL方案，您需要编辑`tiapp.xml`文件以添加一个intent过滤器来监听特定的`android:scheme`和`android:host`。
- en: First open the `tiapp.xml` file and edit the android configuration node.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`tiapp.xml`文件并编辑android配置节点。
- en: '[PRE71]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Next, add the `manifest` node.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`manifest`节点。
- en: '[PRE72]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Add the `application` node. This node will later be used to generate your project's
    `AndroidManifest.xml` file, so make sure the attributes correctly match your project.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`application`节点。此节点将用于生成项目的`AndroidManifest.xml`文件，因此请确保属性正确匹配您的项目。
- en: '[PRE73]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Next add the application's root activity.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来添加应用的根活动。
- en: '[PRE74]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Then add the app's main intent filter. This will be used to launch your app.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加应用的主要intent过滤器。这将用于启动您的应用。
- en: '[PRE75]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Next add a second intent filter with your custom URL information.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来添加一个带有自定义URL信息的第二个intent过滤器。
- en: '[PRE76]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Then add the data node with your `android:scheme` and `android:host` information.
    These values act as the protocol used when `Ti.Platform.openURL` is used to launch
    the URL scheme. The following highlighted code allows you to launch the app using
    a URL such as `bencoding-linkrecipe://com.bencoding`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加包含您的`android:scheme`和`android:host`信息的data节点。这些值在`Ti.Platform.openURL`用于启动URL方案时用作协议。以下高亮代码允许您使用类似`bencoding-linkrecipe://com.bencoding`的URL启动应用。
- en: '[PRE77]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Next a category must be added to the intent filter so that the app will be exposed
    correctly to third-party launchers and will open the app when the URL scheme is
    called. The following highlighted snippet shows the category information needed
    to correctly implement the custom URL scheme.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来必须向intent过滤器添加一个类别，以便应用能够正确地暴露给第三方启动器，并在URL方案被调用时打开应用。以下高亮代码片段显示了实现自定义URL方案所需的类别信息。
- en: '[PRE78]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Creating the recipe UI
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建菜谱UI
- en: This recipe has a simple UI designed to demonstrate how different URL scheme
    features can be implemented.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱有一个简单的UI，用于演示如何实现不同的URL方案功能。
- en: First, a `Ti.UI.Window` is created; this window is the root `Ti.UI.Window` of
    the app.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`Ti.UI.Window`；这是应用的根`Ti.UI.Window`。
- en: '[PRE79]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Next if the recipe is running on an iOS device, a `Ti.UI.Button` is added to
    allow the URL Receiver app to launch the App Launcher app created in the *Launching
    one app from another* recipe discussed earlier in this chapter.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果菜谱在iOS设备上运行，将添加一个`Ti.UI.Button`，允许URL接收器应用启动本章前面讨论的*从另一个应用启动*菜谱中创建的应用启动器应用。
- en: '[PRE80]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When the `launcherButton` is tapped, the app will try to open the App Launcher
    if the app is available on the device. The highlighted code demonstrates how to
    use the `Ti.Platform.openURL` method to launch the app.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击`launcherButton`时，如果设备上安装了应用启动器，应用将尝试打开应用启动器。以下高亮代码演示了如何使用`Ti.Platform.openURL`方法来启动应用。
- en: '[PRE81]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Launching helper functions
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动辅助函数
- en: This recipe uses the `assist object` to help launch a different URL.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用`assist object`来帮助启动不同的URL。
- en: '[PRE82]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `openWindow` method opens a specific window based on the URL and parameter
    values provided.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`openWindow`方法根据提供的URL和参数值打开一个特定的窗口。'
- en: '[PRE83]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `openPageFromUrl` method is called when an app is opened or resumed to determine
    if the app has been opened from a third-party app and if so, what routing information
    has been provided.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用打开或恢复时，会调用`openPageFromUrl`方法以确定应用是否是从第三方应用打开的，如果是，提供了哪些路由信息。
- en: '[PRE84]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The first step is to determine if the app has been opened from a third-party
    app. This is done by checking the `hasLaunchUrl` method.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是确定应用是否是从第三方应用打开的。这是通过检查`hasLaunchUrl`方法来完成的。
- en: '[PRE85]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If the app has not been launched from another app, the main page of the recipe
    will be displayed and any session variables will be reset.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用不是从另一个应用启动的，菜谱的主页将被显示，并且任何会话变量将被重置。
- en: '[PRE86]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If the app was launched by another app, we first need to check if the launching
    URL has changed. This avoids reloading the app if the same window has been requested.
    This can be done by calling the `hasChanged` method as highlighted in the following
    code snippet:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用是由另一个应用启动的，我们首先需要检查启动URL是否已更改。这可以避免在请求相同窗口时重新加载应用。这可以通过调用以下代码片段中突出显示的`hasChanged`方法来完成：
- en: '[PRE87]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Next the URL to be launched is obtained by calling the `getLaunchUrl` method
    as the following code snippet shows. This URL is then loaded into a `session`
    variable for later use.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过调用`getLaunchUrl`方法获取要启动的URL，如下面的代码片段所示。然后，此URL将被加载到`session`变量中供以后使用。
- en: '[PRE88]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Then the requested page is obtained using the `getCurrentPage` function. This
    will be used in determining which page to load using the `openWindow` method.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用`getCurrentPage`函数获取请求的页面。这将用于确定使用`openWindow`方法加载哪个页面。
- en: '[PRE89]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Next, any launch parameters are obtained. The following code block demonstrates
    how to check if launch parameters have been provided and parses them into a formatted
    object.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，获取任何启动参数。以下代码块演示了如何检查是否提供了启动参数，并将它们解析为格式化的对象。
- en: '[PRE90]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Finally, the `openWindow` method is called using the `requestedPage` and `launchParams`
    created in the preceding steps. The `openWindow` method will then open the requested
    window in the app.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用在前面步骤中创建的`requestedPage`和`launchParams`调用`openWindow`方法。`openWindow`方法将随后在应用中打开请求的窗口。
- en: '[PRE91]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: When launched from another app
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当从另一个应用启动时
- en: 'In order to have the recipe launch the requested window, listeners must be
    added to the resumed and open events. The following steps detail how to add the
    proper event listeners to your app:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让食谱启动请求的窗口，必须在恢复和打开事件中添加监听器。以下步骤详细说明了如何将适当的事件监听器添加到您的应用中：
- en: If the recipe is running on iOS, the resumed event listener is added. Please
    note this must be added to your `app.js` when implementing in your own app.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果食谱在iOS上运行，则添加恢复事件监听器。请注意，在实现您自己的应用时，必须将其添加到`app.js`中。
- en: '[PRE92]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `assist.openPageFromUrl` method will be called each time the app is resumed.
    If no URL information is provided, the main window will be displayed.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次应用恢复时，都会调用`assist.openPageFromUrl`方法。如果没有提供URL信息，则将显示主窗口。
- en: '[PRE93]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: A listener is added to the open event on the main window. This event will be
    fired when the app is first launched.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主窗口的打开事件上添加了一个监听器。此事件将在应用首次启动时触发。
- en: '[PRE94]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: On the first launch, the `assist.openPageFromUrl` method is called to determine
    if the app has been opened by a third-party app.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在首次启动时，会调用`assist.openPageFromUrl`方法以确定应用是否被第三方应用打开。
- en: '[PRE95]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: If the recipe is running on Android, a listener is added to the `resume` event
    on the main window. This allows the recipe to detect if a third-party app tries
    to open the recipe while the app is running in the background.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果食谱在Android上运行，则会在主窗口的`resume`事件上添加一个监听器。这允许食谱检测在应用在后台运行时是否有第三方应用尝试打开食谱。
- en: '[PRE96]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Cross-platform custom URL schemes are a great low-cost way to provide integration
    points with third parties. The following section details the end-to-end process
    for using the *Launching one app from another* recipe to access different app
    routes without this recipe's sample app.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台自定义URL方案是提供第三方集成点的低成本好方法。以下部分详细说明了使用“从一个应用启动另一个应用”食谱访问不同应用路由的端到端过程，而无需此食谱的示例应用。
- en: Launching the About window
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动关于窗口
- en: This section provides a step-by-step description on how you can launch the **About**
    window in the URL Receiver recipe when launched from the App Launcher recipe.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了逐步说明，说明您如何在从应用启动器食谱启动时，在URL接收器食谱中启动**关于**窗口。
- en: Open the App Launcher application and tap on the **Recipe Example 1** row in
    the table view as shown with the red boxes in the following screenshot.![Launching
    the About window](img/5343_07_06.jpg)
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用启动器应用程序，并在表格视图中轻触**食谱示例 1**行，如以下截图中的红色方框所示。![启动关于窗口](img/5343_07_06.jpg)
- en: The App Launcher app runs the following code block.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用启动器应用运行以下代码块。
- en: '**On iOS**:'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在iOS上**：'
- en: '[PRE97]'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '**On Android**:'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在Android上**：'
- en: '[PRE98]'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The URL Receiver recipe will then be launched on your device.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将在您的设备上启动URL接收器食谱。
- en: The resumed or open event handlers will then parse the provided URL information.
    When the `getCurrentPage` method is called, the `requestedPage` value will be
    set to a string with the value of `about`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后恢复或打开事件处理程序将解析提供的URL信息。当调用`getCurrentPage`方法时，`requestedPage`值将被设置为包含`about`值的字符串。
- en: '[PRE99]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Next, `my.scheme.hasParams` method is called to determine if any parameters
    have been passed as part of the provided URL. In this case, no additional parameters
    have been provided, so the `session` parameter object remains `null`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用`my.scheme.hasParams`方法以确定是否在提供的URL中传递了任何参数。在这种情况下，没有提供任何附加参数，因此`session`参数对象保持为`null`。
- en: The `openWindow` method is then called and the following **About** window is
    then opened:![Launching the About window](img/5343_07_07.jpg)
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用`openWindow`方法，并打开以下**关于**窗口：![启动关于窗口](img/5343_07_07.jpg)
- en: Launching the Login window
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动登录窗口
- en: This section provides a step-by-step description of launching the **Login**
    window in the URL Receiver recipe when launched from the App Launcher recipe.
    As part of the launch process, the user and token parameters are provided by the
    App Launcher recipe then used to complete the form within the URL Receiver recipe
    app.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了从应用启动器食谱启动URL接收器食谱中**登录**窗口的逐步描述。作为启动过程的一部分，用户和令牌参数由应用启动器食谱提供，然后在URL接收器食谱应用中用于完成表单。
- en: Open the App Launcher application and tap on the **Recipe Example 2** row in
    the table view as shown with the red boxes in the following screenshot:![Launching
    the Login window](img/5343_07_08.jpg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用启动器应用程序，并在表格视图中点击**食谱示例2**行，如下截图中的红色方框所示：![启动登录窗口](img/5343_07_08.jpg)
- en: The App Launcher application runs the following code block.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用启动器应用程序运行以下代码块。
- en: '**On iOS**:'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在iOS上**:'
- en: '[PRE100]'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '**On Android**:'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在Android上**:'
- en: '[PRE101]'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The URL Receiver recipe will then be launched on your device.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在您的设备上启动URL接收器食谱。
- en: The resumed or open event handlers will then parse the provided URL information.
    When the `getCurrentPage` method is called, the `requestedPage` value will be
    set to a string with the value of `login`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后恢复或打开事件处理程序将解析提供的URL信息。当调用`getCurrentPage`方法时，`requestedPage`值将被设置为包含`login`值的字符串。
- en: '[PRE102]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Next, `my.scheme.hasParams` method is called to determine if any parameters
    have been passed as part of the provide URL.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用`my.scheme.hasParams`方法以确定是否在提供的URL中传递了任何参数。
- en: The following parameter object is created using the query string parameters
    included with the calling URL.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的参数对象是使用调用URL中包含的查询字符串参数创建的。
- en: '[PRE103]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `openWindow` method is then called providing the `requestedPage` and `parameter`
    objects. This will then open the **Login** page with the parameter used to complete
    the form as shown in the following screenshot:![Launching the Login window](img/5343_07_09.jpg)
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用`openWindow`方法，提供`requestedPage`和`parameter`对象。这将打开**登录**页面，并使用用于完成表单的参数，如下截图所示：![启动登录窗口](img/5343_07_09.jpg)
- en: Opening your Android app with BOOT_COMPLETED
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BOOT_COMPLETED打开您的Android应用
- en: 'Many enterprise apps have the requirement of always running in the background.
    The most common categories of these apps would be for route management, item tracking,
    or customer scheduling apps. In your Android Titanium app, you can use an intent
    filter for the `BOOT_COMPLETED` action to notify your app that the device has
    been restarted. The event lifecycle for the `BOOT_COMPLETED` action is shown in
    the following diagram:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业应用都有始终在后台运行的要求。这些应用最常见的类别包括路线管理、物品跟踪或客户调度应用。在您的Android Titanium应用中，您可以使用`BOOT_COMPLETED`动作的intent过滤器来通知您的应用设备已重新启动。`BOOT_COMPLETED`动作的事件生命周期如下图中所示：
- en: '![Opening your Android app with BOOT_COMPLETED](img/5343_07_10.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![使用BOOT_COMPLETED打开您的Android应用](img/5343_07_10.jpg)'
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe uses the `bencoding.android.tools` native module to help with the
    subscription of the `BOOT_COMPLETED` broadcast. This module and other code assets
    can be downloaded from the source provided by the book, or individually through
    the links provided in the See also section at the end of this recipe. To install
    this module, simply copy the `modules` folder shown in the following screenshot
    into your project.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱使用`bencoding.android.tools`本地模块来帮助订阅`BOOT_COMPLETED`广播。此模块和其他代码资产可以从本书提供的源代码中下载，或者通过此食谱末尾的“也见”部分提供的链接单独下载。要安装此模块，只需将以下截图所示的`modules`文件夹复制到您的项目中。
- en: Also included with the sample recipe is a series of example `tiapp.xml` and
    `app.js` files demonstrating different options in handling the receipt of the
    `BOOT_COMPLETED` broadcast. You will need to copy the files highlighted in the
    following screenshot into your project as they will be used to demonstrate the
    different available options.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 示例配方还包括一系列示例`tiapp.xml`和`app.js`文件，展示了处理接收`BOOT_COMPLETED`广播的不同选项。您需要将以下截图突出显示的文件复制到您的项目中，因为它们将被用于演示不同的可用选项。
- en: '![Getting ready](img/5343_07_11.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/5343_07_11.jpg)'
- en: 'After copying the mentioned files, you will need to click on your **tiapp.xml**
    file in Titanium Studio and add a reference to the `bencoding.android.tools` module
    as shown in the following screenshot:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 复制提到的文件后，您需要在Titanium Studio中点击您的**tiapp.xml**文件，并添加对`bencoding.android.tools`模块的引用，如下截图所示：
- en: '![Getting ready](img/5343_07_12.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/5343_07_12.jpg)'
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe demonstrates how to implement the following scenarios:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方演示了如何实现以下场景：
- en: Auto restarting your app upon receiving the `BOOT_COMPLETED` broadcast
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接收到`BOOT_COMPLETED`广播时自动重启您的应用
- en: Sending a notification to the user receiving the `BOOT_COMPLETED` broadcast
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向接收`BOOT_COMPLETED`广播的用户发送通知
- en: Using Titanium properties to configure how your app handles the `BOOT_COMPLETED`
    broadcast
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Titanium属性配置您的应用如何处理`BOOT_COMPLETED`广播
- en: Required tiapp.xml updates
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必需的tiapp.xml更新
- en: 'When a Titanium Android app is launched, the Titanium framework first must
    be initialized before your app can run. When the app is launched by another service
    such as the `BOOT_COMPLETED` broadcast, you will receive a message that the app
    needs to restart. To avoid this issue, you must add the following properties into
    your `tiapp.xml` file:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当Titanium Android应用启动时，Titanium框架必须首先初始化，然后您的应用才能运行。当应用由其他服务（如`BOOT_COMPLETED`广播）启动时，您将收到一条消息，表明应用需要重启。为了避免此问题，您必须在您的`tiapp.xml`文件中添加以下属性：
- en: '[PRE104]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Scenario A – auto restart
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景 A – 自动重启
- en: The first `BOOT_COMPLETED` option provided by the `Android.Tools.Receiver` module
    is the ability to restart your app. The typical use case would be to restart your
    Titanium app when the user restarts his/her device.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.Tools.Receiver`模块提供的第一个`BOOT_COMPLETED`选项是能够重启您的应用。典型用例是在用户重启其设备时重启Titanium应用。'
- en: Tip
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To deploy this scenario to your device using the recipe source, rename the `1.auto_start_tiapp.xml`
    file to `tiapp.xml` and the `1.app.js` to `app.js`. This will switch the recipe
    app to use the following scenario details.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用配方源将此场景部署到您的设备上，将`1.auto_start_tiapp.xml`文件重命名为`tiapp.xml`，将`1.app.js`重命名为`app.js`。这将使配方应用使用以下场景详情。
- en: 'Auto restart step 1: adding the receiver to tiapp.xml'
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动重启步骤 1：将接收器添加到tiapp.xml
- en: The first step in enabling this scenario is to add the receiver entry into the
    Android configuration node in our project's `tiapp.xml` file located in the root
    of your Titanium Project.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此场景的第一步是将接收器条目添加到我们项目中的Android配置节点，该节点位于您的Titanium项目根目录下的`tiapp.xml`文件中。
- en: '[PRE105]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: First an intent filter must be added to our receiver, this will subscribe our
    app to the `BOOT_COMPLETED` broadcast.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，必须在我们的接收器中添加一个intent过滤器，这将使我们的应用订阅`BOOT_COMPLETED`广播。
- en: '[PRE106]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Next a metadata node is added with the name `bootType`. This node is used by
    the `Android.Tools` module to determine what boot action should be taken. The
    following snippet demonstrates how to configure the module to restart the app.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来添加一个名为`bootType`的元数据节点。此节点由`Android.Tools`模块使用，以确定应采取什么启动操作。以下代码片段演示了如何配置模块以重启应用。
- en: '[PRE107]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Then a metadata node is added with the name `sendToBack`. This node is used
    by the `Android.Tools` module to determine if the app should be restarted in the
    background if set to `true`, or restarted in the foreground if set to `false`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个名为`sendToBack`的元数据节点。此节点由`Android.Tools`模块使用，以确定如果设置为`true`，则应用应在后台重启，如果设置为`false`，则应在前台重启。
- en: '[PRE108]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Finally the `RECEIVE_BOOT_COMPLETED` permission is added.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后添加了`RECEIVE_BOOT_COMPLETED`权限。
- en: '[PRE109]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Auto restart step 2: testing'
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动重启步骤 2：测试
- en: 'The following steps outline how to best test this recipe scenario:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何最好地测试此配方场景：
- en: Clean your Titanium solution and push to device.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理您的Titanium解决方案并将其推送到设备。
- en: Make sure the app is not running on your device. You can stop the app using
    the **Force stop** option under **Settings**.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用未在您的设备上运行。您可以使用**设置**中的**强制停止**选项停止应用。
- en: Restart your device.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启您的设备。
- en: After the device has been restarted, confirm the date and time displayed on
    the recipe's main screen.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备重启后，确认配方主屏幕上显示的日期和时间。
- en: Scenario B – notification on restart
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景 B – 重启时通知
- en: The second `BOOT_COMPLETED` option provided by the `Android.Tools.Receiver`
    module is the ability to create a notification message when a user restarts his/her
    device. This can be used to provide a reminder or instructions to the user.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.Tools.Receiver` 模块提供的第二个 `BOOT_COMPLETED` 选项是在用户重启其设备时创建通知消息的能力。这可以用于向用户提供提醒或说明。'
- en: Tip
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To deploy this scenario to your device using the recipe source, rename the `2.auto_start_tiapp.xml`
    file to `tiapp.xml` and the `2.app.js` file to `app.js`. This will switch the
    recipe app to use the following scenario details.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用配方源将此场景部署到您的设备上，将 `2.auto_start_tiapp.xml` 文件重命名为 `tiapp.xml`，将 `2.app.js`
    文件重命名为 `app.js`。这将使配方应用切换到使用以下场景详情。
- en: 'Notification on restart step 1: adding receiver to tiapp.xml'
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重启通知步骤 1：将接收器添加到 tiapp.xml
- en: The first step in enabling this scenario is to add the receiver entry into the
    Android configuration node in our project's `tiapp.xml` file.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此场景的第一步是将接收器条目添加到我们项目 `tiapp.xml` 文件中的 Android 配置节点。
- en: '[PRE110]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: First, an intent filter must be added to our receiver, this will subscribe our
    app to the `BOOT_COMPLETED` broadcast.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，必须向我们的接收器添加一个意图过滤器，这将使我们的应用订阅 `BOOT_COMPLETED` 广播。
- en: '[PRE111]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Next, a metadata node is added with the name `bootType`. This node is used by
    the `Android.Tools` module to determine what boot action should be taken. The
    following snippet demonstrates how to configure the module to send a notification
    message on device restart.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `bootType` 的元数据节点。此节点由 `Android.Tools` 模块用于确定应采取什么启动操作。以下片段演示了如何配置模块在设备重启时发送通知消息。
- en: '[PRE112]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Then a metadata node is added with the name `title`. This node contains the
    notification title that will be used.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个名为 `title` 的元数据节点。此节点包含将要使用的通知标题。
- en: '[PRE113]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Then a metadata node is added with the name `message`. This node contains the
    notification message that will be used.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个名为 `message` 的元数据节点。此节点包含将要使用的通知消息。
- en: '[PRE114]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Finally the `RECEIVE_BOOT_COMPLETED` permission is added.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加了 `RECEIVE_BOOT_COMPLETED` 权限。
- en: '[PRE115]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Notification on restart step 2: testing'
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重启通知步骤 2：测试
- en: 'The following steps outline the best method to test this recipe scenario:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了测试此配方场景的最佳方法：
- en: Clean your Titanium solution and push to device.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理您的钛金解决方案并将其推送到设备。
- en: Make sure the app is not running on your device. You can stop the app using
    the **Force stop** option under **Settings**.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用在您的设备上没有运行。您可以使用 **设置** 下的 **强制停止** 选项停止应用。
- en: Restart your device.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启您的设备。
- en: Within a few seconds of device reboot, you will see a new message in yournotification
    tray.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备重启后的几秒钟内，您将在通知托盘中看到一条新消息。
- en: Scenario C – property controlled
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景 C – 属性控制
- en: The final `BOOT_COMPLETED` option provided by the `Android.Tools.Receiver` module
    is the ability to restart your app. The typical use case would be to restart your
    Titanium app when the user restarts his/her device.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.Tools.Receiver` 模块提供的最终 `BOOT_COMPLETED` 选项是能够重启您的应用。典型用例是在用户重启其设备时重启钛金应用。'
- en: Tip
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To deploy this scenario to your device using the recipe source, rename the `3.auto_start_tiapp.xml`
    file to `tiapp.xml` and the `3.app.js` file to `app.js`. This will switch the
    recipe app to use the following scenario details.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用配方源将此场景部署到您的设备上，将 `3.auto_start_tiapp.xml` 文件重命名为 `tiapp.xml`，将 `3.app.js`
    文件重命名为 `app.js`。这将使配方应用切换到使用以下场景详情。
- en: 'Property controlled step 1: adding receiver to tiapp.xml'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性控制步骤 1：将接收器添加到 tiapp.xml
- en: The first step in enabling this scenario is to add the receiver entry into the
    Android configuration node in our project's `tiapp.xml` file.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此场景的第一步是将接收器条目添加到我们项目 `tiapp.xml` 文件中的 Android 配置节点。
- en: '[PRE116]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: An intent filter must be added to our receiver, this will subscribe our app
    to the `BOOT_COMPLETED` broadcast.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须向我们的接收器添加一个意图过滤器，这将使我们的应用订阅 `BOOT_COMPLETED` 广播。
- en: '[PRE117]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Next, a metadata node is added with the name `bootType`. This node is used by
    the `Android.Tools` module to determine what boot action should be taken. The
    following code snippet demonstrates how to configure the module to use Titanium
    properties to determine what action should be taken.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `bootType` 的元数据节点。此节点由 `Android.Tools` 模块用于确定应采取什么启动操作。以下代码片段演示了如何配置模块以使用钛金属性来确定应采取的操作。
- en: '[PRE118]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Metadata nodes are then added to configure the `BOOT_COMPLETED` receiver. Each
    node is used to map a Titanium property to a receiver configuration element. For
    example, the `bootType_property_to_reference` holds the name of the property to
    be used to determine the `bootType`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加元数据节点来配置 `BOOT_COMPLETED` 接收器。每个节点都用于将一个 Titanium 属性映射到一个接收器配置元素。例如，`bootType_property_to_reference`
    包含用于确定 `bootType` 的属性名称。
- en: '[PRE119]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Finally, the `RECEIVE_BOOT_COMPLETED` permission is added.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加 `RECEIVE_BOOT_COMPLETED` 权限。
- en: '[PRE120]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Property controlled step 2: create recipe app.js'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性控制步骤 2：创建 recipe app.js
- en: The `Android.Tools` module allows for the `BOOT_COMPLETED` receiver to be configured
    through Titanium properties. The following code snippet (`app.js`) demonstrates
    how to create two different configurations by simply updating the correct Titanium
    properties.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.Tools` 模块允许通过 Titanium 属性配置 `BOOT_COMPLETED` 接收器。以下代码片段（`app.js`）演示了如何通过简单地更新正确的
    Titanium 属性来创建两种不同的配置。'
- en: First, a `Ti.UI.Window` is created to attach all UI elements.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 `Ti.UI.Window` 来附加所有 UI 元素。
- en: '[PRE121]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Next, a `Ti.UI.Button` is created to demonstrate how to create a foreground
    restart.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `Ti.UI.Button` 来演示如何创建前台重启。
- en: '[PRE122]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: On the `click` event of our first button, the properties used to configure our
    `BOOT_COMPLETED` receiver are updated.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们第一个按钮的 `click` 事件上，用于配置我们的 `BOOT_COMPLETED` 接收器的属性被更新。
- en: '[PRE123]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The first action performed in the `click` event is to set the `BOOT_COMPLETED`
    receiver as enabled.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `click` 事件中执行的第一项操作是将 `BOOT_COMPLETED` 接收器设置为启用。
- en: '[PRE124]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Next, the `bootType` is set to restart. This will restart our Titanium app on
    device reboot.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `bootType` 设置为重启。这将使我们的 Titanium 应用在设备重启时重启。
- en: '[PRE125]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Then the `sendToBack` property is set to `false`. This will restart our Titanium
    app in the foreground when the user restarts his/her device.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `sendToBack` 属性设置为 `false`。这将使用户在重启其设备时，我们的 Titanium 应用在前台重启。
- en: '[PRE126]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Next, a second button is created to demonstrate how to configure the notification.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建第二个按钮来演示如何配置通知。
- en: '[PRE127]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Next a second button is created to demonstrate how to configure notification
    to be generated when the device is restarted.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来创建第二个按钮来演示如何在设备重启时生成通知的配置。
- en: '[PRE128]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: An action performed in the `click` event is to set the `BOOT_COMPLETED` receiver
    to `enabled`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `click` 事件中执行的操作是将 `BOOT_COMPLETED` 接收器设置为 `enabled`。
- en: '[PRE129]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Next the `bootType` is set to `notify`. This will send a message after receiving
    the `BOOT_COMPLETED` broadcast.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `bootType` 设置为 `notify`。这将接收 `BOOT_COMPLETED` 广播后发送一条消息。
- en: '[PRE130]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Next, the notification icon resource identifier is created. This resource identifier
    will be used to create an icon when the notification is created. If no resource
    identifier is provided, a star icon will be used by default.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建通知图标资源标识符。此资源标识符将用于在创建通知时创建图标。如果没有提供资源标识符，则默认使用星形图标。
- en: '[PRE131]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Finally the properties linked to the notification title and message are set
    with new string values. These properties will be used in generating the notification
    when the device has been restarted.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将链接到通知标题和消息的属性设置为新的字符串值。这些属性将在设备重启时生成通知时使用。
- en: '[PRE132]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Property controlled step 3: testing'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性控制步骤 3：测试
- en: 'The following steps outline how to best test this recipe scenario:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何最好地测试此配方场景：
- en: Clean your Titanium solution and push to device.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理您的 Titanium 解决方案并将其推送到设备。
- en: Open the app, and press the first button (`button1`). This will update the properties
    to perform a foreground restart.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用，并按下第一个按钮（`button1`）。这将更新属性以执行前台重启。
- en: Next stop the app; you can stop the app using the **Force stop** option under
    **Settings**.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来停止应用；您可以在 **设置** 下的 **强制停止** 选项中停止应用。
- en: Restart your device.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启您的设备。
- en: After the device is started, the recipe app will be launched in the foreground.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备启动后，配方应用将在前台启动。
- en: Press the second button (`button2`). This will update the properties to send
    a notification on restart.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下第二个按钮（`button2`）。这将更新属性以在重启时发送通知。
- en: Restart your device.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启您的设备。
- en: Within a few seconds of device reboot, you will see a new message in your notification
    tray.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备重启后的几秒钟内，您将在通知托盘中看到一条新消息。
- en: See also
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Android.Tools` module was used in this recipe to provide the `BOOT_COMPLETED`
    functionality. For additional information about this module, please visit the
    project on Github at [https://github.com/benbahrenburg/benCoding.Android.Tools](https://github.com/benbahrenburg/benCoding.Android.Tools).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中使用了`Android.Tools`模块来提供`BOOT_COMPLETED`功能。有关此模块的更多信息，请访问GitHub上的项目[https://github.com/benbahrenburg/benCoding.Android.Tools](https://github.com/benbahrenburg/benCoding.Android.Tools)。
- en: For full documentation on the BootReceiver, visit [https://github.com/benbahrenburg/benCoding.Android.Tools/tree/master/documentation/bootreceiver.md](https://github.com/benbahrenburg/benCoding.Android.Tools/tree/master/documentation/bootreceiver.md).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 有关BootReceiver的完整文档，请访问[https://github.com/benbahrenburg/benCoding.Android.Tools/tree/master/documentation/bootreceiver.md](https://github.com/benbahrenburg/benCoding.Android.Tools/tree/master/documentation/bootreceiver.md)。
- en: iOS Multithreading using Web Workers
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web Workers进行iOS多线程
- en: Enterprise apps often require a large amount of processing to be performed.
    To provide the best user experience while fully leveraging the limited device
    resources, you must perform compute operations on a background thread.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序通常需要执行大量的处理。为了在充分利用有限的设备资源的同时提供最佳的用户体验，您必须在后台线程上执行计算操作。
- en: In this recipe, we will discuss how to use the `Ti.WebWorkerWrapper` module
    to perform background compute operations. To simulate a compute job, a fibonacci
    sequence is calculated for random numbers and processed in parallel. The following
    screenshot shows the recipe running these Web Worker jobs on an iPhone.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何使用`Ti.WebWorkerWrapper`模块执行后台计算操作。为了模拟计算任务，对随机数字计算斐波那契序列并在并行中进行处理。以下截图显示了在iPhone上运行这些Web
    Worker任务的食谱。
- en: '![iOS Multithreading using Web Workers](img/5343_07_13.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![使用Web Workers进行iOS多线程](img/5343_07_13.jpg)'
- en: Note
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe is an iOS-only recipe as it requires Web Workers, which are not
    yet available for Titanium Android.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱是一个仅适用于iOS的食谱，因为它需要Web Workers，而Web Workers目前尚不支持Titanium Android。
- en: Getting ready
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'This recipe uses the `Ti.WebWorkerWrapper` CommonJS module and `fibonacci.js`
    Web Worker. These modules and other code assets can be downloaded from the source
    provided by the book, or individually through the links provided in the *See also*
    section at the end of this recipe. To install the `Ti.WebWorkerWrapper` module
    and Web Worker into your project, simply copy the `Ti.WebWorkerWrapper.js` and
    `fibonacci.js` files into the `Resources` folder of your Titanium project as highlighted
    in the following screenshot:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱使用`Ti.WebWorkerWrapper` CommonJS模块和`fibonacci.js` Web Worker。这些模块和其他代码资产可以从本书提供的源代码中下载，或者通过本食谱末尾的“另请参阅”部分提供的链接单独下载。要将`Ti.WebWorkerWrapper`模块和Web
    Worker安装到您的项目中，只需将`Ti.WebWorkerWrapper.js`和`fibonacci.js`文件复制到您的Titanium项目中的`Resources`文件夹，如下截图所示：
- en: '![Getting ready](img/5343_07_14.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/5343_07_14.jpg)'
- en: How to do it...
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once you have added the `Ti.WebWorkerWrapper` module and `fibonacci.js` file
    to your project, you next need to create your application namespace and use `require`
    to import the module into your `app.js` file as the following code snippet demonstrates:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已将`Ti.WebWorkerWrapper`模块和`fibonacci.js`文件添加到您的项目中，接下来您需要创建您的应用程序命名空间，并使用`require`将模块导入到您的`app.js`文件中，如下代码片段所示：
- en: '[PRE133]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Creating the recipe UI
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建食谱UI
- en: 'This recipe provides a basic UI to launch and track the execution of the Web
    Workers execution of the fibonacci sequence. The following steps detail how to
    create the main components illustrated in the earlier screenshot:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱提供了一个基本的UI，用于启动和跟踪Web Workers执行斐波那契序列的过程。以下步骤详细说明了如何创建前面截图所示的主要组件：
- en: First a `Ti.UI.Window` is created. This window will be used to attach and display
    all UI elements.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个`Ti.UI.Window`。此窗口将用于附加和显示所有UI元素。
- en: '[PRE134]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Next a series of `Ti.UI.Label` controls are added to the `Ti.UI.Window`. These
    controls will be used to display the progress and results of the Web Workers.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，一系列`Ti.UI.Label`控件被添加到`Ti.UI.Window`中。这些控件将用于显示Web Workers的进度和结果。
- en: '[PRE135]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Note
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Three additional Web Worker labels are added using the same template as the
    `worker1` label shown in the preceding code snippet.
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用与前面代码片段中显示的`worker1`标签相同的模板，添加了三个额外的Web Worker标签。
- en: Finally a `Ti.UI.Button` is added to the `Ti.UI.Window`. This button is used
    to launch the four Web Worker processes used in this recipe.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Ti.UI.Window`中添加了一个`Ti.UI.Button`。此按钮用于启动本食谱中使用的四个Web Worker进程。
- en: '[PRE136]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Testing functions
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试函数
- en: This recipe uses a `tests` object to assist with timing and displaying the results
    of the Web Worker fibonacci sequence processing. The following section discusses
    functionality contained within the `tests` JavaScript object.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱使用一个 `tests` 对象来帮助处理时间和显示 Web Worker 斐波那契数列处理的结果。以下部分讨论了 `tests` JavaScript
    对象中的功能。
- en: '[PRE137]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The `updateLabel` method is used to apply a formatting template to each label
    with the results of the fibonacci sequence callback results.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`updateLabel` 方法用于将格式化模板应用于每个标签，以显示斐波那契数列回调结果。'
- en: '[PRE138]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The `worker1` through `worker4` methods are the callback methods provided to
    each Web Worker as it processes the fibonacci sequence. These callbacks receive
    the results from the calculation process.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`worker1` 至 `worker4` 方法是作为回调方法提供给每个 Web Worker 的，以便它在处理斐波那契数列时使用。这些回调接收计算过程中的结果。'
- en: '[PRE139]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The `random` method is used to generate a random number within a given range.
    This method is used to generate the random number sent to the fibonacci sequence.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`random` 方法用于在给定范围内生成随机数。此方法用于生成发送给斐波那契数列的随机数。'
- en: '[PRE140]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Multithreading using Web Workers
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Web Workers 进行多线程
- en: The multithreading example is run when the user taps on the `runButton` button.
    The following section demonstrates how four Web Workers are created in the background.
    Once each Web Worker has finished processing, the results are provided to the
    test's callback method discussed earlier in this recipe.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 `runButton` 按钮时，将运行多线程示例。以下部分演示了如何在后台创建四个 Web Workers。一旦每个 Web Worker
    完成处理，结果将提供给本菜谱前面讨论过的测试回调方法。
- en: '[PRE141]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: First a new worker object is created by initializing a new instance of the `Ti.WebWorkerWrapper`
    module.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过初始化 `Ti.WebWorkerWrapper` 模块的新实例来创建一个新的 worker 对象。
- en: '[PRE142]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Next, the `start` method is called on the `worker` object. The `start` method
    requires the following arguments:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `worker` 对象上调用 `start` 方法。`start` 方法需要以下参数：
- en: The path of the JavaScript file the Web Worker should execute
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Worker 应该执行的 JavaScript 文件路径
- en: A random number passed as a Web Worker `postMessage` for the fibonacci sequence
    to use
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Web Worker `postMessage` 传递的随机数
- en: The callback method to be used when the Web Worker has completed processing
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Web Worker 完成处理时使用的回调方法
- en: '[PRE143]'
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Three additional Web Workers are created using the same pattern demonstrated
    in the creation of `worker1`.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与 `worker1` 创建相同的模式创建了三个额外的 Web Workers。
- en: '[PRE144]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: See also
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Ti.WebWorkerWrapper` CommonJS module is used in this recipe to provide
    multithreading support for the `fibonacci.js` computation. For additional details,
    please visit the module on Github at [https://github.com/benbahrenburg/Ti.WebWorkerWrapper](https://github.com/benbahrenburg/Ti.WebWorkerWrapper).
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，使用 `Ti.WebWorkerWrapper` CommonJS 模块为 `fibonacci.js` 计算提供多线程支持。有关更多详细信息，请访问
    Github 上的模块 [https://github.com/benbahrenburg/Ti.WebWorkerWrapper](https://github.com/benbahrenburg/Ti.WebWorkerWrapper)。
