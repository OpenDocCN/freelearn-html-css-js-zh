- en: Chapter 7. Threads, Queues, and Message Passing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Queuing multiple downloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching one app from another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform URL schemes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening your Android app on BOOT_COMPLETED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS multithreading using Web Workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Size, complexity, and volume are common issues encountered in developing and
    maintaining enterprise apps. Titanium provides support for several common patterns
    used to separate operational responsibility patterns.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how to use message passing, queuing, and multithreaded
    capabilities in Titanium. These step-by-step recipes can then be used to incorporate
    these design principles into your existing Titanium enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: Queuing multiple downloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is commonplace for enterprise apps to require the need to download documents
    and content from your organization's file servers. Use of queuing is helpful in
    this scenario to ensure order and delivery while avoiding pitfalls often associated
    with spawning multiple asynchronous requests. This recipe uses the `Ti.Queue`
    CommonJS module to create a persistent, named queue to perform file downloads.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to implement a persistent queue, this recipe will download
    to your device 5 MB sample files from Github. The following screenshots illustrate
    what this recipe looks like while running on both the iPhone and Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Queuing multiple downloads](img/5343_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses the `Ti.Queue` CommonJS module. This module and other code
    assets can be downloaded from the source provided by the book, or individually
    through the links provided in the *See also* section at the end of this recipe.
    Installing these in your project is straightforward. Simply copy the `Ti.Queue.js`
    file into your project as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Network connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe requires a network connection to download files from Github. Please
    make sure the device or simulator has proper network connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have added the `Ti.Queue` module to your project, you need to create
    your application namespace in the `app.js` file and use `require` to import the
    module into your code as the following code snippet demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating the recipe's UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following steps outline how to create the UI used in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a `Ti.UI.Window` is created to attach all UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, a `Ti.UI.ProgressBar` is added to the `Ti.UI.Window`. This will be used
    to display the status of the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `show` method is called immediately on our `Ti.UI.ProgressBar` so that it
    will be displayed on the `Ti.UI.Window` correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, a `Ti.UI.Button` is added to the `Ti.UI.Window`. This control will be
    used to trigger the queue download logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step in the recipe is to create a named queue as demonstrated in the
    following code snippet. By default, any named queue is persistent and will store
    all jobs between sessions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a name is not provided when creating a new queue, the queue will not save
    jobs between app restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding jobs to the queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the queue has been created, the next step is to create a series of jobs
    for the queue to manage. The following code block creates three download jobs
    for the queue to manage.
  prefs: []
  type: TYPE_NORMAL
- en: The first job is created to download a ZIP file from Github. A timestamp is
    used to provide a unique name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, a second job is created to download a ZIP file from Github. A timestamp
    is used to provide a unique name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, a third job is created to download a ZIP file from Github. A timestamp
    is used to provide a unique name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Recipe's assistant functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `assist` object is used to manage the download process. The following is
    a discussion on how the `assist` object works and can be leveraged within your
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `progressSetup` method is used to restart the progress bar when a new download
    system has been initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `updateProcess` method is used to update the progress bar information and
    alert the user to the status of the overall download job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `whenFinished` method is called after all `Ti.Queue` jobs have finished
    or generated errors. This method is used to update UI to alert the user about
    the queued job which has been processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `next` method is used to process the next job in the `Ti.Queue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This step in the `next` method is to check if there are any jobs available.
    This is done by calling the `getLength` method on the queue to retrieve the number
    of jobs currently stored in the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If there are no jobs remaining in the queue, the `whenFinish` method is called
    and the download process is exited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If a job is available in the queue, the next step is to update the `progressValue`
    to show the current processing status as shown in the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to call the `peek` method on the queue. This allows us to fetch
    the next item in the queue without popping it from the queue itself. This is used
    to write the information to the Titanium Studio console for debugging purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to call the `dequeue` method on the queue. This function pops
    the next item from the queue and returns the item. In the following code snippet,
    the `dequeue` method is called to provide the next queue job to the `item` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `updateProgress` method is then called to alert the user to the download
    progress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next the `download` method is called to start the download process. To create
    a recursive function, the `next` method is provided as a callback argument to
    the `download` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `download` method contains all logic needed to download the queued job from
    Github.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first step in downloading the file from Github is to create `Ti.Network.HTTPClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `onload` callback is fired when the `Ti.Network.HTTPClient` receives a successful
    response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the response does not provide a `200` status code, an error is generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the proper status code is returned, a `Ti.Filesytem` object is then created
    and the `responseData` is saved to the provided output path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `responseData` has been persisted to the filesystem, the callback
    method is triggered. This allows for the recipe to recursively loop through the
    queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `onerror` callback is triggered when the `Ti.Network.HTTPClient` receives
    an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When an error is received, the provided job is requeued for another attempt,
    by calling the `requeue` method on the `assist` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The download progress is started by calling the `open` and `send` methods on
    the `Ti.Network.HTTPClient` using the queue item''s `url` details as demonstrated
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `requeue` method is used to add an item back into the queue. The recipe
    is designed to provide three attempts at downloading before the job is considered
    a permanent error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The item's `attempt` property is checked to determine if the job has been attempted
    more than three times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the job has been attempted more than three times, the item is not readded
    to the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the job has errored, less than three times, the `attempts` property is incremented
    and the item is added to the queue again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally the `callback` method is fired, moving the download process to the next
    step in its lifecycle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start downloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the `downloadButton` is pressed the recipe begins to process the queued
    jobs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first step in the download process is to check if the recipe has a network
    connection. If the network is not available, the recipe will alert the user to
    exit the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step in the download process is to disable the `downloadButton`. This
    avoids the user from processing the button again, once the job has started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `my.jobInfo` object is then updated with the current count and status information.
    This will be used to track the overall download status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next the `processSetup` method is called to initialize the `Ti.UI.ProgressBar`
    with the correct `min` and `max` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, the `next` method is called on the `assist` object. This begins the
    download process and creates a recursive loop that will run until the queue is
    empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about the `Ti.Queue` module used in this recipe, please visit
    [https://github.com/benbahrenburg/Ti.Queue](https://github.com/benbahrenburg/Ti.Queue).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching one app from another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A majority of mobile enterprise apps are designed around a specific task such
    as time reporting. Through the use of URL schemes or Android intent filters you
    can open and communicate between different apps on the user's device. For example,
    you can provide an option for your organization's time-reporting app to open the
    expense app when an employee is traveling and needs to record additional information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe demonstrates how to launch different apps using the native platform''s
    integration pattern. The following screenshot illustrates this recipe running
    on both an iOS and Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching one app from another](img/5343_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe must be run on a device to fully experience all features. A device
    is required as the simulator or emulator do not allow apps from the different
    app stores to be run.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses the `schemeList` CommonJS module. This module and other code
    assets can be downloaded from the source provided by the book. Installing these
    in your project is straightforward. Simply copy the `schemeList.js` file into
    your project as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Network connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This recipe requires that the following apps are installed on your device:'
  prefs: []
  type: TYPE_NORMAL
- en: LinkedIn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evernote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Maps (on iOS and Android)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL Scheme example recipe discussed later in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After adding the `schemaList` module, you will need to create your application
    namespace in the `app.js` file and use `require` to import the module into your
    code as the following code snippet demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: iOS updating tiapp.xml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding the ability to allow other iOS apps to launch your apps is straightforward.
    The following code snippet demonstrates how to add a custom scheme named, `bencoding-linkLauncher`
    to this recipe. This allows any iOS app to launch this sample in a similar fashion
    as discussed later in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `CFBundleURLlTypes` node is an array of dictionaries describing the URL
    schemes supported by the bundle. Under this node, you will list all of the URL
    and scheme names your app will respond to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `CFBundleURLName` is the key that contains the abstract name for this URL
    type. This is the main way to refer to a particular type. To ensure uniqueness,
    it is recommended that you use a Java-package style identifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `CFBundleURLSchemes` is the key that contains an array of strings, each
    of which identifies a URL scheme handled by this type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Creating an app launch list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `schemeList` CommonJS module, added to the `my.scheme` property provides
    a list of iOS and Android scheme examples. The following sections describe how
    schemes are created on both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: iOS scheme list
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On iOS, a URL scheme works just like a URL on the web. The only difference is
    the app's registered URL scheme is used as the protocol. The following steps provide
    detailed examples of the specific URL formats available.
  prefs: []
  type: TYPE_NORMAL
- en: The `getiOSList` provides an array of objects designed to be bound to a `Ti.UI.TableView`
    and later used to launch other apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The most basic type of URL scheme is simply the `CFBundleURLName` of the app.
    This is shown in the following examples for Evernote and LinkedIn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: More complex URL schemes can be used, such as the following example showing
    a URL scheme including the `about` route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'URL schemes can also include query parameters similar to a web page, as demonstrated
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Android scheme list
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Android has the ability to launch applications in a variety of ways. This recipe
    focuses on how to use a URL scheme similar to iOS and intents for app integration.
  prefs: []
  type: TYPE_NORMAL
- en: The `getAndroidList` provides an array of objects designed to be bound to a
    `Ti.UI.TableView` and later used to launch other apps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Similar to iOS apps, you can use a route base URL to launch a third-party app.
    The following code snippet shows how to construct a URL with an `about` route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just as with web pages, you can build more complex URLs with query string parameters.
    The following snippet demonstrates how to call a login screen while passing query
    string information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A more preferred way to launch apps on Android is to use intents. The following
    example shows how to create an intent to launch the LinkedIn app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the LinkedIn intent has been created, it is added to the app's array with
    a type of intent. This will later be used to launch the LinkedIn app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The LinkedIn app must be installed on the user's device in order to have the
    intent launch the app. If the app is not installed, an exception will be generated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A more preferred way to launch apps on Android is to use intents. The following
    example shows how to create an intent to launch the Evernote app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The Evernote app must be installed on the user's device in order to have the
    intent launch the app. If the app is not installed, an exception will be generated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the Evernote intent has been created, it is added to the app's array with
    a type of intent. This will later be used to launch the Evernote app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The recipe's UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section of the recipe is the UI used to launch the third-party apps.
  prefs: []
  type: TYPE_NORMAL
- en: First, a `Ti.UI.Window` is created to attach all UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next the `schemeList` CommonJS module is called to return a list of the applications
    to launch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `schemaData` object is then formatted and bound to a `Ti.UI.TableView` for
    display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final section of this recipe demonstrates how to launch third-party apps
    using the list displayed in the `Ti.UI.TableView`.
  prefs: []
  type: TYPE_NORMAL
- en: A `click` event is added to the `Ti.UI.TableView`. This event will be fired
    when the user taps on a row in the `Ti.UI.TableView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the event is fired, the first step is to check the platform on which the
    recipe is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If running under Android, a check must be performed to determine if the launch
    type is an intent or URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the launch type is an intent, `Ti.Android.currentActivity.startActivity`
    is called using the provided intent as shown in the following snippet. This will
    launch the third-party app if it is installed on the user's device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the launch type is a URL, the `Ti.Platform.openURL` method is used to open
    the app using the provided `url` property as shown in the following snippet. This
    will launch the third-party app if it is installed on the user's device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If the app is not installed, an exception will be generated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The iOS platform launches third-party apps using a URL scheme similar to how
    web pages are loaded using the `Ti.Platform.openURL` method. The following snippet
    demonstrates how to launch a third-party app using the `url` property provided
    by the `schemeList` CommonJS module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about using Android intents in Titanium, visit *Forging Titanium
    Episode 9* at [http://developer.appcelerator.com/blog/2011/10/forging-titanium-episode-9-android-intent-cookbook.html](http://developer.appcelerator.com/blog/2011/10/forging-titanium-episode-9-android-intent-cookbook.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform URL schemes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: URL schemes on iOS and intent filters on Android provide an open integration
    point for you to expose functionality in your apps to others. This is particularly
    helpful if you are building a suite of enterprise apps such as a separate mileage
    and expense app and want to allow for integration points between them.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how to create a cross-platform URL scheme within your
    Titanium Enterprise app. We will illustrate how to use this open integration point
    to access functionality within your Titanium app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses the `demoUI` and `Ti.SchemeTools` CommonJS libraries to help
    manage and demonstrate how to create cross-platform URL schemes. This module and
    other code assets can be downloaded from the source provided by the book. To install
    these modules, simply copy them to the `Resources` folder of your Titanium project
    as demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AppLauncher requirement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another requirement of this recipe is the AppLauncher app, which was created
    in the *Launching one app from another* recipe discussed earlier in this chapter.
    This app will be used to launch the different URL examples contained within this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After adding the `demoUI` and `Ti.SchemeTools` modules, you will need to create
    your application namespaces and use `require` to import the module into your `app.js`
    as the following code snippet demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: iOS updating tiapp.xml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add the ability for other apps to launch this recipe, you must make a few
    updates to the `tiapp.xml` file. The following steps discuss how to create the
    `bencoding-linkrecipe` custom URL scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open your project''s `tiapp.xml` file and make the following changes
    to the `ios` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add the `CFBundleURLTypes` node. This is an array of dictionaries describing
    the URL schemes supported by the bundle. Under this node, you will list all of
    the URL and scheme names your app will respond to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then add the `CFBundleURLName` key. This key contains the abstract name for
    this URL type. This is the main way to refer to a particular app. To ensure uniqueness,
    it is recommended that you use a Java-package style identifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the `CFBundleURLSchemes` keys. These keys contain an array of
    strings, each of which identifies a URL scheme handled by this type. The following
    snippet shows URLs for the login, about, and root activities of the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Android updating tiapp.xml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a custom URL scheme on Android, you will need to edit the `tiapp.xml`
    file to add an intent filter to listen for the specific `android:scheme` and `android:host`
    to be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: First open the `tiapp.xml` file and edit the android configuration node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add the `manifest` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `application` node. This node will later be used to generate your project's
    `AndroidManifest.xml` file, so make sure the attributes correctly match your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next add the application's root activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then add the app's main intent filter. This will be used to launch your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next add a second intent filter with your custom URL information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then add the data node with your `android:scheme` and `android:host` information.
    These values act as the protocol used when `Ti.Platform.openURL` is used to launch
    the URL scheme. The following highlighted code allows you to launch the app using
    a URL such as `bencoding-linkrecipe://com.bencoding`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next a category must be added to the intent filter so that the app will be exposed
    correctly to third-party launchers and will open the app when the URL scheme is
    called. The following highlighted snippet shows the category information needed
    to correctly implement the custom URL scheme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating the recipe UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe has a simple UI designed to demonstrate how different URL scheme
    features can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: First, a `Ti.UI.Window` is created; this window is the root `Ti.UI.Window` of
    the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next if the recipe is running on an iOS device, a `Ti.UI.Button` is added to
    allow the URL Receiver app to launch the App Launcher app created in the *Launching
    one app from another* recipe discussed earlier in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the `launcherButton` is tapped, the app will try to open the App Launcher
    if the app is available on the device. The highlighted code demonstrates how to
    use the `Ti.Platform.openURL` method to launch the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Launching helper functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe uses the `assist object` to help launch a different URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The `openWindow` method opens a specific window based on the URL and parameter
    values provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `openPageFromUrl` method is called when an app is opened or resumed to determine
    if the app has been opened from a third-party app and if so, what routing information
    has been provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first step is to determine if the app has been opened from a third-party
    app. This is done by checking the `hasLaunchUrl` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the app has not been launched from another app, the main page of the recipe
    will be displayed and any session variables will be reset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the app was launched by another app, we first need to check if the launching
    URL has changed. This avoids reloading the app if the same window has been requested.
    This can be done by calling the `hasChanged` method as highlighted in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next the URL to be launched is obtained by calling the `getLaunchUrl` method
    as the following code snippet shows. This URL is then loaded into a `session`
    variable for later use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then the requested page is obtained using the `getCurrentPage` function. This
    will be used in determining which page to load using the `openWindow` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, any launch parameters are obtained. The following code block demonstrates
    how to check if launch parameters have been provided and parses them into a formatted
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, the `openWindow` method is called using the `requestedPage` and `launchParams`
    created in the preceding steps. The `openWindow` method will then open the requested
    window in the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When launched from another app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to have the recipe launch the requested window, listeners must be
    added to the resumed and open events. The following steps detail how to add the
    proper event listeners to your app:'
  prefs: []
  type: TYPE_NORMAL
- en: If the recipe is running on iOS, the resumed event listener is added. Please
    note this must be added to your `app.js` when implementing in your own app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `assist.openPageFromUrl` method will be called each time the app is resumed.
    If no URL information is provided, the main window will be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A listener is added to the open event on the main window. This event will be
    fired when the app is first launched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the first launch, the `assist.openPageFromUrl` method is called to determine
    if the app has been opened by a third-party app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the recipe is running on Android, a listener is added to the `resume` event
    on the main window. This allows the recipe to detect if a third-party app tries
    to open the recipe while the app is running in the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cross-platform custom URL schemes are a great low-cost way to provide integration
    points with third parties. The following section details the end-to-end process
    for using the *Launching one app from another* recipe to access different app
    routes without this recipe's sample app.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the About window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section provides a step-by-step description on how you can launch the **About**
    window in the URL Receiver recipe when launched from the App Launcher recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Open the App Launcher application and tap on the **Recipe Example 1** row in
    the table view as shown with the red boxes in the following screenshot.![Launching
    the About window](img/5343_07_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The App Launcher app runs the following code block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**On iOS**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**On Android**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The URL Receiver recipe will then be launched on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resumed or open event handlers will then parse the provided URL information.
    When the `getCurrentPage` method is called, the `requestedPage` value will be
    set to a string with the value of `about`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, `my.scheme.hasParams` method is called to determine if any parameters
    have been passed as part of the provided URL. In this case, no additional parameters
    have been provided, so the `session` parameter object remains `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `openWindow` method is then called and the following **About** window is
    then opened:![Launching the About window](img/5343_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launching the Login window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section provides a step-by-step description of launching the **Login**
    window in the URL Receiver recipe when launched from the App Launcher recipe.
    As part of the launch process, the user and token parameters are provided by the
    App Launcher recipe then used to complete the form within the URL Receiver recipe
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Open the App Launcher application and tap on the **Recipe Example 2** row in
    the table view as shown with the red boxes in the following screenshot:![Launching
    the Login window](img/5343_07_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The App Launcher application runs the following code block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**On iOS**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**On Android**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The URL Receiver recipe will then be launched on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resumed or open event handlers will then parse the provided URL information.
    When the `getCurrentPage` method is called, the `requestedPage` value will be
    set to a string with the value of `login`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, `my.scheme.hasParams` method is called to determine if any parameters
    have been passed as part of the provide URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following parameter object is created using the query string parameters
    included with the calling URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `openWindow` method is then called providing the `requestedPage` and `parameter`
    objects. This will then open the **Login** page with the parameter used to complete
    the form as shown in the following screenshot:![Launching the Login window](img/5343_07_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Opening your Android app with BOOT_COMPLETED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many enterprise apps have the requirement of always running in the background.
    The most common categories of these apps would be for route management, item tracking,
    or customer scheduling apps. In your Android Titanium app, you can use an intent
    filter for the `BOOT_COMPLETED` action to notify your app that the device has
    been restarted. The event lifecycle for the `BOOT_COMPLETED` action is shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Opening your Android app with BOOT_COMPLETED](img/5343_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the `bencoding.android.tools` native module to help with the
    subscription of the `BOOT_COMPLETED` broadcast. This module and other code assets
    can be downloaded from the source provided by the book, or individually through
    the links provided in the See also section at the end of this recipe. To install
    this module, simply copy the `modules` folder shown in the following screenshot
    into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Also included with the sample recipe is a series of example `tiapp.xml` and
    `app.js` files demonstrating different options in handling the receipt of the
    `BOOT_COMPLETED` broadcast. You will need to copy the files highlighted in the
    following screenshot into your project as they will be used to demonstrate the
    different available options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After copying the mentioned files, you will need to click on your **tiapp.xml**
    file in Titanium Studio and add a reference to the `bencoding.android.tools` module
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe demonstrates how to implement the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Auto restarting your app upon receiving the `BOOT_COMPLETED` broadcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a notification to the user receiving the `BOOT_COMPLETED` broadcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Titanium properties to configure how your app handles the `BOOT_COMPLETED`
    broadcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required tiapp.xml updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a Titanium Android app is launched, the Titanium framework first must
    be initialized before your app can run. When the app is launched by another service
    such as the `BOOT_COMPLETED` broadcast, you will receive a message that the app
    needs to restart. To avoid this issue, you must add the following properties into
    your `tiapp.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Scenario A – auto restart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first `BOOT_COMPLETED` option provided by the `Android.Tools.Receiver` module
    is the ability to restart your app. The typical use case would be to restart your
    Titanium app when the user restarts his/her device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To deploy this scenario to your device using the recipe source, rename the `1.auto_start_tiapp.xml`
    file to `tiapp.xml` and the `1.app.js` to `app.js`. This will switch the recipe
    app to use the following scenario details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Auto restart step 1: adding the receiver to tiapp.xml'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first step in enabling this scenario is to add the receiver entry into the
    Android configuration node in our project's `tiapp.xml` file located in the root
    of your Titanium Project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: First an intent filter must be added to our receiver, this will subscribe our
    app to the `BOOT_COMPLETED` broadcast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next a metadata node is added with the name `bootType`. This node is used by
    the `Android.Tools` module to determine what boot action should be taken. The
    following snippet demonstrates how to configure the module to restart the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then a metadata node is added with the name `sendToBack`. This node is used
    by the `Android.Tools` module to determine if the app should be restarted in the
    background if set to `true`, or restarted in the foreground if set to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally the `RECEIVE_BOOT_COMPLETED` permission is added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Auto restart step 2: testing'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following steps outline how to best test this recipe scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean your Titanium solution and push to device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the app is not running on your device. You can stop the app using
    the **Force stop** option under **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the device has been restarted, confirm the date and time displayed on
    the recipe's main screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scenario B – notification on restart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second `BOOT_COMPLETED` option provided by the `Android.Tools.Receiver`
    module is the ability to create a notification message when a user restarts his/her
    device. This can be used to provide a reminder or instructions to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To deploy this scenario to your device using the recipe source, rename the `2.auto_start_tiapp.xml`
    file to `tiapp.xml` and the `2.app.js` file to `app.js`. This will switch the
    recipe app to use the following scenario details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notification on restart step 1: adding receiver to tiapp.xml'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first step in enabling this scenario is to add the receiver entry into the
    Android configuration node in our project's `tiapp.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: First, an intent filter must be added to our receiver, this will subscribe our
    app to the `BOOT_COMPLETED` broadcast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, a metadata node is added with the name `bootType`. This node is used by
    the `Android.Tools` module to determine what boot action should be taken. The
    following snippet demonstrates how to configure the module to send a notification
    message on device restart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then a metadata node is added with the name `title`. This node contains the
    notification title that will be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then a metadata node is added with the name `message`. This node contains the
    notification message that will be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally the `RECEIVE_BOOT_COMPLETED` permission is added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notification on restart step 2: testing'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following steps outline the best method to test this recipe scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean your Titanium solution and push to device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the app is not running on your device. You can stop the app using
    the **Force stop** option under **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within a few seconds of device reboot, you will see a new message in yournotification
    tray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scenario C – property controlled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final `BOOT_COMPLETED` option provided by the `Android.Tools.Receiver` module
    is the ability to restart your app. The typical use case would be to restart your
    Titanium app when the user restarts his/her device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To deploy this scenario to your device using the recipe source, rename the `3.auto_start_tiapp.xml`
    file to `tiapp.xml` and the `3.app.js` file to `app.js`. This will switch the
    recipe app to use the following scenario details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Property controlled step 1: adding receiver to tiapp.xml'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first step in enabling this scenario is to add the receiver entry into the
    Android configuration node in our project's `tiapp.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: An intent filter must be added to our receiver, this will subscribe our app
    to the `BOOT_COMPLETED` broadcast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, a metadata node is added with the name `bootType`. This node is used by
    the `Android.Tools` module to determine what boot action should be taken. The
    following code snippet demonstrates how to configure the module to use Titanium
    properties to determine what action should be taken.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Metadata nodes are then added to configure the `BOOT_COMPLETED` receiver. Each
    node is used to map a Titanium property to a receiver configuration element. For
    example, the `bootType_property_to_reference` holds the name of the property to
    be used to determine the `bootType`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, the `RECEIVE_BOOT_COMPLETED` permission is added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Property controlled step 2: create recipe app.js'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Android.Tools` module allows for the `BOOT_COMPLETED` receiver to be configured
    through Titanium properties. The following code snippet (`app.js`) demonstrates
    how to create two different configurations by simply updating the correct Titanium
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: First, a `Ti.UI.Window` is created to attach all UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, a `Ti.UI.Button` is created to demonstrate how to create a foreground
    restart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the `click` event of our first button, the properties used to configure our
    `BOOT_COMPLETED` receiver are updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first action performed in the `click` event is to set the `BOOT_COMPLETED`
    receiver as enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, the `bootType` is set to restart. This will restart our Titanium app on
    device reboot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then the `sendToBack` property is set to `false`. This will restart our Titanium
    app in the foreground when the user restarts his/her device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, a second button is created to demonstrate how to configure the notification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next a second button is created to demonstrate how to configure notification
    to be generated when the device is restarted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An action performed in the `click` event is to set the `BOOT_COMPLETED` receiver
    to `enabled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next the `bootType` is set to `notify`. This will send a message after receiving
    the `BOOT_COMPLETED` broadcast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, the notification icon resource identifier is created. This resource identifier
    will be used to create an icon when the notification is created. If no resource
    identifier is provided, a star icon will be used by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally the properties linked to the notification title and message are set
    with new string values. These properties will be used in generating the notification
    when the device has been restarted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Property controlled step 3: testing'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following steps outline how to best test this recipe scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean your Titanium solution and push to device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the app, and press the first button (`button1`). This will update the properties
    to perform a foreground restart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next stop the app; you can stop the app using the **Force stop** option under
    **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the device is started, the recipe app will be launched in the foreground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the second button (`button2`). This will update the properties to send
    a notification on restart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within a few seconds of device reboot, you will see a new message in your notification
    tray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Android.Tools` module was used in this recipe to provide the `BOOT_COMPLETED`
    functionality. For additional information about this module, please visit the
    project on Github at [https://github.com/benbahrenburg/benCoding.Android.Tools](https://github.com/benbahrenburg/benCoding.Android.Tools).
  prefs: []
  type: TYPE_NORMAL
- en: For full documentation on the BootReceiver, visit [https://github.com/benbahrenburg/benCoding.Android.Tools/tree/master/documentation/bootreceiver.md](https://github.com/benbahrenburg/benCoding.Android.Tools/tree/master/documentation/bootreceiver.md).
  prefs: []
  type: TYPE_NORMAL
- en: iOS Multithreading using Web Workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise apps often require a large amount of processing to be performed.
    To provide the best user experience while fully leveraging the limited device
    resources, you must perform compute operations on a background thread.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to use the `Ti.WebWorkerWrapper` module
    to perform background compute operations. To simulate a compute job, a fibonacci
    sequence is calculated for random numbers and processed in parallel. The following
    screenshot shows the recipe running these Web Worker jobs on an iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: '![iOS Multithreading using Web Workers](img/5343_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe is an iOS-only recipe as it requires Web Workers, which are not
    yet available for Titanium Android.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses the `Ti.WebWorkerWrapper` CommonJS module and `fibonacci.js`
    Web Worker. These modules and other code assets can be downloaded from the source
    provided by the book, or individually through the links provided in the *See also*
    section at the end of this recipe. To install the `Ti.WebWorkerWrapper` module
    and Web Worker into your project, simply copy the `Ti.WebWorkerWrapper.js` and
    `fibonacci.js` files into the `Resources` folder of your Titanium project as highlighted
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have added the `Ti.WebWorkerWrapper` module and `fibonacci.js` file
    to your project, you next need to create your application namespace and use `require`
    to import the module into your `app.js` file as the following code snippet demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Creating the recipe UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This recipe provides a basic UI to launch and track the execution of the Web
    Workers execution of the fibonacci sequence. The following steps detail how to
    create the main components illustrated in the earlier screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: First a `Ti.UI.Window` is created. This window will be used to attach and display
    all UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next a series of `Ti.UI.Label` controls are added to the `Ti.UI.Window`. These
    controls will be used to display the progress and results of the Web Workers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Three additional Web Worker labels are added using the same template as the
    `worker1` label shown in the preceding code snippet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally a `Ti.UI.Button` is added to the `Ti.UI.Window`. This button is used
    to launch the four Web Worker processes used in this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe uses a `tests` object to assist with timing and displaying the results
    of the Web Worker fibonacci sequence processing. The following section discusses
    functionality contained within the `tests` JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The `updateLabel` method is used to apply a formatting template to each label
    with the results of the fibonacci sequence callback results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `worker1` through `worker4` methods are the callback methods provided to
    each Web Worker as it processes the fibonacci sequence. These callbacks receive
    the results from the calculation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `random` method is used to generate a random number within a given range.
    This method is used to generate the random number sent to the fibonacci sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Multithreading using Web Workers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The multithreading example is run when the user taps on the `runButton` button.
    The following section demonstrates how four Web Workers are created in the background.
    Once each Web Worker has finished processing, the results are provided to the
    test's callback method discussed earlier in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: First a new worker object is created by initializing a new instance of the `Ti.WebWorkerWrapper`
    module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the `start` method is called on the `worker` object. The `start` method
    requires the following arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The path of the JavaScript file the Web Worker should execute
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A random number passed as a Web Worker `postMessage` for the fibonacci sequence
    to use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback method to be used when the Web Worker has completed processing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Three additional Web Workers are created using the same pattern demonstrated
    in the creation of `worker1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Ti.WebWorkerWrapper` CommonJS module is used in this recipe to provide
    multithreading support for the `fibonacci.js` computation. For additional details,
    please visit the module on Github at [https://github.com/benbahrenburg/Ti.WebWorkerWrapper](https://github.com/benbahrenburg/Ti.WebWorkerWrapper).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
