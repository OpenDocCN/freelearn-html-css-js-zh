<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Adding Physics to Your Games Using the Box2D Engine</h1></div></div></div><p>If you ask me what the biggest revolution in casual gaming is, no doubt I'll say physics engines. A lot of top-selling casual games such as Crayon Physics, Totem Destroyer, Crush the Castle, Angry Birds, Tiny Wings, just to mention a few use physics engines to add a realistic behavior that wouldn't be possible without such engines.</p><p>The most popular among physics engines in the 2D world is Box2D, initially written in C++, then ported to all major languages, including JavaScript.</p><p>Cocos2d-JS supports Box2D, and this chapter will cover the creation of a physics game, including these concepts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring and setting up Cocos2d-JS to add the Box2D engine to your games</li><li class="listitem" style="list-style-type: disc">Creating a physics world</li><li class="listitem" style="list-style-type: disc">Giving the world a realistic gravity</li><li class="listitem" style="list-style-type: disc">Combining bodies, shapes, and fixtures to create a physics object</li><li class="listitem" style="list-style-type: disc">Creating a material</li><li class="listitem" style="list-style-type: disc">Creating static objects</li><li class="listitem" style="list-style-type: disc">Creating dynamic objects</li><li class="listitem" style="list-style-type: disc">Attaching sprites to physics objects</li><li class="listitem" style="list-style-type: disc">Selecting physics objects with the mouse/finger</li><li class="listitem" style="list-style-type: disc">Destroying physics objects</li><li class="listitem" style="list-style-type: disc">Checking for collisions among objects</li><li class="listitem" style="list-style-type: disc">Running the physics simulation</li></ul></div><p>That's a lot of stuff, isn't it?</p><p>By the end of the chapter, you will have a playable level of a famous physics game.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Before you start</h1></div></div></div><p>Learning Box2D in just a few pages is not possible. A whole book is what you will need to start mastering it.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>For an in-depth <a id="id269" class="indexterm"/>understanding of Box2D, you can find my book, <em>Box2D for Flash Games</em>, at <a class="ulink" href="https://www.packtpub.com/game-development/box2d-flash-games">https://www.packtpub.com/game-development/box2d-flash-games</a>.</p></div></div><p>Anyway, this chapter will<a id="id270" class="indexterm"/> give you the bare bones to add physics to your games. Although experienced Box2D users may find some concepts such as collision detection covered in a less-than-perfect way, in the end, it works and that's what really matters in the scope of this chapter: giving you the knowledge to start learning Box2D and include it into your Cocos2d-JS projects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Adding the Box2D engine to your project</h1></div></div></div><p>The best game to write for<a id="id271" class="indexterm"/> you to learn most Box2D concepts is Totem <a id="id272" class="indexterm"/>Destroyer. It can be found at <a class="ulink" href="http://armorgames.com/play/1871/totem-destroyer">http://armorgames.com/play/1871/totem-destroyer</a>.</p><p>You have to smash bricks by clicking/tapping on them while being careful not to let the totem fall to the ground, or it's game over. Not all bricks can be destroyed. In the level shown in the following screenshot, dark bricks can't be destroyed:</p><div><img src="img/0075SOS_07_01.jpg" alt="Adding the Box2D engine to your project"/></div><p>Although the game has quite a simple gameplay, it features some advanced physics concepts, such as collision detection and how to select a physics body.</p><p>We will build this level; so, as usual, the first thing we need to do is take care of the content of the assets folder:</p><div><img src="img/0075SOS_07_02.jpg" alt="Adding the Box2D engine to your project"/></div><p>And this is the content of <code class="literal">loadassets.js</code>:</p><div><pre class="programlisting">var gameResources = [
  "assets/brick1x1.png",
  "assets/brick2x1.png",
  "assets/brick3x1.png",
  "assets/brick4x1.png",
  "assets/brick4x2.png",
  "assets/ground.png",
  "assets/totem.png"
];</pre></div><p>To keep loading times as fast as possible, the basic Cocos2d-JS source we used in the previous chapters<a id="id273" class="indexterm"/> did not feature any physics engine.</p><p>In order to have Cocos2d-JS work with Box2D, we have to load another module called <code class="literal">external</code>, which we will define in the <code class="literal">project.json</code> file:</p><div><pre class="programlisting">{
  "debugMode" : 0,
  "showFPS" : false,
  "frameRate" : 60,
  "id" : "gameCanvas",
  "renderMode" : 0,
  "engineDir":"cocos2d-html5/",

  <strong>"modules" : ["cocos2d","external"],</strong>

  "jsList" : [
    "src/loadassets.js",
    "src/gamescript.js"
    ]
}</pre></div><p>Now, the engine knows we will use Box2D; so, we can focus on the game itself.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Configuring the physics world</h1></div></div></div><p>From now on, all the script will be written in <code class="literal">gamescript.js</code> as usual, so be prepared to write your first Cocos2d-JS Box2D script.</p><p>Some of the magic<a id="id274" class="indexterm"/> happens from the first two lines, which declare global variables:</p><div><pre class="programlisting">var world;
var worldScale = 30;</pre></div><p>Here, the <code class="literal">world</code> variable will represent the physics world we are setting the game in, and will include its own gravity and other properties that we will discover. However, first I want to say a couple of words about <code class="literal">worldScale</code>.</p><p>Box2D is a realistic physics engine that uses real-world units of measurement. This way, everything you will create in Box2D world will be measured in meters. If you create a box whose side length is 2, you mean it's two meters.</p><p>On the other hand, browsers have their own unit of measurement, which is pixels. You can have a game 480 pixels wide, but you'll never find a game two meters wide.</p><p>So, we need to find a ratio between pixels and meters. In almost every project, the <em>1 meter = 30 pixels</em> setting works fine and allows us to think and work in pixels without caring about the Box2D internal unit of measurement.</p><p>The <code class="literal">gameScene</code> class declaration does not change:</p><div><pre class="programlisting">var gameScene = cc.Scene.extend({
  onEnter:function () {
    this._super();
    gameLayer = new game();
    gameLayer.init();
    this.addChild(gameLayer);
  }
});</pre></div><p>The interesting part as usual can be found in the <code class="literal">game</code> declaration:</p><div><pre class="programlisting">var game = cc.Layer.extend({
  init:function () {
    this._super();
    var backgroundLayer = cc.LayerGradient.create(cc.color(0xdf,0x9f,0x83,255), cc.color(0xfa,0xf7,0x9f,255));
    this.addChild(backgroundLayer);
    var gravity = new Box2D.Common.Math.b2Vec2(0, -10)
    world = new Box2D.Dynamics.b2World(gravity, true);
    
    this.scheduleUpdate();
  },
  update:function(dt){
    world.Step(dt,10,10);
    console.log(world);
  }
});</pre></div><p>Once you run the project, in your console, you should see a several instances of <strong>b2World</strong>.</p><p>This means our<a id="id275" class="indexterm"/> Box2D physics world is running; let's see what happened.</p><p>First, we added a gradient background layer:</p><div><pre class="programlisting">var backgroundLayer = cc.LayerGradient.create(cc.color(0xdf,0x9f,0x83,255), cc.color(0xfa,0xf7,0x9f,255));
this.addChild(backgroundLayer);</pre></div><p>Then, we already know that a physics world has gravity. Here is how we define the gravity:</p><div><pre class="programlisting">var gravity = new Box2D.Common.Math.b2Vec2(0, -10);</pre></div><p>All in all, the gravity in the real world can be represented by a vector, and Earth gravity can be represented by a vector (0,9.81), where 9.81 is expressed in meters per second squared, which is the average acceleration of a falling body near the surface of the Earth.</p><p>In Box2D, the <code class="literal">b2Vec2</code> type is used to store vectors; while it's clear that we can approximate 9.81 to 10, it's quite unclear why the gravity vector has its <em>y</em> value to -10. A negative gravity?</p><p>Let me explain: you already know Cocos2d-JS has its origin coordinate in the bottom left of the stage; so, as long as you move from bottom to top, your y coordinate increases. On the other hand, Box2D works in the opposite way: as long as a physics body falls down; its <em>y</em> coordinate increases, and setting the gravity at (0,10) would make Cocos2d-JS sprites fly away rather than fall down.</p><p>That's why we need to reverse the gravity. In Box2D, internal world bodies will fly away, but what we'll see on the stage are the same objects falling down.</p><p>Now, we are finally able to create the world:</p><div><pre class="programlisting">world = new Box2D.Dynamics.b2World(gravity, true);</pre></div><p>As you can see, the world has two arguments: the <code class="literal">gravity</code> variable we created before, and a Boolean flag to<a id="id276" class="indexterm"/> determine whether bodies can sleep. Normally, to save CPU time, physics bodies that don't receive hits and aren't affected by forces for some amount of time are put to sleep. This means they still exist in the Box2D world although their position isn't updated at each frame until they wake up because of some event such as a collision or a force applied to them.</p><p>The remaining line should already be clear for you. We are enabling the game to schedule the update function to be executed at each frame:</p><div><pre class="programlisting">this.scheduleUpdate();</pre></div><p>When we call <code class="literal">scheduleUpdate</code>, we also need an <code class="literal">update</code> function, which in this case only contains:</p><div><pre class="programlisting">world.Step(dt,10,10)</pre></div><p>The <code class="literal">Step</code> method advances the simulation for a certain amount of time, <code class="literal">dt</code> in this case and to be as accurate as possible, while the other two arguments represent the velocity and position iterations, respectively.</p><p>These two arguments are needed because most Box2D code is used for an operation called constraint solver, an <a id="id277" class="indexterm"/>algorithm that solves all the constraints in the simulation, one at a time. While one single constraint can be easily solved, when more constraints come into play, solving one of them means slightly disrupting the others. That's why we need more iterations in order to have an accurate simulation. The official Box2D documentation suggests you set eight for velocity and three for position, although I usually set both to 10 and do not have any problem in making simple games.</p><p>Now, it's time to build the totem.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Adding bodies to the world</h1></div></div></div><p>A physics object in the Box2D world is called a body. So, we will see how to add a body to the world. Moreover, since all bodies in our Totem Destroyer game are boxes, we will define a function to create a body and customize it to fit our needs.</p><p>We'll start from the end, calling a<a id="id278" class="indexterm"/> function we haven't written yet, just to have a look at all arguments that we need to create any kind of body used in Totem Destroyer.</p><p>So, the game's <code class="literal">init</code> function will be modified this way:</p><div><pre class="programlisting">init:function () {
  this._super();
  var backgroundLayer = cc.LayerGradient.create(cc.color(0xdf,0x9f,0x83,255), cc.color(0xfa,0xf7,0x9f,255));
  this.addChild(backgroundLayer);
  var gravity = new Box2D.Common.Math.b2Vec2(0, -10)
  world = new Box2D.Dynamics.b2World(gravity, true);
  
  this.scheduleUpdate();
  <strong>this.addBody(240,10,480,20,false,"assets/ground.png","ground");</strong>
}</pre></div><p>Our custom function is called <code class="literal">addBody</code> and according to the number of arguments will do a lot of things. Let's have a look at the following arguements:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">240</code>: This is the horizontal centre of the body, in pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">10</code>: This is the vertical centre of the body, in pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">480</code>: This is the body width, in pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">20</code>: This is the body height, in pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">false</code>: This Boolean value determines whether the body is dynamic or not. We are building two kinds of bodies, dynamic bodies, which are affected by forces such as gravity and react to collisions, and static bodies, which can't be moved. This will be a static body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">"assets/ground.png"</code>: These are the graphic assets to be bound to the body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">"ground"</code>: This is the body type. We call it <code class="literal">ground</code> because it will represent the ground.</li></ul></div><p>So, in other words, we are creating a static body in the bottom of the stage, which will represent the ground.</p><p>Now, it is time to see how to create and configure a body with Cocos2d-JS and Box2D. Add the <code class="literal">addBody</code> function to the <code class="literal">game</code> class:</p><div><pre class="programlisting">addBody: function(posX,posY,width,height,isDynamic,spriteImage,type){
  var fixtureDef = new  Box2D.Dynamics.b2FixtureDef;
  fixtureDef.density = 1.0;
  fixtureDef.friction = 0.5;
  fixtureDef.restitution = 0.2;
  fixtureDef.shape = new Box2D.Collision.Shapes.b2PolygonShape;
  fixtureDef.shape.SetAsBox(0.5*width/worldScale,0.5*height/worldScale);
  var bodyDef = new Box2D.Dynamics.b2BodyDef;
  if(isDynamic){
    bodyDef.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
  }
  else{
    bodyDef.type = Box2D.Dynamics.b2Body.b2_staticBody;
  }
  bodyDef.position.Set(posX/worldScale,posY/worldScale);
  var userSprite = cc.Sprite.create(spriteImage);
  this.addChild(userSprite, 0);
  userSprite.setPosition(posX,posY);
  bodyDef.userData = {
    type: type,
    asset: userSprite
  }
  var body = world.CreateBody(bodyDef)
  body.CreateFixture(fixtureDef);
}</pre></div><p>There's a lot of new<a id="id279" class="indexterm"/> stuff here, so we will see it line by line. First, we have to create a fixture:</p><div><pre class="programlisting">var fixtureDef = new  Box2D.Dynamics.b2FixtureDef;</pre></div><p>Think about a fixture as a relationship between a body, which is the physics actor, and its shape, which determines how the body looks—like a box, like a circle, and so on.</p><p>The fixture also determines the material of the body, thanks to these three attributes:</p><div><pre class="programlisting">fixtureDef.density = 1.0;
fixtureDef.friction = 0.5;
fixtureDef.restitution = 0.2;</pre></div><p>The <code class="literal">density</code> attribute affects the mass of the body, <code class="literal">friction</code> determines how bodies slide along each other, and <code class="literal">restitution</code> is used to see how a body bounces.</p><p>Now, it's time to create the shape attached to the fixture:</p><div><pre class="programlisting">fixtureDef.shape = new Box2D.Collision.Shapes.b2PolygonShape;
fixtureDef.shape.SetAsBox(0.5*width/worldScale,0.5*height/worldScale);</pre></div><p>The <code class="literal">SetAsBox</code> method <a id="id280" class="indexterm"/>creates a box given a width and a height that Box2D accepts as half of the actual <a id="id281" class="indexterm"/>width and height. So, if you want a box with a width of 30 meters, you'll have to set its width to <em>30*0.5</em>. As said, we are talking about pixels so we also have to divide the given width by <code class="literal">worldScale</code>.</p><p>Once we have the shape and the fixture, it's time to care about the physical body:</p><div><pre class="programlisting">var bodyDef = new Box2D.Dynamics.b2BodyDef;</pre></div><p>Now, we can say whether the body is static or dynamic. In our game, only the floor will be a static body. The code for this is as follows:</p><div><pre class="programlisting">if(isDynamic){
  bodyDef.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
}
else{
  bodyDef.type = Box2D.Dynamics.b2Body.b2_staticBody;
}</pre></div><p>The <code class="literal">type</code> attribute will determine whether the body will be static or dynamic. Now, we have a shape, a body, and a fixture; why don't we place this body somewhere in the world? See the following code snippet:</p><div><pre class="programlisting">bodyDef.position.Set(posX/worldScale,posY/worldScale);</pre></div><p>This can be done with the <code class="literal">position</code> property. Don't forget the pixels-to-meters conversion.</p><p>Now for the hardest part of Box2D. Most of the people trying to learn Box2D fail when it's time to attach a graphic asset to a body. The main reason is, Box2D does not allow you to attach sprites to a body. Print it with a 72-pixel font. You have to manually place sprites on the stage and manually move them as the world updates.</p><p>Let's add the sprite:</p><div><pre class="programlisting">var userSprite = cc.Sprite.create(spriteImage);
this.addChild(userSprite, 0);
userSprite.setPosition(posX,posY);</pre></div><p>This was easy because we only add a sprite in the same way we have since the start of the first chapter. Anyway, we have to somehow tell Box2D that this sprite belongs to the body we just created.</p><p>Too good! There's a <code class="literal">userData</code> property that we can use to store any kind of custom body information:</p><div><pre class="programlisting">bodyDef.userData = {
  type: type,
  asset: userSprite
}</pre></div><p>In this case, I defined <a id="id282" class="indexterm"/>an object with the sprites to be linked with and the type of body we are dealing with—in this case, it will be <code class="literal">ground</code>, according to the argument passed to the <code class="literal">addBody</code> function.</p><p>Finally, we are ready to attach the body to the world, that is, turning our body definition—<code class="literal">b2BodyDef</code> is a body definition—into a physical body:</p><div><pre class="programlisting">var body = world.CreateBody(bodyDef);
body.CreateFixture(fixtureDef);</pre></div><p>The <code class="literal">CreateBody</code> method<a id="id283" class="indexterm"/> will create a real physics body starting from a body definition, while <code class="literal">CreateFixture</code> will attach a fixture—and its shape—to a body.</p><p>Finally, we can run the game and the following image is what you should see:</p><div><img src="img/0075SOS_07_04.jpg" alt="Adding bodies to the world"/></div><p>Finally, we will <a id="id284" class="indexterm"/>have a solid ground, and moreover, a function that will allow us to create the entire totem quickly.</p><p>Let's add these lines:</p><div><pre class="programlisting">init:function () {
  this._super();
  var backgroundLayer = cc.LayerGradient.create(cc.color(0xdf,0x9f,0x83,255), cc.color(0xfa,0xf7,0x9f,255));
  this.addChild(backgroundLayer);
  var gravity = new Box2D.Common.Math.b2Vec2(0, -10)
  world = new Box2D.Dynamics.b2World(gravity, true);
  
  this.scheduleUpdate();
  this.addBody(240,10,480,20,false,"assets/ground.png","ground");
  <strong>this.addBody(204,32,24,24,true,"assets/brick1x1.png","destroyable");</strong>
  <strong>this.addBody(276,32,24,24,true,"assets/brick1x1.png",</strong>  <strong>"destroyable");</strong>
  <strong>this.addBody(240,56,96,24,true,"assets/brick4x1.png","destroyable");</strong>
  <strong>this.addBody(240,80,48,24,true,"assets/brick2x1.png","solid");</strong>
  <strong>this.addBody(228,104,72,24,true,"assets/brick3x1.png",</strong>  <strong>"destroyable");</strong>
  <strong>this.addBody(240,140,96,48,true,"assets/brick4x2.png","solid");</strong>
  <strong>this.addBody(240,188,24,48,true,"assets/totem.png","totem");</strong>
}</pre></div><p>We just have to correctly call the <code class="literal">addBody</code> function to have our totem built with each brick defined with its <a id="id285" class="indexterm"/>own graphic assets, position, size, and property.</p><p>Launch the game now:</p><div><img src="img/0075SOS_07_05.jpg" alt="Adding bodies to the world"/></div><p>That's it! Our totem is standing on the floor, ready to be destroyed.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Updating sprite position as the world changes</h1></div></div></div><p>Unfortunately, our totem is still just a bunch of static sprites. Yes, we attached them to a body, but what happens<a id="id286" class="indexterm"/> when the world changes?</p><p>Try to remove the left foot of the totem, this way:</p><div><pre class="programlisting">init:function () {
  this._super();   var backgroundLayer = cc.LayerGradient.create(cc.color(0xdf,0x9f,0x83,255), cc.color(0xfa,0xf7,0x9f,255));
  this.addChild(backgroundLayer);
  var gravity = new Box2D.Common.Math.b2Vec2(0, -10)
  world = new Box2D.Dynamics.b2World(gravity, true);
  
  this.scheduleUpdate();
  this.addBody(240,10,480,20,false,"assets/ground.png","ground");
  <strong>//this.addBody(204,32,24,24,true,"assets/brick1x1.png",</strong>  <strong>"destroyable");</strong>
  this.addBody(276,32,24,24,true,"assets/brick1x1.png","destroyable");
  this.addBody(240,56,96,24,true,"assets/brick4x1.png","destroyable");
  this.addBody(240,80,48,24,true,"assets/brick2x1.png","solid");
  this.addBody(228,104,72,24,true,"assets/brick3x1.png","destroyable");
  this.addBody(240,140,96,48,true,"assets/brick4x2.png","solid");
  this.addBody(240,188,24,48,true,"assets/totem.png","totem");
}</pre></div><p>I just commented a line; let's see what happens:</p><div><img src="img/0075SOS_07_06.jpg" alt="Updating sprite position as the world changes"/></div><p>It definitively looks wrong. The totem should fall!</p><p>This happens because we properly placed the sprites when we created the bodies but since then, the sprites' position has not been updated.</p><p>The result is the<a id="id287" class="indexterm"/> sprites remain in the same position no matter what happens to the bodies. Remember? <em>Box2D does not allow attaching sprites to a body</em>. Lesson learned.</p><p>We have to move sprites manually, in the <code class="literal">update</code> function:</p><div><pre class="programlisting">update:function(dt){
  world.Step(dt,10,10);
  <strong>for (var b = world.GetBodyList(); b; b = b.GetNext()) {</strong>
    <strong>if (b.GetUserData() != null) {</strong>
      <strong>var mySprite = b.GetUserData().asset;</strong>
      <strong>mySprite.setPosition(b.GetPosition().x * worldScale, b.GetPosition().y * worldScale);</strong>
      <strong>mySprite.setRotation(-1 * cc.radiansToDegrees (b.GetAngle()));</strong>
    <strong>}</strong>
  <strong>}</strong>
}</pre></div><p>Run the game now:</p><div><img src="img/0075SOS_07_07.jpg" alt="Updating sprite position as the world changes"/></div><p>Finally, the<a id="id288" class="indexterm"/> totem falls! Let's have a look at what happened:</p><div><pre class="programlisting">for (var b = world.GetBodyList(); b; b = b.GetNext()) {</pre></div><p>This cycle loops through all bodies placed in the world.</p><div><pre class="programlisting">if (b.GetUserData() != null) {</pre></div><p>
<code class="literal">b</code> is now our current body, and we will see whether we set something into its user data:</p><div><pre class="programlisting">var mySprite = b.GetUserData().asset;
mySprite.setPosition(b.GetPosition().x * worldScale, b.GetPosition().y * worldScale);
mySprite.setRotation(-1 * cc.radiansToDegrees (b.GetAngle()));</pre></div><p>Once we know there's something in the user data, as in this case, we know it's one of the bodies we created to build the totem or the ground. Do you remember we created an object in the user data? The <code class="literal">mySprite</code> variable will store the sprite we inserted in this object.</p><p>The <code class="literal">GetPosition</code> method returns body's position; so, we can update the sprite position—remember the conversion from meters to pixels—and <code class="literal">getAngle</code> returns body rotation.</p><p>This way <a id="id289" class="indexterm"/>we can manually update all sprites attached to Box2D world bodies.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Selecting and destroying world bodies</h1></div></div></div><p>As the name Totem Destroyer suggests, you should be able to destroy the totem. First, uncomment the previously <a id="id290" class="indexterm"/>commented line in order to give back the<a id="id291" class="indexterm"/> totem its left foot, and then we are ready to destroy bricks when the player touches/clicks them.</p><p>Everything starts with a touch, so we have to manage it by first adding the listener to the game's <code class="literal">init</code> function:</p><div><pre class="programlisting">init:function () {
  // same as before
  <strong>cc.eventManager.addListener(touchListener, this);</strong>
}</pre></div><p>Then create the <code class="literal">listener</code> variable itself:</p><div><pre class="programlisting">var touchListener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  swallowTouches: true,
  onTouchBegan: function (touch, event) {
    var worldPoint = new Box2D.Common.Math.b2Vec2(touch.getLocation().x/worldScale,touch.getLocation().y/worldScale);
    for (var b = world.GetBodyList(); b; b = b.GetNext()) {
      if (b.GetUserData() != null &amp;&amp; b.GetUserData().type=="destroyable") {
        for(var f = b.GetFixtureList();f; f=f.GetNext()){
          if(f.TestPoint(worldPoint)){
            gameLayer.removeChild(b.GetUserData().asset)
            world.DestroyBody(b);
          }
        }
      }
    }
  }
});</pre></div><p>Let's see what we added. First, we have to get click/touch coordinates and translate them into Box2D world coordinates; this means turning pixels into meters and placing coordinates into a <code class="literal">b2Vec2</code> variable:</p><div><pre class="programlisting">var worldPoint = new Box2D.Common.Math.b2Vec2(touch.getLocation().x/worldScale,touch.getLocation().y/worldScale);</pre></div><p>Then, we will loop through all bodies in the same way we do when it's time to update the sprite's' position:</p><div><pre class="programlisting">for (var b = world.GetBodyList(); b; b = b.GetNext()) {</pre></div><p>Not all bodies can be destroyed: the<a id="id292" class="indexterm"/> ground and dark bricks can't be destroyed for instance, so we have to be sure we are only trying to destroy bricks we <a id="id293" class="indexterm"/>marked with <code class="literal">destroyable</code> in their user data:</p><div><pre class="programlisting">if (b.GetUserData() != null &amp;&amp; b.GetUserData().type=="destroyable") {</pre></div><p>Once we know a brick can be destroyed, we have to loop through all its fixtures and see whether one of them contains the point the player clicked/touched. This is how we will loop through all fixtures of a body:</p><div><pre class="programlisting">for (var f = b.GetFixtureList();f; f=f.GetNext()){</pre></div><p>And once <code class="literal">f</code> represents the current texture, the <code class="literal">TestPoint</code> method will return <code class="literal">true</code> if the point passed as an argument is inside the fixture:</p><div><pre class="programlisting">if(f.TestPoint(worldPoint)){</pre></div><p>At this time, we are sure the player touched the <code class="literal">b</code> body and we can destroy it, after having removed the sprite. Remember: <em>Box2D does not allow you to attach a sprite to a body</em>. The code snippet for this is shown as follows:</p><div><pre class="programlisting">gameLayer.removeChild(b.GetUserData().asset);
world.DestroyBody(b);</pre></div><p>The <code class="literal">DestroyBody</code> method removes a body from the world.</p><p>Run the game and touch some bodies, then you will be able to destroy the light ones.</p><div><img src="img/0075SOS_07_08.jpg" alt="Selecting and destroying world bodies"/></div><p>Now the game is ready to be<a id="id294" class="indexterm"/> played we only have to check when<a id="id295" class="indexterm"/> the idol touches the ground. This is a game-over event, so it's very important.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Checking for collisions among bodies</h1></div></div></div><p>To complete the prototype, we need to check whether the idol touches the ground. The simplest way, according to what you have learned about Box2D until now, is to continuously scan through idol collisions and check whether one<a id="id296" class="indexterm"/> of the bodies it collides with is the ground.</p><p>We need to add some lines to the <code class="literal">update</code> function:</p><div><pre class="programlisting">update:function(dt){
  world.Step(dt,10,10);
  for (var b = world.GetBodyList(); b; b = b.GetNext()) {
    if (b.GetUserData() != null) {
      var mySprite = b.GetUserData().asset;
      mySprite.setPosition(b.GetPosition().x * worldScale, b.GetPosition().y * worldScale);
      mySprite.setRotation(-1 * cc.radiansToDegrees (b.GetAngle()));
      <strong>if(b.GetUserData().type=="totem"){</strong>
        <strong>for(var c = b.GetContactList(); c; c = c.m_next){</strong>
          <strong>if(c.other.GetUserData() &amp;&amp; c.other.GetUserData().type=="ground"){</strong>
            <strong>console.log("Oh no!!!!");</strong>
          <strong>}</strong>
        <strong>}</strong>
      <strong>}</strong>
    }
  }
}</pre></div><p>In the way that we looped through bodies and fixtures, we can loop through contacts using the following line of code:</p><div><pre class="programlisting">for(var c = b.GetContactList(); c; c = c.m_next){</pre></div><p>For every <code class="literal">c</code> contact, we check the body it got in contact with thanks to the <code class="literal">other</code> property; if its type is <code class="literal">ground</code>, we output a message in the console. The whole process is made only if the current body is the idol.</p><p>Run the game and let the idol touch the ground. You will see<a id="id297" class="indexterm"/> several instances of<strong> Oh no!!!!</strong> on your console log. And finally, we have a working Totem Destroyer prototype!!</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Summary</h1></div></div></div><p>Building a Totem Destroyer level was a great achievement because now you are able to build a cross-platform game like one of the most played browser games; and all thanks to Box2D.</p><p>Why don't you improve it by setting a level goal—such as <em>remove four blocks</em>—and, when this is achieved, waiting a couple of seconds to see if the idol stays in its position without falling to the ground as in the original game?</p></div></body></html>