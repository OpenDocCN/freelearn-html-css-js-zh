- en: Chapter 11. Writing a REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to optimize our CSS writing. We learned
    about the most popular architectural concepts and checked out the available CSS
    preprocessors. This chapter is about building a REST API with Node.js. We are
    going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement routing mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the incoming requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send a proper response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering REST and API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** stands for **Representational State Transfer** and it is an architectural
    principle of the Web. In most of the cases, we have resources on the server that
    need to be created, fetched, updated, or deleted. The REST APIs provide mechanisms
    to perform all these operations. Every resource has its own URI and based on the
    request method, a different action occurs. For example, let''s say that we need
    to manage the users in our social network. To retrieve information about a specific
    user, we will perform the `GET` request to the `/user/23` address, where the number,
    `23`, is the ID of the user. To update the data, we will send the `PUT` request
    to the same URL, and to delete the record, we''ll send the `DELETE` request. The
    `POST` requests are reserved to create new resources. In other words, the resources''
    management on the server happens via HTTP requests sent to carefully selected
    addresses by using the `GET`, `POST`, `PUT`, and `DELETE` methods, which are very
    often called **HTTP verbs**. A lot of companies adopt this architecture because
    it is simple, works through the HTTP protocol, and is highly scalable. There are,
    of course, different approaches such as SOAP or CORBA but we have many more rules
    to follow and the communication between the machines is very often complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: According to Wikipedia, an **Application Programming Interface** (**API**) specifies
    how some software components should interact with each other. The API is usually
    the part of our program that is visible to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build one. It's an API of a simple online books library.
    The resources are the books and they will be accessed through the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an online library – a REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development of a REST API is the same as the development of every other
    Node.js application. We need to plan it and carefully implement the different
    components one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the API parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s always good to have a plan before starting a new project. So, let''s
    define the main parts of the API server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Router**: We know that Node.js starts listening on a port and accepts an
    HTTP requests. So, we need a class that will handle them and pass the request
    to the right logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handler**: This is the place where our logic will be put in. It will process
    the request and prepare the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responder**: We also need a class that will send the result to the browser.
    Very often the API has to respond in different formats. For example, XML and,
    at the same time, JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js is very often used to build REST APIs. Also, because it is a common
    task, we have several possible approaches. There are even ready-to-use modules
    such as `rest.js` or `restify`. However, we are going to build our REST API from
    scratch because it will be much more interesting and challenging. We will start
    by running a Node.js server. Let''s create an empty directory and put the following
    code into the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we run the script with `node ./index.js`, we will be able to open `http://127.0.0.1:9000`
    and see **API response** on the screen. All the incoming requests are going through
    a function. That's the place for our router.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the API router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In almost every web-based Node.js application, the router plays one of the
    main roles. That''s because it is the entry point of the program. That''s the
    place where the URL is mapped to logic and the request is processed. The router
    for the REST API should be a little bit more advanced, because it should handle
    not only the usual `GET` and `POST` requests but also `PUT` and `DELETE`. Along
    with our `index.js`, we need another file called `router.js`. So, add the following
    code to the `router.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The module exports an object with two methods. The first one (`register`) stores
    records in the `routes` variable. The second method (`process`) will be used as
    a handler of the `createServer` method in `index.js`. The following code demonstrates
    how our router is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter of the `register` method will be the HTTP verbs as a string:
    `GET`, `POST`, `PUT`, or `DELETE`. The `route` parameter will be a regular expression
    and, the last one, a function will be called if the expression matches the current
    URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `process` method will do several things. It will run the defined regular
    expression against the current request. It will also do few more things, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the `GET` parameters from the URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching the `POST`/`PUT` parameters passed with the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting dynamic URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these mentioned things could be implemented outside the `router` variable
    but because they are common tasks and we will probably have them in several places,
    we will add them in the following code. The following code is the full code of
    the router''s `process` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an `info` object holding the data which we talked about. We cycled
    over all the routes and tried to find one which has method and regular expression
    matching. We also checked if the request method is `POST` or `PUT` and got the
    sent information. At the end, if there is no matching route, we send an empty
    string. To get the preceding code working, we need to define two variables and
    one function, which are done in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The entities, `url` and `querystring`, are native Node.js modules. The `processRequest`
    variable is needed because Node.js handles the `POST`/`PUT` parameters differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the preceding code, we are able to add routes and check if they work
    properly. For example, see the following code in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we run the server with `node ./index.js` and fire a request to `http://127.0.0.1:9000/books`.
    The result is a text `Getting all the books` on the screen, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the API router](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will also see the following output in our terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the API router](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is no sent data so the `get` and `post` properties are empty. Now, let''s
    use the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We should make sure that our API accepts the `POST` and `GET` requests properly;
    we can do that by using this route. If we send a `POST` request with the data
    `name=Node.js blueprints&author=Krasimir Tsonev` to the `http://127.0.0.1:9000/book?notification=no`
    URL, we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the API router](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is one more thing that our router does. It handles dynamic URLs. By *dynamic*,
    we mean URLs such as `/book/523/edit`, where `523` is the unique ID of the book
    and it can be something different and we want to process all requests of this
    type in one specific handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The key moment here is the regular expression. There are two capturing parentheses.
    The first one represents the ID of the book and the second one, the action that
    we want to perform. For example, `edit` or `delete`. The response of `127.0.0.1:9000/book/523/edit`
    is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the API router](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, `523` and `edit` are a part of the `match` property and we can
    get them easily. We can improve our router by adding a few additional helper methods.
    It''s a good practice to provide methods for every different type of request.
    The following code shows how these methods look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `router.register('GET', /\/book\/(.+)\/(.+)?/...`, we can now write
    `router.get(/\/book\/(.+)\/(.+)?/...`, which is a little bit better. The `all`
    function could be used if we need to handle a specific URL but don't care about
    the `request` method. The same approach is used in the Express framework, where
    we have the `get`, `post`, `put`, `delete`, and `all` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the responder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before writing the logic of our little REST API library, we need a proper responder,
    that is, a class which we will use to send the result to the browser. There is
    something really important that we need to take care of while we are talking about
    a server which works as an API. Along with the data, we have to send a proper
    status code. For example, `200` if everything is fine or `404` if the resource
    is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our responder will be saved in the `responder.js` file located in the same
    directory as `index.js` and `router.js`. The module starts with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The module requires the response object in order to send the result to the
    browser. The `code` method sets the status code. We can get the latest used route
    and transform it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of this chapter, we said that the API should be able to respond
    in different formats. We have to add a few methods in the responder to make this
    possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By adding these functions, we are actually able to serve JSON, HTML, CSS, JavaScript,
    and plain text. The class sends a header to the browser specifying the status
    code, `Content-Type` and `charset`. All the methods of the responder return the
    class itself, so we can chain them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](part0030_split_000.html#page "Chapter 3. Writing a Blog Application
    with Node.js and AngularJS"), *Writing a Blog Application with Node.js and AngularJS*,
    we used MongoDB and MySQL. We learned how to read, write, edit, and delete records
    from these databases. Let''s use MongoDB in this chapter, too. We will store our
    data in a collection named `books`. To use the database driver, we need to create
    a `package.json` file and put the following content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After running `npm install`, we will be able to connect to the MongoDB server
    by using the driver installed in the `node_modules` directory. The code that we
    need to interact with the database is the same as the one used in [Chapter 3](part0030_split_000.html#page
    "Chapter 3. Writing a Blog Application with Node.js and AngularJS"), *Writing
    a Blog Application with Node.js and AngularJS*, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `crypto` module will be used to generate a unique ID for the newly created
    records. There is a MongoDB client initialized. It is connected to the server
    and makes the `collection` variable point to the `books` collection. That's all
    we need. We can now manage records of our books.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The adding of a new book into the database should happen via the `POST` request.
    The following code is the route that will handle this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The URL to add a new book is `/book`. It can be accessed via the `POST` method.
    The expected parameters are `name` and `author`. Notice that we are setting the
    status code as `400` if any of these are missing. `400` means `Bad request`. If
    the user forgets to pass them, we should notify him or her of what exactly is
    wrong. This is really important while designing an API. The developers who use
    our services should know why they didn't get the proper response. Very often,
    the well designed APIs could be used without documentation. That's because their
    methods provide enough information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The book''s data is written in the JSON format and the answer to the browser
    is also sent in the JSON format. The following screenshot is a preview of the
    record saved in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new record](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Editing a record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement editing, we will use the `PUT` method. We will also need to define
    a dynamic route. The following code creates the route and the proper handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Along with the checks for missing `name` and `author`, we need to make sure
    that the ID that is used in the URL exists in our database. If not, a proper error
    message should be sent.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The deletion of records is really similar to the editing. We will again need
    a dynamic route. When we have the ID of the book, we can check if it really exists
    and if yes, simply remove it from the database. Checkout the following implementation
    that does the actions that we just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Displaying all the books
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is maybe the simplest API method, which we will have to implement. There
    is a query to the database and the result is directly passed to the responder.
    The following code defines a route books that fetches all the records from the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Adding a default route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should have a default route, that is, a page that will be sent if the user
    types in a wrong URL or just visits the root address of the API. In order to catch
    every type of request, we use the `all` method of the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We constructed a simple HTML markup and sent it to the user. The route's regular
    expression is just an empty string, which matches everything. We are also using
    the `.all` function, which handles any type of request. Notice that we need to
    add this route after all the others; otherwise, if it is at the start, all the
    requests will go there.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make sure that everything works, we will write a few tests covering all
    the methods mentioned in the previous sections. In [Chapter 9](part0066_split_000.html#page
    "Chapter 9. Automate Your Testing with Node.js"), *Automate Your Testing with
    Node.js*, we learned about Jasmine and Mocha test frameworks. The following test
    suite uses Jasmine. We will also need one additional module to make HTTP requests.
    The module is called `request` and we can get it using `npm install request` or
    by adding it to our `package.json` file. The following are the steps along with
    the code to test the API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first test the creation of a new database record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using the `.post` method of the module. The needed data is attached to
    a `form` property. Also, we expect to receive the JSON object containing a specific
    message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get all the books in the database, we need to perform a request to `http://127.0.0.1:9000/books`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The editing and removing operations are similar to the `POST` and `GET` requests
    except for the fact that we are passing an ID. Also, we got it from the last test
    where we fetched all the records in the collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a REST API to store information about books. Node.js
    handles such tasks well because it has easy-to-work native modules. We successfully
    covered the `GET`, `POST`, `PUT`, and `DELETE` requests that created an interface
    to manage a simple online library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and last chapter of this book, we will build a desktop application.
    We will learn how Node.js can be used not only for web projects, but for desktop
    programs too. By the end of the next chapter, we should have a working file browser
    written with Node.js.
  prefs: []
  type: TYPE_NORMAL
