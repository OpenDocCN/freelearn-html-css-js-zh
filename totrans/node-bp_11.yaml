- en: Chapter 11. Writing a REST API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。编写REST API
- en: 'In the previous chapter, we learned how to optimize our CSS writing. We learned
    about the most popular architectural concepts and checked out the available CSS
    preprocessors. This chapter is about building a REST API with Node.js. We are
    going to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何优化我们的CSS编写。我们了解了最流行的架构概念，并检查了可用的CSS预处理器。本章是关于使用Node.js构建REST API。我们将：
- en: Run a web server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Web服务器
- en: Implement routing mechanisms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现路由机制
- en: Process the incoming requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理传入的请求
- en: Send a proper response
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送适当的响应
- en: Discovering REST and API
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现REST和API
- en: '**REST** stands for **Representational State Transfer** and it is an architectural
    principle of the Web. In most of the cases, we have resources on the server that
    need to be created, fetched, updated, or deleted. The REST APIs provide mechanisms
    to perform all these operations. Every resource has its own URI and based on the
    request method, a different action occurs. For example, let''s say that we need
    to manage the users in our social network. To retrieve information about a specific
    user, we will perform the `GET` request to the `/user/23` address, where the number,
    `23`, is the ID of the user. To update the data, we will send the `PUT` request
    to the same URL, and to delete the record, we''ll send the `DELETE` request. The
    `POST` requests are reserved to create new resources. In other words, the resources''
    management on the server happens via HTTP requests sent to carefully selected
    addresses by using the `GET`, `POST`, `PUT`, and `DELETE` methods, which are very
    often called **HTTP verbs**. A lot of companies adopt this architecture because
    it is simple, works through the HTTP protocol, and is highly scalable. There are,
    of course, different approaches such as SOAP or CORBA but we have many more rules
    to follow and the communication between the machines is very often complicated.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**表示性状态转移**，它是Web的一种架构原则。在大多数情况下，我们在服务器上有资源需要创建、检索、更新或删除。REST API提供了执行所有这些操作的方法。每个资源都有自己的URI，根据请求方法，会发生不同的操作。例如，假设我们需要管理我们的社交网络中的用户。要检索特定用户的信息，我们将向`/user/23`地址执行`GET`请求，其中数字`23`是用户的ID。要更新数据，我们将向同一URL发送`PUT`请求，要删除记录，我们将发送`DELETE`请求。`POST`请求保留用于创建新资源。换句话说，服务器上的资源管理是通过使用`GET`、`POST`、`PUT`和`DELETE`方法向精心选择的地址发送HTTP请求来实现的，这些方法通常被称为**HTTP动词**。许多公司采用这种架构，因为它简单、通过HTTP协议工作，并且具有高度的可扩展性。当然，还有不同的方法，如SOAP或CORBA，但我们有更多的规则要遵循，并且机器之间的通信通常很复杂。'
- en: According to Wikipedia, an **Application Programming Interface** (**API**) specifies
    how some software components should interact with each other. The API is usually
    the part of our program that is visible to the outside world.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，**应用程序编程接口（API**）指定了某些软件组件应该如何相互交互。API通常是我们的程序对外可见的部分。
- en: In this chapter, we will build one. It's an API of a simple online books library.
    The resources are the books and they will be accessed through the REST API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个。这是一个简单的在线图书库的API。资源是书籍，它们将通过REST API进行访问。
- en: Developing an online library – a REST API
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发在线图书馆——REST API
- en: The development of a REST API is the same as the development of every other
    Node.js application. We need to plan it and carefully implement the different
    components one by one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: REST API的开发与其他Node.js应用程序的开发相同。我们需要制定计划，并逐一仔细实现不同的组件。
- en: Defining the API parts
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义API部分
- en: 'It''s always good to have a plan before starting a new project. So, let''s
    define the main parts of the API server as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始一个新项目之前有一个计划总是好的。所以，让我们定义API服务器的主要部分如下：
- en: '**Router**: We know that Node.js starts listening on a port and accepts an
    HTTP requests. So, we need a class that will handle them and pass the request
    to the right logic.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器**：我们知道Node.js从端口开始监听并接受HTTP请求。因此，我们需要一个类来处理它们并将请求传递到正确的逻辑。'
- en: '**Handler**: This is the place where our logic will be put in. It will process
    the request and prepare the response.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：这是我们将放置逻辑的地方。它将处理请求并准备响应。'
- en: '**Responder**: We also need a class that will send the result to the browser.
    Very often the API has to respond in different formats. For example, XML and,
    at the same time, JSON.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应器**：我们还需要一个类，它将结果发送到浏览器。API通常需要以不同的格式响应。例如，XML和JSON。'
- en: Writing the base
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写基础
- en: 'Node.js is very often used to build REST APIs. Also, because it is a common
    task, we have several possible approaches. There are even ready-to-use modules
    such as `rest.js` or `restify`. However, we are going to build our REST API from
    scratch because it will be much more interesting and challenging. We will start
    by running a Node.js server. Let''s create an empty directory and put the following
    code into the `index.js` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js经常被用来构建REST API。此外，因为它是一个常见任务，所以我们有几种可能的方法。甚至有现成的模块，如`rest.js`或`restify`。然而，我们将从头开始构建我们的REST
    API，因为它将更有趣、更具挑战性。我们将首先运行一个Node.js服务器。让我们创建一个空目录，并将以下代码放入`index.js`文件中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we run the script with `node ./index.js`, we will be able to open `http://127.0.0.1:9000`
    and see **API response** on the screen. All the incoming requests are going through
    a function. That's the place for our router.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`node ./index.js`运行脚本，我们就能打开`http://127.0.0.1:9000`并在屏幕上看到**API响应**。所有传入的请求都会通过一个函数。这就是我们的路由器所在的位置。
- en: Implementing the API router
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现API路由器
- en: 'In almost every web-based Node.js application, the router plays one of the
    main roles. That''s because it is the entry point of the program. That''s the
    place where the URL is mapped to logic and the request is processed. The router
    for the REST API should be a little bit more advanced, because it should handle
    not only the usual `GET` and `POST` requests but also `PUT` and `DELETE`. Along
    with our `index.js`, we need another file called `router.js`. So, add the following
    code to the `router.js` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎每个基于Web的Node.js应用程序中，路由器扮演着主要角色之一。这是因为它是程序的入口点。这是URL映射到逻辑和请求处理的地方。对于REST
    API的路由器应该稍微复杂一些，因为它不仅应该处理常见的`GET`和`POST`请求，还应该处理`PUT`和`DELETE`请求。除了我们的`index.js`，我们还需要另一个名为`router.js`的文件。因此，将以下代码添加到`router.js`文件中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The module exports an object with two methods. The first one (`register`) stores
    records in the `routes` variable. The second method (`process`) will be used as
    a handler of the `createServer` method in `index.js`. The following code demonstrates
    how our router is used:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模块导出一个包含两个方法的对象。第一个方法（`register`）将记录存储在`routes`变量中。第二个方法（`process`）将被用作`index.js`中`createServer`方法的处理器。以下代码演示了如何使用我们的路由器：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first parameter of the `register` method will be the HTTP verbs as a string:
    `GET`, `POST`, `PUT`, or `DELETE`. The `route` parameter will be a regular expression
    and, the last one, a function will be called if the expression matches the current
    URL.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`register`方法的第一参数将是HTTP动词作为字符串：`GET`、`POST`、`PUT`或`DELETE`。`route`参数将是一个正则表达式，最后一个参数，如果表达式与当前URL匹配，将调用一个函数。'
- en: 'The `process` method will do several things. It will run the defined regular
    expression against the current request. It will also do few more things, which
    are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`process`方法将执行几件事情。它将对当前请求运行定义的正则表达式。它还将做几件其他事情，如下所述：'
- en: Fetching the `GET` parameters from the URL
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从URL中获取`GET`参数
- en: Fetching the `POST`/`PUT` parameters passed with the request
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取与请求一起传递的`POST`/`PUT`参数
- en: Supporting dynamic URLs
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持动态URL
- en: 'All these mentioned things could be implemented outside the `router` variable
    but because they are common tasks and we will probably have them in several places,
    we will add them in the following code. The following code is the full code of
    the router''s `process` method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的所有这些事情都可以在`router`变量外部实现，但因为是常见任务，我们可能会在几个地方用到它们，所以我们将它们添加到以下代码中。以下代码是路由器`process`方法的完整代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is an `info` object holding the data which we talked about. We cycled
    over all the routes and tried to find one which has method and regular expression
    matching. We also checked if the request method is `POST` or `PUT` and got the
    sent information. At the end, if there is no matching route, we send an empty
    string. To get the preceding code working, we need to define two variables and
    one function, which are done in the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`info`对象持有我们讨论过的数据。我们遍历了所有路由，并尝试找到一个具有方法和正则表达式匹配的路由。我们还检查了请求方法是否为`POST`或`PUT`，并获取了发送的信息。最后，如果没有匹配的路由，我们发送一个空字符串。为了使前面的代码正常工作，我们需要定义两个变量和一个函数，这些都在以下代码中完成：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The entities, `url` and `querystring`, are native Node.js modules. The `processRequest`
    variable is needed because Node.js handles the `POST`/`PUT` parameters differently.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实体`url`和`querystring`是Node.js的本地模块。`processRequest`变量是必需的，因为Node.js以不同的方式处理`POST`/`PUT`参数。
- en: 'By using the preceding code, we are able to add routes and check if they work
    properly. For example, see the following code in the `index.js` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面的代码，我们能够添加路由并检查它们是否正常工作。例如，查看`index.js`文件中的以下代码：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we run the server with `node ./index.js` and fire a request to `http://127.0.0.1:9000/books`.
    The result is a text `Getting all the books` on the screen, as shown in the following
    screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`node ./index.js`启动服务器并向`http://127.0.0.1:9000/books`发送请求。屏幕上显示的结果是文本`获取所有书籍`，如下所示截图：
- en: '![Implementing the API router](img/00065.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![实现API路由](img/00065.jpeg)'
- en: 'You will also see the following output in our terminal:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会在我们的终端中看到以下输出：
- en: '![Implementing the API router](img/00066.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![实现API路由](img/00066.jpeg)'
- en: 'There is no sent data so the `get` and `post` properties are empty. Now, let''s
    use the following route:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发送数据，所以`get`和`post`属性是空的。现在，让我们使用以下路由：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We should make sure that our API accepts the `POST` and `GET` requests properly;
    we can do that by using this route. If we send a `POST` request with the data
    `name=Node.js blueprints&author=Krasimir Tsonev` to the `http://127.0.0.1:9000/book?notification=no`
    URL, we will get the following result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该确保我们的API正确地接受`POST`和`GET`请求；我们可以通过使用此路由来实现。如果我们向`http://127.0.0.1:9000/book?notification=no`发送包含数据`name=Node.js
    blueprints&author=Krasimir Tsonev`的`POST`请求，我们将得到以下结果：
- en: '![Implementing the API router](img/00067.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![实现API路由](img/00067.jpeg)'
- en: 'There is one more thing that our router does. It handles dynamic URLs. By *dynamic*,
    we mean URLs such as `/book/523/edit`, where `523` is the unique ID of the book
    and it can be something different and we want to process all requests of this
    type in one specific handler as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由器还有一件事要做。它处理动态URL。我们所说的“动态”是指像`/book/523/edit`这样的URL，其中`523`是书籍的唯一ID，它可以不同，我们想要在一个特定的处理器中处理所有这类请求，如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The key moment here is the regular expression. There are two capturing parentheses.
    The first one represents the ID of the book and the second one, the action that
    we want to perform. For example, `edit` or `delete`. The response of `127.0.0.1:9000/book/523/edit`
    is as shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是正则表达式。有两个捕获括号。第一个代表书籍的ID，第二个代表我们想要执行的操作，例如`edit`或`delete`。`127.0.0.1:9000/book/523/edit`的响应如下所示截图：
- en: '![Implementing the API router](img/00068.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![实现API路由](img/00068.jpeg)'
- en: 'As we can see, `523` and `edit` are a part of the `match` property and we can
    get them easily. We can improve our router by adding a few additional helper methods.
    It''s a good practice to provide methods for every different type of request.
    The following code shows how these methods look like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`523`和`edit`是`match`属性的一部分，我们可以轻松地获取它们。我们可以通过添加一些额外的辅助方法来改进我们的路由器。为每种不同类型的请求提供方法是一个好的实践。以下代码显示了这些方法的样子：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instead of `router.register('GET', /\/book\/(.+)\/(.+)?/...`, we can now write
    `router.get(/\/book\/(.+)\/(.+)?/...`, which is a little bit better. The `all`
    function could be used if we need to handle a specific URL but don't care about
    the `request` method. The same approach is used in the Express framework, where
    we have the `get`, `post`, `put`, `delete`, and `all` methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以写`router.get(/\/book\/(.+)\/(.+)?/...`，而不是`router.register('GET', /\/book\/(.+)\/(.+)?/...`，这稍微好一些。如果我们需要处理特定的URL但不关心`request`方法，可以使用`all`函数。在Express框架中，我们也有`get`、`post`、`put`、`delete`和`all`方法。
- en: Writing the responder
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写响应器
- en: Before writing the logic of our little REST API library, we need a proper responder,
    that is, a class which we will use to send the result to the browser. There is
    something really important that we need to take care of while we are talking about
    a server which works as an API. Along with the data, we have to send a proper
    status code. For example, `200` if everything is fine or `404` if the resource
    is missing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的小型REST API库的逻辑之前，我们需要一个合适的响应器，即一个我们将用来将结果发送到浏览器的类。当我们谈论一个作为API工作的服务器时，有一些非常重要的事情需要我们注意。除了数据，我们必须发送一个适当的HTTP状态码。例如，如果一切正常，则为`200`，如果资源缺失，则为`404`。
- en: 'Our responder will be saved in the `responder.js` file located in the same
    directory as `index.js` and `router.js`. The module starts with the following
    code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的响应器将被保存在与`index.js`和`router.js`相同的目录中的`responder.js`文件中。模块以以下代码开始：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The module requires the response object in order to send the result to the
    browser. The `code` method sets the status code. We can get the latest used route
    and transform it to the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块需要响应对象以便将结果发送到浏览器。`code` 方法设置状态码。我们可以获取最新使用的路由并将其转换为以下代码：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the beginning of this chapter, we said that the API should be able to respond
    in different formats. We have to add a few methods in the responder to make this
    possible:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到 API 应该能够以不同的格式响应。我们必须在响应器中添加一些方法来实现这一点：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By adding these functions, we are actually able to serve JSON, HTML, CSS, JavaScript,
    and plain text. The class sends a header to the browser specifying the status
    code, `Content-Type` and `charset`. All the methods of the responder return the
    class itself, so we can chain them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这些函数，我们实际上能够提供 JSON、HTML、CSS、JavaScript 和纯文本。类向浏览器发送一个包含状态码、`Content-Type`
    和 `charset` 的头信息。响应器的所有方法都返回类本身，因此我们可以将它们链接起来。
- en: Working with the database
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: 'In [Chapter 3](part0030_split_000.html#page "Chapter 3. Writing a Blog Application
    with Node.js and AngularJS"), *Writing a Blog Application with Node.js and AngularJS*,
    we used MongoDB and MySQL. We learned how to read, write, edit, and delete records
    from these databases. Let''s use MongoDB in this chapter, too. We will store our
    data in a collection named `books`. To use the database driver, we need to create
    a `package.json` file and put the following content in it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](part0030_split_000.html#page "第 3 章。使用 Node.js 和 AngularJS 编写博客应用程序")，*使用
    Node.js 和 AngularJS 编写博客应用程序*中，我们使用了 MongoDB 和 MySQL。我们学习了如何从这些数据库中读取、写入、编辑和删除记录。本章我们也使用
    MongoDB。我们将数据存储在名为 `books` 的集合中。为了使用数据库驱动程序，我们需要创建一个 `package.json` 文件，并在其中放入以下内容：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After running `npm install`, we will be able to connect to the MongoDB server
    by using the driver installed in the `node_modules` directory. The code that we
    need to interact with the database is the same as the one used in [Chapter 3](part0030_split_000.html#page
    "Chapter 3. Writing a Blog Application with Node.js and AngularJS"), *Writing
    a Blog Application with Node.js and AngularJS*, which is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm install` 后，我们将能够通过使用 `node_modules` 目录中安装的驱动程序连接到 MongoDB 服务器。我们需要与数据库交互的代码与
    [第 3 章](part0030_split_000.html#page "第 3 章。使用 Node.js 和 AngularJS 编写博客应用程序")，*使用
    Node.js 和 AngularJS 编写博客应用程序*中使用的代码相同，如下所示：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `crypto` module will be used to generate a unique ID for the newly created
    records. There is a MongoDB client initialized. It is connected to the server
    and makes the `collection` variable point to the `books` collection. That's all
    we need. We can now manage records of our books.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用 `crypto` 模块为新创建的记录生成一个唯一的 ID。已经初始化了一个 MongoDB 客户端。它连接到服务器，并将 `collection`
    变量指向 `books` 集合。这就是我们所需要的。现在我们可以管理我们书籍的记录了。
- en: Creating a new record
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新记录
- en: 'The adding of a new book into the database should happen via the `POST` request.
    The following code is the route that will handle this task:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将新书添加到数据库应通过 `POST` 请求进行。以下代码是处理此任务的路由：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The URL to add a new book is `/book`. It can be accessed via the `POST` method.
    The expected parameters are `name` and `author`. Notice that we are setting the
    status code as `400` if any of these are missing. `400` means `Bad request`. If
    the user forgets to pass them, we should notify him or her of what exactly is
    wrong. This is really important while designing an API. The developers who use
    our services should know why they didn't get the proper response. Very often,
    the well designed APIs could be used without documentation. That's because their
    methods provide enough information.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新书的 URL 是 `/book`。它可以通过 `POST` 方法访问。预期的参数是 `name` 和 `author`。请注意，如果这些中的任何一个缺失，我们将设置状态码为
    `400`。`400` 表示 `Bad request`。如果用户忘记传递它们，我们应该通知他们具体出了什么问题。在设计 API 时，这非常重要。使用我们服务的开发者应该知道为什么他们没有得到适当的响应。通常，设计良好的
    API 可以在没有文档的情况下使用。这是因为它们的方法提供了足够的信息。
- en: 'The book''s data is written in the JSON format and the answer to the browser
    is also sent in the JSON format. The following screenshot is a preview of the
    record saved in the database:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的数据是以 JSON 格式编写的，浏览器接收到的答案也是以 JSON 格式发送的。以下截图是数据库中保存的记录预览：
- en: '![Creating a new record](img/00069.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建新记录](img/00069.jpeg)'
- en: Editing a record
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑记录
- en: 'To implement editing, we will use the `PUT` method. We will also need to define
    a dynamic route. The following code creates the route and the proper handler:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现编辑，我们将使用 `PUT` 方法。我们还需要定义一个动态路由。以下代码创建了路由和适当的处理程序：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Along with the checks for missing `name` and `author`, we need to make sure
    that the ID that is used in the URL exists in our database. If not, a proper error
    message should be sent.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对缺失的`name`和`author`进行检查外，我们还需要确保在URL中使用的ID存在于我们的数据库中。如果不存在的，应该发送适当的错误信息。
- en: Deleting a record
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除记录
- en: 'The deletion of records is really similar to the editing. We will again need
    a dynamic route. When we have the ID of the book, we can check if it really exists
    and if yes, simply remove it from the database. Checkout the following implementation
    that does the actions that we just described:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的删除与编辑非常相似。我们还需要一个动态路由。当我们有书籍的ID时，我们可以检查它是否真的存在，如果存在，则简单地从数据库中删除它。查看以下实现，它执行了我们刚才描述的操作：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Displaying all the books
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示所有书籍
- en: 'This is maybe the simplest API method, which we will have to implement. There
    is a query to the database and the result is directly passed to the responder.
    The following code defines a route books that fetches all the records from the
    database:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最简单的API方法，我们必须要实现。这里有一个对数据库的查询，结果直接传递给响应者。以下代码定义了一个名为`books`的路由，用于从数据库中获取所有记录：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Adding a default route
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加默认路由
- en: 'We should have a default route, that is, a page that will be sent if the user
    types in a wrong URL or just visits the root address of the API. In order to catch
    every type of request, we use the `all` method of the router:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该有一个默认路由，即当用户输入错误的URL或仅访问API的根地址时将被发送的页面。为了捕获所有类型的请求，我们使用路由器的`all`方法：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We constructed a simple HTML markup and sent it to the user. The route's regular
    expression is just an empty string, which matches everything. We are also using
    the `.all` function, which handles any type of request. Notice that we need to
    add this route after all the others; otherwise, if it is at the start, all the
    requests will go there.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个简单的HTML标记并发送给用户。该路由的正则表达式只是一个空字符串，它可以匹配任何内容。我们还在使用`.all`函数，它可以处理任何类型的请求。请注意，我们需要在所有其他路由之后添加此路由；否则，如果它位于开头，所有请求都将流向那里。
- en: Testing the API
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试API
- en: 'To make sure that everything works, we will write a few tests covering all
    the methods mentioned in the previous sections. In [Chapter 9](part0066_split_000.html#page
    "Chapter 9. Automate Your Testing with Node.js"), *Automate Your Testing with
    Node.js*, we learned about Jasmine and Mocha test frameworks. The following test
    suite uses Jasmine. We will also need one additional module to make HTTP requests.
    The module is called `request` and we can get it using `npm install request` or
    by adding it to our `package.json` file. The following are the steps along with
    the code to test the API:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一切正常工作，我们将编写一些测试，涵盖上一节中提到的所有方法。在[第9章](part0066_split_000.html#page "第9章。使用Node.js自动化测试")《使用Node.js自动化测试》中，我们学习了Jasmine和Mocha测试框架。以下测试套件使用Jasmine。我们还需要一个额外的模块来执行HTTP请求。该模块称为`request`，我们可以使用`npm
    install request`或将其添加到我们的`package.json`文件中。以下是与测试API相关的步骤和代码：
- en: 'Let''s first test the creation of a new database record:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先测试创建一个新的数据库记录：
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are using the `.post` method of the module. The needed data is attached to
    a `form` property. Also, we expect to receive the JSON object containing a specific
    message.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用模块的`.post`方法。所需数据附加到`form`属性。我们还期望接收到包含特定消息的JSON对象。
- en: 'To get all the books in the database, we need to perform a request to `http://127.0.0.1:9000/books`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取数据库中的所有书籍，我们需要向`http://127.0.0.1:9000/books`发起请求：
- en: '[PRE20]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The editing and removing operations are similar to the `POST` and `GET` requests
    except for the fact that we are passing an ID. Also, we got it from the last test
    where we fetched all the records in the collection:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑和删除操作与`POST`和`GET`请求相似，只是我们传递了一个ID。而且，我们是从上一个测试中获取集合中所有记录的地方得到的：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a REST API to store information about books. Node.js
    handles such tasks well because it has easy-to-work native modules. We successfully
    covered the `GET`, `POST`, `PUT`, and `DELETE` requests that created an interface
    to manage a simple online library.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个REST API来存储有关书籍的信息。Node.js处理此类任务很好，因为它有易于工作的原生模块。我们成功覆盖了`GET`、`POST`、`PUT`和`DELETE`请求，创建了一个管理简单在线图书馆的接口。
- en: In the next and last chapter of this book, we will build a desktop application.
    We will learn how Node.js can be used not only for web projects, but for desktop
    programs too. By the end of the next chapter, we should have a working file browser
    written with Node.js.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章和最后一章中，我们将构建一个桌面应用程序。我们将学习如何使用Node.js不仅限于Web项目，还可以用于桌面程序。到下一章结束时，我们应该有一个用Node.js编写的可工作的文件浏览器。
