<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Testing Frontend Code"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Testing Frontend Code</h1></div></div></div><p>Testing JavaScript browser code has been notoriously considered hard, and although there are many complications while dealing with cross-browser testing, the most common problem is not with the testing process but rather that the application code itself is not testable.</p><p>Since every element in the browser's document is accessible globally, it is easy to write a monolithic piece of JavaScript code, which deals with the whole page. This leads to a number of problems, and the biggest one is that it is pretty hard to test.</p><p>In this chapter, we are going to get the best practices on how to write maintainable and testable browser code.</p><p>To implement the user interface, we are going to use<a id="id100" class="indexterm"/> jQuery, a well-known JavaScript library that abstracts the browser's DOM in a clean and simple API that works across different browsers.</p><p>To make the writing of the specs easier, we're going to use Jasmine jQuery, a Jasmine extension that adds new matchers to perform assertions on jQuery objects. To install it and its jQuery dependency, download the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js">https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js">https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js</a></li></ul></div><p>Save these<a id="id101" class="indexterm"/> files as <code class="literal">jasmine-jquery.js</code> and <code class="literal">jquery.js</code> respectively <a id="id102" class="indexterm"/>inside the <code class="literal">lib</code> folder, and add them to <code class="literal">SpecRunner.html</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="lib/jquery.js"&gt;&lt;/script&gt;
&lt;script src="lib/jasmine-jquery.js"&gt;&lt;/script&gt;</pre></div><p>As seen until now, we have already created separate abstractions to handle both an investment and its associated stock. Now, it is time to develop this application's user interface and achieve a good result, which is all a matter of organization and good practices.</p><p>The same principles of software engineering that we apply on the server-side code must not be left behind when writing frontend JavaScript code. It is still important to think about components and proper separation of concerns.</p><div class="section" title="Thinking in terms of components (Views)"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Thinking in terms of components (Views)</h1></div></div></div><p>We've talked about the monolithic JavaScript code bases that plague most of the Web, which that are code bases that are impossible to test. And the best way not to fall into this trap is by coding the application driven by tests.</p><p>Consider the mockup interface<a id="id103" class="indexterm"/> of our <a id="id104" class="indexterm"/>Investment Tracker application:</p><div class="mediaobject"><img src="graphics/B04138_03_01.jpg" alt="Thinking in terms of components (Views)"/><div class="caption"><p>This shows the Investment Tracker application's mockup interface</p></div></div><p>How would we go about implementing it? It is easy to see that this application has two different responsibilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One responsibility is to add an investment</li><li class="listitem" style="list-style-type: disc">Another responsibility is to list the added investments</li></ul></div><p>So, we could start by breaking this interface into two different components. To better describe them, we are going to borrow a concept from<a id="id105" class="indexterm"/> <span class="strong"><strong>MVC frameworks</strong></span>, such as <code class="literal">Backbone.js</code>, and call them <a id="id106" class="indexterm"/>
<span class="strong"><strong>Views</strong></span>.</p><p>So, here it is, at the top level of the interface, with two base components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code>: This will be <a id="id107" class="indexterm"/>responsible for creating new investments</li><li class="listitem" style="list-style-type: disc"><code class="literal">InvestmentListView</code>: This is <a id="id108" class="indexterm"/>going to be a list of all added investments</li></ul></div></div></div>
<div class="section" title="The module pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>The module pattern</h1></div></div></div><p>So, we understand<a id="id109" class="indexterm"/> how we must break up the code, but how do we organize it? Until now, we have created a file for each new function. This is a good practice, and we are going to see how we can improve on that.</p><p>Let's start by thinking about our <code class="literal">NewInvestmentView</code> component. We can follow the pattern we've used until now and create a new file, <code class="literal">NewInvestmentView.js</code>, and place it in the <code class="literal">src</code> folder, as follows:</p><div class="informalexample"><pre class="programlisting">(function ($, Investment, Stock) {
  function NewInvestmentView (params) {

  }

  this.NewInvestmentView = NewInvestmentView;
})(jQuery, Investment, Stock);</pre></div><p>You can see that this JavaScript file is more robust than the examples shown until now. We have wrapped all the <code class="literal">NewInvestmentView</code> code inside an<a id="id110" class="indexterm"/> <span class="strong"><strong>immediately invoked function expression</strong></span> (<span class="strong"><strong>IIFE</strong></span>).</p><p>It is called an IIFE because it declares a function and immediately invokes it, effectively creating new scope to declare local variables in.</p><p>A good practice is to use only local variables inside the IIFE. If it needs to use a global dependency, pass it through as a parameter. In this example, it is already passing three dependencies to the <code class="literal">NewInvestmentView</code> code: <code class="literal">jQuery</code>, <code class="literal">Investment</code>, and <code class="literal">Stock</code>.</p><p>You can see this at the function declaration:</p><div class="informalexample"><pre class="programlisting">function (<span class="strong"><strong>$, Investment, Stock</strong></span>)</pre></div><p>And immediate invocation:</p><div class="informalexample"><pre class="programlisting">})(<span class="strong"><strong>jQuery, Investment, Stock</strong></span>);</pre></div><p>The biggest advantage of this practice is that we no longer need to worry about polluting the global namespace since everything we declare inside the IIFE will be local. This makes it much harder to mess with the global scope.</p><p>If we need to make anything global, we do that explicitly by attaching it with the global object, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>this</strong></span>.NewInvestmentView = NewInvestmentView;</pre></div><p>Another advantage is the explicit dependency declaration. We know all about a file's external dependencies by glancing at its first line.</p><p>Although this practice does not have a great advantage right now (since all of the components are being exposed globally), we are going to see how to benefit from it in <a class="link" href="ch08.html" title="Chapter 8. Build Automation">Chapter 8</a>, <span class="emphasis"><em>Build Automation</em></span>.</p><p>This pattern is also known as the <a id="id111" class="indexterm"/>
<span class="strong"><strong>module pattern</strong></span>, and we will use it throughout the rest of the book (even though sometimes it is omitted for simplification purposes).</p></div>
<div class="section" title="Using HTML fixtures"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Using HTML fixtures</h1></div></div></div><p>Continuing with the <a id="id112" class="indexterm"/>development of the <code class="literal">NewInvestmentView</code> component, we can write some basic acceptance criteria, such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should allow the input of the stock symbol</li><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should allow the input of shares</li><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should allow the input of the share price</li></ul></div><p>There are many more, but this is a good start.</p><p>Create a new spec file for this component in the new file <code class="literal">NewInvestmentViewSpec.js</code> inside the <code class="literal">spec</code> folder, and we can start to translate those specs, as follows:</p><div class="informalexample"><pre class="programlisting">describe("NewInvestmentView", function() {
  it("should allow the input of the stock symbol", function() {
  });

  it("should allow the input of shares", function() {
  });

  it("should allow the input of the share price", function() {
  });
});</pre></div><p>However, before we can start to implement these, we must first understand the concept of <span class="strong"><strong>HTML fixtures</strong></span>.</p><p>Test fixtures provide the base state in which the tests run. It could be a class instantiation, the definition of an object, or a piece of HTML. In other words, to test JavaScript code that handles a form submission, we need to have the form available when running the tests. The HTML code containing the form is an HTML fixture.</p><p>One way to handle this requirement is to manually append the required DOM element inside a setup function, as follows:</p><div class="informalexample"><pre class="programlisting">beforeEach(function() {
  $('body').append('&lt;form id="my-form"&gt;&lt;/form&gt;');
});</pre></div><p>Then, remove it during teardown, as follows:</p><div class="informalexample"><pre class="programlisting">afterEach(function() {
  $('#my-form').remove();
});</pre></div><p>Otherwise, the spec<a id="id113" class="indexterm"/> would append a lot of garbage inside the document, and it could interfere with the results of other specs.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>It is important to know that specs should be independent, and that they can be run in any particular order. So, as a rule, treat specs completely in isolation from each other.</p></div></div><p>A better approach is to have a container in the document where we always put the HTML fixtures, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div id="html-fixtures"&gt;
&lt;/div&gt;</pre></div><p>Change the code to the following:</p><div class="informalexample"><pre class="programlisting">beforeEach(function() {
  <span class="strong"><strong>$('#html-fixtures').html('&lt;form id="my-form"&gt;&lt;/form&gt;');</strong></span>
});</pre></div><p>That way, the next time a spec runs, it automatically overwrites the previous fixture with its own.</p><p>But, this can soon escalate into an incomprehensible mess as the fixtures get more complex:</p><div class="informalexample"><pre class="programlisting">beforeEach(function() {
  $('#html-fixtures').html('&lt;form id="new-investment"&gt;&lt;h1&gt;New  investment&lt;/h1&gt;&lt;label&gt;Symbol:&lt;input type="text" class="new-investment-stock-symbol" name="stockSymbol"  value=""&gt;&lt;/label&gt;&lt;input type="submit" name="add"  value="Add"&gt;&lt;/form&gt;');
});</pre></div><p>Wouldn't it be great if this fixture could be loaded from an external file? That is exactly what the Jasmine jQuery extension does with its <span class="strong"><strong>HTML fixture</strong></span> module.</p><p>We can place that HTML code in an external file and load it in the document with a simple call to <code class="literal">loadFixtures</code>, passing the fixture file path, as follows:</p><div class="informalexample"><pre class="programlisting">beforeEach(function() {
  <span class="strong"><strong>loadFixtures('MyFixture.html');</strong></span>
});</pre></div><p>By default, the extension looks for files inside the <code class="literal">spec/javascripts/fixtures</code> folder (for the previous example, it would be <code class="literal">spec/javascripts/fixtures/MyFixture.html</code>) and loads its content inside a container, as<a id="id114" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">&lt;div id="jasmine-fixtures"&gt;
  &lt;form id="new-investment"&gt;
    &lt;h1&gt;New investment&lt;/h1&gt;
    &lt;label&gt;
      Symbol:
      &lt;input type="text" class="new-investment-stock-symbol" name="stockSymbol" value=""&gt;
    &lt;/label&gt;
    &lt;input type="submit" name="add" value="Add"&gt;
  &lt;/form&gt;
&lt;/div&gt;</pre></div><p>We can also use another of the extension's global functions to recreate the first example. The <code class="literal">setFixtures(html)</code> function accepts a parameter with the content to be placed in the container:</p><div class="informalexample"><pre class="programlisting">beforeEach(function() {
  <span class="strong"><strong>setFixtures('&lt;form id="my-form"&gt;&lt;/form&gt;');</strong></span>
});</pre></div><p>The other available<a id="id115" class="indexterm"/> functions are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">appendLoadFixtures(fixtureUrl[, fixtureUrl, …])</code>: Instead of overwriting the content of the fixture container, this appends it</li><li class="listitem" style="list-style-type: disc"><code class="literal">readFixtures(fixtureUrl[, fixtureUrl, …])</code>: This reads a fixture container's content, but instead of appending it to the document, it returns a string with its contents</li><li class="listitem" style="list-style-type: disc"><code class="literal">appendSetFixtures(html)</code>: This is the same as <code class="literal">appendLoadFixtures</code> but with an HTML string instead of a file</li></ul></div><p>The Jasmine jQuery fixture module caches each file, so we can load the same fixture multiple times without penalty at the test suite's speed.</p><p>It loads the fixtures using AJAX, and sometimes, a test might want to modify the inner workings of JavaScript or jQuery AJAX, as we will see in <a class="link" href="ch06.html" title="Chapter 6. Light Speed Unit Testing">Chapter 6</a>, <span class="emphasis"><em>Light Speed Unit Testing</em></span>, which would break the loading of a fixture. A workaround for this issue is to preload the required fixtures on the cache using the <code class="literal">preloadFixtures()</code> function.</p><p>The <code class="literal">preloadFixtures(fixtureUrl[, fixtureUrl, …])</code> function loads one or more files in the cache without appending them to the document.</p><p>There is an issue, though, while using HTML. Jasmine jQuery loads the HTML fixtures using AJAX, but because of the <a id="id116" class="indexterm"/>
<span class="strong"><strong>same origin policy</strong></span> (<span class="strong"><strong>SOP</strong></span>), modern browsers will block all AJAX requests when<a id="id117" class="indexterm"/> opening the <code class="literal">SpecRunner.html</code> with a <code class="literal">file://</code> protocol.</p><p>A solution to this problem is to serve the spec runner through an HTTP server, as described in <a class="link" href="ch04.html" title="Chapter 4. Asynchronous Testing – AJAX">Chapter 4</a>, <span class="emphasis"><em>Asynchronous Testing – AJAX</em></span>.</p><p>For now, there is a workaround available in Chrome through the <span class="strong"><strong>command-line interface</strong></span> (<span class="strong"><strong>CLI</strong></span>)<a id="id118" class="indexterm"/> argument <code class="literal">--allow-file-access-from-files</code>.</p><p>As an example, in Mac OS X, it would require the following command in bash to open Chrome with this flag:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ open "Google Chrome.app" --args --allow-file-access-from-files</strong></span>
</pre></div><p>More details on this issue can be seen at the <a id="id119" class="indexterm"/>GitHub ticket <a class="ulink" href="https://github.com/velesin/jasmine-jquery/issues/4">https://github.com/velesin/jasmine-jquery/issues/4</a>.</p><p>Coming back to the <code class="literal">NewInvestmentView</code> component, we can start the development of the spec with the help of this HTML fixture plugin.</p><p>Create a folder named <code class="literal">fixtures</code> inside the <code class="literal">spec</code> folder. Based on the mockup interface, we can create a new HTML fixture called <code class="literal">NewInvestmentView.html</code> inside the <code class="literal">fixtures</code> folder, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;form id="new-investment"&gt;
  &lt;h1&gt;New investment&lt;/h1&gt;
  &lt;label&gt;
    Symbol:
    &lt;input type="text" class="new-investment-stock-symbol" name="stockSymbol" value=""&gt;
  &lt;/label&gt;
  &lt;label&gt;
    Shares:
    &lt;input type="number" class="new-investment-shares" name="shares" value="0"&gt;
  &lt;/label&gt;
  &lt;label&gt;
    Share price:
    &lt;input type="number" class="new-investment-share-price" name="sharePrice" value="0"&gt;
  &lt;/label&gt;
  &lt;input type="submit" name="add" value="Add"&gt;
&lt;/form&gt;</pre></div><p>This is an HTML fixture because it would otherwise be rendered by a server and the JavaScript code would simply attach to it and add behavior.</p><p>Because we are not saving this fixture at the plugin's default path, we need to add a new configuration at the end of the <code class="literal">SpecHelper.js</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">jasmine.getFixtures().fixturesPath = 'spec/fixtures';</pre></div><p>In the <code class="literal">NewInvestmentSpec.js</code> file, add a call to load the fixture:</p><div class="informalexample"><pre class="programlisting">describe("NewInvestmentView", function() {
  <span class="strong"><strong>beforeEach(function() {</strong></span>
    <span class="strong"><strong>loadFixtures('NewInvestmentView.html');</strong></span>
  <span class="strong"><strong>});</strong></span>
});</pre></div><p>And finally, add both the<a id="id120" class="indexterm"/> spec and the source to the runner after the <code class="literal">Stock.js</code> and <code class="literal">Investment.js</code> files are added, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="src/NewInvestmentView.js"&gt;&lt;/script&gt;
&lt;script src="spec/NewInvestmentViewSpec.js"&gt;&lt;/script&gt;</pre></div></div>
<div class="section" title="Basic View coding rules"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Basic View coding rules</h1></div></div></div><p>Now, it is time to start <a id="id121" class="indexterm"/>coding the first View component. To help us through the process, we are going to lay two basic rules for View coding happiness:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The View should encapsulate a DOM element</li><li class="listitem" style="list-style-type: disc">Integrate Views with observers</li></ul></div><p>So, let's see how they work individually.</p><div class="section" title="The View should encapsulate a DOM element"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec10"/>The View should encapsulate a DOM element</h2></div></div></div><p>As mentioned earlier, a View <a id="id122" class="indexterm"/>is the behavior associated with a DOM element, so it makes sense to have this element related to the View. A good pattern is to pass a CSS <code class="literal">selector</code> in the View instantiation that indicates the element to which it should refer. Here is the spec for the <code class="literal">NewInvestmentView</code> component:</p><div class="informalexample"><pre class="programlisting">describe("NewInvestmentView", function() {
  <span class="strong"><strong>var view;</strong></span>
  beforeEach(function() {
    loadFixtures('NewInvestmentView.html');
    <span class="strong"><strong>view = new NewInvestmentView({</strong></span>
      <span class="strong"><strong>selector: '#new-investment'</strong></span>
    <span class="strong"><strong>});</strong></span>
  });
});</pre></div><p>In the constructor function at the NewInvestmentView.js file, it uses jQuery to get the element for this selector and to store it in an instance variable <code class="literal">$element</code> (source), as follows:</p><div class="informalexample"><pre class="programlisting">function NewInvestmentView (params) {
  <span class="strong"><strong>this.$element = $(params.selector);</strong></span>
}</pre></div><p>To make sure this code works, we should write the following test for it in the <code class="literal">NewInvestmentViewSpec.js</code> file:</p><div class="informalexample"><pre class="programlisting">it("should expose a property with its DOM element", function() {
  expect(view.$element).toExist();
});</pre></div><p>The <code class="literal">toExist</code> matcher<a id="id123" class="indexterm"/> is a custom matcher provided by the Jasmine jQuery extension to check whether an element exists in the document. It validates the existence of the property on the JavaScript object and also the successful association with the DOM element.</p><p>Passing the <code class="literal">selector</code> pattern to the View allows it to be instantiated multiple times to different elements on the document.</p><p>Another advantage of having an explicit association is knowing that this View is not changing anything else on the document, as we will see next.</p><p>A View is the behavior associated with a DOM element, so it shouldn't be messing around everywhere on the page. It should only change or access the element associated with it.</p><p>To demonstrate this concept, let's implement another acceptance criterion regarding the default state of the View, as follows:</p><div class="informalexample"><pre class="programlisting">it("should have an empty stock symbol", function() {
  expect(view.getSymbolInput()).toHaveValue('');
});</pre></div><p>A naive implementation of the <code class="literal">getSymbolInput</code> method might use a global jQuery lookup to find the input and return its value:</p><div class="informalexample"><pre class="programlisting">NewInvestmentView.prototype = {
  getSymbolInput: function () {
    return <span class="strong"><strong>$('.new-investment-stock-symbol')</strong></span>
  }
};</pre></div><p>However, that could lead to a problem; if there is another input with that class name somewhere else in the document, it might get the wrong result.</p><p>A better approach is to use the View's associated element to perform a scoped lookup, as follows:</p><div class="informalexample"><pre class="programlisting">NewInvestmentView.prototype = {
  getSymbolInput: function () {
    return <span class="strong"><strong>this.$element.find('.new-investment-stock-symbol')</strong></span>
  }
};</pre></div><p>The <code class="literal">find</code> function will <a id="id124" class="indexterm"/>only look for elements that are children of <code class="literal">this.$element</code>. It is as if <code class="literal">this.$element</code> represents the entire document for the View.</p><p>Since we will use this pattern everywhere inside the View code, we can create a function and use it instead, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">NewInvestmentView.prototype = {
  <span class="strong"><strong>$: function () {</strong></span>
    <span class="strong"><strong>return this.$element.find.apply(this.$element, arguments);</strong></span>
  <span class="strong"><strong>}</strong></span>,
  getSymbolInput: function () {
    return <span class="strong"><strong>this.$('.new-investment-stock-symbol')</strong></span>
  }
};</pre></div><p>Now let's suppose that from somewhere else in the application, we want to change the value of a <code class="literal">NewInvestmentView</code> form input. We know its class name, so it could be as simple as this:</p><div class="informalexample"><pre class="programlisting">$('.new-investment-stock-symbol').val('from outside the view');</pre></div><p>However, that simplicity hides a serious problem of encapsulation. This one line of code is creating a coupling with what should be an implementation detail of <code class="literal">NewInvestmentView</code>.</p><p>If another developer changes <code class="literal">NewInvestmentView</code>, renaming the input class name from <code class="literal">.new-investment-stock-symbol</code> to <code class="literal">.new-investment-symbol</code>, that one line would be broken.</p><p>To fix this, the developer would need to look at the entire code base for references to that class name.</p><p>A much safer approach is to respect the View and use its APIs, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">newInvestmentView.setSymbol('from outside the view');</pre></div><p>When implemented, that would look like the following:</p><div class="informalexample"><pre class="programlisting">NewInvestmentView.prototype.setSymbol = function(value) {
  this.$('.new-investment-stock-symbol').val(value);
};</pre></div><p>That way, when the code gets refactored, there is only one point to perform the change—inside the <code class="literal">NewInvestmentView</code> implementation.</p><p>Since there is no <a id="id125" class="indexterm"/>sandboxing in the browser's document, which means that from anywhere in the JavaScript code, we can make a change anywhere in the document, there is not much that we can do, besides good practice, to prevent these mistakes.</p></div><div class="section" title="Integrating Views with observers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Integrating Views with observers</h2></div></div></div><p>Following the<a id="id126" class="indexterm"/> development of the Investment Tracker application, we<a id="id127" class="indexterm"/> would eventually need to implement the list of investments. But how would you go about integrating <code class="literal">NewInvestmentView</code> and <code class="literal">InvestmentListView</code>?</p><p>You could write an acceptance criterion for <code class="literal">NewInvestmentView</code>, as follows:</p><p>Given the new investment View, when its add button is clicked, then it should add an investment to the list of investments.</p><p>This is very straightforward thinking, and you can see by the writing that we are creating a direct relationship between the two Views. Translating this into a spec clarifies this perception, as follows:</p><div class="informalexample"><pre class="programlisting">describe("NewInvestmentView", function() {
  beforeEach(function() {
    loadFixtures('NewInvestmentView.html');
    <span class="strong"><strong>appendLoadFixtures('InvestmentListView.html');</strong></span>

    <span class="strong"><strong>listView = new InvestmentListView({</strong></span>
      <span class="strong"><strong>id: 'investment-list'</strong></span>
    <span class="strong"><strong>});</strong></span>

    view = new NewInvestmentView({
      id: 'new-investment',
      <span class="strong"><strong>listView: listView</strong></span>
    });
  });

  describe("when its add button is clicked", function() {
    beforeEach(function() {
      // fill form inputs
      // simulate the clicking of the button
    });

    it("should add the investment to the list", function() {
      expect(<span class="strong"><strong>listView.count()</strong></span>).toEqual(1);
    });
  });
});</pre></div><p>This solution creates a dependency between the two Views. The <code class="literal">NewInvestmentView</code> constructor now receives an instance of <code class="literal">InvestmentListView</code> as its <code class="literal">listView</code> parameter.</p><p>On its<a id="id128" class="indexterm"/> implementation, <code class="literal">NewInvestmentView</code> <a id="id129" class="indexterm"/>calls the <code class="literal">addInvestment</code> method of the <code class="literal">listView</code> object when its form is submitted:</p><div class="informalexample"><pre class="programlisting">function NewInvestmentView (params) {
  <span class="strong"><strong>this.listView = params.listView;</strong></span>
  
  this.$element.on('submit', function () {
    <span class="strong"><strong>this.listView.addInvestment(/* new investment */);</strong></span>
  }.bind(this));
}</pre></div><p>To better clarify how this code works, here is a diagram of how the integration is done:</p><div class="mediaobject"><img src="graphics/B04138_03_02.jpg" alt="Integrating Views with observers"/><div class="caption"><p>This shows a direct relationship between the two Views</p></div></div><p>Although very simple, this solution introduces a number of architectural problems. The first, and most obvious, is the increased complexity of the <code class="literal">NewInvestmentView</code> specs.</p><p>Secondly, it makes evolving these components even more difficult due to the tight coupling.</p><p>To better clarify this last problem, imagine that in the future, we want to list investments in a table too. This would impose a change in <code class="literal">NewInvestmentView</code> to support both the list and table Views, as follows:</p><div class="informalexample"><pre class="programlisting">function NewInvestmentView (params) {
  this.listView = params.listView;
  <span class="strong"><strong>this.tableView = params.tableView;</strong></span>
  
  this.$element.on('submit', function () {
    this.listView.addInvestment(/* new investment */);
    <span class="strong"><strong>this.tableView.addInvestment(/* new investment */);</strong></span>
  }.bind(this));
}</pre></div><p>Rethinking on the acceptance criterion, we can get into a much better, future-proof solution. Let's rewrite it as:</p><p>Given the Investment Tracker application, when a new investment is created, then it should add the investment to the list of investments.</p><p>We can see by<a id="id130" class="indexterm"/> the acceptance criterion that it has introduced a new subject<a id="id131" class="indexterm"/> to be tested: Investment Tracker. This implies a new source and spec file. After creating both the files accordingly and adding them to the runner, we can write this acceptance criterion as a spec, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">describe("InvestmentTracker", function() {
  beforeEach(function() {
    loadFixtures('NewInvestmentView.html');
    appendLoadFixtures('InvestmentListView.html');

    listView = new InvestmentListView({
      id: 'investment-list'
    });

    newView = new NewInvestmentView({
      id: 'new-investment'
    });

    application = new InvestmentTracker({
      listView: listView,
      newView: newView
    });
  });

  describe("when a new investment is created", function() {
    beforeEach(function() {
      // fill form inputs
      newView.create();
    });

    it("should add the investment to the list", function() {
      expect(listView.count()).toEqual(1);
    });
  });
});</pre></div><p>We can see the same setup code that once was inside the <code class="literal">NewInvestmentView</code> spec. It loads the fixtures required by both Views, instantiates both <code class="literal">InvestmentListView</code> and <code class="literal">NewInvestmentView</code>, and creates a new instance of <code class="literal">InvestmentTracker</code>, passing both Views as parameters.</p><p>Later on, while <a id="id132" class="indexterm"/>describing the behavior <code class="literal">when a new investment is created</code>, we can see the function call to the <code class="literal">newView.create</code> function to create a new<a id="id133" class="indexterm"/> investment.</p><p>Later, it checks that a new item was added to the <code class="literal">listView</code> object by checking that <code class="literal">listView.count()</code> is equal to <code class="literal">1</code>.</p><p>But how does the integration happen? We can see that by looking at the <code class="literal">InvestmentTracker</code> implementation:</p><div class="informalexample"><pre class="programlisting">function InvestmentTracker (params) {
  this.listView = params.listView;
  this.newView = params.newView;

  this.newView.onCreate(function (investment) {
    this.listView.addInvestment(investment);
  }.bind(this));
}</pre></div><p>It uses the <code class="literal">onCreate</code> function to register an observer function as a callback at <code class="literal">newView</code>. This observer function will be invoked later when a new investment is created.</p><p>The implementation inside <code class="literal">NewInvestmentView</code> is quite simple. The <code class="literal">onCreate</code> method stores the <code class="literal">callback</code> parameter as an attribute of the object, as follows:</p><div class="informalexample"><pre class="programlisting">NewInvestmentView.prototype.onCreate = function(callback) {
  this._callback = callback;
};</pre></div><p>The naming convention of the <code class="literal">_callback</code> attribute might sound strange, but it is a good convention to indicate it as a private member.</p><p>Although the prepended underline character won't actually change the visibility of the attribute, it at least informs a user of this object that the <code class="literal">_callback</code> attribute might change or even be removed in the future.</p><p>Later, when the <code class="literal">create</code> method is invoked, it invokes <code class="literal">_callback</code>, passing the new investment as a parameter, as follows:</p><div class="informalexample"><pre class="programlisting">NewInvestmentView.prototype.create = function() {
  this._callback(/* new investment */);
};</pre></div><p>A more complete implementation would need to allow multiple calls to <code class="literal">onCreate</code>, storing every passed callback.</p><p>Here is the<a id="id134" class="indexterm"/> solution illustrated for better understanding:</p><div class="mediaobject"><img src="graphics/B04138_03_03.jpg" alt="Integrating Views with observers"/><div class="caption"><p>Using callbacks to integrate the two Views</p></div></div><p>Later, in <a class="link" href="ch07.html" title="Chapter 7. Testing React Applications">Chapter 7</a>, <span class="emphasis"><em>Testing React.js Applications</em></span>, we will see how the implementation of this <code class="literal">NewInvestmentView</code> spec <a id="id135" class="indexterm"/>turned out to be.</p></div></div>
<div class="section" title="Testing Views with jQuery matchers"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Testing Views with jQuery matchers</h1></div></div></div><p>Besides its HTML <a id="id136" class="indexterm"/>fixture module, the Jasmine jQuery extension <a id="id137" class="indexterm"/>comes with a set of custom matchers, which help in writing expectations with the DOM elements.</p><p>The biggest advantage of using these custom matchers, as demonstrated, is that they generate better error messages. So, although we can write all specs without using any of these matchers, it would get us much more useful information when an error happens if we used the matchers.</p><p>To better understand this advantage, we can revisit the example of the <code class="literal">should expose a property with its DOM element</code> spec. There, it uses the <code class="literal">toExist</code> matcher:</p><div class="informalexample"><pre class="programlisting">it("should expose a property with its DOM element", function() {
  <span class="strong"><strong>expect(view.$element).toExist();</strong></span>
});</pre></div><p>If this spec fails, we get a nice error message, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04138_03_04.jpg" alt="Testing Views with jQuery matchers"/><div class="caption"><p>This shows a nice custom matcher error message</p></div></div><p>Now, we rewrite this spec without the custom matcher (still making the same validation):</p><div class="informalexample"><pre class="programlisting">it("should expose a property with its DOM element", function() {
  <span class="strong"><strong>expect($(document).find(view.$element).length).toBeGreaterThan(0);</strong></span>
});</pre></div><p>This time, the error <a id="id138" class="indexterm"/>message<a id="id139" class="indexterm"/> gets less informative:</p><div class="mediaobject"><img src="graphics/B04138_03_05.jpg" alt="Testing Views with jQuery matchers"/><div class="caption"><p>Upon reading the error, we can't understand what it is truly testing</p></div></div><p>So, use these matchers whenever you can to get better error messages. Let's go over some of the available custom matchers, demonstrated by example, with these acceptance criteria of the <code class="literal">NewInvestmentView</code> class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should allow the input of the stock symbol</li><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should allow the input of shares</li><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should allow the input of the share price</li><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should have an empty stock symbol</li><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should have its shares' value at zero</li><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should have its share price value at zero</li><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should have its stock symbol input on focus</li><li class="listitem" style="list-style-type: disc"><code class="literal">NewInvestmentView</code> should not allow to add</li></ul></div><p>It is important that you understand that these next examples, although useful to demonstrate how the Jasmine jQuery matchers work, are not really testing any JavaScript code but only the <a id="id140" class="indexterm"/>HTML elements that were loaded by the HTML <a id="id141" class="indexterm"/>fixture module.</p><div class="section" title="The toBeMatchedBy jQuery matcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>The toBeMatchedBy jQuery matcher</h2></div></div></div><p>This matcher<a id="id142" class="indexterm"/> checks whether the element matches the passed <a id="id143" class="indexterm"/>CSS selector, as follows:</p><div class="informalexample"><pre class="programlisting">it("should allow the input of the stock symbol", function() {
  expect(view.$element.find('.new-investment-stock-symbol')).<span class="strong"><strong>toBeMatchedBy</strong></span>('input[type=text]');
});</pre></div></div><div class="section" title="The toContainHtml jQuery matcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>The toContainHtml jQuery matcher</h2></div></div></div><p>This matcher checks whether <a id="id144" class="indexterm"/>the content of the element matches the passed <a id="id145" class="indexterm"/>HTML, as follows:</p><div class="informalexample"><pre class="programlisting">it("should allow the input of shares", function() {
  expect(view.$element).<span class="strong"><strong>toContainHtml</strong></span>('&lt;input type="number" class="new-investment-shares" name="shares" value="0"&gt;');
});</pre></div></div><div class="section" title="The toContainElement jQuery matcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>The toContainElement jQuery matcher</h2></div></div></div><p>This matcher checks<a id="id146" class="indexterm"/> whether the element contains any <a id="id147" class="indexterm"/>child element matching the passed CSS selector, as follows</p><div class="informalexample"><pre class="programlisting">it("should allow the input of the share price", function() {
  expect(view.$element).<span class="strong"><strong>toContainElement</strong></span>('input[type=number].new-investment-share-price');
});</pre></div></div><div class="section" title="The toHaveValue jQuery matcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>The toHaveValue jQuery matcher</h2></div></div></div><p>Only valid for inputs, this<a id="id148" class="indexterm"/> validates the expected value against the<a id="id149" class="indexterm"/> element's value attribute with the following code:</p><div class="informalexample"><pre class="programlisting">it("should have an empty stock symbol", function() {
  expect(view.$element.find('.new-investment-stock-symbol')).<span class="strong"><strong>toHaveValue</strong></span>('');
});

it("should have its shares value to zero", function() {
  expect(view.$element.find('.new-investment-shares')).<span class="strong"><strong>toHaveValue</strong></span>('0');
});</pre></div></div><div class="section" title="The toHaveAttr jQuery matcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>The toHaveAttr jQuery matcher</h2></div></div></div><p>This matcher<a id="id150" class="indexterm"/> tests whether<a id="id151" class="indexterm"/> the element has any attribute with the name and value specified. The following example shows how to use this matcher to test an input for its value attribute, an expectation that could have been written with the <code class="literal">toHaveValue</code> matcher:</p><div class="informalexample"><pre class="programlisting">it("should have its share price value to zero", function() {
  expect(view.$element.find('.new-investment-share-price')).<span class="strong"><strong>toHaveAttr</strong></span>('value', '0');
});</pre></div></div><div class="section" title="The toBeFocused jQuery matcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>The toBeFocused jQuery matcher</h2></div></div></div><p>The following code<a id="id152" class="indexterm"/> illustrates how the matcher checks whether<a id="id153" class="indexterm"/> the input element is focused:</p><div class="informalexample"><pre class="programlisting">it("should have its stock symbol input on focus", function() {
 expect(view.$element.find('.new-investment-stock-symbol')).<span class="strong"><strong>toBeFocused</strong></span>();
});</pre></div></div><div class="section" title="The toBeDisabled jQuery matcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>The toBeDisabled jQuery matcher</h2></div></div></div><p>This matcher checks<a id="id154" class="indexterm"/> whether the element is disabled with the following<a id="id155" class="indexterm"/> code:</p><div class="informalexample"><pre class="programlisting">function itShouldNotAllowToAdd () {
 it("should not allow to add", function() {
  expect(view.$element.find('input[type=submit]')).<span class="strong"><strong>toBeDisabled</strong></span>();
});</pre></div></div><div class="section" title="More matchers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>More matchers</h2></div></div></div><p>The extension has many more available <a id="id156" class="indexterm"/>matchers; make sure to check the documentation of the project at <a class="ulink" href="https://github.com/velesin/jasmine-jquery#jquery-matchers">https://github.com/velesin/jasmine-jquery#jquery-matchers</a>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, you learned how testing can become so much easier once you drive the application development by tests. You saw how to use the module pattern to better organize the project code and how the View pattern can help create a more maintainable browser code.</p><p>You learned how to use HTML fixtures, making your specs much more readable and understandable. I also showed you how to test code that interacts with the browser's DOM by the use of custom jQuery matchers.</p><p>In the next chapter, we will go a step further and start testing server integration and asynchronous code.</p></div></body></html>