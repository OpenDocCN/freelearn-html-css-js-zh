<html><head></head><body>
		<div id="_idContainer106">
			<h1 id="_idParaDest-167" class="chapter-number"><a id="_idTextAnchor168"/>9</h1>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor169"/>Database Manipulation in Microservices with Node.js</h1>
			<p>When working with microservices architecture and Node.js, databases play a crucial role in storing and retrieving data for <span class="No-Break">each service.</span></p>
			<p>We’ll start this chapter by understanding how to work with databases in microservices with Node.js. This involves many concepts and tools, such as database types, database connection, service-specific databases, data models and schemas, API endpoints, error handling, transactions and atomicity, caching, security, testing, monitoring, and logging. Manipulating data in microservices also involves performing <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations <a id="_idIndexMarker647"/>on databases or data storage systems. Remember to follow best practices for data security, such as input validation, data encryption, and protecting sensitive data, based on the requirements of your microservices and <span class="No-Break">compliance standards.</span></p>
			<p>By the end of this chapter, you will have learned how to manipulate databases in microservices and choose the right database for each <span class="No-Break">specific service.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Choosing the right database and <span class="No-Break">database connections</span></li>
				<li>Data models and schemas and <span class="No-Break">CRUD operations</span></li>
				<li>Transactions and <span class="No-Break">data validation</span></li>
				<li>Error handling <span class="No-Break">and optimizations</span></li>
				<li><span class="No-Break">Testing</span></li>
			</ul>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor170"/>Choosing the right database and database connections</h1>
			<p>In this section, we’re <a id="_idIndexMarker648"/>going to show you how to select a database or data storage system that aligns with your microservice requirements and establish connections to your chosen database from your <span class="No-Break">Node.js microservice.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/>Choosing the right database</h2>
			<p><strong class="bold">Choosing the right database</strong> for your application is an important decision that can affect the performance, scalability, and maintainability of your system. There are many factors to consider when selecting a database, such as the type, size, and structure of your data, the expected workload and concurrency of your application, the availability and consistency requirements of your system, the budget and resources of your project, and the programming languages and frameworks that <span class="No-Break">you use.</span></p>
			<p>Here are the key steps for choosing the <span class="No-Break">right database:</span></p>
			<ol>
				<li><strong class="bold">Data model complexity</strong>: Choose <a id="_idIndexMarker649"/>relational databases <a id="_idIndexMarker650"/>such as <strong class="bold">MySQL</strong> or <strong class="bold">PostgreSQL</strong> for<a id="_idIndexMarker651"/> complex relationships and structured data. Choose NoSQL databases <a id="_idIndexMarker652"/>such as <strong class="bold">MongoDB</strong> or <strong class="bold">Cassandra</strong> for <a id="_idIndexMarker653"/>flexible, semi-structured, or unstructured data. NoSQL databases are suitable for <strong class="bold">handling large volumes of data with </strong><span class="No-Break"><strong class="bold">varying structures.</strong></span></li>
				<li><strong class="bold">Scalability requirements</strong>: If you <a id="_idIndexMarker654"/>need to scale your microservices horizontally (across multiple servers or containers), consider NoSQL databases such as MongoDB, Cassandra, or <strong class="bold">Amazon DynamoDB</strong>, which <a id="_idIndexMarker655"/>are designed for seamless horizontal scaling. For applications where vertical scaling (adding more resources to a single server) is sufficient, SQL databases can handle <span class="No-Break">considerable loads.</span></li>
				<li><strong class="bold">Consistency requirements</strong>: Consider<a id="_idIndexMarker656"/> whether your application requires strong data consistency. ACID transactions are a way of ensuring the reliability and consistency of database operations. They have four key properties: Atomicity, Consistency, Isolation, and Durability. Alternatively, you can opt for SQL databases. NoSQL databases often provide eventual consistency, which is suitable for applications where slight data inconsistencies are acceptable and low latency <span class="No-Break">is essential.</span></li>
				<li><strong class="bold">Query complexity</strong>: While <a id="_idIndexMarker657"/>SQL databases are designed for complex queries involving multiple tables and joins, NoSQL databases such as MongoDB are excellent for simple queries and fast <span class="No-Break">data aggregation.</span></li>
				<li><strong class="bold">Community and support</strong>: Consider<a id="_idIndexMarker658"/> the community support and documentation available for the chosen database. A robust community ensures timely help and a wealth of resources <span class="No-Break">for problem-solving.</span></li>
				<li><strong class="bold">Operational overhead</strong>: Evaluate the <a id="_idIndexMarker659"/>operational overhead required to manage the database. Some databases, especially managed services in the cloud, such <a id="_idIndexMarker660"/>as <strong class="bold">AWS RDS</strong> and <strong class="bold">Azure Cosmos DB</strong>, handle<a id="_idIndexMarker661"/> many operational tasks, easing the burden on <span class="No-Break">your team.</span></li>
				<li><strong class="bold">Compliance and security</strong>: Ensure<a id="_idIndexMarker662"/> the database complies with necessary regulations and security standards applicable to your industry. Consider features such as data encryption, access control, and audit trails. Evaluate the security features of the database (encryption, authorization, and authentication) and make sure the database meets the security requirements of <span class="No-Break">your application.</span></li>
				<li><strong class="bold">Database recovery methods</strong>: Make sure the database supports data recovery <a id="_idIndexMarker663"/>in case of any data loss. Understand the disaster recovery process of the database and how it can be handled well with <span class="No-Break">the application.</span></li>
			</ol>
			<p>Choosing the right database and managing database connections are critical decisions in microservices architecture. </p>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> illustrates <a id="_idIndexMarker664"/>the process of choosing the <span class="No-Break">right database:</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B14980_09_01.jpg" alt="Figure 9.1: The process of choosing the right database (image by fullvector on Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: The process of choosing the right database (image by fullvector on Freepik)</p>
			<p>With these concepts covered, we can continue with <span class="No-Break">database connections.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>Database connections in microservices</h2>
			<p><strong class="bold">Database connections</strong> in microservices <a id="_idIndexMarker665"/>is a topic that involves many design decisions and trade-offs. One of the main challenges is how to organize and manage the data that each microservice needs <span class="No-Break">to operate.</span></p>
			<p>Here are the key <a id="_idIndexMarker666"/>concepts for database connections <span class="No-Break">in microservices:</span></p>
			<ul>
				<li><strong class="bold">Connection pooling</strong>: Use <a id="_idIndexMarker667"/>connection pooling techniques to manage database connections efficiently. Connection pools reuse existing connections, reducing the overhead of establishing new connections for <span class="No-Break">each request.</span></li>
				<li><strong class="bold">Connection details</strong>: Connection details <a id="_idIndexMarker668"/>include connection limits and contract-based communications. These are important aspects of microservices architecture that help ensure efficient and reliable communication between the different services within the system. <strong class="bold">Connection limits</strong> refer to the maximum number of connections<a id="_idIndexMarker669"/> that a service can handle at any given time. In a microservices architecture, each service typically has connection limits to manage the incoming and outgoing communication with other services, databases, or external systems. Setting and managing these connection limits is crucial to prevent overloading the service and causing <span class="No-Break">performance issues.</span></li>
				<li><strong class="bold">Contract-based communication</strong>, on the other hand, refers to the practice of defining and<a id="_idIndexMarker670"/> adhering to a clear set of communication protocols and data formats between services. This involves establishing clear contracts or interfaces that specify how services should communicate with each other, including the types of messages, data structures, and protocols to be used. By adhering to these contracts, services can ensure that their communication is reliable and predictable, regardless of the technology or implementation details used within <span class="No-Break">each service.</span><p class="list-inset">In the context <a id="_idIndexMarker671"/>of microservices, proper management of connection limits and adherence to contract-based communication principles can help maintain the stability and scalability of the system. It allows for services to communicate efficiently and reliably, while also enabling changes and updates to be made to individual services without disrupting the overall system. Ultimately, this approach contributes to the overall robustness and maintainability of a <span class="No-Break">microservices architecture.</span></p></li>
				<li><strong class="bold">Retry strategies</strong>: Implement <a id="_idIndexMarker672"/>retry strategies to handle transient database connection failures. Retrying failed database operations can improve the overall robustness of <span class="No-Break">your microservices.</span></li>
				<li><strong class="bold">Timeouts</strong>: Set <a id="_idIndexMarker673"/>connection timeouts to prevent requests from waiting indefinitely for a response. Timeouts ensure that if a database operation takes too long, the system can recover and handle the <span class="No-Break">situation gracefully.</span></li>
				<li><strong class="bold">Connection string management</strong>: Manage <a id="_idIndexMarker674"/>connection strings securely. Avoid hardcoding sensitive information such as passwords. Utilize environment variables or secure vaults for sensitive <span class="No-Break">configuration data.</span></li>
				<li><strong class="bold">Graceful handling of failures</strong>: Implement graceful handling of database failures. When a <a id="_idIndexMarker675"/>database connection fails, microservices should respond gracefully, providing meaningful error messages to clients and attempting reconnection using <span class="No-Break">back-off strategies.</span></li>
				<li><strong class="bold">Database connection monitoring</strong>: Implement <a id="_idIndexMarker676"/>monitoring for database connections. Track connection usage, errors, and latencies. Monitoring helps identify bottlenecks and performance issues in your <span class="No-Break">microservices architecture.</span></li>
			</ul>
			<p>Remember, it is important to write securely the database connection to ensure that the software with microservices is error-free <span class="No-Break">and secure.</span></p>
			<p>In summary, by carefully considering your application’s requirements and selecting the appropriate database technology, along with implementing robust database connection management practices, you can ensure the reliability, scalability, and security of your <span class="No-Break">microservices-based application.</span></p>
			<p>Next, we’ll learn more about data models and schemas and <span class="No-Break">CRUD operations.</span></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor173"/>Data models and schemas and CRUD operations</h1>
			<p>In microservices architecture, defining clear data models and schemas, as well as implementing CRUD operations, are essential tasks for managing <span class="No-Break">data effectively.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor174"/>Data models and schemas</h2>
			<p><strong class="bold">Data models and schemas</strong> are two important concepts in database design and development. A data model <a id="_idIndexMarker677"/>is a way of representing the structure, relationships, and constraints of the data in a database. A schema is a specific implementation<a id="_idIndexMarker678"/> of a data model, usually expressed in a formal language such as SQL. A schema defines the tables, columns, keys, indexes, views, and other objects that make up a database. There are different types of data models and schemas, depending on the level of abstraction and the purpose of <span class="No-Break">the design.</span></p>
			<p>Here’s how <a id="_idIndexMarker679"/>you can<a id="_idIndexMarker680"/> handle data models and schemas <span class="No-Break">in microservices:</span></p>
			<ul>
				<li><strong class="bold">Define clear data models</strong>: Create well-defined data models for your microservices. Understand the entities your service will handle and represent them as JavaScript objects. Define the properties and their <span class="No-Break">data types.</span></li>
				<li><strong class="bold">Use schemas for validation</strong>: Implement schemas using validation libraries such as <strong class="bold">Joi</strong>, or <a id="_idIndexMarker681"/>ORM/ODM features. ORM/ODM schemas are the definitions of how data is mapped between an object model and a database. An ORM schema specifies how the tables, columns, keys, and relationships in a relational database correspond to the classes, properties, methods, and associations in an object-oriented programming language. An ODM schema defines how the documents, fields, indexes, and references in a document database match the objects, attributes, functions, and links in an object-based programming language. Schemas enforce data consistency and validate incoming data against predefined rules. They ensure that the data adheres to the expected structure <span class="No-Break">and format.</span></li>
				<li><strong class="bold">Handle relationships</strong>: If your microservice handles entities with relationships (for example, one-to-many, many-to-many, and others), define relationships in your data models. Use foreign keys or references to establish these relationships, ensuring <span class="No-Break">data integrity.</span></li>
				<li><strong class="bold">Version your schemas</strong>: Consider versioning your schemas, especially in a microservices environment where services might evolve independently. Versioned schemas help maintain compatibility with existing consumers while allowing new features to <span class="No-Break">be added.</span></li>
			</ul>
			<p>In this section, we<a id="_idIndexMarker682"/> learned how to define data models or schemas that <a id="_idIndexMarker683"/>represent the structure and attributes of the data stored in <span class="No-Break">the database.</span></p>
			<p>With these concepts covered, let’s learn more about <span class="No-Break">CRUD operations.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/>CRUD operations</h2>
			<p><strong class="bold">CRUD operations</strong> are<a id="_idIndexMarker684"/> the four basic functions of persistent storage in computer programming: Create, Read, Update, and Delete. These operations can be performed on various types of data, such as relational, document, or object-based data. CRUD operations are also mapped to standard HTTP methods, such as POST, GET, PUT, and DELETE, when working with <span class="No-Break">web applications.</span></p>
			<p>Here’s how you can <a id="_idIndexMarker685"/>handle CRUD operations <span class="No-Break">in microservices:</span></p>
			<ul>
				<li><strong class="bold">Create (POST) operation</strong>: Implement the create operation to add new records to the <a id="_idIndexMarker686"/>database. Validate the incoming data using the defined schema before inserting it into the database. Then, return the created entity with a success <span class="No-Break">status code.</span></li>
				<li><strong class="bold">Read (GET) operation</strong>: Implement<a id="_idIndexMarker687"/> the read operation to retrieve data from the database. Use query parameters to filter, sort, and paginate the results if necessary. Handle different endpoints or query parameters for specific data <span class="No-Break">retrieval requirements.</span></li>
				<li><strong class="bold">Update (PUT/PATCH) operation</strong>: Implement the update operation to modify <a id="_idIndexMarker688"/>existing records. Validate the incoming data against the schema. Use <strong class="bold">PUT</strong> to update the entire resource and <strong class="bold">PATCH</strong> to update specific fields. Return the updated entity with a success <span class="No-Break">status code.</span></li>
				<li><strong class="bold">Delete (DELETE) operation</strong>: Implement the delete operation to remove records<a id="_idIndexMarker689"/> from the database. Use a unique identifier (for example, ID) to identify the entity to delete. Handle cascading deletions if necessary for <span class="No-Break">related data.</span></li>
			</ul>
			<p>CRUD operations <a id="_idIndexMarker690"/>help us in our everyday work in terms of manipulating <span class="No-Break">databases efficiently.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.2</em> depicts the process of database and <span class="No-Break">CRUD operations:</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B14980_09_02.jpg" alt="Figure 9.2: Database and CRUD operations (image by Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Database and CRUD operations (image by Freepik)</p>
			<p>In summary, by following these best practices, you can ensure that your microservices handle data <a id="_idIndexMarker691"/>effectively, maintain data integrity, and provide reliable CRUD operations <span class="No-Break">to consumers.</span></p>
			<p>Now, we can continue to the next section, in which we will talk about transactions and <span class="No-Break">data validation.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor176"/>Transactions and data validation</h1>
			<p>In microservices architecture, transactions are crucial for maintaining data consistency when multiple operations need to be executed atomically. Data validation and sanitization are critical for preventing common <span class="No-Break">security vulnerabilities.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor177"/>Transactions in microservices</h2>
			<p><strong class="bold">Transactions</strong> in<a id="_idIndexMarker692"/> microservices are a challenge that requires careful design and trade-offs. Transactions are operations that ensure the consistency and reliability of data across multiple systems. However, in microservices architecture, where each service has its own data store and communication is asynchronous and unreliable, implementing transactions becomes more complex and costly. There are different approaches and patterns to handle transactions in microservices, depending on the requirements and constraints of <span class="No-Break">the system.</span></p>
			<p>Here’s how you <a id="_idIndexMarker693"/>can handle transactions in your microservices <span class="No-Break">using Node.js:</span></p>
			<ul>
				<li><strong class="bold">Database support</strong>: Choose a database that supports transactions. Most relational <a id="_idIndexMarker694"/>databases, such as MySQL and PostgreSQL, offer transactional support. Some NoSQL databases, such as MongoDB, provide support for multi-document transactions. NoSQL databases that support transactions natively, such as MongoDB, CouchDB, and RethinkDB, provide ACID guarantees for transactions within a single document or collection, and some of them also support multi-document or cross-collection transactions. However, these transactions may have performance and scalability trade-offs, and they may not work well for complex or cross-service transactions. NoSQL databases that support transactions through external libraries or frameworks, such as OrientDB, ArangoDB, and Cassandra, do not have built-in transaction support, but<a id="_idIndexMarker695"/> they can be integrated with third-party tools or modules that provide transaction capabilities, such as two-phase commit, the Saga pattern, or event sourcing. However, these tools or modules may have limitations or dependencies, and they may require additional coding <span class="No-Break">or configuration.</span><p class="list-inset">NOSQL <a id="_idIndexMarker696"/>may support different consistency models and may not guarantee ACID transactions in all situations, such as when key-value pairs or document-oriented programming is involved. While some NoSQL databases offer transactional capabilities, others may prioritize other aspects, such as high availability and scalability, over strong <span class="No-Break">transactional consistency.</span></p><p class="list-inset">Also, graph databases such as Neo4j can be used with microservices to handle transactional data. In microservices architecture, each service can have a graph database instance to manage its specific data. Neo4j supports ACID-compliant transactions, and its flexible data model makes it suitable for handling complex relationships and graph data in a distributed and <span class="No-Break">scalable environment.</span></p></li>
				<li><strong class="bold">Begin and commit transactions</strong>: Use the appropriate commands to begin and <a id="_idIndexMarker697"/>commit transactions. In SQL databases, this typically involves commands such as <strong class="source-inline">BEGIN TRANSACTION</strong>, <strong class="source-inline">COMMIT</strong>, and <strong class="source-inline">ROLLBACK</strong> for error handling. In NoSQL databases, transactions might involve a series of operations that are executed atomically. We must close database connections after each use. Failing to close these can result in memory leaks. Each open connection consumes memory resources, and if connections are not closed properly, the memory associated with those connections may not be released, leading to increased memory usage <span class="No-Break">over time.</span></li>
				<li><strong class="bold">Error handling and rollbacks</strong>: Implement<a id="_idIndexMarker698"/> error handling within transactions. If any operation within a transaction fails, roll back the entire transaction. This ensures that either all operations in the transaction succeed, or the database is left in its initial <span class="No-Break">state (rollback).</span></li>
				<li><strong class="bold">Concurrency control</strong>: Consider implementing concurrency control mechanisms<a id="_idIndexMarker699"/> such as pessimistic or optimistic concurrency control. Pessimistic concurrency control involves locking resources to prevent conflicts, while optimistic concurrency control uses versioning or timestamps to detect conflicts and handle <span class="No-Break">them gracefully.</span></li>
				<li><strong class="bold">Nested transactions</strong>: Some <a id="_idIndexMarker700"/>databases support nested transactions. Be cautious when using nested transactions as they can lead to complex behaviors. Nested transactions might commit independently of their parent transaction, leading to <span class="No-Break">unexpected results.</span></li>
				<li><strong class="bold">Test transactions</strong>: Test your<a id="_idIndexMarker701"/> transactional logic thoroughly, including <a id="_idIndexMarker702"/>scenarios where transactions involve multiple services. Mock external service calls during testing to simulate different outcomes and ensure your transactions handle errors and <span class="No-Break">rollbacks correctly.</span></li>
				<li><strong class="bold">Monitor connection usage</strong>: This<a id="_idIndexMarker703"/> will help you track the usage of database connections, which, in turn, helps with identifying potential issues such as connection leaks, excessive connection usage, or performance bottlenecks. We can monitor them using <span class="No-Break">Datadog dashboards.</span></li>
			</ul>
			<p>With transactions, we can create faster a database and ensure <span class="No-Break">its quality.</span></p>
			<p>Next, we’ll look at data validation <span class="No-Break">and sanitization.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>Data validation and sanitization</h2>
			<p><strong class="bold">Data validation and sanitization</strong> are<a id="_idIndexMarker704"/> two important techniques for ensuring the quality and security of data in web applications. Data validation is the process of checking if the user input meets certain criteria, such as format, length, type, or range, before we process or store it. Data sanitization is the process of removing or escaping potentially harmful characters or scripts from the user input to prevent attacks such<a id="_idIndexMarker705"/> as <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>) or SQL injection. By applying data validation and sanitization, developers can prevent various security vulnerabilities and ensure that the data being received and processed is accurate <span class="No-Break">and reliable.</span></p>
			<p>Here’s how you can <a id="_idIndexMarker706"/>handle data validation and sanitization in your microservices <span class="No-Break">using Node.js:</span></p>
			<ul>
				<li><strong class="bold">Use validation libraries</strong>: Utilize validation <a id="_idIndexMarker707"/>libraries such as Joi to validate incoming data against predefined schemas. Joi allows you to define the expected structure of data and validate it, ensuring that it adheres to the specified format before it’s processed. Here’s an example of using Joi in a Node.js <span class="No-Break">route handler:</span><pre class="source-code">
//Firstly, we need to import the required library</pre><pre class="source-code">
const Joi = require('joi');</pre><pre class="source-code">
// We define the schema using Joi library with its parameters</pre><pre class="source-code">
const schema = Joi.object({</pre><pre class="source-code">
  username: Joi.string().alphanum().min(3).max(30).required(),</pre><pre class="source-code">
  email: Joi.string().email().required(),</pre><pre class="source-code">
});</pre><pre class="source-code">
// Validate request data</pre><pre class="source-code">
const { error, value } = schema.validate(req.body);</pre><pre class="source-code">
if (error) {</pre><pre class="source-code">
  // Handle validation error</pre><pre class="source-code">
}</pre></li>
				<li><strong class="bold">Sanitize user input</strong>: Sanitize user input to prevent XSS attacks and SQL injection. Sanitization <a id="_idIndexMarker708"/>libraries such<a id="_idIndexMarker709"/> as <strong class="bold">DOMPurify</strong> can help clean HTML input to remove potentially malicious scripts. For SQL sanitization, use parameterized queries to avoid SQL injection attacks. Here’s an example of using DOMPurify to sanitize <span class="No-Break">HTML input:</span><pre class="source-code">
const DOMPurify = require('dompurify');</pre><pre class="source-code">
const sanitizedHTML = DOMPurify.sanitize(req.body.htmlInput);</pre></li>
				<li><strong class="bold">Regular expressions</strong>: Use<a id="_idIndexMarker710"/> regular expressions to validate specific patterns, such as <a id="_idIndexMarker711"/>email addresses, URLs, or credit card numbers. Regular expressions can be powerful tools for complex data validation. Here’s an example of using a regular expression to validate an <span class="No-Break">email address:</span><pre class="source-code">
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;</pre><pre class="source-code">
if (!emailRegex.test(req.body.email)) {</pre><pre class="source-code">
  // Handle invalid email address</pre><pre class="source-code">
}</pre></li>
				<li><strong class="bold">Avoid eval() and unsafe functions</strong>: Avoid using <strong class="source-inline">eval()</strong> and other unsafe functions <a id="_idIndexMarker712"/>that can execute arbitrary code. These functions can introduce serious security vulnerabilities by allowing attackers to execute malicious scripts within <span class="No-Break">your application.</span></li>
				<li><strong class="bold">Output encoding</strong>: Apply appropriate output encoding techniques to escape potentially <a id="_idIndexMarker713"/>malicious characters within user-generated content before rendering it in the browser. Utilize encoding methods such as HTML entity encoding, JavaScript escaping, and URL encoding to prevent malicious scripts from being injected into <span class="No-Break">the output.</span></li>
				<li><strong class="bold">Security policies</strong>: Enforce strict <strong class="bold">content security policies</strong> (<strong class="bold">CSPs</strong>) to define trusted<a id="_idIndexMarker714"/> sources<a id="_idIndexMarker715"/> of content and mitigate the risks associated with loading external resources and executing inline scripts. Implement appropriate HTTP security headers, such as X-XSS-Protection, to enable your browser’s XSS filtering mechanism and block potential <span class="No-Break">attack vectors.</span></li>
			</ul>
			<p>Incorporating <a id="_idIndexMarker716"/>these preventive measures can significantly reduce the likelihood of XSS attacks and enhance the overall security posture of your application. Additionally, staying informed about the latest security best practices and vulnerabilities is crucial for continuously improving your XSS <span class="No-Break">prevention strategies.</span></p>
			<p>Data validation and sanitization help us a lot in validating user input in models and not allowing hackers to modify <span class="No-Break">our databases.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.3</em> illustrates data validation <span class="No-Break">and sanitizing:</span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B14980_09_03.jpg" alt="Figure 9.3: Data validation and sanitizing (image by storyset on Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: Data validation and sanitizing (image by storyset on Freepik)</p>
			<p>In summary, by<a id="_idIndexMarker717"/> implementing robust transaction management and thorough data validation and sanitization practices, you can significantly enhance the security and reliability of your <span class="No-Break">microservices-based applications.</span></p>
			<p>In the next section, we will learn about error handling <span class="No-Break">and optimizations.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor179"/>Error handling and optimizations</h1>
			<p>Proper error handling is crucial in microservices architecture to ensure reliability and provide meaningful feedback to clients. On the other hand, optimizing your microservices ensures they run efficiently and handle requests quickly, enhancing the overall <span class="No-Break">user experience.</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>Error handling in microservices</h2>
			<p><strong class="bold">Error handling</strong> in<a id="_idIndexMarker718"/> microservices is a crucial aspect of building reliable and resilient distributed systems. Errors can occur due to various reasons, such as network failures, service outages, data inconsistencies, or application bugs. Therefore, it is important to have a consistent and effective strategy for handling errors across <span class="No-Break">different microservices.</span></p>
			<p>Here’s how you can handle errors effectively in your <span class="No-Break">Node.js microservices:</span></p>
			<ul>
				<li><strong class="bold">Use HTTP status codes</strong>: Utilize <a id="_idIndexMarker719"/>appropriate <a id="_idIndexMarker720"/>HTTP status codes in your responses. For example, use <strong class="bold">400 Bad Request</strong> for client errors (for example, validation failures), <strong class="bold">404 Not Found</strong> for <a id="_idIndexMarker721"/>resources that don’t exist, and <strong class="bold">500 Internal Server Error</strong> for server-side errors (a server-side error is an error that <a id="_idIndexMarker722"/>occurs on the web server when it fails to process a request from a client (such as a web browser). A common example of a server-side error is the 500 Internal Server Error, which indicates that the server encountered an unexpected condition that prevented it from fulfilling <span class="No-Break">the request.</span></li>
				<li><strong class="bold">Centralized error handling</strong>: Implement centralized error handling middleware. This<a id="_idIndexMarker723"/> middleware catches unhandled errors, logs them, and sends an appropriate error response to the client. It ensures consistent error formatting across your microservices. Here’s an example of <a id="_idIndexMarker724"/>using <strong class="bold">Express.js</strong> middleware for centralized <span class="No-Break">error handling:</span><pre class="source-code">
app.use((err, req, res, next) =&gt; {</pre><pre class="source-code">
  console.error(err.stack);</pre><pre class="source-code">
  res.status(500).send('Something went wrong!');</pre><pre class="source-code">
});</pre></li>
				<li><strong class="bold">Custom error classes</strong>: Use custom error classes to represent different types of errors. Custom errors <a id="_idIndexMarker725"/>can include additional information and help you handle specific error scenarios more effectively. Here’s an example of creating a custom error class <span class="No-Break">in Node.js:</span><pre class="source-code">
class CustomError extends Error {</pre><pre class="source-code">
  constructor(message, statusCode) {</pre><pre class="source-code">
    super(message);</pre><pre class="source-code">
    this.statusCode = statusCode;</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre><pre class="source-code">
// Usage</pre><pre class="source-code">
throw new CustomError('Custom error message', 400);</pre></li>
				<li><strong class="bold">Logging</strong>: Log errors <a id="_idIndexMarker726"/>with detailed information, including the error message, stack trace, and relevant context. Centralized logging helps in diagnosing issues and monitoring the health of <span class="No-Break">your microservices.</span></li>
				<li><strong class="bold">Error codes and messages</strong>: Include error codes and user-friendly error messages in <a id="_idIndexMarker727"/>your responses. Error codes can help both clients and developers identify specific issues, while user-friendly messages improve the <span class="No-Break">user experience.</span></li>
			</ul>
			<p>Error handling in microservices can help you avoid headaches later while developing microservices in Node.js. It helps developers <span class="No-Break">debug faster.</span></p>
			<p>In the next section, we will talk about optimizations <span class="No-Break">in microservices.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor181"/>Optimizations in microservices</h2>
			<p><strong class="bold">Optimizations</strong> in <a id="_idIndexMarker728"/>microservices are the techniques and practices that aim to improve the performance, scalability, and reliability of <span class="No-Break">microservice-based applications.</span></p>
			<p>Here are some optimization techniques that are specific to <span class="No-Break">Node.js microservices:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Code optimization</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Minimize dependencies</strong>: Use <a id="_idIndexMarker729"/>only the necessary libraries to reduce the size of <span class="No-Break">your application</span></li><li><strong class="bold">Avoid synchronous operations</strong>: Prefer asynchronous operations to prevent blocking the <span class="No-Break">event loop</span></li><li><strong class="bold">Use efficient algorithms</strong>: Choose appropriate data structures and algorithms to optimize <span class="No-Break">processing times</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Database optimization</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Use indexing</strong>: Index <a id="_idIndexMarker730"/>database fields that are frequently used in queries to speed up <span class="No-Break">search operations</span></li><li><strong class="bold">Batch database operations</strong>: Combine multiple database operations into batches to reduce the number of round trips to <span class="No-Break">the database</span></li><li><strong class="bold">Connection pooling</strong>: Reuse database connections using connection pooling libraries to <span class="No-Break">minimize overhead</span></li></ul></li>
				<li><strong class="bold">Caching</strong>: Implement <a id="_idIndexMarker731"/>caching mechanisms (in-memory caching or external caches such as <strong class="bold">Redis</strong>) for<a id="_idIndexMarker732"/> frequently accessed data. Caching reduces the need to fetch data from the <span class="No-Break">database repeatedly.</span></li>
				<li><strong class="bold">Load balancing</strong>: Use <a id="_idIndexMarker733"/>load balancers to distribute incoming traffic across multiple instances of your microservices. Load balancing ensures that no single instance is overwhelmed, optimizing <span class="No-Break">resource utilization.</span></li>
				<li><strong class="bold">Error handling and monitoring</strong>: Monitor your<a id="_idIndexMarker734"/> microservices using tools<a id="_idIndexMarker735"/> such as <strong class="bold">Prometheus</strong>, <strong class="bold">Grafana</strong>, or <strong class="bold">New Relic</strong>. Track <a id="_idIndexMarker736"/>performance metrics, errors, and<a id="_idIndexMarker737"/> resource usage to identify bottlenecks and areas <span class="No-Break">for optimization.</span></li>
				<li><span class="No-Break"><strong class="bold">Network optimization</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Minimize external API calls</strong>: Reduce<a id="_idIndexMarker738"/> the number of calls to external services or APIs since network latency can significantly impact <span class="No-Break">response times</span></li><li><strong class="bold">Compression</strong>: Use response compression to reduce the size of data sent over the network, especially for <span class="No-Break">JSON responses</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Microservices communication</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Optimize inter-service communication</strong>: Choose<a id="_idIndexMarker739"/> efficient protocols<a id="_idIndexMarker740"/> such as <strong class="bold">gRPC</strong> and <strong class="bold">Protocol Buffers</strong> for<a id="_idIndexMarker741"/> communication <span class="No-Break">between microservices.</span></li><li><strong class="bold">Implement circuit breaking</strong>: Circuit breaking<a id="_idIndexMarker742"/> in microservices is a technique that prevents cascading failures in a distributed system by stopping communication with a failing or unresponsive service. A circuit breaker is a component that monitors the health and performance of a service and acts as a proxy for the requests. When the service is functioning normally, the circuit breaker allows the requests to pass through. Use circuit-breaking patterns to prevent cascading failures in case a dependent service is slow <span class="No-Break">or unresponsive.</span></li></ul></li>
			</ul>
			<p>In summary, by combining effective error handling practices with strategic optimizations, you can ensure your Node.js microservices are both robust and performant, providing a seamless experience for users <span class="No-Break">and clients.</span></p>
			<p>In the final section, we are going to talk <span class="No-Break">about testing.</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/>Testing</h1>
			<p><strong class="bold">Testing</strong> is a<a id="_idIndexMarker743"/> critical aspect of software development as it ensures that your microservices are reliable, secure, and function <span class="No-Break">as expected.</span></p>
			<p>Here are various <a id="_idIndexMarker744"/>testing techniques and best practices for <span class="No-Break">Node.js microservices:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Unit testing</strong></span><span class="No-Break">:</span><ul><li><em class="italic">Purpose</em>: Test individual units or components of your microservices <span class="No-Break">in isolation</span></li><li><em class="italic">Tools</em>: Use testing frameworks<a id="_idIndexMarker745"/> such as <strong class="bold">Mocha</strong>, <strong class="bold">Jest</strong>, or <strong class="bold">Jasmine</strong>, and <a id="_idIndexMarker746"/>assertion<a id="_idIndexMarker747"/> libraries such as <strong class="bold">Chai</strong> or Jest’s <a id="_idIndexMarker748"/><span class="No-Break">built-in assertions</span></li><li><em class="italic">Techniques</em>: Write tests for functions, classes, and modules, mocking dependencies to isolate the unit <span class="No-Break">being tested</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Integration testing</strong></span><span class="No-Break">:</span><ul><li><em class="italic">Purpose</em>: Validate interactions<a id="_idIndexMarker749"/> between different components <span class="No-Break">or microservices.</span></li><li><em class="italic">Tools</em>: Use testing frameworks and libraries similar to unit testing but focus on scenarios where multiple <span class="No-Break">units interact.</span></li><li><em class="italic">Techniques</em>: Test API endpoints, data flows, and integrations with databases or external services. Use real or in-memory databases for more <span class="No-Break">realistic testing.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">End-to-end testing</strong></span><span class="No-Break">:</span><ul><li><em class="italic">Purpose</em>: Test the <a id="_idIndexMarker750"/>entire flow of a microservice, including interactions with <span class="No-Break">external dependencies</span></li><li><em class="italic">Tools</em>: <strong class="bold">Selenium</strong>, <strong class="bold">Puppeteer</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Cypress</strong></span></li><li><em class="italic">Techniques</em>: Automate <a id="_idIndexMarker751"/>browser interactions, simulate user<a id="_idIndexMarker752"/> behaviors, and<a id="_idIndexMarker753"/> validate the application’s behavior across its <span class="No-Break">entire stack</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Contract testing</strong></span><span class="No-Break">:</span><ul><li><em class="italic">Purpose</em>: Ensure that<a id="_idIndexMarker754"/> services interacting via APIs adhere to <a id="_idIndexMarker755"/>their <span class="No-Break">defined contracts</span></li><li><em class="italic">Tools</em>: <strong class="bold">Pact</strong> and <strong class="bold">Spring </strong><span class="No-Break"><strong class="bold">Cloud Contract</strong></span></li><li><em class="italic">Techniques</em>: Define <a id="_idIndexMarker756"/>contracts (expectations) between services, then verify that both the producer and consumer of the API meet <span class="No-Break">these expectations</span></li></ul></li>
				<li><strong class="bold">Load and </strong><span class="No-Break"><strong class="bold">performance testing</strong></span><span class="No-Break">:</span><ul><li><em class="italic">Purpose</em>: Assess <a id="_idIndexMarker757"/>how the system behaves under various loads and identify <span class="No-Break">performance bottlenecks</span></li><li><em class="italic">Tools</em>: <strong class="bold">Apache JMeter</strong>, <strong class="bold">Loader.io</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Artillery</strong></span></li><li><em class="italic">Techniques</em>: Simulate<a id="_idIndexMarker758"/> a high volume of requests to your <a id="_idIndexMarker759"/>microservices, monitoring<a id="_idIndexMarker760"/> response times and server <span class="No-Break">resource usage</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Security testing</strong></span><span class="No-Break">:</span><ul><li><em class="italic">Purpose</em>: Identify <a id="_idIndexMarker761"/>vulnerabilities and weaknesses in <span class="No-Break">your microservices</span></li><li><em class="italic">Tools</em>: <strong class="bold">OWASP ZAP</strong>, <strong class="bold">Burp Suite</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">SonarQube</strong></span></li><li><em class="italic">Techniques</em>: Conduct <a id="_idIndexMarker762"/>security scans, code analysis, and penetration<a id="_idIndexMarker763"/> testing to<a id="_idIndexMarker764"/> find security flaws and address them <span class="No-Break">before deployment</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Mutation testing</strong></span><span class="No-Break">:</span><ul><li><em class="italic">Purpose</em>: Evaluate <a id="_idIndexMarker765"/>the quality of your unit tests by introducing small code mutations and checking if the tests <span class="No-Break">catch them</span></li><li><em class="italic">Tools</em>: <strong class="bold">Stryker</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">PITest</strong></span></li><li><em class="italic">Techniques</em>: Mutate <a id="_idIndexMarker766"/>your code base (change a small part of the code), rerun<a id="_idIndexMarker767"/> tests, and see if the tests fail due to <span class="No-Break">the mutation</span></li></ul></li>
			</ul>
			<p>As we have learned, these concepts can help us test software better and deliver a well-tested piece <span class="No-Break">of software.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em> illustrates <a id="_idIndexMarker768"/>the process <span class="No-Break">of testing:</span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B14980_09_04.jpg" alt="Figure 9.4: Testing (image by storyset on Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4: Testing (image by storyset on Freepik)</p>
			<p>In summary, by <a id="_idIndexMarker769"/>following these testing techniques and best practices, you can ensure that your Node.js microservices are thoroughly tested, reliable, and ready <span class="No-Break">for deployment.</span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor183"/>Summary</h1>
			<p>In this chapter, we learned a lot about microservices, how to manipulate databases, and how to fully test our software application. We have gone through every step of database manipulation and testing while developing so that our software application will <span class="No-Break">be bug-free.</span></p>
			<p>Manipulating data in microservices involves performing CRUD operations on databases or data storage systems. Remember to follow best practices for data security, such as input validation, data encryption, and protecting sensitive data, based on the requirements of your microservices and compliance standards. By implementing these steps, you can effectively manipulate data within your Node.js microservices and ensure proper interaction with the underlying database or data <span class="No-Break">storage system.</span></p>
			<p>Managing databases effectively within a microservices architecture using Node.js involves careful consideration of data models, CRUD operations, transactions, <span class="No-Break">and optimizations.</span></p>
			<p>By adhering to these practices, microservices can effectively manage databases, ensuring data integrity, security, and optimal performance within the <span class="No-Break">microservices ecosystem.</span></p>
			<p>In the next chapter, we are going to learn about API communication and data contracts <span class="No-Break">in microservices.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>Quiz time</h1>
			<ul>
				<li>What are the key steps for choosing the <span class="No-Break">right database?</span></li>
				<li>How can you handle data models and schemas <span class="No-Break">in microservices?</span></li>
				<li>What are <span class="No-Break">CRUD operations?</span></li>
				<li>What <span class="No-Break">are transactions?</span></li>
			</ul>
		</div>
	</body></html>