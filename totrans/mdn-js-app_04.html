<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Building a Chatroulette</h1></div></div></div><p>The best way to master MediaStream and PeerJS is by building real-world applications, which is what we will do in this chapter. A chatroulette is a website that pairs random site visitors together for webcam and text-based conversation. Discussing how to build a chatroulette will help us to study PeerJS and PeerServer in depth, as it requires us to integrate PeerServer with Express. We will also add media controls to our site in order to pause/resume local MediaStream and allow the user to choose their desired microphone/webcam, which will help us to study MediaStream even more in depth. We will be actually creating a chatroulette that only allows the users of a particular country to chat, which would require an extra step of verification before connecting to the PeerServer; therefore, taking us even deeper into the integration of PeerServer into Express.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Running your own instance of PeerServer</li><li class="listitem" style="list-style-type: disc">Creating a custom PeerServer</li><li class="listitem" style="list-style-type: disc">Integrating PeerServer with Express</li><li class="listitem" style="list-style-type: disc">Verify users for connecting to PeerServer</li><li class="listitem" style="list-style-type: disc">Finding the IP address and country of a user connected to the server</li><li class="listitem" style="list-style-type: disc">Allowing the user to use a microphone and webcam directly on the webpage</li><li class="listitem" style="list-style-type: disc">Discussing the requirements for building a completely working chatroulette</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Creating your own PeerServer</h1></div></div></div><p>Before we <a id="id142" class="indexterm"/>start building a chatroulette, let's see how to run our own instance of PeerServer.</p><p>PeerServer is available as an npm package on npm cloud. Let's create a custom PeerServer and use it with the PeerJS application that we built in our previous chapter.</p><p>First create a directory named <code class="literal">Custom-PeerServer</code> and place <code class="literal">app.js</code> and <code class="literal">package.json</code> files in it.</p><p>In the <code class="literal">package.json</code> file, place the following code and run the <code class="literal">npm install</code> command to download the PeerServer package:</p><div><pre class="programlisting">{
  "name": "Custom-PeerServer",
  "dependencies": {
    "peer": "0.2.8",
    "express": "4.13.3"
  }
}</pre></div><p>At the <a id="id143" class="indexterm"/>time of writing, the latest version of PeerServer is 0.2.8. Here, we will also download the <code class="literal">express</code> package, as we will need to demonstrate how to integrate PeerServer with Express.</p><p>PeerServer package provides a library to create a custom PeerServer or integrate PeerServer with Express and also an executable file to directly create our own instance of PeerServer without any customization.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Run PeerServer from shell</h2></div></div></div><p>If you <a id="id144" class="indexterm"/>want to directly run your own instance of PeerServer from shell without any customization, then run the following command in the <code class="literal">Custom-PeerServer/node_modules/peer/bin</code> directory:</p><div><pre class="programlisting">
<strong>./peerjs –port 8080</strong>
</pre></div><p>It should now print the following command:</p><div><pre class="programlisting">
<strong>Started PeerServer on ::, port: 8080, path: / (v. 0.2.8)</strong>
</pre></div><p>This confirms that <code class="literal">PeerServer</code> is running. To test whether the <code class="literal">PeerServer</code> instance is working or not, go to the <code class="literal">index.html</code> file of the application that we created in our previous chapter and replace the following code:</p><div><pre class="programlisting">peer = new Peer(id, {key: ""});</pre></div><p>The preceding code will be replaced with the following code:</p><div><pre class="programlisting">peer = new Peer(id, {host: "localhost", port: 8080});</pre></div><p>Now run the application and it should work as usual.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Using PeerServer library</h2></div></div></div><p>PeerServer library is <a id="id145" class="indexterm"/>used to create a custom PeerServer. The PeerServer library also allows us to integrate PeerServer with the Express server.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Creating custom PeerServer</h3></div></div></div><p>Here is an <a id="id146" class="indexterm"/>example code that demonstrates how to create your own custom PeerServer. Place the following code in the <code class="literal">app.js</code> file and run the <code class="literal">node app.js</code> command to start the server:</p><div><pre class="programlisting">var PeerServer = require("peer").PeerServer;
var server = PeerServer({port: 8080});

server.on("connection", function(id) {
  console.log(id + " has connected to the PeerServer");
});

server.on("disconnect", function(id) {
  console.log(id + " has disconnected from the PeerServer");
});</pre></div><p>Here, the first two lines of the code create the custom PeerServer. We then attached event handlers that will be triggered when a user connects or disconnects from PeerServer. A custom PeerServer doesn't provide an API to check whether a peer is allowed to connect to PeerServer or not. It just allows us to do something after the peer is connected or when the peer disconnects.</p><p>To test whether the custom PeerServer is working or not, go to the <code class="literal">index.html</code> file of the application that we created in the previous chapter and replace the following code:</p><div><pre class="programlisting">peer = new Peer(id, {key: ""});</pre></div><p>The preceding code will be replaced with the following code:</p><div><pre class="programlisting">peer = new Peer(id, {host: "localhost", port: 8080});</pre></div><p>Now run the application and it should work as usual.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Integrating PeerServer with the Express server</h3></div></div></div><p>We can also <a id="id147" class="indexterm"/>integrate PeerServer <a id="id148" class="indexterm"/>with the Express server, that is, a particular path of the Express server will provide the signaling service. The main advantage of integrating PeerServer with the Express server is that we can check whether a peer is allowed to connect to PeerServer or not, and if it is not allowed, then we can stop the peer from using it.</p><p>Here is an example code that demonstrates how to integrate PeerServer with the Express server. Place <a id="id149" class="indexterm"/>the following <a id="id150" class="indexterm"/>code in the <code class="literal">app.js</code> file and run the <code class="literal">node app.js</code> command to start the server:</p><div><pre class="programlisting">var express = require("express");
var app = express();

var server = app.listen(8080);

app.use("/signaling", function(httpRequest, httpResponse, next){
  //check whether peer is allowed to connect or not.

  next();
});


var ExpressPeerServer = require("peer").ExpressPeerServer(server, {debug: true});

app.use("/signaling", ExpressPeerServer);

ExpressPeerServer.on("connection", function(id){

});

ExpressPeerServer.on("disconnect", function(id){

});</pre></div><p>Here we are using a middleware provided by the <code class="literal">PeerServer</code> library to integrate PeerServer with Express. Here, PeerServer is made available on the <code class="literal">/signaling</code> path. You can use any path you want to.</p><p>The <code class="literal">PeerServer</code> library doesn't provide any way to check whether the peer is allowed to connect to PeerServer or not, so we are using our own technique, that is, we are attaching another middleware on top of the <code class="literal">ExpressPeerServer</code> middleware, which performs this check. Although this technique may seem fine, if our custom middleware stops the request from proceeding <a id="id151" class="indexterm"/>further, then PeerServer fires the <code class="literal">connection</code> and <code class="literal">disconnect</code> events and destroys the <code class="literal">Peer</code> instance on the frontend.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>You can learn more about PeerServer at <a class="ulink" href="https://www.npmjs.com/package/peer">https://www.npmjs.com/package/peer</a>.</p></div></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Creating a chatroulette</h1></div></div></div><p>The chatroulette <a id="id152" class="indexterm"/>that we will build is only for people residing in <a id="id153" class="indexterm"/>India, that is, a peer cannot connect to the PeerServer if the IP address of the peer doesn't resolve to India. We added this filter to make the website a little more complex to code so that you can learn how to check whether a user is allowed to connect to PeerServer or not.</p><p>We will use a single server that will serve webpages and also act as a PeerServer, that is, we will integrate PeerServer with the Express server.</p><p>We won't get into designing the frontend of our chatroulette. We will only be concentrating on building the architecture and functionalities.</p><p>The exercise files for this chapter contain two directories: <code class="literal">Chatroulette</code> and <code class="literal">Custom-PeerServer</code>. In the <code class="literal">Chatroulette</code> directory, there are two directories: <code class="literal">Initial</code> and <code class="literal">Final</code>. In the <code class="literal">Final</code> directory, you will find the complete chatroulette source code. In the <code class="literal">Initial</code> directory, you will only find the HTML code for our chatroulette. The <code class="literal">Initial</code> directory is to help you quickly get started with building the chatroulette.</p><p>You will place the code related to the frontend functionality of the site in the <code class="literal">Initial/public/js/main.js</code> file and you will place the code related to the server side functionality in the <code class="literal">Initial/app.js</code> file.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Building the backend</h2></div></div></div><p>Our site <a id="id154" class="indexterm"/>will basically contain three URL end points: a root path for serving the home page, the <code class="literal">/find</code> path to find the ID of a free user for chatting, and finally the <code class="literal">/signaling</code> path that serves as the end point for PeerServer.</p><p>Every user will have a unique ID that is generated by PeerServer. For a user to retrieve the ID of another free user using the <code class="literal">/find</code> URL, they must be first be connected to PeerServer.</p><p>The server will maintain two different arrays, that is, the first array contains IDs of the users connected to PeerServer and the second array contains IDs of the users that need a partner to chat.</p><p>Let's get started with building our backend. Place the following code in the <code class="literal">app.js</code> file to create our web server and serve the home page of our site:</p><div><pre class="programlisting">var express = require("express");
var app = express();

app.use(express.static(__dirname + "/public"));

app.get("/", function(httpRequest, httpResponse, next){
  httpResponse.sendFile(__dirname + "/public/html/index.html");
})

var server = app.listen(8080);</pre></div><p>Here we are serving the <code class="literal">index.html</code> file as our home page. Run the <code class="literal">node app.js</code> command <a id="id155" class="indexterm"/>to start the server. I am assuming that you are running <code class="literal">node.js</code> on the localhost, so open the <code class="literal">http://localhost:8080/</code> URL on the browser to see the home page. The home page should look similar to the following image:</p><div><img src="img/B05154_04_01.jpg" alt="Building the backend"/></div><p>The following are the different elements of the home page:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">At the top of the home page, we will display the status of the <code class="literal">PeerServer</code> connection, <code class="literal">DataConnection</code>, and <code class="literal">MediaConnection</code>.</li><li class="listitem" style="list-style-type: disc">Then we will display a video element and message box. <code class="literal">MediaStream</code> of the remote peer will be rendered on the video element.</li><li class="listitem" style="list-style-type: disc">Then we have drop-down boxes for the user to select a microphone and webcam that they want to use if they have multiple microphones or webcams connected to their computer.</li><li class="listitem" style="list-style-type: disc">Then we have checkboxes that allow the users to pause or resume their audio and video.</li><li class="listitem" style="list-style-type: disc">Finally, we have a button that allows the user to disconnect from the current user and chat with another user.</li></ul></div><p>Every interactive element in the HTML page has an ID associated with it. While coding the frontend of the website, we will be using their IDs to get their reference.</p><p>Now let's create our signaling server. Here is the code for this. Place it in the <code class="literal">app.js</code> file:</p><div><pre class="programlisting">var requestIp = require("request-ip");
var geoip = require("geoip-lite");

app.use("/signaling", function(httpRequest, httpResponse, next){

  var clientIp = requestIp.getClientIp(httpRequest);
  var geo = geoip.lookup(clientIp);

  if(geo != null)
  {
    if(geo.country == "IN")
    {
      next();
    }
    else
    {
      httpResponse.end();
    }
  }
  else
  {
    next();
  }
});

var ExpressPeerServer = require("peer").ExpressPeerServer(server);

app.use("/signaling", ExpressPeerServer);

var connected_users = [];

ExpressPeerServer.on("connection", function(id){
  var idx = connected_users.indexOf(id); 
  if(idx === -1) //only add id if it's not in the array yet
  {
    connected_users.push(id);
  }
});

ExpressPeerServer.on("disconnect", function(id){
  var idx = connected_users.indexOf(id); 
  if(idx !== -1) 
  {
    connected_users.splice(idx, 1);
  }

  idx = waiting_peers.indexOf(id);
  if(idx !== -1) 
  {
    waiting_peers.splice(idx, 1);
  }  
});</pre></div><p>The <a id="id156" class="indexterm"/>following is how the code works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Before the user can connect to PeerServer, we will find the country to which the IP address of the user belongs. We will find the IP address using the <code class="literal">request-ip</code> module and resolve the IP address to the country using the <code class="literal">geoip-lite</code> module. If the country is <code class="literal">IN</code> or the country name couldn't be resolved, then we will allow the user to connect to PeerServer by triggering the next middleware, otherwise we will stop them by sending an empty response.</li><li class="listitem" style="list-style-type: disc">When a user connects to PeerServer, we will add the ID of the user in the <code class="literal">connected_users</code> array that maintains a list IDs if the users that are connected to PeerServer. Similarly, when the user disconnects from the PeerServer, we will remove the ID of the user from the <code class="literal">connected_users</code> array.</li></ul></div><p>Now let's define route for the <code class="literal">/find</code> path using which a user can find another user who is free to chat. The following is the code for this. Place this code in the <code class="literal">app.js</code> file:</p><div><pre class="programlisting">var waiting_peers = [];

app.get("/find", function(httpRequest, httpResponse, next){

  var id = httpRequest.query.id;

  if(connected_users.indexOf(id) !== -1)
  {

    var idx = waiting_peers.indexOf(id); 
     if(idx === -1) 
    {
      waiting_peers.push(id);
    }

    if(waiting_peers.length &gt; 1)
    {
      waiting_peers.splice(idx, 1);  
      var user_found = waiting_peers[0];
      waiting_peers.splice(0, 1);
      httpResponse.send(user_found);
    }
    else
    {
      httpResponse.status(404).send("Not found");
    }
  }
  else
  {
    httpResponse.status(404).send("Not found");
  }
})</pre></div><p>Here is <a id="id157" class="indexterm"/>how the code works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<code class="literal"> waiting_users</code> array holds the IDs of the users who are free and looking for a partner to chat to.</li><li class="listitem" style="list-style-type: disc">When a user makes a request to the <code class="literal">/find</code> path, the route handler first checks whether the user is connected to PeerServer or not by checking whether the user ID is present in the <code class="literal">connected_users</code> array.</li><li class="listitem" style="list-style-type: disc">If the user is not connected to PeerServer, then it sends an HTTP 404 error. If the user is connected to PeerServer, then it checks whether the user's ID is present in the <code class="literal">waiting_list</code> array. If not, it adds in the array and proceeds.</li><li class="listitem" style="list-style-type: disc">Now it checks whether any other user ID is also present in the <code class="literal">waiting_list</code> array, and if yes, then it sends the first user ID in the list and then removes all user IDs from the <code class="literal">waiting_list</code> array. If it doesn't find any other user ID in the <code class="literal">waiting_list</code> array, then it simply sends <code class="literal">404 error</code>.</li></ul></div><p>Now we are done building the backend of our website. Before we get into building the frontend of our site, make sure that you restart the server with the latest code.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Building the frontend</h2></div></div></div><p>First <a id="id158" class="indexterm"/>of all, as soon as the home page loads, we need to find the microphones and webcams connected to the user computer and list them so that the user can choose the desired device. The following is the code to do this. Place this code in the <code class="literal">main.js</code> file:</p><div><pre class="programlisting">window.addEventListener("load", function(){
  MediaStreamTrack.getSources(function(devices){
    var audioCount = 1;
    var videoCount = 1;

    for(var count = 0; count &lt; devices.length; count++)
    {
      if(devices[count].kind == "audio")
      {
        var name = "";

        if(devices[count].label == "")
        {
          name = "Microphone " + audioCount;
          audioCount++;
        }
        else
        {
          name = devices[count].label;
        }

        document.getElementById("audioInput").innerHTML = document.getElementById("audioInput").innerHTML + "&lt;option value='" + devices[count].id + "'&gt;" + name + "&lt;/option&gt;";
      }
      else if(devices[count].kind == "video")
      {
        var name = "";

        if(devices[count].label == "")
        {
          name = "Webcam " + videoCount;
          videoCount++;
        }
        else
        {
          name = devices[count].label;
        }

        document.getElementById("videoInput").innerHTML = document.getElementById("videoInput").innerHTML + "&lt;option value='" + devices[count].id + "'&gt;" + name + "&lt;/option&gt;";
      }
    }
  });
});</pre></div><p>Here <a id="id159" class="indexterm"/>we are retrieving the audio and video input devices using <code class="literal">MediaStream.getSources</code> and populating the <code class="literal">&lt;select&gt;</code> tags so that the user can choose an option.</p><p>As soon as the home page loads, we also need to create a <code class="literal">Peer</code> instance. Here is the code to <a id="id160" class="indexterm"/>do this. Place this code in the <code class="literal">main.js</code> file:</p><div><pre class="programlisting">var peer = null;
var dc = null;
var mc = null;
var ms = null;
var rms = null;

window.addEventListener("load", function(){
  peer = new Peer({host: "localhost", port: 8080, path: "/signaling", debug: true}); 

  peer.on("disconnected", function(){

    var interval = setInterval(function(){
      if(peer.open == true || peer.destroyed == true)
      {
        clearInterval(interval);
      }
      else
      {
        peer.reconnect();
      }
    }, 4000)
  })

  peer.on("connection", function(dataConnection){
    if(dc == null || dc.open == false)
    {
      dc = dataConnection;

      dc.on("data", function(data){
        document.getElementById("messages").innerHTML = document.getElementById("messages").innerHTML + "&lt;li&gt;&lt;span class='right'&gt;" + data + "&lt;/span&gt;&lt;div class='clear'&gt;&lt;/div&gt;&lt;/li&gt; ";
        document.getElementById("messages-container").scrollTop = document.getElementById("messages-container").scrollHeight;
      })

      dc.on("close", function(){
        document.getElementById("messages").innerHTML = "";
      })
    }
    else
    {
      dataConnection.close();
    }
  })

  peer.on("call", function(mediaConnection){
    if(mc == null || mc.open == false)
    {
      mc = mediaConnection;
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
      navigator.getUserMedia({video: true, audio: true}, function(mediaStream) {
        ms = mediaStream;
        mc.answer(mediaStream);
        mc.on("stream", function(remoteStream){
          rms = remoteStream;
          document.getElementById("peerVideo").setAttribute("src", URL.createObjectURL(remoteStream));
          document.getElementById("peerVideo").play();
        })

      }, function(e){ alert("An error occured while retrieving webcam and microphone stream"); })
    }
    else
    {
      mediaConnection.close();
    }
  })
});</pre></div><p>Here <a id="id161" class="indexterm"/>is how the code works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First we declared five global variables. <code class="literal">peer</code> will hold reference for the <code class="literal">Peer</code> instance, <code class="literal">dc</code> will hold reference for <code class="literal">DataConnection</code>, <code class="literal">mc</code> will hold reference for  <code class="literal">MediaConnection</code>, <code class="literal">ms</code> will hold reference for the local <code class="literal">MediaStream</code>, and <code class="literal">rms</code> will hold reference for the remote <code class="literal">MediaStream</code>.</li><li class="listitem" style="list-style-type: disc">Then, as soon as the page finished loading, we connected to PeerServer, creating a <code class="literal">Peer</code> instance and attaching event handlers for the <code class="literal">disconnected</code>, <code class="literal">connection</code>, and <code class="literal">call</code> event handlers.</li><li class="listitem" style="list-style-type: disc">Then we made sure that in case a peer gets disconnected from PeerServer due to some reason, then it automatically tries to connect to PeerServer.</li><li class="listitem" style="list-style-type: disc">If another peer tries to establish <code class="literal">DataConnection</code> with us, then we will only accept it if there is no other <code class="literal">DataConnection</code> currently established, otherwise we will reject it. After accepting <code class="literal">DataConnection</code>, we attached the event handlers for the <code class="literal">data</code> and <code class="literal">close</code> events to print the incoming messages in the chat box, and clear all messages in the chat box if <code class="literal">DataConnection</code> is closed.</li><li class="listitem" style="list-style-type: disc">Similarly, if another peer tries to establish <code class="literal">MediaConnection</code> with us, we will only accept it if there is no other <code class="literal">MediaConnection</code> currently established, otherwise we will reject it. After accepting the <code class="literal">MediaConnection</code>, we will attach the event handler for the <code class="literal">stream</code> event so that when remote <code class="literal">MediaStream</code> arrives, we can display it.</li></ul></div><p>In the <a id="id162" class="indexterm"/>preceding code, we are waiting for another peer to establish <code class="literal">DataConnection</code> and <code class="literal">MediaConnection</code> with us.</p><p>Now let's write a code to find a free peer and establish <code class="literal">DataConnection</code> and <code class="literal">MediaConnection</code> with it. The following is the code for this. Place this code in the <code class="literal">main.js</code> file:</p><div><pre class="programlisting">function ajaxRequestObject()
{
  var request;
  if(window.XMLHttpRequest)
  {
    request = new XMLHttpRequest();
  }
  else if(window.ActiveXObject) 
  {
    try 
    {
      request = new ActiveXObject('Msxml2.XMLHTTP');
    }
    catch (e)
    {
      request = new ActiveXObject('Microsoft.XMLHTTP');
    }
  }

  return request;
}

function connectToNextPeer()
{
  var request = ajaxRequestObject();

  var url = "/find?id=" + peer.id;

  request.open("GET", url);

  request.addEventListener("load", function(){
    if(request.readyState === 4) 
    {
      if(request.status === 200) 
      {
        dc = peer.connect(request.responseText, {reliable: true, ordered: true});

        dc.on("data", function(data){
          document.getElementById("messages").innerHTML = document.getElementById("messages").innerHTML + 
          "&lt;li&gt;&lt;span class='right'&gt;" + data + "&lt;/span&gt;&lt;div class='clear'&gt;&lt;/div&gt;&lt;/li&gt;";
          document.getElementById("messages-container").scrollTop = document.getElementById("messages-container").scrollHeight;
        })

        dc.on("close", function(){
          document.getElementById("messages").innerHTML = "";
        })

        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        
        var audioInputID = document.getElementById("audioInput").options[document.getElementById("audioInput").selectedIndex].value;
        var videoInputID = document.getElementById("videoInput").options[document.getElementById("videoInput").selectedIndex].value;

        navigator.getUserMedia({video: {mandatory: {sourceId: videoInputID}}, audio: {mandatory: {sourceId: audioInputID}}}, function(mediaStream) {
          ms = mediaStream;

          if(document.getElementById("audioToggle").checked)
          {
            var tracks = ms.getAudioTracks();
            if(document.getElementById("audioToggle").checked)
            {
              tracks[0].enabled = true;
            }
            else
            {
              tracks[0].enabled = false;
            }
          }

          if(document.getElementById("videoToggle").checked)
          {
            var tracks = ms.getVideoTracks();
            if(document.getElementById("videoToggle").checked)
            {
              tracks[0].enabled = true;
            }
            else
            {
              tracks[0].enabled = false;
            }
          }

          mc = peer.call(request.responseText, ms);

          mc.on("stream", function(remoteStream){
            rms = remoteStream;
            document.getElementById("peerVideo").setAttribute("src", URL.createObjectURL(remoteStream));
            document.getElementById("peerVideo").play();
          })

        }, function(e){ alert("An error occured while retrieving webcam and microphone stream"); });

      }
    }
  }, false);

  request.send(null);
}

function communication()
{
  if(peer != null &amp;&amp; peer.disconnected == false &amp;&amp; peer.destroyed == false)
  {
    if(dc == null || mc == null || dc.open == false || mc.open == false)
    {
      connectToNextPeer();
    }
  }
}

setInterval(communication, 4000);</pre></div><p>This <a id="id163" class="indexterm"/>code is long but easy to understand. Here is how the code works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First we defined a <code class="literal">ajaxRequestObject()</code> function that just returns an AJAX object and hides browser differences by creating an AJAX object.</li><li class="listitem" style="list-style-type: disc">Then we defined the <code class="literal">connectToNextPeer()</code> method that makes requests for a free ID from the <code class="literal">/next</code> path, and if found, it establishes <code class="literal">DataConnection</code> and <code class="literal">MediaConnection</code> with this peer. It also attaches the necessary event handlers that are same as the previous code.</li><li class="listitem" style="list-style-type: disc">While retrieving <code class="literal">MediaStream</code>, it uses the device selected by the user in the dropdown.</li><li class="listitem" style="list-style-type: disc">Before calling the other peer, it sets the <code class="literal">enabled</code> property to <code class="literal">true</code> or <code class="literal">false</code>, depending on whether the checkbox is checked or not respectively.</li><li class="listitem" style="list-style-type: disc">Finally, we set a timer that calls the <code class="literal">connectToNext()</code> peer once in every four second if the peer is connected to PeerServer, and <code class="literal">MediaConnection</code> or <code class="literal">DataConnection</code> is currently not established with another peer.</li></ul></div><p>Now we need to write code to send the message to a connected peer when the user presses the <em>Enter</em> key on the text input fields of the message box. Here is the code to do this. Place this code in the <code class="literal">main.js</code> file:</p><div><pre class="programlisting">document.getElementById("message-input-box").addEventListener("keypress", function(){
  if(dc != null &amp;&amp; dc.open == true)
  {
    var key = window.event.keyCode;
    if (key == 13) 
    {
      var message = document.getElementById("message-input-box").value;
      document.getElementById("message-input-box").value = "";
      dc.send(message);
      document.getElementById("messages").innerHTML = document.getElementById("messages").innerHTML + "&lt;li&gt;&lt;span class='left'&gt;" + message + "&lt;/span&gt;&lt;div class='clear'&gt;&lt;/div&gt;&lt;/li&gt; ";
      document.getElementById("messages-container").scrollTop = document.getElementById("messages-container").scrollHeight;
    }
    else
    {
      return;
    }
  }
})</pre></div><p>Here, at <a id="id164" class="indexterm"/>first, we are checking whether <code class="literal">DataConnection</code> is established or not. If <code class="literal">DataConnection</code> is currently established, then we will send a message to the connected peer and also display the message in the message box.</p><p>Now we need to write the code to pause or resume audio and video when the user toggles the checkboxes. The following is the code to do this. Place this code in the <code class="literal">main.js</code> file:</p><div><pre class="programlisting">document.getElementById("videoToggle").addEventListener("click", function(){
  if(ms !== null)
  {
    var tracks = ms.getVideoTracks();

    if(document.getElementById("videoToggle").checked)
    {
      tracks[0].enabled = true;
    }
    else
    {
      tracks[0].enabled = false;
    }
  }
});

document.getElementById("audioToggle").addEventListener("click", function(){
  if(ms !== null)
  {
    var tracks = ms.getAudioTracks();

    if(document.getElementById("audioToggle").checked)
    {
      tracks[0].enabled = true;
    }
    else
    {
      tracks[0].enabled = false;
    }
  }
});</pre></div><p>Here we are achieving this functionality by assigning <code class="literal">true</code> or <code class="literal">false</code> to the enabled property of the tracks.</p><p>We need <a id="id165" class="indexterm"/>to close <code class="literal">MediaConnection</code> and <code class="literal">DataConnection</code> and find another user for chatting when the user clicks on the <strong>Next User</strong> button. The following is the code to do this. Place this code in the <code class="literal">main.js</code> file:</p><div><pre class="programlisting">document.getElementById("next").addEventListener("click", function(){
  if(mc != null)
  {
    mc.close();
  }

  if(dc != null)
  {
    dc.close();
  }

  connectToNextPeer();  
})</pre></div><p>If there is any <code class="literal">MediaConnection</code> or <code class="literal">DataConnection</code> currently established, then we are closing it. Then we will call the <code class="literal">connectToNextPeer()</code> method to establish <code class="literal">MediaConnection</code> and <code class="literal">DataConnection</code>.</p><p>Now we finally need to display the status of the peer-to-peer connection and PeerServer connection. Here is the code to do this. Place this code in the <code class="literal">main.js</code> file:</p><div><pre class="programlisting">setInterval(function(){
  if(dc == null || mc == null || dc.open == false || mc.open == false)
  {
    document.getElementById("peerStatus").innerHTML = "Waiting for a free peer";
  }
  else
  {
    document.getElementById("peerStatus").innerHTML = "Connected to a peer";
  }

  if(peer != null &amp;&amp; peer.disconnected == false &amp;&amp; peer.destroyed == false)
  {
    document.getElementById("peerServerStatus").innerHTML = "Connected to PeerServer";
  }
  else
  {
    document.getElementById("peerServerStatus").innerHTML = "Not connected to PeerServer";
  }
}, 4000);</pre></div><p>Here we are checking and updating the status every <code class="literal">4</code> seconds.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Testing the website</h3></div></div></div><p>To test <a id="id166" class="indexterm"/>the chatroulette website we just created, first make sure that the server is running and then open the <code class="literal">http://localhost:8080/</code> URL in two different tabs, browsers, or devices.</p><p>Now you will see that both of them automatically get connected and are able to chat with each other.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we saw how to build a chatroulette using our own instance of PeerServer that is integrated with Express. The website we build had almost all the features that a chatroulette should have. You can now add features such as screen sharing, connecting users of particular a gender with each other, connecting users of a particular age, integrating captcha to prevent spam, and other features of your choice.</p><p>At the time of writing, the WebRTC team is working on an API that allows you to retrieve a stream from a screen for screen sharing. As this API is still under development, you can use browser plugins to retrieve a stream from a screen. You can find more about retrieving a stream from a screen using the plugins at <a class="ulink" href="https://www.webrtc-experiment.com/Pluginfree-Screen-Sharing/">https://www.webrtc-experiment.com/Pluginfree-Screen-Sharing/</a>.</p><p>In the next chapter, we will discuss bidirectional communication between the client and the server in real time using WebSockets.</p></div></body></html>