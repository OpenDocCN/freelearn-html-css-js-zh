- en: Chapter 4. Architecting an Ext JS Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you're only developing one application or plan to develop many, it's
    an excellent idea to consider your application architecture well in advance. The
    architecture is the internal structure of your application and the programming
    patterns employed within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, following commonly used patterns provides continuity and consistency
    in your applications. This gives us four major advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The framework and your applications are easier to learn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes less time to switch between applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code sharing between applications is possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You gain consistency among your build and testing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As this chapter covers application architecture with Ext JS, the core topics
    we''re going to look at are:'
  prefs: []
  type: TYPE_NORMAL
- en: Sencha Cmd and how it can be used to help us build our apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Model-View-Controller** (**MVC**) architectural pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The newly introduced **Model-View-ViewModel** (**MVVM**) architectural pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-class communication with an event-driven model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considerations for taking your application offline and an offline first design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ext JS 5 now provides support for both MVC and MVVM application architectures.
    Essentially, the two patterns split the application, resulting in well-organized
    code in a well-organized file system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the most from Sencha Cmd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We described how to get started with Sencha Cmd in [Chapter 1](ch01.html "Chapter 1. Getting
    to Know Ext JS"), *Getting to Know Ext JS*, but it is possible to do a lot more
    with it. In this section, we will explore some of its powerful commands and how
    they can speed up and improve our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Generating application components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sencha Cmd can help by generating MVC/MVVM components to speed up the development
    process and allow us to focus on our application's logic rather than writing repetitive
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Generating models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a model to your application, make `/path/to/MyWorkspace/BizDash` your
    current directory and run Sencha Cmd, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command adds a `model` class in a `User.js` file in the `model` directory.
    The file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Generating views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a view to your application in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app/view/Location/`: The folder for the classes implementing the new view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.js`: The new view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapModel.js`: The `Ext.app.ViewModel` for the new view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapController.js`: The `Ext.app.ViewController` for the new view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output from the preceding code for `Map.js` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The ViewController (`MapController.js`) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no required parameters in this case beyond the view name. You can,
    however, add a base class if desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will change the extend used by the view class to `Ext.tab.Panel`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Ext JS 5, each view generated by Sencha Cmd has a default `Ext.app.ViewController`,
    so it is not necessary to generate global controllers based on `Ext.app.Controller`
    in most cases. If you need a new controller, you can generate one in the same
    basic way as with Models and Views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a file called `Location.js` in the controller directory
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Upgrading your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As framework enhancements, features, and bug fixes are implemented, you may
    find yourself in a position where you wish to upgrade your application to a newer
    version of the framework. You can do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command will upgrade both, the Sencha Cmd scaffold and the framework used
    by the application. Complete instructions on upgrading your application are available
    in the framework documentation.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that reversing an upgrade operation isn't possible with Sencha
    Cmd. We recommend ensuring you are in a position to revert the upgrade changes
    in your version control system before starting.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing application metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following command regenerates the metadata file containing *bootstrap* data
    for the dynamic loader and class system. This must be done any time a class is
    added, renamed or removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Triggering automatic builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `watch` command is extremely useful as it watches your code base for changes
    (edits, deletes, and so on) and triggers a rebuild of the application to speed
    up the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the following command, a web server is started to host the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default port of the web server is 1841.
  prefs: []
  type: TYPE_NORMAL
- en: MVC and MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next part of the chapter is going to focus on the architectural patterns
    that work best with Ext JS applications. Sencha was the pioneer of MVC in web
    applications when it introduced the latter in the early versions of Sencha Touch.
    Since then, MVC (and MVVM) has gained traction and popularity in the web development
    community as web apps become larger, more complicated, and harder to maintain.
    One of the main purposes of these application architectures is to provide structure
    and consistency to your code base. Nowadays, most major frameworks support them,
    and the same is true of Ext JS.
  prefs: []
  type: TYPE_NORMAL
- en: We will explain what MVC and MVVM are, their pros and cons, and how they work
    in a typical Ext JS application.
  prefs: []
  type: TYPE_NORMAL
- en: What is MVC?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC) is an architectural pattern for writing software.
    It splits the user interface of an application into three distinct parts, which
    helps organize the code base into logical representations of information, depending
    upon the function. In an Ext JS application, the end result of this paradigm is
    to have well-organized code and a well-organized filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the abbreviations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, MVC implementations vary slightly between applications, but in general,
    each part of the architecture has specific responsibilities. In MVC architecture,
    every object in the program is a model, a view, or a controller.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Model represents the data we are planning to use within the application.
    It describes a common format for the data—in most cases simple fields—but it may
    also contain business rules, validation logic, conversions, formatting rules,
    and various other functions.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The View visually represents the data to the user. It is defined using the standard
    JSON configuration of Ext JS by extending a framework component/widget. For example,
    a typical view may be a grid, a form, or a chart.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that more than one view may display the same data in different
    ways. For example, a chart and a grid look visually different even though they
    share the same data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Best practices dictate that little, if any, business logic exists in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Controller is the central piece of an MVC application. It is a singular
    construct and responds to the events in the application and delegates commands
    between the Model and the View. Due to the clear separation of concerns in MVC,
    a controller acts as a global message bus listening for events on configured components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram will give you a clearer picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controller](img/6626_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Putting this together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In your application, a user will interact with the views, which often contain
    data that is held in the models. The controller plays the pivotal role of monitoring
    the various interactions in the view and making the necessary updates to the model
    or view. Controllers hold almost all of the business logic of the application,
    leaving the views and models mostly unaware of each other. You can think of it
    as a Publish-Subscribe model for an application.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS has specific classes to manage controllers and models, namely `Ext.app.Controller`
    and `Ext.data.Model`. The views should be defined by extending framework widgets.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea to define your model first, as it contains the data you plan
    on using in the application. Simply extending the `Ext.data.Model` class with
    basic field configurations is all that is required to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, create a view by extending a component or widget. Try to avoid
    putting business logic in the view; instead, put the logic in the controller.
    For example, a button in a view should not contain event logic—it should be placed
    inside the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, create a controller by extending `Ext.app.Controller`. The controller
    may not be aware of the view, and in many cases, you will be required to manually
    get a reference to the view before you can do more work. Sencha's documentation
    on refs ([http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.app.Controller-cfg-refs](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.app.Controller-cfg-refs))
    and Component Query ([http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.ComponentQuery-method-query](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.ComponentQuery-method-query))
    explains this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS naming convention and directory structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sencha uses a clearly defined naming convention to keep all our files together.
    For example, as was explained in [Chapter 2](ch02.html "Chapter 2. Mastering the
    Framework's Building Blocks"), *Mastering the Framework's Building Blocks*, the
    class `BizDash.view.Main` correlates to a location in your filesystem. In this
    case, the file is called `Main.js` within the `view` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you store your models in the `model` directory, views in the `view`
    directory, and controllers in the `controller` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits and drawbacks of using MVC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a number of advantages of using MVC, which include:'
  prefs: []
  type: TYPE_NORMAL
- en: Consistency across applications, which reduces learning time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease of sharing code between applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to build optimized apps using Sencha's build tools when using MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the greatest advantage of MVC architecture is that it helps developers
    avoid writing excessively large files that are difficult to maintain. By clearly
    splitting the responsibilities of each piece of the application, the classes are
    stored in a directory structure that's consistent and easy to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, MVC architecture does come with its drawbacks. Controllers are globally
    scoped to the application in the Ext JS approach to MVC, which results in additional
    business logic to grab references to views, models, and other objects. Controllers
    could be written to watch any object at any time, so any given controller might
    have logic for both view A and view B, leading to additional confusion in large
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is another issue that crops up time and time again in MVC applications.
    In MVC models, views and controllers are supposed to be loosely coupled, but testing
    a controller necessitates some knowledge of the greater application. More often
    than not, unit testing requires the entire application to be launched in order
    to test the individual pieces. This is obviously cumbersome, time-consuming, and
    brittle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't fall into the trap of building applications with a relatively small number
    of controllers, each spanning thousands of lines of code. Ultimately, this causes
    poor performance and long-term maintenance issues.
  prefs: []
  type: TYPE_NORMAL
- en: What is MVVM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the MVC architecture clearly does have some major benefits, its drawbacks
    need addressing. The Model-View-ViewModel (MVVM) architecture is an answer. Sencha
    only introduced MVVM architecture support in Ext JS 5, so you will not be able
    to apply these principles to your Ext JS 4 or Sencha Touch 2 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS 5 still offers support for MVC, so upgrading from Ext JS 4 to 5 will
    not break your application. Sencha decided to support MVVM in Ext JS 5 to address
    the drawbacks of maintainability and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing the concerns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In theory, global controllers are very useful, but as you can see, they can
    be difficult to manage in practice. MVVM overcomes this by introducing a new class
    called `ViewModel`, which manages the data specific to the view. It does this
    using data bindings. This means we write less code, it's easier to maintain, and
    a lot easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the abbreviations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like MVC, MVVM is another architectural pattern for writing software. It's
    based on the MVC pattern, so a lot of this should be familiar.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The principle of a Model in MVVM architecture is the same as in MVC.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with the Model, the View is also the same in MVVM as it is in MVC. The only
    difference is that we must set up our data bindings for the view. This is done
    by adding a ViewModel to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Unlike MVC, MVVM architecture tightly couples views to their associated ViewModels
    and ViewControllers.
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ViewModel is the key difference between MVVM and MVC. In MVC, using events,
    our Controller is responsible for managing the communication between a Model and
    a View. In MVVM, the framework does the heavy lifting behind the scenes and does
    this using data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding is simply a mechanism to connect the user interface with the business
    logic. For instance, when the values in the UI are changed, the underlying data
    value in the model also changes.
  prefs: []
  type: TYPE_NORMAL
- en: The result of introducing ViewModels is that the Model and framework perform
    much more work than before, which minimizes the application logic required to
    manipulate the View.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ViewModel](img/6626_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A typical ViewModel may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ViewModels provide a bridge between the Models' data and its visual representation.
    They are tied closely to the views and provide the data that they represent.
  prefs: []
  type: TYPE_NORMAL
- en: Business logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's still the question of application logic, however. There are two options
    for this, but in general, your business logic should go in ViewControllers.
  prefs: []
  type: TYPE_NORMAL
- en: ViewControllers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A ViewController is very similar to a Controller, as it still uses a Publish-Subscribe
    model by listening for events. Where it differs is in how it's coupled to the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'A ViewController is:'
  prefs: []
  type: TYPE_NORMAL
- en: Scoped directly to a View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a one-to-one relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created for every instance of the View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This drastically reduces overheads, as your application doesn't have as many
    events and component references floating about. Memory leaks and state management
    are easier to identify and maintain, as the ViewController is tied to the View
    that referenced it.
  prefs: []
  type: TYPE_NORMAL
- en: '![ViewControllers](img/6626_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your ViewController will start off looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The alias defined here can be used in a View definition's controller configuration
    to tie the two classes together.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can, however, continue to use controllers for your application-wide message
    bus. They will continue to listen for events in multiple views just like in the
    MVC architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-class communication with events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your Ext JS application makes use of events to handle user interaction, but
    it is also easy to have your classes communicate with each other via events.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS is very mature in the way it handles events, as it's something that's
    been at the core of the framework since the beginning. It uses an observer pattern
    to allow your classes to publish events and others to subscribe to those events.
    Your subscribing class will have its logic triggered as soon as the publishing
    class fires the event. This paradigm is asynchronous and modular.
  prefs: []
  type: TYPE_NORMAL
- en: As we covered in [Chapter 2](ch02.html "Chapter 2. Mastering the Framework's
    Building Blocks"), *Mastering the Framework's Building Blocks*, the event-driven
    logic in Ext JS is handled by the `Ext.mixin.Observable` class.
  prefs: []
  type: TYPE_NORMAL
- en: Taking your application offline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building applications, developers often debate the problem of designing
    a system that's capable of working offline. Ext JS as a framework is designed
    to imitate the components and widgets one may typically see in a standard desktop
    environment. It gives us the tools we need to build truly rich applications and
    an experience that's similar, if not better, than a legacy desktop application.
    For web developers, the issue is that users are already used to working with software
    that's been designed "offline first" The same applies to many mobile or tablet
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take an e-mail client as an example: the desktop clients continue to work even
    when your data connection is lost. You can read e-mail, search, organize folders,
    and do much more. On the other hand, the equivalent web-based client is not likely
    to fare so well. Try it yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: Why should we design offline first?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from ensuring that the web is, and remains, a viable solution for delivering
    applications, there are many advantages of considering taking your applications
    offline:'
  prefs: []
  type: TYPE_NORMAL
- en: The most important fact is that *we go offline*. It might not be intended and
    it may not be desirable, but connectivity is sporadic and not always guaranteed.
    This might result in your user losing data or being unable to complete their job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't have ubiquitous Internet. We've got to work within the confines of
    our mobile and fixed line network providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile, remote working and accessing systems on the move are more popular than
    ever before. This trend is continuing, and most developers are required to consider
    this when developing new applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance is greatly enhanced as the user does much of the work locally, leaving
    your servers for other, more important tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliability and trust are improved, as your users see the application as something
    that doesn't come with the usual flaws.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, robustness is improved, as, for example, your server downtime doesn't
    necessarily mean application downtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, an offline first approach will enable you to deliver a better
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: What can we do about this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Different apps have different approaches and the difficulty rating of each
    is different. Common approaches, in order of simplest to most complex, are to:'
  prefs: []
  type: TYPE_NORMAL
- en: Warn the user they are offline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the user cached data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users minimal interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users full interaction with a complex application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we do this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of ways to achieve this in web applications, and choosing
    the right method for your application isn't straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Native packaging is an option, similar to that of hybrid mobile apps. It is
    possible to package your web applications with tools such as Embedded WebKit,
    Cordova, or Chrome/Firefox apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the web app manifest to define the details and APIs present in your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AppCache is useful to have the browser cache files and resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ServiceWorkers are useful if you need to do background processing; for example,
    data syncing. It's still early days for ServiceWorkers, but these might be ideal
    for many JavaScript developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LocalStorage is great for storing data in key-value pairs. Ext JS provides excellent
    support for working with LocalStorage, but be wary of its browser enforced storage
    limitations—typically around 5 MB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IndexedDB or WebSQL are other ways storing application data in the client side.
    WebSQL has been deprecated but IndexedDB is an extremely viable alternative and
    has excellent support from Ext JS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offline architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot to consider, and it goes without saying that clearly, an offline
    web application requires a different architecture.
  prefs: []
  type: TYPE_NORMAL
- en: You should always plan for the worst and hope for the best.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to the problem is to put all the state in the client and then sync
    it whenever possible. Essentially, you want to design your application to download
    and store files in cache on the user's hard disk and interact with locally stored
    data. In the background, the locally stored data is synced with your server through
    some form of proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syncing data with your backend is perhaps the trickiest part of developing an
    application with the offline first principle. Writing a sync protocol is a difficult
    and time-consuming process. You should consider using frameworks and tools, such
    as Hoodie, PouchDB, and remoteStorage.io to alleviate the problem that syncing
    causes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get the best results, we recommend that you follow these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Do it often and as soon as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer the minimal amount of data you can get away with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be prepared for unreliable data networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a strategy to manage conflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has focused on the principles of application architecture and
    some of the tools we have available in Ext JS 5 applications. We have covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Sencha Cmd to generate models, views, and controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC and MVVM architecture patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-class communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with offline data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter will deepen your knowledge further by introducing data packages
    in detail. A solid understanding of data modeling and stores will stand you in
    good stead to develop advanced web applications.
  prefs: []
  type: TYPE_NORMAL
