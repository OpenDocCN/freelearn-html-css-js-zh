- en: Chapter 4. Architecting an Ext JS Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。构建 Ext JS 应用程序架构
- en: Whether you're only developing one application or plan to develop many, it's
    an excellent idea to consider your application architecture well in advance. The
    architecture is the internal structure of your application and the programming
    patterns employed within it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是仅开发一个应用程序还是计划开发多个，提前考虑您的应用程序架构都是一个很好的主意。架构是您应用程序的内部结构以及其中使用的编程模式。
- en: 'Ultimately, following commonly used patterns provides continuity and consistency
    in your applications. This gives us four major advantages:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，遵循常用模式为您提供了应用程序中的连续性和一致性。这给我们带来了四个主要优势：
- en: The framework and your applications are easier to learn
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架和您的应用程序更容易学习
- en: It takes less time to switch between applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序之间切换所需时间更少
- en: Code sharing between applications is possible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序之间的代码共享是可能的
- en: You gain consistency among your build and testing tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在构建和测试工具之间获得一致性
- en: 'As this chapter covers application architecture with Ext JS, the core topics
    we''re going to look at are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章涵盖了使用 Ext JS 的应用程序架构，我们将要探讨的核心主题包括：
- en: Sencha Cmd and how it can be used to help us build our apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sencha Cmd 以及它如何帮助我们构建应用程序
- en: The **Model-View-Controller** (**MVC**) architectural pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）架构模式'
- en: The newly introduced **Model-View-ViewModel** (**MVVM**) architectural pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新引入的 **模型-视图-视图模型**（**MVVM**）架构模式
- en: Cross-class communication with an event-driven model
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件驱动模型进行跨类通信
- en: Considerations for taking your application offline and an offline first design
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑将您的应用程序离线以及离线优先设计
- en: Ext JS 5 now provides support for both MVC and MVVM application architectures.
    Essentially, the two patterns split the application, resulting in well-organized
    code in a well-organized file system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5 现在提供了对 MVC 和 MVVM 应用程序架构的支持。本质上，这两种模式将应用程序分割，从而在组织良好的文件系统中产生井然有序的代码。
- en: Getting the most from Sencha Cmd
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 充分利用 Sencha Cmd
- en: We described how to get started with Sencha Cmd in [Chapter 1](ch01.html "Chapter 1. Getting
    to Know Ext JS"), *Getting to Know Ext JS*, but it is possible to do a lot more
    with it. In this section, we will explore some of its powerful commands and how
    they can speed up and improve our workflow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。了解 Ext JS")中描述了如何使用 Sencha Cmd 开始，*了解 Ext JS*，但您可以使用它做更多的事情。在本节中，我们将探讨一些其强大的命令以及它们如何加快并改进我们的工作流程。
- en: Generating application components
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成应用程序组件
- en: Sencha Cmd can help by generating MVC/MVVM components to speed up the development
    process and allow us to focus on our application's logic rather than writing repetitive
    code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd 可以通过生成 MVC/MVVM 组件来帮助加快开发过程，并使我们能够专注于应用程序的逻辑而不是编写重复的代码。
- en: Generating models
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成模型
- en: 'To add a model to your application, make `/path/to/MyWorkspace/BizDash` your
    current directory and run Sencha Cmd, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模型添加到您的应用程序中，将 `/path/to/MyWorkspace/BizDash` 设置为当前目录并运行 Sencha Cmd，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command adds a `model` class in a `User.js` file in the `model` directory.
    The file looks like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在 `model` 目录中的 `User.js` 文件中添加一个 `model` 类。文件看起来像这样：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Generating views
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成视图
- en: 'Add a view to your application in the same way:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式将视图添加到您的应用程序中：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will generate the following files:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下文件：
- en: '`app/view/Location/`: The folder for the classes implementing the new view'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/view/Location/`：实现新视图的类的文件夹'
- en: '`Map.js`: The new view'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.js`：新视图'
- en: '`MapModel.js`: The `Ext.app.ViewModel` for the new view'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapModel.js`：新视图的 `Ext.app.ViewModel`'
- en: '`MapController.js`: The `Ext.app.ViewController` for the new view'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapController.js`：新视图的 `Ext.app.ViewController`'
- en: 'The output from the preceding code for `Map.js` is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为 `Map.js` 生成的输出如下：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The ViewController (`MapController.js`) is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ViewController (`MapController.js`) 是：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are no required parameters in this case beyond the view name. You can,
    however, add a base class if desired:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，除了视图名称之外没有必需的参数。然而，如果您愿意，可以添加一个基类：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will change the extend used by the view class to `Ext.tab.Panel`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变视图类使用的扩展为 `Ext.tab.Panel`。
- en: Generating controllers
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成控制器
- en: 'In Ext JS 5, each view generated by Sencha Cmd has a default `Ext.app.ViewController`,
    so it is not necessary to generate global controllers based on `Ext.app.Controller`
    in most cases. If you need a new controller, you can generate one in the same
    basic way as with Models and Views:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 5 中，由 Sencha Cmd 生成的每个视图都有一个默认的 `Ext.app.ViewController`，因此大多数情况下不需要基于
    `Ext.app.Controller` 生成全局控制器。如果您需要一个新的控制器，您可以使用与模型和视图相同的基本方式生成：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will generate a file called `Location.js` in the controller directory
    with the following content:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制器目录中生成一个名为 `Location.js` 的文件，其内容如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Upgrading your application
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级您的应用程序
- en: 'As framework enhancements, features, and bug fixes are implemented, you may
    find yourself in a position where you wish to upgrade your application to a newer
    version of the framework. You can do this with the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随着框架增强、功能和错误修复的实施，您可能会发现自己处于希望将应用程序升级到框架新版本的境地。您可以使用以下命令来完成此操作：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command will upgrade both, the Sencha Cmd scaffold and the framework used
    by the application. Complete instructions on upgrading your application are available
    in the framework documentation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将升级 Sencha Cmd 框架和应用程序使用的框架。有关升级应用程序的完整说明，请参阅框架文档。
- en: It is worth noting that reversing an upgrade operation isn't possible with Sencha
    Cmd. We recommend ensuring you are in a position to revert the upgrade changes
    in your version control system before starting.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，使用 Sencha Cmd 无法撤销升级操作。我们建议在开始之前，确保您能够在版本控制系统中撤销升级更改。
- en: Refreshing application metadata
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新应用程序元数据
- en: The following command regenerates the metadata file containing *bootstrap* data
    for the dynamic loader and class system. This must be done any time a class is
    added, renamed or removed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令重新生成包含动态加载器和类系统 *bootstrap* 数据的元数据文件。每次添加、重命名或删除类时，都必须执行此操作。
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Triggering automatic builds
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发自动构建
- en: The `watch` command is extremely useful as it watches your code base for changes
    (edits, deletes, and so on) and triggers a rebuild of the application to speed
    up the development process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch` 命令非常有用，因为它会监视您的代码库中的更改（编辑、删除等），并触发应用程序的重建以加快开发过程。'
- en: 'When you run the following command, a web server is started to host the application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行以下命令时，将启动一个 Web 服务器以托管应用程序：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default port of the web server is 1841.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器的默认端口是 1841。
- en: MVC and MVVM
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC 和 MVVM
- en: The next part of the chapter is going to focus on the architectural patterns
    that work best with Ext JS applications. Sencha was the pioneer of MVC in web
    applications when it introduced the latter in the early versions of Sencha Touch.
    Since then, MVC (and MVVM) has gained traction and popularity in the web development
    community as web apps become larger, more complicated, and harder to maintain.
    One of the main purposes of these application architectures is to provide structure
    and consistency to your code base. Nowadays, most major frameworks support them,
    and the same is true of Ext JS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一部分将重点关注与 Ext JS 应用程序配合最佳的建筑模式。当 Sencha 在 Sencha Touch 的早期版本中引入 MVC 时，它是
    Web 应用程序中 MVC 的先驱。从那时起，随着 Web 应用程序变得更大、更复杂、更难以维护，MVC（以及 MVVM）在 Web 开发社区中获得了动力和普及。这些应用程序架构的主要目的之一是为您的代码库提供结构和一致性。如今，大多数主要框架都支持它们，Ext
    JS 也是如此。
- en: We will explain what MVC and MVVM are, their pros and cons, and how they work
    in a typical Ext JS application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释 MVC 和 MVVM 是什么，它们的优缺点，以及它们在典型的 Ext JS 应用程序中的工作方式。
- en: What is MVC?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 MVC？
- en: Model-View-Controller (MVC) is an architectural pattern for writing software.
    It splits the user interface of an application into three distinct parts, which
    helps organize the code base into logical representations of information, depending
    upon the function. In an Ext JS application, the end result of this paradigm is
    to have well-organized code and a well-organized filesystem.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）是编写软件的架构模式。它将应用程序的用户界面分为三个不同的部分，有助于将代码库组织成基于功能的逻辑信息表示。在 Ext JS
    应用程序中，这种范式的结果是拥有组织良好的代码和文件系统。
- en: Explaining the abbreviations
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释缩写
- en: Sometimes, MVC implementations vary slightly between applications, but in general,
    each part of the architecture has specific responsibilities. In MVC architecture,
    every object in the program is a model, a view, or a controller.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，MVC 实现在不同应用程序之间可能略有不同，但一般来说，架构的每个部分都有特定的职责。在 MVC 架构中，程序中的每个对象都是一个模型、一个视图或一个控制器。
- en: Model
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模型
- en: The Model represents the data we are planning to use within the application.
    It describes a common format for the data—in most cases simple fields—but it may
    also contain business rules, validation logic, conversions, formatting rules,
    and various other functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模型代表我们在应用程序中计划使用的数据。它描述了数据的通用格式——在大多数情况下是简单的字段，但它也可能包含业务规则、验证逻辑、转换、格式化规则和各种其他功能。
- en: View
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 视图
- en: The View visually represents the data to the user. It is defined using the standard
    JSON configuration of Ext JS by extending a framework component/widget. For example,
    a typical view may be a grid, a form, or a chart.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 视图从视觉上向用户展示数据。它使用Ext JS的标准JSON配置通过扩展框架组件/小部件来定义。例如，一个典型的视图可能是一个网格、一个表单或一个图表。
- en: It is possible that more than one view may display the same data in different
    ways. For example, a chart and a grid look visually different even though they
    share the same data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有多个视图以不同的方式显示相同的数据。例如，尽管图表和网格在视觉上不同，但它们共享相同的数据。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Best practices dictate that little, if any, business logic exists in the view.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践规定，视图中几乎不存在任何业务逻辑。
- en: Controller
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制器
- en: The Controller is the central piece of an MVC application. It is a singular
    construct and responds to the events in the application and delegates commands
    between the Model and the View. Due to the clear separation of concerns in MVC,
    a controller acts as a global message bus listening for events on configured components.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是MVC应用程序的核心部分。它是一个单一的结构，响应应用程序中的事件，并在模型和视图之间委派命令。由于MVC中关注点的清晰分离，控制器充当一个全局的消息总线，监听配置组件上的事件。
- en: 'The following diagram will give you a clearer picture:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表将为你提供一个更清晰的画面：
- en: '![Controller](img/6626_04_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![控制器](img/6626_04_01.jpg)'
- en: Putting this together
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将这些内容整合起来
- en: In your application, a user will interact with the views, which often contain
    data that is held in the models. The controller plays the pivotal role of monitoring
    the various interactions in the view and making the necessary updates to the model
    or view. Controllers hold almost all of the business logic of the application,
    leaving the views and models mostly unaware of each other. You can think of it
    as a Publish-Subscribe model for an application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，用户将与视图交互，这些视图通常包含存储在模型中的数据。控制器在监控视图中的各种交互并更新模型或视图方面发挥着关键作用。控制器几乎包含应用程序的所有业务逻辑，使得视图和模型之间大部分互不干扰。你可以将其视为应用程序的发布-订阅模型。
- en: Ext JS has specific classes to manage controllers and models, namely `Ext.app.Controller`
    and `Ext.data.Model`. The views should be defined by extending framework widgets.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS有特定的类来管理控制器和模型，即`Ext.app.Controller`和`Ext.data.Model`。视图应通过扩展框架小部件来定义。
- en: It's a good idea to define your model first, as it contains the data you plan
    on using in the application. Simply extending the `Ext.data.Model` class with
    basic field configurations is all that is required to get you started.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 定义模型是一个好主意，因为它包含了你计划在应用程序中使用的数据。只需通过基本的字段配置扩展`Ext.data.Model`类，就可以开始使用。
- en: Following this, create a view by extending a component or widget. Try to avoid
    putting business logic in the view; instead, put the logic in the controller.
    For example, a button in a view should not contain event logic—it should be placed
    inside the controller.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 依据此原则，通过扩展组件或小部件来创建视图。尽量避免在视图中放置业务逻辑；相反，将逻辑放在控制器中。例如，视图中的一个按钮不应包含事件逻辑——它应该放在控制器内部。
- en: Finally, create a controller by extending `Ext.app.Controller`. The controller
    may not be aware of the view, and in many cases, you will be required to manually
    get a reference to the view before you can do more work. Sencha's documentation
    on refs ([http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.app.Controller-cfg-refs](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.app.Controller-cfg-refs))
    and Component Query ([http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.ComponentQuery-method-query](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.ComponentQuery-method-query))
    explains this in more detail.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过扩展`Ext.app.Controller`来创建控制器。控制器可能不知道视图，在许多情况下，在你可以进行更多工作之前，你需要手动获取视图的引用。Sencha关于refs([http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.app.Controller-cfg-refs](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.app.Controller-cfg-refs))和组件查询([http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.ComponentQuery-method-query](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.ComponentQuery-method-query))的文档详细解释了这一点。
- en: Ext JS naming convention and directory structure
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ext JS的命名规范和目录结构
- en: Sencha uses a clearly defined naming convention to keep all our files together.
    For example, as was explained in [Chapter 2](ch02.html "Chapter 2. Mastering the
    Framework's Building Blocks"), *Mastering the Framework's Building Blocks*, the
    class `BizDash.view.Main` correlates to a location in your filesystem. In this
    case, the file is called `Main.js` within the `view` directory.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha使用明确的命名规范来保持所有文件在一起。例如，正如在[第2章](ch02.html "第2章. 掌握框架的构建块")中解释的，*掌握框架的构建块*，类`BizDash.view.Main`与你的文件系统中的一个位置相关联。在这种情况下，文件被命名为`Main.js`，位于`view`目录中。
- en: Ensure that you store your models in the `model` directory, views in the `view`
    directory, and controllers in the `controller` directory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将你的模型存储在`model`目录中，视图存储在`view`目录中，控制器存储在`controller`目录中。
- en: The benefits and drawbacks of using MVC
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MVC的优缺点
- en: 'There are a number of advantages of using MVC, which include:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MVC有许多优点，包括：
- en: Consistency across applications, which reduces learning time
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用之间的连贯性，这减少了学习时间
- en: Ease of sharing code between applications
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用之间共享代码的便利性
- en: Ability to build optimized apps using Sencha's build tools when using MVC
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用MVC时，使用Sencha的构建工具构建优化应用的能
- en: However, the greatest advantage of MVC architecture is that it helps developers
    avoid writing excessively large files that are difficult to maintain. By clearly
    splitting the responsibilities of each piece of the application, the classes are
    stored in a directory structure that's consistent and easy to work with.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MVC架构最大的优势在于它帮助开发者避免编写过大且难以维护的文件。通过明确划分应用每个组件的责任，类被存储在一致且易于工作的目录结构中。
- en: Sadly, MVC architecture does come with its drawbacks. Controllers are globally
    scoped to the application in the Ext JS approach to MVC, which results in additional
    business logic to grab references to views, models, and other objects. Controllers
    could be written to watch any object at any time, so any given controller might
    have logic for both view A and view B, leading to additional confusion in large
    applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，MVC架构确实有其缺点。在Ext JS的MVC方法中，控制器是全局作用域的，这导致需要额外的业务逻辑来获取对视图、模型和其他对象的引用。控制器可以编写为在任何时候监视任何对象，因此任何给定的控制器可能既有视图A的逻辑，也有视图B的逻辑，这在大应用中会导致额外的混淆。
- en: Unit testing is another issue that crops up time and time again in MVC applications.
    In MVC models, views and controllers are supposed to be loosely coupled, but testing
    a controller necessitates some knowledge of the greater application. More often
    than not, unit testing requires the entire application to be launched in order
    to test the individual pieces. This is obviously cumbersome, time-consuming, and
    brittle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是MVC应用中反复出现的问题。在MVC模型中，视图和控制器应该是松散耦合的，但测试控制器需要了解更大的应用。很多时候，单元测试需要启动整个应用来测试单个组件。这显然是繁琐的、耗时的，并且容易出错。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't fall into the trap of building applications with a relatively small number
    of controllers, each spanning thousands of lines of code. Ultimately, this causes
    poor performance and long-term maintenance issues.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要陷入构建具有相对较少控制器、每个控制器跨越数千行代码的应用程序的陷阱。最终，这会导致性能不佳和长期维护问题。
- en: What is MVVM?
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是MVVM？
- en: While the MVC architecture clearly does have some major benefits, its drawbacks
    need addressing. The Model-View-ViewModel (MVVM) architecture is an answer. Sencha
    only introduced MVVM architecture support in Ext JS 5, so you will not be able
    to apply these principles to your Ext JS 4 or Sencha Touch 2 applications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MVC架构确实有一些主要优点，但其缺点也需要解决。模型-视图-视图模型（MVVM）架构是一个解决方案。Sencha仅在Ext JS 5中引入了MVVM架构支持，因此你无法将这些原则应用于你的Ext
    JS 4或Sencha Touch 2应用。
- en: Ext JS 5 still offers support for MVC, so upgrading from Ext JS 4 to 5 will
    not break your application. Sencha decided to support MVVM in Ext JS 5 to address
    the drawbacks of maintainability and testing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5仍然支持MVC，因此从Ext JS 4升级到5不会破坏你的应用。Sencha决定在Ext JS 5中支持MVVM架构，以解决可维护性和测试的缺点。
- en: Addressing the concerns
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决关注点
- en: In theory, global controllers are very useful, but as you can see, they can
    be difficult to manage in practice. MVVM overcomes this by introducing a new class
    called `ViewModel`, which manages the data specific to the view. It does this
    using data bindings. This means we write less code, it's easier to maintain, and
    a lot easier to test.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，全局控制器非常有用，但如您所见，在实际中它们可能很难管理。MVVM通过引入一个名为`ViewModel`的新类来克服这一点，该类管理特定于视图的数据。它是通过数据绑定来做到这一点的。这意味着我们编写的代码更少，更容易维护，并且测试起来更容易。
- en: Explaining the abbreviations
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释缩写
- en: Just like MVC, MVVM is another architectural pattern for writing software. It's
    based on the MVC pattern, so a lot of this should be familiar.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像MVC一样，MVVM是另一种用于编写软件的架构模式。它基于MVC模式，因此其中很多内容应该都很熟悉。
- en: Model
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模型
- en: The principle of a Model in MVVM architecture is the same as in MVC.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM架构中模型的原则与MVC中相同。
- en: View
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 视图
- en: 'As with the Model, the View is also the same in MVVM as it is in MVC. The only
    difference is that we must set up our data bindings for the view. This is done
    by adding a ViewModel to the view:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与模型一样，视图在MVVM中与MVC中相同。唯一的区别是我们必须为视图设置数据绑定。这是通过向视图中添加ViewModel来完成的：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Unlike MVC, MVVM architecture tightly couples views to their associated ViewModels
    and ViewControllers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与MVC不同，MVVM架构紧密地将视图与其关联的ViewModel和ViewController耦合在一起。
- en: ViewModel
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ViewModel
- en: The ViewModel is the key difference between MVVM and MVC. In MVC, using events,
    our Controller is responsible for managing the communication between a Model and
    a View. In MVVM, the framework does the heavy lifting behind the scenes and does
    this using data binding.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel是MVVM与MVC之间的关键区别。在MVC中，使用事件，我们的控制器负责管理模型和视图之间的通信。在MVVM中，框架在幕后进行大量工作，并使用数据绑定来完成这项工作。
- en: Data binding is simply a mechanism to connect the user interface with the business
    logic. For instance, when the values in the UI are changed, the underlying data
    value in the model also changes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是一种将用户界面与业务逻辑连接起来的机制。例如，当UI中的值发生变化时，模型中的底层数据值也会发生变化。
- en: The result of introducing ViewModels is that the Model and framework perform
    much more work than before, which minimizes the application logic required to
    manipulate the View.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 引入ViewModel的结果是模型和框架比以前做更多的工作，这最大限度地减少了操纵视图所需的应用程序逻辑。
- en: 'Have a look at the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表：
- en: '![ViewModel](img/6626_04_02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![ViewModel](img/6626_04_02.jpg)'
- en: 'A typical ViewModel may look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的ViewModel可能看起来像这样：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ViewModels provide a bridge between the Models' data and its visual representation.
    They are tied closely to the views and provide the data that they represent.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel在模型的数据和其视觉表示之间提供了一个桥梁。它们与视图紧密相关，并提供了它们所代表的数据。
- en: Business logic
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: There's still the question of application logic, however. There are two options
    for this, but in general, your business logic should go in ViewControllers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然存在应用程序逻辑的问题。有两个选项，但通常，您的业务逻辑应该放在ViewController中。
- en: ViewControllers
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ViewController
- en: A ViewController is very similar to a Controller, as it still uses a Publish-Subscribe
    model by listening for events. Where it differs is in how it's coupled to the
    view.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ViewController非常类似于Controller，因为它仍然通过监听事件来使用发布-订阅模型。它与之不同的地方在于它与视图的耦合方式。
- en: 'A ViewController is:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ViewController的定义如下：
- en: Scoped directly to a View
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接关联到视图
- en: Has a one-to-one relationship
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有一对一的关系
- en: Created for every instance of the View
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个视图实例创建
- en: This drastically reduces overheads, as your application doesn't have as many
    events and component references floating about. Memory leaks and state management
    are easier to identify and maintain, as the ViewController is tied to the View
    that referenced it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这大大减少了开销，因为您的应用程序没有那么多事件和组件引用在浮动。由于ViewController与引用它的视图相关联，内存泄漏和状态管理更容易识别和维护。
- en: '![ViewControllers](img/6626_04_03.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![ViewControllers](img/6626_04_03.jpg)'
- en: 'Your ViewController will start off looking like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您的ViewController最初看起来可能如下所示：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The alias defined here can be used in a View definition's controller configuration
    to tie the two classes together.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处定义的别名可以在视图定义的控制器配置中使用，以将两个类关联起来。
- en: Controllers
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制器
- en: You can, however, continue to use controllers for your application-wide message
    bus. They will continue to listen for events in multiple views just like in the
    MVC architecture.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您仍然可以使用控制器来处理您应用程序的消息总线。它们将继续像MVC架构中一样在多个视图中监听事件。
- en: Cross-class communication with events
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件进行跨类通信
- en: Your Ext JS application makes use of events to handle user interaction, but
    it is also easy to have your classes communicate with each other via events.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Ext JS应用程序利用事件来处理用户交互，但也很容易让您的类通过事件相互通信。
- en: Ext JS is very mature in the way it handles events, as it's something that's
    been at the core of the framework since the beginning. It uses an observer pattern
    to allow your classes to publish events and others to subscribe to those events.
    Your subscribing class will have its logic triggered as soon as the publishing
    class fires the event. This paradigm is asynchronous and modular.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS在处理事件方面非常成熟，因为这是框架自始至终的核心。它使用观察者模式允许您的类发布事件，并让其他类订阅这些事件。一旦发布类触发事件，您的订阅类就会立即触发其逻辑。这种范式是异步和模块化的。
- en: As we covered in [Chapter 2](ch02.html "Chapter 2. Mastering the Framework's
    Building Blocks"), *Mastering the Framework's Building Blocks*, the event-driven
    logic in Ext JS is handled by the `Ext.mixin.Observable` class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.html "第2章。掌握框架的构建块")中所述，*掌握框架的构建块*，Ext JS中的事件驱动逻辑由`Ext.mixin.Observable`类处理。
- en: Taking your application offline
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的应用程序离线
- en: When building applications, developers often debate the problem of designing
    a system that's capable of working offline. Ext JS as a framework is designed
    to imitate the components and widgets one may typically see in a standard desktop
    environment. It gives us the tools we need to build truly rich applications and
    an experience that's similar, if not better, than a legacy desktop application.
    For web developers, the issue is that users are already used to working with software
    that's been designed "offline first" The same applies to many mobile or tablet
    apps.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，开发者经常争论设计一个能够离线工作的系统的问题。Ext JS作为一个框架，旨在模仿在标准桌面环境中可能看到的组件和小部件。它为我们提供了构建真正丰富应用程序和类似甚至优于传统桌面应用程序的体验所需的工具。对于Web开发者来说，问题是用户已经习惯了使用那些被设计为“首先离线”的软件。许多移动或平板电脑应用程序也是如此。
- en: 'Take an e-mail client as an example: the desktop clients continue to work even
    when your data connection is lost. You can read e-mail, search, organize folders,
    and do much more. On the other hand, the equivalent web-based client is not likely
    to fare so well. Try it yourself.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以电子邮件客户端为例：即使您的数据连接丢失，桌面客户端仍然可以继续工作。您可以阅读电子邮件，搜索，组织文件夹，做很多事情。另一方面，基于Web的等效客户端可能表现不佳。自己试试看。
- en: Why should we design offline first?
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们应该设计离线优先？
- en: 'Apart from ensuring that the web is, and remains, a viable solution for delivering
    applications, there are many advantages of considering taking your applications
    offline:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保网络始终是，并且继续是交付应用程序的有效解决方案之外，考虑将您的应用程序离线还有很多优势：
- en: The most important fact is that *we go offline*. It might not be intended and
    it may not be desirable, but connectivity is sporadic and not always guaranteed.
    This might result in your user losing data or being unable to complete their job.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的事实是*我们离线了*。这可能是无意为之，也可能不是我们所希望的，但连接性是间歇性的，并不总是可以保证的。这可能会导致您的用户丢失数据或无法完成他们的工作。
- en: We don't have ubiquitous Internet. We've got to work within the confines of
    our mobile and fixed line network providers.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有无处不在的互联网。我们必须在我们的移动和固定线路网络提供商的限制内工作。
- en: Mobile, remote working and accessing systems on the move are more popular than
    ever before. This trend is continuing, and most developers are required to consider
    this when developing new applications.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动、远程工作和在移动中访问系统比以往任何时候都更受欢迎。这一趋势仍在继续，大多数开发者在开发新应用程序时都需要考虑这一点。
- en: Performance is greatly enhanced as the user does much of the work locally, leaving
    your servers for other, more important tasks.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能得到了极大的提升，因为用户在本地做了大量工作，而您的服务器则可以用于其他更重要的任务。
- en: Reliability and trust are improved, as your users see the application as something
    that doesn't come with the usual flaws.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性和信任度得到了提升，因为您的用户将应用程序视为不带有通常缺陷的东西。
- en: Finally, robustness is improved, as, for example, your server downtime doesn't
    necessarily mean application downtime.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，鲁棒性得到了提升，例如，您的服务器宕机并不一定意味着应用程序会宕机。
- en: To summarize, an offline first approach will enable you to deliver a better
    user experience.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，采用离线优先的方法将使您能够提供更好的用户体验。
- en: What can we do about this?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们能做些什么呢？
- en: 'Different apps have different approaches and the difficulty rating of each
    is different. Common approaches, in order of simplest to most complex, are to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的应用有不同的方法，每个方法的难度等级也不同。按照从简单到复杂的顺序，常见的方法包括：
- en: Warn the user they are offline
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告用户他们处于离线状态
- en: Provide the user cached data
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用户缓存的数据库
- en: Allow users minimal interaction
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户进行最小程度的交互
- en: Allow users full interaction with a complex application
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户与复杂应用进行完全交互
- en: How can we do this?
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何做到这一点？
- en: There are a number of ways to achieve this in web applications, and choosing
    the right method for your application isn't straightforward.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用中有许多实现方式，为您的应用选择正确的方法并不简单。
- en: Native packaging is an option, similar to that of hybrid mobile apps. It is
    possible to package your web applications with tools such as Embedded WebKit,
    Cordova, or Chrome/Firefox apps.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生打包是一个选项，类似于混合移动应用。可以使用嵌入式 WebKit、Cordova 或 Chrome/Firefox 应用等工具打包您的网络应用。
- en: Using the web app manifest to define the details and APIs present in your app.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络应用清单来定义应用中存在的详细信息和 API。
- en: Using AppCache is useful to have the browser cache files and resources.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AppCache 有助于浏览器缓存文件和资源。
- en: ServiceWorkers are useful if you need to do background processing; for example,
    data syncing. It's still early days for ServiceWorkers, but these might be ideal
    for many JavaScript developers.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要进行后台处理，例如数据同步，ServiceWorkers 非常有用；对于许多 JavaScript 开发者来说，这些可能是理想的。
- en: LocalStorage is great for storing data in key-value pairs. Ext JS provides excellent
    support for working with LocalStorage, but be wary of its browser enforced storage
    limitations—typically around 5 MB.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LocalStorage 适用于以键值对的形式存储数据。Ext JS 为使用 LocalStorage 提供了出色的支持，但要注意其浏览器强制的存储限制——通常约为
    5 MB。
- en: IndexedDB or WebSQL are other ways storing application data in the client side.
    WebSQL has been deprecated but IndexedDB is an extremely viable alternative and
    has excellent support from Ext JS.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IndexedDB 或 WebSQL 是在客户端存储应用程序数据的其他方法。WebSQL 已被弃用，但 IndexedDB 是一个非常可行的替代方案，并且
    Ext JS 提供了出色的支持。
- en: Offline architecture
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离线架构
- en: There's a lot to consider, and it goes without saying that clearly, an offline
    web application requires a different architecture.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多需要考虑的因素，显然，一个离线网络应用需要不同的架构。
- en: You should always plan for the worst and hope for the best.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该总是为最坏的情况做准备，并希望最好的情况发生。
- en: One solution to the problem is to put all the state in the client and then sync
    it whenever possible. Essentially, you want to design your application to download
    and store files in cache on the user's hard disk and interact with locally stored
    data. In the background, the locally stored data is synced with your server through
    some form of proxy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是将所有状态放在客户端，并在可能的情况下同步它。本质上，你希望设计你的应用程序以在用户的硬盘上下载和存储文件到缓存，并与本地存储的数据交互。在后台，本地存储的数据通过某种形式的代理与服务器同步。
- en: Syncing data
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步数据
- en: Syncing data with your backend is perhaps the trickiest part of developing an
    application with the offline first principle. Writing a sync protocol is a difficult
    and time-consuming process. You should consider using frameworks and tools, such
    as Hoodie, PouchDB, and remoteStorage.io to alleviate the problem that syncing
    causes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与后端同步数据可能是采用离线优先原则开发应用程序中最棘手的部分。编写同步协议是一个困难且耗时的过程。你应该考虑使用框架和工具，如 Hoodie、PouchDB
    和 remoteStorage.io 来减轻同步引起的问题。
- en: 'In order to get the best results, we recommend that you follow these guidelines:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳结果，我们建议您遵循以下指南：
- en: Do it often and as soon as possible
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常做，并且尽可能快地做
- en: Transfer the minimal amount of data you can get away with
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能地传输最少的数据
- en: Be prepared for unreliable data networks
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备好不可靠的数据网络
- en: Have a strategy to manage conflicts
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定策略来管理冲突
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter has focused on the principles of application architecture and
    some of the tools we have available in Ext JS 5 applications. We have covered:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了应用程序架构的原则以及我们在 Ext JS 5 应用程序中可用的某些工具。我们涵盖了：
- en: Sencha Cmd to generate models, views, and controllers
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sencha Cmd 生成模型、视图和控制台
- en: MVC and MVVM architecture patterns
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC 和 MVVM 架构模式
- en: Cross-class communication
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨类通信
- en: Working with offline data
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与离线数据一起工作
- en: The next chapter will deepen your knowledge further by introducing data packages
    in detail. A solid understanding of data modeling and stores will stand you in
    good stead to develop advanced web applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过详细介绍数据包来进一步加深你的知识。对数据建模和存储的扎实理解将使你开发高级网络应用时处于有利地位。
