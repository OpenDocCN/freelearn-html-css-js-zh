- en: 5\. Interfaces and Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to interfaces and inheritance. You will learn how
    to use an interface to shape your classes, objects, and functions. You will also
    gain an appreciation of how interfaces will help you to write better code. By
    the end of this chapter, you will be able to write better, more maintainable code
    with well-structured functions, classes, and objects, and also be able to reuse
    your existing code efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter discussed classes and objects. You learned that classes
    define objects and their functionality. Classes are the blueprint followed while
    constructing these objects. Now, we will go up one level of abstraction. We are
    now going to construct interfaces. Interfaces are descriptors and allow you to
    define the structure of your object. Interfaces allow you to define contracts,
    which are rules that govern how your data is shaped.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are important because they enable your objects to be strongly typed,
    which gives you the ability to write cleaner code. Defining the shape of your
    objects may not be much of an issue with smaller applications, but when working
    with large applications, interfaces will prove their worth as they will make it
    possible for your application to scale without your code becoming confusing and
    hard to support.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance allows new objects to take the properties of existing objects, enabling
    you to extend your code functionality without having to redefine common properties.
    Inheritance will give you a better understanding of how you should structure your
    code to be more efficient and logical in your approach. This chapter will first
    address interfaces and equip you with the skills you need to use them and will
    then progress onto the topic of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we have an example of a simple interface that defines the shape of a user object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined an interface that we can implement on
    any object that should follow rules defined in our interface. The advantage this
    gives us over other web languages such as vanilla JavaScript is that all objects
    that implement this interface have to follow the structure defined by the interface.
    This means that our objects are now strongly typed and have language support such
    as syntax highlighting, autocompletion, and the throwing of exceptions when implemented
    incorrectly. If you are a developer working on a large application, this is very
    important as you have defined the rules and can now be sure that all the objects
    that implement `UserInterFace` will have the same properties as those defined
    in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an object that implements the `UserInterface` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, we are now able to implement an object
    that adheres to the guidelines defined in the `UserInterFace` interface. When
    working with large teams or on complex web applications, it is important to have
    transparent, well-understood rules for your code.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces allow for the creation of a common point of reference for your objects,
    a place where rules are defined on how objects should be constructed. In the following
    section, we will cover in-depth interfaces in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces are used when you want to set up rules for how your objects, classes,
    and functions should be implemented. They are a contract that governs structure
    but not functionality. Here we have a diagram that shows an interface and its
    relationship to two classes – `User` and `Admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Relation between interface and classes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Relation between interface and classes'
  prefs: []
  type: TYPE_NORMAL
- en: In the diagram, we have a user interface that describes how a class belonging
    to this interface should be implemented. As you can see, we have a few properties
    (highlighted code in User Interface) and methods provided in two classes. The
    interface provides only basic information for the property's name, type, method
    structures, and return types, if not void. Note that the interface provides no
    rules related to how the methods work, only how they are structured. The actual
    functionality of the methods is defined in the class itself. As stated earlier,
    interfaces in TypeScript give you the rules and you implement them as you see
    fit. This is evident from the preceding diagram. The `AdminUser` class has a method
    not defined in `UserInterface`; however, this is not an issue because the class
    is in compliance with all the elements of the interface. There is no rule that
    says that you cannot add to your class, only that you need to meet the requirements
    of the interface that your class implements.
  prefs: []
  type: TYPE_NORMAL
- en: Case Study – Writing Your First Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you are working with an application development team building an application
    for warehouse floor workers. You have the task of building the product creation
    classes and functions. You have developed a plan for your classes based on the
    functional requirements of your application. You start by creating a product interface
    called `ProductTemplate`. `ProductTemplate` defines the structure of our product
    object and base requirements. Note that we could also use a type object in the
    same way, and it may be preferable since this is a simple object, not a class,
    which could not be represented by a type. However, for the sake of this example
    and also to enlighten you to the fact that interfaces can also be used as types
    when defining a simple object, we have constructed the `ProductTemplate` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When defining an interface, we start with the interface keyword, followed by
    the name of our interface, `ProductTemplate`, as shown in the preceding snippet.
    We have three properties that our product requires – height, width, and color.
    Now that we have described what our product data should look like, let''s use
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have built a function, `productMaker`, that takes a product object as an
    argument. To ensure that only objects with the properties required by our `productMaker`
    function get passed to the function, we use our `ProductTemplate` interface, as
    shown in the preceding snippet. Now, all we need to do is define our product object;
    we will use our interface there as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have declared a product object, `myProduct`, with our `ProductTemplate` interface
    and added the properties required by our interface. Using the interface in this
    way ensures that we are fully compliant when creating the product object. Now,
    if we add a property not defined or remove a property that is defined in our `ProductTemplate`
    interface, the IDE and or TypeScript compiler will throw a helpful error message.
    IDE highlighting will depend on your IDE and the level of support for TypeScript.
    VS Code should highlight the following error messages for the preceding two scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following error message appears when you add a property length that is
    not defined in the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following error message appears when you don''t use the color property,
    which is defined in the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our product object, let''s pass it to our productMaker function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you run the file using `npx` `ts-node` `Example_Interface.ts`, you will
    obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the ideal scenario. But what would happen if you pass an object that
    does not comply with the `ProductTemplate` interface? Consider the following code
    representing this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will receive the following error message when you run the file using `tsc`
    `[filename].ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: VS Code prevents you from making such errors. If you hover over the red-underlined
    code in the VS Code window, you will see a warning similar to the preceding error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our interface example (`Example_Interface.ts`). Now, we have
    an interface for our product. Let''s do the same for our `productMaker` function.
    We want to make sure that whenever a function takes our product as an argument,
    it is constructed in the right way. Hence, we construct the following interface
    – `productInterfaceFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the function interface, `productInterfaceFunction`, just after `ProductTemplate`.
    As you can see, the syntax is simple and just defines what arguments the function
    can take and what it should return. We can now use the function interface in our
    function declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should again get the same output as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now used interfaces in two ways: to shape an object and a function.
    The only issue here is that it''s not very efficient to work this way. As good
    developers, we want to be as efficient as possible and comply with object-oriented
    standards of coding. To this end, we will now refactor our code to define a class
    that will encapsulate our product properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we have built an interface for our class where we
    have defined a `product` property and the makeProduct method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also making good use of the interfaces we created previously for our
    product object and `makeProduct`. Next, we will use the new interface, `ProductClassInterface`,
    to instantiate a new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are using the `implements` keyword to apply the
    interface rules to our `ProductClass`. The syntax structure is as follows: `class`
    `ProductClass` followed by the `implements` keyword, and then the interface you
    would like to apply to the class: `class ProductClass implements ProductClassInterface`.
    As you can see, this code is a bit less verbose and easy to manage. Using an interface
    to define our product class allows us to be more descriptive as we can not only
    define our class but the methods and properties associated with it.'
  prefs: []
  type: TYPE_NORMAL
- en: ype aliases can also be used in a similar manner, but types are more of a validator
    than a descriptor, hence it is recommended to use types more to verify objects
    returned from a function or arguments received by a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces and types can be used together, and they should be. However, how
    they are used, where they are used, and how they are applied in code is down to
    you, as they are similar in many respects and even more so in recent updates of
    the TypeScript language. Let''s now make a product object and use our class instance, `newProduct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we build a product object and then pass it to our
    class's `makeProduct` function. We then console out the results, which is the
    same as before, except now our functional code is wrapped in a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a basic understanding of how to implement an interface with
    TypeScript, let's build a more realistic product creation process in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Implementing Interfaces'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement an interface on an object, function, and
    class. Some of the code is verbose and you may not implement it this way in a
    real-world application. However, this exercise will expose you to the different
    ways in which you can implement interfaces in your code. We will construct a class
    that manages product objects and use interfaces to enforce rules related to how
    our class should be implemented. We will also use interfaces to shape our product
    object and class methods. In a typical web application, this code would probably
    be part of a product management interface – an inventory management application,
    for example. Alternativley, it could also be part of the product creation process,
    where you have a form that takes user data and processes it:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can be found here: [https://packt.link/SR8eg](https://packt.link/SR8eg).
    For this chapter, in order to run any TypeScript file, you need to go into the
    file directory and execute `npx ts-node filename.ts`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface called `ProductObjectTemplate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When creating an interface or a type object for that matter, you should take
    into consideration what are the common elements your interface or type will need.
    This could be based on the application requirements or dependent only on the functionality
    the application is required to have. `ProductObjectTemplate` is a simple object
    and, in most cases, should be a type, but in order to show that interfaces can
    also be used in this way, we have opted to make it an interface. As you can see,
    we have just defined some basic properties that we may have for a product – `height`,
    `width`, and `color`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the interface defined in the preceding step, define a function called
    `ProductClass`Template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding step, we used an interface to define a function and, by doing
    this, we are providing the rules on what arguments your function can take. This
    will ensure that any implementation of this function will only take `ProductObjectTemplate`
    as an argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build an interface for a class called `ProductClassTemplate`. Reuse `ProductFunctionTemplate`
    and `ProductObjectTemplate` in your new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding step, we are reusing the function and product interfaces defined
    in *Steps 1 and 2* to build our class interface. We can simplify the code in this
    step because we are reusing interfaces that we created in the first two steps.
    *Step 3* is a good example of how you can build complexity while also making your
    code less verbose.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `Product` class and implement our class interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this preceding step, we created our class implementing the `ProductClassTemplate`
    interface. This will ensure that our class adheres to the rules defined in our
    interface. We are also reusing the `ProductTemplate` interface to verify that
    our class method takes the right arguments and returns the correct data. In the
    previous steps, we did a bit of prep work setting up interfaces, and now we can
    reuse them in our code base, making the overall code easier to write, well supported,
    and understandable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instantiate our class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here again, we are making use of an interface, `ProductClassTemplate` to ensure
    the class we implement matches our ruleset.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we try to call `makeProduct` with an empty object, we get a helpful error
    message we can use to resolve our issue. Feel free to perform a test to make sure
    that your interfaces are working as they should. Here, we have the correct implementation
    of our class instance method, `makeProduct`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `makeProduct` method and provide a valid product object as defined
    in our product interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `allProducts` method and console out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `allProducts` method returns an array of products. This would be the equivalent
    of an API call that returns a list of products to your frontend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, console out the results of the `allProducts` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the file by executing `npx` `ts-node` `Exercise01.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will obtain the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you have followed the steps correctly, your output should be an array or
    product object as shown in the preceding screenshot. Interfaces provide you with
    the means to define contracts that govern how your code should be implemented,
    which is the point of a strongly typed language such as TypeScript and its main
    advantage over JavaScript. By using interfaces as shown in the exercise, we now
    have code that is less prone to errors and easier to support when working with
    large applications or on a large team. Interfaces can be invaluable to the development
    process if they are implemented correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Implementing Interfaces – Creating a Prototype Blogging Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you are a developer working on a social networking site. You are
    tasked with setting up a blogging system that will allow users to post to the
    site. The project is intended to scale up globally, so it will be quite large.
    Hence, your code needs to be well defined with all the necessary contexts. The
    main theme here is context. You are coding in a manner that will lead to bug-free
    code that is well supported and understood.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start with the main object – the blog post. In order to build a blogging
    system, we need to define what a blog post is. Because this is a simple object,
    we create a type alias, `BlogPost`. As mentioned previously, we can use an interface
    to define this object, but types are more suited to simple, non-complex objects.
    A type is more of a descriptor of a unit of something, for example, a number or
    a string, while an interface is more like directions on how to interact with something,
    not what it is:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can be found here: [https://packt.link/6uFmG](https://packt.link/6uFmG).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a blog type as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an interface called `AddToPost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This interface will serve as the main interface for the method we will use to
    add to our blog list. As we elaborated in the previous exercise, the `AddToPost`
    interface defines how we will interact with our main method and also what it will
    return when called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an interface to define a class, `BlogPostClass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we define our class interface. We know we need a place to hold our blogs,
    so we define an `allPost` global object that is of the `BlogPost` type array.
    We also define a method, `addToPost`, that implements the `AddPost` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a class called `blogPostClass` that implements the `blogPostClass` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding class, we reuse our type to enforce and validate. The logic
    of the `addToPost` method is up to you, the developer. In this step, the code
    implements the method once it adheres to the interface by taking an argument of
    the `BlogPost` type and returns a `BlogPost` array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an instance of `blogPostClass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build three objects of the `BlogPost` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This step simulates a user posting to your blog site. In a real-world application,
    this will be a web form that creates the object when submitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `addToPost` method three times and pass the post objects you created
    in *Step 6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In an actual web application, the call to `addToPost` would entail making an
    API call to send the updated data to the backend of your application, but for
    the purpose of this exercise, we are just updating an array. If, for example,
    you are using some kind of state management for your frontend, the preceding code
    could look very similar to the state management handling the backend updates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Console out the `allPost` global from the class instance created in *Step 5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the file by executing `npx ts-node Exercise02.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 5.03: Creating Interfaces for a Function for Updating a User Database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As part of a web app developer team, you have been tasked with building an
    interface for a function that will update a user database. In a real-world application,
    this function might be part of a user registration form that updates a user database
    via an API call. The requirements are simple: the function should take an argument
    of the `User` type, which consists of `email` and `userId` properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of this exercise, assume that you are just working out the logic
    of the function and that the code is just temporary for testing purposes before
    you implement it in your working application. As such, we will have an array that
    will represent the database, which will be preloaded with some user objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can be found here: [https://packt.link/XLIz9](https://packt.link/XLIz9).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a user type with `email` and `userId` properties, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a user type allows you to simplify your function interface. Now, you
    can reuse your `User` type when defining your interface in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build a function interface called `SuperAddMe`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In doing this, we have defined how we will interact with our function. This
    is a small thing, but now, all functions of this type will have set rules. We
    will know what it needs and what it will return.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Initialize an array of the `User` type and populate it with a few users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This array will simulate a database of users that we will add to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a function of the `SuperAddMe` interface type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When implementing a function in this way, you must first declare it as being
    of the interface type, which in this case is the `SuperAddMe` interface. Next,
    use the function variable and assign a function to it that adheres to the specification
    of our interface. This implementation is very similar to a type assignment, but
    because of the complexity of the function, an interface is used. Also, note that
    this code could be simplified by doing the declaration and assignment on one line,
    but in order to show the process and make it more readable, the assignment is
    implemented in parts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Display the results of a call to a new function, `adduser`, and pass a user
    object of the `User` type. Console out the results to show that the code is working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code using the `npx ts-node` command. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activity 5.01: Building a User Management Component Using Interfaces'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you are working on a web application and are tasked with building
    a user management component. You need to build a class to encapsulate the user
    management aspects of the application and, because you are a good developer, you
    will be using interfaces to ensure that your code is easy to reuse and support.
    For this activity, you can assume that your user interface will have at least
    three properties: email, token, and loginAt. These properties relate to a user''s
    email ID, the web token, and the time on the system when the user logged in.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this activity can be found here: [https://packt.link/xsOhv](https://packt.link/xsOhv).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some steps that will help you to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a user object interface with the following properties: `email : string`,
    `loginAt : number`, and `token: string`. The `loginAt` and `token` properties
    should be optional properties.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a class interface with a global property, `user`, and use the interface
    created in the preceding step to apply user object rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to define a `getUser` method that returns the `user` object and then
    use the interface to ensure that the return object is a user object. Finally,
    define a `login` method that takes a `user` object and `password(type string)`
    as arguments. Use the `user` object interface as the `user` argument type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Declare a class called `UserClass` that implements the class interface from
    the preceding step. Your login method should assign the local function's `user`
    argument to the global user property and return the global user. The `getUser`
    method should return the global user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of your class declared in *Step 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `user` object instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Console out our methods to ensure that they are working as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor402).
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript was born out of the need to build less confusing, clearly defined
    code. Interfaces allow you to build out your code in the most structured way possible.
    Everything has rules and there is no confusion, unlike with vanilla JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize the importance of interfaces, you can say that now you can produce
    code that is better structured and easier for third parties to use.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say, for example, that you built a `user` class as you did in the preceding
    activity, and now you need to move on to a different part of your project. The
    interfaces you have built will be a great help to the developer taking over the
    user section of the application, or maybe some other developer wants to build
    a user class with a similar structure to your user class. By using the interfaces
    you have defined, they can build a structure that follows all the rules you have
    put in place. This is also helpful as regards debugging, as now they know how
    things are expected to function and can find where the issues are by using the
    interfaces as a guideline.
  prefs: []
  type: TYPE_NORMAL
- en: The next section of this chapter is dedicated to inheritance in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now dive into inheritance, which is one of the core principles of object-oriented
    programming. It allows us to stay DRY (don't repeat yourself). Inheritance also
    allows us to be polymorphic, by abstracting functionality. Inheritance gives you
    the ability to extend your classes from the original class to a child class, which
    allows you to retain the functionality from the parent or original class and add
    or override what you don't need.
  prefs: []
  type: TYPE_NORMAL
- en: Child classes can override methods of their parents and have their own methods
    and objects. Inheritance only allows you to build on the parent class; how you
    implement your child class is up to you. However, the rule is that there must
    be some code you need to reuse from your parent class in your child class or you
    should create a new class as there would be no need to extend a class you don't
    plan to use any code from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a user class created to manage users in your application.
    You are working on a web application and, in the planning stages, you come to
    the realization that you need more than one user type, as different users will
    have different levels of access and be able to perform different actions depending
    on their roles. This is the perfect case for the use of inheritance. Any time
    you have common properties and functionality, you can extend and not duplicate
    your code. In this case, we have several user types, which all have common properties
    of a user: email, createDate, lastLogin, and token, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Because these properties are common to all users, we can put them all into a
    user class. The user class will serve as the base class that we can extend to
    our child classes. Your child classes will now have all the common properties
    without you having to declare them for each child class. As you can see, this
    is a much more efficient way to do things; it stops code duplication and allows
    for the consolidation of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s go over some ground rules of inheritance in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript only supports inheritance in two ways: single-level and multi-level.
    Thus, in TypeScript, a child can inherit from a parent (single-level inheritance)
    or a child can inherit from another child (multi-level inheritance).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: They are other types of inheritance, but since Typescript does not support those
    patterns, this chapter will not address these types here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have a diagram of the two types of inheritance that TypeScript supports
    – single-level and multi-level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: An example of single- and multi-level inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: An example of single- and multi-level inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: Single-level inheritance occurs when a child class inherits directly from a
    parent class, as shown in the preceding diagram. The Son child class is derived
    from the Father parent class and has all its attributes. It can also have its
    own properties and functions that are unique to the child class. One of the goals
    of inheritance is to build on top of an existing base, therefore, just creating
    a duplicate of the class would be pointless. Multi-level inheritance works the
    same as single-level inheritance, except the child class inherits from another
    child class and not directly from the parent, as shown in the preceding diagram.
    In other words, single-level is derived directly from the base class, which has
    no parents, while a multi-level child class inherits from a derived class. As
    you can see, the Grandfather class is the base class and therefore has no parents.
    Father is derived from GrandFather, but Son, in this case, is derived from Father,
    making this example multi-level.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript makes use of the private and public keywords to allow you to hide
    code from a child class that is private and control how your class properties
    are accessed by a child class with getter and setter methods. You can override
    any method that is exposed by a parent class in the child that includes the constructor
    method by using the keyword super, which is a direct link to the parent class.
    super also allows you to access properties and methods of the parent class even
    if they are overridden in your child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how inheritance works in code, let''s go back to our user example that
    we covered in the introduction to this section. The users of any given application
    have some common properties, email, createDate, lastLogin, and token, for example.
    We will use these common elements to build out a base user class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is some information on the properties used in the base class. This will
    also help you understand why these properties are present in the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`email`: This property serves as a unique identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createDate`: This property allows you to know when the user was added to the
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastLogin`: This property lets us know when the user was last active on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token`: This property will validate user requests to the application''s API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setToken`: This property allows us to set and reset the token property; for
    example, the user logs out of the application and the token needs to be set to null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resetPassword`: This property allows us to reset the current user''s password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are also using the this keyword to access our class-level token in our `setToken`
    function. We have also provided a number of default values in our base class,
    such as setting an empty string for email and zero for `createDate`. This just
    makes it easier to create instances of the class as we do not need to provide
    values every time we initialize a class instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on to inheritance. We will now create a child class, `AdminUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for us to create a child class, we must use the extends keyword followed
    by the parent class, as shown in the preceding snippet. The syntax structure is
    as follows: class keyword followed by the name of the child class, the extends
    keyword, and finally, the name of the parent class you would like to extend: class
    AdminUser extends UserOne.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to some examples, let''s list a few things we cannot do with
    class inheritance in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use other types of inheritance other than single- and multi-level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you declare a property or a method private, you cannot access it directly
    in your derived classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot override the constructor method of your base class unless you call
    `super` in your derived class's constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s go back to our child class, `AdminUser`. Note that we have added
    some properties and methods unique to our child class. Unique to `AdminUser` are
    adminPages, which is a list of pages only the admin user has access to, and resetUserPassword,
    which takes an email address of a user and returns a default password:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also reference directly the properties and methods of your parent class
    by using the `this` keyword in the child class, since `AdminUser` is now a combined
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we create an instance of our child class, `AdminUser`.
    We also declare a string, `propString`, as an empty string. This string will hold
    a list of your class properties. Using a `for` loop, we loop over our class instance
    and append the properties to `propString`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, console out an instance of our child class to verify that we have successfully
    inherited from our base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the properties and methods of our child and parent classes printed
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is the expected result. You now have a list of the combined
    properties of `UserOne` and `AdminUser`, showing that we have successfully extended
    our `UserOne` class to `AdminUser` or, in other words, we have shown that `AdminUser`
    inherits from `UserOne`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take inheritance up one level by deriving a new class from the `AdminUser`
    class. Call the derived class `SuperAdmin`, because not all admins are created
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding snippet, we are now extending the `AdminUser`
    class to create a `SuperAdmin` class. This means that we now have multi-level
    inheritance as our current class is inheriting from a derived class. We have also
    added a new property, `superPages`, and a method, `createAdmin`.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-level inheritance is useful for building complexity while still keeping
    your code easy to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to overload our `resetPassword` method in the `SuperAdmin`
    child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to create a new method for resetting passwords in our `SuperAdmin`
    class. We require a method that adds a hash to make the user password more secure
    as this will be the admin super user''s password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet creates a new method, `resetPassword`, and adds a
    new `myHash` property to our `SuperAdmin` class. We gave our new method the same
    name, `resetPassword`, as the `resetPassword` method in our grandfather class,
    `UserOne`. However, this new method returns a password appended with our hash
    property.
  prefs: []
  type: TYPE_NORMAL
- en: This is called method overriding because the methods have the same name and
    signature, meaning they take the same arguments. The method in the grandfather
    class is overridden and the new method will take precedence with instances of
    the `SuperAdmin` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful when you need to add some functionality to a method in a child
    class but don't want to change the signature, as the new method does something
    similar but not exactly the same. Consumers of your code will be able to use the
    same method but get different outcomes based on which derived child class they
    invoke.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we will console out the results of an instance of
    the `SuperAdmin` and `AdminUser` classes and the `resetPassword` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You will obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, we are calling the same method and getting a
    different output. This shows that we were able to successfully override the `resetPassword`
    method from our parent class, `UserOne`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add some access modifiers to our classes to show how they will
    affect our child classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we have added the `private` access modifier to the
    `token` property. Now, we can only access the `token` property through the `setToken`
    method, which is public, and all derived classes have access to the `setToken`
    method. This is useful in cases where you want to restrict which methods and properties
    to grant access to in your child classes. This is also useful in cases where you
    want to abstract functionality, thereby making interfacing with your code easier
    for consumers.
  prefs: []
  type: TYPE_NORMAL
- en: We want to make sure that every `AdminUser` class instance is initialized with
    an email address. Hence, we decide to add a constructor method to our `AdminUser`
    class to create an email address for our admin users whenever an `AdminUser` class
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: However, we cannot just create a constructor as this is a child class, which
    means we already have a parent class with a constructor method and we cannot override
    a constructor method without invoking our base class's constructor method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke our base class''s constructor method, we use `super()`, which is
    a direct reference to our base class''s constructor method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding snippet, we have a constructor method that takes
    an email address and sets the global email address. We also call the `super` method
    so that we can invoke the constructor method on our parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can create an instance of our `AdminUserTwo` class and pass an email
    address when the instance is created. This is all transparent to the user of our
    `AdminUser` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have covered inheritance, we will put what we have learned to good
    use in the upcoming exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.04: Creating a Base Class and Two Extended Child Classes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you are part of a development team working on a web application
    for a supermarket chain. You have the task of building a class to represent a
    user in the application. Because you are a good developer and are aware that you
    should not try to create one class for all use cases, you will build a base class
    with common attributes you think all users in your application should have and
    then extend that as required with child classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can be found here: [https://packt.link/hMd62](https://packt.link/hMd62).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `User` class, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application requires all its users to have `username` and `token` upon creation
    of the user object, so we add those properties and they will be initialized in
    our constructor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also set them to `private` as we do not want child classes to access our
    properties directly. We also have a `timestamp` property that we will use to set
    a creation date for the user object. This is set to `readonly` as it is created
    when the class is instanced and we don't want it to be modified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Different parts of your application will also need to access the properties
    of your user object. Therefore, we have added `getUser`, a method that returns
    your user properties. The `getUser` method will also allow derived or child classes
    to access private properties in an indirect way. The application allows the user
    to be logged in for a set period of time, after which the user token is expired.
    In order for a user to keep working in the application, we will need to renew
    their token, so we have added the `renewToken` method to allow for the setting
    of the user token property without giving direct access to properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `Cashier` class derived from the `User` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have a new user class, `Cashier`, derived from `User`, with some unique
    traits. A user of the `Cashier` type would need to function in our application.
    We do not, however, have access to all the properties of our parent class. You
    cannot access `userName` and `token` directly. You are able to access the `renewToken`
    method, but not through an instance of the `Cashier` class. However, you can call
    that method while building out the `Cashier` class as part of your user management
    for cashiers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Why would we want to modify access in the child class as opposed to modifying
    a parent? This is because of encapsulation and standardization: we want to reduce
    the complexity of our code when consumed by others.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, you have been working on a library of useful functions. You want
    your coworkers to be able to use it, but they don't need to know the inner workings
    of your `User` class. They just need to be able to access the class using the
    exposed methods and properties. This allows you to guide the process even if you
    are not the person extending or implementing the code. A good example would be
    the `Date` class in JavaScript. You don't need to know how that works. You can
    simply instance it and use it as directed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an `Inventory` class derived from `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our new user type, `Inventory`, needs to be able to initialize products upon
    the declaration of a new inventory user, as this user will be dealing with products
    directly and should have some products in their user queue when the user logs
    in to the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to make that possible, we have overridden our parent class constructor
    method in our child class. Our constructor now takes a new argument, `products`,
    which is an array of the string type. This means that we have changed the number
    of arguments our constructor should take based on what we defined in our parent
    class. Whenever we override our constructor, we need to call `super`, which is
    a reference to our parent class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, this allows us to access the parent constructor method, so we
    can now initialize `userName` and `token` and, in doing so, fulfill our child
    class's parent requirements. The main thing to take away from this is that all
    our code changes were made in the child class. Your new code for the `Inventory`
    class does not affect the other classes derived from `User`. You have extended
    and customized your code to deal with unique cases without having to write new
    code for this user case, saving you time and keeping your code base simple.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So far, we have derived two classes from our `User` class, which is single inheritance,
    as the child classes we created are directly derived from a base class. The next
    step involves multi-level inheritance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new derived class, `FloorWorker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is multi-level inheritance. This class takes into account floor workers.
    These are users that deal with stocking shelves in the store, so they need to
    access products from the inventory. They also need to have a count of the products
    they have removed to stock the store shelves. They need to have access to the
    `User` class' properties as well as access to the `Products` array from the `Inventory`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the following code snippet, we will instantiate our different user classes
    and console out the results of the work we have done so far.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instantiate your basic user and console out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will obtain the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate the `Cashier` class user and console out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will obtain the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate the `Inventory` class user and console out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will obtain the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate the `FloorWorker` class user and console out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will obtain the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For *steps 5-8*, you can also instantiate and console out all your users belonging
    to the different classes at once, rather than individually, as shown in the exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, you created a base class, child classes, and worked on multi-level
    and single-level inheritance. You also made use of `super` and access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Creating Bases and Extended Classes Using Multi-level Inheritance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are a developer working at a cell phone company and you are given the task
    of building a cell phone simulation application. The company manufactures two
    types of phone – a smartphone and a standard phone. The testing department wants
    to be able to showcase a number of functions of their phones and requires the
    ability to add more features to both phone types as the real devices are updated.
    After looking at the requirements, you come to the realization that you need the
    ability to model two types of phone and you also want to make it easy to update
    your code without doing a lot of refactoring and breaking other code that your
    phone models may use. You also know that both phones have a lot in common – they
    both have the basic functionality of communicating through voice and text data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can be found here: [https://packt.link/pyqDK](https://packt.link/pyqDK).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Phone` class that will serve as the base class for our child classes,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Phone` class is where we will store all the common elements of a phone.
    This will allow us to simplify our child classes to only deal with the elements
    unique to them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `Smart` class that extends the base or parent class created in *Step
    1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Smart` child class allows us to isolate all the methods and properties
    of a `Smart` `Phone` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `Standard` class that extends the parent class created in *Step 1*,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Steps 2 and 3 deal with the creation of our child class, which allows us to
    meet our goals of being able to update our code without issues and keep our code
    clean and well maintained. Because we are planning well at this stage, if we need
    to add features to our `Smart` phone, we just need to update one child class.
    This is also true for the `Standard` phone class. Also, if we have a method or
    property that we need in both child classes, we only need to update the `Phone`
    parent class. With class inheritance, we work smart, not hard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create two instances of our child classes and initialize them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Console out and call the unique methods of our class instances to verify that
    our child classes are working as defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will obtain the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if you revisit the respective class definitions of the `Smart` and `Standard`
    classes, you will be able to confirm that the preceding output is indeed evidence
    of the fact that the classes have worked as expected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Display the child class instance to show that we have all the properties and
    methods of our parent class and child classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will obtain the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For this preceding output, too, revisiting the respective class definitions
    of the `Smart` and `Dumb` classes should be proof enough that inheritance, as
    applied in this exercise, works correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you have an understanding of how inheritance works in TypeScript, we
    will test our skills in the form of the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.02: Creating a Prototype Web Application for a Vehicle Showroom
    Using Inheritance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are tasked with creating a web application for a vehicle showroom. You have
    decided to use your new skills in inheritance to build out the classes and child
    classes that will shape the vehicle objects we will require for our complete application.
    Note that the showroom has several types of vehicles. However, all these types
    will have some common properties. For example, all vehicles have wheels and a
    body. You can use this information to build your base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can be found here: [https://packt.link/6Xp8H](https://packt.link/6Xp8H).'
  prefs: []
  type: TYPE_NORMAL
- en: Create a parent class that will hold all common methods and properties for a
    base vehicle. Define a constructor method that allows you to initialize the base
    properties of this class and add a method that returns your properties as an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an access modifier to properties and class methods you want to control access
    to if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Derive two child classes from your parent class that are types of vehicles,
    for example, `Car` and `Truck`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override your constructor to add some unique properties to your child classes
    based on the type of vehicle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Derive a class from one of the child classes created in *Step 3*, for example,
    `Suv`, which will have some of the properties a truck might have, so it would
    be logical to extend `Truck`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate your child classes and seed them with data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Console out our child class instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor405).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered interfaces in TypeScript. You learned how interfaces
    allow you to build contracts around your objects, classes, and methods. You also
    learned that interfaces are rules that outline how your code is implemented. This
    chapter covered how using interfaces makes your code easier to understand and
    is better supported by you and other developers when working in larger teams.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also taught you about inheritance, one of the core principles of
    object-oriented programing. You learned about the types of inheritance TypeScript
    supports and how you can use inheritance to build complexity in your code without
    making your code more complex. This chapter elucidated that stacking simple structures
    to make more complex ones is a good practice as it allows you to reuse code and
    not reinvent the wheel every time you need to build a class. This also lends itself
    to better code support as you will write only the code you need and have common
    parent classes that will remain constant throughout your application, thereby
    making mistakes and bugs easier to find.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a good understanding of interfaces and inheritance, two building
    blocks you will make good use of as you move forward in this book and in web development
    using TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts you have covered here will make you a better developer overall
    as now you have the tools to write well-supported, clean, bug-free code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will cover advanced types and will learn about type
    aliases, type literals, unions, and intersection types.
  prefs: []
  type: TYPE_NORMAL
