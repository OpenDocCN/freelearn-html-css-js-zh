- en: Chapter 4. Making Things Move
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pretty picture is just the beginning! The hallmark of taking full advantage
    of the medium is making visualizations that adapt to new situations. Visualizations
    that let the user explore our data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll animate our pictures with the powerful transitions module
    of d3.js, and will look at some strategies for interacting with the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Animating with transitions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far attributes have been applied instantly, which is great for rendering
    an image, but what if we want to highlight something with a simple animation?
    Perhaps we just want a smoother transition from nothing to "Hey, graph!" while
    loading external data?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: That's where transitions come in. Transitions use the familiar principle of
    changing a selection's attributes, except that changes are applied over time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'To slowly turn a rectangle red, we''d use the following line of code:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We start a new transition with `.transition()` and then define the final state
    of each animated attribute. By default, every transition takes 250 milliseconds;
    you can change the timing with `.duration()`. New transitions are executed on
    all properties simultaneously unless you set a delay using `.delay()`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Delays are handy when we want to make transitions happen in sequence. Without
    a delay, they are all executed at the same time, depending on an internal timer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: For single objects, nested transitions are much simpler than carefully calibrated
    delays.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Take our rectangle example and write something like this in your Chrome console.
    If you haven't already, you'll need to actually add a rectangle to the page for
    this to work. Such is life.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running this code, you'll see the rectangle become red as it moves right by
    a hundred pixels, then moves downwards by the same distance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Capturing animations in screenshots is tough, but say this is your initial
    state:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating with transitions](img/0007OS_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: 'The final state would look like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating with transitions](img/0007OS_04_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: We do realize these are just two squares on a white background, but believe
    me, the red square is a hundred pixels below and to the right of the black square.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to do something before a transition begins, or want to listen for
    it to end, you can use `.each()` with the appropriate event type like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is handy for making instant changes before or after a transition. Just
    keep in mind that transitions run independently and you cannot rely on transitions
    outside the current callback being in this state or that.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Interpolators
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To calculate values between the initial and final states of a transition, d3.js
    uses interpolators—functions mapping the `[0,1]` domain to the target range (color,
    number, or string). Under the hood, scales are based on these same interpolators.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: D3's built-in interpolators can interpolate between almost any two arbitrary
    values, most often between numbers or colors, but also between strings. This sounds
    odd at first, but it's actually pretty useful.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: To let d3.js pick the right interpolator for the job, we just write `d3.interpolate(a,
    b)` and the `interpolation` function is chosen depending on the type of `b`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If `b` is a number, `a` will be coerced into a number and `.interpolateNumber()`
    will be used. You should avoid interpolating to or from a zero value because values
    will eventually be transformed into a string for the actual attribute and very
    small numbers might turn into scientific notation. CSS and HTML don't quite understand
    `1e-7` (the digit 1 with seven zeroes in front), so the smallest number you can
    safely use is `1e-6`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: If `b` is a string, d3.js checks whether it's a CSS color, in which case it
    is transformed to a proper color, just like the ones in [Chapter 2](ch02.html
    "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*.
    `a` is transformed into a color as well, and then d3.js uses `.interpolateRgb()`
    or a more appropriate interpolator for your color space.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Something even more amazing happens when the string is not a color. d3.js can
    handle that too! When it encounters a string, d3.js will parse it for numbers,
    then use `.interpolateNumber()` on each numerical piece of the string. This is
    useful for interpolating mixed style definitions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to transition a font definition, you might do something like
    this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We used `.styleTween()` to manually define a transition. It is most useful when
    we want to define the starting value of a transition without relying on the current
    state. The first argument defines which style attribute to transition and the
    second is the interpolator.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: You can use `.tween()` to do this for attributes other than style.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Every numerical part of the string was interpolated between the starting and
    ending values, and the string parts changed to their final state immediately.
    An interesting application of this is interpolating path definitions—you can make
    shapes change in time. How cool is that?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that only strings with the same number and location of control
    points (numbers in the string) can be interpolated. You can't use interpolators
    for everything. Creating a custom interpolator is as simple as defining a function
    that takes a single `t` parameter and returns the start value for `t = 0` and
    end value for `t = 1` and blends values for anything in between.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code shows the `interpolateNumber` function of d3.js:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's as simple as that!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: You can even interpolate whole arrays and objects, which work like compound
    interpolators of multiple values. We'll use those soon.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Easing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Easing tweaks the behavior of interpolators by controlling the `t` argument.
    We use this to make our animations feel more natural, to add some bounce elasticity,
    and so on. Mostly we use easing to avoid the artificial feel of linear animation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a quick comparison of the easing functions provided by d3.js and
    see what they do.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget the drawing area! I once spent an hour debugging a graph before
    realizing there was no `svg` element.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we need an array of easing functions and a scale for placing them along
    the vertical axis.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You'll notice that `poly`, `elastic`, and `back` take arguments; since these
    are just strings, we'll have to manually change them into real arguments later.
    The `poly` easing function is just a polynomial, so `poly(2)` is equal to `quad`
    and `poly(3)` is equal to `cubic`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The `elastic` easing function simulates an elastic and the two arguments control
    tension. I suggest playing with the values to get the effect you want.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The `back` easing function is supposed to simulate backing into a parking space.
    The argument controls how much overshoot there's going to be.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The nonsense at the end (`cubic-in`, `cubic-out`, and so on) is a list of the
    easing functions we create ourselves by combining the following modifiers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '`-in`: It does nothing'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '-`out`: It reverses the easing direction'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '-`in-out`: It copies and mirrors the easing function from `[0, 0.5]` and `[0.5,
    1]`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-out-in`: It copies and mirrors the easing function from `[1, 0.5]` and `[0.5,
    0]`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can add these to any easing function, so play around. Time to render a
    circle flying towards the right for every function in the list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We loop over the list with an iterator that creates a new circle and uses the
    `y()` scale for vertical placement and `y.rangeBand()` for circle size. This way,
    we can add or remove examples easily. Transitions will start with a delay of just
    under half a second to give us a chance to see what's going on. A duration of
    `1500` milliseconds and a final position of `400` should give enough time and
    space to see the easing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the easing at the end of this function, before the `});` bit:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code checks for parentheses in the `ease` string, parses out the easing
    function and its arguments, and feeds them to `transition.ease()`. Without parentheses,
    `ease` is just the easing type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some text so we can tell the examples apart:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The visualization is a cacophony of dots:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![Easing](img/0007OS_04_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: The screenshot doesn't quite showcase the animation, so you should really try
    this one in the browser. Or you can take a look at the easing curves at [http://easings.net/](http://easings.net/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To schedule transitions, d3.js uses timers. Even an immediate transition will
    start after a delay of 17 ms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Far from keeping timers all to itself, d3.js lets us use timers so that we can
    take animation beyond the two-keyframe model of transition. For those of us who
    aren't animators, keyframes define the start or end of a smooth transition.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: To create a timer, we use `d3.timer()`. It takes a function, a delay, and a
    starting mark. After the set delay (in milliseconds) from the mark, the function
    will be executed repeatedly until it returns `true`. The mark should be a date
    converted into milliseconds since Unix epoch (`Date.getTime()` will do), or you
    can let d3.js use `Date.now()` by default.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Let's animate the drawing of a parametric function to work just like the Spirograph
    toy you might have had as a kid.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a timer, let it run for a few seconds, and use the millisecond
    mark as the parameter for a parametric function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a drawing area:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I found a good function in Wikipedia's article on parametric equations at [http://en.wikipedia.org/wiki/Parametric_equations](http://en.wikipedia.org/wiki/Parametric_equations).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function will return a mathematical position based on the parameter going
    from zero up. You can tweak the Spirograph by changing the `a`, `b`, `c`, and
    `d` variables—examples in the same Wikipedia article.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'This function returns positions between `-2` and `2`, so we need some scales
    to make it visible on the screen:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`t_scale` will translate time into parameters for the function; `x` and `y`
    will calculate the final position on the image.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to define `brush` to fly around and pretend it's drawing and a variable
    to hold the `previous` position so that we can draw straight lines.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to define an animation `step` function that moves the brush and
    draws a line between the previous and current points:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first condition stops the timer when the current value of the `time` parameter
    is beyond the domain of `t_scale`. Then, we use `t_scale()` to translate the time
    into our parameter and get a new position for the brush.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Then, we move the brush—there is no transition because *we* are performing the
    transition—and draw a new steelblue line between the previous and current position
    (`pos`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We conclude by setting a new value for the previous position.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left now is creating a timer:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it. Half a second after a page refresh, the code will begin drawing a
    beautiful shape and finish 25 seconds later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting out, it looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Timers](img/0007OS_04_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: Getting the whole picture takes a while, so this probably isn't the best way
    to draw Spirographs. Since we're using time as a parameter, a smoother curve (more
    points) takes more time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is that lagging computers or slower machines will affect the
    final outcome of the animation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: A reader wrote a version without these problems and put the code on Github at
    [https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js](https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Timers](img/0007OS_04_05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: But both versions of the code will eventually come up with a beautiful flower.
    When I wrote this code, I spent an hour just marveling at the drawing process
    and tweaking the parameters to see what happens.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the user
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great visualizations don't just stop at pretty pictures and animations! They
    give users the power to play with data and figure things out on their own. That's
    what we'll look into next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: You don't know it yet, but you already know how to let users interact with visualizations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Basic interaction
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like with other UI libraries, the principle for interaction is simple—attach
    an event listener to an element and do something when it's triggered. We add and
    remove listeners to and from selections with the `.on()` method, an event type
    (for instance, `click`), and a listener function that is executed when the event
    is triggered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We can set a capture flag, which ensures our listener is called first and all
    other listeners wait for our listener to finish. Events bubbling up from children
    elements will not trigger our listener.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: You can rely on the fact there will only ever be a single listener for a particular
    event on an element because old listeners for the same event are removed when
    new ones are added. This is very useful for avoiding unpredictable behavior.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Just like other functions acting on element selections, event listeners get
    the current datum and index and set the `this` context to the DOM element. The
    global `d3.event` will let you access the actual event object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Let's play around with these principles and a simple visualization using mouse
    clicks and finger touches. Yes, d3.js has some support for touch devices, but
    it doesn't always work perfectly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, begin with a drawing area:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we create a function that will emulate ripples in a pond using three
    circles; you might need some imagination:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `radiate` function creates three circles centered around a position, defined
    by a two-element array—[x, y]. A transition will grow the circles, reduce their
    opacity, and in the end, remove them. We used `.delay` to ensure the circles don't
    overlap, which creates the rippling illusion.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the fun part:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We used `.on()` once for each type of event we want to make ripples for—the
    familiar `click` event first and then the possibly less familiar `touchstart`.
    The `touchstart` event is triggered when a finger touches the screen; think of
    it as the `mousedown` event of touch. Other useful touch events are `touchmove`,
    `touchend`, `touchcancel`, and `tap`. Mozilla's documentation explains touch events
    in more detail at [https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The `click` listener uses `d3.mouse()` to get the cursor's position relative
    to the container element, and the `touchstart` listener maps through a list of
    all touches. In theory, this will draw several ripples if you smoosh your whole
    hand on the screen, but I was unable to get this working on any of my devices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the ripples pretty with some styling:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Clicking around makes ripples!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic interaction](img/0007OS_04_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Behaviors
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you want more than to just let the user click around like a madman;
    you want drag-and-drop and zoom-in and zoom-out stuff!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: You can make all this with just click events, but I heartily recommend d3's
    behaviors module. It makes complex behaviors as simple as calling the right function
    on some elements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Currently, d3.js supports only `drag` and `zoom`, but I am hopeful that more
    are on the way. The main benefit of behaviors is that they automatically create
    relevant event listeners and let you work at a higher level of abstraction.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Drag
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I can't think of a better dragging demonstration than animating with the parallax
    illusion. The illusion works by having several keyframes rendered in vertical
    slices and dragging a screen over them to create an animated thingamabob.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the lines by hand would be tedious, so we're using an image *Marco Kuiper*
    created in Photoshop. I asked on Twitter and he said we can use the image, if
    we check out his other work at [marcofolio.net](http://marcofolio.net).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Drag](img/0007OS_04_07.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: You can also get the image in the examples repository at [https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png](https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'We need somewhere to put the parallax:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll use SVG''s native support for embedding bitmaps to insert `parallax_base.png`
    into the page:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `image` element's magic stems from its `xlink:href` attribute. It understands
    links and even lets us embed images to create self-contained SVGs. To use that,
    you would prepend an image MIME type to a base64 encoded representation of the
    image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the following line is the smallest embedded version of a spacer
    GIF. Don't worry if you don't know what a spacer GIF is; they were useful up to
    about 2005.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Anyway, now that we have the animation base, we need a screen that can be dragged.
    It''s going to be a bunch of carefully calibrated vertical lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We'll base the screen off an array of numbers (`lines`). Since line thickness
    and density are very important, we divide `screen_width` by `6`—five pixels for
    a line and one for spacing. Make sure the value of `screen_width` is a multiple
    of 6; otherwise anti-aliasing ruins the effect.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The `x` scale will help us place the lines evenly:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's nothing particularly interesting here, just stuff you already know.
    The code goes through the array and draws a new vertical line for each entry.
    We made absolutely certain there won't be any anti-aliasing by setting `shape-rendering`
    to `crispEdges`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to define and activate a dragging behavior for our group of lines:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We created the behavior with `d3.behavior.drag()`, defined a `.origin()` accessor,
    and specified what happens on drag. The behavior automatically translates touch
    and mouse events to the higher-level drag event. How cool is that!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We need to give the behavior an origin so it knows how to calculate positions
    relatively; otherwise, the current position is always set to the mouse cursor
    and objects jump around. It's terrible. `Object` is the identity function for
    elements and assumes a datum with *x* and *y* coordinates.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The heavy lifting happens inside the `drag` listener. We get the screen's new
    position from `d3.event.x`, move the screen there, and update the attached `.datum()`
    method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left to do is to call `drag` and make sure to set the attached
    datum to the current position:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The item looks solid now! Try dragging the screen at different speeds.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Drag](img/0007OS_04_08.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: The parallax effect doesn't work very well on a retina display because the base
    image gets resized and our screen loses calibration.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Zoom
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Despite the name, the zoom behavior lets you do more than just zoom—you can
    also pan! Like the drag behavior, zoom automatically handles both mouse and touch
    events and then triggers the higher-level zoom event. Yes, this means pinch-to-zoom
    works! That's pretty awesome if you ask me.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Remember that map from [Chapter 3](ch03.html "Chapter 3. Making Data Useful"),
    *Making Data Useful*? The one with airports on a world map? That one.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Let's commit a crime against computational efficiency and make it zoom and pan.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: I am warning you this will be very rudimentary and painfully slow. This is not
    how you'd make a real explorable map, just an example to let us play with zooming.
    In real life you should use tiling, progressive detailing, and other tricks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: To make this a bit more bearable, you should disable water and urban areas.
    Comment out `add_to_map` calls for rivers, lakes, and oceans roughly on lines
    30, 36, and 42 in the JavaScript code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Your map becomes much simpler:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Zoom](img/0007OS_04_09.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: The biggest effect comes from removing large areas, so if you remove land as
    well, the map will be surprisingly performant but quite useless.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Jump to the end of `draw_airlines` and add a call to `zoomable`; we''ll define
    this next:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`zoomable` needs `airports`, `R_scale`, and `routes` data to resize the circles
    when zooming:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We defined a zoom behavior with `d3.behavior.zoom()` and immediately called
    it on the whole image.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We set the current `.translate()` vector and `.scale()` to whatever the projection
    was using. The zoom event will call our `onzoom` function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First we told our projection the new translation vector is in `d3.event.translate`.
    The translation vector will pan the map with a transformation, just like in [Chapter
    2](ch02.html "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG,
    and CSS*. `d3.event.scale` is just a number the projection uses to scale itself,
    effectively zooming the map.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Then, we recalculated all the paths with a new `d3.geo.path()` using the changed
    projection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The same approach works for circles. Take the new info, select all the circles,
    and change their attributes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The positioning function is exactly the same as in `draw_airlines` because geographic
    projections handle panning out of the box. Adjusting size takes a bit more work.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: After calculating a magnifier as a ratio between the current and default scale
    (`1200`), we use `R_scale` to get the circle's normal size and multiply it by
    the magnifier.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: You can now explore the world!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Have patience, though, it's slow. Redrawing everything on every move will do
    that.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: For a more performant zoomable map, we'd have to use data with less detail when
    zoomed out, draw a sensible number of airports, and possibly avoid drawing parts
    of the map that fall out of the image anyway.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Zoom](img/0007OS_04_10.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: Brushes
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to zoom and drag, brushes are a simple way to create complex behavior—they
    enable users to select a part of the canvas.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Strangely enough, they aren't considered a behavior, but fall under the `.svg`
    namespace, perhaps because they are mostly meant for visual effects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: To create a new brush, we'd call `d3.svg.brush()` and define its x and y scales
    using `.x()` and `.y()`. We can also define a bounding rectangle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Time for an example!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to make a scatterplot of some random data and let the user select
    points. Begin with a drawing area and some data:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We used a built-in random generator to create numbers with a `normal` distribution
    centered around `.5` and a dispersion of `.11`. d3.js also gives us the `logNormal`
    and `irwinHall` distributions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: We now have an array of 800 random two-dimensional positions. To draw them,
    we'll use two scales to make the tiny range more visible, then place each datum
    on the page as a circle.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'I know we don''t usually add axes in this book, but scatterplots look ridiculous
    without them. Let''s add some:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You should remember what's going on here from [Chapter 2](ch02.html "Chapter 2. A
    Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*, where we discussed
    axes at length.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some basic styling to the HTML:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And yay, scatterplot!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Brushes](img/0007OS_04_11.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'Now for the fun stuff:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We made a new grouping element for the brush and called a freshly constructed
    `d3.svg.brush()` with both scales defined. The `"brush"` class will help with
    styling. Finally, we defined listeners for `brusthstart`, `brush`, and `brushend`
    events.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`brushstart` flicks the styling to `selecting`. We''ll use it to help the user
    distinguish between selected and unselected circles:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`brushmove` is where the real magic happens.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: First, we find the selection's boundaries using `d3.event.target.extent()`.
    `d3.event.target` returns the current brush and `.extent()` returns a set of two
    points—upper-left and bottom-right corner.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we go through all the circles and turn the `selected` class on or off,
    depending on whether a circle''s position lies within the bounding box:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`brushend` just turns off the selecting state if the selection is empty.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Our HTML needs some more styling definitions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We're changing the opacity of the circle fill (`fill-opacity)` rather than for
    the borders so that the circle edges always shine out at full opacity. Adding
    a CSS transition gives everything a smoother feel.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在改变圆形填充的透明度（`fill-opacity`），而不是边框的透明度，这样圆形的边缘总是以全透明度闪耀。添加CSS过渡使一切感觉更加平滑。
- en: In this case, we prefer CSS transitions over what d3.js can do, so we can limit
    JavaScript to changing element states. Brushes sometimes also have problems with
    d3.js transitions and change properties immediately.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们更喜欢CSS过渡而不是d3.js能做的，这样我们可以将JavaScript限制在改变元素状态上。刷子有时也会在d3.js过渡中遇到问题，并立即更改属性。
- en: 'When you select some elements, the image will look like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一些元素时，图像将看起来像这样：
- en: '![Brushes](img/0007OS_04_12.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![刷子](img/0007OS_04_12.jpg)'
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow, what a fun chapter!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，多么有趣的一章！
- en: You've made things jump around the page, almost killed your computer and patience
    with a zoomable map, and created a spinning thingy out of nothing but vertical
    lines.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你让事物在页面上跳跃，几乎用可缩放的地图杀死了你的电脑和耐心，并且仅用垂直线条就创造了一个旋转的东西。
- en: This is everything you need for visualizations users can play with. The rest
    is just experimentation and some ingenuity in piecing things together. Good luck!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是用户可以与之互动的视觉化所需的一切。其余的只是实验和一些巧妙地将事物组合在一起。祝你好运！
