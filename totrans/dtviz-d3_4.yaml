- en: Chapter 4. Making Things Move
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pretty picture is just the beginning! The hallmark of taking full advantage
    of the medium is making visualizations that adapt to new situations. Visualizations
    that let the user explore our data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll animate our pictures with the powerful transitions module
    of d3.js, and will look at some strategies for interacting with the user.
  prefs: []
  type: TYPE_NORMAL
- en: Animating with transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far attributes have been applied instantly, which is great for rendering
    an image, but what if we want to highlight something with a simple animation?
    Perhaps we just want a smoother transition from nothing to "Hey, graph!" while
    loading external data?
  prefs: []
  type: TYPE_NORMAL
- en: That's where transitions come in. Transitions use the familiar principle of
    changing a selection's attributes, except that changes are applied over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To slowly turn a rectangle red, we''d use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We start a new transition with `.transition()` and then define the final state
    of each animated attribute. By default, every transition takes 250 milliseconds;
    you can change the timing with `.duration()`. New transitions are executed on
    all properties simultaneously unless you set a delay using `.delay()`.
  prefs: []
  type: TYPE_NORMAL
- en: Delays are handy when we want to make transitions happen in sequence. Without
    a delay, they are all executed at the same time, depending on an internal timer.
  prefs: []
  type: TYPE_NORMAL
- en: For single objects, nested transitions are much simpler than carefully calibrated
    delays.
  prefs: []
  type: TYPE_NORMAL
- en: Take our rectangle example and write something like this in your Chrome console.
    If you haven't already, you'll need to actually add a rectangle to the page for
    this to work. Such is life.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running this code, you'll see the rectangle become red as it moves right by
    a hundred pixels, then moves downwards by the same distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Capturing animations in screenshots is tough, but say this is your initial
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating with transitions](img/0007OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final state would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating with transitions](img/0007OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do realize these are just two squares on a white background, but believe
    me, the red square is a hundred pixels below and to the right of the black square.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to do something before a transition begins, or want to listen for
    it to end, you can use `.each()` with the appropriate event type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is handy for making instant changes before or after a transition. Just
    keep in mind that transitions run independently and you cannot rely on transitions
    outside the current callback being in this state or that.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To calculate values between the initial and final states of a transition, d3.js
    uses interpolators—functions mapping the `[0,1]` domain to the target range (color,
    number, or string). Under the hood, scales are based on these same interpolators.
  prefs: []
  type: TYPE_NORMAL
- en: D3's built-in interpolators can interpolate between almost any two arbitrary
    values, most often between numbers or colors, but also between strings. This sounds
    odd at first, but it's actually pretty useful.
  prefs: []
  type: TYPE_NORMAL
- en: To let d3.js pick the right interpolator for the job, we just write `d3.interpolate(a,
    b)` and the `interpolation` function is chosen depending on the type of `b`.
  prefs: []
  type: TYPE_NORMAL
- en: If `b` is a number, `a` will be coerced into a number and `.interpolateNumber()`
    will be used. You should avoid interpolating to or from a zero value because values
    will eventually be transformed into a string for the actual attribute and very
    small numbers might turn into scientific notation. CSS and HTML don't quite understand
    `1e-7` (the digit 1 with seven zeroes in front), so the smallest number you can
    safely use is `1e-6`.
  prefs: []
  type: TYPE_NORMAL
- en: If `b` is a string, d3.js checks whether it's a CSS color, in which case it
    is transformed to a proper color, just like the ones in [Chapter 2](ch02.html
    "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*.
    `a` is transformed into a color as well, and then d3.js uses `.interpolateRgb()`
    or a more appropriate interpolator for your color space.
  prefs: []
  type: TYPE_NORMAL
- en: Something even more amazing happens when the string is not a color. d3.js can
    handle that too! When it encounters a string, d3.js will parse it for numbers,
    then use `.interpolateNumber()` on each numerical piece of the string. This is
    useful for interpolating mixed style definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to transition a font definition, you might do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We used `.styleTween()` to manually define a transition. It is most useful when
    we want to define the starting value of a transition without relying on the current
    state. The first argument defines which style attribute to transition and the
    second is the interpolator.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `.tween()` to do this for attributes other than style.
  prefs: []
  type: TYPE_NORMAL
- en: Every numerical part of the string was interpolated between the starting and
    ending values, and the string parts changed to their final state immediately.
    An interesting application of this is interpolating path definitions—you can make
    shapes change in time. How cool is that?
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that only strings with the same number and location of control
    points (numbers in the string) can be interpolated. You can't use interpolators
    for everything. Creating a custom interpolator is as simple as defining a function
    that takes a single `t` parameter and returns the start value for `t = 0` and
    end value for `t = 1` and blends values for anything in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code shows the `interpolateNumber` function of d3.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as that!
  prefs: []
  type: TYPE_NORMAL
- en: You can even interpolate whole arrays and objects, which work like compound
    interpolators of multiple values. We'll use those soon.
  prefs: []
  type: TYPE_NORMAL
- en: Easing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Easing tweaks the behavior of interpolators by controlling the `t` argument.
    We use this to make our animations feel more natural, to add some bounce elasticity,
    and so on. Mostly we use easing to avoid the artificial feel of linear animation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a quick comparison of the easing functions provided by d3.js and
    see what they do.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget the drawing area! I once spent an hour debugging a graph before
    realizing there was no `svg` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need an array of easing functions and a scale for placing them along
    the vertical axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that `poly`, `elastic`, and `back` take arguments; since these
    are just strings, we'll have to manually change them into real arguments later.
    The `poly` easing function is just a polynomial, so `poly(2)` is equal to `quad`
    and `poly(3)` is equal to `cubic`.
  prefs: []
  type: TYPE_NORMAL
- en: The `elastic` easing function simulates an elastic and the two arguments control
    tension. I suggest playing with the values to get the effect you want.
  prefs: []
  type: TYPE_NORMAL
- en: The `back` easing function is supposed to simulate backing into a parking space.
    The argument controls how much overshoot there's going to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nonsense at the end (`cubic-in`, `cubic-out`, and so on) is a list of the
    easing functions we create ourselves by combining the following modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-in`: It does nothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '-`out`: It reverses the easing direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '-`in-out`: It copies and mirrors the easing function from `[0, 0.5]` and `[0.5,
    1]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-out-in`: It copies and mirrors the easing function from `[1, 0.5]` and `[0.5,
    0]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can add these to any easing function, so play around. Time to render a
    circle flying towards the right for every function in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We loop over the list with an iterator that creates a new circle and uses the
    `y()` scale for vertical placement and `y.rangeBand()` for circle size. This way,
    we can add or remove examples easily. Transitions will start with a delay of just
    under half a second to give us a chance to see what's going on. A duration of
    `1500` milliseconds and a final position of `400` should give enough time and
    space to see the easing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the easing at the end of this function, before the `});` bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code checks for parentheses in the `ease` string, parses out the easing
    function and its arguments, and feeds them to `transition.ease()`. Without parentheses,
    `ease` is just the easing type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some text so we can tell the examples apart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The visualization is a cacophony of dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easing](img/0007OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The screenshot doesn't quite showcase the animation, so you should really try
    this one in the browser. Or you can take a look at the easing curves at [http://easings.net/](http://easings.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To schedule transitions, d3.js uses timers. Even an immediate transition will
    start after a delay of 17 ms.
  prefs: []
  type: TYPE_NORMAL
- en: Far from keeping timers all to itself, d3.js lets us use timers so that we can
    take animation beyond the two-keyframe model of transition. For those of us who
    aren't animators, keyframes define the start or end of a smooth transition.
  prefs: []
  type: TYPE_NORMAL
- en: To create a timer, we use `d3.timer()`. It takes a function, a delay, and a
    starting mark. After the set delay (in milliseconds) from the mark, the function
    will be executed repeatedly until it returns `true`. The mark should be a date
    converted into milliseconds since Unix epoch (`Date.getTime()` will do), or you
    can let d3.js use `Date.now()` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Let's animate the drawing of a parametric function to work just like the Spirograph
    toy you might have had as a kid.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a timer, let it run for a few seconds, and use the millisecond
    mark as the parameter for a parametric function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a drawing area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I found a good function in Wikipedia's article on parametric equations at [http://en.wikipedia.org/wiki/Parametric_equations](http://en.wikipedia.org/wiki/Parametric_equations).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function will return a mathematical position based on the parameter going
    from zero up. You can tweak the Spirograph by changing the `a`, `b`, `c`, and
    `d` variables—examples in the same Wikipedia article.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function returns positions between `-2` and `2`, so we need some scales
    to make it visible on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`t_scale` will translate time into parameters for the function; `x` and `y`
    will calculate the final position on the image.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to define `brush` to fly around and pretend it's drawing and a variable
    to hold the `previous` position so that we can draw straight lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define an animation `step` function that moves the brush and
    draws a line between the previous and current points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first condition stops the timer when the current value of the `time` parameter
    is beyond the domain of `t_scale`. Then, we use `t_scale()` to translate the time
    into our parameter and get a new position for the brush.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we move the brush—there is no transition because *we* are performing the
    transition—and draw a new steelblue line between the previous and current position
    (`pos`).
  prefs: []
  type: TYPE_NORMAL
- en: We conclude by setting a new value for the previous position.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left now is creating a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Half a second after a page refresh, the code will begin drawing a
    beautiful shape and finish 25 seconds later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting out, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Timers](img/0007OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting the whole picture takes a while, so this probably isn't the best way
    to draw Spirographs. Since we're using time as a parameter, a smoother curve (more
    points) takes more time.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is that lagging computers or slower machines will affect the
    final outcome of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: A reader wrote a version without these problems and put the code on Github at
    [https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js](https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js).
  prefs: []
  type: TYPE_NORMAL
- en: '![Timers](img/0007OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But both versions of the code will eventually come up with a beautiful flower.
    When I wrote this code, I spent an hour just marveling at the drawing process
    and tweaking the parameters to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great visualizations don't just stop at pretty pictures and animations! They
    give users the power to play with data and figure things out on their own. That's
    what we'll look into next.
  prefs: []
  type: TYPE_NORMAL
- en: You don't know it yet, but you already know how to let users interact with visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like with other UI libraries, the principle for interaction is simple—attach
    an event listener to an element and do something when it's triggered. We add and
    remove listeners to and from selections with the `.on()` method, an event type
    (for instance, `click`), and a listener function that is executed when the event
    is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: We can set a capture flag, which ensures our listener is called first and all
    other listeners wait for our listener to finish. Events bubbling up from children
    elements will not trigger our listener.
  prefs: []
  type: TYPE_NORMAL
- en: You can rely on the fact there will only ever be a single listener for a particular
    event on an element because old listeners for the same event are removed when
    new ones are added. This is very useful for avoiding unpredictable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Just like other functions acting on element selections, event listeners get
    the current datum and index and set the `this` context to the DOM element. The
    global `d3.event` will let you access the actual event object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's play around with these principles and a simple visualization using mouse
    clicks and finger touches. Yes, d3.js has some support for touch devices, but
    it doesn't always work perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, begin with a drawing area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a function that will emulate ripples in a pond using three
    circles; you might need some imagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `radiate` function creates three circles centered around a position, defined
    by a two-element array—[x, y]. A transition will grow the circles, reduce their
    opacity, and in the end, remove them. We used `.delay` to ensure the circles don't
    overlap, which creates the rippling illusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the fun part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We used `.on()` once for each type of event we want to make ripples for—the
    familiar `click` event first and then the possibly less familiar `touchstart`.
    The `touchstart` event is triggered when a finger touches the screen; think of
    it as the `mousedown` event of touch. Other useful touch events are `touchmove`,
    `touchend`, `touchcancel`, and `tap`. Mozilla's documentation explains touch events
    in more detail at [https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events).
  prefs: []
  type: TYPE_NORMAL
- en: The `click` listener uses `d3.mouse()` to get the cursor's position relative
    to the container element, and the `touchstart` listener maps through a list of
    all touches. In theory, this will draw several ripples if you smoosh your whole
    hand on the screen, but I was unable to get this working on any of my devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the ripples pretty with some styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Clicking around makes ripples!
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic interaction](img/0007OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you want more than to just let the user click around like a madman;
    you want drag-and-drop and zoom-in and zoom-out stuff!
  prefs: []
  type: TYPE_NORMAL
- en: You can make all this with just click events, but I heartily recommend d3's
    behaviors module. It makes complex behaviors as simple as calling the right function
    on some elements.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, d3.js supports only `drag` and `zoom`, but I am hopeful that more
    are on the way. The main benefit of behaviors is that they automatically create
    relevant event listeners and let you work at a higher level of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Drag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I can't think of a better dragging demonstration than animating with the parallax
    illusion. The illusion works by having several keyframes rendered in vertical
    slices and dragging a screen over them to create an animated thingamabob.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the lines by hand would be tedious, so we're using an image *Marco Kuiper*
    created in Photoshop. I asked on Twitter and he said we can use the image, if
    we check out his other work at [marcofolio.net](http://marcofolio.net).
  prefs: []
  type: TYPE_NORMAL
- en: '![Drag](img/0007OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also get the image in the examples repository at [https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png](https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need somewhere to put the parallax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use SVG''s native support for embedding bitmaps to insert `parallax_base.png`
    into the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `image` element's magic stems from its `xlink:href` attribute. It understands
    links and even lets us embed images to create self-contained SVGs. To use that,
    you would prepend an image MIME type to a base64 encoded representation of the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the following line is the smallest embedded version of a spacer
    GIF. Don't worry if you don't know what a spacer GIF is; they were useful up to
    about 2005.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Anyway, now that we have the animation base, we need a screen that can be dragged.
    It''s going to be a bunch of carefully calibrated vertical lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We'll base the screen off an array of numbers (`lines`). Since line thickness
    and density are very important, we divide `screen_width` by `6`—five pixels for
    a line and one for spacing. Make sure the value of `screen_width` is a multiple
    of 6; otherwise anti-aliasing ruins the effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `x` scale will help us place the lines evenly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing particularly interesting here, just stuff you already know.
    The code goes through the array and draws a new vertical line for each entry.
    We made absolutely certain there won't be any anti-aliasing by setting `shape-rendering`
    to `crispEdges`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to define and activate a dragging behavior for our group of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We created the behavior with `d3.behavior.drag()`, defined a `.origin()` accessor,
    and specified what happens on drag. The behavior automatically translates touch
    and mouse events to the higher-level drag event. How cool is that!
  prefs: []
  type: TYPE_NORMAL
- en: We need to give the behavior an origin so it knows how to calculate positions
    relatively; otherwise, the current position is always set to the mouse cursor
    and objects jump around. It's terrible. `Object` is the identity function for
    elements and assumes a datum with *x* and *y* coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The heavy lifting happens inside the `drag` listener. We get the screen's new
    position from `d3.event.x`, move the screen there, and update the attached `.datum()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left to do is to call `drag` and make sure to set the attached
    datum to the current position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The item looks solid now! Try dragging the screen at different speeds.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drag](img/0007OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The parallax effect doesn't work very well on a retina display because the base
    image gets resized and our screen loses calibration.
  prefs: []
  type: TYPE_NORMAL
- en: Zoom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Despite the name, the zoom behavior lets you do more than just zoom—you can
    also pan! Like the drag behavior, zoom automatically handles both mouse and touch
    events and then triggers the higher-level zoom event. Yes, this means pinch-to-zoom
    works! That's pretty awesome if you ask me.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that map from [Chapter 3](ch03.html "Chapter 3. Making Data Useful"),
    *Making Data Useful*? The one with airports on a world map? That one.
  prefs: []
  type: TYPE_NORMAL
- en: Let's commit a crime against computational efficiency and make it zoom and pan.
  prefs: []
  type: TYPE_NORMAL
- en: I am warning you this will be very rudimentary and painfully slow. This is not
    how you'd make a real explorable map, just an example to let us play with zooming.
    In real life you should use tiling, progressive detailing, and other tricks.
  prefs: []
  type: TYPE_NORMAL
- en: To make this a bit more bearable, you should disable water and urban areas.
    Comment out `add_to_map` calls for rivers, lakes, and oceans roughly on lines
    30, 36, and 42 in the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your map becomes much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Zoom](img/0007OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The biggest effect comes from removing large areas, so if you remove land as
    well, the map will be surprisingly performant but quite useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jump to the end of `draw_airlines` and add a call to `zoomable`; we''ll define
    this next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`zoomable` needs `airports`, `R_scale`, and `routes` data to resize the circles
    when zooming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We defined a zoom behavior with `d3.behavior.zoom()` and immediately called
    it on the whole image.
  prefs: []
  type: TYPE_NORMAL
- en: We set the current `.translate()` vector and `.scale()` to whatever the projection
    was using. The zoom event will call our `onzoom` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First we told our projection the new translation vector is in `d3.event.translate`.
    The translation vector will pan the map with a transformation, just like in [Chapter
    2](ch02.html "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG,
    and CSS*. `d3.event.scale` is just a number the projection uses to scale itself,
    effectively zooming the map.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we recalculated all the paths with a new `d3.geo.path()` using the changed
    projection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The same approach works for circles. Take the new info, select all the circles,
    and change their attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The positioning function is exactly the same as in `draw_airlines` because geographic
    projections handle panning out of the box. Adjusting size takes a bit more work.
  prefs: []
  type: TYPE_NORMAL
- en: After calculating a magnifier as a ratio between the current and default scale
    (`1200`), we use `R_scale` to get the circle's normal size and multiply it by
    the magnifier.
  prefs: []
  type: TYPE_NORMAL
- en: You can now explore the world!
  prefs: []
  type: TYPE_NORMAL
- en: Have patience, though, it's slow. Redrawing everything on every move will do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: For a more performant zoomable map, we'd have to use data with less detail when
    zoomed out, draw a sensible number of airports, and possibly avoid drawing parts
    of the map that fall out of the image anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '![Zoom](img/0007OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Brushes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to zoom and drag, brushes are a simple way to create complex behavior—they
    enable users to select a part of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Strangely enough, they aren't considered a behavior, but fall under the `.svg`
    namespace, perhaps because they are mostly meant for visual effects.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new brush, we'd call `d3.svg.brush()` and define its x and y scales
    using `.x()` and `.y()`. We can also define a bounding rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Time for an example!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to make a scatterplot of some random data and let the user select
    points. Begin with a drawing area and some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We used a built-in random generator to create numbers with a `normal` distribution
    centered around `.5` and a dispersion of `.11`. d3.js also gives us the `logNormal`
    and `irwinHall` distributions.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an array of 800 random two-dimensional positions. To draw them,
    we'll use two scales to make the tiny range more visible, then place each datum
    on the page as a circle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'I know we don''t usually add axes in this book, but scatterplots look ridiculous
    without them. Let''s add some:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You should remember what's going on here from [Chapter 2](ch02.html "Chapter 2. A
    Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*, where we discussed
    axes at length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some basic styling to the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And yay, scatterplot!
  prefs: []
  type: TYPE_NORMAL
- en: '![Brushes](img/0007OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now for the fun stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We made a new grouping element for the brush and called a freshly constructed
    `d3.svg.brush()` with both scales defined. The `"brush"` class will help with
    styling. Finally, we defined listeners for `brusthstart`, `brush`, and `brushend`
    events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`brushstart` flicks the styling to `selecting`. We''ll use it to help the user
    distinguish between selected and unselected circles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`brushmove` is where the real magic happens.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we find the selection's boundaries using `d3.event.target.extent()`.
    `d3.event.target` returns the current brush and `.extent()` returns a set of two
    points—upper-left and bottom-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we go through all the circles and turn the `selected` class on or off,
    depending on whether a circle''s position lies within the bounding box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`brushend` just turns off the selecting state if the selection is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our HTML needs some more styling definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We're changing the opacity of the circle fill (`fill-opacity)` rather than for
    the borders so that the circle edges always shine out at full opacity. Adding
    a CSS transition gives everything a smoother feel.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we prefer CSS transitions over what d3.js can do, so we can limit
    JavaScript to changing element states. Brushes sometimes also have problems with
    d3.js transitions and change properties immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you select some elements, the image will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Brushes](img/0007OS_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow, what a fun chapter!
  prefs: []
  type: TYPE_NORMAL
- en: You've made things jump around the page, almost killed your computer and patience
    with a zoomable map, and created a spinning thingy out of nothing but vertical
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: This is everything you need for visualizations users can play with. The rest
    is just experimentation and some ingenuity in piecing things together. Good luck!
  prefs: []
  type: TYPE_NORMAL
