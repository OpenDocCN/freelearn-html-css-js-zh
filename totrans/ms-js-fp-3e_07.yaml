- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Transforming Functions – Currying and Partial Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数转换——柯里化和偏应用
- en: In [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, we
    saw several ways of manipulating functions to get new versions with some changes
    in their functionality. In this chapter, we will go into a particular kind of
    transformation, a sort of **factory method** that lets you produce new versions
    of any given function.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B19301_06.xhtml#_idTextAnchor107)“生成函数”中，我们看到了几种操纵函数的方法，以获得功能有所改变的新版本。在本章中，我们将探讨一种特定的转换，一种**工厂方法**，它允许你生成任何给定函数的新版本。
- en: 'We will be considering the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑以下内容：
- en: '**Currying**: A classic FP theoretical function that transforms a function
    with many parameters into a sequence of unary functions'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**柯里化**：一个经典的FP理论函数，它将具有许多参数的函数转换为一串一元函数'
- en: '**Partial application**: Another time-honored FP transformation, which produces
    new versions of functions by fixing some of their arguments'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏应用**：这是FP中一个历史悠久的变化，通过固定函数的一些参数来产生新的函数版本'
- en: '**Partial currying** (a name of my own): Can be seen as a mixture of the two
    previous transformations'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分柯里化**（我自己的名字）：可以看作是前两种转换的混合'
- en: The techniques in this chapter will provide you with a different way of producing
    functions from other functions. To be fair, we’ll also see that some of these
    techniques can be emulated, possibly with greater clarity, by simple arrow functions.
    However, since you are liable to find currying and partial application in all
    sorts of texts and web pages on FP, it is important that you know their meaning
    and usage, even if you opt for a simpler way out. We’ll look at several applications
    of the ideas in the following sections.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的技术将为你提供从其他函数生成函数的不同方法。公平地说，我们还将看到，其中一些技术可以通过简单的箭头函数来模拟，可能更加清晰。然而，由于你可能会在各种关于FP的文本和网页中遇到柯里化和偏应用，了解它们的意义和用法是很重要的，即使你选择更简单的方法。我们将在接下来的几节中探讨这些想法的几个应用。
- en: A bit of theory
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点理论
- en: 'The concepts we’ll discuss in this chapter are in some ways very similar, and
    in other ways quite different. It’s common to find confusion about their real
    meanings, and plenty of web pages misuse terms. You could even say that all the
    transformations in this chapter are roughly equivalent since they let you transform
    a function into another one that fixes some parameters, leaving other parameters
    free, and eventually leading to the same result. Okay, I agree; this isn’t very
    clear! So, let’s start by clearing the air and providing some short definitions,
    which we will expand on later. (If you feel your eyes are glazing over, please
    skip this section and return to it later!) Yes, you may find the following descriptions
    a bit perplexing, but bear with us—we’ll go into more detail in just a bit:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将讨论的概念在某些方面非常相似，在其他方面则相当不同。常常会发现人们对它们的真正含义感到困惑，而且很多网页都误用了术语。你甚至可以说，本章中的所有变化在某种程度上都是大致等价的，因为它们允许你将一个函数转换成另一个函数，该函数固定了一些参数，而其他参数是自由的，最终得到相同的结果。好吧，我同意；这并不非常清楚！所以，让我们先澄清一下，并提供一些简短的定义，我们将在稍后进行扩展。（如果你觉得你的眼睛开始发花了，请跳过这一部分，稍后再回来！）是的，你可能会觉得以下描述有点令人困惑，但请耐心等待——我们将在稍后进行更详细的解释：
- en: '*Currying* is transforming an *m*-ary function (that is, a function of arity
    *m*) into a sequence of *m* unary functions, each receiving one argument of the
    original function, from left to right. (The first function receives the first
    argument of the original function and returns a second function, which receives
    the second argument and returns a third function, which receives the third argument,
    and so on.) Upon being called with an argument, each function produces the next
    one in the sequence, and the last one does the actual calculations.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*柯里化*是将一个*m*元函数（即参数数为*m*的函数）转换为一串*m*个一元函数的过程，每个一元函数接收原始函数的一个参数，从左到右。（第一个函数接收原始函数的第一个参数，并返回一个接收第二个参数的第二个函数，该第二个函数返回一个接收第三个参数的第三个函数，以此类推。）当被一个参数调用时，每个函数都会产生序列中的下一个函数，最后一个函数执行实际的计算。'
- en: '*Partial application* is providing *n* arguments to an *m*-ary function, with
    *n* less than or equal to *m*, to transform it into a function with (*m*-*n*)
    parameters. Each time you provide some arguments, a new function is produced,
    with smaller arity. When you provide the last arguments, the actual calculations
    are performed.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分应用* 是向一个 *m* 元函数提供 *n* 个参数，其中 *n* 小于或等于 *m*，将其转换为一个具有 (*m*-*n*) 个参数的函数。每次你提供一些参数，就会产生一个新的函数，具有更小的参数数量。当你提供最后一个参数时，实际的计算将被执行。'
- en: '*Partial currying* is a mixture of both preceding ideas: you provide *n* arguments
    (from left to right) to an *m*-ary function and produce a new function of arity
    (*m-n*). When this new function receives some other arguments, also from left
    to right, it will produce yet another function. When the last parameters are provided,
    the function produces the correct calculations.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分Currying* 是前两种思想的结合：你向一个 *m* 元函数提供 *n* 个参数（从左到右），并产生一个新的具有 (*m-n*) 个参数的函数。当这个新函数接收到其他参数时，也是从左到右，它将产生另一个函数。当提供最后一个参数时，函数将执行正确的计算。'
- en: In this chapter, we will see these three transformations, what they require,
    and ways of implementing them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到这三种转换，它们需要什么，以及实现它们的方法。
- en: Currying
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Currying
- en: We already mentioned *currying* back in the *Arrow functions* section of [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015)*, Becoming Functional,* and in the *One
    argument or many?* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, but let’s be more thorough here. Currying is a
    technique that enables you to only work with single-variable functions, even if
    you need a multi-variable one.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第1章*](B19301_01.xhtml#_idTextAnchor015) 的 *箭头函数* 部分，以及 [*第3章*](B19301_03.xhtml#_idTextAnchor054)
    的 *一个参数还是多个参数？* 部分中提到了 *Currying*，但在 *成为函数式编程者* 和 *开始使用函数* 中，我们将更加详细地介绍。Currying
    是一种技术，它使你能够只与单变量函数一起工作，即使你需要一个多变量函数。
- en: Currying by any other name?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简称“Currying”？
- en: The idea of converting a multi-variable function into a series of single-variable
    functions (or, more rigorously, reducing operators with several operands to a
    sequence of applications of a single operand operator) was worked on by Moses
    Schönfinkel. Some authors suggest, not necessarily tongue-in-cheek, that currying
    would be more correctly named *Schönfinkeling*!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将多变量函数转换为一系列单变量函数（或者更严格地说，将具有多个操作数的算子减少为单个操作数算子的应用序列）的想法是由 Moses Schönfinkel
    研究的。一些作者建议，不一定是在开玩笑，Currying 应该更正确地命名为 *Schönfinkeling*！
- en: In the following sections, we will first see how to deal with functions with
    many parameters, and then move on to how to curry by hand or by using `bind()`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将首先看到如何处理具有许多参数的函数，然后继续介绍如何手动Currying或使用 `bind()`。
- en: Dealing with many parameters
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多个参数
- en: 'The idea of currying, by itself, is simple. If you need a function with, say,
    three parameters, you could write something like the following by using arrow
    functions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Currying 的想法本身很简单。如果你需要一个具有三个参数的函数，你可以使用箭头函数编写如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can have a sequence of functions, each with a single parameter,
    as shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以有一系列函数，每个函数只有一个参数，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you might want to consider them as nested functions, like the
    following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能想将它们视为嵌套函数，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In terms of usage, there’s an essential difference in how you’d use each function.
    While you would call the first in the usual fashion, such as `make3("A",2,"Z")`,
    that wouldn’t work with the second definition. Let’s work out why: `make3curried()`
    is a unary (single parameter), so we should write `make3curried("A")`. But what
    does this return? According to the preceding definition, this also returns a unary
    function—and that function also returns a unary function! So, the correct call
    to get the same result as with the ternary function would be `make3curried("A")(2)("Z")`!
    See *Figure 7**.1*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用方面，使用每个函数的方式有一个本质的区别。虽然你会像通常那样调用第一个，例如 `make3("A",2,"Z")`，但这与第二个定义不兼容。让我们分析一下原因：`make3curried()`
    是一个一元（单个参数）函数，所以我们应该写 `make3curried("A")`。但这是什么返回值？根据前面的定义，这也返回一个一元函数——而且那个函数也返回一个一元函数！所以，要得到与三元函数相同的结果的正确调用应该是
    `make3curried("A")(2)("Z")`！请参见 *图7.1*：
- en: '![Figure 7.1 – The diﬀerence between a common function and a curried equivalent](img/Figure_7.1_B19301.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 普通函数与Currying等价函数的区别](img/Figure_7.1_B19301.jpg)'
- en: Figure 7.1 – The diﬀerence between a common function and a curried equivalent
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 普通函数与Currying等价函数的区别
- en: Study this carefully—we have the first function, and when we apply an argument
    to it, we get a second function. Applying an argument to it produces a third function,
    and a final application produces the desired result. This can be seen as a needless
    exercise in theoretical computing, but it actually brings some advantages because
    you can then always work with unary functions, even if you need functions with
    more parameters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究这个例子——我们有一个函数，当我们向它应用一个参数时，我们得到第二个函数。向第二个函数应用参数产生第三个函数，最终应用产生所需的结果。这可以看作是理论计算中的无意义练习，但实际上它带来了一些优势，因为你可以始终使用一元函数，即使你需要更多参数的函数。
- en: Currying versus uncurrying
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化与去柯里化
- en: Since there is a currying transformation, there is also an uncurrying one! In
    our case, we would write `make3uncurried = (a, b, c) => make3curried(a)(b)(c)`
    to reverse the currying process and make it usable once again, to provide all
    parameters in one sitting.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在柯里化转换，也存在去柯里化转换！在我们的例子中，我们会写 `make3uncurried = (a, b, c) => make3curried(a)(b)(c)`
    来逆转柯里化过程，使其再次可用，一次提供所有参数。
- en: In some languages, such as Haskell, functions are only allowed to take a single
    parameter—but then again, the language’s syntax allows you to invoke functions
    as if multiple parameters were permitted. For our example, in Haskell, writing
    `make3curried "A" 2 "Z"` would have produced `"A:2:Z"` without anybody even needing
    to be aware that it involved three function calls, each with one of our arguments.
    Since you don’t write parentheses around parameters and don’t separate them with
    commas, you cannot tell that you are not providing a triplet of values instead
    of three singular ones.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，例如 Haskell，函数只能接受单个参数——然而，该语言的语法允许你以允许多个参数的方式调用函数。在我们的例子中，在 Haskell 中，编写
    `make3curried "A" 2 "Z"` 将会生成 `"A:2:Z"`，甚至没有人需要意识到这涉及到三个函数调用，每个调用都有一个我们的参数。由于你不需要在参数周围写括号，也不需要用逗号分隔它们，所以你无法知道你提供的是三个单独的值而不是一个三元组。
- en: Currying is basic in Scala or Haskell, which are fully functional languages,
    but JavaScript has enough features to allow us to define and use currying in our
    work. It won’t be as easy since, after all, it’s not built-in—but we’ll be able
    to manage.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化在 Scala 或 Haskell 中是基本的，它们是完全函数式语言，但 JavaScript 具有足够的特性，允许我们在工作中定义和使用柯里化。这不会那么容易，因为毕竟它不是内置的——但我们能够处理。
- en: 'So, to review the basic concepts, the key differences between our original
    `make3()` and `make3curried()` functions are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了回顾基本概念，我们的原始 `make3()` 和 `make3curried()` 函数之间的关键区别如下：
- en: '`make3()` is a ternary function, but `make3curried()` is unary'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make3()` 是一个三元函数，但 `make3curried()` 是一元函数'
- en: '`make3()` returns a string; `make3curried()` returns another function—which
    itself returns a second function, which returns yet a third function, which finally
    does return a string'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make3()` 返回一个字符串；`make3curried()` 返回另一个函数——该函数本身返回第二个函数，该函数返回第三个函数，最终返回一个字符串'
- en: You can produce a string by writing something like `make3("A",2,"Z")`, which
    returns `"A:2:Z"`, but you’ll have to write `make3curried("A")(2)("Z")` to get
    the same result
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过编写类似 `make3("A",2,"Z")` 的内容来生成一个字符串，它返回 `"A:2:Z"`，但你需要编写 `make3curried("A")(2)("Z")`
    来得到相同的结果
- en: 'Why would you go to all this bother? Let’s look at a simple example, and further
    on, we will look at more examples. Suppose you had a function that calculated
    the value-added tax (VAT) for an amount, as shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你要费这么大的力气？让我们看看一个简单的例子，然后我们还会看到更多例子。假设你有一个函数用来计算金额的增值税（VAT），如下所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you had to apply a single, constant rate, you could curry the `addVAT()`
    function to produce a more specialized version that always applied your given
    rate. For example, if your national rate was 6%, you could then have something
    like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须应用一个单一的、恒定的税率，你可以将 `addVAT()` 函数柯里化，以产生一个更专业的版本，该版本始终应用你给出的税率。例如，如果你的国家税率是
    6%，那么你就可以有如下所示的内容：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first line defines a curried version of our VAT-calculating function. Given
    a tax rate, `addVATcurried()` returns a new function, which, when given an amount
    of money, finally adds the original tax rate to it. So, if the national tax rate
    were 6%, `addNationalVAT()` would be a function that added 6% to any amount given
    to it. For example, if we were to calculate `addNationalVAT(1500)`, as in the
    preceding code, the result would be `1590`: $1,500, plus 6% tax.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了我们VAT计算函数的curried版本。给定一个税率，`addVATcurried()`返回一个新的函数，当给定一个金额时，最终将原始税率加到它上面。所以，如果国家税率是6%，`addNationalVAT()`将是一个将6%加到它所接收的任何金额上的函数。例如，如果我们计算`addNationalVAT(1500)`，就像前面的代码中那样，结果将是`1590`：$1,500加上6%的税。
- en: 'Of course, you are justified in saying that this currying thing is a bit too
    much just to add a 6% tax, but the simplification is what counts. Let’s look at
    one more example. In your application, you may want to include some logging with
    a function such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你有理由说，这种currying方法只是为了加6%的税而有点过度，但简化才是关键。让我们再看一个例子。在你的应用程序中，你可能想使用如下函数添加一些日志：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, with this approach, every time you wanted to display a normal log
    message, you would write `myLog("NORMAL", "some normal text")`, and for warnings,
    you’d write `myLog("WARNING", "some warning text")`. You could simplify this a
    bit with currying, by fixing the first parameter of `myLog()` as follows, with
    a `curry()` function that we’ll look at later. Our code could then be as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这种方法，每次你想显示一个正常的日志消息时，你都会写`myLog("NORMAL", "some normal text")`，对于警告，你会写`myLog("WARNING",
    "some warning text")`。你可以通过以下方式使用currying简化这一点，固定`myLog()`的第一个参数，如下所示，使用我们稍后将要看到的`curry()`函数。然后我们的代码可以是这样的：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What do you gain? Now, you can write `myNormalLog("some normal text")` or `myWarningLog("some
    warning text")` because you have curried `myLog()` and then fixed its argument,
    making for simpler, easier-to-read code!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到了什么？现在，你可以写`myNormalLog("some normal text")`或`myWarningLog("some warning
    text")`，因为你已经curried `myLog()`并固定了它的参数，这使得代码更简单、更容易阅读！
- en: 'By the way, if you prefer, you could have also achieved the same result in
    a single step, with the original uncurried `myLog()` function, by currying it
    case by case:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你愿意，你也可以通过一步实现相同的结果，使用原始的非curried `myLog()`函数，通过逐个case进行currying：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, having a `curry()` function lets you fix some arguments while leaving others
    still open; let’s see how to do this in three different ways.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，有一个`curry()`函数让你可以固定一些参数，同时让其他参数仍然开放；让我们看看如何以三种不同的方式做到这一点。
- en: Currying by hand
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动currying
- en: Before trying more complex things, we could curry a function by hand, without
    any special auxiliary functions or anything else. And, in fact, if we want to
    implement currying for a particular case, there’s no need to do anything complex
    because we can manage with simple arrow functions. We saw that with both `make3curried()`
    and `addVATcurried()`, so there’s no need to revisit that idea.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试更复杂的事情之前，我们可以手动curry一个函数，而不需要任何特殊的辅助函数或其他任何东西。实际上，如果我们想为特定情况实现currying，没有必要做复杂的事情，因为我们可以用简单的箭头函数来处理。我们在`make3curried()`和`addVATcurried()`中都看到了这一点，所以没有必要重新审视这个想法。
- en: 'Instead, let’s look into some ways of doing that automatically, so we can produce
    an equivalent curried version of any function, even without knowing its arity
    beforehand. Going further, we should code a more intelligent version of a function
    that could work differently depending on the number of received arguments. For
    example, we could have a `sum(x,y)` function that behaved as in the following
    examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们看看一些自动完成这个任务的方法，这样我们就可以生成任何函数的等效curried版本，甚至不需要事先知道它的arity。更进一步，我们应该编写一个更智能的函数版本，它可以根据接收到的参数数量以不同的方式工作。例如，我们可以有一个`sum(x,y)`函数，其行为如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can achieve that behavior by hand. Our function would be something like
    the following – and since we won’t be using this style, let’s stay with plain
    JavaScript, with no typing:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过手动实现这种行为。我们的函数可能如下所示——由于我们不会使用这种风格，让我们保持使用纯JavaScript，不使用类型：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s recap what we did here. Our curried-by-hand function has this behavior:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在这里做了什么。我们手动编写的curried函数具有以下行为：
- en: If we call it with two arguments, it adds them and returns the sum; this provides
    our first use case, as in `sum(3,5)===8`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们用两个参数调用它，它将它们相加并返回总和；这提供了我们的第一个用例，就像`sum(3,5)===8`。
- en: 'If only one argument is provided, it returns a new function. This new function
    expects a single argument and will return the sum of that argument and the original
    one: this behavior is what we expected in the other two use cases, such as `add2(3)===5`
    or `sum(2)(7)===9`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只提供了一个参数，它将返回一个新的函数。这个新函数期望一个参数，并将返回该参数与原始参数的和：这正是我们在其他两个用例中期望的行为，例如`add2(3)===5`或`sum(2)(7)===9`。
- en: Finally, if no arguments are provided, it returns itself. This means that we
    would be able to write `sum()(1)(2)` if we desired. (No, I cannot think of a reason
    for wanting to write that.)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果没有提供任何参数，它将返回自身。这意味着如果我们想的话，我们可以写`sum()(1)(2)`。（不，我想不出为什么要写那个。）
- en: So, we can incorporate currying in the definition itself of a function. However,
    you’ll have to agree that dealing with all the special cases in each function
    could quickly become troublesome and error-prone. So, let’s work out some generic
    ways of accomplishing the same result without any particular coding.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在函数的定义本身中结合柯里化。然而，你必须同意处理每个函数中的所有特殊情况可能会很快变得麻烦且容易出错。所以，让我们找出一些通用的方法来完成相同的结果，而不需要特定的编码。
- en: Currying with bind()
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bind()进行柯里化
- en: We can find a solution to currying by using the `bind()` method, which we have
    already applied in several places in this book. This allows us to fix one argument
    (or more, if need be; we won’t need to do that here, but later on we will use
    it) and provide a function with that fixed argument. Of course, many libraries
    (such as Lodash, Underscore, Ramda, and others) provide this functionality, but
    we want to see how to implement that ourselves.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`bind()`方法来找到柯里化的解决方案，这种方法我们在本书的几个地方已经应用过了。这允许我们固定一个参数（或者如果需要的话，可以固定多个参数；在这里我们不需要这么做，但稍后我们会用到它）并提供一个带有这个固定参数的函数。当然，许多库（如Lodash、Underscore、Ramda等）都提供了这个功能，但我们想看看如何自己实现它。
- en: A plain JavaScript version
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯JavaScript版本
- en: 'Our implementation is relatively short but will require some explanation. First,
    let’s see a JavaScript version and deal with TypeScript later:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现相对较短，但需要一些解释。首先，让我们看看JavaScript版本，稍后再处理TypeScript：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Start by noticing that `curryByBind()` always returns a new function, which
    depends on the `fn` function given as its parameter. If the function has no (more)
    parameters left (when `fn.length===0`) because all parameters have already been
    bound, we can evaluate it by using `fn()`. Otherwise, the result of currying the
    function will be a new function that receives a single argument and produces a
    newly curried function with another fixed argument. Let’s see this in action,
    with a detailed example, using the `make3()` function we saw at the beginning
    of this chapter once again:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要注意`curryByBind()`总是返回一个新的函数，它依赖于作为其参数提供的`fn`函数。如果函数没有（更多）参数（当`fn.length===0`）因为所有参数都已经绑定，我们可以通过使用`fn()`来评估它。否则，函数柯里化的结果将是一个接收单个参数并产生一个新的带有另一个固定参数的柯里化函数的新函数。让我们通过一个详细的例子来看看这个动作，再次使用我们在本章开头看到的`make3()`函数：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The explanation of this code is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的解释如下：
- en: The first function, `f1()`, has yet to receive any arguments. When called with
    an argument, it will produce a curried version of `make3()`, with its first argument
    fixed.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数`f1()`还没有收到任何参数。当调用一个参数时，它将产生一个带有固定第一个参数的`make3()`的柯里化版本。
- en: Calling `f1("A")` produces a new unary function, `f2()`, which will itself produce
    a curried version of `make3()`—but with its first argument set to `"A"`, so actually,
    the new function will end up fixing the second parameter of `make3()`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`f1("A")`会产生一个新的单参数函数`f2()`，它本身将产生一个带有其第一个参数设置为`"A"`的`make3()`的柯里化版本——但实际上，这个新函数最终会固定`make3()`的第二个参数。
- en: Similarly, calling `f2(2)` produces a third unary function, `f3()`, which will
    produce a version of `make3()`, but fixing its third argument, since the first
    two have already been fixed.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，调用`f2(2)`会产生一个第三个一元函数`f3()`，它将产生一个`make3()`的版本，但固定其第三个参数，因为前两个参数已经被固定了。
- en: Finally, when we calculate `f3("Z")`, this fixes the last parameter of `make3()`
    to `"Z"`, and since there are no more arguments left, the thrice-bound `make3()`
    function is called and the `"A:2:Z"` result is produced.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当我们计算`f3("Z")`时，这会将`make3()`的最后一个参数固定为`"Z"`，由于没有更多的参数了，三次绑定的`make3()`函数被调用，并产生了`"A:2:Z"`的结果。
- en: 'You can do other call sequences as well, such as the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以做其他的调用序列，例如以下内容：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To curry the function by hand, you could use JavaScript’s `.bind()` method.
    The sequence would be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动柯里化函数，你可以使用 JavaScript 的 `.bind()` 方法。顺序如下：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In each step, we provide an additional parameter. (The `null` value is required,
    to provide context. If it were a method attached to an object, we would provide
    that object as the first parameter to `.bind()`. Since that’s not the case, `null`
    is expected.) This is equivalent to what our code does, except that the last time,
    `curryByBind()` does the actual calculation instead of making you do it, as in
    `step3()`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，我们提供一个额外的参数。（需要 `null` 值以提供上下文。如果这是一个附加到对象上的方法，我们将提供该对象作为 `.bind()` 的第一个参数。由于情况并非如此，因此预期为
    `null`。）这与我们的代码所做的工作等效，只是最后一次，`curryByBind()` 实际上进行了计算，而不是像 `step3()` 那样让你去做。
- en: A TypeScript version
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TypeScript 版本
- en: 'Now that have implemented this in JavaScript, let’s see how to define types
    for currying. We have to work recursively and consider two cases:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 JavaScript 中实现了这个功能，让我们看看如何定义柯里化的类型。我们必须递归地工作并考虑两种情况：
- en: If we curry a function with just one parameter, the function will directly produce
    the desired result
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们只对一个参数进行柯里化，该函数将直接产生所需的结果
- en: 'If we curry a function with two or more parameters, we’ll create a unary function
    (with the first parameter) that will return a (curried!) function that will deal
    with the rest of the parameters:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们对具有两个或更多参数的函数进行柯里化，我们将创建一个一元函数（具有第一个参数），该函数将返回一个（柯里化！）函数，该函数将处理其余的参数：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will have a generic type with two inputs: `P`, representing the parameters
    of the function to process, and `R`, standing for the result type of that function.
    If `P` has just one type, `H`, we return a function that, given an argument of
    the `H` type, returns a result of the `R` type. If `P` is formed by a first `H`
    type (“head”) and some other `T` types (“tail”), we return a function that will
    return a (curried) function with `T` types as arguments.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个具有两个输入的通用类型：`P`，代表要处理的函数的参数，`R` 代表该函数的结果类型。如果 `P` 只有一个类型 `H`，我们返回一个函数，给定一个
    `H` 类型的参数，返回一个 `R` 类型的结果。如果 `P` 由一个 `H` 类型的第一个（“头部”）和一些其他 `T` 类型（“尾部”）组成，我们返回一个函数，该函数将返回一个具有
    `T` 类型参数的（柯里化）函数。
- en: 'Using this type has an added complexity. TypeScript cannot verify that our
    `curryByBind()` function works correctly because it cannot deduce that, for every
    function, we’ll eventually produce a result instead of yet another curried function.
    There’s a tricky solution involving an overloaded function with just *one* signature.
    The key is that the implementation is checked more loosely, and you can use `any`
    types to get by. Of course, working like this isn’t precisely type-safe; it’s
    up to you to ensure that the function is type-correct because you are essentially
    bypassing TypeScript’s checks. We’ll have to do this kind of trick more than once
    in this chapter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种类型有一个额外的复杂性。TypeScript 无法验证我们的 `curryByBind()` 函数是否正确工作，因为它无法推断出，对于每个函数，我们最终会产生一个结果而不是另一个柯里化函数。有一个涉及只有一个签名（*one*
    signature）的重载函数的巧妙解决方案。关键是实现检查得更宽松，你可以使用 `any` 类型来通过。当然，这样工作并不完全类型安全；你必须确保函数类型正确，因为你实际上绕过了
    TypeScript 的检查。在本章中，我们不得不做这类技巧不止一次：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s go back to our `make3()` example. Types work out perfectly well:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `make3()` 示例。类型工作得非常完美：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type of `f1` is key; it shows that our recursive typing worked as expected.
    The types of `f2` and `f3` are shorter, and the type of `f4` is the type of the
    final result, `string`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1` 的类型是关键；它表明我们的递归类型工作正如预期。`f2` 和 `f3` 的类型更短，而 `f4` 的类型是最终结果 `string` 的类型。'
- en: Currying tests
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 柯里化测试
- en: 'Testing this transformation is rather simple because there are not many possible
    ways of currying:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这种转换相对简单，因为柯里化的可能方式并不多：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What else could you test? Maybe functions with just one parameter could be added,
    but there are no more to try.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你还能测试什么？也许可以添加只有一个参数的函数，但已经没有更多可以尝试的了。
- en: Partial application
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: The second transformation we will be considering lets you fix some of the function’s
    parameters, creating a new function that will receive the rest of them. Let’s
    make this clear with a nonsense example. Imagine you have a function with five
    parameters. You might want to fix the second and fifth parameters, and partial
    application would produce a new version of the function that fixed those two parameters
    but left the other three open for new calls. If you called the resulting function
    with the three required arguments, it would produce the correct answer by using
    the original two fixed parameters plus the newly provided three.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的第二种转换允许你固定函数的一些参数，创建一个新的函数，该函数将接收其余的参数。让我们用一个无意义的例子来说明这一点。假设你有一个有五个参数的函数。你可能想要固定第二个和第五个参数，部分应用将生成一个新的函数版本，固定这两个参数，但留下其他三个参数开放供新的调用。如果你用三个必需的参数调用这个结果函数，它将通过使用原始的两个固定参数加上新提供的三个参数来产生正确的答案。
- en: Projecting parameters
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 投影参数
- en: 'The idea of specifying only some parameters in function application, producing
    a function of the remaining parameters, is called **projection**: you are said
    to be projecting the function onto the remaining arguments. We will not use this
    term, but I wanted to cite it in case you find it elsewhere.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数应用中仅指定一些参数，生成剩余参数的函数，这种思想被称为**投影**：你可以说你在将函数投影到剩余的参数上。我们不会使用这个术语，但我想在你在其他地方找到它时引用它。
- en: Let’s consider an example using the `fetch()` API, widely considered the modern
    way to go for Ajax calls. You might want to fetch several resources, always specifying
    the same parameters for the call (for example, request headers) and only changing
    the URL to search. By using partial application, you could create a new `myFetch()`
    function that would always provide fixed parameters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个使用`fetch()` API的例子，它被广泛认为是进行Ajax调用的现代方式。你可能想要获取多个资源，始终为调用指定相同的参数（例如，请求头）并且只更改搜索的URL。通过使用部分应用，你可以创建一个新的`myFetch()`函数，该函数将始终提供固定参数。
- en: On fetching
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取数据
- en: You can read more on `fetch()` at [developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](http://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
    According to [caniuse.com/#search=fetch](http://caniuse.com/#search=fetch), you
    can use it in most browsers except for (oh, surprise!) Internet Explorer, but
    you can get around this limitation with a polyfill, such as the one found at [github.com/github/fetch](http://github.com/github/fetch).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](http://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)上了解更多关于`fetch()`的信息。根据[caniuse.com/#search=fetch](http://caniuse.com/#search=fetch)，你可以在除（哦，惊喜！）Internet
    Explorer之外的大多数浏览器中使用它，但你可以通过polyfill来绕过这个限制，例如在[github.com/github/fetch](http://github.com/github/fetch)上找到的一个。
- en: 'Let’s assume we have a `partial()` function that implements this kind of application
    and let’s see how we’d use that to produce our new, specialized version of `fetch()`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`partial()`函数实现了这种应用，让我们看看我们如何使用它来产生我们新的、专门的`fetch()`版本：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Currying would have worked if the request parameters had been the first argument
    for `fetch()`. (We’ll have more to say about the order of parameters later.) With
    partial application, you can replace any arguments, no matter which, so in this
    case, `myFetch()` ends up as a unary function. This new function will get data
    from any URL you wish, always passing the same set of parameters for the `GET`
    operation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求参数是`fetch()`的第一个参数，柯里化（currying）将有效。（我们稍后会更多地说到参数的顺序。）使用部分应用，你可以替换任何参数，无论哪个，所以在这种情况下，`myFetch()`最终成为一个一元函数。这个新函数将获取你想要的任何URL的数据，始终传递相同的参数集进行`GET`操作。
- en: Partial application with arrow functions
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用箭头函数进行部分应用
- en: 'Trying to do partial application by hand, as we did with currying, is too complicated.
    For instance, for a function with 5 parameters, you would have to write code allowing
    the user to provide any of the 32 possible combinations of fixed and unfixed parameters
    – 32 being equal to 2 raised to the fifth power. Even if you could simplify the
    problem, it would still remain hard to write and maintain. See *Figure 7**.2*
    for one of many possible combinations:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试手动进行部分应用，就像我们处理柯里化（currying）那样，过于复杂。例如，对于一个有5个参数的函数，你需要编写代码，允许用户提供32种可能的固定和未固定参数组合——32等于2的5次方。即使你可以简化问题，编写和维护代码仍然会很困难。参见*图7**.2*，展示了许多可能的组合之一：
- en: '![Figure 7.2 – Partial application may let you ﬁrst provide some parameters,
    and then provide the rest, to ﬁnally get the result](img/Figure_7.2_B19301.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 部分应用可以先提供一些参数，然后提供剩余的参数，最终得到结果](img/Figure_7.2_B19301.jpg)'
- en: Figure 7.2 – Partial application may let you ﬁrst provide some parameters, and
    then provide the rest, to ﬁnally get the result
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 部分应用可以先提供一些参数，然后提供剩余的参数，最终得到结果
- en: 'Doing partial application with arrow functions, however, is much simpler. With
    the example we mentioned previously, we would have something like the following
    code. In this case, we will assume we want to fix the second parameter to `22`
    and the fifth parameter to `1960`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用箭头函数进行部分应用要简单得多。以我们之前提到的例子为例，我们会有以下代码。在这种情况下，我们将假设我们想要将第二个参数固定为`22`，第五个参数固定为`1960`：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Doing partial application this way is quite simple, though we may want to find
    a more general solution. You can set any number of parameters, by creating a new
    function out of the previous one but fixing some more parameters. (Wrappers, as
    in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, could
    be used.) For instance, you might now want to also fix the last parameter of the
    new `fix2and5()` function to `9`, as shown in the following code; there’s nothing
    easier:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式进行部分应用相当简单，尽管我们可能想要找到一个更通用的解决方案。你可以通过从先前的函数中创建一个新的函数并固定更多的参数来设置任意数量的参数。（正如[*第6章*](B19301_06.xhtml#_idTextAnchor107)，*生成函数*中提到的，可以使用包装器。）例如，你现在可能还想要将新函数`fix2and5()`的最后一个参数固定为`9`，如下面的代码所示；这没有什么更简单的了：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You might also have written `nonsense(a, 22, c, 9, 1960)` if you wished to,
    but the fact remains that fixing parameters by using arrow functions is simple.
    Let’s now consider, as we said, a more general solution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你也可以写成`nonsense(a, 22, c, 9, 1960)`，但事实仍然是，使用箭头函数固定参数很简单。现在，让我们考虑我们所说的更通用的解决方案。
- en: Partial application with closures
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用闭包进行部分应用
- en: 'If we want to be able to do partial application fixing of any combination of
    parameters, we must have a way to specify which arguments are to be left free
    and which will be fixed from that point on. Some libraries, such as Underscore
    and Lodash, use a special `_` object to signify an omitted parameter. In this
    fashion, still using the same `nonsense()` function, we would write the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要能够固定任何参数组合的部分应用，我们必须有一种方法来指定哪些参数将被保留为自由参数，哪些参数将从该点开始固定。一些库，如Underscore和Lodash，使用一个特殊的对象`_`来表示省略的参数。以这种方式，仍然使用相同的`nonsense()`函数，我们会编写以下内容：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We could do the same sort of thing by having a global variable that would represent
    a pending, not yet fixed argument, but let’s make it simpler and just use `undefined`
    to represent a missing parameter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过有一个表示待定、尚未固定的参数的全局变量来做同样的事情，但让我们让它更简单，只用`undefined`来表示缺失的参数。
- en: Careful comparison
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 小心比较
- en: When checking for `undefined`, remember to always use the `===` operator; with
    `==`, it happens that `null==undefined`, and you don’t want that. See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined)
    for more on this.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查`undefined`时，请记住始终使用`===`运算符；使用`==`时，`null==undefined`会发生，你不想这样。有关更多信息，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined)。
- en: 'We want to write a function that will partially apply some arguments and leave
    the rest open for the future. We want to write code similar to the following and
    produce a new function in the same fashion as we did earlier with arrow functions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编写一个函数，它将部分应用一些参数，并将剩余的参数留待将来使用。我们希望编写的代码类似于以下内容，并以与之前箭头函数相同的方式生成一个新的函数：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'How will we do this? Our implementation will use closures. (You may want to
    review that topic in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming
    Functional*.) This way of doing partial application will behave in a fashion somewhat
    reminiscent of currying in the sense that each function will produce a new one
    with some more fixed parameters. Our new implementation would be as follows –
    and once again, let’s start with plain JavaScript:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何实现这一点？我们的实现将使用闭包。（你可能需要回顾一下[*第1章*](B19301_01.xhtml#_idTextAnchor015)，*成为函数式开发者*。）这种部分应用的方式在某种程度上类似于柯里化，因为每个函数都会产生一个新的函数，并带有更多的固定参数。我们新的实现将如下所示——而且，让我们再次从纯JavaScript开始：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Wow—a longish bit of code! The key is the inner `partialize()` function. Given
    a list of parameters (`args1`), it produces a function that receives a second
    list of parameters (`args2`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 哇——一段相当长的代码！关键是内部的`partialize()`函数。给定一个参数列表（`args1`），它产生一个接收第二个参数列表（`args2`）的函数：
- en: First, it replaces all possible `undefined` values in `args1` with values from
    `args2`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它将`args1`中所有可能的`undefined`值替换为`args2`中的值
- en: Then, if any parameters are left in `args2`, it also appends them to those of
    `args1`, producing `allParams`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，如果`args2`中还有任何参数，它也将它们追加到`args1`的参数中，生成`allParams`
- en: Finally, if `allParams` does not include any more `undefined` values and is
    sufficiently long, it calls the original function
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果`allParams`不再包含任何`undefined`值并且足够长，它将调用原始函数
- en: Otherwise, it partializes itself to wait for more parameters
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它将部分化自身以等待更多的参数
- en: 'An example will make it more clear. Let’s go back to our trusty `make3()` function
    and construct a partial version of it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子会使它更清楚。让我们回到我们信任的`make3()`函数，并构建它的部分版本：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `f1()` function gets `[undefined, 2]` as parameters. Now, let’s create
    a new function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1()`函数接收`[undefined, 2]`作为参数。现在，让我们创建一个新的函数：'
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What happens? The previous list of parameters (`[undefined, 2]`) gets merged
    with the new list (a single element—in this case, `["A"]`), producing a function
    that now receives `"A"` and `2` as its first two arguments. However, this isn’t
    yet ready, because the original function requires three arguments. We can write
    the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？先前的参数列表（`[undefined, 2]`）与新列表（一个元素——在这种情况下，`["A"]`）合并，生成一个现在接收`"A"`和`2`作为其前两个参数的函数。然而，这还不是最终的，因为原始函数需要三个参数。我们可以写出以下内容：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, the current list of arguments would be merged with the new argument, producing
    `["A",2,"Z"]`. Since the list is now complete, the original function will be evaluated,
    producing `"A:2:Z"` as the final result.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当前参数列表将与新参数合并，生成`["A",2,"Z"]`。由于列表现在完整，原始函数将被评估，生成`"A:2:Z"`作为最终结果。
- en: 'There are significant similarities between the structure of this code and the
    other higher-order function we wrote earlier in the *Currying with* *bind()* section:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结构与其他我们在*柯里化与* *bind()*部分写过的其他高阶函数有显著的相似之处：
- en: If all the arguments have been provided, the original function is called
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有参数都已提供，将调用原始函数
- en: Otherwise, if some arguments are still required (when currying, it’s just a
    matter of counting arguments by checking the function’s `length` property; when
    doing partial application, you must also consider the possibility of having some
    `undefined` parameters), the higher-order function calls itself to produce a new
    version of the function, which will wait for the missing arguments
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果还需要一些参数（在柯里化时，这只是一个通过检查函数的`length`属性来计数参数的问题；在部分应用时，你还必须考虑存在一些`undefined`参数的可能性），高阶函数会调用自身以产生函数的新版本，该版本将等待缺失的参数
- en: Let’s get now to a TypeScript version with its data typing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个带有其数据类型的TypeScript版本。
- en: Partial data types
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分数据类型
- en: 'We’ll use an auxiliary type, `Partialize<P,A>`. If `P` is the tuple of the
    parameter types for the function, and `A` is the tuple of the argument types for
    a function call, `Partialize<>` will return a tuple with the types in `P` for
    which there is an `undefined` type in `A`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个辅助类型，`Partialize<P,A>`。如果`P`是函数参数类型的元组，而`A`是函数调用参数类型的元组，`Partialize<>`将返回一个元组，其中包含`P`中在`A`中有`undefined`类型的类型：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How does this work?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？
- en: If `P` is empty, the output is empty as well.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`P`为空，输出也是空的。
- en: If `A` is empty (there are no more arguments left), the output is `P`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`A`为空（没有更多的参数），输出是`P`。
- en: If `P` is split in `PH` (head) and `PT` (tail), and `A` is similarly split in
    `AH` and `AT`, then if `AH` is `undefined`, we return a new type that includes
    `PH` (because no value was given for it) and `Partialize<PT,AT>`, to recursively
    process the rest of both tuples. Otherwise, if `AH` is not `undefined`, we provide
    a value for the corresponding parameter, so the result is `Partialize<PT,AT>`;
    we don’t have to care about the parameter corresponding to `PH`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`P`被分成`PH`（头部）和`PT`（尾部），并且`A`也被类似地分成`AH`和`AT`，那么如果`AH`是`undefined`，我们返回一个新类型，它包括`PH`（因为没有为其提供值）和`Partialize<PT,AT>`，以递归处理这两个元组的其余部分。否则，如果`AH`不是`undefined`，我们为相应的参数提供一个值，因此结果是`Partialize<PT,AT>`；我们不必关心与`PH`对应的参数。
- en: 'Using recursion makes this harder to understand; let’s see some examples:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归使得这更难理解；让我们看看一些例子：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For instance, the `p04` type shows that if you have a function that expects
    three parameters – `boolean`, `number`, and `string` – and you call it with a
    `boolean`, an `undefined` value, and a `string`, the partialized function will
    have just a `number` parameter. The `p05` type shows that if you had called that
    function with just a `boolean`, the partialized function would have a `number`
    and a `string` as parameters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`p04` 类型表明，如果你有一个期望三个参数（`boolean`、`number` 和 `string`）的函数，并且你用 `boolean`、`undefined`
    值和 `string` 调用它，那么偏应用后的函数将只有一个 `number` 参数。`p05` 类型表明，如果你只使用 `boolean` 调用该函数，那么偏应用后的函数将有
    `number` 和 `string` 作为参数。
- en: 'This isn’t totally right, however. Let’s say we had written the following instead:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不完全正确。假设我们写的是以下内容：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result would have been the same; we are checking that we have the right
    number of arguments, but not their types. Let’s have another auxiliary type check:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是相同的；我们正在检查我们是否有正确数量的参数，但不是它们的类型。让我们再做一个辅助类型检查：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`TypesMatch` gets two lists of types, `P` and `A`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypesMatch` 获取两个类型列表 `P` 和 `A`：'
- en: If any of the lists is empty, that’s OK.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何一个列表为空，那没关系。
- en: If both lists are not empty, it splits them in head and tail as `PH` and `PT`,
    and `AH` and `AT`. If `AH` is `undefined`, or if it matches `PH`, then `TypesMatch<>`
    keeps going to analyze both tails.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个列表都不为空，它将它们分为头部和尾部，分别记为 `PH` 和 `PT`，以及 `AH` 和 `AT`。如果 `AH` 是 `undefined`，或者如果它与
    `PH` 匹配，那么 `TypesMatch<>` 将继续分析两个尾部。
- en: If `AH` isn’t `undefined` but doesn’t match `PH`, `never` (which implies an
    error) is generated.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `AH` 不是 `undefined` 但不匹配 `PH`，将生成 `never`（这表示错误）。
- en: 'We can now write the `Partial<>` generic type using this auxiliary definition:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个辅助定义来编写 `Partial<>` 泛型类型：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, `P` stands for the types of the function’s parameters, `R` for its result
    type, and `A` for the types of the function’s arguments. We first check whether
    `P` and `A` match types. If so, if `Partialize<P,A>` is empty, we return a `(...x:
    [...P]) => R` function; otherwise, we (recursively) return a function with `Partialize<P,A>`
    parameter types.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`P` 代表函数参数的类型，`R` 代表其结果类型，`A` 代表函数参数的类型。我们首先检查 `P` 和 `A` 是否匹配类型。如果是这样，如果
    `Partialize<P,A>` 为空，我们返回一个 `(...x: [...P]) => R` 函数；否则，我们（递归地）返回一个具有 `Partialize<P,A>`
    参数类型的函数。'
- en: 'Finally, we have all we need for our TypeScript version of `partial()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们拥有了编写 TypeScript 版本的 `partial()` 所需的一切：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It’s worth noting that, as in the currying examples, we use several `any` types
    because TypeScript isn’t really very good at working with recursion. This implies
    that we must be extra careful with our code because there will be no way of detecting
    errors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，正如在柯里化示例中一样，我们使用了多个 `any` 类型，因为 TypeScript 并非特别擅长处理递归。这意味着我们必须格外小心我们的代码，因为将无法检测到错误。
- en: Partial testing
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偏测试
- en: 'Let’s finish this section by writing some tests. Here are some things we should
    consider:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一些测试来完成这个部分。以下是我们应该考虑的一些事情：
- en: When we do partial application, the arity of the produced function should decrease
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们进行偏应用时，产生的函数的arity应该减少
- en: The original function should be called when arguments are in the correct order
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当参数顺序正确时，应该调用原始函数
- en: 'We could write something like the following, allowing the fixing of arguments
    in different places. Instead of using a spy or mock, we can directly work with
    the `nonsense()` function we had because it’s quite efficient:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写点像下面这样的东西，允许在不同位置修复参数。而不是使用间谍或模拟，我们可以直接与 `nonsense()` 函数一起工作，因为它相当高效：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have now seen currying and partial application; let’s see our third and last
    transformation, a hybrid of our previous ones.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了柯里化和偏应用；让我们看看我们的第三个也是最后一个转换，它是我们之前方法的混合体。
- en: Partial currying
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偏柯里化
- en: The last transformation we will look at is a mixture of currying and partial
    application. If you google it, in some places, you will find it called currying,
    and in others, partial application, but as it happens, it fits neither, so I’m
    sitting on the fence and calling it *partial currying*!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的最后一个转换是柯里化和偏应用的混合体。如果你在谷歌上搜索它，你会在一些地方找到它被称为柯里化，在其他地方被称为偏应用，但事实上，它既不是柯里化也不是偏应用，所以我站在中间，称之为
    *偏柯里化*！
- en: 'Given a function, the idea is to fix its first few arguments and produce a
    new function that will receive the rest of them. However, if that new function
    is given fewer arguments, it will fix whatever it was given and produce a newer
    function to receive the rest of them, until all the arguments are given and the
    final result can be calculated. See *Figure 7**.3*:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个函数，我们的想法是固定其前几个参数，并产生一个新的函数，该函数将接收其余的参数。然而，如果这个新函数接收到的参数更少，它将固定所提供的参数，并产生一个新的函数来接收其余的参数，直到所有参数都给出，最终结果可以计算。参见
    *图 7.3**.3*：
- en: '![Figure 7.3 – Partial currying is a mixture of currying and partial application.
    You may provide arguments from the left, in any quantity, until all have been
    provided, and then the result is calculated](img/Figure_7.3_B19301.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 部分柯里化是柯里化和部分应用的混合。你可以提供任意数量的参数，从左侧开始，直到所有参数都提供，然后计算结果](img/Figure_7.3_B19301.jpg)'
- en: Figure 7.3 – Partial currying is a mixture of currying and partial application.
    You may provide arguments from the left, in any quantity, until all have been
    provided, and then the result is calculated
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 部分柯里化是柯里化和部分应用的混合。你可以提供任意数量的参数，从左侧开始，直到所有参数都提供，然后计算结果
- en: 'To look at an example, let’s go back to the `nonsense()` function we have been
    using in previous sections, as follows. Assume we already have a `partialCurry()`
    function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看一个例子，让我们回到我们在前几节中使用过的 `nonsense()` 函数，如下所示。假设我们已经有了一个 `partialCurry()` 函数：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The original function had an arity of `5`. When we partially curry that function
    and give it arguments of `9` and `22`, it becomes a ternary function, because
    out of the original five parameters, two have become fixed. If we take that ternary
    function and give it a single argument, `(60)`, the result is yet another function:
    in this case, a binary one, because now we have fixed the first three of the original
    five parameters. The final call, providing the last two arguments, then does the
    job of actually calculating the desired result.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 原始函数的元数是 `5`。当我们对那个函数进行部分柯里化并给它提供 `9` 和 `22` 参数时，它变成了一个三元函数，因为从原始的五个参数中，有两个已经固定。如果我们给那个三元函数提供一个单一参数
    `(60)`，结果又是另一个函数：在这种情况下，是一个二元函数，因为我们现在已经固定了原始五个参数中的前三个。最后的调用，提供最后两个参数，然后执行实际计算所需结果的职责。
- en: 'There are some points in common with currying and partial application, but
    also some differences, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与柯里化和部分应用有一些共同点，但也有一些差异，如下所示：
- en: The original function is transformed into a series of functions, each producing
    the next one until the last in the series actually carries out its calculations.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始函数被转换成一系列函数，每个函数都产生下一个函数，直到系列中的最后一个函数实际上执行其计算。
- en: You always provide parameters starting from the first one (the leftmost one),
    as in currying, but you can provide more than one, as in partial application.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你总是从第一个参数（最左侧的一个）开始提供参数，就像柯里化一样，但你可以提供多个参数，就像部分应用一样。
- en: When currying a function, all the intermediate functions are unary, but with
    partial currying, that need not be so. However, if in each instance we were to
    provide a single argument, then the result would require as many steps as plain
    currying.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进行函数柯里化时，所有中间函数都是一元的，但在部分柯里化中，并不一定如此。然而，如果我们每次都提供一个参数，那么结果将需要与普通柯里化一样多的步骤。
- en: So, we have our definition—let’s now see how we can implement our new higher-order
    function; we’ll probably be reusing a few concepts from the previous sections
    in this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有我们的定义——现在让我们看看我们如何实现我们新的高阶函数；我们可能会在这个章节的上一节中重新使用一些概念。
- en: Partial currying with bind()
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `bind()` 进行部分柯里化
- en: 'Similar to what we did with currying, there’s a simple way to do partial currying.
    We will take advantage of the fact that `bind()` can actually fix many arguments
    at once, and we’ll look at JavaScript code first for clarity:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前对柯里化所做的一样，部分柯里化有一个简单的方法。我们将利用 `bind()` 实际上可以同时固定多个参数的事实，并且我们首先查看 JavaScript
    代码以增强清晰度：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Compare the code to the previous `curry()` function and you’ll see the main,
    but very small, differences:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码与之前的 `curry()` 函数进行比较，你会看到主要但非常小的差异：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The mechanism is exactly the same. The only difference is that in our new function,
    we can bind many arguments simultaneously, while in `curry()`, we always bind
    just one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 机制完全相同。唯一的区别在于，在我们的新函数中，我们可以同时绑定多个参数，而在 `curry()` 中，我们总是只绑定一个。
- en: 'In a sense, the TypeScript version is akin to the one for `partial()`. The
    provided arguments must match the types of the original function parameters, so
    we’ll use again our `TypesMatch<>` type from the previous section. If the original
    function had several parameters, and we provide a few of them, we need to figure
    out the rest – our `Minus<>` type will do that:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，TypeScript 版本类似于 `partial()` 的版本。提供的参数必须与原始函数参数的类型匹配，因此我们将再次使用上一节中的 `TypesMatch<>`
    类型。如果原始函数有多个参数，而我们只提供了其中几个，我们需要找出剩余的参数——我们的 `Minus<>` 类型将完成这项工作：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Basically, if both types have more than one element, we ignore the first ones
    and process the tails of both types; otherwise, we return the first. With this,
    we can write the `PartialCurry<>` type:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果两种类型都有多个元素，我们忽略第一个，并处理两种类型的尾部；否则，我们返回第一个。有了这个，我们可以编写 `PartialCurry<>`
    类型：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If types don’t match (a wrong type argument was provided), the result is an
    error, `never`. Otherwise, if we’ve provided enough arguments, the original `R`
    result type will be produced; if not, we’ll produce a new function with fewer
    parameters by recursion and using `Minus<>`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型不匹配（提供了错误类型参数），结果将是错误，`never`。否则，如果我们提供了足够的参数，将产生原始的 `R` 结果类型；如果没有，我们将通过递归使用
    `Minus<>` 产生一个参数更少的新的函数。
- en: We can revisit our earlier example with the `make3()` function, and the only
    difference is that we can get results in fewer steps – or more, as in the little
    sensical `h7` example!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回顾一下之前的例子，使用 `make3()` 函数，唯一的区别是我们可以在更少的步骤中获取结果——或者更多，就像那个有点无意义的 `h7` 示例一样！
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By the way, and just to be aware of the existing possibilities, you can fix
    some parameters when currying, as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，为了了解现有的可能性，你可以在柯里化时固定一些参数，如下所示：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Testing this function is easy, and the examples we provided are a very good
    starting point. Note, however, that since we allow fixing any number of arguments,
    we cannot test the arity of the intermediate functions. Our tests could be as
    follows, then:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个函数很容易，我们提供的例子是一个非常好的起点。然而，请注意，由于我们允许固定任意数量的参数，我们无法测试中间函数的参数数量。我们的测试可能如下所示：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Partial currying with closures
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用闭包进行部分柯里化
- en: 'As with partial application, there’s a solution that works with closures. Since
    we have gone over many of the required details, let’s jump directly into the code,
    the JavaScript version first:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与部分应用类似，有一个解决方案可以与闭包一起使用。既然我们已经讨论了许多必要的细节，让我们直接进入代码，首先是 JavaScript 版本：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you compare `partialCurryByClosure()` and `partial()`, the main difference
    is that with partial currying, since we are always providing arguments from the
    left and there is no way to skip some, you concatenate whatever arguments you
    had with the new ones, and check whether you got enough. If the new list of arguments
    has reached the expected arity of the original function, you can call it and get
    the final result. In other cases, you just use `curryize()` (in `partial()`, we
    had a similar `partialize()` function) to get a new intermediate function, which
    will wait for more arguments.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较 `partialCurryByClosure()` 和 `partial()`，主要区别在于，在部分柯里化中，由于我们总是从左侧提供参数，并且无法跳过某些参数，所以你会将已有的参数与新参数连接起来，并检查是否足够。如果新的参数列表达到了原始函数期望的参数数量，你可以调用它并得到最终结果。在其他情况下，你只需使用
    `curryize()`（在 `partial()` 中，我们有一个类似的 `partialize()` 函数）来获取一个新的中间函数，该函数将等待更多的参数。
- en: 'With TypeScript, we don’t need any new types since the function just works
    (internally) in a different way, but produces the same results:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript，我们不需要任何新的类型，因为函数只是以不同的方式（内部）工作，但产生相同的结果：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The results are exactly the same as in the previous section, so it’s not worth
    repeating them. You can change the tests we wrote to use `partialCurryByClosure()`
    instead of `partialCurryByBind()`, and they will work.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与上一节完全相同，所以不值得重复。你可以更改我们编写的测试，使用 `partialCurryByClosure()` 而不是 `partialCurryByBind()`，它们将正常工作。
- en: Final thoughts
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的想法
- en: Let’s finish this chapter with some short topics. First, we should consider
    how we’d apply the methods in this chapter to a function with a variable number
    of parameters – not a trivial point, as all the code we’ve seen strongly depends
    on the function’s arity.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一些简短的主题结束这一章。首先，我们应该考虑如何将本章的方法应用于具有可变数量参数的函数——这不是一个简单的问题，因为我们看到的所有代码都强烈依赖于函数的参数数量。
- en: 'Then we’ll finish with two more philosophical considerations regarding currying
    and partial application, which may cause a bit of a discussion:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将以两个关于柯里化和部分应用的哲学思考结束，这可能会引起一些讨论：
- en: First, many libraries are just wrong about the order of their parameters, making
    them harder to use
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，许多库在参数顺序上都是错误的，这使得它们更难使用
- en: Second, I don’t usually even use the higher-order functions in this chapter,
    going for simpler JavaScript code
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我通常甚至不使用本章中的高阶函数，而是追求更简单的 JavaScript 代码
- en: That’s probably not what you were expecting at this time, so let’s first solve
    the problem with the functions with an unknown number of parameters, and then
    go over the last two points in more detail, so you’ll see it’s not a matter of
    *do as I say, not as I do*... or as the libraries do!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你现在所期望的，所以让我们首先解决具有未知数量的参数的函数的问题，然后更详细地讨论最后两点，这样你就会看到这并不是 *do as I say,
    not as I do*... 或是库的做法！
- en: Variable number of parameters
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变数量的参数
- en: 'How can we work with functions that allow for a variable (possibly undefined,
    indeterminate) number of parameters? This is a problem because all the code we
    developed in the chapter depends on `fn.length`, the arity of the function to
    be processed. You could want to curry the `reduce()` function, but you’d find
    that its arity is `1`, so the curried function would not accept a second argument.
    Another case: you could have a `sumAll()` function as follows, and you’d want
    to apply `partial()` to it and get a function with, say, three parameters, but
    `sumAll.length` is `0` because all its parameters are optional:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理允许变量（可能未定义、不确定）数量的参数的函数？这是一个问题，因为我们在本章中开发的全部代码都依赖于 `fn.length`，即要处理的函数的元数。你可能想要柯里化
    `reduce()` 函数，但你发现它的元数是 `1`，所以柯里化后的函数不会接受第二个参数。另一个例子：你可能有一个 `sumAll()` 函数如下，并且你想要对其应用
    `partial()` 并得到一个具有三个参数的函数，但 `sumAll.length` 是 `0`，因为它的所有参数都是可选的：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the two previous editions of this book, I added an extra parameter to `curry()`
    and the rest so I could override the `length` attribute of the input function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前两版中，我向 `curry()` 和其他函数添加了一个额外的参数，以便我可以覆盖输入函数的 `length` 属性：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: However, currently, I don’t think this is best. First, TypeScript cannot understand
    how many arguments the function will have, and that’s not very good. And, second,
    we don’t really need this! Given the functions that we saw in the *Arity changing*
    section of the previous chapter, if you have an `fn()` function that you want
    to curry for just two parameters, you can do `curry(binary(fn))` – and that solves
    the issue!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前我认为这并不是最好的方法。首先，TypeScript 无法理解函数将有多少个参数，这并不好。其次，我们实际上并不需要这个！根据我们在上一章 *Arity
    changing* 部分中看到的函数，如果你有一个 `fn()` 函数，你只想对其柯里化两个参数，你可以这样做 `curry(binary(fn))` –
    这就解决了问题！
- en: I think combining functions is a better solution than twiddling with already
    good implementations, so from now on, I’m recommending this new approach. Check
    the *Being functional* section later in this chapter for more examples of this
    usage.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为组合函数比调整现有的良好实现更好，所以从现在开始，我推荐这种新的方法。请查看本章后面的 *Being functional* 部分，以了解更多关于这种用法的示例。
- en: Parameter order
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数顺序
- en: There’s a problem that’s common to not only functions such as Underscore’s or
    Lodash’s `_.map(list, mappingFunction)` or `_.reduce(list, reducingFunction, initialValue)`
    but also to some that we have produced in this book, such as the result of `demethodize()`,
    for example. (See the *Demethodizing – turning methods into functions* section
    of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*, Producing Functions,* to
    review that higher-order function.) The problem is that the order of their parameters
    doesn’t really help with currying.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个问题不仅存在于像 Underscore 或 Lodash 的 `_.map(list, mappingFunction)` 或 `_.reduce(list,
    reducingFunction, initialValue)` 这样的函数中，也存在于我们在这本书中产生的某些函数中，例如 `demethodize()`
    的结果。例如，请参阅 [*第6章*](B19301_06.xhtml#_idTextAnchor107) 的 *Demethodizing – turning
    methods into functions* 部分，以回顾那个高阶函数。问题是它们的参数顺序实际上并不能帮助进行柯里化。
- en: 'When currying a function, you will probably want to store intermediate results.
    When we do something as in the code that follows, we assume that you are going
    to reuse the curried function with the fixed argument, and that means that the
    first argument to the original function is the least likely to change. Let’s now
    consider a specific case. Answer this question: what’s more likely—that you’ll
    use `map()` to apply the same function to several different arrays or that you’ll
    apply several different functions to the same array? With validations or transformations,
    the former is more likely, but that’s not what we get!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当柯里化一个函数时，你可能想要存储中间结果。当我们像以下代码中所做的那样做某事时，我们假设你将使用固定的参数重新使用柯里化函数，这意味着原始函数的第一个参数最不可能改变。现在让我们考虑一个具体的情况。回答这个问题：你更有可能使用`map()`将相同的函数应用于几个不同的数组，还是将几个不同的函数应用于同一个数组？在验证或转换的情况下，前者更有可能，但这不是我们得到的结果！
- en: 'We can write a simple function to flip the parameters for a binary function,
    as shown here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个简单的函数来翻转二进制函数的参数，如下所示：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With this, you could then write code as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，你可以编写如下代码：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The most common use case is that you’ll want to apply the function to several
    different lists; neither the library functions nor our own de-methodized ones
    provide that. However, by using `flip2()`, we can work in the fashion we prefer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的用例是您将想要将函数应用于几个不同的列表；库函数和我们的非方法化函数都不能提供这一点。然而，通过使用`flip2()`，我们可以按照我们喜欢的风格工作。
- en: (Yes, in this particular case, we might have solved our problem by using partial
    application instead of currying; with that, we could fix the second argument to
    `map()` without any further bother. However, flipping arguments to produce new
    functions that have a different order of parameters is also an often-used technique,
    and you must be aware of it.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: （是的，在这个特定的情况下，我们可能通过使用偏应用而不是柯里化来解决我们的问题；通过这种方式，我们可以将`map()`的第二个参数固定，而无需进一步麻烦。然而，翻转参数以产生具有不同参数顺序的新函数也是一种常用的技术，你必须对此有所了解。）
- en: 'For situations such as with `reduce()`, which usually receives three arguments
    (the list, the function, and the initial value), we may opt for this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`reduce()`这样的情况，它通常接收三个参数（列表、函数和初始值），我们可能会选择这样做：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we used partial currying to simplify the expression for `sumAll()`. The
    alternative would have been using common currying, and then we would have defined
    `sumAll =` `myReduce(sum)(0)`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了偏柯里化来简化`sumAll()`的表达式。另一种选择是使用常规柯里化，然后我们会定义`sumAll = myReduce(sum)(0)`。
- en: You can also go for more esoteric parameter rearranging functions if you want,
    but you usually won’t need more than these two. For really complex situations,
    you may instead opt for using arrow functions (as we did when defining `flip2()`
    and `flip3()`) and make it clear what kind of reordering you need.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用更神秘的参数重新排列函数，也可以，但你通常不需要比这两个更多的函数。对于真正复杂的情况，你可能会选择使用箭头函数（就像我们在定义`flip2()`和`flip3()`时做的那样）并清楚地说明你需要什么样的重新排序。
- en: Being functional
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成为函数式编程者
- en: 'Now that we are nearing the end of this chapter, a confession is in order:
    I do not always use currying and partial application, as shown previously! Don’t
    misunderstand me, I do apply those techniques—but sometimes they make for longer,
    less clear, not necessarily better code. Let me show you what I’m talking about.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们即将结束本章，一个坦白是必要的：我并不总是使用柯里化和偏应用，就像之前展示的那样！不要误解我，我确实应用了这些技术——但有时它们会使代码更长、不那么清晰，并不一定更好。让我向你展示我是说什么。
- en: 'If I’m writing my own function and then I want to curry it to fix the first
    parameter, currying, partial application, or partial currying don’t really make
    a difference compared to arrow functions. I’d have to write the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我正在编写自己的函数，然后我想将其柯里化以固定第一个参数，与箭头函数相比，柯里化、偏应用或偏柯里化实际上并没有太大区别。我必须编写以下内容：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Currying the function and giving it a first parameter, all in the same line,
    may be considered not so clear; the alternative calls for an added variable and
    one more line of code. Later, the future call isn’t so good either; however, partial
    currying makes it more straightforward, with something like `myPartiallyCurriedFn(set2nd,
    set3rd)`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一行中将函数柯里化并给它一个第一个参数可能被认为不是很清晰；另一种方法需要添加一个变量和一行额外的代码。然而，未来的调用也不是很好；然而，偏柯里化使其更加直接，例如`myPartiallyCurriedFn(set2nd,
    set3rd)`。
- en: 'In any case, when I compare the final code with the use of arrow functions,
    I think the other solutions aren’t really any better; make your own evaluation
    of the sample that follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，当我将最终代码与箭头函数的使用进行比较时，我认为其他解决方案并不真的更好；请对你下面的样本进行自己的评估：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Where I do think that currying and partial application is quite good is in
    my small library of de-methodized, pre-curried, basic higher-order functions.
    I have my own set of functions, such as the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为柯里化和偏应用相当好的地方在于我的小型去方法化、预柯里化的基本高阶函数库。我有一套自己的函数，如下所示：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here are some points to note about the code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码，以下是一些需要注意的点：
- en: I have these functions in a separate module, and I only export the `myXXX()`
    named ones.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将这些函数放在一个单独的模块中，并且只导出名为`myXXX()`的函数。
- en: The other functions are private, and I use the leading underscore to remind
    me of that.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他函数是私有的，我使用前导下划线来提醒自己。
- en: I use the `my...` prefix to remember that these are my functions, not the normal
    JavaScript ones. Some people would rather keep familiar names such as `map()`
    or `filter()`, but I prefer distinct names.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我使用`my...`前缀来记住这些是我的函数，而不是正常的JavaScript函数。有些人可能更喜欢保留熟悉的名字，如`map()`或`filter()`，但我更喜欢独特的名字。
- en: Since most of the JavaScript methods have a variable arity, I fixed that as
    described in the *Variable number of* *parameters* section.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于大多数JavaScript方法都有可变参数数量，我在*可变数量参数*部分描述了如何解决这个问题。
- en: I always provide the third argument (the initial value for reducing) to `reduce()`,
    so the arity I chose for that function is `3`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我总是为`reduce()`函数提供第三个参数（累加的初始值），因此我为该函数选择的是`3`个参数。
- en: When currying flipped functions, you don’t need to specify the number of parameters
    because flipping already does that for you.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对翻转函数进行柯里化时，你不需要指定参数数量，因为翻转已经为你做了这件事。
- en: Ultimately, it all comes down to a personal decision; experiment with the techniques
    we’ve looked at in this chapter and see which ones you prefer!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这都归结于个人决定；尝试本章中我们探讨的技术，看看你更喜欢哪一种！
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have considered a new way of producing functions by fixing
    arguments to an existing function in several different ways: currying, which originally
    came from computer theory; partial application, which is more flexible; and partial
    currying, which combines good aspects from both of the previous methods. Using
    these transformations, you can simplify your coding because you can generate more
    specialized versions of general functions without any hassle.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了一种通过以几种不同的方式将参数固定到现有函数上来产生函数的新方法：柯里化，它最初来自计算机理论；偏应用，它更灵活；以及偏柯里化，它结合了前两种方法的优点。使用这些转换，你可以简化你的编码，因为你可以在不费事的情况下生成更专业的通用函数版本。
- en: In [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*,
    we will turn back to some concepts we looked at in the chapter on pure functions,
    and we will consider ways of ensuring that functions cannot become impure by accident,
    by seeking ways to make their arguments immutable, making them impossible to mutate.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B19301_08.xhtml#_idTextAnchor148) *连接函数*中，我们将回顾我们在纯函数章节中探讨的一些概念，并考虑确保函数不会意外变得不纯的方法，通过寻找使它们的参数不可变的方法，使它们无法被修改。
- en: Questions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 7.1 `sum()` function, we could write `sum()(3)(5)` and get `8`. But what happens
    if we write `sum(3)()(5)` instead?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 7.1 `sum()`函数，我们可以写成`sum()(3)(5)`并得到`8`。但如果我们写成`sum(3)()(5)`会发生什么呢？
- en: '7.2 `sumMany()` function that lets you sum an indeterminate quantity of numbers
    in the following fashion. Note that when the function is called with no arguments,
    the sum is returned:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 7.2 `sumMany()`函数允许你以以下方式对不确定数量的数字进行求和。请注意，当函数没有参数被调用时，返回求和结果：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '7.3 `eval()` – yes, the unsafe, dangerous `eval()`! If you are willing to avoid
    the potential security headaches that `eval()` can bring, you could use it to
    transform a function such as the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3 `eval()` – 是的，那个不安全、危险的`eval()`！如果你愿意避免`eval()`可能带来的潜在安全头痛，你可以用它来转换如下函数：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You could transform it into a curried equivalent:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其转换为柯里化等价形式：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Give it a try! A tip: using the `range()` function we wrote back in the *Working
    with ranges* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*, Programming
    Declaratively,* may shorten your code. Also, remember that `fn.length` tells you
    the arity of the `fn()` function.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下！提示：使用我们在 [*第5章*](B19301_05.xhtml#_idTextAnchor084) 的 *使用范围* 部分中编写的 `range()`
    函数，可能会缩短你的代码。另外，记住 `fn.length` 会告诉你 `fn()` 函数的参数数量。
- en: '7.4 `unCurry(fn, arity)` function that receives as arguments a (curried) function
    and its expected arity, and returns an uncurried version of `fn()` – that is,
    a function that will receive all arguments at once and produce a result (providing
    the expected arity is needed because you have no way of determining it on your
    own):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4 `unCurry(fn, arity)` 函数接收一个（柯里化的）函数及其预期参数数量作为参数，并返回 `fn()` 的非柯里化版本——即一次接收所有参数并产生结果的函数（需要预期参数数量，因为你无法自己确定它）：
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '7.5 `(a) => (b) => (c) => result`. However, if you use partial curry, there
    are some more ways of using it: `(a,b) => (c) => result`, `(a) => (b,c) => result`,
    and even `(a,b,c) => result`. In how many ways can you use a partially curried
    function with *n* parameters?'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5 `(a) => (b) => (c) => result`。然而，如果你使用部分柯里化，还有更多使用它的方法：(a,b) => (c) => result，(a)
    => (b,c) => result，甚至 (a,b,c) => result。你有多少种方式可以使用具有 *n* 个参数的部分柯里化函数？
- en: '7.6 `Function.prototype` to provide a `curry()` method that will work like
    the `curry()` function we saw in the chapter. Completing the following code should
    produce the following results:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 7.6 在 `Function.prototype` 中提供一个 `curry()` 方法，使其像我们在本章中看到的 `curry()` 函数一样工作。完成以下代码应该会产生以下结果：
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 7.7 `Curry<>` type could be written in an equivalent but shorter way if you
    first tested for two or more arguments. Can you implement this change?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 7.7 如果首先对两个或更多参数进行了测试，`Curry<>` 类型可以用一种等效但更简洁的方式编写。你能实现这个更改吗？
- en: '7.8 `Curry<>` type, we tested whether a single argument was provided by writing
    `P extends [infer H]` – can you rewrite the code to work with `["length"]` instead?
    A hint: we did this kind of thing when we defined the `Partial<>` type:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 7.8 `Curry<>` 类型，我们通过编写 `P extends [infer H]` 来测试是否提供了一个单个参数——你能重写代码以使用 `["length"]`
    吗？提示：我们在定义 `Partial<>` 类型时做过类似的事情：
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '7.9 `applyStyle()` function that will let you apply basic styling to strings
    in the following way. Use either currying or partial application:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 7.9 `applyStyle()` 函数将允许你以以下方式对字符串应用基本样式。可以使用柯里化或部分应用：
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '7.10 **Mystery questions function**: What does the following function, purposefully
    written in an unhelpful way, actually do?'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 7.10 **神秘问题函数**：以下故意以不友好的方式编写的函数实际上做什么？
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 7.11 `partial()` and `partialCurry()` will be available as methods.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 7.11 `partial()` 和 `partialCurry()` 将作为方法提供。
- en: '7.12 **Yet more curry!** Here is another proposal for a currying-style function:
    can you see why it works? A hint – the code is related to something we saw in
    the chapter:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 7.12 **更多的柯里化**！这是另一个关于柯里化风格函数的建议：你能看出为什么它有效吗？提示——代码与我们本章中看到的内容有关：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
