- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transforming Functions – Currying and Partial Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, we
    saw several ways of manipulating functions to get new versions with some changes
    in their functionality. In this chapter, we will go into a particular kind of
    transformation, a sort of **factory method** that lets you produce new versions
    of any given function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be considering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Currying**: A classic FP theoretical function that transforms a function
    with many parameters into a sequence of unary functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial application**: Another time-honored FP transformation, which produces
    new versions of functions by fixing some of their arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial currying** (a name of my own): Can be seen as a mixture of the two
    previous transformations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The techniques in this chapter will provide you with a different way of producing
    functions from other functions. To be fair, we’ll also see that some of these
    techniques can be emulated, possibly with greater clarity, by simple arrow functions.
    However, since you are liable to find currying and partial application in all
    sorts of texts and web pages on FP, it is important that you know their meaning
    and usage, even if you opt for a simpler way out. We’ll look at several applications
    of the ideas in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concepts we’ll discuss in this chapter are in some ways very similar, and
    in other ways quite different. It’s common to find confusion about their real
    meanings, and plenty of web pages misuse terms. You could even say that all the
    transformations in this chapter are roughly equivalent since they let you transform
    a function into another one that fixes some parameters, leaving other parameters
    free, and eventually leading to the same result. Okay, I agree; this isn’t very
    clear! So, let’s start by clearing the air and providing some short definitions,
    which we will expand on later. (If you feel your eyes are glazing over, please
    skip this section and return to it later!) Yes, you may find the following descriptions
    a bit perplexing, but bear with us—we’ll go into more detail in just a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Currying* is transforming an *m*-ary function (that is, a function of arity
    *m*) into a sequence of *m* unary functions, each receiving one argument of the
    original function, from left to right. (The first function receives the first
    argument of the original function and returns a second function, which receives
    the second argument and returns a third function, which receives the third argument,
    and so on.) Upon being called with an argument, each function produces the next
    one in the sequence, and the last one does the actual calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Partial application* is providing *n* arguments to an *m*-ary function, with
    *n* less than or equal to *m*, to transform it into a function with (*m*-*n*)
    parameters. Each time you provide some arguments, a new function is produced,
    with smaller arity. When you provide the last arguments, the actual calculations
    are performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Partial currying* is a mixture of both preceding ideas: you provide *n* arguments
    (from left to right) to an *m*-ary function and produce a new function of arity
    (*m-n*). When this new function receives some other arguments, also from left
    to right, it will produce yet another function. When the last parameters are provided,
    the function produces the correct calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will see these three transformations, what they require,
    and ways of implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already mentioned *currying* back in the *Arrow functions* section of [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015)*, Becoming Functional,* and in the *One
    argument or many?* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, but let’s be more thorough here. Currying is a
    technique that enables you to only work with single-variable functions, even if
    you need a multi-variable one.
  prefs: []
  type: TYPE_NORMAL
- en: Currying by any other name?
  prefs: []
  type: TYPE_NORMAL
- en: The idea of converting a multi-variable function into a series of single-variable
    functions (or, more rigorously, reducing operators with several operands to a
    sequence of applications of a single operand operator) was worked on by Moses
    Schönfinkel. Some authors suggest, not necessarily tongue-in-cheek, that currying
    would be more correctly named *Schönfinkeling*!
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will first see how to deal with functions with
    many parameters, and then move on to how to curry by hand or by using `bind()`.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with many parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea of currying, by itself, is simple. If you need a function with, say,
    three parameters, you could write something like the following by using arrow
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can have a sequence of functions, each with a single parameter,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you might want to consider them as nested functions, like the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of usage, there’s an essential difference in how you’d use each function.
    While you would call the first in the usual fashion, such as `make3("A",2,"Z")`,
    that wouldn’t work with the second definition. Let’s work out why: `make3curried()`
    is a unary (single parameter), so we should write `make3curried("A")`. But what
    does this return? According to the preceding definition, this also returns a unary
    function—and that function also returns a unary function! So, the correct call
    to get the same result as with the ternary function would be `make3curried("A")(2)("Z")`!
    See *Figure 7**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The diﬀerence between a common function and a curried equivalent](img/Figure_7.1_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The diﬀerence between a common function and a curried equivalent
  prefs: []
  type: TYPE_NORMAL
- en: Study this carefully—we have the first function, and when we apply an argument
    to it, we get a second function. Applying an argument to it produces a third function,
    and a final application produces the desired result. This can be seen as a needless
    exercise in theoretical computing, but it actually brings some advantages because
    you can then always work with unary functions, even if you need functions with
    more parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Currying versus uncurrying
  prefs: []
  type: TYPE_NORMAL
- en: Since there is a currying transformation, there is also an uncurrying one! In
    our case, we would write `make3uncurried = (a, b, c) => make3curried(a)(b)(c)`
    to reverse the currying process and make it usable once again, to provide all
    parameters in one sitting.
  prefs: []
  type: TYPE_NORMAL
- en: In some languages, such as Haskell, functions are only allowed to take a single
    parameter—but then again, the language’s syntax allows you to invoke functions
    as if multiple parameters were permitted. For our example, in Haskell, writing
    `make3curried "A" 2 "Z"` would have produced `"A:2:Z"` without anybody even needing
    to be aware that it involved three function calls, each with one of our arguments.
    Since you don’t write parentheses around parameters and don’t separate them with
    commas, you cannot tell that you are not providing a triplet of values instead
    of three singular ones.
  prefs: []
  type: TYPE_NORMAL
- en: Currying is basic in Scala or Haskell, which are fully functional languages,
    but JavaScript has enough features to allow us to define and use currying in our
    work. It won’t be as easy since, after all, it’s not built-in—but we’ll be able
    to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to review the basic concepts, the key differences between our original
    `make3()` and `make3curried()` functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`make3()` is a ternary function, but `make3curried()` is unary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make3()` returns a string; `make3curried()` returns another function—which
    itself returns a second function, which returns yet a third function, which finally
    does return a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can produce a string by writing something like `make3("A",2,"Z")`, which
    returns `"A:2:Z"`, but you’ll have to write `make3curried("A")(2)("Z")` to get
    the same result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why would you go to all this bother? Let’s look at a simple example, and further
    on, we will look at more examples. Suppose you had a function that calculated
    the value-added tax (VAT) for an amount, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you had to apply a single, constant rate, you could curry the `addVAT()`
    function to produce a more specialized version that always applied your given
    rate. For example, if your national rate was 6%, you could then have something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line defines a curried version of our VAT-calculating function. Given
    a tax rate, `addVATcurried()` returns a new function, which, when given an amount
    of money, finally adds the original tax rate to it. So, if the national tax rate
    were 6%, `addNationalVAT()` would be a function that added 6% to any amount given
    to it. For example, if we were to calculate `addNationalVAT(1500)`, as in the
    preceding code, the result would be `1590`: $1,500, plus 6% tax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you are justified in saying that this currying thing is a bit too
    much just to add a 6% tax, but the simplification is what counts. Let’s look at
    one more example. In your application, you may want to include some logging with
    a function such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with this approach, every time you wanted to display a normal log
    message, you would write `myLog("NORMAL", "some normal text")`, and for warnings,
    you’d write `myLog("WARNING", "some warning text")`. You could simplify this a
    bit with currying, by fixing the first parameter of `myLog()` as follows, with
    a `curry()` function that we’ll look at later. Our code could then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What do you gain? Now, you can write `myNormalLog("some normal text")` or `myWarningLog("some
    warning text")` because you have curried `myLog()` and then fixed its argument,
    making for simpler, easier-to-read code!
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, if you prefer, you could have also achieved the same result in
    a single step, with the original uncurried `myLog()` function, by currying it
    case by case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, having a `curry()` function lets you fix some arguments while leaving others
    still open; let’s see how to do this in three different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Currying by hand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before trying more complex things, we could curry a function by hand, without
    any special auxiliary functions or anything else. And, in fact, if we want to
    implement currying for a particular case, there’s no need to do anything complex
    because we can manage with simple arrow functions. We saw that with both `make3curried()`
    and `addVATcurried()`, so there’s no need to revisit that idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let’s look into some ways of doing that automatically, so we can produce
    an equivalent curried version of any function, even without knowing its arity
    beforehand. Going further, we should code a more intelligent version of a function
    that could work differently depending on the number of received arguments. For
    example, we could have a `sum(x,y)` function that behaved as in the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve that behavior by hand. Our function would be something like
    the following – and since we won’t be using this style, let’s stay with plain
    JavaScript, with no typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recap what we did here. Our curried-by-hand function has this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: If we call it with two arguments, it adds them and returns the sum; this provides
    our first use case, as in `sum(3,5)===8`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If only one argument is provided, it returns a new function. This new function
    expects a single argument and will return the sum of that argument and the original
    one: this behavior is what we expected in the other two use cases, such as `add2(3)===5`
    or `sum(2)(7)===9`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if no arguments are provided, it returns itself. This means that we
    would be able to write `sum()(1)(2)` if we desired. (No, I cannot think of a reason
    for wanting to write that.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we can incorporate currying in the definition itself of a function. However,
    you’ll have to agree that dealing with all the special cases in each function
    could quickly become troublesome and error-prone. So, let’s work out some generic
    ways of accomplishing the same result without any particular coding.
  prefs: []
  type: TYPE_NORMAL
- en: Currying with bind()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can find a solution to currying by using the `bind()` method, which we have
    already applied in several places in this book. This allows us to fix one argument
    (or more, if need be; we won’t need to do that here, but later on we will use
    it) and provide a function with that fixed argument. Of course, many libraries
    (such as Lodash, Underscore, Ramda, and others) provide this functionality, but
    we want to see how to implement that ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: A plain JavaScript version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our implementation is relatively short but will require some explanation. First,
    let’s see a JavaScript version and deal with TypeScript later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by noticing that `curryByBind()` always returns a new function, which
    depends on the `fn` function given as its parameter. If the function has no (more)
    parameters left (when `fn.length===0`) because all parameters have already been
    bound, we can evaluate it by using `fn()`. Otherwise, the result of currying the
    function will be a new function that receives a single argument and produces a
    newly curried function with another fixed argument. Let’s see this in action,
    with a detailed example, using the `make3()` function we saw at the beginning
    of this chapter once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first function, `f1()`, has yet to receive any arguments. When called with
    an argument, it will produce a curried version of `make3()`, with its first argument
    fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `f1("A")` produces a new unary function, `f2()`, which will itself produce
    a curried version of `make3()`—but with its first argument set to `"A"`, so actually,
    the new function will end up fixing the second parameter of `make3()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, calling `f2(2)` produces a third unary function, `f3()`, which will
    produce a version of `make3()`, but fixing its third argument, since the first
    two have already been fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, when we calculate `f3("Z")`, this fixes the last parameter of `make3()`
    to `"Z"`, and since there are no more arguments left, the thrice-bound `make3()`
    function is called and the `"A:2:Z"` result is produced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can do other call sequences as well, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To curry the function by hand, you could use JavaScript’s `.bind()` method.
    The sequence would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In each step, we provide an additional parameter. (The `null` value is required,
    to provide context. If it were a method attached to an object, we would provide
    that object as the first parameter to `.bind()`. Since that’s not the case, `null`
    is expected.) This is equivalent to what our code does, except that the last time,
    `curryByBind()` does the actual calculation instead of making you do it, as in
    `step3()`.
  prefs: []
  type: TYPE_NORMAL
- en: A TypeScript version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that have implemented this in JavaScript, let’s see how to define types
    for currying. We have to work recursively and consider two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If we curry a function with just one parameter, the function will directly produce
    the desired result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we curry a function with two or more parameters, we’ll create a unary function
    (with the first parameter) that will return a (curried!) function that will deal
    with the rest of the parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have a generic type with two inputs: `P`, representing the parameters
    of the function to process, and `R`, standing for the result type of that function.
    If `P` has just one type, `H`, we return a function that, given an argument of
    the `H` type, returns a result of the `R` type. If `P` is formed by a first `H`
    type (“head”) and some other `T` types (“tail”), we return a function that will
    return a (curried) function with `T` types as arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this type has an added complexity. TypeScript cannot verify that our
    `curryByBind()` function works correctly because it cannot deduce that, for every
    function, we’ll eventually produce a result instead of yet another curried function.
    There’s a tricky solution involving an overloaded function with just *one* signature.
    The key is that the implementation is checked more loosely, and you can use `any`
    types to get by. Of course, working like this isn’t precisely type-safe; it’s
    up to you to ensure that the function is type-correct because you are essentially
    bypassing TypeScript’s checks. We’ll have to do this kind of trick more than once
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go back to our `make3()` example. Types work out perfectly well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The type of `f1` is key; it shows that our recursive typing worked as expected.
    The types of `f2` and `f3` are shorter, and the type of `f4` is the type of the
    final result, `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Currying tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Testing this transformation is rather simple because there are not many possible
    ways of currying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What else could you test? Maybe functions with just one parameter could be added,
    but there are no more to try.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second transformation we will be considering lets you fix some of the function’s
    parameters, creating a new function that will receive the rest of them. Let’s
    make this clear with a nonsense example. Imagine you have a function with five
    parameters. You might want to fix the second and fifth parameters, and partial
    application would produce a new version of the function that fixed those two parameters
    but left the other three open for new calls. If you called the resulting function
    with the three required arguments, it would produce the correct answer by using
    the original two fixed parameters plus the newly provided three.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting parameters
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of specifying only some parameters in function application, producing
    a function of the remaining parameters, is called **projection**: you are said
    to be projecting the function onto the remaining arguments. We will not use this
    term, but I wanted to cite it in case you find it elsewhere.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example using the `fetch()` API, widely considered the modern
    way to go for Ajax calls. You might want to fetch several resources, always specifying
    the same parameters for the call (for example, request headers) and only changing
    the URL to search. By using partial application, you could create a new `myFetch()`
    function that would always provide fixed parameters.
  prefs: []
  type: TYPE_NORMAL
- en: On fetching
  prefs: []
  type: TYPE_NORMAL
- en: You can read more on `fetch()` at [developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](http://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
    According to [caniuse.com/#search=fetch](http://caniuse.com/#search=fetch), you
    can use it in most browsers except for (oh, surprise!) Internet Explorer, but
    you can get around this limitation with a polyfill, such as the one found at [github.com/github/fetch](http://github.com/github/fetch).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a `partial()` function that implements this kind of application
    and let’s see how we’d use that to produce our new, specialized version of `fetch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Currying would have worked if the request parameters had been the first argument
    for `fetch()`. (We’ll have more to say about the order of parameters later.) With
    partial application, you can replace any arguments, no matter which, so in this
    case, `myFetch()` ends up as a unary function. This new function will get data
    from any URL you wish, always passing the same set of parameters for the `GET`
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application with arrow functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Trying to do partial application by hand, as we did with currying, is too complicated.
    For instance, for a function with 5 parameters, you would have to write code allowing
    the user to provide any of the 32 possible combinations of fixed and unfixed parameters
    – 32 being equal to 2 raised to the fifth power. Even if you could simplify the
    problem, it would still remain hard to write and maintain. See *Figure 7**.2*
    for one of many possible combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Partial application may let you ﬁrst provide some parameters,
    and then provide the rest, to ﬁnally get the result](img/Figure_7.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Partial application may let you ﬁrst provide some parameters, and
    then provide the rest, to ﬁnally get the result
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing partial application with arrow functions, however, is much simpler. With
    the example we mentioned previously, we would have something like the following
    code. In this case, we will assume we want to fix the second parameter to `22`
    and the fifth parameter to `1960`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing partial application this way is quite simple, though we may want to find
    a more general solution. You can set any number of parameters, by creating a new
    function out of the previous one but fixing some more parameters. (Wrappers, as
    in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, could
    be used.) For instance, you might now want to also fix the last parameter of the
    new `fix2and5()` function to `9`, as shown in the following code; there’s nothing
    easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You might also have written `nonsense(a, 22, c, 9, 1960)` if you wished to,
    but the fact remains that fixing parameters by using arrow functions is simple.
    Let’s now consider, as we said, a more general solution.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application with closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to be able to do partial application fixing of any combination of
    parameters, we must have a way to specify which arguments are to be left free
    and which will be fixed from that point on. Some libraries, such as Underscore
    and Lodash, use a special `_` object to signify an omitted parameter. In this
    fashion, still using the same `nonsense()` function, we would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We could do the same sort of thing by having a global variable that would represent
    a pending, not yet fixed argument, but let’s make it simpler and just use `undefined`
    to represent a missing parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Careful comparison
  prefs: []
  type: TYPE_NORMAL
- en: When checking for `undefined`, remember to always use the `===` operator; with
    `==`, it happens that `null==undefined`, and you don’t want that. See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined)
    for more on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to write a function that will partially apply some arguments and leave
    the rest open for the future. We want to write code similar to the following and
    produce a new function in the same fashion as we did earlier with arrow functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'How will we do this? Our implementation will use closures. (You may want to
    review that topic in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming
    Functional*.) This way of doing partial application will behave in a fashion somewhat
    reminiscent of currying in the sense that each function will produce a new one
    with some more fixed parameters. Our new implementation would be as follows –
    and once again, let’s start with plain JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow—a longish bit of code! The key is the inner `partialize()` function. Given
    a list of parameters (`args1`), it produces a function that receives a second
    list of parameters (`args2`):'
  prefs: []
  type: TYPE_NORMAL
- en: First, it replaces all possible `undefined` values in `args1` with values from
    `args2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, if any parameters are left in `args2`, it also appends them to those of
    `args1`, producing `allParams`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if `allParams` does not include any more `undefined` values and is
    sufficiently long, it calls the original function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it partializes itself to wait for more parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example will make it more clear. Let’s go back to our trusty `make3()` function
    and construct a partial version of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `f1()` function gets `[undefined, 2]` as parameters. Now, let’s create
    a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens? The previous list of parameters (`[undefined, 2]`) gets merged
    with the new list (a single element—in this case, `["A"]`), producing a function
    that now receives `"A"` and `2` as its first two arguments. However, this isn’t
    yet ready, because the original function requires three arguments. We can write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then, the current list of arguments would be merged with the new argument, producing
    `["A",2,"Z"]`. Since the list is now complete, the original function will be evaluated,
    producing `"A:2:Z"` as the final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are significant similarities between the structure of this code and the
    other higher-order function we wrote earlier in the *Currying with* *bind()* section:'
  prefs: []
  type: TYPE_NORMAL
- en: If all the arguments have been provided, the original function is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if some arguments are still required (when currying, it’s just a
    matter of counting arguments by checking the function’s `length` property; when
    doing partial application, you must also consider the possibility of having some
    `undefined` parameters), the higher-order function calls itself to produce a new
    version of the function, which will wait for the missing arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get now to a TypeScript version with its data typing.
  prefs: []
  type: TYPE_NORMAL
- en: Partial data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll use an auxiliary type, `Partialize<P,A>`. If `P` is the tuple of the
    parameter types for the function, and `A` is the tuple of the argument types for
    a function call, `Partialize<>` will return a tuple with the types in `P` for
    which there is an `undefined` type in `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How does this work?
  prefs: []
  type: TYPE_NORMAL
- en: If `P` is empty, the output is empty as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `A` is empty (there are no more arguments left), the output is `P`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `P` is split in `PH` (head) and `PT` (tail), and `A` is similarly split in
    `AH` and `AT`, then if `AH` is `undefined`, we return a new type that includes
    `PH` (because no value was given for it) and `Partialize<PT,AT>`, to recursively
    process the rest of both tuples. Otherwise, if `AH` is not `undefined`, we provide
    a value for the corresponding parameter, so the result is `Partialize<PT,AT>`;
    we don’t have to care about the parameter corresponding to `PH`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using recursion makes this harder to understand; let’s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For instance, the `p04` type shows that if you have a function that expects
    three parameters – `boolean`, `number`, and `string` – and you call it with a
    `boolean`, an `undefined` value, and a `string`, the partialized function will
    have just a `number` parameter. The `p05` type shows that if you had called that
    function with just a `boolean`, the partialized function would have a `number`
    and a `string` as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn’t totally right, however. Let’s say we had written the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result would have been the same; we are checking that we have the right
    number of arguments, but not their types. Let’s have another auxiliary type check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`TypesMatch` gets two lists of types, `P` and `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: If any of the lists is empty, that’s OK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both lists are not empty, it splits them in head and tail as `PH` and `PT`,
    and `AH` and `AT`. If `AH` is `undefined`, or if it matches `PH`, then `TypesMatch<>`
    keeps going to analyze both tails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `AH` isn’t `undefined` but doesn’t match `PH`, `never` (which implies an
    error) is generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now write the `Partial<>` generic type using this auxiliary definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `P` stands for the types of the function’s parameters, `R` for its result
    type, and `A` for the types of the function’s arguments. We first check whether
    `P` and `A` match types. If so, if `Partialize<P,A>` is empty, we return a `(...x:
    [...P]) => R` function; otherwise, we (recursively) return a function with `Partialize<P,A>`
    parameter types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have all we need for our TypeScript version of `partial()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It’s worth noting that, as in the currying examples, we use several `any` types
    because TypeScript isn’t really very good at working with recursion. This implies
    that we must be extra careful with our code because there will be no way of detecting
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Partial testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s finish this section by writing some tests. Here are some things we should
    consider:'
  prefs: []
  type: TYPE_NORMAL
- en: When we do partial application, the arity of the produced function should decrease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original function should be called when arguments are in the correct order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could write something like the following, allowing the fixing of arguments
    in different places. Instead of using a spy or mock, we can directly work with
    the `nonsense()` function we had because it’s quite efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen currying and partial application; let’s see our third and last
    transformation, a hybrid of our previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: Partial currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last transformation we will look at is a mixture of currying and partial
    application. If you google it, in some places, you will find it called currying,
    and in others, partial application, but as it happens, it fits neither, so I’m
    sitting on the fence and calling it *partial currying*!
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a function, the idea is to fix its first few arguments and produce a
    new function that will receive the rest of them. However, if that new function
    is given fewer arguments, it will fix whatever it was given and produce a newer
    function to receive the rest of them, until all the arguments are given and the
    final result can be calculated. See *Figure 7**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Partial currying is a mixture of currying and partial application.
    You may provide arguments from the left, in any quantity, until all have been
    provided, and then the result is calculated](img/Figure_7.3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Partial currying is a mixture of currying and partial application.
    You may provide arguments from the left, in any quantity, until all have been
    provided, and then the result is calculated
  prefs: []
  type: TYPE_NORMAL
- en: 'To look at an example, let’s go back to the `nonsense()` function we have been
    using in previous sections, as follows. Assume we already have a `partialCurry()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The original function had an arity of `5`. When we partially curry that function
    and give it arguments of `9` and `22`, it becomes a ternary function, because
    out of the original five parameters, two have become fixed. If we take that ternary
    function and give it a single argument, `(60)`, the result is yet another function:
    in this case, a binary one, because now we have fixed the first three of the original
    five parameters. The final call, providing the last two arguments, then does the
    job of actually calculating the desired result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some points in common with currying and partial application, but
    also some differences, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The original function is transformed into a series of functions, each producing
    the next one until the last in the series actually carries out its calculations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You always provide parameters starting from the first one (the leftmost one),
    as in currying, but you can provide more than one, as in partial application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When currying a function, all the intermediate functions are unary, but with
    partial currying, that need not be so. However, if in each instance we were to
    provide a single argument, then the result would require as many steps as plain
    currying.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we have our definition—let’s now see how we can implement our new higher-order
    function; we’ll probably be reusing a few concepts from the previous sections
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Partial currying with bind()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to what we did with currying, there’s a simple way to do partial currying.
    We will take advantage of the fact that `bind()` can actually fix many arguments
    at once, and we’ll look at JavaScript code first for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the code to the previous `curry()` function and you’ll see the main,
    but very small, differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The mechanism is exactly the same. The only difference is that in our new function,
    we can bind many arguments simultaneously, while in `curry()`, we always bind
    just one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a sense, the TypeScript version is akin to the one for `partial()`. The
    provided arguments must match the types of the original function parameters, so
    we’ll use again our `TypesMatch<>` type from the previous section. If the original
    function had several parameters, and we provide a few of them, we need to figure
    out the rest – our `Minus<>` type will do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, if both types have more than one element, we ignore the first ones
    and process the tails of both types; otherwise, we return the first. With this,
    we can write the `PartialCurry<>` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If types don’t match (a wrong type argument was provided), the result is an
    error, `never`. Otherwise, if we’ve provided enough arguments, the original `R`
    result type will be produced; if not, we’ll produce a new function with fewer
    parameters by recursion and using `Minus<>`.
  prefs: []
  type: TYPE_NORMAL
- en: We can revisit our earlier example with the `make3()` function, and the only
    difference is that we can get results in fewer steps – or more, as in the little
    sensical `h7` example!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, and just to be aware of the existing possibilities, you can fix
    some parameters when currying, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing this function is easy, and the examples we provided are a very good
    starting point. Note, however, that since we allow fixing any number of arguments,
    we cannot test the arity of the intermediate functions. Our tests could be as
    follows, then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Partial currying with closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with partial application, there’s a solution that works with closures. Since
    we have gone over many of the required details, let’s jump directly into the code,
    the JavaScript version first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you compare `partialCurryByClosure()` and `partial()`, the main difference
    is that with partial currying, since we are always providing arguments from the
    left and there is no way to skip some, you concatenate whatever arguments you
    had with the new ones, and check whether you got enough. If the new list of arguments
    has reached the expected arity of the original function, you can call it and get
    the final result. In other cases, you just use `curryize()` (in `partial()`, we
    had a similar `partialize()` function) to get a new intermediate function, which
    will wait for more arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'With TypeScript, we don’t need any new types since the function just works
    (internally) in a different way, but produces the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The results are exactly the same as in the previous section, so it’s not worth
    repeating them. You can change the tests we wrote to use `partialCurryByClosure()`
    instead of `partialCurryByBind()`, and they will work.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s finish this chapter with some short topics. First, we should consider
    how we’d apply the methods in this chapter to a function with a variable number
    of parameters – not a trivial point, as all the code we’ve seen strongly depends
    on the function’s arity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we’ll finish with two more philosophical considerations regarding currying
    and partial application, which may cause a bit of a discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: First, many libraries are just wrong about the order of their parameters, making
    them harder to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, I don’t usually even use the higher-order functions in this chapter,
    going for simpler JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s probably not what you were expecting at this time, so let’s first solve
    the problem with the functions with an unknown number of parameters, and then
    go over the last two points in more detail, so you’ll see it’s not a matter of
    *do as I say, not as I do*... or as the libraries do!
  prefs: []
  type: TYPE_NORMAL
- en: Variable number of parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How can we work with functions that allow for a variable (possibly undefined,
    indeterminate) number of parameters? This is a problem because all the code we
    developed in the chapter depends on `fn.length`, the arity of the function to
    be processed. You could want to curry the `reduce()` function, but you’d find
    that its arity is `1`, so the curried function would not accept a second argument.
    Another case: you could have a `sumAll()` function as follows, and you’d want
    to apply `partial()` to it and get a function with, say, three parameters, but
    `sumAll.length` is `0` because all its parameters are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the two previous editions of this book, I added an extra parameter to `curry()`
    and the rest so I could override the `length` attribute of the input function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: However, currently, I don’t think this is best. First, TypeScript cannot understand
    how many arguments the function will have, and that’s not very good. And, second,
    we don’t really need this! Given the functions that we saw in the *Arity changing*
    section of the previous chapter, if you have an `fn()` function that you want
    to curry for just two parameters, you can do `curry(binary(fn))` – and that solves
    the issue!
  prefs: []
  type: TYPE_NORMAL
- en: I think combining functions is a better solution than twiddling with already
    good implementations, so from now on, I’m recommending this new approach. Check
    the *Being functional* section later in this chapter for more examples of this
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a problem that’s common to not only functions such as Underscore’s or
    Lodash’s `_.map(list, mappingFunction)` or `_.reduce(list, reducingFunction, initialValue)`
    but also to some that we have produced in this book, such as the result of `demethodize()`,
    for example. (See the *Demethodizing – turning methods into functions* section
    of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*, Producing Functions,* to
    review that higher-order function.) The problem is that the order of their parameters
    doesn’t really help with currying.
  prefs: []
  type: TYPE_NORMAL
- en: 'When currying a function, you will probably want to store intermediate results.
    When we do something as in the code that follows, we assume that you are going
    to reuse the curried function with the fixed argument, and that means that the
    first argument to the original function is the least likely to change. Let’s now
    consider a specific case. Answer this question: what’s more likely—that you’ll
    use `map()` to apply the same function to several different arrays or that you’ll
    apply several different functions to the same array? With validations or transformations,
    the former is more likely, but that’s not what we get!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a simple function to flip the parameters for a binary function,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, you could then write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The most common use case is that you’ll want to apply the function to several
    different lists; neither the library functions nor our own de-methodized ones
    provide that. However, by using `flip2()`, we can work in the fashion we prefer.
  prefs: []
  type: TYPE_NORMAL
- en: (Yes, in this particular case, we might have solved our problem by using partial
    application instead of currying; with that, we could fix the second argument to
    `map()` without any further bother. However, flipping arguments to produce new
    functions that have a different order of parameters is also an often-used technique,
    and you must be aware of it.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For situations such as with `reduce()`, which usually receives three arguments
    (the list, the function, and the initial value), we may opt for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used partial currying to simplify the expression for `sumAll()`. The
    alternative would have been using common currying, and then we would have defined
    `sumAll =` `myReduce(sum)(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also go for more esoteric parameter rearranging functions if you want,
    but you usually won’t need more than these two. For really complex situations,
    you may instead opt for using arrow functions (as we did when defining `flip2()`
    and `flip3()`) and make it clear what kind of reordering you need.
  prefs: []
  type: TYPE_NORMAL
- en: Being functional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are nearing the end of this chapter, a confession is in order:
    I do not always use currying and partial application, as shown previously! Don’t
    misunderstand me, I do apply those techniques—but sometimes they make for longer,
    less clear, not necessarily better code. Let me show you what I’m talking about.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I’m writing my own function and then I want to curry it to fix the first
    parameter, currying, partial application, or partial currying don’t really make
    a difference compared to arrow functions. I’d have to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Currying the function and giving it a first parameter, all in the same line,
    may be considered not so clear; the alternative calls for an added variable and
    one more line of code. Later, the future call isn’t so good either; however, partial
    currying makes it more straightforward, with something like `myPartiallyCurriedFn(set2nd,
    set3rd)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, when I compare the final code with the use of arrow functions,
    I think the other solutions aren’t really any better; make your own evaluation
    of the sample that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Where I do think that currying and partial application is quite good is in
    my small library of de-methodized, pre-curried, basic higher-order functions.
    I have my own set of functions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some points to note about the code:'
  prefs: []
  type: TYPE_NORMAL
- en: I have these functions in a separate module, and I only export the `myXXX()`
    named ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other functions are private, and I use the leading underscore to remind
    me of that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I use the `my...` prefix to remember that these are my functions, not the normal
    JavaScript ones. Some people would rather keep familiar names such as `map()`
    or `filter()`, but I prefer distinct names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since most of the JavaScript methods have a variable arity, I fixed that as
    described in the *Variable number of* *parameters* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I always provide the third argument (the initial value for reducing) to `reduce()`,
    so the arity I chose for that function is `3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When currying flipped functions, you don’t need to specify the number of parameters
    because flipping already does that for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, it all comes down to a personal decision; experiment with the techniques
    we’ve looked at in this chapter and see which ones you prefer!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have considered a new way of producing functions by fixing
    arguments to an existing function in several different ways: currying, which originally
    came from computer theory; partial application, which is more flexible; and partial
    currying, which combines good aspects from both of the previous methods. Using
    these transformations, you can simplify your coding because you can generate more
    specialized versions of general functions without any hassle.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*,
    we will turn back to some concepts we looked at in the chapter on pure functions,
    and we will consider ways of ensuring that functions cannot become impure by accident,
    by seeking ways to make their arguments immutable, making them impossible to mutate.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 7.1 `sum()` function, we could write `sum()(3)(5)` and get `8`. But what happens
    if we write `sum(3)()(5)` instead?
  prefs: []
  type: TYPE_NORMAL
- en: '7.2 `sumMany()` function that lets you sum an indeterminate quantity of numbers
    in the following fashion. Note that when the function is called with no arguments,
    the sum is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '7.3 `eval()` – yes, the unsafe, dangerous `eval()`! If you are willing to avoid
    the potential security headaches that `eval()` can bring, you could use it to
    transform a function such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You could transform it into a curried equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Give it a try! A tip: using the `range()` function we wrote back in the *Working
    with ranges* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*, Programming
    Declaratively,* may shorten your code. Also, remember that `fn.length` tells you
    the arity of the `fn()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '7.4 `unCurry(fn, arity)` function that receives as arguments a (curried) function
    and its expected arity, and returns an uncurried version of `fn()` – that is,
    a function that will receive all arguments at once and produce a result (providing
    the expected arity is needed because you have no way of determining it on your
    own):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '7.5 `(a) => (b) => (c) => result`. However, if you use partial curry, there
    are some more ways of using it: `(a,b) => (c) => result`, `(a) => (b,c) => result`,
    and even `(a,b,c) => result`. In how many ways can you use a partially curried
    function with *n* parameters?'
  prefs: []
  type: TYPE_NORMAL
- en: '7.6 `Function.prototype` to provide a `curry()` method that will work like
    the `curry()` function we saw in the chapter. Completing the following code should
    produce the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 7.7 `Curry<>` type could be written in an equivalent but shorter way if you
    first tested for two or more arguments. Can you implement this change?
  prefs: []
  type: TYPE_NORMAL
- en: '7.8 `Curry<>` type, we tested whether a single argument was provided by writing
    `P extends [infer H]` – can you rewrite the code to work with `["length"]` instead?
    A hint: we did this kind of thing when we defined the `Partial<>` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '7.9 `applyStyle()` function that will let you apply basic styling to strings
    in the following way. Use either currying or partial application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '7.10 **Mystery questions function**: What does the following function, purposefully
    written in an unhelpful way, actually do?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 7.11 `partial()` and `partialCurry()` will be available as methods.
  prefs: []
  type: TYPE_NORMAL
- en: '7.12 **Yet more curry!** Here is another proposal for a currying-style function:
    can you see why it works? A hint – the code is related to something we saw in
    the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
