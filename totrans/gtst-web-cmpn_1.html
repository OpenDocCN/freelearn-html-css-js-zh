<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Web Components Essentials and Specifications</h1>
                </header>
            
            <article>
                
<p>Welcome to the world of Web Components.</p>
<p>Web Components, as the name indicates, are components that can be reused across different sections of a website by keeping encapsulation in check. They can even be published on the web, and be used by another site with the help of a simple import. This book covers all there is to know about Web Components. What they are made up of, how they can be used and in what scenarios. The book also covers wide variety of moderate and advanced level concepts such as good practices and integrating Web Components with other technologies.</p>
<p>In this chapter, we will talk about what Web Components are and how we can identify them while browsing various sites. We will also be talking about the specifications that make up Web Components along with detailed examples. You will be able to understand what custom elements are and how you can create one on your own. You will be able to encapsulate your Web Components with the help of a s<span>hadow DOM, a</span><span>nd you will be able to use templates to achieve reusability.</span></p>
<p>While this chapter talks only about the basics of Web Components, by the end of this chapter you will be able to create your own Web Components from scratch, and understand the specifications associated with them.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Web Components</li>
<li>Web Component specifications</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>In order to run the code, you will need a simple server, say a Python <kbd>SimpleHTTPServer</kbd>. In order to see the code on the browser, first start the server. On Mac, use the following command:</p>
<pre><strong>py -m SimpleHTTPServer</strong> </pre>
<p>On Windows, use the following command <span>in the folder that you have the code </span>:</p>
<pre><strong>py -m http.server</strong></pre>
<p>and then you can simply go to <kbd>localhost:8080</kbd>. It will run <kbd>index.html</kbd> for you in that folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web Components</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span><span>L</span></span>et's say you have a phone with a touchscreen. This touchscreen is a component of the mobile phone, working in conjunction with various other components, such as the circuit board and battery. Very few of us know how a phone screen works individually, yet we're all able to operate a mobile phone with ease. The same can be said of Web Components, which are the complex building blocks of websites which become navigable to all.</p>
<p class="mce-root">More importantly, the millions of phone screens around the world today are largely based on only a handful of designs. Fundamentally, the technology behind the mobile component is reusable and adaptable, and the same principle applies to Web Components.</p>
<p class="mce-root">The above points show how component methodology can be useful in creating a better product. Now, you must be thinking, why do we even need to look into the concept of components on the web? Well, I would like you to recall the last five sites that you visited. All these five sites probably shared a few features in common. Some of these are a header, a footer, some sort of menu, and an advertisement section. All these features, in terms of functionality, are doing the same thing. The only thing that differs is the look and feel.</p>
<p class="mce-root">Let us consider another use case where the site domain is the same but there are multiple web apps running on that domain.</p>
<p class="mce-root">We have <span>all</span><span> </span><span>used Google or at least two or three Google services. If we observe, there is a section at the top-right corner on any of the Google services/sites. It's your account information, the one with your profile picture. And it shows the list of accounts you have logged in with:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/22c29b2f-f549-42a8-9a40-c753c348e640.png" style="width:22.50em;height:32.17em;"/></p>
<p>You will be able to see a similar account information card when you go from one service to another. Imagine being able to convert this functionality into an HTML tag <kbd>&lt;account-info&gt;</kbd> and being able to reuse it again and again on different services. This can be achieved with the help of Web Components. </p>
<p>A Web Component is a collection of specifications that lets a user create a functionality with a certain look and feel and which can be reused in such a way that all this functionality is encapsulated. </p>
<p>Just like the preceding example, <kbd>&lt;account-info&gt;</kbd>, a Web Component lets you put your functionality into its own custom name, which can be represented by an HTML tag, and then encapsulate its functionality. This encapsulation makes it easy to distribute and it can be reused again and again very easily.</p>
<p class="mce-root">In all, a Web Component lets you create a custom HTML tag that can be reused, and whose functionality is encapsulated from the user. </p>
<p class="mce-root"/>
<p>Now that we know what Web Components are and what Web Components can do, let's talk about Web Component specifications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web Component specifications</h1>
                </header>
            
            <article>
                
<p>Just like any technology, Web Components also have a set of specifications that need to be followed in order to achieve the functionality associated with them.</p>
<p>A Web Component specification has the following parts:</p>
<ul>
<li><strong>Custom element</strong>: The ability to create custom HTML tags and make sure that the browser understands how to use this HTML tag</li>
<li><strong>Shadow DOM</strong>: The ability to encapsulate the contents of the component from other parts of the DOM</li>
<li><strong>Template</strong>: Being able to create a reusable DOM structure that can be modified on the fly and output desired results</li>
</ul>
<p>These three specifications, when used together, provide a way to create a custom HTML tag that can output desired results (DOM structure) and let it encapsulate from the page, making it reusable again and again.</p>
<p>Now that we know these specifications and what they do, let's dive into them individually and try to look at <span><span>their</span></span> JavaScript APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom elements</h1>
                </header>
            
            <article>
                
<p>A custom element specification lets you create a custom HTML tag that can be used as its own HTML tag on the page. In order to achieve this, we need to first write a class with the functionalities associated with that HTML element, and then we need to register it so that the browser understands what this HTML tag is, and how it can be used on the page. </p>
<p>If you are someone who is new to the concept of classes in JavaScript, here is how you can create a class:</p>
<pre>class myClass {<br/>  constructor() {<br/>    // do stuff<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p>Pretty simple, right? Let's use the same class structure to create our custom element class, say <kbd>HelloWorld</kbd>:</p>
<pre>class HelloWorld extends HTMLElement {<br/>  constructor() {<br/>    // very important<br/>    // needed in every constructor<br/>    // which extends another class<br/>    super();<br/><br/>    // do magic here<br/>    this.innerText = 'Hello World';<br/>  }<br/>}</pre>
<p>In the preceding code, our custom element class is called <kbd>HelloWorld</kbd> and it is extending interface from the <kbd>HTMLElement</kbd> <span>class,</span> which represents how an HTML element should work on a page. So, <kbd>HelloWorld</kbd> now knows what click events are, what CSS is, and so on, simply by extending <kbd>HTMLElement</kbd>.</p>
<p>Inside this class, we have the <kbd>constructor()</kbd> method, which gets called as soon as a new instance of this class is created. The <kbd>super()</kbd> function needs to be called in order to correctly instantiate the properties of the extended class.</p>
<p>The preceding code simply creates the element class definition. We still need to register this element. We can do so by writing the following code:</p>
<pre>customElements.define('hello-world', HelloWorld);</pre>
<p>What it does is register the class <kbd>HelloWorld</kbd> by defining it using the <kbd>define()</kbd> interface in the <kbd>customElements</kbd> interface; <kbd>hello-world</kbd> is the name of the custom element that is going to be available on the page.</p>
<p>Once this is defined, you can used the custom element by simply writing the HTML tag as following:</p>
<pre>&lt;hello-world&gt;&lt;hello-world&gt;</pre>
<p>When this code is run on a browser, it will render the text, <strong><span class="packt_screen">Hello World</span></strong>.</p>
<div class="packt_infobox">Final code: <a href="https://codepen.io/prateekjadhwani/pen/jJZmyy" target="_blank">https://codepen.io/prateekjadhwani/pen/jJZmyy</a>.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of custom elements</h1>
                </header>
            
            <article>
                
<p>Now that you have understood how we can register custom elements, it is time we looked deeper into the type of custom elements. Based on the type of requirement, we can create two types of custom elements: </p>
<ul>
<li><strong>Autonomous custom element</strong>: Any element that can be used by itself, without depending on another HTML element can be considered an autonomous custom element. In technical terms, <span>Any custom </span><span> hat extends </span><kbd>HTMLElement</kbd><span> is an autonomous custom element.</span></li>
</ul>
<p style="padding-left: 60px">Let's have another example of an autonomous custom element. Let's create a <kbd>SmileyEmoji</kbd> <span>element</span><span> </span><span>that shows a smiley emoji. Here is what it looks like:</span></p>
<pre style="padding-left: 60px">class SmileyEmoji extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    // let's set the inner text of <br/>    // this element to a smiley<br/>    this.innerText = '<img src="assets/6a712802-5678-48e3-a208-9be654a329ed.png" style="width:1.42em;height:1.50em;"/>'; <br/>  }<br/>}<br/><br/>customElements.define('smiley-emoji', SmileyEmoji);</pre>
<p style="padding-left: 60px">This registers the <kbd>smiley-emoji</kbd> custom element, which can be used as follows:</p>
<pre style="padding-left: 60px">&lt;smiley-emoji&gt;&lt;/smiley-emoji&gt;</pre>
<ul>
<li><strong>Customized built-in element</strong>: This type of custom element can extend the functionality of an already existing HTML tag. Let's create a custom element that extends <kbd>HTMLSpanElement</kbd> instead of <kbd>HTMLElement.</kbd> And its functionality is, say, it needs to add a smiley emoji at the end of the custom element:</li>
</ul>
<pre style="padding-left: 60px">class AddSmiley extends HTMLSpanElement {<br/>  constructor() {<br/>    super();<br/><br/>    // lets append a smiley<br/>    // to the inner text<br/>    this.innerText += '<img src="assets/6a712802-5678-48e3-a208-9be654a329ed.png" style="width:1.58em;height:1.67em;"/>'; <br/>  }<br/>}<br/>customElements.define('add-smiley', AddSmiley, { extends: 'span' });</pre>
<p style="padding-left: 60px">Now, if you have the following HTML, t<span>his will add the smiley to the end of the text</span><span> </span><kbd>Hello World</kbd><span>:</span></p>
<pre style="padding-left: 60px">&lt;span is="add-smiley"&gt;Hello World&lt;/span&gt;</pre>
<div class="packt_infobox"> Final code: <a href="https://codepen.io/prateekjadhwani/pen/RdQarm" target="_blank">https://codepen.io/prateekjadhwani/pen/RdQarm</a>.</div>
<p><span>Try running the code for autonomous custom elements and </span><span>customized built-in elements on a browser, or CodePen, or JSFiddle. The class and registration code will be in the JavaScript block and the rest will be in the HTML block.</span></p>
<p>Notice the difference in registration code for <kbd>&lt;smiley-emoji&gt;</kbd> and <kbd>&lt;add-smiley&gt;</kbd> custom elements. The second one uses an extra parameter that specifies what it is extending.</p>
<p>You can check whether a custom element is already defined or not with the help of the following code:</p>
<pre>customElements.get('smiley-emoji');</pre>
<p>It will either return undefined if it has not been registered, or will return the class definition, if it has been registered. This is a very helpful statement in large projects because registering an already registered custom element will break the code.</p>
<div class="packt_infobox">Final code: <a href="https://codepen.io/prateekjadhwani/pen/moXPBd" target="_blank">https://codepen.io/prateekjadhwani/pen/moXPBd</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shadow DOM</h1>
                </header>
            
            <article>
                
<p>This is the second specification for Web Components and this one is responsible for encapsulation. Both the CSS and DOM can be encapsulated so that they are hidden from the rest of the page. <span>What a shadow DOM does is let you create a new root node, called shadow root, that is hidden from the normal DOM of the page.</span></p>
<p>However, even before we jump into the concept of a shadow DOM, let's try to look at what a normal DOM looks like. Any page with a DOM follows a tree structure. Here I have the DOM structure of a very simple page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e67c5097-533a-4500-be7a-443cf7de1386.png" style="width:24.25em;height:14.92em;"/></p>
<p>In the preceding image, you can see that <kbd>#document</kbd> is the root node for this page. </p>
<div class="packt_tip">You can find out the root node of a page by typing <kbd>document.querySelector('html').getRootNode()</kbd> in the browser console.</div>
<p>If you try to get the child nodes of an HTML tag using <kbd>document.querySelector('html').childNodes</kbd> in the browser console, then you can see the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c74c9446-3506-4ab8-9535-8e66f8592d24.png" style="width:21.25em;height:9.50em;"/></p>
<div class="packt_infobox">Final code: <a href="https://codepen.io/prateekjadhwani/pen/aMqBLa" target="_blank">https://codepen.io/prateekjadhwani/pen/aMqBLa</a>.</div>
<p>This shows that the DOM follows a tree structure. You can go deeper into these nodes by clicking on the arrow right next to the name of the node. And just like how I have shown in the screenshot, anyone can go into a particular node by expanding it and change these values. In order to achieve this encapsulation, the concept of a shadow DOM was invented.</p>
<p>What a shadow DOM does is let you create a new root node, called shadow root, that is hidden from the normal DOM of the page. This shadow root can have any HTML inside and can work as any normal HTML DOM structure with events and CSS. But this shadow root can only be accessed by a shadow host attached to the DOM. </p>
<p>For example, let's say that instead of having text inside the <kbd>&lt;p&gt;</kbd> tag in the preceding example, we have a shadow host that is attached to a shadow root. This is what the page source would look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d50f552b-ec38-4de8-bfe0-9d5cb1a74e7e.png" style="width:26.08em;height:17.08em;"/></p>
<p>Furthermore, if you tried to get the child nodes of this <kbd>&lt;p&gt;</kbd> tag, you would see something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9e6719dc-3ccd-4f5e-8f66-49020c8a2c7a.png" style="width:25.00em;height:6.58em;"/></p>
<p>Notice that there is a <kbd>&lt;span&gt;</kbd> tag in the shadow root. Even though this <kbd>&lt;span&gt;</kbd> tag is present inside the <kbd>&lt;p&gt;</kbd> tag, the shadow root does not let JavaScript APIs touch it. This is how the shadow DOM encapsulates code inside itself.</p>
<div class="packt_infobox">Final code: <a href="https://codepen.io/prateekjadhwani/pen/LaQxEY" target="_blank">https://codepen.io/prateekjadhwani/pen/LaQxEY</a>.</div>
<p>Now that we know what a shadow DOM does, let's jump on to some code and learn how to create our own shadow DOMs.</p>
<p>Let's say we have a DOM with a class name entry. This is what it looks like:</p>
<pre>&lt;div class="entry"&gt;&lt;/div&gt;</pre>
<p>In order to create a shadow DOM in this <kbd>div</kbd>, we will first need to get the reference to this <kbd>.entry</kbd> <kbd>div</kbd>, then we need to mark it as a shadow root, and then append the content to this shadow root. So, here is the JavaScript code for <span><span>creating a <kbd>shadowRoot</kbd> inside a <kbd>div</kbd> and adding contents to it</span></span>:</p>
<pre>// get the reference to the div<br/>let shadowRootEl = document.querySelector('.entry');<br/><br/>// mark it as a shadow root<br/>let shadowRoot = shadowRootEl.attachShadow({mode: 'open'});<br/><br/>// create a random span tag<br/>// that can be appended to the shadow root<br/>let childEl = document.createElement('span');<br/>childEl.innerText = "Hello shadow DOM";<br/><br/>// append the span tag to shadow root<br/>shadowRoot.appendChild(childEl);</pre>
<div class="packt_infobox">Final code: <a href="https://codepen.io/prateekjadhwani/pen/JzpWYE" target="_blank">https://codepen.io/prateekjadhwani/pen/JzpWYE</a>.</div>
<p>Pretty simple, right? Remember, we are still discussing the shadow DOM spec. We haven't started implementing it inside a custom element yet. Let's recall the definition of our <kbd>hello-world</kbd> custom element. This is what it looked like:</p>
<pre>class HelloWorld extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>    // do magic here<br/>    this.innerText = 'Hello World';<br/>  }<br/>}<br/><br/>customElements.define('hello-world', HelloWorld);</pre>
<p>Notice that the text <kbd>Hello World</kbd> is currently being added to normal DOM. We can use the same shadow DOM concepts discussed earlier in this custom element.</p>
<p>First, we need to get the reference to the node where we want to attach the shadow root. In this case, let's make the custom element itself the shadow host by using the following code:</p>
<pre>let shadowRoot = this.attachShadow({mode: 'open'});</pre>
<p>Now, we can either add a text node or create a new element and append it to this <kbd>shadowRoot</kbd>:</p>
<pre>// add a text node<br/>shadowRoot.append('Hello World');</pre>
<div class="packt_infobox">Final code: <a href="https://codepen.io/prateekjadhwani/pen/LaQyPB" target="_blank">https://codepen.io/prateekjadhwani/pen/LaQyPB</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Templates</h1>
                </header>
            
            <article>
                
<p>Till now, we have only created custom elements and shadow DOMs that require only one or, at the most, two lines of HTML code. If we move on to a real-life example, HTML code can be more than two lines. It can start from a few lines of nested <kbd>div</kbd> to images and paragraphs—you get the picture. The template specification provides a way to hold HTML on the browser without actually rendering it on the page. Let us look at a small example of a template:</p>
<pre>&lt;template id="my-template"&gt;<br/> &lt;div class="red-border"&gt;<br/> &lt;p&gt;Hello Templates&lt;/p&gt;<br/> &lt;p&gt;This is a small template&lt;/p&gt;<br/> &lt;/div&gt;<br/>&lt;/template&gt;</pre>
<p class="mce-root"/>
<p>You can write a template inside <kbd>&lt;template&gt;</kbd> tags and assign it an identifier, just as I have done with the help of an <kbd>id</kbd>. You can put it anywhere on the page; it does not matter. We can get its content with the help of JavaScript APIs and then clone it and put it inside any DOM, just as I have shown in the following:</p>
<pre>// Get the reference to the template<br/>let templateReference = document.querySelector('#my-template');<br/><br/>// Get the content node<br/>let templateContent = templateReference.content;<br/><br/>// clone the template content<br/>// and append it to the target div<br/>document.querySelector('#target')<br/>    .appendChild(templateContent.cloneNode(true));</pre>
<p>Similarly, we can have any number of templates on the page, which can be used by any JavaScript code.</p>
<div class="packt_infobox">Final code: <a href="https://codepen.io/prateekjadhwani/pen/ZPxOeq" target="_blank">https://codepen.io/prateekjadhwani/pen/ZPxOeq</a>.</div>
<p>Let's now use the same template with a shadow DOM. We will keep the template as it is. The changes in the JavaScript code would be something like this:</p>
<pre>// Get the reference to the template<br/>let templateReference = document.querySelector('#my-template');<br/><br/>// Get the content node<br/>let templateContent = templateReference.content;<br/><br/>// Get the reference to target DOM<br/>let targetDOM = document.querySelector('#target');<br/><br/>// add a shadow root to the target reference DOM<br/>let targetShadowRoot = targetDOM.attachShadow({mode: 'open'});<br/><br/>// clone the template content<br/>// and append it to the target div<br/>targetShadowRoot.appendChild(templateContent.cloneNode(true));</pre>
<p>We are doing the same thing that we did in the previous example, but, instead of appending the code directly to the target <kbd>div</kbd>, we are first attaching a shadow root to the target <kbd>div</kbd>, and then appending the cloned template content.</p>
<div class="packt_infobox">Final code: <a href="https://codepen.io/prateekjadhwani/pen/moxroz" target="_blank">https://codepen.io/prateekjadhwani/pen/moxroz</a>.<a href="https://codepen.io/prateekjadhwani/pen/moxroz" target="_blank"/></div>
<p>We should be able to use the exact same concept inside the autonomous custom element that uses a shadow DOM. Let's give it a try.</p>
<p>Let's edit the <kbd>id</kbd> of the template and call it <kbd>hello-world-template</kbd>:</p>
<pre>&lt;template id="hello-world-template"&gt;<br/>  &lt;div&gt;<br/>    &lt;p&gt;Hello Templates&lt;/p&gt;<br/>    &lt;p&gt;This is a small template&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</pre>
<p>We will follow the exact same approach that we followed in the preceding example. We will get the template content from the template reference, clone it, and append it in the custom element, making the code of the custom element look like the following:</p>
<pre>class HelloWorld extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    <br/>    // Get the reference to the template<br/>    let templateReference = document.querySelector('#hello-world-template');<br/>  <br/>    // Get the content node<br/>    let templateContent = templateReference.content;<br/><br/>    let shadowRoot = this.attachShadow({mode: 'open'});<br/>    <br/>    // add a text node<br/>    shadowRoot.append(templateContent.cloneNode(true));<br/>  }<br/>}<br/><br/>customElements.define('hello-world', HelloWorld);</pre>
<p>Now we can simply call the HTML tag inside our page using the following code:</p>
<pre>&lt;hello-world&gt;&lt;/hello-world&gt;</pre>
<p>If we inspect the DOM structure inside developer tools, this is what we see:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/151c185e-055a-4b7b-803a-3f4a4dc84289.png" style="width:23.25em;height:9.92em;"/></p>
<div class="mce-root packt_tip packt_infobox">Final code: <a href="https://codepen.io/prateekjadhwani/pen/ywKgBp" target="_blank">https://codepen.io/prateekjadhwani/pen/ywKgBp</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module loader API</h1>
                </header>
            
            <article>
                
<p>Module loader API is not a part of Web Component spec sheet, but it is definitely something that is useful to know when it comes to creating and using multiple classes. As the name says, this specification lets a user load the modules. That is, if you have a bunch of classes, you can use module loaders to load these classes into the web page.</p>
<div class="packt_tip">If your build process involves using WebPack or Gulp or anything else that lets you import modules directly or indirectly, please feel free to skip this section.</div>
<p>Let's start with the basics. Let's say we have our <kbd>index.html</kbd> like this:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en" dir="ltr"&gt;<br/>  &lt;head&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;p&gt;Placeholder for Random Number&lt;/p&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>We can see that there is a <kbd>&lt;p&gt;</kbd> tag in this HTML file. Now, l<span>et's say we have a class called <kbd>AddNumber</kbd>, whose purpose is to add a random number between 0 and 1 to this <kbd>&lt;p&gt;</kbd> tag. This would make the code look something like this:</span></p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en" dir="ltr"&gt;<br/>  &lt;head&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;p&gt;Placeholder for Random Number&lt;/p&gt;<br/><br/>    &lt;script type="text/javascript"&gt;<br/>      class AddNumber {<br/>        constructor() {<br/>          document.querySelector('p').innerText = Math.random();<br/>        }<br/>      }<br/><br/>      new AddNumber();<br/>    &lt;/script&gt;<br/><br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Simple, right? If you open the page on a browser, you will simply see a random number, and if you inspect the page, you will see that the random number replaced the text which was inside the <kbd>&lt;p&gt;</kbd> tag.</p>
<p>If we choose to store it in a JavaScript file, we can try to import it using the following code, where <kbd>addNumber.js</kbd> is the name of the file:</p>
<pre>&lt;script type="text/javascript" src="./addNumber.js"&gt;&lt;/script&gt;</pre>
<p>Now, let's say you have a <kbd>randomNumberGenerator</kbd> function instead of the <kbd>Math.random()</kbd> method. The code would look something like this:</p>
<pre>class AddNumber {<br/>  constructor() {<br/>    // let's set the inner text of<br/>    // this element to a smiley<br/>    document.querySelector('p').innerText = randomNumberGenerator();<br/>  }<br/>}<br/>function randomNumberGenerator() {<br/>  return Math.random();<br/>}<br/>new AddNumber();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We also want the ability to let the user create a new object of the <kbd>AddNumber</kbd> class, rather than us creating it in the file. We do not want the user to know how <kbd>randomNumberGenerator</kbd> works, so we want the user to be only able to create the object of <kbd>AddNumber</kbd>. This way, we reach how modules work. We, the creators of modules, decide which functionalities the user can use and which they cannot.</p>
<p>We can choose what the user can use with the help of the <kbd>export</kbd> keyword. This would make the code look something like this:</p>
<pre>//addNumber.js<br/><br/>export default class AddNumber {<br/>  constructor() {<br/>    document.querySelector('p').innerText = randomNumberGenerator();<br/>  }<br/>}<br/><br/>function randomNumberGenerator() {<br/>  return Math.random();<br/>}</pre>
<p>When this file is imported (note that we haven't talked about imports yet), the user will only be able to use the <kbd>AddNumber</kbd> class. The <kbd>randomNumberGenerator</kbd> <span>function</span><span> </span><span>won't be available to the user.</span></p>
<p>Similarly, if you have another file with, say, two other functions, <kbd>add()</kbd> and <kbd>subtract()</kbd>, you can export both of them as shown in the following:</p>
<pre>// calc.js<br/><br/>export function add(x, y) {<br/>  return x + y;<br/>}<br/><br/>export function subtract(x, y) {<br/>  return x - y;<br/>}</pre>
<p>Importing a module can be easily done with the help of the import keyword. In this section, we will talk about the <kbd>type="module"</kbd> attribute.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Inside the HTML file, <kbd>index.html</kbd>, instead of <kbd>type=text/javascript</kbd>, we can use <kbd>type=module</kbd> to tell the browser that the file that we are importing is a module. This is what it will look like when we are trying to import the file <kbd>addNumber.js</kbd>:</p>
<pre>&lt;script type="module" &gt;<br/>  import AddNumberWithNewName from './addNumber.js';<br/>  new AddNumberWithNewName();<br/>&lt;/script&gt;</pre>
<p>This is how it will look if we import functions from the <kbd>calc.js</kbd> module:</p>
<pre>&lt;script type="module" &gt;<br/> import {add, subtract} from './calc.js';<br/> console.log(add(1,5));<br/>&lt;/script&gt;</pre>
<p>Notice how we can change the name of the module exported from <kbd>AddNumber</kbd>, which uses <kbd>export default</kbd>, and how we have to use the same name as the name of the function exported using <kbd>export</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Named export versus default export</h1>
                </header>
            
            <article>
                
<p><span>In the previous examples, that is, </span><kbd>addNumber.js</kbd><span> and </span><kbd>calc.js</kbd><span>, we saw that there are two ways to export something: </span><kbd>export</kbd><span> and </span><kbd>export default</kbd><span>. The simplest way to understand it is as follows: when a file exports multiple things with different names and when these names cannot be changed after import, it is a named export, whereas, when we export only one thing from a module file and this name can be changed to anything after the import, it is a default export. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom elements using imports</h1>
                </header>
            
            <article>
                
<p>Let's say we need to create a Web Component that does a very simple task of showing a heading and a paragraph inside it, and the name of the custom element should be <kbd>&lt;revamped-paragraph&gt;</kbd>. This is what the definition of this Web Component would look like:</p>
<pre>//revampedParagraph.js<br/><br/>export default class RevampedParagraph extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>    // template ref and content<br/>    let templateReference = document.querySelector('#revamped-paragraph-template');<br/>    let template = templateReference.content;<br/><br/>    // adding html from template<br/>    this.append(template.cloneNode(true));<br/>  }<br/>}</pre>
<p>Our <kbd>index.html</kbd> file, the file that imports this module, would look like this:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en" dir="ltr"&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Revamped Paragraph&lt;/title&gt;<br/><br/>    &lt;!--<br/>      Notice how we use type="module"<br/>    --&gt;<br/>    &lt;script type="module"&gt;<br/>    <br/>      // imports object from the module <br/>      // and names it as RevampedParagraph<br/>      // You can name it anything you want<br/>      // since it is a default export<br/>      import RevampedParagraph from './revampedParagraph.js';<br/><br/>      // We are now defining the custom element <br/>      customElements.define('revamped-paragraph', RevampedParagraph);<br/>    &lt;/script&gt;<br/><br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/><br/>    &lt;revamped-paragraph&gt;&lt;/revamped-paragraph&gt;<br/><br/>    &lt;!--<br/>      Template for<br/>      Revamped Paragraph<br/>    --&gt;<br/>    &lt;template id="revamped-paragraph-template"&gt;<br/>      &lt;h1&gt;Revamped Paragraph&lt;/h1&gt;<br/>      &lt;p&gt;This is the default paragraph inside<br/>      the revamped-paragraph element&lt;/p&gt;<br/>    &lt;/template&gt;<br/><br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root"/>
<p>Notice how the template is a part of our HTML, and how it gets used when the module is imported. We will be learning about all the steps that take place from the actual registration of the Web Components to what happens when they are removed from the page in the next chapter, where we will learn about life cycle methods. But for now, we need to look at more examples to understand how to create Web Components.</p>
<p>Let's take a look at another example. In this example, we need to import multiple Web Components in the <kbd>index.html</kbd> file. The components are as follows:</p>
<ul>
<li><strong>A student attendance table component</strong>: A table that shows the index number, student name, and attendance in a checkbox. This data is obtained from a <kbd>student.json</kbd> file.</li>
<li><strong>An information banner component</strong>: The purpose of this component is to show a phone number and an address for the school where these students are studying.</li>
<li><strong>A time slot component</strong>: A component that lets the user select a time slot for the class between three sets of timings.</li>
</ul>
<p>Let us start with the first one, the <kbd>&lt;student-attendance-table&gt;</kbd> component. We need to first identify what it needs. In my opinion, these are the things it needs:</p>
<ul>
<li>A <kbd>fetch</kbd> call to the <kbd>student.json</kbd> file</li>
<li>A template for each row of the string. I will be using template strings here</li>
<li>A default text that says <span class="packt_screen">loading...</span> when it is making the call and another text that says <span class="packt_screen">unable to retrieve student list.</span> when the fetch call fails</li>
</ul>
<p>This is what our <kbd>student.json</kbd> file looks like:</p>
<pre>[<br/>  {<br/>    "name": "Robert De Niro",<br/>    "lastScore": 75<br/>  },<br/>  {<br/>    "name": "Jack Nicholson",<br/>    "lastScore": 87<br/>  },<br/>  {<br/>    "name": "Marlon Brando",<br/>    "lastScore": 81<br/>  },<br/>  {<br/>    "name": "Tom Hanks",<br/>    "lastScore": 62<br/>  },<br/>  {<br/>    "name": "Leonardo DiCaprio",<br/>    "lastScore": 92<br/>  }<br/>]</pre>
<p>This is what the definition of the Web Component looks like:</p>
<pre>// StudentAttendanceTable.js<br/><br/>export default class StudentAttendanceTable extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>    // we simply called another method<br/>    // inside the class<br/>    this.render();<br/>  }<br/><br/>  render() {<br/>    // let put our loading text first<br/>    this.innerText = this.getLoadingText();<br/><br/>    // let's start our fetch call<br/>    this.getStudentList();<br/>  }<br/><br/>  getStudentList() {<br/>    // lets use fetch api<br/>    // https://developer.mozilla.org/en-US/docs/Web<br/>    // /API/Fetch_API/Using_Fetch<br/>    fetch('./student.json')<br/>    .then(response =&gt; {<br/><br/>      // converts response to json<br/>      return response.json();<br/><br/>    })<br/>    .then(jsonData =&gt; {<br/>      this.generateTable(jsonData);<br/>    })<br/>    .catch(e =&gt; {<br/><br/>      // lets set the error message for<br/>      // the user<br/>      this.innerText = this.getErrorText();<br/><br/>      // lets print out the error<br/>      // message for the devs<br/>      console.log(e);<br/>    });<br/><br/>  }<br/><br/>  generateTable(names) {<br/>    // lets loop through names<br/>    // with the help of map<br/>    let rows = names.map((data, index) =&gt; {<br/>      return this.getTableRow(index, data.name);<br/>    });<br/><br/>    // creating the table<br/>    let table = document.createElement('table');<br/>    table.innerHTML = rows.join('');<br/><br/>    // setting the table as html for this component<br/>    this.appendHTMLToShadowDOM(table);<br/>  }<br/><br/>  getTableRow(index, name) {<br/>    let tableRow = `&lt;tr&gt;<br/>        &lt;td&gt;${index + 1}&lt;/td&gt;<br/>        &lt;td&gt;${name}&lt;/td&gt;<br/>        &lt;td&gt;<br/>          &lt;input type="checkbox" name="${index}-attendance"/&gt;<br/>        &lt;/td&gt;<br/>      &lt;/tr&gt;`;<br/><br/>    return tableRow;<br/>  }<br/><br/>  appendHTMLToShadowDOM(html) {<br/>    // clearing out old html<br/>    this.innerHTML = '';<br/>    <br/>    let shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    // add a text node<br/>    shadowRoot.append(html);<br/>  }<br/><br/>  getLoadingText() {<br/>    return `loading..`;<br/>  }<br/><br/>  getErrorText() {<br/>    return `unable to retrieve student list.`;<br/>  }<br/>}<br/><br/></pre>
<p>Notice the functions <kbd>getLoadingText()</kbd> and <kbd>getErrorText()</kbd>. Their purpose is simply to return a text. Then the <kbd>render()</kbd> method first consumes the <span><kbd>getLoadingText()</kbd> method, and then makes the call using <kbd>getStudentList()</kbd> to fetch the student list from <kbd>student.json</kbd> file.</span></p>
<p>Once this student list is fetched, it gets passed onto <kbd>generateTable()</kbd> method, where every <kbd>name</kbd> and its <kbd>index</kbd> is passed into the <kbd>getTableRow()</kbd> method to generate rows and then gets returned back to be a part of the table. Once the table is formed, it is then passed into the <kbd>appendHTMLToShadowDOM()</kbd> method to be added to the shadow DOM for the component.</p>
<p>It's time to look into the <kbd>&lt;information-banner&gt;</kbd> component. Since this component simply needs to display a phone number and an address of the school where they are studying, we can use <kbd>&lt;template&gt;</kbd> and make it work. This is what it looks like:</p>
<pre>//InformationBanner.js<br/><br/>export default class InformationBanner extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>    // we simply called another method<br/>    // inside the class<br/>    this.render();<br/>  }<br/><br/>  render() {<br/><br/>    // Get the reference to the template<br/>    let templateReference = document.querySelector('#information-banner-template');<br/><br/>    // Get the content node<br/>    let templateContent = templateReference.content;<br/><br/>    let shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    // add the template text to the shadow root<br/>    shadowRoot.append(templateContent.cloneNode(true));<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p>Furthermore, <kbd>information-banner-template</kbd> looks something like this:</p>
<pre>&lt;template id="information-banner-template"&gt;<br/>  &lt;div&gt;<br/>    &lt;a href="tel:1234567890"&gt;Call: 1234567890&lt;/a&gt;<br/>    &lt;div&gt;<br/>      &lt;p&gt;Just Some Random Street&lt;/p&gt;<br/>      &lt;p&gt;Town&lt;/p&gt;<br/>      &lt;p&gt;State - 123456&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</pre>
<p class="mce-root">As you can see, it is not much different than the custom elements we have already talked about in previous sections.</p>
<p>Let's move on to the last custom element, the <kbd>&lt;time-slot&gt;</kbd> component. Since it also involves a preset number of time slots, we can use a <kbd>&lt;template&gt;</kbd> tag to do our work. </p>
<p>The template would look something like this:</p>
<pre>&lt;template id="time-slot-template"&gt;<br/>  &lt;div&gt;<br/>    &lt;div&gt;<br/>      &lt;input type="radio" name="timeslot" value="slot1" checked&gt; 9:00 <br/>      AM - 11:00 AM<br/>    &lt;/div&gt;<br/>    &lt;div&gt;<br/>      &lt;input type="radio" name="timeslot" value="slot2"&gt; 11:00 AM - <br/>      1:00 PM<br/>    &lt;/div&gt;<br/>    &lt;div&gt;<br/>      &lt;input type="radio" name="timeslot" value="slot3"&gt; 1:00 PM - 3:00    <br/>       PM<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</pre>
<p>The definition of the <kbd>&lt;time-slot&gt;</kbd> <span>component</span><span> </span><span>would look like this:</span></p>
<pre>// TimeSlot.js<br/><br/>export default class TimeSlot extends HTMLElement {<br/>  constructor() {<br/>    super();<br/><br/>    // we simply called another method<br/>    // inside the class<br/>    this.render();<br/>  }<br/><br/>  render() {<br/><br/>    // Get the reference to the template<br/>    let templateReference = document.querySelector('#time-slot-<br/>    template');<br/><br/>    // Get the content node<br/>    let templateContent = templateReference.content;<br/><br/>    let shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    // add the template text to the shadow root<br/>    shadowRoot.append(templateContent.cloneNode(true));<br/>  }<br/>}</pre>
<p>It is the same as the previous component.</p>
<p>Now that we have written the Web Components, it's time to take a look at the <kbd>index.html</kbd> file that includes all of these components together. This is what it looks like:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en" dir="ltr"&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Student Page&lt;/title&gt;<br/><br/>    &lt;!--<br/>      Notice how we use type="module"<br/>    --&gt;<br/>    &lt;script type="module"&gt;<br/><br/>      // importing the first custom element<br/>      import StudentAttendanceTable from './StudentAttendanceTable.js';<br/><br/>      // importing the second custom element<br/>      import InformationBanner from './InformationBanner.js';<br/><br/>      // importing the third custom element<br/>      import TimeSlot from './TimeSlot.js';<br/><br/>      customElements.define('student-attendance-table', <br/>      StudentAttendanceTable);<br/>      customElements.define('information-banner', InformationBanner);<br/>      customElements.define('time-slot', TimeSlot);<br/>    &lt;/script&gt;<br/><br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/><br/>    &lt;time-slot&gt;&lt;/time-slot&gt;<br/>    &lt;student-attendance-table&gt;&lt;/student-attendance-table&gt;<br/>    &lt;information-banner&gt;&lt;/information-banner&gt;<br/><br/>    &lt;template id="information-banner-template"&gt;<br/>      &lt;div&gt;<br/>        &lt;a href="tel:1234567890"&gt;Call: 1234567890&lt;/a&gt;<br/>        &lt;div&gt;<br/>          &lt;p&gt;Just Some Random Street&lt;/p&gt;<br/>          &lt;p&gt;Town&lt;/p&gt;<br/>          &lt;p&gt;State - 123456&lt;/p&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/template&gt;<br/><br/>    &lt;template id="time-slot-template"&gt;<br/>      &lt;div&gt;<br/>        &lt;div&gt;<br/>          &lt;input type="radio" name="timeslot" value="slot1" checked&gt; <br/>           9:00 AM - 11:00 AM<br/>        &lt;/div&gt;<br/>        &lt;div&gt;<br/>          &lt;input type="radio" name="timeslot" value="slot2"&gt; 11:00 AM - <br/>          1:00 PM<br/>        &lt;/div&gt;<br/>        &lt;div&gt;<br/>          &lt;input type="radio" name="timeslot" value="slot3"&gt; 1:00 PM - <br/>         3:00 PM<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/template&gt;<br/><br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>As you can see, one <kbd>&lt;script&gt;</kbd> tag of <kbd>type="module"</kbd> can import all three of them together, and can register the custom elements, which can be used in the <kbd>&lt;body&gt;</kbd> tag.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we talked about Web Components and how we are able to identify them in our daily web visits. We also talked about the specifications associated with Web Components, making it easier to understand even further. We looked into custom elements and how we can create our own custom elements. We talked about the shadow DOM and how it provides a level of encapsulation for our Web Components. We then talked about templates and how they provide an element of reusability inside a Web Component. We also looked into modules and how they let you create and add Web Components dynamically. </p>
<p>We dived deep into creating a Web Component with detailed code examples. With this, we should be able to create a simple Web Component from scratch without any issues.</p>
<p>In the next chapter, we will look into how we can make our Web Components do more with life cycle methods.</p>


            </article>

            
        </section>
    </body></html>