["```js\ngeometry = [\n  [new THREE.IcosahedronGeometry(200, 4), 50],\n  [new THREE.IcosahedronGeometry(200, 3), 300],\n  [new THREE.IcosahedronGeometry(200, 2), 1000],\n  [new THREE.IcosahedronGeometry(200, 1), 2000],\n  [new THREE.IcosahedronGeometry(200, 0), 8000],\n];\nmaterial = new THREE.MeshNormalMaterial();\n\nlod = new THREE.LOD();\nfor (var i = 0; i < geometry.length; i++) {\n  var mesh = new THREE.Mesh(geometry[i][0], material);\n  lod.addLevel(mesh, geometry[i][1]);\n}\nscene.add(lod);\n```", "```js\nscene.traverse(function(object) {\n  if (object instanceof THREE.LOD) {\n    object.position.z = 2500 * Math.cos(Date.now() / 1000);\n    object.update(camera);\n  }\n});\n```", "```js\nTHREE.BufferGeometryUtils.fromGeometry(geometry);\n```", "```js\nvar resize = (function() {\n  var canvas = renderer.domElement;\n  canvas.style.width = canvas.width + 'px';\n  canvas.style.height = canvas.height + 'px';\n  var originalWidth = canvas.width;\n  var originalHeight = canvas.height;\n  return function(scale) {\n    canvas.width = Math.round(originalWidth*scale);\n    canvas.height = Math.round(originalHeight*scale);\n    camera.aspect = canvas.width / canvas.height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(canvas.width, canvas.height);\n  }\n})();\n```", "```js\n  var vector = new THREE.Vector3(\n    scale *  renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,\n    scale * -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,\n    0.5\n    );\n```", "```js\nvar texture = THREE.ImageUtils.loadCompressedTexture(imagePath);\n```"]