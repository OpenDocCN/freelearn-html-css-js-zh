- en: Chapter 3. Basic Building Blocks for Creating Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we have seen which QTP features are required to create
    scripts. To design a framework and its components we need to design reusable code
    blocks, apart from QTP features. The key features of code blocks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual checkpoint**: This is a reusable function that checks whether the
    property is matching as expected at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual synchronization**: This is a reusable function that waits up to a
    specified time for the property to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptive programming**: This provides the object identification property
    in test scripts to create the object description or creates the description itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular expression**: This is a text string for matching a pattern and allows
    us to define objects that follow the pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling with Err object and Exit statements**: Also known as exception
    handling, it guides us on how to come out of exceptional events and gracefully
    exit these conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions, subroutines, and procedures**: Functions and subprocedures allow
    us to make scripts modular and reusable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VBScript – key features for creating code blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VBScript is an easy-to-learn yet powerful scripting language. It is used to
    develop scripts to perform both simple and complex object-based tasks, even without
    previous programming experience. While working in the **Expert** view, use the
    following general VBScript syntax rules and guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case sensitivity**: VBScript does not differentiate between uppercased and
    lowercased words. It is not case sensitive by default, for example, in constant,
    variable, object, and method names. The following two statements are identical:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Text strings**: We can define a string by adding double quotes before and
    after the text string. In the following example, the string value is assigned
    using double quotes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Date strings**: We can define the date by adding hash marks before and after
    the date value; for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Variables**: Variables are used to store strings, integers, dates, arrays,
    and objects. We can specify variables to refer to test objects or store simple
    values with or without using `Dim`. If used, the `Option Explicit` statement must
    appear in a script before any other statements. When the Option Explicit statement
    is declared, it forces us to explicitly declare variables using the `Dim`, `Private`,
    `Public`, or `ReDim` statements; otherwise, an error occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To specify a variable to refer to an object, use the `Set` statement with the
    following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Don''t use the `Set` statement to specify a variable that contains a simple
    value (such as a string or number). The example that follows shows us how to define
    a variable for a simple value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or it can also be defined as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Comments**: Type `rem` or use an apostrophe (`''`) to add comments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spaces**: Spaces are ignored by VBScript; they just enhance the clarity and
    readability of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parentheses**: If the called function returns a value, use parentheses around
    the arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example requires parentheses around the method arguments since
    it returns a value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following example requires parentheses around method arguments, since **Call**
    is being used:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following example requires parentheses around the method arguments since
    they return the value of the checkpoint:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following example does not require parentheses around the `Click` method
    arguments since they don''t return any values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: VBScript procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In VBScript, there are two types of procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: Subprocedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subprocedures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A subprocedure starts with the `Sub` statement and ends with the `End Sub`
    statement. `Sub` accepts arguments and does not return a value. An example is
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Function procedures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function procedure starts with the `Function` statement and ends with the
    `End Function` statement. It can return a value; the return value is always a
    variant. To return the value, assign it to the function name. An example of the
    function procedure is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Checkpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A checkpoint checks the specific values or characteristics of a page, object,
    or text string and enables the test object to identify whether the AUT is functioning
    correctly. A checkpoint compares the expected value (captured at the time of recording
    or creating the checkpoint) with the actual value (captured at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script creates the order using the Flight application; after
    selecting the `FlyFrom insert` checkpoint, we need to verify whether the **FLIGHT**
    button''s **enabled** property is set to **True**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checkpoints](img/1027EN_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Output value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **output value** is a value that is retrieved during the test execution from
    DataTable or saved in a variable or parameter. When the output value is executed,
    the `Output` method places the object's property value into the prespecified column
    (which is defined when the test was created) and is retrieved through the DataTable.
    Later, this value is used to verify the expected and actual value; thus, we can
    use the output value as a checkpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet creates a checkpoint using the output values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can create a manual checkpoint using the `CheckProperty` method as well.
    `CheckProperty` allows us to use various options, and we can check the not equal
    condition as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'How to check an equal condition using `CheckProperty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Checkpoints allow the following options to ascertain various unequal options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`micGreaterThan`: This option verifies whether the value of the property is
    greater than the expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`micLessThan`: This option verifies whether the value of the property is less
    than the expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`micGreaterThanOrEqual`: This option verifies whether the value of the property
    is greater than or equal to the expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`micLessThanOrEqual`: This option verifies whether the value of the property
    is less than or equal to the expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`micNotEqual`: This option verifies whether the value of the property is not
    equal to the expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to use the not equal option:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`micRegExpMatch`: The `CheckProperty` also allows us to use regular expressions.
    The `micRegExpMatch` option verifies if the property value matches with the regular
    expression, as shown in the following example, and how to use the regular expression
    with `CheckProperty`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetROProperty` returns the current value of the specified identification property
    from the runtime object in the AUT. We can use the `GetROProperty` to create the
    checkpoint. Using this checkpoint, we will get the runtime property, and we can
    compare it with the expected value as shown in the following example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we design the framework and its components, we need to create manual checkpoints
    for reusability; a good practice is to create them as reusable functions.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QTP and AUT join or handshake at a certain point to match up their speeds for
    the event to occur in order to accomplish a certain sequence of action.
  prefs: []
  type: TYPE_NORMAL
- en: Speed mismatch, delays, the wait for property to change, change of object, and
    occurrence of an event causes mismatch in the speed of execution of scripts, and
    AUT causes synchronization issues, for example, script has to wait until the page
    is loaded. The default object synchronization is 20 seconds but we can change
    it by navigating to **File** | **Test Settings** | **Run** | **Object synchronization
    timeout**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the **Object synchronization timeout** from **20** seconds to **2**
    seconds as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Synchronization](img/1027EN_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have changed the **Object synchronization timeout** value, we will
    run the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve synchronization, we introduce some wait scripts that wait for the
    specified time. Refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wait` statement tells QTP to wait for a predefined amount of time, for
    example, 10 seconds. Here, the following situations can arise:'
  prefs: []
  type: TYPE_NORMAL
- en: The AUT is ready to perform the next step, but the script is still waiting till
    the specified time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wait time is over and the AUT is still not ready for the next step to be
    executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both of these conditions, static wait is not a good option. Waiting for an
    appropriate amount of time based on some property or event that has to be completed
    is called dynamic synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dynamic synchronization allows waiting till the object property is changed
    or till time out, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `WaitProperty` can be inserted using Insert synchronization point or we
    can manually add the `WaitProperty` method by typing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from using `WaitProperty`, we can also create synchronization points
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Descriptive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QTP identifies an object by its properties that are stored in the OR. When the
    object description is created in the test script, the approach is called descriptive
    programming. In this method of script creation, objects are not stored in the
    OR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Descriptive programming can be achieved in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static programming**: The object''s description is directly provided into
    the script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic programming**: The object''s description is created using QTP''s
    description object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Examples of static descriptive programming are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QTP allows the use of the `Description` object and its `Create` method to create
    the object description and pass it as an argument to create the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The test objects that have the same identification properties are called **duplicate
    objects** . Ordinal identifiers allow us to identify duplicate objects using the
    `index` and `location` properties. `index` represents the order of the objects
    from left to right and top to bottom. `location` represents the objects from top-left
    to bottom and top-right to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome after we run the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic programming](img/1027EN_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The outcome after we run the script is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic programming](img/1027EN_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Descriptive programming allows us to deal with dynamic objects; this is a situation
    where the test object does not exist till runtime, so we cannot store the dynamic
    objects in the OR. For example, a textbox is generated based on the user ID in
    the web page at runtime and the name of the object follows the convention edit_xxx,
    that is, edit_123455\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is provided on the preceding page; now we will write the code to set
    the value as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'One use of descriptive programming is that it allows us to find the object(s)
    at runtime and performs the following operations on it/them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A regular expression (abbreviated regex or regexp) is a sequence of text characters,
    some of which are understood to be meta characters with symbolic meaning and some
    of which have their literal meaning, that together automatically identify a given
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression is very useful when the objects are dynamic in nature and
    we cannot store each and every object which follows a pattern in the OR. In the
    Flight Reservation application, we can open any existing order by the order number
    and send the fax. When the **Fax** window is opened, the title of the window contains
    the order number; this will cause an issue when we want to open the fax window
    with a different order number as the window is no longer the same. In this condition,
    we can use regular expression. Refer to the following screenshot; the identification
    property of the object is **Fax Order No. 11**. Here we convert the **text** property
    into a regular expression to identify the property as a pattern and not a fixed
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression shown in the following screenshot matches a pattern where
    the number of digits may vary from **1** to **3**. This means that it is used
    to verify the **Fax** window title from 0 to 999.
  prefs: []
  type: TYPE_NORMAL
- en: '![Regular expressions](img/1027EN_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Regular expressions in descriptive programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the earlier screenshot, we have seen that once we change the **text** property
    to the regular expression, QTP is able to identify objects with order numbers
    from 0 to 999\. We can use the regular expression in object description as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions in checkpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A checkpoint allows us to use the regular expression for matching the pattern.
    To use the regular expression in a checkpoint, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Parameter Options** in the **Text Checkpoint Properties** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on ![Regular expressions in checkpoints](img/1027EN_03_icon.jpg).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Regular expression** option in **Parameter Options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** and change the parameter to regular expressions (in **DataTable**)
    as shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Regular expressions in checkpoints](img/1027EN_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Regular expressions in CheckProperty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CheckProperty` allows us to compare the values using regular expressions and
    `micRegExpMatch` as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exception handling is the way to deal with abnormal or exceptional events that
    interrupt the normal flow of test execution. For example, when a floating point
    number is divided by zero (0), it stops execution and an error message is displayed
    as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `Err` object in VBScript holds the details of the runtime errors, allowing
    continued execution despite a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `On Error Resume Next` statement is absent in the script, any runtime
    error will stop execution and display the error message as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using the `On Error Resume Next` statement allows us to continue with the exception,
    but it is necessary to deal with the error using the `Err` object and come out
    clean from the erroneous condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties of the `Err` object are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Description` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelpContext` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelpFile` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The methods of the `Err` object are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Clear` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Raise` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Use `On Error GoTo 0` to disable error handling if `On Error Resume Next` has
    been used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples are shown in the following code snippet of how to use the `Err` object
    for error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `Exit` statements in QTP are very important; they allow us to gracefully
    exit from loops, actions, iterations, components, and tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different types of `Exit` statements are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Exit Do`: This statement allows us to exit a `Do` loop statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exit For`: This statement allows us to exit a `For` loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exit Function`: This statement allows us to exit the `Function` procedure
    in which it is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exit Property`: This statement allows us to exit the `Property` procedure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exit Sub`: This allows statement us to exit the `Sub` procedure in which it
    is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExitAction`: This statement allows us to exit from the current iteration of
    an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExitTest`: This statement allows us to exit the entire QTP or **Quality Centre**
    (**QC**) business process test, regardless of the runtime iteration settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExitTestIteration`: This statement allows us to exit the test iteration or
    QC''s business process test and moves on to the next iteration. If there is no
    next iteration, it stops execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value of `ExitActionIteration` is displayed in the **Run Result**
    window.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExitComponent`: This statement allows us to exit the current component run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Business Process Testing** (**BPT**), each component (scripted or business)
    is the same as a QTP Test with a single action. A business process runs each component
    one by one. QC loads the component in QTP and starts the run. Once the run is
    complete, the next component in the test is loaded, and all the results are collated
    into a single test result summary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ExitComponentIteration`: This statement allows us to exit the current component
    iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates the use of the `Exit` statement(s) if the
    checkpoint fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Recovery scenarios – an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any unexpected event or erroneous condition that crashes the AUT during execution
    needs to be recovered. To handle these situations, QTP allows us to define the
    recovery scenarios and associates them with the test. Recovery scenarios activate
    specific recovery operations when trigger events occur.
  prefs: []
  type: TYPE_NORMAL
- en: The recovery scenario manager allows us to define the recovery scenario, that
    includes an unexpected event and the operations to recover during a run session.
    For example, an unexpected pop-up message appears and the recovery scenario is
    recovered from it by clicking on the **OK** button in the pop up.
  prefs: []
  type: TYPE_NORMAL
- en: 'A recovery scenario has the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trigger event**: Any event that abruptly interferes with the normal flow
    of the test runs, for example, a dialog pops up during test execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recovery operations**: The recovery option allows QTP to continue running
    the test or its components after the trigger event hampers test execution. For
    example, closing the pop-up window or a call to restart the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post**-**recovery option**: QTP provide options after the recovery operations
    have been executed, for example, calling a custom function, executing the same
    step, or executing the next step in the test or component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After recovery scenarios are created, we can associate them with selected components/tests.
    So, QTP will perform the appropriate scenarios during the run sessions if a trigger
    event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have gone through various concepts and code blocks. The key
    is to understand that apart from the QTP features, we need other components that
    support the entire design and architecture of the framework. One of the key aspects
    for creating code blocks is to enhance the reusability and create an impact on
    every feature of designing the framework. The next chapter will talk about designing
    and implementing the test automation framework.
  prefs: []
  type: TYPE_NORMAL
