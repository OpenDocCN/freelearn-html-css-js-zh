- en: Chapter 3. Basic Building Blocks for Creating Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we have seen which QTP features are required to create
    scripts. To design a framework and its components we need to design reusable code
    blocks, apart from QTP features. The key features of code blocks are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual checkpoint**: This is a reusable function that checks whether the
    property is matching as expected at runtime'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual synchronization**: This is a reusable function that waits up to a
    specified time for the property to change'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptive programming**: This provides the object identification property
    in test scripts to create the object description or creates the description itself'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular expression**: This is a text string for matching a pattern and allows
    us to define objects that follow the pattern'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling with Err object and Exit statements**: Also known as exception
    handling, it guides us on how to come out of exceptional events and gracefully
    exit these conditions'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions, subroutines, and procedures**: Functions and subprocedures allow
    us to make scripts modular and reusable'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VBScript – key features for creating code blocks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VBScript is an easy-to-learn yet powerful scripting language. It is used to
    develop scripts to perform both simple and complex object-based tasks, even without
    previous programming experience. While working in the **Expert** view, use the
    following general VBScript syntax rules and guidelines:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Case sensitivity**: VBScript does not differentiate between uppercased and
    lowercased words. It is not case sensitive by default, for example, in constant,
    variable, object, and method names. The following two statements are identical:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Text strings**: We can define a string by adding double quotes before and
    after the text string. In the following example, the string value is assigned
    using double quotes:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Date strings**: We can define the date by adding hash marks before and after
    the date value; for example:'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Variables**: Variables are used to store strings, integers, dates, arrays,
    and objects. We can specify variables to refer to test objects or store simple
    values with or without using `Dim`. If used, the `Option Explicit` statement must
    appear in a script before any other statements. When the Option Explicit statement
    is declared, it forces us to explicitly declare variables using the `Dim`, `Private`,
    `Public`, or `ReDim` statements; otherwise, an error occurs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To specify a variable to refer to an object, use the `Set` statement with the
    following syntax:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Don''t use the `Set` statement to specify a variable that contains a simple
    value (such as a string or number). The example that follows shows us how to define
    a variable for a simple value:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or it can also be defined as:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Comments**: Type `rem` or use an apostrophe (`''`) to add comments.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spaces**: Spaces are ignored by VBScript; they just enhance the clarity and
    readability of the code.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parentheses**: If the called function returns a value, use parentheses around
    the arguments.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example requires parentheses around the method arguments since
    it returns a value:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following example requires parentheses around method arguments, since **Call**
    is being used:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following example requires parentheses around the method arguments since
    they return the value of the checkpoint:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following example does not require parentheses around the `Click` method
    arguments since they don''t return any values:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: VBScript procedures
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In VBScript, there are two types of procedures:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Subprocedures
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function procedures
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subprocedures
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A subprocedure starts with the `Sub` statement and ends with the `End Sub`
    statement. `Sub` accepts arguments and does not return a value. An example is
    shown in the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Function procedures
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function procedure starts with the `Function` statement and ends with the
    `End Function` statement. It can return a value; the return value is always a
    variant. To return the value, assign it to the function name. An example of the
    function procedure is shown as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Checkpoints
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A checkpoint checks the specific values or characteristics of a page, object,
    or text string and enables the test object to identify whether the AUT is functioning
    correctly. A checkpoint compares the expected value (captured at the time of recording
    or creating the checkpoint) with the actual value (captured at runtime).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script creates the order using the Flight application; after
    selecting the `FlyFrom insert` checkpoint, we need to verify whether the **FLIGHT**
    button''s **enabled** property is set to **True**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Checkpoints](img/1027EN_03_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Output value
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **output value** is a value that is retrieved during the test execution from
    DataTable or saved in a variable or parameter. When the output value is executed,
    the `Output` method places the object's property value into the prespecified column
    (which is defined when the test was created) and is retrieved through the DataTable.
    Later, this value is used to verify the expected and actual value; thus, we can
    use the output value as a checkpoint.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet creates a checkpoint using the output values:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can create a manual checkpoint using the `CheckProperty` method as well.
    `CheckProperty` allows us to use various options, and we can check the not equal
    condition as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'How to check an equal condition using `CheckProperty`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Checkpoints allow the following options to ascertain various unequal options:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '`micGreaterThan`: This option verifies whether the value of the property is
    greater than the expected value.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`micLessThan`: This option verifies whether the value of the property is less
    than the expected value.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`micGreaterThanOrEqual`: This option verifies whether the value of the property
    is greater than or equal to the expected value.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`micLessThanOrEqual`: This option verifies whether the value of the property
    is less than or equal to the expected value.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`micNotEqual`: This option verifies whether the value of the property is not
    equal to the expected value.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to use the not equal option:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`micRegExpMatch`: The `CheckProperty` also allows us to use regular expressions.
    The `micRegExpMatch` option verifies if the property value matches with the regular
    expression, as shown in the following example, and how to use the regular expression
    with `CheckProperty`:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`GetROProperty` returns the current value of the specified identification property
    from the runtime object in the AUT. We can use the `GetROProperty` to create the
    checkpoint. Using this checkpoint, we will get the runtime property, and we can
    compare it with the expected value as shown in the following example:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When we design the framework and its components, we need to create manual checkpoints
    for reusability; a good practice is to create them as reusable functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QTP and AUT join or handshake at a certain point to match up their speeds for
    the event to occur in order to accomplish a certain sequence of action.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Speed mismatch, delays, the wait for property to change, change of object, and
    occurrence of an event causes mismatch in the speed of execution of scripts, and
    AUT causes synchronization issues, for example, script has to wait until the page
    is loaded. The default object synchronization is 20 seconds but we can change
    it by navigating to **File** | **Test Settings** | **Run** | **Object synchronization
    timeout**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the **Object synchronization timeout** from **20** seconds to **2**
    seconds as shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Synchronization](img/1027EN_03_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have changed the **Object synchronization timeout** value, we will
    run the following script:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To achieve synchronization, we introduce some wait scripts that wait for the
    specified time. Refer to the following code snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `wait` statement tells QTP to wait for a predefined amount of time, for
    example, 10 seconds. Here, the following situations can arise:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The AUT is ready to perform the next step, but the script is still waiting till
    the specified time
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wait time is over and the AUT is still not ready for the next step to be
    executed
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both of these conditions, static wait is not a good option. Waiting for an
    appropriate amount of time based on some property or event that has to be completed
    is called dynamic synchronization.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic synchronization
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dynamic synchronization allows waiting till the object property is changed
    or till time out, as shown in the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `WaitProperty` can be inserted using Insert synchronization point or we
    can manually add the `WaitProperty` method by typing it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from using `WaitProperty`, we can also create synchronization points
    using the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Descriptive programming
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QTP identifies an object by its properties that are stored in the OR. When the
    object description is created in the test script, the approach is called descriptive
    programming. In this method of script creation, objects are not stored in the
    OR.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Descriptive programming can be achieved in two ways:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Static programming**: The object''s description is directly provided into
    the script'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic programming**: The object''s description is created using QTP''s
    description object'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static programming
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Examples of static descriptive programming are shown as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Dynamic programming
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QTP allows the use of the `Description` object and its `Create` method to create
    the object description and pass it as an argument to create the scripts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the same:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The test objects that have the same identification properties are called **duplicate
    objects** . Ordinal identifiers allow us to identify duplicate objects using the
    `index` and `location` properties. `index` represents the order of the objects
    from left to right and top to bottom. `location` represents the objects from top-left
    to bottom and top-right to bottom.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The outcome after we run the script is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic programming](img/1027EN_03_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The outcome after we run the script is as follows
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic programming](img/1027EN_03_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: Descriptive programming allows us to deal with dynamic objects; this is a situation
    where the test object does not exist till runtime, so we cannot store the dynamic
    objects in the OR. For example, a textbox is generated based on the user ID in
    the web page at runtime and the name of the object follows the convention edit_xxx,
    that is, edit_123455\.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is provided on the preceding page; now we will write the code to set
    the value as shown in the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One use of descriptive programming is that it allows us to find the object(s)
    at runtime and performs the following operations on it/them:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Regular expressions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A regular expression (abbreviated regex or regexp) is a sequence of text characters,
    some of which are understood to be meta characters with symbolic meaning and some
    of which have their literal meaning, that together automatically identify a given
    pattern.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression is very useful when the objects are dynamic in nature and
    we cannot store each and every object which follows a pattern in the OR. In the
    Flight Reservation application, we can open any existing order by the order number
    and send the fax. When the **Fax** window is opened, the title of the window contains
    the order number; this will cause an issue when we want to open the fax window
    with a different order number as the window is no longer the same. In this condition,
    we can use regular expression. Refer to the following screenshot; the identification
    property of the object is **Fax Order No. 11**. Here we convert the **text** property
    into a regular expression to identify the property as a pattern and not a fixed
    value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression shown in the following screenshot matches a pattern where
    the number of digits may vary from **1** to **3**. This means that it is used
    to verify the **Fax** window title from 0 to 999.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Regular expressions](img/1027EN_03_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Regular expressions in descriptive programming
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the earlier screenshot, we have seen that once we change the **text** property
    to the regular expression, QTP is able to identify objects with order numbers
    from 0 to 999\. We can use the regular expression in object description as shown
    in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Regular expressions in checkpoints
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A checkpoint allows us to use the regular expression for matching the pattern.
    To use the regular expression in a checkpoint, do the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Parameter Options** in the **Text Checkpoint Properties** window.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on ![Regular expressions in checkpoints](img/1027EN_03_icon.jpg).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Regular expression** option in **Parameter Options**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** and change the parameter to regular expressions (in **DataTable**)
    as shown in the following screenshot.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Regular expressions in checkpoints](img/1027EN_03_06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Regular expressions in CheckProperty
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CheckProperty` allows us to compare the values using regular expressions and
    `micRegExpMatch` as shown in the following code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Error handling
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exception handling is the way to deal with abnormal or exceptional events that
    interrupt the normal flow of test execution. For example, when a floating point
    number is divided by zero (0), it stops execution and an error message is displayed
    as shown in the following piece of code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Err` object in VBScript holds the details of the runtime errors, allowing
    continued execution despite a runtime error.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `On Error Resume Next` statement is absent in the script, any runtime
    error will stop execution and display the error message as shown:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using the `On Error Resume Next` statement allows us to continue with the exception,
    but it is necessary to deal with the error using the `Err` object and come out
    clean from the erroneous condition.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties of the `Err` object are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '`Description` property'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelpContext` property'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelpFile` property'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number` property'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source` property'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The methods of the `Err` object are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '`Clear` method'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Raise` method'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Use `On Error GoTo 0` to disable error handling if `On Error Resume Next` has
    been used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples are shown in the following code snippet of how to use the `Err` object
    for error handling:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Exit` statements in QTP are very important; they allow us to gracefully
    exit from loops, actions, iterations, components, and tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The different types of `Exit` statements are shown as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`Exit Do`: This statement allows us to exit a `Do` loop statement.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exit For`: This statement allows us to exit a `For` loop.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exit Function`: This statement allows us to exit the `Function` procedure
    in which it is called.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exit Property`: This statement allows us to exit the `Property` procedure.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exit Sub`: This allows statement us to exit the `Sub` procedure in which it
    is called.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExitAction`: This statement allows us to exit from the current iteration of
    an action.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExitTest`: This statement allows us to exit the entire QTP or **Quality Centre**
    (**QC**) business process test, regardless of the runtime iteration settings.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExitTestIteration`: This statement allows us to exit the test iteration or
    QC''s business process test and moves on to the next iteration. If there is no
    next iteration, it stops execution.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value of `ExitActionIteration` is displayed in the **Run Result**
    window.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '`ExitComponent`: This statement allows us to exit the current component run.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Business Process Testing** (**BPT**), each component (scripted or business)
    is the same as a QTP Test with a single action. A business process runs each component
    one by one. QC loads the component in QTP and starts the run. Once the run is
    complete, the next component in the test is loaded, and all the results are collated
    into a single test result summary.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ExitComponentIteration`: This statement allows us to exit the current component
    iteration.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates the use of the `Exit` statement(s) if the
    checkpoint fails:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Recovery scenarios – an overview
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any unexpected event or erroneous condition that crashes the AUT during execution
    needs to be recovered. To handle these situations, QTP allows us to define the
    recovery scenarios and associates them with the test. Recovery scenarios activate
    specific recovery operations when trigger events occur.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The recovery scenario manager allows us to define the recovery scenario, that
    includes an unexpected event and the operations to recover during a run session.
    For example, an unexpected pop-up message appears and the recovery scenario is
    recovered from it by clicking on the **OK** button in the pop up.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'A recovery scenario has the following elements:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Trigger event**: Any event that abruptly interferes with the normal flow
    of the test runs, for example, a dialog pops up during test execution.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recovery operations**: The recovery option allows QTP to continue running
    the test or its components after the trigger event hampers test execution. For
    example, closing the pop-up window or a call to restart the window.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post**-**recovery option**: QTP provide options after the recovery operations
    have been executed, for example, calling a custom function, executing the same
    step, or executing the next step in the test or component.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After recovery scenarios are created, we can associate them with selected components/tests.
    So, QTP will perform the appropriate scenarios during the run sessions if a trigger
    event occurs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have gone through various concepts and code blocks. The key
    is to understand that apart from the QTP features, we need other components that
    support the entire design and architecture of the framework. One of the key aspects
    for creating code blocks is to enhance the reusability and create an impact on
    every feature of designing the framework. The next chapter will talk about designing
    and implementing the test automation framework.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了各种概念和代码块。关键是要理解，除了QTP功能之外，我们还需要其他支持整个框架设计和架构的组件。创建代码块的一个关键方面是提高其可重用性，并对框架设计的每个功能产生影响。下一章将讨论设计和实现测试自动化框架。
