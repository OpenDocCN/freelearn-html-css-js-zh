["```js\nimport fs from 'fs'\nimport path from 'path'\nimport superagent from 'superagent'\nimport mkdirp from 'mkdirp'\nimport { urlToFilename } from './utils.js' \n```", "```js\nexport function spider (url, cb) {\n  const filename = urlToFilename(url)\n  fs.access(filename, err => {                                // (1)\n    if (err && err.code === 'ENOENT') {\n      console.log(`Downloading ${url} into ${filename}`)\n      superagent.get(url).end((err, res) => {                 // (2)\n        if (err) {\n          cb(err)\n        } else {\n          mkdirp(path.dirname(filename), err => {             // (3)\n            if (err) {\n              cb(err)\n            } else {\n              fs.writeFile(filename, res.text, err => {       // (4)\n                if (err) {\n                  cb(err)\n                } else {\n                  cb(null, filename, true)\n                }\n              })\n            }\n          })\n        }\n      })\n    } else {\n      cb(null, filename, false)\n    }\n  })\n} \n```", "```js\n    fs.access(filename, err => ... \n    ```", "```js\n    superagent.get(url).end((err, res) => ... \n    ```", "```js\n    mkdirp(path.dirname(filename), err => ... \n    ```", "```js\n    fs.writeFile(filename, res.text, err => ... \n    ```", "```js\nimport { spider } from './spider.js'\nspider(process.argv[2], (err, filename, downloaded) => {\n  if (err) {\n    console.error(err)\n  } else if (downloaded) {\n    console.log(`Completed the download of \"${filename}\"`)\n  } else {\n    console.log(`\"${filename}\" was already downloaded`)\n  }\n}) \n```", "```js\nnpm install \n```", "```js\nnode spider-cli.js http://www.example.com \n```", "```js\nasyncFoo(err => {\n  asyncBar(err => {\n    asyncFooBar(err => {\n      //...\n    })\n  })\n}) \n```", "```js\nif (err) {\n  cb(err)\n} else {\n  // code to execute when there are no errors\n} \n```", "```js\nif (err) {\n  return cb(err)\n}\n// code to execute when there are no errors \n```", "```js\nif (err) {\n  callback(err)\n}\n// code to execute when there are no errors. \n```", "```js\nreturn callback(...) \n```", "```js\ncallback(...)\nreturn \n```", "```js\nfunction saveFile (filename, contents, cb) {\n  mkdirp(path.dirname(filename), err => {\n    if (err) {\n      return cb(err)\n    }\n    fs.writeFile(filename, contents, cb)\n  })\n} \n```", "```js\nfunction download (url, filename, cb) {\n  console.log(`Downloading ${url}`)\n  superagent.get(url).end((err, res) => {\n    if (err) {\n      return cb(err)\n    }\n    saveFile(filename, res.text, err => {\n      if (err) {\n        return cb(err)\n      }\n      console.log(`Downloaded and saved: ${url}`)\n      cb(null, res.text)\n    })\n  })\n} \n```", "```js\nexport function spider (url, cb) {\n  const filename = urlToFilename(url)\n  fs.access(filename, err => {\n    if (!err || err.code !== 'ENOENT') {   // (1)\n      return cb(null, filename, false)\n    }\n    download(url, filename, err => {\n      if (err) {\n        return cb(err)\n      }\n      cb(null, filename, true)\n    })\n  })\n} \n```", "```js\nfunction task1 (cb) {\n  asyncOperation(() => {\n    task2(cb)\n  })\n}\nfunction task2 (cb) {\n  asyncOperation(() => {\n    task3(cb)\n  })\n}\nfunction task3 (cb) {\n  asyncOperation(() => {\n    cb() // finally executes the callback\n  })\n}\ntask1(() => {\n  // executed when task1, task2 and task3 are completed\n  console.log('tasks 1, 2 and 3 executed')\n}) \n```", "```js\nexport function spider (url, nesting, cb) {\n  const filename = urlToFilename(url)\n  fs.readFile(filename, 'utf8', (err, fileContent) => {\n    if (err) {\n      if (err.code !== 'ENOENT') {\n        return cb(err)\n      }\n      // The file doesn't exist, so let's download it\n      return download(url, filename, (err, requestContent) => {\n        if (err) {\n          return cb(err)\n        }\n        spiderLinks(url, requestContent, nesting, cb)\n      })\n    }\n    // The file already exists, let's process the links\n    spiderLinks(url, fileContent, nesting, cb)\n  })\n} \n```", "```js\nfunction spiderLinks (currentUrl, body, nesting, cb) {\n  if (nesting === 0) {\n    // Remember Zalgo from chapter 3?\n    return process.nextTick(cb)\n  }\n  const links = getPageLinks(currentUrl, body)            // (1)\n  if (links.length === 0) {\n    return process.nextTick(cb)\n  }\n  function iterate (index) {                              // (2)\n    if (index === links.length) {\n      return cb()\n    }\n    spider(links[index], nesting - 1, function (err) {    // (3)\n      if (err) {\n        return cb(err)\n      }\n      iterate(index + 1)\n    })\n  }\n  iterate(0)                                              // (4)\n} \n```", "```js\nimport { spider } from './spider.js'\nconst url = process.argv[2]\nconst nesting = Number.parseInt(process.argv[3], 10) || 1\nspider(url, nesting, err => {\n  if (err) {\n    console.error(err)\n    process.exit(1)\n  }\n  console.log('Download complete')\n}) \n```", "```js\nfunction iterate (index) {\n  if (index === tasks.length) {\n    return finish()\n  }\n  const task = tasks[index]\n  task(() => iterate(index + 1))\n}\nfunction finish () {\n  // iteration completed\n}\niterate(0) \n```", "```js\niterateSeries(collection, iteratorCallback, finalCallback) \n```", "```js\nfunction spiderLinks (currentUrl, body, nesting, cb) {\n  if (nesting === 0) {\n    return process.nextTick(cb)\n  }\n  const links = getPageLinks(currentUrl, body)\n  if (links.length === 0) {\n    return process.nextTick(cb)\n  }\n  let completed = 0\n  let hasErrors = false\n  function done (err) {\n    if (err) {\n      hasErrors = true\n      return cb(err)\n    }\n    if (++completed === links.length && !hasErrors) {\n      return cb()\n    }\n  }\n  links.forEach(link => spider(link, nesting - 1, done))\n} \n```", "```js\nlinks.forEach(link => spider(link, nesting - 1, done)) \n```", "```js\nfunction done (err) {\n  if (err) {\n    hasErrors = true\n    return cb(err)\n  }\n  if (++completed === links.length && !hasErrors) {\n    return cb()\n  }\n} \n```", "```js\nconst tasks = [ /* ... */ ]\nlet completed = 0\ntasks.forEach(task => {\n  task(() => {\n    if (++completed === tasks.length) {\n      finish()\n    }\n  })\n})\nfunction finish () {\n  // all the tasks completed\n} \n```", "```js\nexport function spider (url, nesting, cb) {\n  const filename = urlToFilename(url)\n  fs.readFile(filename, 'utf8', (err, fileContent) => {\n    if (err) {\n      if (err.code !== 'ENOENT') {\n        return cb(err)\n      }\n      return download(url, filename, (err, requestContent) => {\n        // ... \n```", "```js\nconst spidering = new Set()\nfunction spider (url, nesting, cb) {\n  if (spidering.has(url)) {\n    return process.nextTick(cb)\n  }\n  spidering.add(url)\n// ... \n```", "```js\nconst tasks = [\n  // ...\n]\nconst concurrency = 2\nlet running = 0\nlet completed = 0\nlet index = 0\nfunction next () {                                          // (1)\n  while (running < concurrency && index < tasks.length) {\n    const task = tasks[index++]\n    task(() => {                                            // (2)\n      if (++completed === tasks.length) {\n        return finish()\n      }\n      running--\n      next()\n    })\n    running++\n  }\n}\nnext()\nfunction finish() {\n  // all tasks finished\n} \n```", "```js\nexport class TaskQueue {\n  constructor (concurrency) {\n    this.concurrency = concurrency\n    this.running = 0\n    this.queue = []\n  }\n  pushTask (task) {\n    this.queue.push(task)\n    process.nextTick(this.next.bind(this))\n    return this\n  }\n  next () {\n    while (this.running < this.concurrency && this.queue.length) {\n      const task = this.queue.shift()\n      task(() => {\n        this.running--\n        process.nextTick(this.next.bind(this))\n      })\n      this.running++\n    }\n  }\n} \n```", "```js\nimport { EventEmitter } from 'events'\nexport class TaskQueue extends EventEmitter {\n  constructor (concurrency) {\n    super()\n    // ...\n  }\n  // ...\n} \n```", "```js\nnext () {\n  if (this.running === 0 && this.queue.length === 0) {         // (1)\n    return this.emit('empty')\n  }\n  while (this.running < this.concurrency && this.queue.length) {\n    const task = this.queue.shift()\n    task((err) => {                                            // (2)\n      if (err) {\n        this.emit('error', err)\n      }\n      this.running--\n      process.nextTick(this.next.bind(this))\n    })\n    this.running++\n  }\n} \n```", "```js\nfunction spiderTask (url, nesting, queue, cb) {             // (1)\n  const filename = urlToFilename(url)\n  fs.readFile(filename, 'utf8', (err, fileContent) => {\n    if (err) {\n      if (err.code !== 'ENOENT') {\n        return cb(err)\n      }\n      return download(url, filename, (err, requestContent) => {\n        if (err) {\n          return cb(err)\n        }\n        spiderLinks(url, requestContent, nesting, queue)    // (2)\n        return cb()\n      })\n    }\n    spiderLinks(url, fileContent, nesting, queue)           // (3)\n    return cb()\n  })\n} \n```", "```js\nfunction spiderLinks (currentUrl, body, nesting, queue) {\n  if (nesting === 0) {\n    return\n  }\n  const links = getPageLinks(currentUrl, body)\n  if (links.length === 0) {\n    return\n  }\n  links.forEach(link => spider(link, nesting - 1, queue))\n} \n```", "```js\nconst spidering = new Set()                               // (1)\nexport function spider (url, nesting, queue) {\n  if (spidering.has(url)) {\n    return\n  }\n  spidering.add(url)\n  queue.pushTask((done) => {                              // (2)\n    spiderTask(url, nesting, queue, done)\n  })\n} \n```", "```js\nimport { spider } from './spider.js'\nimport { TaskQueue } from './TaskQueue.js'\nconst url = process.argv[2]                                    // (1)\nconst nesting = Number.parseInt(process.argv[3], 10) || 1\nconst concurrency = Number.parseInt(process.argv[4], 10) || 2\nconst spiderQueue = new TaskQueue(concurrency)                 // (2)\nspiderQueue.on('error', console.error)\nspiderQueue.on('empty', () => console.log('Download complete'))\nspider(url, nesting, spiderQueue)                              // (3) \n```", "```js\nnode spider-cli.js https://loige.co 1 4 \n```", "```js\n    function concatFiles (srcFile1, srcFile2, srcFile3, ... ,\n                          dest, cb) {\n      // ...\n    } \n    ```", "```js\n    function listNestedFiles (dir, cb) { /* ... */ } \n    ```", "```js\n    function recursiveFind(dir, keyword, cb) { /* ... */ } \n    ```", "```js\n    recursiveFind('myDir', 'batman', console.log)\n    // should print ['foo.txt', 'baz.txt'] \n    ```"]