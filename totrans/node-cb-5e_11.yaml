- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Node.js Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **microservices** is used to describe applications that have been built
    based on the microservice architecture paradigm. This architecture encourages
    larger applications to be built as a set of smaller modular applications, where
    each application focuses on one key concern. Microservice architectures are a
    contrast to the monolithic architectures of the past. **Monolith** is a term given
    to an application that handles many disparate concerns.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous benefits to adopting a microservice architecture. Ensuring
    that an application only serves one purpose means that the application can be
    optimized to best serve that purpose. Microservices help to decouple various parts
    of a system, which can result in easier debuggability if something goes wrong.
    Adopting a microservice architecture also enables you to scale different parts
    of the system independently.
  prefs: []
  type: TYPE_NORMAL
- en: There are not only technical benefits to adopting a microservice architecture.
    Separating microservices into separate code bases can enable smaller teams to
    have autonomy over the microservices they’re responsible for. Many microservice-based
    systems are written in a variety of frameworks and languages. Development teams
    can choose the language and framework they feel is best suited for their microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can, however, increase complexity due to the management of multiple
    services, which requires mature DevOps practices and comprehensive monitoring.
    For this reason, microservices are often not suitable for simple applications
    where the management overhead outweighs the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js microservices commonly expose **RESTful** APIs. **Representational State
    Transfer** ( **REST** ) is very popular. A RESTful API exposes its API via HTTP,
    making appropriate use of the HTTP verbs. For example, if a blogging service exposed
    a RESTful API, you’d expect it to expose an endpoint to which you could send an
    HTTP GET request to retrieve a blog post. Similarly, it would likely expose an
    endpoint to which you could send an HTTP POST request, with data, to publish new
    blogs.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices and container technologies go hand in hand. Cloud and container
    technologies are growing in adoption, with Docker and Kubernetes, which are the
    leading choices for deploying microservice-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a microservice with LoopBack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming a microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have Node.js installed, preferably the latest version – Node.js
    22. You’ll also need access to an editor and browser of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Before completing this chapter, it is recommended that you have some understanding
    of HTTP protocols – you can refer to [*Chapter 4*](B19212_04.xhtml#_idTextAnchor100)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The latter three recipes of this chapter will require you to have **Docker for
    Desktop** installed. It is recommended to install Docker for Desktop from [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The recipe code for this chapter can be found at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter11** folder.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a microservice with LoopBack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LoopBack** ( [https://loopback.io/](https://loopback.io/) ) is an extensible
    open source Node.js framework that is purpose-built for creating REST APIs and
    microservices. Early versions of LoopBack were both inspired by and based directly
    on the Express.js web framework. The most recent version, LoopBack 4, went through
    a significant refactor and was rewritten in TypeScript. This refactor allowed
    the maintainers to expand the features of LoopBack without being restricted by
    the technical implementation decisions made in prior versions.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to use the LoopBack 4 **Command-Line Interface**
    ( **CLI** ) to generate a Node.js microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prepare for the recipe, we need to globally install the LoopBack CLI. Enter
    the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have globally installed the LoopBack CLI, let’s move on to the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’re going to generate a RESTful API, which will form our
    Node.js microservice. The RESTful API that we will create will mimic a bookstore
    inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The LoopBack CLI should be available in your path as **lb4** . To start generating
    the project, we call the LoopBack CLI, providing a project name. Let’s give our
    project the name **loopback-bookstore** . Enter the following command in your
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Entering the command will start an interactive interface where the LoopBack
    CLI will request information for your new project. For the project description,
    project root directory, and application class name, just hit *Enter* to accept
    the default names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fourth CLI question asks the user which features should be enabled in the
    project. Hit *Enter* to enable all features. If you are shown a subsequent command
    detailing that Yarn is available, enter **N** to indicate we do not wish to enable
    it by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now see the LoopBack CLI scaffolding your application. Expect to
    see output starting with the following in your terminal window, detailing files
    and directories that have been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The LoopBack CLI has now generated our application. It should have also automatically
    installed our **npm** dependencies. Navigate to the application directory and
    start the application with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you navigate to **http://localhost:3000** in your browser, you should expect
    to see the application running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The generated LoopBack home page for the LoopBack bookstore
    application](img/Figure_11.1_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The generated LoopBack home page for the LoopBack bookstore application
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to your terminal and press *Ctrl* + *C* to stop the application. So
    far, the LoopBack CLI has just generated a barebones project structure. Now we
    can build our bookstore API. We can do this using LoopBack’s model generator.
    Enter the following command to start creating a model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'LoopBack’s model generator will open an interactive CLI where we can define
    the model and its properties. The model we want to create is a book of the **Entity**
    type. First, add the **id** property, which will be a number. You’ll also need
    to add **author** and **title** properties to the model, which should both be
    mandatory and of the string type. Enter these via the interactive session. The
    transcript of the session should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.2 – An overview of the expected transcript of the LoopBack model
    generator](img/Figure_11.2_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – An overview of the expected transcript of the LoopBack model generator
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve created our model, we need to create our data source using LoopBack’s
    data source CLI. Enter the following command in your terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The interactive CLI will request information about the data source. We’re going
    to use an in-memory data store. The values you should supply should be **Data
    source name: local** and **In-memory DB** . For the last two questions, hit *Enter*
    to accept the defaults. Expect the transcript of your session to match the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.3 – An overview of the transcript of the LoopBack data source generator](img/Figure_11.3_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – An overview of the transcript of the LoopBack data source generator
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a LoopBack repository. This is a LoopBack class that
    binds the data source and the model. Enter the following command to start the
    repository generator interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the repository, we want to use **LocalDatasource** for the **Book** model
    with a **DefaultCrudRepository** base class. The terminal should match the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Expected transcript of the LoopBack repository generator](img/Figure_11.4_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Expected transcript of the LoopBack repository generator
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create a LoopBack controller. A LoopBack controller handles
    the API requests and responses. Enter the following command to start the controller
    generator interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our controller should be a **REST Controller with Create, Read, Update, and
    Delete** ( **CRUD** ) **functions** named **Books** . For the remainder of the
    questions, you can accept the defaults by hitting *Enter* . The terminal should
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – An overview of the transcript of the LoopBack controller generator](img/Figure_11.5_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – An overview of the transcript of the LoopBack controller generator
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the application with **$ npm start** and navigate to **http://localhost:3000/explorer/**
    . This will open up the LoopBack API explorer that we can use to test our API.
    Observe that the routes for various HTTP verbs have been automatically generated
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – LoopBack API Explorer for the loopback-bookstore application](img/Figure_11.6_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – LoopBack API Explorer for the loopback-bookstore application
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the HTTP POST route in the explorer. Clicking the **Try it out**
    button will open an interface where you will be able to add a book to the inventory.
    Change the sample **title** and **author** values and then click **Execute** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – LoopBack API Explorer request interface](img/Figure_11.7_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – LoopBack API Explorer request interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **http://localhost:3000/books** . This route will return a JSON
    array of all of the books stored. Expect to see the book that we added in the
    previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve generated a RESTful API that represents a bookstore inventory using the
    LoopBack CLI.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe demonstrated how to build a RESTful API for a sample bookstore inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command we supplied to the generator was **$ lb4 loopback-bookstore**
    . This command scaffolds a LoopBack project structure for our application. In
    the recipe, we enabled all the following optional features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ESLint** : A popular linter with some pre-defined linter rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prettier** : A popular code formatter that is used throughout the examples
    in this book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocha** : A Node.js test framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loopback Build** : A set of LoopBack build helpers, exposed via the **@**
    **loopback/build** module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VSCode** : Configuration files for the VSCode editor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker** : Generates **Dockerfile** and **.dockerignore** for the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repositories** : Enables convenience methods that can automatically bind
    repository classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services** : Includes service-proxy imports (refer to [https://loopback.io/doc/en/lb4/Service.html](https://loopback.io/doc/en/lb4/Service.html)
    for more information on services)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the optional features were selected, the LoopBack CLI generated a base
    application structure. This structure includes directories and files related to
    the optional features that were selected. For example, the **eslintrc.js** and
    **mocharc.js** files were generated to configure ESLint and Mocha.
  prefs: []
  type: TYPE_NORMAL
- en: We used the LoopBack model generator to create representations of the data we
    needed to store. In our case, we created one model named **Book** that contained
    the data we wished to store for each book. The LoopBack generator assisted us
    in adding these properties, including specifying which type the properties should
    be and whether they are required or optional properties. In larger and more complex
    APIs, it’s common to have multiple models, where some models may reference others,
    in a comparable manner to how relational databases are structured.
  prefs: []
  type: TYPE_NORMAL
- en: The model generator created our **Book** model in **src/models/book.model.ts**
    . The model file contains a representation of a book in the form of a TypeScript
    class.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the model, we used the LoopBack data source generator to create
    a data source. We opted to use an in-memory data source to avoid the need to provision
    an instance of a database. Using an in-memory data source means that by default,
    when we stop our API from running, the data is lost. LoopBack handles data source
    integrations, removing the need for the developer to create and set up the data
    store connection. For the most part, this means the developer will not need to
    write code that is specific to the data store, making it easier to change between
    data stores.
  prefs: []
  type: TYPE_NORMAL
- en: With LoopBack 4, it is necessary to create a repository for our **Book** model.
    A repository acts as an interface to a model, providing strong-typed data operations.
  prefs: []
  type: TYPE_NORMAL
- en: The final step of the recipe involved generating a controller to handle API
    requests and responses. We instructed the generator to create a REST Controller
    with CRUD functions for the **Book** model. **CRUD** covers the four basic functions
    that enable persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Book** controller was created at **src/controllers/books.controller.ts**
    and contains generated functions to handle each REST API operation for our **Book**
    model. For example, the following code was generated in the controller to handle
    an HTTP GET request on the **/books** route. This route returns all books in the
    data store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The controller, repositories, and data sources that were created are all loaded
    and bound to the application at boot time. This is handled by the **@** **loopback/boot**
    module.
  prefs: []
  type: TYPE_NORMAL
- en: In the final part of the recipe, we used the API explorer ( **http://localhost:3000/explorer/**
    ) to send requests to our API. The route explorer displays the available routes
    and provides sample requests for each route, allowing for an intuitive way to
    test your API. This explorer is implemented using Swagger UI ( [https://swagger.io/](https://swagger.io/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: LoopBack also allows for the generation of an OpenAPI specification document
    for the API, providing a standard interface for the RESTful API that includes
    human- and machine-readable definitions of the API routes. This can be achieved
    by running the **npm run openapi-spec ./open-api.json** command, which will create
    an **open-api.json** file containing the OpenAPI specification.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe highlighted that it is possible to generate a RESTful Node.js API
    without writing any code. Once your base API has been generated, it would then
    be possible to extend the application with any necessary business logic. LoopBack
    abstracts and handles some of the common technical tasks related to creating APIs,
    such as implementing CRUD operations. This enables developers to focus on the
    business logic of their microservice, rather than underlying and repetitive technical
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Consuming a microservice* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create an Express.js web application that will consume
    the **loopback-bookstore** microservice created in the previous recipe, *Generating
    a microservice with LoopBack* . This will demonstrate how modern web architectures
    are implemented based on the microservice pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will be consuming the microservice created in the *Generating
    a microservice with LoopBack* recipe. If you have not completed that recipe, you
    can obtain the code from the Packt GitHub repository at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter11/loopback-bookstore** directory.
  prefs: []
  type: TYPE_NORMAL
- en: We will also be creating a frontend web application, using the Express.js generator
    to create a base for our web application. For more information on the Express.js
    generator, visit [https://expressjs.com/en/starter/generator.html](https://expressjs.com/en/starter/generator.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following commands in your terminal to create the base application
    using the Express.js generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be creating a route and HTML form to add a book to the bookstore inventory.
    Let’s create the files for those in advance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a base Express.js web application, we’re ready to move on to
    the recipe steps, where we’ll extend the application to interact with the bookstore
    inventory microservice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re going to build a web application with Express.js that consumes our **loopback-bookstore**
    microservice. The web application should enable us to view the inventory and add
    a book to the inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding two routes to the application. The first route we will add
    is a **/inventory** route that will accept an HTTP GET request. This route will
    respond with a list of books in the inventory and an HTML form that can be used
    to add a book to the inventory. The second route will accept an HTTP POST request
    on the **/inventory/add** endpoint. The **/inventory/add** route will interact
    with the bookstore inventory microservice to persist a new book. Add the following
    to **routes/inventory.j s** to create these two routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in **app.js** , we need to register our new **inventory** router. Add
    the following line to **app.js** to first import the router using **var** to be
    consistent with the rest of the generated file. Add the following just below the
    other router imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to instruct our Express.js application to use the **inventory**
    router. Add the following line below **app.use(''/users'', usersRouter);** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our inventory routes reference an **Embedded JavaScript** ( **EJS** ) template
    file named **inventory.ejs** . This template file will output a list of all books
    stored in the inventory and expose a form we can use to add books to the inventory.
    Add the following to the **views/inventory.ejs** file we created in the *Getting
    started* section of this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start your **loopback-bookstore** microservice from the previous recipe. Do
    this from within the **loopback-bookstore** directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in a separate terminal window, start the **bookstore-web-app** application
    with the following command. We’ll also pass a **PORT** environment variable to
    the start command to set a custom port. Express.js web applications default to
    port **3000** , but this will already be in use by our **loopback-bookstore**
    microservice, so we need to supply an alternative port. Run the following command
    from the **bookstore-web-app** directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to **http://localhost:8080/inventory** in your browser and expect
    to see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.8 – HTML page showing an empty bookstore inventory and an HTML
    form to add a new book](img/Figure_11.8_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – HTML page showing an empty bookstore inventory and an HTML form
    to add a new book
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try adding a book to the inventory. Populate the **title** and **author**
    input fields and then click the **Submit** button. After submitting, you should
    expect to see the book you submitted added to the inventory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Web page showing a populated bookstore inventory](img/Figure_11.9_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Web page showing a populated bookstore inventory
  prefs: []
  type: TYPE_NORMAL
- en: We’ve successfully built a frontend web application that communicates with our
    **loopback-bookstore** microservice.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we implemented a frontend web application layer that was backed
    by our **loopback-bookstore** microservice.
  prefs: []
  type: TYPE_NORMAL
- en: When our **/inventory** web page loads, under the covers, the Express.js web
    frontend queries the data from the loopback microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Our Express.js server sends an HTTP POST request to the **http://localhost:3000/books**
    endpoint. The request is supplied with the HTML form data.
  prefs: []
  type: TYPE_NORMAL
- en: Once the request to the LoopBack microservice is complete, the Express.js web
    application redirects to the **/inventory** route. This refreshes the template,
    which will then list the newly added book.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture demonstrates how you can modularize an application by building
    the backend API, in this case, **loopback-microservice** , separately from the
    frontend web application. This enables both applications to be scaled independently
    and keeps the code loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: For larger systems, it’s common to have many microservices communicating together.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Receiving HTTP POST requests* recipe in [*Chapter 4*](B19212_04.xhtml#_idTextAnchor100)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Generating a microservice w ith LoopBack* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have a Node.js microservice, we need to package it ready for deployment
    to the cloud. Cloud and container technologies go hand in hand, and one of the
    most prevalent container technologies is Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a tool used for creating, deploying, and running applications with
    containers. A container enables you to package up your application with all its
    dependencies. A container is often said to be like a virtual machine, the key
    difference being that Docker allows applications to reuse the same Linux kernel,
    whereas a virtual machine virtualizes the whole operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit to containerizing a microservice is that it is encapsulated,
    which means that the container holds everything that the microservice requires
    in order to run. This helps make the application portable and consistent across
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: Container technologies such as Docker are seen as the de facto tools for deploying
    to modern cloud environments, often combined with a container orchestrator such
    as Kubernetes, which we’ll cover in the *Deploying to Kubernetes* recipe of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker and Kubernetes are large and complex technologies. This chapter will
    focus on demonstrating how to leverage Docker and Kubernetes to deploy Node.js
    microservices. An in-depth overview of Docker and Kubernetes is beyond the scope
    of this book. Refer to the following links for more detailed information about
    Docker and Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes overview: [https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes setup guide: [https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we’ll be packaging a sample Node.js microservice into a Docker
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need to have Docker installed. It is recommended to
    install Docker for Desktop from [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure Docker is running. You can test this by entering the following command
    in your terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This command pulls the **hello-world** image from Docker Hub and creates a container
    to run it. Docker Hub is a central repository of Docker images, almost like an
    **npm** registry for Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: The **hello-world** image is a sample image that you can use to test that Docker
    is installed and operating correctly. When you run the image, expect to see **Hello
    from Docker!** returned along with additional help text.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need an API, or microservice, to build into a Docker container.
    We’ll use the Fastify CLI to generate an API. For more information on Fastify,
    refer to [*Chapter 6*](B19212_06.xhtml#_idTextAnchor178) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a sample API in a new directory named **fastify-microservice** by
    entering the following commands in your terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have confirmed that Docker is installed and we have a sample microservice,
    we can move on to the recipe steps, where we’ll build a container.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will be building a container for our **fastify-microservice**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a **Dockerfile** file and a **.dockerignore** file in the
    **fastify-microservice** directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A **Dockerfile** file is a set of instructions on how to build the container
    for our application or microservice. Open the **Dockerfile** file and add the
    following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create the **.dockerignore** file. Similar to a **.gitignore**
    file, the **.dockerignore** file is used to exclude files from being built into
    a container. Add the following to the **.** **dockerignore** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re now ready to build the microservice. We do this by using the **docker
    build** command, along with **fastify-microservice** as a tag for our image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following output as Docker builds the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Web page showing a populated bookstore inventory](img/Figure_11.10_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Web page showing a populated bookstore inventory
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command in your terminal window to list all of your Docker
    images. You should expect to see the **fastify-microservice** Docker image in
    the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can run the Docker image as a Docker container, passing the **--publish**
    flag to instruct Docker to map port **3000** from within the container to port
    **3000** on our local machine. Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should be able to navigate to **http://localhost:3000/example** and see
    the **this is an** **example** output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *C* in your terminal window to stop your container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve now successfully built our first containerized microservice.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers enable you to package your application into an isolated environment.
    **Dockerfile** is used to define the environment. The environment should include
    the libraries and dependencies that are required to run the application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the contents of the **Dockerfile** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FROM node:22** : The **node** instruction is used to initialize a new build
    stage. A **Dockerfile** file must start with a **FROM** instruction pointing to
    a valid Docker image that can be used as a base for our image. In this example,
    the image is based on the Docker Official Node.js image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RUN apt-get update...** : This line instructs Docker to update the containers’
    OS dependencies using the **Advanced Package Tool** ( **APT** ), which is Debian’s
    default package manager. It’s important that OS dependencies are up to date to
    ensure that your dependencies contain the latest available fixes and patches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COPY package*.json ./** : This copies the **package.json** and **package-lock.json**
    files, should they exist, into the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RUN npm install --production** : This executes the **npm install** command
    within the container based on the **package*.json** files copied earlier into
    the container. **npm install** must be run within the container as some dependencies
    may have native components that need to be built based on the container’s OS.
    For example, if you’re developing locally on macOS and have native dependencies,
    you will not be able to just copy the contents of **node_modules** into the container,
    as the native macOS dependencies will not work in the Debian-based container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COPY . /app.** : This copies our application code into the container. Note
    that the **COPY** command will ignore all patterns listed in the **.dockerignore**
    file. This means that the **COPY** command will not copy **node_modules** and
    other information to the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ENV PORT 3000** : This sets the **PORT** environment variable in the container
    to **3000** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXPOSE 3000** : The **EXPOSE** instruction is used as a form of documentation
    as to which port is intended to be published for the containerized application.
    It does not publish the port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**USER node** : This instructs Docker to run the image as the **node** user.
    The **node** user is created by the Docker Official Node.js image. When omitted,
    the image will default to being run as the root user. You should run your containers
    as an unprivileged (non-root) user where possible as security mitigation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMD ["npm", "start"]** : This executes the command to start the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ordering of the commands in **Dockerfile** is important. For each command
    in the **Dockerfile** file, Docker creates a new layer in the image. Docker will
    only rebuild the layers that have changed, so the ordering of the commands in
    the **Dockerfile** file can impact rebuild times. It is for this reason that we
    copy the application code into the container after running **npm install** , as
    we’re more commonly going to be changing the application code as opposed to changing
    our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to view the Docker layers for an image using the **docker history**
    command. For example, **$ docker history fastify-microservice** will output the
    layers of our **fastify-microservice** image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – An overview of Docker history output for the fastify-microservice
    image](img/Figure_11.11_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – An overview of Docker history output for the fastify-microservice
    image
  prefs: []
  type: TYPE_NORMAL
- en: The **$ docker build --tag fastify-microservice .** command builds the Docker
    image, based on the instructions in the **Dockerfile** file in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: To run the image, we call **docker run --publish 3000:3000 fastify-microservice**
    . We pass this command the name of the image we’d like to run, and also the port
    we wish to expose. The **--publish 3000:3000** option maps port **3000** on your
    host machine to port **3000** on the container, ensuring that any traffic sent
    to port **3000** on the host is forwarded to port **3000** in the container.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a Docker image, it’s important to make it as small as possible.
    It’s considered good practice for your production image to only contain the dependencies
    and libraries required to run the application in production. To create a smaller
    image, we can leverage Docker’s multistage builds capability ( [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Docker multistage builds allow us to define multiple Docker images in the same
    **Dockerfile** file. For Node.js applications, we can split the *build* and *run*
    steps into separate containers. The result is that the final production container,
    the **run** container, will be a smaller and lighter-weight container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use the following multistage **Dockerfile** file to containerize our
    **fastify-microservice** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Observe that there are two **FROM** instructions in the **Dockerfile** file,
    indicating that there are two build stages.
  prefs: []
  type: TYPE_NORMAL
- en: The first build stage creates a container that handles the installation of dependencies
    and any build tasks. In our example, the first container executes the **npm install**
    command. **node_modules** may contain native add-ons, which means the first container
    needs the relevant compilers and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The second container uses a base of the **node:22-slim** image. The **node:22-slim**
    image is a variant of the official Node.js Docker image that contains the minimum
    libraries required to run Node.js. This image is a much smaller and lighter-weight
    image. The regular **node** Docker image is around 1 GB in size, whereas the multi-stage
    **slim** image is around 200 MB. When deploying to the cloud, in many cases, you’ll
    be charged per MB. Minimizing your image size can result in cost savings.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve completed the recipes in this chapter, you should stop and remove
    the Docker containers and images. Otherwise, the containers and images may linger
    on your system and consume system resources. Use **$ docker ps** to list your
    containers. Locate the container identifier and pass this to **$ docker stop <containerID>**
    to stop a container. Follow this up with **$ docker rm -f <containerID>** to remove
    a container. Similarly, to remove a Docker image, use the **$ docker image rm
    <image>** command. You can also use (with caution) the **$ docker system prune
    --all** command to remove all images and containers on your system.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Publishing a Docker image* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Deploying to Kubernetes* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing a Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Hub provides a global repository of images. Throughout this chapter and
    [*Chapter 7*](B19212_07.xhtml#_idTextAnchor212) , we’ve pulled Docker images that
    were stored in the Docker Hub repository. This includes the Docker Official Node.js
    image, which we used as a basis for our image in the *Building a Docker container*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to publish our **fastify-microservice** image to
    Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will use the image created in the previous recipe, *Building a*
    *Docker container* .
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t completed that recipe, the code is available in the Packt GitHub
    repository ( [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    ) in the **Chapter11/fastify-microservice** directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’re going to sign up for a Docker Hub account and publish
    our **fastify-microservice** image to Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a Docker Hub account. Visit [https://hub.docker.com/signup](https://hub.docker.com/signup)
    to create an account. You will need to enter your details and click **Sign up**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you’ve created your Docker Hub account, you need to authenticate your
    Docker client. Do this by entering the following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have authenticated our Docker client, we then need to retag our image
    for it to be pushed to Docker Hub. Tag the image with the following command, substituting
    **<namespace>** with your Docker Hub ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to push the newly tagged image using the **docker** **push** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now navigate to **https://hub.docker.com/repository/docker/<namespace>/fastify-microservice**
    to verify that your image has been published to Docker Hub. Again, you’ll need
    to substitute **<namespace>** with your Docker Hub ID. Expect to see output similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Docker Hub view of the published fastify-microservice image](img/Figure_11.12_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Docker Hub view of the published fastify-microservice image
  prefs: []
  type: TYPE_NORMAL
- en: If you click on **Tags** , you should see that our Docker image has one tag
    named **latest** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is also now possible to pull the image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve pushed a Docker image containing our **fastify-microservice** image to
    Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first tagged the **fastify-microservice** image with the **<namespace>/fastify-microservice**
    tag. This tag format instructs Docker that this image is associated with a repository
    on Docker Hub. Once we’ve appropriately tagged our image, we use the **docker
    push** command to publish the image to Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: By default, our Docker Hub image will be publicly accessible. Production microservices
    are not typically expected to be published publicly to Docker Hub to avoid exposing
    any proprietary code or secrets. Docker Hub does provide private image functionality,
    but users are limited to one private registry on Docker Hub’s free account plan.
    It is possible to sign up for a paid account plan with Docker Hub, which provides
    unlimited private repositories.
  prefs: []
  type: TYPE_NORMAL
- en: When deploying images for use in production-grade systems, it is common to create
    a private Docker registry. Docker exposes a registry image ( [https://hub.docker.com/_/registry](https://hub.docker.com/_/registry)
    ) that can be used to provision a private registry. For more information on setting
    up a private registry, refer to [https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The **<IP>:<PORT>/<IMAGE>** format is used when referring to images stored in
    private registries, where the IP is the address of the private registry. Many
    of the leading cloud providers also provide commercial container registry solutions,
    which can be used to avoid the overhead of managing a container registry.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we did not specify a version tag for our Docker image. Therefore,
    Docker defaulted to creating the **latest** version tag for our image. The **latest**
    tag is automatically updated each time we rebuild our image without explicitly
    specifying a version tag.
  prefs: []
  type: TYPE_NORMAL
- en: It is generally considered good practice to version Docker Hub images similar
    to how you’d version an application. Versioning Docker Hub images provides a history
    of images, which makes it possible to roll back to earlier image versions should
    something go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can tag our **fastify-microservice** image with the following command, substituting
    the namespace for our Docker Hub username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The **1.0.0** version is specified in the preceding command to match the version
    declared in our **package.json** file. This is just one of many approaches we
    can take to versioning as there is no formal standard for how Docker images should
    be versioned. Other options include an incremental versioning scheme or even using
    the Git commit SHA of the application code as the version tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'We push the image to Docker Hub with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If we navigate to the **Tags** panel for our **fastify-microservice** image
    on Docker Hub, we should be able to see that our newly pushed image version is
    available.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Building a Docker container* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Deploying to Kubernetes* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is an open source container orchestration and management system originally
    developed by Google. Today, the Kubernetes project is maintained by the Cloud
    Native Computing Foundation ( [https://www.cncf.io/](https://www.cncf.io/) ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes is a comprehensive and complex tool that provides the following
    features, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery and load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage orchestration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated rollouts and rollbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic bin packing, specifying how much CPU and memory each container needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-healing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret and configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An oversimplified description of Kubernetes is that it is a tool used to manage
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will serve as an introduction to Kubernetes, demonstrating how we
    can deploy a microservice, packaged into a Docker container, to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should have Node.js 22 installed, and access to both an editor and browser
    of your choice. This recipe also relies on the **fastify-microservice** image
    that we created in the *Building a Docker container* recipe in this chapter. If
    you haven’t completed that recipe, you can download the code from the Packt GitHub
    repository ( [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    ) in the **Chapter11/fastify-microservice** directory.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, you will additionally need to have both Docker and Kubernetes
    installed. It’s possible to install and enable Kubernetes via Docker for Desktop.
    It is recommended to install Docker for Desktop from [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This recipe has been written based on using Docker for Desktop, which handles
    the setup of Kubernetes and installation of the **kubectl** CLI. However, Docker
    for Desktop is only available on macOS and Windows OSs. On Linux, an alternative
    is to use **minikube** , which is a tool that runs a Kubernetes cluster in a virtual
    machine on your local device. Minikube has a more complicated setup compared to
    Docker for Desktop. First, you’ll need to manually install the **kubectl** CLI
    ( [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    ), and then follow the installation instructions for Minikube at [https://kubernetes.io/docs/tasks/tools/install-minikube](https://kubernetes.io/docs/tasks/tools/install-minikube)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Kubernetes in Docker for Desktop, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Docker** icon in your menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the **Preferences/Settings** | **Kubernetes** tab (as shown in
    the following screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.13 – The Docker for Desktop Kubernetes tab](img/Figure_11.13_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – The Docker for Desktop Kubernetes tab
  prefs: []
  type: TYPE_NORMAL
- en: Check the **Enable** **Kubernetes** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply &** **restart** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will take a short while for Kubernetes to install. The installation process
    will instantiate all of the images that are required to run a Kubernetes cluster
    on your laptop. The **kubectl** CLI will also be installed at **/usr/local/bin/kubectl**
    . We will be using the **kubectl** CLI to interact with our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already use Kubernetes, ensure that you are configured to use the **docker-desktop**
    context. To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Docker icon in your menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Kubernetes** and select the **docker-desktop** context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new terminal window and verify that both Docker and the **kubectl**
    CLI are present by entering the following commands. Expect to see output similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Should any issues arise, refer to the official Docker for Desktop installation
    and the *Getting Started* guides at [https://docs.docker.com/desktop/#get-started](https://docs.docker.com/desktop/#get-started)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Docker and Kubernetes installed and started, we can move to
    our recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’re going to deploy our **fastify-microservice** image to
    Kubernetes. We’ll be using the **kubectl** CLI to interact with our Kubernetes
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s test out some **kubectl** commands. Enter the following commands
    to list the Kubernetes nodes and services present on our cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can proceed to deploy our **fastify-microservice** image. Let’s start
    by ensuring we have our Docker image built. To do so, run the following command
    within the **fastify-microservice** directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create our deployment files. The deployment files will be a set
    of YAML files that are used to configure Kubernetes. We’ll create a subdirectory
    named **deployment** to hold the deployment files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re going to create a Kubernetes deployment. We can configure a Kubernetes
    deployment with a YAML file. To create a deployment YAML file, add the following
    to **deployment/fastify-app.yml** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create the Kubernetes deployment, we need to apply our YAML file that describes
    the deployment. We can confirm that the deployment has been created by asking
    our Kubernetes cluster to list its deployments. Do this by entering the following
    two commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our YAML file, we instructed Kubernetes to create three replicas. This means
    three Kubernetes pods will be created. A Kubernetes pod is a group of one or more
    containers that are deployed together on the same host and share the same network
    namespace and storage volumes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can confirm that these have been created by listing all of the pods in our
    Kubernetes cluster by means of the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s move on to how we can expose the instances of our **fastify-microservice**
    image running in the pods. We do this by creating a Kubernetes Service. Add the
    following to **fastify-app-svc.yml** to create the Kubernetes Service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create the Kubernetes Service defined in the previous step, we need to apply
    the Service YAML file with the following commands. We can confirm that the Kubernetes
    Service was created by supplying the **kubectl get service** command. Enter the
    following in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created a Kubernetes Service, we should be able to access
    the application in our browser. You will need to access the application via the
    external port, which is the port number detailed in the output of the previous
    step. In the preceding example, the application is located at **https://localhost:31815/example**
    , but you will need to substitute the port, as it is randomly assigned by Kubernetes.
    The external port, by default, will be in the range of **30000** to **32767**
    as this is the default range assigned to **NodePort services** by Kubernetes.
    Expect to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Browser showing the this is an example string](img/Figure_11.14_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Browser showing the this is an example string
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now pushed our containerized **fastify-microservice** image to our local
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we deployed our **fastify-microservice** image to the local Kubernetes
    cluster running under Docker for Desktop. Many of the leading cloud providers
    have commercial Kubernetes offerings that can be used should you not wish to manage
    a Kubernetes cluster. These commercial offerings extend the Kubernetes open source
    project, meaning the underlying Kubernetes technology remains consistent across
    cloud providers. Most of the providers offer CLIs to interact with their Kubernetes
    offering; however, the APIs provided by these CLIs tend to just be wrappers or
    shortcuts for **kubectl** commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a selection of the commercial Kubernetes Services available
    from leading cloud providers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazon Elastic Kubernetes Service: [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Kubernetes Service: [https://azure.microsoft.com/en-gb/services/kubernetes-service/](https://azure.microsoft.com/en-gb/services/kubernetes-service/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google Kubernetes Engine: [https://cloud.google.com/kubernetes-engine](https://cloud.google.com/kubernetes-engine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IBM Cloud Kubernetes Service: [https://www.ibm.com/products/kubernetes-service](https://www.ibm.com/products/kubernetes-service)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipe relied on our **fastify-microservice** image being built and available
    on the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declared a Kubernetes deployment in the **deployment/fastify-app.yml** file.
    A Kubernetes deployment is a resource object in Kubernetes. A Kubernetes deployment
    allows you to define the life cycle of your application. The life cycle definition
    includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The image to use for the deployment is included. In the recipe, the deployment
    YAML referenced the local **fastify-microservice** image that we created in the
    *Building a Docker container* recipe of this chapter. Note that we could have
    supplied an external image, such as one from Docker Hub, or referenced an image
    in a private registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of replicas or pods that should be available are included.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the replicas or pods should be updated is detailed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **deployment/fastify-app.yml** , we declared that there should be three replicas,
    and therefore three pods were created by Kubernetes. We set three replicas so
    that if one pod crashes, then the other two pods can handle the load. The number
    of replicas required will depend on the typical load of a given application. Having
    multiple instances available is part of what provides Kubernetes’ “high-availability”
    behaviors; having other pods available that can handle the load in the case where
    one pod crashes can reduce downtime. If we were to manually kill a pod with **docker
    delete pod <podname>** , Kubernetes would automatically try to restart and spin
    up a new pod in its place. This demonstrates Kubernetes’ “ auto-restart” behavior.
  prefs: []
  type: TYPE_NORMAL
- en: To access our application, we needed to define a Kubernetes Service. This Service
    is used to expose an application running on a set of pods. In the case of the
    recipe, we created a Kubernetes Service to expose **fastify-microservice** , which
    was running in three pods. Kubernetes creates a single DNS name for a group of
    Kubernetes pods, enabling load balancing between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe has only touched upon Kubernetes in the context of deploying a
    simple Node.js microservice. A full introduction to Kubernetes is beyond the scope
    of this book. For more detailed information on Kubernetes, you can refer to the
    following guides:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes overview: [https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes setup guide: [https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes is focused on enabling the high availability of applications to minimize
    downtime. When deploying an updated version of your microservice, Kubernetes will
    conduct a rolling update. Rolling updates aim for zero downtime by incrementally
    updating individual pod instances with the new version of the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate Kubernetes rolling updates by updating our microservice
    and instructing Kubernetes to deploy the updated version of the microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by making a small change to **fastify-microservice** . Open **routes/example/index.js**
    and change the response that is returned on line 5 to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to rebuild our container for our microservice. We’ll tag this image
    with version **2.0.0** . Enter the following command to rebuild and tag the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to update our Kubernetes deployment. Open **deployment/fastify-app.yml**
    and change the image to reference our new image tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to reapply our Kubernetes deployment configuration with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following to obtain the **NodePort** for our Kubernetes Service.
    We need this port to access the application from our browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to **http://localhost:<NodePort>/example** , where **NodePort** is
    the port output from the previous command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **this is an updated example** string should be returned in your browser,
    indicating that the rolling update has taken place.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve completed this recipe, including the *There’s more…* section, you
    should delete the Kubernetes resources you have created to avoid an unnecessary
    load on your system. To delete the deployment, use the **$ kubectl delete deployment
    fastify-app** command. Similarly, to delete the Kubernetes Service, use the **$
    kubectl delete service** **fastify-app-svc** command.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Building a Docker container* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Publishing a Docker image* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
