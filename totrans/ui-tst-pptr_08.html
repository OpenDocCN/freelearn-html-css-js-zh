<html><head></head><body>
		<div id="_idContainer116">
			<h1 id="_idParaDest-125"><em class="italic"><a id="_idTextAnchor137"/>Chapter 8</em>: Environments emulation</h1>
			<p>I had the good luck of using the internet before it became popular. I was a teenager when <em class="italic">Windows 95 Plus</em> was launched to the market. Most people might remember <em class="italic">Windows 95 Plus</em> because it came with some cool themes and even the <em class="italic">Space Cadet Pinball</em> game. But this version of Windows brought a new software application whose name is still around these days, with haters and lovers. <em class="italic">Windows 95 Plus</em> came with <em class="italic">Internet Explorer 1.0 (IE 1.0)</em>.</p>
			<p>My first internet connection was a free phone number that a local newspaper shared with its readers. I was able to convince my dad to get me a modem. The speed was 36.6 kbps. Today my speed test goes to 150 Mbps download and 30 Mbps upload, over 4,000 times faster than the speed I got as a teen.</p>
			<p>I don't remember very well the specs of my computer. But I do remember using a 15'' 800x600 monitor, and then upgrading to a 17'' 1,024x768. LED? No way! What's that? There were some bulky, eye-burning CRT monitors.</p>
			<p>SEO? Google? Nobody knew those words back then. I remember that my favorite search engine was <em class="italic">AltaVista</em>.</p>
			<p>Why am I telling you all this? Because back then, the internet experience was consistent. It was slow, very slow, ugly, very ugly, and limited, very limited. But it was the same for everybody. If you were a developer back then, you knew that you had to develop a website for IE 1.0 to be displayed on an 800x600 screen and that your page would take over a minute to download. But you wouldn't have thought about all that. You would be happy creating your page with <em class="italic">Microsoft FrontPage</em>, pushing that to some server, and letting the world know about your site.</p>
			<p>But now things are different. The ecosystem is more diverse than ever, and we need to be prepared to test all the different scenarios that we could come across. At the end of the day, it is our job to honor all our customers and try to understand their environments.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Understanding the browser's market share</li>
				<li>Emulating mobile devices</li>
				<li>Emulating network conditions</li>
				<li>Emulating localization</li>
				<li>Other emulations</li>
			</ul>
			<p>By the end of this chapter, you will be able to get into your users' shoes and emulate how they experience your sites.</p>
			<p>Let's get started.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor138"/>Technical requirements</h1>
			<p>You will find all the code of this chapter on the GitHub repository (<a href="https://github.com/PacktPublishing/UI-Testing-with-Puppeteer">https://github.com/PacktPublishing/UI-Testing-with-Puppeteer</a>) under the <strong class="source-inline">Chapter8</strong> directory. Remember to run <strong class="source-inline">npm install</strong> on that directory, and then go to the <strong class="source-inline">Chapter8/vuejs-firebase-shopping-cart</strong> directory and run <strong class="source-inline">npm install</strong> again.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor139"/>Understanding the browser's market share</h1>
			<p>Before getting into all the emulation features Puppeteer provides, I would like to discuss how the browser's market share <a id="_idIndexMarker388"/>looks these days. I believe that will give you a clear picture of the importance of testing and emulating different scenarios.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor140"/>The browser's popularity over the years</h2>
			<p>We have lived through lots of changes over the past 25 years. Browsers have been dramatically <a id="_idIndexMarker389"/>adopted and discarded. Let's take a look at this table made by Nick Routley in his post <em class="italic">Internet Browser Market Share (1996â€“2019)</em> (<a href="https://www.visualcapitalist.com/internet-browser-market-share/">https://www.visualcapitalist.com/internet-browser-market-share/</a>): </p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/Table_8.1.jpg" alt=""/>
				</div>
			</div>
			<p>Although I used <em class="italic">Netscape Navigator</em>, I wasn't there at its peak back in 1995. But I remember the days when the only browser that mattered was <em class="italic">Internet Explorer</em>.</p>
			<p>The community was living through <a id="_idIndexMarker390"/>browser fatigue back in 2008, when <em class="italic">Google Chrome</em> was launched, causing a massive number of users to move to <em class="italic">Google Chrome</em> and <em class="italic">Firefox</em>, which had a peak in 2010.</p>
			<p>If you didn't play the video on Nick's post, don't miss that. I took a screenshot from the moment that the video gets to 2013 Q1:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/Figure_8.01_B16113.jpg" alt="Market share in 2013&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Market share in 2013</p>
			<p>That was a challenging year for <a id="_idIndexMarker391"/>developers. You had four different browser engines behaving differently, processing CSS styles differently, having different JavaScript features. It was a mess. But I think that was a healthy web, with no clear market owner.</p>
			<h3>Browsers' popularity in 2020</h3>
			<p>According to <em class="italic">StatCounter</em> (<a href="https://gs.statcounter.com/">https://gs.statcounter.com/</a>), the picture is very different these days:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/Figure_8.02_B16113.jpg" alt="Browser market share in December 2020 according to StatCounter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Browser market share in December 2020 according to StatCounter</p>
			<p>Many people call <em class="italic">Google Chrome</em> the <strong class="bold">new</strong> Internet Explorer. The Chrome predominance gets even more <a id="_idIndexMarker392"/>important when you consider that <em class="italic">Edge</em> and <em class="italic">Opera</em> use the Chromium engine. When a browser gets to these levels of market share, it is good for developers, but it's not good for the web. </p>
			<p>What if we take a look at operative systems?</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor141"/>Operative Systems market share</h2>
			<p>Operative systems play <a id="_idIndexMarker393"/>an essential part in how browsers work. They are responsible for providing the fonts and interacting with the hardware, among other things. Most browsers are cross-platform, but although they try to give the same experience <a id="_idIndexMarker394"/>across operative systems, they don't always work in the same way. That's why it's so important to know how the operative system market share looks:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/Figure_8.03_B16113.jpg" alt="Operative system market share in December 2020 according to StatCounter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Operative system market share in December 2020 according to StatCounter</p>
			<p>I honestly found this surprising. Almost 55% of internet <a id="_idIndexMarker395"/>consumption is on mobile, and over 39% is on Android. These values should make us re-think how we <a id="_idIndexMarker396"/>develop and test our sites.</p>
			<p>The last thing we can take a look at is screen resolutions.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor142"/>Screen resolution distribution</h2>
			<p>Screen resolution is <a id="_idIndexMarker397"/>another important piece when we try to understand the whole web ecosystem. In <a href="B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Navigating through a website</em>, we talked about how developers can change a page layout based on the screen resolution. Let's see how the screen resolution is distributed according to <strong class="bold">StatCounter</strong>:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/Figure_8.04_B16113.jpg" alt="Screen resolution market share in December 2020 according to StatCounter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Screen resolution market share in December 2020 according to StatCounter</p>
			<p>The distribution of <a id="_idIndexMarker398"/>screen resolutions is crazy. There is not only a wide variety of resolutions, but we also have "<strong class="bold">Other</strong>" with 41%. We are far from that 800x600 standard.</p>
			<p>The message I want to leave you with is that the internet ecosystem is more diverse than ever. The world where everything was just IE, 800x600, over a dial-up connection is long gone. Although there is one predominant browser, we have many possible scenarios, mobile devices, and screen resolutions, and we haven't talked about network speeds. We have Wi-Fi, 4G, 3G, or GPRS.</p>
			<p>We sometimes make the error of thinking that all users have a crazy-fast internet and 27'' 4K displays, and we are unable to understand why they feel frustrated with our site.</p>
			<p>Do you know your users? Do you know whether they use your site on the street on their phones? Do you want your site to be used worldwide? Do you know that there are countries where they write right to left or where they don't have 4G coverage?</p>
			<p>It's time to get into mobile users' shoes. Let's see how we can emulate mobile devices.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor143"/>Emulating mobile devices</h1>
			<p>The first type of emulation I want to cover is mobile emulation. In this section, we will cover the three elements that <a id="_idIndexMarker399"/>Puppeteer can emulate: The viewport, the touchscreen, and the user agent. We have to keep in mind that it is a browser trying to <strong class="bold">emulate</strong> a mobile device. Puppeteer and Chromium won't be able to emulate any hardware limitations or any other specific features that certain mobile phones offer. There is no real device behind the curtains; it's just a browser trying to show you how a website would look on that device's screen.</p>
			<p>As I mentioned previously, <strong class="bold">55% of the internet traffic comes from mobile devices</strong>. Most of the diversity we saw in the previous section is in the mobile world.</p>
			<p>Let's take a look at some of the browser distribution in the mobile world:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/Figure_8.05_B16113.jpg" alt="Browser market share in mobile devices according to StatCounter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Browser market share in mobile devices according to StatCounter</p>
			<p>The mobile market is mostly divided between <em class="italic">Chrome</em> and <em class="italic">Safari</em>. One thing you should know is that in <em class="italic">iOS</em>, the only available browser engine is <em class="italic">WebKit</em>/<em class="italic">Safari</em>. You have browsers such as <em class="italic">Chrome</em>, <em class="italic">Edge</em>, or <em class="italic">Firefox</em> available in <em class="italic">iOS</em>, but they cannot ship their own browser engine. They have to use <em class="italic">WebKit</em>. The only thing they can provide are features over that engine. The main feature you will see in those browsers is the synchronization between the desktop and the mobile browser.</p>
			<p>Let's take a look at screen resolutions on mobile devices:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/Figure_8.06_B16113.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Screen resolutions on mobile devices according to StatCounter</p>
			<p>You need 10 screen resolutions to <a id="_idIndexMarker400"/>reach 50% of the market share, compared with only three resolutions on desktop, 1,920x1,080, 1,366x768, and 1,536x864. The screen resolutions in the mobile world are highly diverse. Another thing that should call your attention in that chart is the resolutions that are pretty low. Who buys a phone with a 360x640 resolution? No one. We will find out in the next section who those 360x480 users really are.</p>
			<p>So, it's time to talk about the elements <a id="_idIndexMarker401"/>that Puppeteer considers to emulate a mobile device.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor144"/>The Viewport</h2>
			<p>We've talked a lot about the <a id="_idIndexMarker402"/>viewport in this book. It's time to give a clear definition of the viewport.</p>
			<p>I like to explain the viewport by explaining what it's not. The viewport is not the screen resolution. It's not the <a id="_idIndexMarker403"/>size of the browser's window. And lastly, it's not the size of the page. The viewport is the rectangular portion of the screen the <a id="_idIndexMarker404"/>browser uses to render a page. From the user's point of view, the viewport is the part of the page you can see:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/Figure_8.07_B16113.jpg" alt="The viewport&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">The viewport</p>
			<p>I love the preceding visualization, not because I made it, but because it clearly shows the difference between the viewport and the screen size. The page can be huge. It can be way longer than what you can see. Even more, if you are a social media user, you would also know that pages can have an "infinite" height because sites such as <em class="italic">Facebook</em> and <em class="italic">Twitter</em> load new <a id="_idIndexMarker405"/>content when you are close to reaching the end of the page. Although it's not as common, a page could also be wider than the <a id="_idIndexMarker406"/>viewport. There was a wave of horizontal-scrolling pages when <em class="italic">Windows 8</em> was launched. The Microsoft <em class="italic">Azure</em> portal still shows its content using a horizontal layout.</p>
			<p>The second element to take into consideration when you try to emulate a device screen is the pixel ratio.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor145"/>Pixel ratio</h2>
			<p>What if I told you that the Samsung Galaxy S20, with a <a id="_idIndexMarker407"/>screen resolution of 1,440x3,200, has a viewport of 360x800? </p>
			<p>No, that's not a typo, nor an error. That's the <a id="_idIndexMarker408"/>browser's viewport on that beautiful mobile phone. How's that possible? Let's see how a web page would be displayed on a Samsung S20 without a pixel ratio set:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/Figure_8.08_B16113.jpg" alt="Galaxy S20 without a pixel ratio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Galaxy S20 without a pixel ratio</p>
			<p>Imagine if the browser <a id="_idIndexMarker409"/>honored the real resolution of the screen. That would be <a id="_idIndexMarker410"/>impossible to read, so you need to scale the resolution. You need to tell the browser to use a ratio to zoom the page and make it more usable. In the case of the Samsung Galaxy S20, the pixel ratio is 4, taking the viewport to 360x800, which is simple math (1,440/4) x (3,200/4). If we navigate the page using a pixel ratio of 4, we will see something like this:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/Figure_8.09_B16113.jpg" alt="Galaxy S20 with the right pixel ratio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Galaxy S20 with the right pixel ratio</p>
			<p>Now we have an S20 with a huge resolution, but <a id="_idIndexMarker411"/>pages are rendered in a way <a id="_idIndexMarker412"/>that we can read them. </p>
			<p>If you're wondering how I've been emulating different devices, it's tool time! </p>
			<p>If you open the developer tools (I hope that by now I don't have to tell you how to do that), you will find that there is a <a id="_idIndexMarker413"/>button called <strong class="bold">Toggle device emulation</strong>:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/Figure_8.10_B16113.jpg" alt="Toggle device emulation option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Toggle device emulation option</p>
			<p>If you click on that button, you will activate the device emulation mode. From there, you will be able to pick any <a id="_idIndexMarker414"/>device to emulate, or create new ones. You will also be able to change the zoom. Notice that this <a id="_idIndexMarker415"/>zoom won't affect the viewport; it's just to zoom the emulator. Finally, you will have the option to emulate different network speeds. We will talk about that in the <em class="italic">Emulating network conditions</em> section.</p>
			<p>The next element that Puppeteer takes into consideration is the touchscreen.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor146"/>The touchscreen</h2>
			<p>If the device has a touchscreen, the browser <a id="_idIndexMarker416"/>will give developers an extra set of tools, <strong class="bold">touch events</strong> (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/touchevents">https://www.hardkoded.com/ui-testing-with-puppeteer/touchevents</a>). Single taps <a id="_idIndexMarker417"/>will be processed as click events. But the browser offers the chance of processing multi-touch interactions. Let's see how Chromium shows the <a id="_idIndexMarker418"/>touchscreen emulation:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/Figure_8.11_B16113.jpg" alt="Touch emulation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Touch emulation</p>
			<p>If you use the device emulation, you will <a id="_idIndexMarker419"/>see that Chromium will emulate taps with a black circle.</p>
			<p>That takes us to the last thing that Puppeteer uses to emulate devices: the user agent.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor147"/>The user agent</h2>
			<p>The user agent is one of <a id="_idIndexMarker420"/>those terrible decisions <a id="_idIndexMarker421"/>made on the web that are hard to eradicate. The user agent is a string (text) sent to the server on every request that identifies the browser/application, the operative system, the vendor, and its version.</p>
			<p>According to MDN (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent">https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent</a>), the format should be something like this:</p>
			<p class="source-code">User-Agent: &lt;product&gt; / &lt;product-version&gt; &lt;comment&gt;</p>
			<p>If you open DevTools in Chrome and type <strong class="source-inline">navigator.userAgent</strong>, you will get something like this:</p>
			<p class="source-code">"Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36"</p>
			<p>The only clear thing here is that I'm on a Mac, using an Intel processor, and the operating system version is <strong class="source-inline">11_0_1</strong>. It's also true that I'm on <strong class="source-inline">Chrome/87.0.4280.88</strong>. The rest are patches <a id="_idIndexMarker422"/>after patches, so the user doesn't get a "Your browser is not compatible" message. So, if the server checks for Mozilla, the user agent will match, but it's not Mozilla. Could you tell me what <em class="italic">KHTML, like Gecko</em> is? As you can see, the user agent system is broken.</p>
			<p>Many developers would use the <a id="_idIndexMarker423"/>user agent to determine which device is on the other side. Let's take, for instance, the user agent on an iPad:</p>
			<p class="source-code">Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1</p>
			<p>If a developer wants to check whether the user is on an iPad, they can check whether the user agent contains the word <strong class="bold">iPad</strong>. But what if they want to check whether the user is using Safari? If they look for the word <strong class="bold">Safari</strong>, it will work on iPad, but, if you look at Chrome's user agent, it also has the word Safari, so we would think that Chromium is Safari. User agents are a mess.</p>
			<p>If Puppeteer wants to emulate devices correctly, it needs to change the User-Agent in two places. First, it needs to change the User-Agent request header (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent">https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent</a>) sent to the server. And second, as developers can also access the User-Agent from their JavaScript code using the <strong class="source-inline">navigator.userAgent</strong> property, the browser needs to change the value of that property as well. With these changes, both the server and the client will get a User-Agent that a real device would send.</p>
			<p>Now it's time to see how we apply all this in our Puppeteer code.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor148"/>Emulating mobile devices with Puppeteer</h2>
			<p>You toggle the emulation mode by calling <strong class="source-inline">page.emulate(options)</strong>. I honestly think that the name <strong class="source-inline">options</strong> is wrong there. Compared with the other options we have seen in this book, this <strong class="source-inline">options</strong> argument is mandatory. The object will contain all the required <a id="_idIndexMarker424"/>data Puppeteer needs to emulate a device:</p>
			<ul>
				<li><strong class="source-inline">viewport</strong> is the first property, and it includes the definition of the viewport and a little bit more:<p>a) <strong class="source-inline">width</strong>, representing the viewport width.</p><p>b) <strong class="source-inline">height</strong>, representing the viewport height.</p><p>c) <strong class="source-inline">deviceScaleFactor</strong>, which is the pixel ratio we talked about before.</p><p>d) <strong class="source-inline">isMobile</strong> is a Boolean property that will make the browser consider the meta viewport tag. You can read more about this on the MDN site (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/viewportMetaTag">https://www.hardkoded.com/ui-testing-with-puppeteer/viewportMetaTag</a>).</p><p>e) <strong class="source-inline">hasTouch</strong> is a Boolean that will enable touch support.</p><p>f) <strong class="source-inline">isLandscape</strong> is a Boolean that will emulate a device in landscape mode.</p></li>
				<li>The <strong class="source-inline">userAgent</strong> property will allow us to change the user agent on the request header and JavaScript, as we saw in the previous section.</li>
			</ul>
			<p>I have some good news and some bad news for you. Good news first. The <strong class="source-inline">puppeteer</strong> class has a property called <strong class="source-inline">devices</strong>. It's a dictionary containing over 70 devices. We could do something like this in our code:</p>
			<p class="source-code">const iPhone = puppeteer.devices['iPhone 6'];</p>
			<p class="source-code">await page.emulate(iPhone);</p>
			<p>That's the good news. The bad news is that you have to go to the source code for you to know the available list of devices: <a href="https://www.hardkoded.com/ui-testing-with-puppeteer/DeviceDescriptors">https://www.hardkoded.com/ui-testing-with-puppeteer/DeviceDescriptors</a>. That's not ideal. The other option would be grabbing any Puppeteer code you have and printing the keys of the <strong class="source-inline">devices</strong> object:</p>
			<p class="source-code">console.log(Object.keys(puppeteer.devices));</p>
			<p>If you do that, you will get <a id="_idIndexMarker425"/>all the devices included in Puppeteer. The other bad news is that the list of devices is not as up to date as you might expect. But I think it makes sense. First, because we get new devices every month, and keeping that list updated would be a tough job. And second, the website you want to automate shouldn't need to be tested on every single device. I think you should be able to have good test coverage using the provided devices. </p>
			<p>If you do need to test a specific device, you could browse the spec on the web and manually pass a device setting. <em class="italic">yesviz.com</em> (https://yesviz.com/devices.php) has a nice list of devices' viewports. You can find a list of user agents at <em class="italic">DeviceAtlas</em> (https://deviceatlas.com/blog/list-of-user-agent-strings).</p>
			<p>If we want to emulate an iPhone 12 device, which is not on the devices list, we can do something like this:</p>
			<p class="source-code">await page.emulate({</p>
			<p class="source-code">Â Â Â Â userAgent:</p>
			<p class="source-code">Â Â Â Â Â Â Â Â 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',</p>
			<p class="source-code">Â Â Â Â viewport: {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â width: 360,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â height: 780,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â deviceScaleFactor: 3,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â isMobile: true,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â hasTouch: true,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â isLandscape: false,</p>
			<p class="source-code">Â Â Â Â },</p>
			<p class="source-code">});</p>
			<p>At the time of writing this book, I wasn't able to find the user agent sent by an iPhone 12, so I'm using the <a id="_idIndexMarker426"/>one from the iPhone XR. But if you are using this as a test tool, it would be a matter of asking your development team which values they are checking so you can then test the different user agents used by the team.</p>
			<p>That takes us on to the next questions. How do we apply all these new concepts? How should we test mobile emulation?</p>
			<h3>Testing mobile UX</h3>
			<p>First, you need to check for <strong class="bold">behavior changes</strong>. Good developers make a great effort to give the best experience based on the device they infer <a id="_idIndexMarker427"/>you are using. Let's see how the <a href="http://www.packtpub.com">www.packtpub.com</a> website looks on mobile:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/Figure_8.12_B16113.jpg" alt="The packtpub site on an iPhone X&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">The packtpub site on an iPhone X</p>
			<p>As we can see, the experience changes completely. The top menu is changed to a hamburger menu, and now you need to click on the magnifying glass to search for a book.</p>
			<p>If you care about UI regressions, you will need to identify the different <strong class="bold">layout changes</strong>. Grids could become lists, and sections might be removed entirely to simplify the UI, fit the content on the screen, and make the user experience much nicer. </p>
			<p>You might be thinking, "OK, but how do I test all that? Which devices should I test, all of them?". In order to know which devices to test, we need to know a little bit about <strong class="bold">breakpoints</strong>. No, not debugging breakings, <strong class="bold">media query breakpoints</strong>. Media query breakpoints are points that a <a id="_idIndexMarker428"/>developer can use to apply a different set of CSS styles based on the viewport width or height.</p>
			<p>Do you remember how when we <a id="_idIndexMarker429"/>talked about generating PDF files, we mentioned that developers could use <strong class="source-inline">@media print</strong> to determine the style used to print a page? Well, <strong class="source-inline">@media print</strong> is not the only option we have there. We can also do stuff such as this:</p>
			<p class="source-code">/* Extra small devices (phones, 600px and down) */</p>
			<p class="source-code">@media only screen and (max-width: 600px) {...}</p>
			<p class="source-code">/* Small devices (portrait tablets and large phones, 600px and up) */</p>
			<p class="source-code">@media only screen and (min-width: 600px) {...}</p>
			<p class="source-code">/* Medium devices (landscape tablets, 768px and up) */</p>
			<p class="source-code">@media only screen and (min-width: 768px) {...}</p>
			<p class="source-code">/* Large devices (laptops/desktops, 992px and up) */</p>
			<p class="source-code">@media only screen and (min-width: 992px) {...}</p>
			<p class="source-code">/* Extra large devices (large laptops and desktops, 1200px and up) */</p>
			<p class="source-code">@media only screen and (min-width: 1200px) {...}</p>
			<p>This example is taken from the <em class="italic">w3schools</em> site (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/breakpoints">https://www.hardkoded.com/ui-testing-with-puppeteer/breakpoints</a>). We can see that developers can set specific styles depending on the width of the viewport. Functionally speaking, these days, we talk about five types of device categories:</p>
			<ul>
				<li>Mobile phones in portrait (up to 600 px)</li>
				<li>Tablets in portrait (up to 900 px)</li>
				<li>Tablets in landscape (up to 1,200 px)</li>
				<li>Desktops (up to 1,800 px)</li>
				<li>Big desktops (bigger than 1,800 px)</li>
			</ul>
			<p>These numbers are relative, and you <a id="_idIndexMarker430"/>should team up with the development team and see which breakpoints they are using, and you should try to test edge scenarios using those breakpoints.</p>
			<p>So maybe once you have met with the development team, you find that, based on the breakpoints they use, you should test the following devices:</p>
			<ul>
				<li>iPhone 6</li>
				<li>iPad</li>
				<li>iPad Landscape</li>
				<li>A desktop with a viewport of 1,280x1,080</li>
			</ul>
			<p>We could improve our UI regression tests and test those devices:</p>
			<p class="source-code">it('Should visually match', async() =&gt; {</p>
			<p class="source-code">Â Â for(const device of ['iPhone 6', 'iPad', 'iPad landscape', ''])</p>
			<p class="source-code">Â Â {</p>
			<p class="source-code">Â Â Â Â const target = differencify.init({ chain: false, testName: 'Home ' + device });</p>
			<p class="source-code">Â Â Â Â await target.launch();</p>
			<p class="source-code">Â Â Â Â const page = await target.newPage();</p>
			<p class="source-code">Â Â Â Â if(device) {</p>
			<p class="source-code">Â Â Â Â Â Â await page.emulate(puppeteer.devices[device]);</p>
			<p class="source-code">Â Â Â Â } else {</p>
			<p class="source-code">Â Â Â Â Â Â await page.setViewport({ width: 1600, height: 1200 });</p>
			<p class="source-code">Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â await page.goto(config.baseURL);</p>
			<p class="source-code">Â Â Â Â const image = await page.screenshot();</p>
			<p class="source-code">Â Â Â Â const result = await target.toMatchSnapshot(image)</p>
			<p class="source-code">Â Â Â Â await page.close();</p>
			<p class="source-code">Â Â Â Â await target.close();</p>
			<p class="source-code">Â Â Â Â expect(result).to.be.true;</p>
			<p class="source-code">Â Â }</p>
			<p class="source-code">});</p>
			<p>Here, I grabbed the same code from the previous chapter, but I wrapped it in a <strong class="source-inline">for</strong> loop that will iterate through the <a id="_idIndexMarker431"/>four devices we picked. We will assume that an empty string will be the default. If we get a device in the loop, we call the <strong class="source-inline">emulate</strong> function. If not, we set the <strong class="bold">viewport</strong> we had before.</p>
			<p>Lastly, if you want to emulate user taps, you can replace calls to the <strong class="source-inline">click</strong> function with a call to the <strong class="source-inline">tap</strong> function. The <strong class="source-inline">tap</strong> function works just like the <strong class="source-inline">click</strong> function, but instead of using mouse emulation, it will use touchscreen emulation.</p>
			<p>Now we have UI regression tests for mobile devices.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Device emulation is not only for UI testing. Web developers can benefit from this feature to check how a page looks on different devices. In the same way that we coded this test, you can create a small script that can loop through many devices, navigate a page, and take screenshots. Then you can check whether something is broken or not.</p>
			<p>If you want to test a page's behavior on <a id="_idIndexMarker432"/>mobile devices, it won't be much different from the different Puppeteer tests we've been writing. You could create a new test file for mobile and add your tests there. You could create a <strong class="source-inline">homepage.iPhone.tests.js</strong>, and do something like this in the <strong class="source-inline">beforeEach</strong> function:</p>
			<p class="source-code">beforeEach(async () =&gt; {</p>
			<p class="source-code">Â Â Â Â page = await browser.newPage();</p>
			<p class="source-code">Â Â Â Â await page.emulate(puppeteer.devices['iPhone 6']);</p>
			<p class="source-code">Â Â Â Â page.setDefaultTimeout(config.timeout);</p>
			<p class="source-code">Â Â Â Â pageModel = new LoginPageModel(page, config);</p>
			<p class="source-code">Â Â Â Â await pageModel.go();</p>
			<p class="source-code">})</p>
			<p>The only thing new there is the call to the <strong class="source-inline">emulate</strong> function. From there, it is up to you to evaluate which tests you want to write for iPhone and which tests you don't. For instance, you might want to test layout changes, but tests such as prices or stock checks should be the same no matter the device.</p>
			<p>In this section, we learned how to emulate different viewports, user agents, and touch devices. But there is more. Let's move on to bandwidth emulation.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor149"/>Emulating network conditions</h1>
			<p>Networking is a <a id="_idIndexMarker433"/>challenging topic in computer science. If you tell a network engineer that Chromium emulates a 4G network, they will ask you to show them how it can emulate radio tower and weather conditions. Chromium does not pretend to emulate a network but a network condition. Chromium limits the scope to three variables that affect web development: Download speed, Upload speed, and Latency. That's it.</p>
			<p>Emulating network conditions is <a id="_idIndexMarker434"/>something that you can now do on Chromium. You can open the developer tools and go to the <strong class="bold">Network</strong> tab, and you will find a drop-down list called throttling with the <strong class="bold">Online</strong> option selected by default, as in the following screenshot:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/Figure_8.13_B16113.jpg" alt="Emulating network conditions on Chromium&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Emulating network conditions on Chromium</p>
			<p>If you click on that drop-down list, you will find three other options: <strong class="bold">Fast 3G</strong>, <strong class="bold">Slow 3G</strong>, and <strong class="bold">Offline</strong>. Another cool feature is that you will be able to add custom profiles. There you will be asked about three variables we mentioned before, download, upload, and latency, and additionally, to provide a name so you can identify your new profile.</p>
			<p>Emulating different network conditions is not something you want to add to every UI test. We want our tests to be as fast as possible. But it's a great tool to perform tests on demand. For instance, say one user of your e-commerce site reports that they're unable to finish the checkout process when they're using 4G. The company doesn't want to leave mobile users out, so they improve the site to work better on 4G. Now we have to write a test to ensure that <a id="_idIndexMarker435"/>the page will work on 4G.</p>
			<p>You can emulate different network conditions by calling <strong class="source-inline">page.networkConditions(networkConditions)</strong>, where <strong class="source-inline">networkConditions</strong> is an object with the following properties: </p>
			<ul>
				<li><strong class="source-inline">download</strong>: Download speed (bytes/sec). -1 disables download throttling.</li>
				<li><strong class="source-inline">upload</strong>: Upload speed (bytes/sec). -1 disables upload throttling.</li>
				<li><strong class="source-inline">latency</strong>: Minimum latency from the request sent to response headers received (ms).</li>
			</ul>
			<p>The <strong class="source-inline">puppeteer</strong> object has a property called <strong class="source-inline">networkConditions</strong> that provides two network settings: <strong class="source-inline">'Slow 3G'</strong> and <strong class="source-inline">'Fast 3G'</strong>. This is how you can use them according to the official documentation:  </p>
			<p class="source-code">const puppeteer = require('puppeteer');</p>
			<p class="source-code">const slow3G = puppeteer.networkConditions['Slow 3G'];</p>
			<p class="source-code">(async () =&gt; {</p>
			<p class="source-code">Â Â const browser = await puppeteer.launch();</p>
			<p class="source-code">Â Â const page = await browser.newPage();</p>
			<p class="source-code">Â Â await page.emulateNetworkConditions(slow3G);</p>
			<p class="source-code">Â Â // other actions...</p>
			<p class="source-code">Â Â await browser.close();</p>
			<p class="source-code">})();</p>
			<p>But we are not limited to the two options Puppeteer provides. We can create our own settings, or find examples on GitHub. For instance, The <em class="italic">porchmark</em> project (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark">https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark</a>) has a <a id="_idIndexMarker436"/>great list. The project is under the MIT license so we can use it freely.</p>
			<p>These are some values we can get from that project, and then use them in our own code to emulate different network conditions:</p>
			<p class="source-code">const NETWORK_PRESETS = {</p>
			<p class="source-code">Â Â Â Â GPRS: {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â download: 50 * 1024 / 8,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â upload: 20 * 1024 / 8,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â latency: 500,</p>
			<p class="source-code">Â Â Â Â },</p>
			<p class="source-code">Â Â Â Â Good3G: {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â download: 1.5 * 1024 * 1024 / 8,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â upload: 750 * 1024 / 8,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â latency: 40,</p>
			<p class="source-code">Â Â Â Â },</p>
			<p class="source-code">Â Â Â Â Regular4G: {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â download: 4 * 1024 * 1024 / 8,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â upload: 3 * 1024 * 1024 / 8,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â latency: 20,</p>
			<p class="source-code">Â Â Â Â }</p>
			<p class="source-code">};</p>
			<p class="source-code">export default NETWORK_PRESETS;</p>
			<p>There are more in that repository. You can <a id="_idIndexMarker437"/>see the full list here: <a href="https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark-presets">https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark-presets</a>. If you want to <a id="_idIndexMarker438"/>incorporate that file, you will need to rename the <strong class="source-inline">downloadThroughput</strong> property to <strong class="source-inline">download</strong> and <strong class="source-inline">uploadThroughput</strong> to <strong class="source-inline">upload</strong>, and remove the <strong class="source-inline">offline</strong> property. You will also find the <strong class="source-inline">networkPresets.js</strong> file in the project of this chapter with all the replacements already made.</p>
			<p>We could test our login on a "Good 3G" network with all this information. We can go to our <strong class="source-inline">login.tests.js</strong> file and add this test:</p>
			<p class="source-code">it('Should login on 3G', async() =&gt; {</p>
			<p class="source-code">Â Â await page.emulateNetworkConditions(NetworkPresets.Good3G);</p>
			<p class="source-code">Â Â await pageModel.login(config.username, config.password);</p>
			<p class="source-code">Â Â await page.waitForSelector('.thumbnail.card');</p>
			<p class="source-code">});</p>
			<p>This is the same test as <strong class="bold">Should login</strong>, but adding a call to the <strong class="source-inline">emulateNetworkConditions</strong> function. If we don't want to use a <strong class="source-inline">NetworkPresets</strong> file, we could hardcode our network condition. Let's see how we can call <strong class="source-inline">page.emulateNetworkConditions</strong> using our own settings:</p>
			<p class="source-code">it('Should login on 3G with custom settings', async() =&gt; {</p>
			<p class="source-code">Â Â Â Â await page.emulateNetworkConditions(</p>
			<p class="source-code">Â Â Â Â {</p>
			<p class="source-code">Â Â Â Â Â Â download: 750 * 1024 / 8,</p>
			<p class="source-code">Â Â Â Â Â Â upload: 250 * 1024 / 8,</p>
			<p class="source-code">Â Â Â Â Â Â latency: 100,</p>
			<p class="source-code">Â Â Â Â });</p>
			<p class="source-code">Â Â await pageModel.login(config.username, config.password);</p>
			<p class="source-code">Â Â await page.waitForSelector('.thumbnail.card');</p>
			<p class="source-code">});</p>
			<p>The end result will be <a id="_idIndexMarker439"/>the same. You can also have a fixed preset and add it to our existing <strong class="source-inline">config.js</strong> file.</p>
			<p>We already covered a lot of ground in this chapter. In this section, we learned how to emulate different network conditions. We also learned how to execute methods from the DevTools protocol that are not exposed in the Puppeteer API. Now it's time to learn about localization.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor150"/>Emulating localization</h1>
			<p>I love this topic. Maybe because English is not my mother tongue, so I have seen and felt the pain when a site fails to honor other cultures.</p>
			<p>There are many debates about what <a id="_idIndexMarker440"/>localization is, what internationalization is, and the difference between them. While I bet there will be debate over whether I should treat both as a whole or not, we will treat both as a whole.</p>
			<p>When we talk about localization, we're saying that a website should honor its audience:</p>
			<ul>
				<li>It should honor their language.</li>
				<li>It should honor their culture, such as how they read numbers, sort information, and read the content.</li>
				<li>It should honor their beliefs. For example, Green/Good Red/Bad might not apply in every culture.</li>
			</ul>
			<p>Localization is a feature.</p>
			<p>Ideally, every site on the web should consider localization. But localization can be quite a costly feature to implement. There is a high chance that your company is not Google or Amazon and you cannot afford to localize your site for every culture, so you need to know your audience.</p>
			<p>You might be thinking: "I'm just a QA analyst. Should I care about that?". Let me tell you this: You should be the number-one person in the company defending and honoring your customers' culture.</p>
			<p>Let me share a few real-life examples of having a clear scope of your audience.</p>
			<p>I have found many times that <a id="_idIndexMarker441"/>buying local train tickets in Europe can be hard. They are only in the local language, or the English version of the site is extremely poor. The scope is evident. This site is for local people. If you are a tourist, go to <em class="italic">Rail Europe</em>.</p>
			<p>One colleague from the United States wanted to buy a flight ticket on a Chilean website. He went to that site and found a flight at $186.992. He thought the flight price was 186 dollars and 992 cents. In fact, it was one hundred and eighty-six thousand, nine hundred and ninety-two Chilean pesos. The site didn't consider the way that my friend reads numbers. He wasn't part of the site's audience.</p>
			<p>On the bright side, if you go to <a href="http://www.google.com">www.google.com</a>, you will always get the site in your preferred language. The world is their audience.</p>
			<p>If I go to <a href="http://www.kayak.com">www.kayak.com</a>, I will get prices in <a id="_idIndexMarker442"/>my local currency, because I'm part of their audience. This is the full list of countries you will find on Kayak's website:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/Figure_8.14_B16113.jpg" alt="Kayak's audience&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Kayak's audience</p>
			<p>This might look like just a list of countries in Kayak. But that's, in fact, the definition of their audience.</p>
			<p>If you don't <a id="_idIndexMarker443"/>know your site's audience, ask for it, and defend it in your tests.</p>
			<p>Before getting into the code, there is one more thing you need to know regarding localization. There is no one way to implement it, and Puppeteer won't cover every scenario. But, let's take a look at the things we will be able to do with Puppeteer.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor151"/>Emulating geolocation</h2>
			<p>With Puppeteer, we will be able to change the geolocation used by pages using the Geolocation API (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/geolocalization">https://www.hardkoded.com/ui-testing-with-puppeteer/geolocalization</a>). I chose those words carefully. You won't be able to emulate geolocation completely. Most sites use IP-based geolocation. That means that when a site gets a request from your device, it will grab the IP, and it will infer your country based on an IP-to-country table they have on their server. In other words, you won't be able to change the country on <em class="italic">Netflix.com</em>.</p>
			<p>So, what can we emulate? You will be able to <a id="_idIndexMarker444"/>emulate client-side geolocation, such as <a href="http://maps.google.com">maps.google.com</a> or even the <a href="http://google.com">google.com</a> search itself. </p>
			<p>Let's say we want to make Google tell us where to eat, but in Paris. We can do something like this:</p>
			<p class="source-code">const browser = await puppeteer.launch({ headless: false, defaultViewport: null});</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">const context = browser.defaultBrowserContext();</p>
			<p class="source-code">await context.overridePermissions('https://www.google.com/', ['geolocation']);</p>
			<p class="source-code">await page.setGeolocation({latitude: 48.8578349, longitude: 2.3249841});</p>
			<p class="source-code">await page.goto('https://www.google.com/');</p>
			<p class="source-code">await page.type('[name="q"]', 'where to eat');</p>
			<p class="source-code">await page.keyboard.press('Enter');</p>
			<p class="source-code">await browser.close();</p>
			<p>Let's go through this code. You can find this script in the <strong class="source-inline">wheretoeat.js</strong> file. We already know what <strong class="source-inline">puppeteer.launch</strong> and <strong class="source-inline">browser.newPage</strong> do. The third line has something new: <strong class="source-inline">browser.defaultBrowserContext</strong>. OK, that's new for us, but that's not a big deal. It will give us the context of the new page we got in the previous line.</p>
			<p>The next line does have something interesting: <strong class="source-inline">context.overridePermissions</strong>. This function allows us to bypass many permission checks that Chromium performs. If you open Google for the first time and you search for "where to eat," you will get something like this:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Figure_8.15_B16113.jpg" alt="Geolocation permission request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Geolocation permission request</p>
			<p>That window is not something you can <a id="_idIndexMarker445"/>click on with Puppeteer. As we can't click on that, Puppeteer provides <strong class="source-inline">context.overridePermissions</strong> to tell the browser which permissions we want to grant automatically. The signature is quite simple: <strong class="source-inline">browserContext.overridePermissions(origin, permissions)</strong>, where <strong class="source-inline">origin</strong> is the page (the URL) we want to grant permission, and <strong class="source-inline">permissions</strong> is an array of strings accepting one of the following values:</p>
			<ul>
				<li>geolocation</li>
				<li>midi</li>
				<li>midi-sysex</li>
				<li>notifications</li>
				<li>push</li>
				<li>camera</li>
				<li>microphone</li>
				<li>background-sync</li>
				<li>ambient-light-sensor</li>
				<li>accelerometer</li>
				<li>gyroscope</li>
				<li>magnetometer</li>
				<li>accessibility-events</li>
				<li>clipboard-read</li>
				<li>clipboard-write</li>
				<li>payment-handler</li>
			</ul>
			<p>You don't need to remember all these values; just <a id="_idIndexMarker446"/>come to this list when you get a permission request, and you need to know which value to use.</p>
			<p>The next line is a fun one: <strong class="source-inline">await page.setGeolocation({latitude: 48.8578349, longitude: 2.3249841})</strong>. This function is also fairly straightforward. It only expects an object with three properties: <strong class="source-inline">latitude</strong>, which is a number between -90 and 90; <strong class="source-inline">longitude</strong>, which is a number between -180 and 180; and <strong class="source-inline">accuracy</strong>.</p>
			<p class="callout-heading">Pro tip</p>
			<p class="callout">If you want to know the coordinates of a place, you <a id="_idIndexMarker447"/>can go to Google Maps (<a href="https://www.google.com/maps">https://www.google.com/maps</a>) and search for a place. The resulting URL will give you the coordinates. For instance, if you search for Paris, the URL should be https://www.google.com/maps/search/Paris/@48.8590448,2.3257917,14.49z; <strong class="source-inline">48.8590448</strong> will be the latitude, and <strong class="source-inline">2.3257917</strong> the longitude.</p>
			<p>After setting the geolocation, we can navigate to Google, type <strong class="bold">where to eat</strong>, and the result will be where to eat in Paris:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/Figure_8.16_B16113.jpg" alt="Where to eat in Paris&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Where to eat in Paris</p>
			<p>Puppeteer allows us to <a id="_idIndexMarker448"/>emulate not only a location but also a time zone. Let's see how we can travel around the globe with Puppeteer.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor152"/>Emulating time zones</h2>
			<p>Finding a use case for time zone emulation is <a id="_idIndexMarker449"/>not easy, but there are a few. You can emulate time zones to test an application in some specific time zone, even if you are not there. This will be helpful when we talk about scraping in the next chapter.</p>
			<p>One check that can be interesting is testing that your application saves data correctly, no matter the time zone.</p>
			<p>The function to emulate time zones is pretty straightforward: <strong class="source-inline">page.emulateTimezone(timezoneId)</strong>, where <strong class="source-inline">timezoneId</strong> is an ICU's time zone. Chromium also has a list of ICU time zones in its source code. You can find it using the following link: <a href="https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt">https://www.hardkoded.com/ui-testing-with-puppeteer/metazones</a>.</p>
			<p>If you want to test this feature, you can try <a id="_idIndexMarker450"/>changing your time zone and going to a site that shows your current date. You can follow this script in the <strong class="source-inline">timezones.js</strong> file:</p>
			<p class="source-code">const browser = await puppeteer.launch({ headless: false, defaultViewport: null});</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">await page.emulateTimezone('Europe/London')</p>
			<p class="source-code">await page.goto('https://www.unixtimestamp.com/');</p>
			<p class="source-code">await browser.close();</p>
			<p>There we set the time zone to "Europe/London," and go to <a href="https://www.unixtimestamp.com/">https://www.unixtimestamp.com/</a>, which shows dates and times in different formats. Not a fancy feature, but it might be useful someday.</p>
			<p>The last thing we want to cover on this localization topic is language.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor153"/>Emulating languages</h2>
			<p>Delivering the website in the user's language is the <a id="_idIndexMarker451"/>first thing developers cover when implementing localization. But there's one problem in our ecosystem. Let's cover the four common ways developers implement localization.</p>
			<p>You will see sites that will show you the content <strong class="bold">based on your IP</strong>. If it detects your IP is from Spain, it'll show you content in Spanish. If it detects you're in France, it'll show you the site in French. What if you live in a country with five official languages? It just picks one. As we mentioned when we talked about geolocation, we won't be able to emulate IP-based language change.</p>
			<p>Developers could also deliver <strong class="bold">domain-based</strong> solutions. If you go to <a href="http://www.amazon.es">www.amazon.es</a>, you will see the content in Spanish. If you go to <a href="http://www.amazon.fr">www.amazon.fr</a>, you will see content in French. This will be easy to test. You just need to create a language domain map and use it in your tests.</p>
			<p>Third, developers might offer a <strong class="bold">preference-based</strong> solution. If you go to <a href="http://www.amazon.com">www.amazon.com</a>, you'll get the content in English, but it will show you a drop-down list somewhere to change your <a id="_idIndexMarker452"/>language. This one will also be easy to test. You could have one user per language in your test database, and then use them to test the website in different languages.</p>
			<p>The last option I will cover here, although maybe there are more, is the one I believe is the proper way of inferring the user language: by reading the <strong class="bold">Accept-Language header</strong> value. According to MDN (https://www.hardkoded.com/ui-testing-with-puppeteer/Accept-Language), "<em class="italic">the Accept-Language request HTTP header advertises which languages the client is able to understand, and which locale variant is preferred. (By languages, we mean natural languages, such as English, and not programming languages.) Using content negotiation, the server then selects one of the proposals, uses it and informs the client of its choice with the Content-Language response header</em>."</p>
			<p>The browser tells the server which languages you prefer. When you navigate to a page, and on every subsequent request after that, the browser adds the <strong class="bold">Accept-Language</strong> header so that the server can act accordingly.</p>
			<p>When you install a Browser, it will have a default list of languages, based on the download option you chose or the language of your Operative System. But you can then go to the preferences page and change that list of languages. If you go to your browser's preferences, you should be able to find a <strong class="bold">Languages</strong> section. You should be able to see something like this:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/Figure_8.17_B16113.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Language settings in Microsoft Edge</p>
			<p>There, I have three languages: English (United States), English, and Spanish. All those three are set in the Accept-Language header. Sadly for us, according to Paul Reinheimer (https://twitter.com/preinheimer), only 7.2% of the top 10,000 sites supported Accept-Language in 2017 (https://wonderproxy.com/blog/accept-language/). That means that despite having the tools to infer the <a id="_idIndexMarker453"/>language based on the user's preference, most sites won't use it. I hope that changes over time. How can we test languages using the Accept-Language header? It's not that hard:</p>
			<p class="source-code">const browser = await puppeteer.launch({headless: false, defaultViewport: null});</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">await page.setExtraHTTPHeaders({</p>
			<p class="source-code">Â Â Â Â 'Accept-Language': 'fr'</p>
			<p class="source-code">});</p>
			<p class="source-code">await page.goto('https://www.google.com/');</p>
			<p class="source-code">await browser.close();</p>
			<p>This is a way you can get Google's website in French. We will talk more about <strong class="source-inline">page.setExtraHTTPHeaders</strong> in the next chapter. But what you need to know is that you will be able to change the <a id="_idIndexMarker454"/>Accept-Language header the server gets.</p>
			<p>I think we have now seen the most relevant emulation features that Puppeteer offers. But I don't want you to miss anything. Let me briefly show you a few more emulation tools.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor154"/>Other emulations</h1>
			<p>To wrap up this chapter, I want to share <a id="_idIndexMarker455"/>three extra emulation functions with you.</p>
			<p>The first one is related to <strong class="bold">accessibility</strong>. Localization and accessibility are <a id="_idIndexMarker456"/>two human topics. They talk about integration, about not leaving <a id="_idIndexMarker457"/>anyone out, not even from the web. I believe that your website could leave certain cultures out (read these words in context, please). You could say, "I don't plan to sell my products to this country, so I don't need to translate my site to X." As we said, localization could be expensive. But we do have to design sites to be inclusive. I think that in the same way we enforce shopping malls to have ramps for wheelchairs, we should enforce websites to be accessible. I could write lots of pages about this, but that's not the purpose of this book. But I encourage you to read about inclusive design on Microsoft's site: <a href="https://www.microsoft.com/design/inclusive/">https://www.microsoft.com/design/inclusive/</a>. I will leave you with this quote from that site:</p>
			<p class="author-quote">Exclusion happens when we solve problems using our own biases.</p>
			<p>I'm taking the time to write these paragraphs in a UI testing book because I believe that Quality Assurance is the last line of defense for defending and including all users of the web.</p>
			<p>Puppeteer won't cover every accessibility check you should do, but it will help you emulate different vision deficiencies. You can call the <strong class="source-inline">page.emulateVisionDeficiency(type)</strong> function to emulate the following vision deficiencies: <strong class="bold">achromatopsia</strong> (total color blindness), <strong class="bold">deuteranopia</strong> (green color blindness), <strong class="bold">protanopia</strong> (red color blindness), <strong class="bold">tritanopia</strong> (blue-yellow color blindness), and <strong class="bold">blurredVision</strong>, to check blurred vision. Let's see how we <a id="_idIndexMarker458"/>can use this <a id="_idIndexMarker459"/>new function:</p>
			<p class="source-code">const browser = await puppeteer.launch();</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">await page.goto('https://www.packtpub.com/');</p>
			<p class="source-code">await page.emulateVisionDeficiency('achromatopsia');</p>
			<p class="source-code">await page.screenshot({ path: 'achromatopsia.png' });</p>
			<p class="source-code">await page.emulateVisionDeficiency('blurredVision');</p>
			<p class="source-code">await page.screenshot({ path: 'blurred-vision.png' });</p>
			<p class="source-code">await browser.close();</p>
			<p>If you run this check, you will get this result:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/Figure_8.18_B16113.jpg" alt="Packtpub under blurred vision emulation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Packtpub under blurred vision emulation</p>
			<p>You could write checks such as this and share them in a <a id="_idIndexMarker460"/>dashboard, so both the <a id="_idIndexMarker461"/>design and the development team can see how accessible the site is for people with visual impairments.</p>
			<p>The next emulation I want to share with you is about <a id="_idIndexMarker462"/>emulating media features. The function is <strong class="source-inline">page.emulateMediaFeatures(features)</strong>. It accepts an array of <strong class="bold">name/value</strong> features you want to change. These are the two features that Puppeteer supports:</p>
			<ul>
				<li><strong class="source-inline">prefers-colors-scheme</strong>, which will help you toggle between <strong class="source-inline">dark</strong> and <strong class="source-inline">light</strong> mode</li>
				<li><strong class="source-inline">prefers-reduced-motion</strong>, which will reduce CSS animations with the <strong class="source-inline">reduce</strong> option or <strong class="source-inline">no-preference</strong></li>
			</ul>
			<p>This might not have been a popular feature a few years ago. But now, many sites are jumping onto the dark mode hype. This is how you can test dark mode:</p>
			<p class="source-code">const browser = await puppeteer.launch();</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">await page.goto('https://duckduckgo.com/');</p>
			<p class="source-code">await page.emulateMediaFeatures([{ name: 'prefers-color-scheme', value: 'dark' }]);</p>
			<p class="source-code">await page.screenshot({ path: 'dark.png' });</p>
			<p class="source-code">await browser.close();</p>
			<p>As you can see, we can <a id="_idIndexMarker463"/>simply navigate to a page and emulate <strong class="source-inline">prefers-color-scheme</strong> with the value <strong class="source-inline">dark</strong>.</p>
			<p>The last emulation I want to share in this chapter is <a id="_idIndexMarker464"/>media type emulation. We talked about media types when we talked about PDF generation. We have two media types: <strong class="bold">screen</strong> and <strong class="bold">print</strong>. This is an excellent feature if you need to test how a page would be printed. You could use it to test the receipt page, which might be printed by the user.</p>
			<p>The function is <strong class="source-inline">page.emulateMediaType(type)</strong>, and the type is a string that can be <strong class="source-inline">screen</strong> or <strong class="source-inline">print</strong>:</p>
			<p class="source-code">const browser = await puppeteer.launch();</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">await page.goto('https://github.com/puppeteer/puppeteer');</p>
			<p class="source-code">await page.emulateMediaType('print');</p>
			<p class="source-code">await page.screenshot({ path: 'print.png' });</p>
			<p class="source-code">await browser.close();</p>
			<p>Here we go to the Puppeteer repo and check how it would look if we were about to print the page.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor155"/>Summary</h1>
			<p>This was another chapter full of content. I hope you enjoyed it as much as I enjoyed writing it. </p>
			<p>We started the chapter by talking about the internet ecosystem. We talked about how the world is moving toward mobile experiences. This is an excellent time to reach out to the person in charge of analytics in your company and see whether the charts we saw in this chapter represent your website's users.</p>
			<p>Then we moved on to mobile emulation. There, we learn about the viewport, the pixel ratio, a fundamental concept in mobile resolution, touchscreen emulation, and the user agent.</p>
			<p>We also learned how to emulate different network conditions. We will see in <a href="B16113_10_Final_SK_ePub.xhtml#_idTextAnchor167"><em class="italic">Chapter 10</em></a>, <em class="italic">Evaluating and Improving the Performance of a Website</em>, how critical speed is in the mobile experience.</p>
			<p>At the end of this chapter, we covered localization emulation. We learned how to emulate geolocation, time zones, and languages.</p>
			<p>I didn't want to leave any emulation out of this chapter. That's why we also learned about other available emulations. We covered accessibility, dark mode, and media type emulation. Testing dark mode will become more important with all the dark mode hype we live in these days.</p>
			<p>The next chapter will be about Scraping. We will demystify the concept of scraping and learn some new techniques so that you can use Puppeteer not only for testing but also for other fun stuff.</p>
		</div>
	</body></html>