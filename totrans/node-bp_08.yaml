- en: Chapter 8. Developing Web App Workflow with Grunt and Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few chapters, we learned how to use Node.js together with the most
    popular client-side JavaScript frameworks such as AngularJS and Ember.js. We learned
    how to run a fully functional web server and build a command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the world of the task runners. Grunt and Gulp
    are two modules widely used and they have a solid collection of plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the task runners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications are agreeably complex in nature. More and more logic is put into
    the browser and it is written with many lines of JavaScript code. The new CSS3
    features and the improved performance of native browser animations lead to a lot
    of CSS code. Of course, at the end, we still want to keep the things separated.
    Make sure that everything is well-placed in different folders and files. Otherwise,
    our code will be difficult to maintain. We may need to generate `manifest.json`,
    use a preprocessor, or simply copy files from one location to another. Thankfully,
    there are instruments that make our life easier. The **task runner** accepts instructions
    and performs certain actions. It enables us to set a watcher and monitor files
    for changes. This is extremely helpful if we have a complex setup and a lot of
    aspects to handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, there are two popular task runners for Node.js: Grunt and Gulp.
    They are widely used because of the plugins written specifically for them; the
    modules themselves don''t have many features; however, if we combine them with
    external plugins, they become our best friends. Even companies such as Twitter
    or Adobe elaborate on them.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Grunt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Grunt** is a Node.js module, which means it is installed via the Node.js
    package manager. To get started, we need to install Grunt''s command-line tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After running `npm install`, we will be able to request the plugin by calling
    `grunt.loadNpmTasks` (`grunt-contrib-concat`). There is also a `grunt.loadTasks`
    method for custom-defined tasks. Now, let's continue and run our first Grunt script.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concatenation is one of the most common operations. It is the same with the
    CSS styles. Having many files means more server requests, which could decrease
    the performance of your application. The `grunt-contrib-concat` plugin is here
    to help. It accepts a `glob` pattern of source files and a destination path. It
    goes through all the folders, finds the files that match the pattern, and merges
    them. Let's prepare a folder for our small experiment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Concatenating files](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `build/scripts.js` file will be generated by Grunt. So, we don''t have
    to create it. Add some content to the files in the `src` folder. Our `Gruntfile.js`
    file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `concat` task contains a `javascript` object that holds the configuration
    for the concatenation. The source value is actually a `glob` pattern that matches
    all the JavaScript files inside the `src` folder and its subfolders. We have used
    the `glob` module in [Chapter 6](part0046_split_000.html#page "Chapter 6. Using
    Node.js as a Command-line Tool"), *Using Node.js as a Command-line Tool*. With
    the preceding code, we can run the `grunt` command in our terminal. We will get
    a result similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Concatenating files](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `scripts.js` file should be generated in the `build` directory and contain
    all the files from the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Very often, we end up debugging the compiled file. This is mainly because it''s
    the file that we use in the browser and everything is saved together, so we can''t
    really see where the error is initiated. In such cases, it is good to add some
    text before the content in every file. This will allow us to see the original
    destination of the code. The new content of the `Gruntfile.js` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we pass a custom `process` function. It accepts the content of the file
    and its path. It should return the code we want to be concatenated. In our case,
    we just add a short comment at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Minifying your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Minification** is a process that makes our code smaller. It uses smart algorithms
    that replace the names of our variables and functions. It also removes the unnecessary
    spaces and tabs. That''s pretty important for optimization because it normally
    decreases the file size by half. Grunt''s plugin, `grunt-contrib-uglify`, provides
    this functionality. Let''s use the example code from the previous pages and modify
    our `Gruntfile.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we do the following important tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: We add `grunt-contrib-uglify` to our `package.json` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We run `npm install` to get the module in the `node_modules` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end, we define the minification's options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding code, we set up a new task called `uglify`. Its property, `files`,
    contains a hash of the conversions we want to perform. The key is the destination
    path and the value is the source file. In our case, the source file is the output
    of another task so that we can directly use the `<% %>` delimiters. We are able
    to set the exact path, but doing it using the delimiters is much more flexible.
    This is because we may end up with a very long Grunt file and it is always good
    to keep the code maintainable. If we have the destination in one place only, we
    are able to correct it without repeating the same change in other places.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the tasks we defined depend on each other, that is, they should be
    run in a specific order. Otherwise, we will receive unexpected results. Like in
    our example, the `concat` task is performed before `uglify`. That's because the
    second one needs the result from the first.
  prefs: []
  type: TYPE_NORMAL
- en: Watching files for changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grunt is really great at doing some stuff for us. However, it is a bit annoying
    if we have to run it every time we change some of our files. Let''s take the situation
    in the previous section. We have a bunch of JavaScript scripts and want to merge
    them into one file. If we work with the compiled version, then we have to run
    the concatenation every time we make corrections to the source files. For such
    cases, the best thing to do is set up a watcher—a task that monitors our filesystems
    and triggers a specific task. A plugin called `grunt-contrib-watch` does exactly
    this for us. Add this to our `package.json` file and run `npm install` again to
    install it locally. Our file needs only one entry in the configuration. The following
    code shows the new watch property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is a `watch` task added after `concat` and `uglify`. Note that the plugin
    requires two options. The first one, `files`, contains the files we want to monitor
    and the second one, `tasks`, defines the processes that will be run. We are also
    executing a specific part of the `concat` task. At the moment, we have only one
    thing to concatenate, but if we work on a big project, we may have several types
    of files or even different JavaScript sources. So, it is always good to specify
    our definitions, especially for the watching `glob` patterns. We really don't
    want to run unnecessary tasks. For example, we normally don't concatenate JavaScript
    if some of the CSS files are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the setup shown in the preceding code and run Grunt, we will see
    the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Watching files for changes](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There is pretty good logging that shows what exactly happened. All the tasks
    are run and the `src\A.js` file is changed. Immediately, the `concat` and `uglify`
    plugins are launched.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we will have files that should not occupy a part in the whole process,
    for example, having a CSS file should not be concatenated with the others. Grunt
    offers a solution for such cases. Let''s say we want to skip the JavaScript in
    `src/lib/D.js`. We should update our `GruntFile.js` file and change the `src`
    property of the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: All we have to do is to use an array instead of a single string. The exclamation
    mark in front of the value tells Grunt that we want this file to be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grunt has an enormous collection of plugins and we will probably find what we
    want. However, there are situations where we need something custom for our projects.
    In such cases, we will need a custom task. Let's say we need to save the file
    size of the compiled JavaScript. We should access `build/scripts.js`, check its
    size, and write it to a file on the hard disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need is a new directory that will host our tasks as shown
    in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our own task](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note the `custom` folder and the `jssize.js` file. Its name may not match that
    of the new task, but it is a good practice to keep them in sync. Before writing
    the actual code that does the job, we will change our configuration to fire the
    task. So far, we used `grunt.loadNpmTasks` to indicate modules we will use during
    the processing. However, our script is not part of the Node.js'' package management
    and we have to use `grunt.loadTasks`. The method accepts a path to the folder
    containing our file as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All the files in the `custom` directory will be fetched and registered as valid,
    ready-to-use plugins. Now we can add our `jssize` task to the default tasks list
    so that it runs along with the others as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, we will add a new entry in the object passed to the `grunt.initConfig`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As this is our own task, we can pass whatever we think is necessary. In our
    case, this is the file we will get the size of and the path we will save the result
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Grunt task is actually a Node.js module that exports a function by accepting
    the Grunt''s API object. The following is the content of the `custom/jssize.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The key moment is the `grunt.registerMultiTask` method. The first argument is
    the name of the task. This is quite important because the same string is used
    in the `Gruntfile.js` file. Immediately after, we pass a description and anonymous
    function. The body of that function contains the real logic to accomplish the
    task. The configurations we defined are available in the `this.data` object. The
    file-size check is done and the result is saved via the `grunt.file` API.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a cache manifest file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We found out how to create our own Grunt task. Let's write something interesting.
    Let's generate a cache manifest file for the project.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Cache manifest** file is a declarative file we use to indicate the static
    resources of our web application. This could be our CSS files, images, HTML templates,
    video files, or something that remains consistent. This is a huge optimization
    trick because the browser will load these resources not from the web, but from
    the user''s device. If we need to update an already cached file, we should change
    the manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, we have only JavaScript files. Let''s add a few images and one
    CSS file. Make the necessary changes so that our project folder looks like the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a cache manifest file](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The content of `styles.css` is not important. The images in the `img` folder
    are also not important. We just need different files to test with. The next thing
    we have to do is add our task to `Gruntfile.js`. We will use `generate-manifest`
    as a name as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are passing several `glob` patterns; these are the files we want
    to add. Describing every single file in the configuration will take too much time
    and we could forget something. Grunt has a really effective API method, `grunt.file.expand`,
    that accepts `glob` patterns and returns the matched files. The rest of our task
    is to compose the content of the manifest file and save it to the disc. We will
    register the new task and fill the `content` variable, which is later written
    to the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's a good practice to rely on the Grunt API in our custom tasks. It keeps
    the consistency of our application because we depend only on one module—Grunt.
    In the preceding code, we used `grunt.file.expand`, which we already discussed
    before the code, and `grunt.file.write` that saves the manifest's content to the
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a workable manifest, the cache file should start with `CACHE MANIFEST`.
    That's why we add it at the beginning. It's also a good practice to include the
    date on which the generation happened. The randomly generated `id` simplifies
    the process of an application's development.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, the browser will serve the cached version of the files until
    the cache manifest file is changed. Setting a different `id` each time forces
    the browser to fetch the latest version of the files. However, in the production
    environment, this should be removed. To use the cache manifest file, add a special
    attribute in our HTML page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, we should see a result similar to that shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a cache manifest file](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Hence, the content of the cache manifest will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Documenting our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that the code should have documentation. But very often, this is too
    time consuming and mundane. There are some good practices out there that we could
    use. One of them is to write comments into the code and generate the documentation
    using these comments. Following this approach, we should make our code more understandable
    for our colleagues. The Grunt plugin, `grunt-contrib-yuidoc`, will help us create
    the `.doc` files. Add it to our `package.json` and run `npm install`. Again, all
    we have to do is to update our `Gruntfile.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a `paths` property that shows the source code and the `outdir` property
    that shows where the documentation will be saved. If we run Grunt and navigate
    to the directory with our favorite browser, we will see that there is nothing
    listed. That''s because we didn''t add any comment to the code. Open `src/A.js`
    and place the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After relaunching the tasks, we will see the **A Class** in the documentation
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting our code](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Discovering Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gulp** is a build system that has become quite popular. It''s almost the
    same concept as Grunt. We are able to create tasks that do something for us. Of
    course, there are a lot of plugins. In fact, most of the main Grunt plugins have
    equivalent plugins in Gulp. However, there are some differences, which are mentioned
    in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a configuration file, but it is called `gulpfile.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gulp uses streams to process the files, which means that it doesn't create any
    temporary file or folder. This may lead to the better performance of the task
    runner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gulp follows the `code-over-configuration` principle, that is, while we set
    up the Gulp tasks, the process is like coding rather than writing the configurations.
    This makes Gulp friendly for the developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Gulp and fetching plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Grunt, Gulp is available in the Node.js' package manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command line will set up the task runner globally. Once the installation
    is complete, we will be able to run the `gulp` command. Of course, we should do
    that in the directory containing the `gulpfile.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: The plugins for Gulp are also Node.js modules. For example, `gulp-concat` is
    the same as `grunt-contrib-concat` and `gulp-uglify` is the alternative for `grunt-contrib-uglify`.
    It is a good practice to describe them in a `package.json` file. There is no function
    such as `grunt.loadNpmTasks`. We could directly require the module.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating and minifying with Gulp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use the code we already have. There are a bunch of JavaScript files
    in the `src` folder and we want them concatenated. The task runner should also
    generate a minified version and watch the files for changes. We will need several
    modules, and here is how our `package.json` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `gulp` command is needed because we need access to Gulp's API. The `gulp-concat`
    plugin will concatenate the files and `gulp-uglify` will minify the result. The
    `gulp-rename` plugin is used because we have to deliver two files—one suitable
    for reading and one minified, that is, `build/scripts.js` and `build/scripts.min.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the content of the `gulpfile.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With Grunt, we need a little more knowledge about the task runner and its configuration
    structure. With Gulp, it's slightly different. We have the usual Node.js modules
    and the usage of their public APIs. The script starts with the definition of the
    plugins and the `gulp` object. A task is defined by using the `gulp.task` method.
    The first parameter is the name of the task and the second is a function. Also,
    instead of the function, we may pass an array of strings representing other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, like in Grunt, we have a `default` entry. This time, we split the
    tasks into two parts: JavaScript operations and watchers. Almost every Gulp task
    starts with `gulp.src` and ends with `gulp.dest`. The first method accepts the
    `glob` pattern, showing the files that need to be transformed. The `gulp.dest`
    plugin saves the result to the desired location. All the actions between them
    are actually modules that receive and output the streams. In our case, the `js`
    task fetches all the files from the `src` directory and its subfolders, concatenates
    them, and saves the result to the `build` folder. We continue by renaming the
    file, minifying it, and saving it in the same place. The output of our terminal
    after running `gulp` in the project''s folder should be as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Concatenating and minifying with Gulp](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, we should see the `scripts.js` and `scripts.min.js` files in the
    build directory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own Gulp plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The development of the Gulp plugin looks almost the same as creating a Grunt
    one. We need a new Node.js module with a proper API. The difference is that we
    receive a stream and we should then output the stream. This can be a little difficult
    to code because we need to understand how the streams work. Thankfully, there
    is a helper package that simplifies the process. We are going to use `through2`—a
    tiny wrapper around the Node.js'' streams API. So, our `package.json` file grows
    a bit with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the same `jssize` task. It needs to do only one job: measure
    the file size of the concatenated file. We could recreate the `custom` directory
    and place an empty `jssize.js` file there. Our Gulp file also needs a quick correction.
    At the top, we require the newly created module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to pipe the output of the first `gulp.dest(''./build/'')` command to
    the `jssize` plugin. The following snippet shows the finished task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how our plugin looks using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `through2.obj` object returns a stream used in the Gulp's pipeline. Working
    with streams is like working with chunks. In other words, we do not receive the
    entire file, but parts of it again and again till we get the whole data. The `through2`
    object simplifies the process and gives us direct access to the entire file. So,
    the `transform` method accepts the file, its encoding, and a function that we
    need to call once we finish our job. Otherwise, the chain will be stopped and
    the next plugins will not be able to finish their tasks. The actual code that
    generates the `size.log` file is the same as that used in the Grunt version.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use the task runners. These are tools that
    make our life easier by simplifying the common tasks. As web developers, we might
    want to concatenate and minify our production code, and such trivial operations
    are well-handled by modules such as Grunt and Gulp. The wide range of plugins
    and the great Node.js community encourage the usage of task runners and change
    our workflow completely.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into test-driven development and see how Node.js
    handles such processes.
  prefs: []
  type: TYPE_NORMAL
