- en: Chapter 14. Server-side Highcharts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章 服务器端Highcharts
- en: The first edition of *Learning Highcharts* covered a number of approaches to
    run Highcharts on the server side. Since then, there has been significant development
    in this area. It turns out that Highcharts adopts PhantomJS (the headless webkit)
    for the server solution and PhantomJS/Batik for the server implementation in Java.
    We will also explore how we can create our own Highcharts server process using
    PhantomJS and how to use the official server-side script released by Highcharts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 第一版《学习Highcharts》涵盖了在服务器端运行Highcharts的多种方法。从那时起，这个领域已经取得了显著的发展。结果是，Highcharts采用了PhantomJS（无头webkit）作为服务器解决方案，以及PhantomJS/Batik作为Java服务器实现。我们还将探讨如何使用PhantomJS创建我们自己的Highcharts服务器进程，以及如何使用Highcharts发布的官方服务器端脚本。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why we want to run Highcharts on the server side
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们想在服务器端运行Highcharts
- en: Why PhantomJS and Batik are adopted by Highcharts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Highcharts采用了PhantomJS和Batik
- en: The basics of PhantomJS and Batik
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhantomJS和Batik的基本知识
- en: Creating our own PhantomJS script to export charts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的PhantomJS脚本来导出图表
- en: How to use the Highcharts server-side script in both command-line and server
    modes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在命令行和服务器模式下使用Highcharts服务器端脚本
- en: Running Highcharts on the server side
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器端运行Highcharts
- en: 'The main reason for running Highcharts on the server side is to allow the client-based
    graphing application to be automated and accessible on the server side. In some
    cases, it is desirable to produce graphs at the frontend as well as delivering
    automated reports with graphs at the backend. For the sake of consistency and
    development costs, we would like to produce the same style of graphs at both ends.
    Here are other scenarios where we may want to generate graphs on the server side:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端运行Highcharts的主要原因是为了允许基于客户端的图形应用程序在服务器端自动化和访问。在某些情况下，我们希望在前端生成图表，同时在后端交付带有图表的自动化报告。为了保持一致性和开发成本，我们希望在两端生成相同风格的图表。以下是我们可能希望在服务器端生成图表的其他场景：
- en: The application is required to run a scheduled task on the server side. It generates
    a regular summary report with graphs (for example, the Service Level Agreement
    report) and automatically e-mails the report to clients or users with a managerial
    role.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序需要在服务器端运行一个计划任务。它生成带有图表的常规总结报告（例如，服务水平协议报告），并自动将报告通过电子邮件发送给客户或具有管理角色的用户。
- en: The nature of the data means it requires a long time to compute for a graph.
    Instead, users send the parameters over to the server to generate a graph. Once
    it is finished, the chart setup is saved, then the users are notified to see a
    live Highcharts chart from the precomputed JSON setup.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的本质意味着它需要很长时间来计算图表。相反，用户将参数发送到服务器以生成图表。一旦完成，图表设置被保存，然后用户被通知查看从预计算的JSON设置中实时Highcharts图表。
- en: The application involves a vast amount of recurring data that is only kept for
    a certain period, such as data trend graphs that are automatically produced and
    stored in an image format for your records.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序涉及大量重复数据，这些数据仅保留一定时期，例如自动生成并存储为图像格式的数据趋势图表，以供记录。
- en: Highcharts on the server side
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端Highcharts
- en: In the first edition of this book, we mentioned a number of technologies that
    can be used to produce chart images purely on the server side. Within those technologies,
    PhantomJS is the most prominent. In a nutshell, it is a standalone program that
    is capable of running JavaScript on the server. Besides this, it is easy to use,
    has minimum setup, and is programmable and robust.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，我们提到了一些可以用于在服务器端纯服务器端生成图表图像的技术。在这些技术中，PhantomJS是最突出的。简而言之，它是一个能够运行服务器端JavaScript的独立程序。除此之外，它易于使用，设置简单，且可编程且健壮。
- en: The alternative approach was to use Rhino, a Java implementation of the JavaScript
    engine, to run JavaScript on the server side so that Highcharts can be run on
    the server side to export a chart into an SVG file. Then, the SVG file is forwarded
    to Batik, a generic Java-based SVG toolkit, to produce an image file from SVG.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用Rhino，这是一种JavaScript引擎的Java实现，可以在服务器端运行JavaScript，以便Highcharts可以在服务器端运行并将图表导出为SVG文件。然后，SVG文件被转发到Batik，这是一个基于Java的通用SVG工具包，从SVG生成图像文件。
- en: Since then, Highcharts have extensively experimented with different approaches
    and concluded that incorporating PhantomJS is the solution moving forward. There
    are a number of reasons for this decision. First, Rhino has rendering problems
    compared to PhantomJS, which makes PhantomJS a better choice. Moreover, PhantomJS
    can also export images, although it has scalability issues in rendering charts
    when the number of data points increases to around 1,500\. ImageMagick, the image
    converter, was also considered, but it also has specific performance and reliability
    issues. For details of the findings, please see [http://www.highcharts.com/component/content/article/2-articles/news/52-serverside-generated-charts#phantom_usage](http://www.highcharts.com/component/content/article/2-articles/news/52-serverside-generated-charts#phantom_usage).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，Highcharts 对不同的方法进行了广泛实验，并得出结论，将 PhantomJS 纳入解决方案是未来的方向。这个决定有几个原因。首先，与
    PhantomJS 相比，Rhino 存在渲染问题，这使得 PhantomJS 成为更好的选择。此外，PhantomJS 还可以导出图像，尽管当数据点的数量增加到约
    1,500 时，它在渲染图表方面存在可扩展性问题。还考虑了图像转换器 ImageMagick，但它也存在特定的性能和可靠性问题。有关发现详情，请参阅 [http://www.highcharts.com/component/content/article/2-articles/news/52-serverside-generated-charts#phantom_usage](http://www.highcharts.com/component/content/article/2-articles/news/52-serverside-generated-charts#phantom_usage)。
- en: For a server-side solution required to implement in Java, Batik is a more natural
    choice for formatting SVG, whereas PhantomJS is launched to run Highcharts for
    SVG content. As for a non-Java approach, PhantomJS itself is good enough to drive
    the whole server-side solution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要在 Java 中实现的服务器端解决方案，Batik 是格式化 SVG 的更自然选择，而 PhantomJS 则用于运行 Highcharts 以处理
    SVG 内容。至于非 Java 方法，PhantomJS 本身就足够驱动整个服务器端解决方案。
- en: Batik – an SVG toolkit
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Batik – SVG 工具包
- en: Batik is part of the Apache foundation projects, [http://xmlgraphics.apache.org/batik/](http://xmlgraphics.apache.org/batik/).
    Its purpose is to provide a web service to view, generate, and transform SVG data.
    For instance, Highcharts uses this third-party software to convert SVG data into
    an image format. When the user clicks on the export button, Highcharts internally
    forwards the chart's SVG data and the user-selected image format request to Batik.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Batik 是 Apache 基金会项目的一部分，[http://xmlgraphics.apache.org/batik/](http://xmlgraphics.apache.org/batik/)。其目的是提供一项网络服务，用于查看、生成和转换
    SVG 数据。例如，Highcharts 使用第三方软件将 SVG 数据转换为图像格式。当用户点击导出按钮时，Highcharts 内部将图表的 SVG 数据和用户选择的图像格式请求转发给
    Batik。
- en: 'Then, Batik receives the SVG data and transforms the data into the desired
    image format. The following diagram summarizes how a normal Highcharts chart uses
    the export service with Batik:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Batik 接收 SVG 数据并将其转换为所需的图像格式。以下图表总结了正常 Highcharts 图表如何使用 Batik 的导出服务：
- en: '![Batik – an SVG toolkit](img/7451OS_14_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Batik – SVG 工具包](img/7451OS_14_01.jpg)'
- en: 'To install Batik, download the latest distribution from [http://xmlgraphics.apache.org/batik/download.html#binary](http://xmlgraphics.apache.org/batik/download.html#binary)
    and follow the installation instructions. As for Ubuntu, simply do:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Batik，请从 [http://xmlgraphics.apache.org/batik/download.html#binary](http://xmlgraphics.apache.org/batik/download.html#binary)
    下载最新发行版，并按照安装说明进行操作。对于 Ubuntu，只需执行以下操作：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Out of the entire Batik package, we only need the image converter component,
    which is the `batik-rasterizer.jar` file. To transcode from an SVG to a PNG file,
    we can use the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个 Batik 软件包中，我们只需要图像转换组件，即 `batik-rasterizer.jar` 文件。要从 SVG 转码为 PNG 文件，可以使用以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding command will convert `chart.svg` and create `chart.png` in the
    same directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将转换 `chart.svg` 并在同一目录下创建 `chart.png`。
- en: PhantomJS (headless webkit)
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PhantomJS (无头 WebKit)
- en: A webkit is basically the backend engine that drives browsers such as Safari
    and Google Chrome. It implements almost everything in HTML5 except the browser's
    user interface. PhantomJS (found at [http://phantomjs.org/](http://phantomjs.org/),
    created and maintained by Ariya Hidayat) is a headless webkit, which means that
    the webkit engine can be run as a standalone program. It is useful in a number
    of ways, and one of them is server-side SVG rendering.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WebKit 基本上是驱动 Safari 和 Google Chrome 等浏览器的后端引擎。它实现了 HTML5 中的几乎所有功能，除了浏览器的用户界面。PhantomJS（位于
    [http://phantomjs.org/](http://phantomjs.org/)，由 Ariya Hidayat 创建和维护）是一个无头 WebKit，这意味着
    WebKit 引擎可以作为独立程序运行。它在许多方面都很有用，其中之一就是服务器端 SVG 渲染。
- en: Creating a simple PhantomJS script
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建简单的 PhantomJS 脚本
- en: 'Although Highcharts released a PhantomJS script to export charts on the server
    side, it is worth understanding the concept of PhantomJS and how it works. Suppose
    we already have a web server and PhantomJS installed and running. To run an HTML
    page on PhantomJS from a command line, run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Highcharts发布了一个PhantomJS脚本以在服务器端导出图表，但了解PhantomJS的概念及其工作原理仍然很有价值。假设我们已经有了一个运行中的Web服务器和PhantomJS。要从命令行在PhantomJS上运行HTML页面，请运行以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `loadPage.js` page can be as simple as this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadPage.js`页面可以像这样简单：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside the PhantomJS process, it first loads the `webpage` module and creates
    a `page` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在PhantomJS进程中，它首先加载`webpage`模块并创建一个`page`对象。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is only a short example for illustration. For a proper way of handling
    error messages, please refer to the PhantomJS API documentation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简短的示例，用于说明。对于正确处理错误消息的方法，请参阅PhantomJS API文档。
- en: The `page.onError` and `page.onConsoleMessage` methods redirect the page's error
    and output messages to the terminal output via `console.log`. Note that `console.log`
    in this instance is referring to our terminal console. If `console.log` is called
    inside a page, it will only stay within the page object life cycle and we will
    never see those messages unless `page.onConsoleMessage` is defined to redirect
    them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`page.onError`和`page.onConsoleMessage`方法通过`console.log`将页面错误和输出消息重定向到终端输出。请注意，这里的`console.log`是指我们的终端控制台。如果页面内部调用`console.log`，它将仅保留在页面对象的生命周期内，除非定义了`page.onConsoleMessage`来重定向这些消息。'
- en: The preceding script only opens the HTML page into a `webpage` object and then
    terminates, which is not particularly useful.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本仅将HTML页面打开到`webpage`对象中，然后终止，这并不特别有用。
- en: Creating our own server-side Highcharts script
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们自己的服务器端 Highcharts 脚本
- en: 'Let''s use PhantomJS in a slightly more advanced way. In PhantomJS, we don''t
    need to rely on a web server to serve a page. Instead, we load a Highcharts page
    file locally and include the series data from another JSON file. Then, we render
    the result into an image file. So here is how we will run the server-side script
    on a command line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以稍微更高级的方式使用PhantomJS。在PhantomJS中，我们不需要依赖Web服务器来提供服务页面。相反，我们本地加载一个Highcharts页面文件，并包含另一个JSON文件中的系列数据。然后，我们将结果渲染到图像文件中。因此，以下是我们在命令行上运行服务器端脚本的方式：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `chart.html` page is just a simple Highcharts page that we would normally
    create. In this exercise, we will leave the series data as a variable, `seriesData`.
    The following shows how we structure the `chart.html` page:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`chart.html`页面只是一个我们通常会创建的简单Highcharts页面。在这个练习中，我们将系列数据保留为变量`seriesData`。以下显示了如何构建`chart.html`页面：'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, `data.json` is just a simple JSON file containing the array of *x* and
    *y* series data. Here is some of the content:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`data.json`只是一个简单的JSON文件，包含*x*和*y*系列数据的数组。以下是其中的一些内容：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the PhantomJS file, `renderChart.js`, it is surprising how little extra
    code (highlighted in bold) we need to add to achieve the result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PhantomJS文件`renderChart.js`，令人惊讶的是，我们只需要添加很少的额外代码（粗体突出显示）就能达到结果：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We first load the `system` and `fs` modules, which are used in this example
    to select command-line arguments and process file I/O on the JSON file. The script
    basically reads (`fs.read`) the content of the JSON file and converts the content
    into a JavaScript expression and saves (`fs.write`) it in a file. Then, we define
    the `onInitialized` event handler for the page object that is triggered before
    the URL is loaded. So, we insert (`injectJs`) the JavaScript expression of `seriesData`
    before the page object loads the `chart.html` page. Once the page is loaded, we
    export (`page.render`) the page content into an image file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载`system`和`fs`模块，这些模块在本例中用于选择命令行参数并在JSON文件上处理文件I/O。脚本基本上读取（`fs.read`）JSON文件的内容，将其转换为JavaScript表达式，并将其保存（`fs.write`）到文件中。然后，我们为页面对象定义`onInitialized`事件处理器，该事件在URL加载之前触发。因此，我们在页面对象加载`chart.html`页面之前插入（`injectJs`）`seriesData`的JavaScript表达式。一旦页面加载，我们就将页面内容导出（`page.render`）到图像文件中。
- en: 'Notice that the resulting image file is not quite correct in that the line
    series is actually missing. However, if we observe the image more carefully, actually
    the line has just started being drawn (see the following screenshot):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，生成的图像文件并不完全正确，因为折线系列实际上缺失了。然而，如果我们更仔细地观察图像，实际上线条已经开始绘制（请参见以下截图）：
- en: '![Creating our own server-side Highcharts script](img/7451OS_14_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们自己的服务器端 Highcharts 脚本](img/7451OS_14_02.jpg)'
- en: 'This is because of the chart default animation settings. After we turn the
    initial animation off by setting the `plotOptions.series.animation` option to
    `false`, the line series appears:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为图表默认的动画设置。在我们通过将 `plotOptions.series.animation` 选项设置为 `false` 关闭初始动画后，线条系列就会出现：
- en: '![Creating our own server-side Highcharts script](img/7451OS_14_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们自己的服务器端 Highcharts 脚本](img/7451OS_14_03.jpg)'
- en: Running the Highcharts server script
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Highcharts 服务器脚本
- en: So far, our script example is lacking in features and error checking functionality,
    and is far from perfect. Nonetheless, we can see how easy it is to create our
    own server-side Highcharts process to produce images. In this section, you will
    learn how to use the official server-side script by Highcharts, which has more
    features and can be used in different scenarios.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的脚本示例在功能和错误检查功能方面还不足，远非完美。尽管如此，我们可以看到创建自己的服务器端 Highcharts 进程以生成图像是多么容易。在本节中，你将学习如何使用
    Highcharts 的官方服务器端脚本，它具有更多功能，可用于不同场景。
- en: Server script usage
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器脚本使用
- en: Since version 3, Highcharts is packaged with server-side script, `highcharts_convert.js`,
    which is located in the `exporting-server/phantomjs` directory. The script can
    be run as either a command line or as a listening server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 3 以来，Highcharts 与服务器端脚本 `highcharts_convert.js` 一起打包，该脚本位于 `exporting-server/phantomjs`
    目录中。该脚本可以作为命令行或监听服务器运行。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a full description of usage and parameters, refer to [https://github.com/highslide-software/highcharts.com/tree/master/exporting-server/phantomjs](https://github.com/highslide-software/highcharts.com/tree/master/exporting-server/phantomjs).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用法和参数的完整描述，请参阅 [https://github.com/highslide-software/highcharts.com/tree/master/exporting-server/phantomjs](https://github.com/highslide-software/highcharts.com/tree/master/exporting-server/phantomjs)。
- en: Running the script as a standalone command
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将脚本作为独立命令运行
- en: 'Here is a typical command-line format for `highcharts_convert.js`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `highcharts_convert.js` 的典型命令行格式：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is a list of parameters used in the preceding command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在前一个命令中使用的参数列表：
- en: '`-infile`: This is the input source for the script, which can be either a chart
    configuration in the JSON format (general usage) or an SVG file. The server script
    automatically detects the content type, and processes and exports the chart/content
    in the desired format.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-infile`：这是脚本的输入源，可以是 JSON 格式的图表配置（通用用法）或 SVG 文件。服务器脚本会自动检测内容类型，并按所需格式处理和导出图表/内容。'
- en: '`-outfile`, `-type`, `-tmpdir`: The two ways to specify the output format are
    by `-type` or `-outfile`. With the `-outfile` parameter, the script will derive
    the image format from the extension name. Alternatively, `-type`, for example,
    type `png`, formats into a PNG image file and combines with `-tmpdir` to save
    the output file in a specific location.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-outfile`，`-type`，`-tmpdir`：指定输出格式的两种方式是通过 `-type` 或 `-outfile`。使用 `-outfile`
    参数时，脚本将从扩展名推导图像格式。或者，使用 `-type`，例如，输入 `png`，将格式化为 PNG 图像文件，并使用 `-tmpdir` 将输出文件保存到特定位置。'
- en: '`-scale`, `-width`: There are two optional parameters to adjust the output
    image size, by `-scale` or by `-width`. As the name suggests, one is to adjust
    the size by scaling and the other is by the absolute size.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-scale`，`-width`：有两个可选参数用于调整输出图像大小，通过 `-scale` 或 `-width`。正如其名所示，一个是通过缩放调整大小，另一个是通过绝对大小调整。'
- en: '`-constr`: The `-constr` parameter is to instruct the script whether to export
    the chart as a Highcharts or Highstock chart (another product for financial charts).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-constr`：`-constr` 参数用于指示脚本是否将图表导出为 Highcharts 或 Highstock 图表（另一个用于金融图表的产品）。'
- en: '`-callback`: The `-callback` parameter is to execute additional JavaScript
    code on the chart once it is loaded and before the chart is exported.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-callback`：`-callback` 参数用于在图表加载后和导出之前执行额外的 JavaScript 代码。'
- en: Let's apply the previous chart configuration file into this command line. Furthermore,
    we are going to superimpose a watermark, `SAMPLE`, on top of the chart with the
    callback argument.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将之前的图表配置文件应用到这个命令行中。此外，我们还将使用回调参数在图表上叠加水印，`SAMPLE`。
- en: 'First, we save the whole chart configuration object into a file including the
    series data:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将整个图表配置对象及其系列数据保存到文件中：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we create a callback script with the following code to add the watermark,
    `watermark.js`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个回调脚本，以下代码用于添加水印，`watermark.js`：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we run the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们运行以下命令：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The command generates the output as it runs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 命令在运行时会生成输出：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It also produces the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它还生成以下截图：
- en: '![Running the script as a standalone command](img/7451OS_14_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![以独立命令运行脚本](img/7451OS_14_04.jpg)'
- en: Running the script as a listening server
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以监听服务器运行脚本
- en: 'To run the script as a server listening for HTTP requests, we launch the script
    with the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要将脚本作为监听 HTTP 请求的服务器运行，我们使用以下命令启动脚本：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s start a Highcharts export server with the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令启动一个 Highcharts 导出服务器：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This starts a server listening only to local incoming connections on port 9413,
    and the following message outputs to the screen:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个只监听本地端口 9413 的服务器，以下消息输出到屏幕：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Passing options to the listening server
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向监听服务器传递选项
- en: Once the server process is ready, we can start sending POST requests embedded
    within the Highcharts configuration data. The Highcharts options used inside the
    request are the same ones we used in the command line. Let's reuse the configuration
    from the last exercise and pack them into a POST request.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器进程准备就绪，我们就可以开始发送嵌入 Highcharts 配置数据中的 POST 请求。请求中使用的 Highcharts 选项与我们在命令行中使用的相同。让我们重用上一个练习中的配置，并将它们打包成一个
    POST 请求。
- en: 'First, we need to "stringify" the whole chart configuration as a value for
    the `infile` option. Next, we treat the callback method in the same manner. Then,
    we put the rest of the options into one JSON format and save it in a file called
    `post.json`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将整个图表配置“字符串化”为一个值，作为 `infile` 选项的值。接下来，我们以同样的方式处理回调方法。然后，我们将其余的选项放入一个
    JSON 格式，并保存到一个名为 `post.json` 的文件中：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next task is to package this data into a POST query. Since the purpose
    of this chapter is the server-side process, we should operate in a command-line
    style. Hence, we use the `curl` utility to create a POST request. The following
    command can do the job:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是把这个数据打包成一个 POST 查询。由于本章的目的是服务器端处理，我们应该以命令行风格操作。因此，我们使用 `curl` 工具来创建一个
    POST 请求。以下命令可以完成这项工作：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding `curl` command is to create a POST request with the JSON content
    type. The `-d @` argument notifies the `curl` command about which file contains
    the POST data. Since HTTP is an ASCII protocol, the response of the result binary
    image data is returned in base-64 encoding. Therefore, we need to pipe the POST
    response data to another utility, base64, to decode the data and write it to a
    file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `curl` 命令是用来创建一个带有 JSON 内容类型的 POST 请求。`-d @` 参数通知 `curl` 命令哪个文件包含 POST 数据。由于
    HTTP 是一个 ASCII 协议，结果二进制图像数据的响应以 base-64 编码返回。因此，我们需要将 POST 响应数据管道到另一个实用程序，base64，以解码数据并将其写入文件。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described the purpose of running Highcharts on the server
    side and you learned which technology Highcharts has opted to use on a server.
    You learned the basics of PhantomJS and the role of Batik. You extended your understanding
    of PhantomJS to create your own server-side script for Highcharts. Besides that,
    we experimented with how to run the official PhantomJS script released by Highcharts
    in both single command-line and server mode.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了在服务器端运行 Highcharts 的目的，并学习了 Highcharts 在服务器上选择使用的技术。你学习了 PhantomJS
    的基础知识以及 Batik 的作用。你扩展了对 PhantomJS 的理解，以创建自己的 Highcharts 服务器端脚本。除此之外，我们还实验了如何以单命令行和服务器模式运行
    Highcharts 发布的官方 PhantomJS 脚本。
- en: In the next chapter, we will take a glimpse at which online services Highcharts
    offer and explore some of the Highcharts plugins.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将简要了解 Highcharts 提供的在线服务，并探索一些 Highcharts 插件。
