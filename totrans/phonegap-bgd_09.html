<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Getting Ready for Release</h1></div></div></div><p>
<em>So far, you've created your app with PhoneGap, defined the building blocks of its interface, and learned to use various APIs provided by PhoneGap. In this chapter, you will consolidate the app architecture and learn how to prepare your app for your final release to the public. You can optimize your application using various methods to give your users a solid UX experience.</em>
</p><p>In this chapter, you will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn to compress your JavaScript and also learn why this is especially important for a mobile app</li><li class="listitem" style="list-style-type: disc">Learn how to introduce JavaScript dependencies</li><li class="listitem" style="list-style-type: disc">Learn more about template engines and how to compress template files</li><li class="listitem" style="list-style-type: disc">Create fluid, multiple views of your app using PhoneGap</li><li class="listitem" style="list-style-type: disc">Learn how to create hardware-accelerated transitions</li><li class="listitem" style="list-style-type: disc">Discover how to use common code base for web and mobile platforms</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec79"/>Exploring JavaScript compression</h1></div></div></div><p>In computer <a id="id654" class="indexterm"/>programming, we refer to the process of removing unnecessary characters from the source code files, and eventually concatenating them, as<a id="id655" class="indexterm"/> <strong>file compression</strong>. When dealing with web standards, we can compress any file type, including HTML, CSS, and JavaScript. The main goal of this process is to reduce the file size in order to speed up download time.</p><p>One of the benefits of compressing your source code when working with PhoneGap is performance improvement. When dealing with a mobile app, the files are compiled as a single file that eventually loads external data. However, when dealing with an app built using PhoneGap, the files, even if they are stored locally, have to be loaded in the browser (that is, the <strong>WebView</strong>). Smaller<a id="id656" class="indexterm"/> files will be executed faster, so the end user will get a better experience with a more responsive user interface.</p><p>You may think that what really matters on a mobile device is the memory consumption, and that compression will not cause a great reduction of memory usage because the original file and the minified one are interpreted into the same code. However, there are compression tools that<a id="id657" class="indexterm"/> can affect the runtime performance as well. The following sections discuss three of the most popular compression tools that may help improve the performance of your app.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec73"/>Google Closure Compiler</h2></div></div></div><p>
<strong>Google Closure</strong> is a set of open source tools built in order to help developers speed up the development process of modern web applications. The project consists of a JavaScript optimizer, comprehensive JavaScript library, server-side and client-side template engine, and JavaScript style checker<a id="id658" class="indexterm"/> and style fixer. As a complete overview of Google Closure is beyond the scope of this book, we will focus only on the compiler.</p><p>One of the sentences that best <a id="id659" class="indexterm"/>describes the compiler comes from the online documentation:</p><div><blockquote class="blockquote"><p><em>“Instead of compiling from a source language to machine code, it compiles from JavaScript to better JavaScript.”</em></p></blockquote></div><p>You can use the compiler in<a id="id660" class="indexterm"/> one of the following three ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can use it online at <a class="ulink" href="http://closure-compiler.appspot.com/home">http://closure-compiler.appspot.com/home</a></li><li class="listitem" style="list-style-type: disc">You can download <a id="id661" class="indexterm"/>a Java application from <a class="ulink" href="http://closure-compiler.googlecode.com/files/compiler-latest.zip">http://closure-compiler.googlecode.com/files/compiler-latest.zip</a> and execute it through the command-line tool</li><li class="listitem" style="list-style-type: disc">You can use the API provided by Google (see <a class="ulink" href="https://developers.google.com/closure/compiler/docs/gettingstarted_api">https://developers.google.com/closure/compiler/docs/gettingstarted_api</a>)</li></ul></div><p>When you open the online application, you can specify in the left pane the URLs of the scripts you want to compile, what kind of optimization you want to be applied to the output file, and if you want the output to be formatted for readability. On the right pane of the web application, you will get a report dealing with the original size and the optimized size of the file, the compiled code, a list of warnings, eventually some errors, and the POST data sent to the Closure Compiler APIs. The warnings provided refer to possible mistakes in the source code and optimization that can be performed. For a reference to possible warning messages, go to <a class="ulink" href="https://developers.google.com/closure/compiler/docs/error-ref">https://developers.google.com/closure/compiler/docs/error-ref</a>.</p><div><img src="img/B03476_09_01.jpg" alt="Google Closure Compiler"/></div><p>If you prefer working <a id="id662" class="indexterm"/>with the command-line tool, you can download the compiler application and execute it, specifying the compiling options and the input and output files:</p><div><pre class="programlisting">
<strong>$ java -jar compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --js hello.js</strong>
</pre></div><p>You get the same result when using the online tool; however, using the command line saves you an extra step: you don't have to upload the source code first.</p><p>When you use the advanced optimization, be aware that the renaming process will be more aggressive, the unused code will be removed, and the body of the function calls will be replaced with the body of the function itself (this process is known as <strong>function inlining</strong>).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec80"/>Time for action – compressing files using the Closure Compiler</h1></div></div></div><p>Follow the given<a id="id663" class="indexterm"/> steps to get a compressed and optimized file using the Google Closure Compiler:</p><div><ol class="orderedlist arabic"><li class="listitem">Download and unzip the Closure Compiler application available at <a class="ulink" href="http://dl.google.com/closure-compiler/compiler-latest.zip">http://dl.google.com/closure-compiler/compiler-latest.zip</a>.</li><li class="listitem">Open the command-line tool, move to the unzipped folder, and create a folder named <code class="literal">sample</code>.</li><li class="listitem">In the new folder, create three files: <code class="literal">index.html</code>, <code class="literal">test.js</code>, and <code class="literal">index.js</code>. You can use the following commands:<div><pre class="programlisting">
<strong>$ echo ‘&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;' &gt; index.html</strong>
<strong>$ echo &gt; index.js</strong>
<strong>$ echo &gt; test.js</strong>
</pre></div></li><li class="listitem">Open the <code class="literal">test.js</code> file and define a self-executing function. Within the body of the function, declare<a id="id664" class="indexterm"/> two other functions and return one of them in order to be able to run this code from another JavaScript file (the purpose of the two functions is to<a id="id665" class="indexterm"/> mimic a real use case when some code is kept internal to a closure and some other is exposed through a returning object).<div><pre class="programlisting">var test  =  (function(){

    var main = function(){

        alert(‘executing main');
        internal();
    };

    var internal = function(){

        alert(‘executing internal');

    };

    return {

        init: main

}

}());</pre></div></li><li class="listitem">Open the <code class="literal">index.js</code> file and declare a variable in order to store the result of the self-executing function and make a call to the <code class="literal">init</code> function returned by the function itself:<div><pre class="programlisting">var myTest = test.init();</pre></div></li><li class="listitem">Return to the command-line tool and run the compiler against the JavaScript files you just created:<div><pre class="programlisting">
<strong>$ java -jar closure-compiler/compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --js samples/test.js samples/index.js --js_output_file samples/app.js</strong>
</pre></div></li><li class="listitem">Open the generated file and take a look at the source code; you will get the following JavaScript:<div><pre class="programlisting">alert(“executing main”);alert(“executing internal”);</pre></div></li><li class="listitem">Insert the <code class="literal">script</code> tag<a id="id666" class="indexterm"/> in the HTML page referring to the new optimized JavaScript file and open it in a <a id="id667" class="indexterm"/>browser.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec74"/>
<em>What just happened?</em>
</h2></div></div></div><p>You discovered the potential of the <code class="literal">ADVANCED_OPTIMIZATIONS</code> compilation level of the Closure Compiler. As you can see, it's pretty aggressive. In fact, if you run the same command using the files you have created for your actual project, you will not be able to run the application as intended. In short, ensure to check whether the <code class="literal">ADVANCED_OPTIMIZATIONS</code> option breaks your code; if so, you should consider using a different level of compression.</p><p>Next, you will discover how to optimize and compress JavaScript modules using UglifyJS.</p><div><div><h3 class="title"><a id="note42"/>Note</h3><p>In order to get an exhaustive guide to the Closure Compiler, refer to the online reference at <a class="ulink" href="https://developers.google.com/closure/compiler/docs/api-tutorial3">https://developers.google.com/closure/compiler/docs/api-tutorial3</a> or just type <code class="literal">$ java -jar compiler.jar --help</code> in your command-line tool.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec75"/>UglifyJS2</h2></div></div></div><p>The <strong>UglifyJS</strong> project became very<a id="id668" class="indexterm"/> popular when jQuery started to use it. Being used by one of the <em>de facto</em> standard JavaScript libraries resulted in a lot of feedback to the author, which in turn helped him fix a number of bugs.</p><p>The new version of the<a id="id669" class="indexterm"/> project, named <strong>UglifyJS2</strong>, is slower than the previous one, but the overall compression results are much better and there are more advanced features such as multilevel source maps (basically, it's a way to map a combined/minified file back to an unbuilt state) like in the<a id="id670" class="indexterm"/> Google Closure Compiler.</p><p>UglifyJS2 is distributed as a Node.js module. In order to install it, you can proceed as with any other Node.js module. Open the command-line tool and use npm to install the <code class="literal">uglify-js</code> module:</p><div><pre class="programlisting">
<strong>$ sudo npm install uglify-js -g</strong>
</pre></div><p>At this point, compressing your JavaScript files just got a lot easier.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Time for action – using UglifyJS</h1></div></div></div><p>Let's see how you can <a id="id671" class="indexterm"/>get a compressed version of the same files you worked on with the Google Closure Compiler:</p><div><ol class="orderedlist arabic"><li class="listitem">Open your command-line tool and go to the sample folder created to test the Closure Compiler.</li><li class="listitem">Type the following command in order to concatenate the JavaScript files and to run the UglifyJS2 compressor. For Windows, you can use the <code class="literal">copy</code> command to concatenate the files:<div><pre class="programlisting">
<strong>C:\ copy /a *.js index.js</strong>

<strong>$ cat test.js index.js</strong>

<strong>$ uglifyjs --inline-script -o mytest.min.js</strong>
</pre></div></li><li class="listitem">Open the generated file and take a look at the source code; you will get the following JavaScript:<div><pre class="programlisting">var test=function(){var main=function(){alert(“executing manin”);internal()};var internal=function(){alert(“executing internal”)};return{init:main}}();var test=test.init();</pre></div></li><li class="listitem">Insert the <code class="literal">script</code> tag in the HTML page and open it in a browser.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec76"/>
<em>What just happened?</em>
</h2></div></div></div><p>You created a compressed version of two simple JavaScript files. As you can see, the output is rather different from the one created with the Closure Compiler. One of the main features of UglifyJS2 is that the generated output doesn't break the source code.</p><p>For a complete reference, you can<a id="id672" class="indexterm"/> check the project page on GitHub at <a class="ulink" href="https://github.com/mishoo/UglifyJS2">https://github.com/mishoo/UglifyJS2</a>.</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>If you run UglifyJS2 in order to compress the files created in <a class="link" href="ch04.html" title="Chapter 4. Working with Plugins">Chapter 4</a>, <em>Working with Plugins</em>, you will be able to run the application as intended.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec77"/>Optimization with RequireJS</h2></div></div></div><p>RequireJS includes an<a id="id673" class="indexterm"/> optimization tool named <strong>r.js</strong> that<a id="id674" class="indexterm"/> combines related scripts<a id="id675" class="indexterm"/> together into build layers and minifies them via UglifyJS or the Closure Compiler. The tool can be used through Node.js or Java. When using the Closure Compiler, it's mandatory to run the tool using Java.</p><p>The optimizer is better than using a plain concatenation script because it runs RequireJS as part of the optimization, so it knows how to load the plugins and all the dependencies of the JavaScript modules <a id="id676" class="indexterm"/>needed in your application.</p><p>For an exhaustive guide to r.js, refer<a id="id677" class="indexterm"/> to the readme file available on GitHub at <a class="ulink" href="https://github.com/jrburke/r.js">https://github.com/jrburke/r.js</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Time for action – optimizing JavaScript with RequireJS</h1></div></div></div><p>Follow these steps to<a id="id678" class="indexterm"/> optimize the source code of your app using Node.js and RequireJS:</p><div><ol class="orderedlist arabic"><li class="listitem">Install the <code class="literal">requirejs</code> module using npm from the command-line tool:<div><pre class="programlisting">
<strong>$ sudo npm install requirejs -g</strong>
</pre></div></li><li class="listitem">Go to the root folder <a id="id679" class="indexterm"/>of the app you worked on in the previous chapters, create a file named <code class="literal">build.js</code>, and add to it the build process configuration info (that is, the JavaScript folder, the paths to the library used in the project, the name of the main file of the app, and the output folder and filename):<div><pre class="programlisting">({
    baseUrl: ‘js/',
    paths: {
        mustache: ‘libs/mustache',
        alice: ‘libs/alice.min',
        text: ‘libs/require/plugins/text'
    },
    name: ‘main',
    out: ‘js/main-built.js'
})</pre></div></li><li class="listitem">Open the command-line tool again and execute the following command in order to build the app:<div><pre class="programlisting">
<strong>$ r.js -o build.js</strong>
</pre></div></li><li class="listitem">Open the <code class="literal">index.html</code> file and change the entry point of your app in the <code class="literal">script</code> tag in the header:<div><pre class="programlisting">&lt;script data-main=”js/main-built” src=”js/libs/require/require.js”&gt;&lt;/script&gt;</pre></div></li><li class="listitem">Open the <code class="literal">index.html</code> file in a browser.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec78"/>
<em>What just happened?</em>
</h2></div></div></div><p>You created a compressed version of the app's JavaScript files minified in a single file, specifying the command-line options using a build file. The result is that the code of the app is now optimized using<a id="id680" class="indexterm"/> UglifyJS2 (the engine that works behind the scenes) and it still works perfectly. In order to<a id="id681" class="indexterm"/> get a complete overview of the build options, refer to the sample build file available on GitHub at <a class="ulink" href="https://github.com/jrburke/r.js/blob/master/build/example.build.js">https://github.com/jrburke/r.js/blob/master/build/example.build.js</a>.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>If you prefer to use the <a id="id682" class="indexterm"/>Closure Compiler to compress and optimize the app's JavaScript files, you have to download the binaries of <a id="id683" class="indexterm"/>Rhino (an open source implementation of JavaScript written entirely in Java) available at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Rhino/Download_Rhino">https://developer.mozilla.org/en-US/docs/Rhino/Download_Rhino</a>, download r.js from the RequireJS website at <a class="ulink" href="http://requirejs.org/docs/download.html#rjs">http://requirejs.org/docs/download.html#rjs</a>, add the <code class="literal">optimize: ‘closure'</code> option to the build file, and execute the following command:</p><div><pre class="programlisting">
<strong>$ java -classpath ~/rhino1_7R4/js.jar:~/compilers/closure-compiler/compiler.jar org.mozilla.javascript.tools.shell.Main r.js build.js</strong>
</pre></div><p>Here, <code class="literal">classpath</code> refers to the full path to Rhino and the Closure Compiler.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Comparing compression tools</h1></div></div></div><p>We have covered three of the most popular compression tools. Each tool has its pros and cons. As always, the right tool<a id="id684" class="indexterm"/> for you is the one that best fits your needs. The following table summarizes the results, in bytes, you can get compressing a RequireJS file itself with the tools we just discussed:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>File</p>
</th><th style="text-align: left" valign="bottom">
<p>Original size</p>
</th><th style="text-align: left" valign="bottom">
<p>Compressor</p>
</th><th style="text-align: left" valign="bottom">
<p>Size</p>
</th></tr></thead><tbody><tr><td rowspan="3" style="text-align: left" valign="top">
<p>RequireJS</p>
</td><td rowspan="3" style="text-align: left" valign="top">
<p>82944</p>
</td><td style="text-align: left" valign="top">
<p>UglifyJS2</p>
</td><td style="text-align: left" valign="top">
<p>24576</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Google Closure</p>
</td><td style="text-align: left" valign="top">
<p>13312 </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>r.js</p>
</td><td style="text-align: left" valign="top">
<p>15360</p>
</td></tr></tbody></table></div><p>As you can see, in this example, Google Closure yields the best result, but that is not always the case. If you run the same tests on the popular RaphaelJS library, you get the best result with Google Closure Compiler instead. The results vary depending on the source code writing style; for this reason, there is no single best tool to use. I prefer r.js because it can run the compressor engine as well as handle the plugins and module dependencies very well.</p><p>JavaScript task runners <a id="id685" class="indexterm"/>such as Gulp or Grunt can be used to create tasks to link, compress, and concatenate your resources automatically whenever there are some changes.</p><div><div><h3 class="title"><a id="note44"/>Note</h3><p>Other compression tools you may consider include KJScompress, Bananascript, JSMin, ShrinkSafe, and YUI Compressor.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Using template engine compression</h1></div></div></div><p>When you work on larger HTML projects, it's advisable to use JavaScript templating engines and image compressions. When the application needs to be updated frequently with data, templating<a id="id686" class="indexterm"/> libraries will be of much use. I strongly believe that there is no such thing as <em>the</em> best JavaScript template engine. Each time you work on a project, you have to decide which is the right engine for the job at hand. For instance, <strong>Underscore.js</strong> templates<a id="id687" class="indexterm"/> are fast and lightweight and if you want them already loaded in your app, then it's a good option. When using jQuery, the natural choice seems to be<a id="id688" class="indexterm"/> <strong>ICanHaz.js</strong> because it returns each template as a jQuery object. When you need a more robust template<a id="id689" class="indexterm"/> engine, then <strong>Google Closure Templates</strong> could be a valid option. For a<a id="id690" class="indexterm"/> comparison of templating engines, visit <a class="ulink" href="http://garann.github.io/template-chooser/">http://garann.github.io/template-chooser/</a>.</p><p>In most cases, <strong>Mustache.js</strong> <a id="id691" class="indexterm"/>completely fits the needs of an application because there is no logic in the templates and because the templates are language-agnostic, allowing you to reuse them between frontend and backend. There are several template engines based on <strong>Mustache.js</strong>, including<a id="id692" class="indexterm"/> <strong>Handlebars.js</strong>, <strong>Hogan.js</strong>, or <strong>Pistachio</strong>.</p><p>Handlebars.js is a superset of Mustache.js that<a id="id693" class="indexterm"/> adds some useful features such as block expressions, helpers, and more (refer to the online documentation at <a class="ulink" href="http://handlebarsjs.com/">http://handlebarsjs.com/</a> for a<a id="id694" class="indexterm"/> complete overview).</p><p>Hogan.js is a very<a id="id695" class="indexterm"/> powerful compiler for Mustache.js templates from Twitter. Hogan.js is also delivered with a command-line utility that compiles all the <code class="literal">*.mustache</code> templates stored in a folder; the utility is located in the <code class="literal">hogan.js-template/bin</code> folder. More information about Hogan.js is available on GitHub at <a class="ulink" href="https://github.com/twitter/hogan.js">https://github.com/twitter/hogan.js</a>.</p><p>Pistachio is not just <a id="id696" class="indexterm"/>another JavaScript template engine based on Mustache.js. Its package contains a pure JavaScript compiler that compiles templates into self-contained JavaScript functions that can be used in every JavaScript environment.</p><p>In order to start using<a id="id697" class="indexterm"/> Pistachio's compiler, you can install it as a Node.js module:</p><div><pre class="programlisting">
<strong>$ sudo npm install pistachio -g</strong>
</pre></div><p>Once installed, you can compile a template by typing <code class="literal">pistachio</code> followed by the path to the file you want compile.</p><p>The interesting features of Pistachio's compiler are the capability to compile a template as an AMD module<a id="id698" class="indexterm"/> or CommonJS compatible module and the possibility to create the output as a jQuery object. A template compiled with Pistachio is still dynamic and can be compressed even more using the Google Closure Compiler. For a complete reference <a id="id699" class="indexterm"/>on Pistachio, go to <a class="ulink" href="https://npmjs.org/package/pistachio">https://npmjs.org/package/pistachio</a>.</p><p>A compressed template speeds up your application rendering because you can cache it as a JavaScript function and avoid continuously loading and unloading it <a id="id700" class="indexterm"/>with an <strong>AJAX</strong> request (with some performance penalties involved) when the app is in use.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>If you want to include multiple templates in a file, you can simply store them in <code class="literal">script</code> tags, assign an ID to each tag, and then use the <code class="literal">getElementByID()</code> document object method and the <code class="literal">innerHTML</code> HTMLElement object property to render it:</p><div><pre class="programlisting">&lt;script type=”text/x-mustache” id=”tid...”&gt;
    /* mustache template */
&lt;/script&gt;</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Time for action – compiling a template using Pistachio</h1></div></div></div><p>Create a new template<a id="id701" class="indexterm"/> file and eventually compress it using<a id="id702" class="indexterm"/> Pistachio. Follow the given steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open your command-line tool and move to the folders containing the template files.</li><li class="listitem">Type the <code class="literal">pistachio</code> command and specify the name of the output file and the file to compile:<div><pre class="programlisting">
<strong>$ pistachio --out=splash-tpl.js splash-tpl.html</strong>
</pre></div></li><li class="listitem">Create a build file named, for instance, <code class="literal">template-build.js</code>, for the existing template to use when compressing the file with UglifyJS2, specifying the template name and the desired output filename:<div><pre class="programlisting">({
    name: ‘splash-tpl',
    out: ‘splash-built.js'
})</pre></div></li><li class="listitem">Run the r.js Node<a id="id703" class="indexterm"/> module from the command-line tool:<div><pre class="programlisting">
<strong>$ r.js -o template-build.js</strong>
</pre></div></li><li class="listitem">Open the file and <a id="id704" class="indexterm"/>check its syntax and size.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec79"/>
<em>What just happened?</em>
</h2></div></div></div><p>You created a compressed version of the template file that is stored in a variable. You can now request it in the modules of the app and avoid any unnecessary XMLHttpRequest.</p><p>This technique is most beneficial when working with pretty big and complex templates. Throughout this book, you will discover some advanced template caching techniques.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Creating fluid, multiple app views</h1></div></div></div><p>One of the strengths of PhoneGap is that the app UI and logic are built upon web standards. A mobile app is made up of several views that allow the user to interact with its core features. As for a web app, when working with PhoneGap, you can think of a view as a web page or a <a id="id705" class="indexterm"/>fragment of a web page.</p><p>You can create multiple views in your app using different HTML pages or dynamically changing the markup of a single HTML page. The first approach is usually known as <strong>multipage pattern</strong>; the<a id="id706" class="indexterm"/> second one is known <a id="id707" class="indexterm"/>as <strong>single-page pattern</strong>.</p><p>Generally speaking, the multipage pattern is best suited to applications that mostly comprise static content or applications that rely mostly on the server for the business logic. When most of the content is static, you can package it using PhoneGap and deliver it as an app. When the business logic is defined on the server, you can think of the client as the presentation layer of your app and rely on a good mobile connection to make it available to users. In both cases, your client-side code should be pretty simple and easy to maintain.</p><p>The multipage approach has some disadvantages. For instance, when the user navigates from one page to the next, the browser has to reload and parse all the JavaScript associated with the new page. Also, because the JavaScript code is reloaded, all application state is lost if your app does not use other techniques such as local storage or the HTML5 history state object to maintain it.</p><p>The single-page pattern <a id="id708" class="indexterm"/>overcomes the disadvantages associated with the multipage approach. The PhoneGap and app JavaScript code is loaded just once, removing the need to pass application state from one page to the next. The disadvantage of this approach is an increased complexity of the JavaScript that contains most of the business logic and that it is required to update the UI when navigation occurs. Single-page applications are best written using the MVC design pattern and libraries such as AngularJS can be used.</p><p>The most important difference between the two patterns is that with the single-page pattern, the PhoneGap JavaScript bridge is loaded once. There's a noticeable pause when it's loaded due to the fact that the link between the JavaScript APIs and the native counterparts is created. When the app loads the PhoneGap JavaScript API once, the UI appears more responsive and the user experience is improved.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Using hardware-accelerated transitions</h1></div></div></div><p>Much has been said about the use of <a id="id709" class="indexterm"/>
<strong>graphics processing unit</strong> (<strong>GPU</strong>) hardware acceleration in smartphone<a id="id710" class="indexterm"/> and tablet web browsers. The general scheme is to offload tasks that would otherwise be calculated by the main CPU to the GPU in your computer's graphics adapter. (For a very detailed article to better understand <a id="id711" class="indexterm"/>hardware-accelerated transitions, go to <a class="ulink" href="https://dev.sencha.com/blog/understanding-hardware-acceleration-on-mobile-browsers">https://dev.sencha.com/blog/understanding-hardware-acceleration-on-mobile-browsers</a>.)</p><p>GPU can accelerate the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The general layout compositing</li><li class="listitem" style="list-style-type: disc">All the CSS transitions</li><li class="listitem" style="list-style-type: disc">The CSS 3D transformations</li><li class="listitem" style="list-style-type: disc">All the canvas drawing operations</li></ul></div><p>You can create smooth animations with the new CSS transitions by pretty easily defining them in your style sheets or you can rely on external libraries.</p><p>CSS transitions are supported in the latest versions of Firefox, Safari, and Chrome. They're supported in IE 10 and above. If CSS animations aren't supported in a given browser, then the properties will be applied instantly, gracefully degrading. There are several techniques to handle a CSS transition. I will use <strong>Alice.js</strong>, which is an interesting JavaScript library that allows you to execute hardware-accelerated transitions in your app.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec80"/>AliceJS</h2></div></div></div><p>AliceJS (A Lightweight Independent CSS Engine) is a JavaScript library that leverages hardware-accelerated <a id="id712" class="indexterm"/>capabilities of browsers in order to generate visual effects. One of the strengths of the library is that it doesn't rely on other libraries and that it's self-contained in a single JavaScript file (for a complete reference and some<a id="id713" class="indexterm"/> interesting examples, refer to the official website at <a class="ulink" href="http://blackberry.github.com/Alice/demos/index.html">http://blackberry.github.com/Alice/demos/index.html</a>.)</p><p>Each time you want to<a id="id714" class="indexterm"/> create a transition with AliceJS, you have to set up a configuration object. This object varies depending on the effect or plugin you are using. However, some configuration properties are shared between all the effects and plugins, including the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">elems</code>: This is the target element(s) or node</li><li class="listitem" style="list-style-type: disc"><code class="literal">rotate</code>: This is the rotation angle in degrees</li><li class="listitem" style="list-style-type: disc"><code class="literal">perspectiveOrigin</code>: This is the anchor point, which can be <code class="literal">top-left</code>, <code class="literal">top-center</code>, <code class="literal">top-right</code>, <code class="literal">center</code>, and so on, or the explicit coordinates in percentage of the entire size of <code class="literal">div</code>, for example, <code class="literal">{x: 200, y: 200}</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">duration</code>: This is the duration of the effect</li><li class="listitem" style="list-style-type: disc"><code class="literal">timing</code>: This is the easing function as per standard CSS specs</li><li class="listitem" style="list-style-type: disc"><code class="literal">delay</code>: This determines how long before the animation starts</li><li class="listitem" style="list-style-type: disc"><code class="literal">iteration</code>: This is the number of iterations</li><li class="listitem" style="list-style-type: disc"><code class="literal">direction</code>: This specifies whether the animation should be played in reverse mode</li><li class="listitem" style="list-style-type: disc"><code class="literal">playstate</code>: This is either <code class="literal">running</code> or <code class="literal">paused</code></li></ul></div><p>In this way, it's possible to easily configure a CSS-based animation without any additional required know-how. There are three plugins for AliceJS and they include a few animation types. The following is the simple code from the Alice documentation to create a wobble effect by using the Cheshire plugin. So, we need to include the core and the plugin file:</p><div><pre class="programlisting">&lt;div id=”DIV1”&gt;HERE IS ONE DIV&lt;/div&gt;
&lt;img id=”IMG1” src=”/myimg.gif”&gt;
&lt;script src=”/alice/alice.core.js”&gt;&lt;/script&gt;
&lt;script src=”/alice/alice.plugins.cheshire.js”&gt;&lt;/script&gt;

&lt;script&gt;
alicejs.wobble({
    elems: [“DIV1”, “IMG1”], 
    rotate: 5, 
    perspectiveOrigin: “center”, 
    duration: “200ms”, 
    timing: “linear”, 
    delay: “0ms”, 
    iteration: “infinite”, 
    direction: “alternate”, 
    playstate: “running”
});
&lt;/script&gt;</pre></div><p>As you can see, the <a id="id715" class="indexterm"/>code is pretty simple; for a complete overview, please refer to the online documentation<a id="id716" class="indexterm"/> of AliceJS.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Porting web applications</h1></div></div></div><p>We know that PhoneGap/Cordova allows you to have a common code base for all mobile platforms. PhoneGap helps to package your HTML, CSS, and JavaScript code so that it can be installed in<a id="id717" class="indexterm"/> a mobile device and can be used as an app in different types of platforms such as Android, iOS, Firefox, and so on. It's not a surprise now. However, did you know that, with some planning, you can convert your existing web application to a hybrid mobile app?</p><p>If you are a web developer, you can even create a mobile app with your existing knowledge of web development and can sell in app marketplaces. You can save a lot of time and money by avoiding redevelopment.</p><p>PhoneGap/Cordova provides a lot of APIs to access device features such as the camera, accelerometer, and more. In this way, PhoneGap gives developers the ability to create a full-featured mobile app using web technologies. However, you can't use such device-related APIs in your web application. So, you have to design your code base so that it provides modularity.</p><p>The way a user interacts with an Android app is different from interacting with an iOS app and so on. So, there has to be careful planning on the design factors of the app. You might need tweaks on each platform to have a better user experience. You can use responsive design<a id="id718" class="indexterm"/> and media queries to target multiple screen sizes, devices, and display destinations (standard or high-density).</p><p>Providing a robust design for a common code base is beyond the scope of this book. However, there are lots of success stories of porting web applications to hybrid mobile applications.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec89"/>Summary</h1></div></div></div><p>In this chapter, you learned how to optimize the source code of your app and also how to compress the templates that you use; we also saw various code compression methods. With this, we have completed our learning and it's time to put them to work. In the next chapter, we will create an app to demonstrate all our knowledge of PhoneGap.</p></div></body></html>