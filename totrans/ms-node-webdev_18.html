<html><head></head><body>
<div><h1 class="chapternumber">16</h1>
<h1 class="chaptertitle" id="_idParaDest-277">SportsStore: A Real Application</h1>
<p class="normal1">In each of the previous chapters, I focused on a particular feature required by web applications, which allowed me to dig into detail. In this part of the book, I show how the features described in earlier chapters are combined to build a simple but realistic e-commerce application.</p>
<p class="normal">My application, called<a id="_idIndexMarker849" class="calibre3"/> SportsStore, will follow the classic approach taken by online stores everywhere. I will create an online product catalog that customers can browse or search through, a shopping cart where users can add and remove products, and a checkout where customers can enter their shipping details. I will also create an administration area that provides facilities to manage the catalog, and I will protect it so that only authorized users can make changes.</p>
<p class="normal">My goal in this part of the book is to give you a sense of what real web application development is by creating as realistic an example as possible. I want to focus on Node.js, of course, so I have simplified integration with external systems, such as the database, and omitted others entirely, such as payment processing.</p>
<h1 class="heading" id="_idParaDest-278">Understanding the project structure</h1>
<p class="normal1">The SportsStore application <a id="_idIndexMarker850" class="calibre3"/>spans six chapters and contains many files, some of which have the same name, either because that’s what TypeScript/JavaScript requires or because of my development style. There will be multiple <code class="inlinecode">index.ts</code> files, for example, because that’s the filename that JavaScript uses when importing from modules. There will also be <a id="_idIndexMarker851" class="calibre3"/>multiple files whose name contains the term <em class="italic">helper</em> because that’s how I tend to write code that supports some other part of the application. For quick reference, <em class="italic">Table 16.1</em> provides a high-level overview of the structure of the completed SportsStore project, which will provide context as you read through the chapters and follow the examples. </p>
<p class="packt_figref">Table 16.1: The project layout and key files</p>
<table class="table-container" id="table001-13">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Folder</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">dist</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder will contain the JavaScript files created by the TypeScript compiler, which will be executed by Node.js.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder will contain all of the source code for the SportsStore application and will be compiled into the <code class="inlinecode">dist</code> folder.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/admin</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder supports the administration features created in <em class="italic">Chapter 20</em>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/config</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder contains the code that provides configuration settings to the rest of the application, which is read from configuration files and environment settings.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/data</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder contains all the functionality related to handling data.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/data/orm</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder contains the <code class="inlinecode">Sequelize</code> implementation of the data model.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/data/validation</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder contains the code to validate user input.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/helpers</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder contains helpers for the logicless template package.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/routes</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder contains the HTTP routes that match and handle requests.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/authentication.ts</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">The code in this file configures user authentication. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/errors.ts</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">The code in this file creates HTTP error responses.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/server.ts</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">The code in this file is executed when the SportsStore application starts and is responsible for setting up the application features and creating the HTTP server.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">src/sessions.ts</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">The code in this file sets up cookie-based HTTP sessions.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">templates</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This folder contains templates the server will use to render content for HTML clients. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">products.json</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This file contains product data that will be used to populate the catalog. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">server.config.json</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This is the main configuration file for the application. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">development.env</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This file is used to store secrets as environment variables during development.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The structure of the <em class="italic">SportsStore</em> project reflects, at least in part, the way that I like to<a id="_idIndexMarker852" class="calibre3"/> write software. You don’t have to follow this pattern in your projects, and I encourage you to find ways to organize features such that they correspond to how you think about the problems you need to solve.</p>
<h1 class="heading" id="_idParaDest-279">Creating the project</h1>
<p class="normal1">Open<a id="_idIndexMarker853" class="calibre3"/> a new command prompt, navigate to a convenient location, and create a folder named <code class="inlinecode">sportsstore</code>. Navigate to the <code class="inlinecode">sportsstore</code> folder, run the command shown in <em class="italic">Listing 16.1</em> to initialize the project, and create the <code class="inlinecode">package.json</code> file.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 16.1: Initializing the project</p>
<pre class="programlisting1"><code class="hljs-con">npm init -y
</code></pre>
<h2 class="heading1" id="_idParaDest-280">Setting up the development tools</h2>
<p class="normal1">I am<a id="_idIndexMarker854" class="calibre3"/> going to start by setting up a toolchain that will monitor the TypeScript files in the project, and then compile and execute them when there is a change. Run the commands shown in <em class="italic">Listing 16.2</em> in the <code class="inlinecode">sportsstore</code> folder to install the development tool packages. </p>
<p class="packt_figref">Listing 16.2: Installing the development tool packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install --save-dev typescript@5.2.2
npm install --save-dev tsc-watch@6.0.4
npm install --save-dev nodemon@3.0.3
npm install --save-dev @tsconfig/node20
npm install --save-dev @types/node@20.6.1
</code></pre>
<p class="normal">These packages are described in <em class="italic">Table 16.2</em> for quick reference.</p>
<p class="packt_figref">Table 16.2: The development packages </p>
<table class="table-container" id="table002-13">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">typescript</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains the TypeScript compiler. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">tsc-watch</code></p>
</td>
<td class="table-cell">
<p class="normal">This package monitors the TypeScript files in a project and compiles them when there is a change. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">nodemon</code></p>
</td>
<td class="table-cell">
<p class="normal">This package monitors a wider range of file types and executes a command when a change is detected. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">@tsconfig/node20</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains a TypeScript compiler configuration file for Node.js projects. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">@types/node</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains type descriptions for the Node.js API.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Create the <code class="inlinecode">src</code> folder, and add to it a file named <code class="inlinecode">server.ts</code> with the content shown in <em class="italic">Listing 16.3</em>, which will act as a placeholder while setting up the development tools.</p>
<p class="packt_figref">Listing 16.3: The contents of the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">console.log("Hello, SportsStore");
</code></pre>
<p class="normal">To <a id="_idIndexMarker855" class="calibre3"/>configure the TypeScript compiler, add a file named <code class="inlinecode">tsconfig.json</code> to the <code class="inlinecode">sportsstore</code> folder with the content shown in <em class="italic">Listing 16.4</em>.</p>
<p class="packt_figref">Listing 16.4: The contents of the tsconfig.json file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "extends": "@tsconfig/node20/tsconfig.json",
     "compilerOptions": {                      
         "rootDir": "src/",  
         "outDir": "dist/"       
     },
     "include": ["src/**/*"]
}
</code></pre>
<p class="normal">The configuration builds on the basic settings provided by the <code class="inlinecode">@tsconfig/node20</code> package, specifying that the source files can be found in the <code class="inlinecode">src</code> folder and the compiled JavaScript files should be written to the <code class="inlinecode">src</code> folder.</p>
<p class="normal">To set up the file watchers, replace the <code class="inlinecode">scripts</code> section of the <code class="inlinecode">package.json</code> file and add the <code class="inlinecode">nodemonConfig</code> section, as shown in <em class="italic">Listing 16.5</em>.</p>
<p class="packt_figref">Listing 16.5: Setting the scripts section of the package.json file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">{
  "name": "sportsstore",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
<strong class="screentext">  "scripts": {</strong>
<strong class="screentext">    "watch": "tsc-watch --noClear --onsuccess \"node dist/server.js\"",</strong>
<strong class="screentext">    "start": "nodemon --exec npm run watch"</strong>
<strong class="screentext">  },</strong>
<strong class="screentext">  "</strong><strong class="screentext">nodemonConfig": {</strong>
<strong class="screentext">    "ext": "js,handlebars,json",</strong>
<strong class="screentext">    "ignore": ["dist/**", "node_modules/**"]</strong>
<strong class="screentext">  },</strong>
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@tsconfig/node20": "^20.1.2",
    "@types/node": "^20.6.1",
    "nodemon": "^3.0.3",
    "tsc-watch": "^6.0.4",
    "typescript": "^5.2.2"
  }
}
</code></pre>
<p class="normal">Earlier<a id="_idIndexMarker856" class="calibre3"/> chapters used only the <code class="inlinecode">tsc-watch</code> package to monitor and build TypeScript files, and restart the application when there is a change. This can be frustrating when working with other file types, such as templates, where changes do not trigger a restart. Bundler packages, such as webpack (used in <em class="italic">Chapter 7</em>), can be used to create complex build pipelines, but my preference is to combine <code class="inlinecode">tsc-watch</code> with the <code class="inlinecode">nodemon</code> package, which restarts a process when a file is changed. The <code class="inlinecode">start</code> script uses <code class="inlinecode">nodemon</code> to run <code class="inlinecode">tsc-watch</code>, which in turn starts the TypeScript compiler in watch mode. If a TypeScript file is changed, then the TypeScript compiler compiles the TypeScript files into JavaScript, which is then executed by the <code class="inlinecode">tsc-watch</code> package. If a non-TypeScript file is changed, then the <code class="inlinecode">nodemon</code> package restarts <code class="inlinecode">tsc-watch</code>, which ensures that the application is restarted. The <code class="inlinecode">nodemonConfig</code> section specifies the file extension that <code class="inlinecode">nodemon</code> reacts to and a set of directories to ignore. This is not a perfect arrangement of tools, but it is reliable and responsive, and I have had fewer problems using these packages than when trying to configure webpack, which has some limitations when dealing with TypeScript files.</p>
<p class="normal">Open a new command prompt, navigate to the <code class="inlinecode">sportsstore</code> folder, and run the command shown in <em class="italic">Listing 16.6</em> to start the build process.</p>
<pre class="programlisting1"><code class="hljs-con">Listing 16.6: Starting the build process
</code></pre>
<pre class="programlisting2"><code class="hljs-code">npm start
</code></pre>
<p class="normal">The <a id="_idIndexMarker857" class="calibre3"/>build tools will generate pure JavaScript files, which will be executed by Node.js, producing the following output:</p>
<pre class="programlisting"><code class="hljs-code">...
Hello, SportsStore
...
</code></pre>
<p class="normal">Changes to files will be detected automatically, triggering a new build and then executing the output.</p>
<h2 class="heading1" id="_idParaDest-281">Handling HTTP requests</h2>
<p class="normal1">The <a id="_idIndexMarker858" class="calibre3"/>next step is to add support to handle HTTP requests, which is the foundation for the SportsStore application and everything that it does. Run the commands shown in <em class="italic">Listing 16.7</em> in the <code class="inlinecode">sportsstore</code> folder to add the HTTP packages. </p>
<p class="packt_figref">Listing 16.7: Installing the basic application packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install express@4.18.2
npm install helmet@7.1.0
npm install --save-dev @types/express@4.17.20
</code></pre>
<p class="normal">These packages are described in <em class="italic">Table 16.3</em> for quick reference, but they provide enhancements to the basic Node.js HTTP features and set a sensible content security policy.</p>
<p class="packt_figref">Table 16.3: The HTTP handling packages </p>
<table class="table-container" id="table003-13">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">express</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains the Express HTTP framework, which was introduced in <em class="italic">Chapter 5</em>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">helmet</code></p>
</td>
<td class="table-cell">
<p class="normal">This package is used to set an HTTP content security policy, as described in <em class="italic">Chapter 7</em>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">@types/express</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains type descriptions for the Express API.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Replace the contents of the <code class="inlinecode">server.ts</code> file with the code shown in <em class="italic">Listing 16.8</em> to create a <a id="_idIndexMarker859" class="calibre3"/>basic HTTP server. (Plain HTTP will be used for development, and HTTPS will be introduced in <em class="italic">Chapter 21</em> when the application is prepared for deployment.)</p>
<p class="packt_figref">Listing 16.8: Creating a basic HTTP server in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, { Express } from "express";
import helmet from "helmet";
const port = 5000;
const expressApp: Express = express();
expressApp.use(helmet());
expressApp.use(express.json());
expressApp.use(express.urlencoded({extended: true}))
expressApp.get("/", (req, resp) =&gt; {
    resp.send("Hello, SportsStore");
})
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The new code uses Express and enables support to decode JSON and form-encoded content, using the <code class="inlinecode">json</code> and <code class="inlinecode">urlencoded</code> methods. There is a single route that handles <code class="inlinecode">GET</code> requests and responds with a string. Open a web browser, request <code class="inlinecode">http://localhost:5500</code>, and you should see the response shown in <em class="italic">Figure 16.1</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_16_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 16.1: A response from the application</p>
<h2 class="heading1" id="_idParaDest-282">Creating a configuration system</h2>
<p class="normal1">The port <a id="_idIndexMarker860" class="calibre3"/>on which the server listens for HTTP requests is hardcoded into the <code class="inlinecode">server.ts</code> file, which means that changing ports will require a new version of the application to be built and deployed. A more flexible approach is to define settings in a configuration file, which is read when the application starts and can be modified without requiring a code change.</p>
<p class="normal">Create the <code class="inlinecode">src/config</code> folder, and add to it a file named <code class="inlinecode">environment.ts</code>, with the content shown in <em class="italic">Listing 16.9</em>. </p>
<p class="packt_figref">Listing 16.9: The contents of the environment.ts file in the src/config folder</p>
<pre class="programlisting"><code class="hljs-code">export enum Env {
    Development = "development", Production = "production"
}
export const getEnvironment = () : Env =&gt; {
    const env = process.env.NODE_ENV;
    return  env === undefined || env === Env.Development
        ? Env.Development : Env.Production;
}
</code></pre>
<p class="normal">Most applications require different configurations for different environments, such as development and production. The convention for Node.js is to specify the environment using an environment variable, named <code class="inlinecode">NODE_ENV</code>. Applications can support as many environments as needed, but a minimal approach is to support development and production environments. If the <code class="inlinecode">NODE_ENV</code> variable isn’t set or has been set to <code class="inlinecode">development</code>, then the application is in the development environment. The code in <em class="italic">Listing 16.9</em> allows the environment to be read consistently, without the need for different parts of the application to inspect and interpret environment variables.</p>
<p class="normal">The <a id="_idIndexMarker861" class="calibre3"/>environment is important for a configuration system because it allows a base configuration file to be supplemented with settings that are specific to each environment. The simplest way to define configuration settings is to use the JSON format, which can be parsed into JavaScript objects at runtime. Objects read from multiple configuration files can be merged to create the overall configuration. JavaScript doesn’t have integrated support for merging objects, so add a file named <code class="inlinecode">merge.ts</code> to the <code class="inlinecode">src/config</code> folder with the content shown in <em class="italic">Listing 16.10</em>. </p>
<p class="packt_figref">Listing 16.10: The contents of the merge.ts file in the src/config folder</p>
<pre class="programlisting"><code class="hljs-code">export const merge = (target: any, source: any) : any =&gt; {
    Object.keys(source).forEach(key =&gt; {
        if (typeof source[key] === "object"
                &amp;&amp; !Array.isArray(source[key])) {
            if (Object.hasOwn(target, key)) {
                merge(target[key], source[key]);
            } else {
                Object.assign(target, source[key])
            }
        } else {
            target[key] = source[key];
        }
    });
}
</code></pre>
<p class="normal">The <code class="inlinecode">merge</code> function accepts <code class="inlinecode">source</code> and <code class="inlinecode">target</code> objects and copies the properties defined by the <code class="inlinecode">source</code> object to the <code class="inlinecode">target</code>, overriding the existing values. Next, add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">src/config</code> folder, with the content shown in <em class="italic">Listing 16.11</em>.</p>
<p class="packt_figref">Listing 16.11: The contents of the index.ts file in the src/config folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFileSync } from "fs";
import { getEnvironment, Env } from "./environment";
import { merge } from "./merge";
const file = process.env.SERVER_CONFIG ?? "server.config.json"
const data = JSON.parse(readFileSync(file).toString());
try {
    const envFile = getEnvironment().toString() + "." + file;
    const envData = JSON.parse(readFileSync(envFile).toString());
    merge(data, envData);
} catch {
    // do nothing - file doesn't exist or isn't readable
}
export const getConfig = (path: string, defaultVal: any = undefined) : any =&gt; {
    const paths = path.split(":");
    let val = data;
    paths.forEach(p =&gt; val = val[p]);
    return val ?? defaultVal;
}
export { getEnvironment, Env };
</code></pre>
<p class="normal">The <a id="_idIndexMarker862" class="calibre3"/>code in <em class="italic">Listing 16.11</em> uses an environment variable named <code class="inlinecode">SERVER_CONFIG</code> to get the name of the configuration file, falling back to <code class="inlinecode">server.config.json</code> if the variable isn’t defined. The contents of the file are read and merged with an environment-specific file, the name of which is determined by appending the current environment, such as <code class="inlinecode">production.server.config.json</code>. The <code class="inlinecode">getConfig</code> function accepts a string in the form <code class="inlinecode">http:port</code>, where keys are separated by colons (the <code class="inlinecode">:</code> character). The keys are used to navigate through the configuration data to find a value. A default value can be provided, which will be returned if a value has not been loaded from the configuration files. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Environment variables can be set on most platforms, but Node.js also supports <code class="inlinecode">.env</code> files, which can be used to set values and are loaded with the Node <code class="inlinecode">--env-file</code> argument. In <em class="italic">Chapter 21</em>, I will set environment variables as part of the containerization process used to prepare the application for deployment.</p>
</div>
<p class="normal">To start the <a id="_idIndexMarker863" class="calibre3"/>configuration, add a file named <code class="inlinecode">server.config.json</code> to the <code class="inlinecode">sportsstore</code> folder with the content shown in <em class="italic">Listing 16.12</em>.</p>
<p class="packt_figref">Listing 16.12: The contents of the server.config.json file in the SportsStore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "http": {
        "port": 5000
    }
}
</code></pre>
<p class="normal">The configuration file defines a section named <code class="inlinecode">http</code> that contains a <code class="inlinecode">port</code> setting. <em class="italic">Listing 16.13</em> updates the <code class="inlinecode">server.ts</code> file to use this configuration setting to listen to HTTP requests, with a fallback value that will be used if no configuration setting has been defined.</p>
<p class="packt_figref">Listing 16.13: Using configuration data in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, { Express } from "express";
import helmet from "helmet";
<strong class="screentext">import { getConfig } from "./config";</strong>
<strong class="screentext">const port = getConfig("http:port", 5000);</strong>
const expressApp: Express = express();
expressApp.use(helmet());
expressApp.use(express.json());
expressApp.use(express.urlencoded({extended: true}))
expressApp.get("/", (req, resp) =&gt; {
    resp.send("Hello, SportsStore");
})
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The <a id="_idIndexMarker864" class="calibre3"/>configuration file will be populated as new features are added, but the overall effect is to allow the settings used by the application to change without altering code files.</p>
<h2 class="heading1" id="_idParaDest-283">Adding application routes</h2>
<p class="normal1">As the <a id="_idIndexMarker865" class="calibre3"/>application grows, there will be a large number of HTTP routes to define and manage, so it will be useful to introduce a structure that allows related routes to be grouped and easily located. Create the <code class="inlinecode">src/routes</code> folder, and add to it a file named <code class="inlinecode">catalog.ts</code> with the content shown in <em class="italic">Listing 16.14</em>. </p>
<p class="packt_figref">Listing 16.14: The contents of the catalog.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
export const createCatalogRoutes = (app: Express) =&gt; {
    app.get("/", (req, resp) =&gt; {
        resp.send("Hello, SportsStore Route");
    })
}
</code></pre>
<p class="normal">This file will contain the routes that present a catalog of products to the user, but it contains a placeholder for now. To combine the individual route modules so that they can be applied in a single step, add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">src/routes</code> folder with the content shown in <em class="italic">Listing 16.15</em>.</p>
<p class="packt_figref">Listing 16.15: The contents of the index.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { createCatalogRoutes } from "./catalog";
export const createRoutes = (app: Express) =&gt; {
    createCatalogRoutes(app);
}
</code></pre>
<p class="normal"><em class="italic">Listing 16.16</em> uses<a id="_idIndexMarker866" class="calibre3"/> the new module to enable the routes it defines.</p>
<p class="packt_figref">Listing 16.16: Applying routes to the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, { Express } from "express";
import helmet from "helmet";
import { getConfig } from "./config";
<strong class="screentext">import { createRoutes } from "./routes";</strong>
const port = getConfig("http:port", 5000);
const expressApp: Express = express();
expressApp.use(helmet());
expressApp.use(express.json());
expressApp.use(express.urlencoded({extended: true}))
<strong class="screentext">// expressApp.get("/", (req, resp) =&gt; {</strong>
<strong class="screentext">//     resp.send("Hello, SportsStore");</strong>
<strong class="screentext">// })</strong>
<strong class="screentext">createRoutes(expressApp);</strong>
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">Use a web browser request, <code class="inlinecode">http://localhost:5000</code>, and you will see the response shown in <em class="italic">Figure 16.2</em>, which shows the response has been generated by the <a id="_idIndexMarker867" class="calibre3"/>request handler defined in <em class="italic">Listing 16.14</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_16_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 16.2: The effect of a separate module for routes</p>
<h2 class="heading1" id="_idParaDest-284">Adding support for HTML templates</h2>
<p class="normal1">HTML templates<a id="_idIndexMarker868" class="calibre3"/> will be used to render the content presented to the user. Run the commands shown in <em class="italic">Listing 16.17</em> in the <code class="inlinecode">sportsstore</code> folder to install the packages required to support templates. </p>
<p class="packt_figref">Listing 16.17: Installing template packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install bootstrap@5.3.2
npm install handlebars@4.7.8
npm install express-handlebars@7.1.2
</code></pre>
<p class="normal">These packages are described in <em class="italic">Table 16.4</em> for quick reference.</p>
<p class="packt_figref">Table 16.4: The template packages </p>
<table class="table-container" id="table004-9">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">bootstrap</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains CSS stylesheets that are used to style the HTML content produced by the application. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">handlebars</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains the Handlebars template engine, which was introduced in <em class="italic">Chapter 10</em>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">express-handlebars</code></p>
</td>
<td class="table-cell">
<p class="normal">This package integrates the Handlebars template engine with the Express package.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">As explained in <em class="italic">Chapter 10</em>, the templates rendered by the Handlebars package rely on helper functions instead of including code expressions. Create the <code class="inlinecode">src/helpers</code> folder, and add to it a file named <code class="inlinecode">env.ts</code> with the content shown in <em class="italic">Listing 16.18</em>. </p>
<p class="packt_figref">Listing 16.18: The contents of the env.ts file in the src/helpers folder</p>
<pre class="programlisting"><code class="hljs-code">import { Env, getEnvironment } from "../config";
export const isDevelopment = (value: any) =&gt; {
    return getEnvironment() === Env.Development
}
</code></pre>
<p class="normal">The <code class="inlinecode">isDevelopment</code> helper <a id="_idIndexMarker869" class="calibre3"/>can be used to determine whether the application has been configured for development or production. To set up the template system, add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">src/helpers</code> folder with the content shown in <em class="italic">Listing 16.19</em>.</p>
<p class="packt_figref">Listing 16.19. The contents of the index.ts file in the src/helpers folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { getConfig } from "../config";
import { engine } from "express-handlebars";
import * as env_helpers from "./env";
const location = getConfig("templates:location");
const config = getConfig("templates:config");
export const createTemplates = (app: Express) =&gt; {
    app.set("views", location);
    app.engine("handlebars", engine({
        ...config, helpers: {...env_helpers }
    }));
    app.set("view engine", "handlebars");
}
</code></pre>
<p class="normal">The <code class="inlinecode">createTemplates</code> function configures the template engine and registers it with Express. Add the settings to the configuration file, as shown in <em class="italic">Listing 16.20</em>.</p>
<p class="packt_figref">Listing 16.20: Adding settings to the server.config.json file in the SportsStore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "http": {
        "port": 5000
    },
    <strong class="screentext">"templates": {</strong>
<strong class="screentext">        "location": "templates",</strong>
<strong class="screentext">        "config": {</strong>
<strong class="screentext">            "layoutsDir": "templates",</strong>
<strong class="screentext">            "defaultLayout":</strong><strong class="screentext"> "main_layout.handlebars",</strong>
<strong class="screentext">            "partialsDir": "templates"</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal">The <code class="inlinecode">getConfig</code> function defined in <em class="italic">Listing 16.11</em> can be used to get entire configuration <a id="_idIndexMarker870" class="calibre3"/>sections, as well as individual values, and these sections can be used to directly configure packages. This statement is used to get a configuration section:</p>
<pre class="programlisting"><code class="hljs-code">...
const <strong class="screentext">config</strong> = getConfig("templates:config");
...
</code></pre>
<p class="normal">The result is an object whose properties correspond to the <code class="inlinecode">templates:config</code> section of the configuration file, which has been parsed from JSON into a JavaScript object and is used to configure the template engine:</p>
<pre class="programlisting"><code class="hljs-code">...
app.engine("handlebars", engine({
    ...<strong class="screentext">config</strong>, helpers: {...env_helpers }
}));
...
</code></pre>
<p class="normal">The properties read from the configuration file are combined with the helper functions imported from the <code class="inlinecode">helpers</code> module.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal"><em class="italic">Listing 16.20</em> configures the template engine so that templates, partials, and layouts are all in the same folder. This is not a requirement, but I prefer to keep the files together and use the filename to indicate the content rendered by a template.</p>
</div>
<h3 class="heading2" id="_idParaDest-285">Creating layouts and templates</h3>
<p class="normal1">Create<a id="_idIndexMarker871" class="calibre3"/> the <code class="inlinecode">sportsstore/templates</code> folder, and add to it a file named <code class="inlinecode">index.handlebars</code> with the<a id="_idIndexMarker872" class="calibre3"/> placeholder contents shown in <em class="italic">Listing 16.21</em>.</p>
<p class="packt_figref">Listing 16.21: The contents of the index.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="h4 m-2"&gt;Hello, SportsStore&lt;/div&gt;
</code></pre>
<p class="normal">Add a file named <code class="inlinecode">main_layout.handlebars</code> to the templates folder with the content shown in <em class="italic">Listing 16.22</em>.</p>
<p class="packt_figref">Listing 16.22: The contents of the main_layout.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link href="/css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="bg-dark text-white p-2"&gt;
            &lt;span class="navbar-brand ml-2"&gt;SPORTS STORE&lt;/span&gt;
        &lt;/div&gt;
        {{{ body }}}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The layout contains an HTML document that includes a <code class="inlinecode">link</code> element for the CSS stylesheet from the <code class="inlinecode">Bootstrap</code> package and a <em class="italic">SportsStore</em> header. <em class="italic">Listing 16.23</em> completes the setup for the templates.</p>
<p class="packt_figref">Listing 16.23: Completing the template setup in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, { Express } from "express";
import helmet from "helmet";
import { getConfig } from "./config";
import { createRoutes } from "./routes";
i<strong class="screentext">mport { createTemplates } from "./helpers";</strong>
const port = getConfig("http:port", 5000);
const expressApp: Express = express();
expressApp.use(helmet());
expressApp.use(express.json());
expressApp.use(express.urlencoded({extended: true}))
<strong class="screentext">expressApp.use(express.static("node_modules/bootstrap/dist"));</strong>
<strong class="screentext">createTemplates(expressApp);</strong>
createRoutes(expressApp);
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">In <a id="_idIndexMarker873" class="calibre3"/>addition to calling the <code class="inlinecode">createTemplates</code> function, <em class="italic">Listing 16.23</em> uses the Express <code class="inlinecode">static</code> middleware to serve content <a id="_idIndexMarker874" class="calibre3"/>from the Bootstrap package. <em class="italic">Listing 16.24</em> uses a template to render a response instead of returning a plain string.</p>
<p class="packt_figref">Listing 16.24: Using a template in the catalog.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
export const createCatalogRoutes = (app: Express) =&gt; {
    app.get("/", (req, resp) =&gt; {
        <strong class="screentext">//resp.send("Hello, SportsStore Route");</strong>
<strong class="screentext">        resp.render("index");</strong>
    })
}
</code></pre>
<p class="normal">Use a <a id="_idIndexMarker875" class="calibre3"/>browser<a id="_idIndexMarker876" class="calibre3"/> to request <code class="inlinecode">http://localhost:5000</code>, and you will see the response shown in <em class="italic">Figure 16.3</em>, which is produced using a template and a layout.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_16_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 16.3: Adding layouts to the application</p>
<h2 class="heading1" id="_idParaDest-286">Creating error handlers</h2>
<p class="normal1">Express <a id="_idIndexMarker877" class="calibre3"/>includes support to generate responses when a request is made for a URL for which there is no handler, or when a handler throws an error. To demonstrate the default error handlers and prepare for custom replacements, <em class="italic">Listing 16.25</em> defines routes that always create errors. </p>
<p class="packt_figref">Listing 16.25: Creating errors in the catalog.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
export const createCatalogRoutes = (app: Express) =&gt; {
    app.get("/", (req, resp) =&gt; {
        resp.render("index");
    })
    <strong class="screentext">app.get("/err", (req, resp) =&gt; {</strong>
<strong class="screentext">        throw new Error ("Something bad happened");</strong>
<strong class="screentext">    });</strong>
<strong class="screentext"> </strong>
<strong class="screentext">    app.get("/asyncerr"</strong><strong class="screentext">, async (req, resp) =&gt; {</strong>
<strong class="screentext">        throw new Error ("Something bad happened asynchronously");</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">Use a <a id="_idIndexMarker878" class="calibre3"/>browser to request <code class="inlinecode">http://localhost:5000/nosuchfile</code>, and you will see the default response created by Express, which is shown on the left side of <em class="italic">Figure 16.3</em>. This error is shown when no handler generates a response. Use a browser to request <code class="inlinecode">http://localhost:5000/err</code>, and you will see the other error message shown in <em class="italic">Figure 16.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_16_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 16.4: A default Express error message</p>
<p class="normal">The handler for errors doesn’t deal with errors thrown by asynchronous handlers. You can see the problem by requesting <code class="inlinecode">http://localhost:5000/asyncerr</code>. A stack trace will be written at the Node.js console, but no response is sent to the browser, which will eventually assume that the application has refused to accept the HTTP request.</p>
<p class="normal">There is an <a id="_idIndexMarker879" class="calibre3"/>excellent package that adds support for errors in asynchronous handlers. Run the command shown in <em class="italic">Listing 16.26</em> in the <code class="inlinecode">sportsstore</code> folder to add the package, which is called <code class="inlinecode">express-async-errors</code>, to the project.</p>
<p class="packt_figref">Listing 16.26: Adding the asynchronous error package</p>
<pre class="programlisting1"><code class="hljs-con">npm install express-async-errors@3.1.1
</code></pre>
<p class="normal">For quick reference, this package is described in <em class="italic">Table 16.5</em>.</p>
<p class="packt_figref">Table 16.5: The errors package</p>
<table class="table-container" id="table005-8">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">express-async-errors</code></p>
</td>
<td class="table-cell">
<p class="normal">This package adds support to process errors produced by asynchronous request handlers. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The custom error handlers will use templates to display formatted responses. Add a file named <code class="inlinecode">not_found.handlebars</code> to the <code class="inlinecode">templates</code> folder with the content shown in <em class="italic">Listing 16.27</em>.</p>
<p class="packt_figref">Listing 16.27: The contents of the not_found.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="h2 bg-danger text-white text-center p-2 my-2"&gt;
    404 - Not Found
&lt;/div&gt;
&lt;div class="text-center"&gt;
    &lt;a class="btn btn-secondary" href="/"&gt;OK&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">This template will be rendered when a request isn’t matched by a route. It doesn’t include any dynamic content, but it will be displayed within the default layout. Next, add a file named <code class="inlinecode">error.handlebars</code> to the <code class="inlinecode">templates</code> folder with the content shown in <em class="italic">Listing 16.28</em>.</p>
<p class="packt_figref">Listing 16.28: The contents of the error.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="h2 bg-danger text-white text-center p-2 my-2"&gt;
    500 - Error
&lt;/div&gt;
&lt;div class="text-center"&gt;
    &lt;a class="btn btn-secondary" href="/"&gt;OK&lt;/a&gt;
&lt;/div&gt;
{{#if (isDevelopment) }}
    &lt;div class="h4 bg-danger text-white p-1 mt-2"&gt;Error Details&lt;/div&gt;
    &lt;div class="h5 p-1"&gt;Message: {{ error.message }}&lt;/div&gt;
    &lt;div class="font-monospace p-1"&gt;{{error.stack}}&lt;/div&gt;
 {{/if }}
</code></pre>
<p class="normal">This <a id="_idIndexMarker880" class="calibre3"/>template uses the <code class="inlinecode">isDevelopment</code> helper to include details of the error when the application is configured in the development environment. <em class="italic">Listing 16.29</em> adds a new configuration section that specifies the error template files.</p>
<p class="packt_figref">Listing 16.29: Adding a configuration section to the server.config.json file in the SportsStore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "http": {
        "port": 5000
    },
    "templates": {
        "location": "templates",
        "config": {
            "layoutsDir": "templates",
            "defaultLayout": "main_layout.handlebars",
            "partialsDir": "templates"
        }
    },
   <strong class="screentext"> "errors": {</strong>
<strong class="screentext">        "400": "not_found",</strong>
<strong class="screentext">        "500": "error"</strong>
<strong class="screentext">    }   </strong>
}
</code></pre>
<p class="normal">Add a file named <code class="inlinecode">errors.ts</code> to the <code class="inlinecode">src</code> folder with the content shown in <em class="italic">Listing 16.30</em>. This file imports the <code class="inlinecode">express-async-errors</code> module, which is all that’s required to use the package, and defines error handlers that use templates to generate<a id="_idIndexMarker881" class="calibre3"/> responses.</p>
<p class="packt_figref">Listing 16.30: The contents of the errors.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, ErrorRequestHandler } from "express";
import { getConfig } from "./config";
import "express-async-errors";
const template400 = getConfig("errors:400");
const template500 = getConfig("errors:500");
export const createErrorHandlers = (app: Express) =&gt; {
    app.use((req, resp) =&gt; {
        resp.statusCode = 404;
        resp.render(template400);
    });
    const handler: ErrorRequestHandler = (error, req, resp, next) =&gt; {
        console.log(error);
        if (resp.headersSent) {
            return next(error);
        }
        try {
            resp.statusCode = 500;
            resp.render(template500, { error} );
        } catch (newErr) {
            next(error);
        }
    }
    app.use(handler);
}
</code></pre>
<p class="normal">The <code class="inlinecode">createErrorHandlers</code> function sets up a request handler that will generate a 404 response, and that will be the last handler to run when a request is received. There is also an error handler, which works like a middleware component but with an additional <code class="inlinecode">error</code> parameter. There is a danger that something will go wrong when rendering an error response, in which case the default error handler will be used. To prevent the new error from being the one displayed to the user, a try/catch block is used, and the <code class="inlinecode">catch</code> clause invokes the <code class="inlinecode">next</code> method using the original error, which tells Express which error needs to be processed.</p>
<p class="normal">To <a id="_idIndexMarker882" class="calibre3"/>complete the setup, <em class="italic">Listing 16.31</em> calls the <code class="inlinecode">createErrorHandlers</code> function as part of the application startup.</p>
<p class="packt_figref">Listing 16.31: Setting up error handlers in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, { Express } from "express";
import helmet from "helmet";
import { getConfig } from "./config";
import { createRoutes } from "./routes";
import { createTemplates } from "./helpers";
<strong class="screentext">import { createErrorHandlers } from "./errors";</strong>
const port = getConfig("http:port", 5000);
const expressApp: Express = express();
expressApp.use(helmet());
expressApp.use(express.json());
expressApp.use(express.urlencoded({extended: true}))
expressApp.use(express.static("node_modules/bootstrap/dist"));
createTemplates(expressApp);
createRoutes(expressApp);
<strong class="screentext">createErrorHandlers</strong><strong class="screentext">(expressApp);</strong>
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">Save the changes, and use a browser to request <code class="inlinecode">http://localhost:5000/nosuchfile</code>, <code class="inlinecode">http://localhost:5000/err</code>, and <code class="inlinecode">http://localhost:5000/asyncerr</code>. Asynchronous errors are now handled correctly, and users will <a id="_idIndexMarker883" class="calibre3"/>see the custom error responses, which are shown in <em class="italic">Figure 16.5</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_16_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 16.5: Custom error responses</p>
<h1 class="heading" id="_idParaDest-287">Starting the data model</h1>
<p class="normal1">Once the<a id="_idIndexMarker884" class="calibre3"/> basic building blocks are in place, it is time to start working on the data model. For the SportsStore <a id="_idIndexMarker885" class="calibre3"/>application, the key data is a catalog of products from which customers will make selections. Run the commands shown in <em class="italic">Listing 16.32</em> in the <code class="inlinecode">sportsstore</code> folder to install the data storage packages. </p>
<p class="packt_figref">Listing 16.32: Adding data storage packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install sqlite3@5.1.6
npm install sequelize@6.35.1
</code></pre>
<p class="normal">For quick reference, these packages are described in <em class="italic">Table 16.6</em>. I am going to use SQLite during development because it is easy to set up and then change to PostgreSQL, which is a more conventional database server, in <em class="italic">Chapter 21</em> to prepare for deployment.</p>
<p class="packt_figref">Table 16.6: The data packages </p>
<table class="table-container" id="table006-6">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">sqlite3</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains the SQLite database manager, which stores its data in a file and was first used in <em class="italic">Chapter 12</em>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">sequelize</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains the <code class="inlinecode">Sequelize</code> ORM framework, which maps between relational data and JavaScript objects and was introduced in <em class="italic">Chapter 12</em>. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal">There<a id="_idIndexMarker886" class="calibre3"/> are different ways to create data models for web applications. As I explained in <em class="italic">Chapter 12</em>, I like to use a <a id="_idIndexMarker887" class="calibre3"/>repository that allows the details of how the data is stored to be hidden from the rest of the application. Create the <code class="inlinecode">src/data</code> folder, and add to it a file named <code class="inlinecode">catalog_models.ts</code> file with the content shown in <em class="italic">Listing 16.33</em>.</p>
<p class="packt_figref">Listing 16.33: The contents of the catalog_models.ts file in the src/data folder</p>
<pre class="programlisting"><code class="hljs-code">export interface  Product {
    id?: number;
    name: string;
    description: string;
    price: number;
   
    category?: Category;
    supplier?: Supplier;
}
export interface Category {
    id?: number;
    name: string;
    products?: Product[];
}
export interface Supplier {
    id?: number;
    name: string;
   
    products?: Product[];
}
</code></pre>
<p class="normal">This file defines three model interfaces that provide the building blocks for a basic product catalog. A real online store would have a more complex data model, but<a id="_idIndexMarker888" class="calibre3"/> much of the additional complexity relates to external processes, such as procurement, dispatch, customer service, and so on, which won’t be part of the <em class="italic">SportsStore</em> application. These<a id="_idIndexMarker889" class="calibre3"/> three interfaces in <em class="italic">Listing 16.33</em> are enough to get started. To describe a repository, add a file named <code class="inlinecode">catalog_repository.ts</code> to the <code class="inlinecode">src/data</code> folder, with the content shown in <em class="italic">Listing 16.34</em>.</p>
<p class="packt_figref">Listing 16.34: The contents of the catalog_repository.ts file in the src/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { Category, Product, Supplier } from "./catalog_models";
export interface CatalogRepository {
    getProducts(): Promise&lt;Product[]&gt;;
    storeProduct(p: Product): Promise&lt;Product&gt;;
    getCategories() : Promise&lt;Category[]&gt;;
    storeCategory(c: Category): Promise&lt;Category&gt;;
    getSuppliers(): Promise&lt;Supplier[]&gt;;
    storeSupplier(s: Supplier): Promise&lt;Supplier&gt;;
}
</code></pre>
<p class="normal">The <code class="inlinecode">CatalogRepository</code> interface defines methods to query and store objects that implement the <code class="inlinecode">Product</code>, <code class="inlinecode">Category</code>, and <code class="inlinecode">Supplier</code> interfaces.</p>
<h2 class="heading1" id="_idParaDest-288">Implementing the repository</h2>
<p class="normal1">The <a id="_idIndexMarker890" class="calibre3"/>use of a repository means that the details of how data is stored don’t have to align with how data is used by the rest of the application. In <em class="italic">Chapter 12</em>, for example, I used a set of conversion functions to convert the data read from the database into the format expected by the rest of the application. This works well because it means that the application gets data in a format that is natural to work with, and the repository gets data that is easily stored and queried. The downside is that data must be transformed as it passes between the repository and the rest of the application.</p>
<p class="normal">An <a id="_idIndexMarker891" class="calibre3"/>alternative approach is to implement the repository so that it stores data without transformation, ensuring that the results of querying the database, for example, are objects whose type matches the expectations of the rest of the application. This approach doesn’t require conversion functions, but it can require some effort to override the default behavior of the ORM package. This is the approach that I am going to take for the SportsStore application.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">This isn’t an issue if you are using an object database, such as MongoDB, or if you are writing native SQL queries without using an ORM package. However, as noted in <em class="italic">Chapter 12</em>, relational databases are used by the majority of projects, and ORM packages allow developers to perform complex queries without needing deep SQL knowledge.</p>
</div>
<p class="normal">To get started, create the <code class="inlinecode">src/data/orm/models</code> folder, and add to it a file named <code class="inlinecode">catalog_models.ts</code>, with the content shown in <em class="italic">Listing 16.35</em>.</p>
<p class="packt_figref">Listing 16.35: The contents of the catalog_models.ts file in the src/data/orm/models folder</p>
<pre class="programlisting"><code class="hljs-code">import { Model, CreationOptional, ForeignKey, InferAttributes,
    InferCreationAttributes  } from "sequelize";
export class ProductModel extends Model&lt;InferAttributes&lt;ProductModel&gt;,
        InferCreationAttributes&lt;ProductModel&gt;&gt; {
    declare id?: CreationOptional&lt;number&gt;;
    declare name: string;
    declare description: string;
    declare price: number;
    declare categoryId: ForeignKey&lt;CategoryModel["id"]&gt;;
    declare supplierId: ForeignKey&lt;SupplierModel["id"]&gt;;
    declare category?: InferAttributes&lt;CategoryModel&gt;
    declare supplier?: InferAttributes&lt;SupplierModel&gt;
}
export class CategoryModel extends Model&lt;InferAttributes&lt;CategoryModel&gt;,
        InferCreationAttributes&lt;CategoryModel&gt;&gt;   {
    declare id?: CreationOptional&lt;number&gt;;
    declare name: string;
   
    declare products?:  InferAttributes&lt;ProductModel&gt;[];
}
export class SupplierModel extends Model&lt;InferAttributes&lt;SupplierModel&gt;,
        InferCreationAttributes&lt;SupplierModel&gt;&gt;  {
    declare id?: CreationOptional&lt;number&gt;;  
    declare name: string;
    declare products?:  InferAttributes&lt;ProductModel&gt;[];
}
</code></pre>
<p class="normal">The <code class="inlinecode">ProductModel</code>, <code class="inlinecode">CategoryModel</code>, and <code class="inlinecode">SupplierModel</code> classes conform to the interfaces<a id="_idIndexMarker892" class="calibre3"/> defined in <em class="italic">Listing 16.33</em>, with some additions required for storage in a relational database, which means that the objects created by the ORM package will have a superset of the properties expected by the rest of the application – notably, the <code class="inlinecode">categoryId</code> and <code class="inlinecode">supplierId</code> properties defined by the <code class="inlinecode">ProductModel</code> class, which represent relationships between tables in the database.</p>
<p class="normal">To describe the format and relationships between the model classes, add a file named <code class="inlinecode">catalog_helpers.ts</code> to the <code class="inlinecode">src/data/orm/models</code> folder <a id="_idIndexMarker893" class="calibre3"/>with the content shown in <em class="italic">Listing 16.36</em>.</p>
<div><p class="normal"><strong class="screentext">The iterative process of defining a data model</strong></p>
<p class="normal">Figuring out the <code class="inlinecode">Sequelize</code> configuration for this example took a couple of hours of trial and error, which is not easily conveyed in the linear progression shown by a book example. I wrote the code in <em class="italic">Listing 16.35</em> at the same time as the initial implementation of the repository. This allowed me to make sure that the data storage and queries worked as expected, and to reset the database each time I made a change.</p>
<p class="normal">There are two challenges in this process: ensuring that the database schema makes sense and that results conform to the model interfaces.</p>
<p class="normal">To check the schema, I use the excellent DB Browser for SQLite (<a href="https://sqlitebrowser.org" class="calibre3">https://sqlitebrowser.org</a>) package, which allows SQLite databases to be opened and inspected. This allows me to check that I have configured <code class="inlinecode">Sequelize</code> to correctly create the relationships between tables, and it also allows me to check that data is written as it should be.</p>
<p class="normal">To check that data objects are created correctly, I query the database and write out the results as JSON data. This reveals the structure of the objects created by <code class="inlinecode">Sequelize</code> and lets me see how columns in the database are represented as JavaScript object properties.</p>
<p class="normal">Once you have confirmed that <code class="inlinecode">Sequelize</code> creates data objects correctly, the final step is to make sure that you have described those objects accurately with the <code class="inlinecode">declare</code> keyword. Bear in mind that the TypeScript annotations applied to the model classes are not used by <code class="inlinecode">Sequelize</code> and only exist so that the TypeScript compiler can check the way that data is used. The type annotations have no effect at runtime because <code class="inlinecode">Sequelize</code> creates objects dynamically, so it is important to confirm that the data is stored and retrieved as you intended and that the type annotations correctly describe those processes.</p>
</div>
<div><p class="normal">This can be a time-consuming process – and for some, it is an argument in favor of object databases – but working methodically and checking the results after each change will keep you on the right path.</p>
</div>
<p class="packt_figref">Listing 16.36: The contents of the catalog_helpers.ts file in the src/data/orm/models folder</p>
<pre class="programlisting"><code class="hljs-code">import { DataTypes, Sequelize } from "sequelize";
import { CategoryModel, ProductModel, SupplierModel } from "./catalog_models";
const primaryKey = {
    id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true }
};
export const initializeCatalogModels = (sequelize: Sequelize) =&gt; {
    ProductModel.init({
        ...primaryKey,
        name: { type: DataTypes.STRING},       
        description: { type: DataTypes.STRING},
        price: { type: DataTypes.DECIMAL(10, 2) }
    }, { sequelize })
    CategoryModel.init({
        ...primaryKey,
        name: { type: DataTypes.STRING}
    }, { sequelize });
    SupplierModel.init({
        ...primaryKey,
        name: { type: DataTypes.STRING}
    }, { sequelize})
    ProductModel.belongsTo(CategoryModel,
        { foreignKey: "categoryId", as: "category"});   
    ProductModel.belongsTo(SupplierModel,
        { foreignKey: "supplierId", as: "supplier"});
    CategoryModel.hasMany(ProductModel,
        { foreignKey: "categoryId", as: "products"});
    SupplierModel.hasMany(ProductModel,
        { foreignKey: "supplierId", as: "products"});
}
</code></pre>
<p class="normal">The <code class="inlinecode">initializeCatalogModels</code> function accepts a <code class="inlinecode">Sequelize</code> object, which is used to initialize the model classes and create the relationships between them. The <code class="inlinecode">belongsTo</code> and <code class="inlinecode">hasMany</code> methods used to create the relationships between models accept a configuration object, which is used to override the default names used for the foreign key and association properties.</p>
<p class="normal">To <a id="_idIndexMarker894" class="calibre3"/>complete the initial ORM models, add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">src/data/orm/models</code> folder with the content shown in <em class="italic">Listing 16.37</em>.</p>
<p class="packt_figref">Listing 16.37: The contents of the index.ts file in the src/data/orm/models folder</p>
<pre class="programlisting"><code class="hljs-code">import { Sequelize } from "sequelize";
import { initializeCatalogModels } from "./catalog_helpers";
export { ProductModel, CategoryModel, SupplierModel } from "./catalog_models";
export const initializeModels = (sequelize: Sequelize) =&gt; {
    initializeCatalogModels(sequelize);
}
</code></pre>
<p class="normal">This file will be updated as new model classes are created and will help organize the features required for different parts of the application.</p>
<h3 class="heading2" id="_idParaDest-289">Creating the repository class</h3>
<p class="normal1">My <a id="_idIndexMarker895" class="calibre3"/>preference for repositories is to break up the code into smaller sections that are more easily maintained. This is purely a matter of personal style, but I don’t like large code files, and I am willing to accept some degree of complexity if I can split up something like a repository into more manageable pieces.</p>
<p class="normal">The way that JavaScript supports this style of development is called <em class="italic">mixins</em>, where classes are defined as function results, which allows complex functionality to be built up piece by piece. To start the implementation of the repository, add a file named <code class="inlinecode">core.ts</code> to the <code class="inlinecode">src/data/orm</code> folder, with the content shown in <em class="italic">Listing 16.38</em>.</p>
<p class="packt_figref">Listing 16.38: The contents of the core.ts file in the src/data/orm folder</p>
<pre class="programlisting"><code class="hljs-code">import { Sequelize } from "sequelize";
import { getConfig } from "../../config";
import { initializeModels, CategoryModel, ProductModel, SupplierModel }
    from "./models";
import { readFileSync } from "fs";
const config = getConfig("catalog:orm_repo");
const logging = config.logging
        ? { logging: console.log, logQueryParameters: true}
        : { logging: false };
export class BaseRepo {
    sequelize: Sequelize;
   
    constructor() {
        this.sequelize = new Sequelize({ ...config.settings, ...logging })
        this.initModelsAndDatabase();
    }
    async initModelsAndDatabase() : Promise&lt;void&gt; {
        initializeModels(this.sequelize);
        if (config.reset_db) {
            await this.sequelize.drop();
            await this.sequelize.sync();
            await this.addSeedData();
        } else {
            await this.sequelize.sync();           
        }
    }   
    async addSeedData() {
        const data = JSON.parse(readFileSync(config.seed_file).toString());
        await this.sequelize.transaction(async (transaction) =&gt; {
            await SupplierModel.bulkCreate(data.suppliers, { transaction });
            await CategoryModel.bulkCreate(data.categories, { transaction });
            await ProductModel.bulkCreate(data.products, { transaction });
        });
    }   
}
export type Constructor&lt;T = {}&gt; = new (...args: any[]) =&gt; T;
</code></pre>
<p class="normal">The <code class="inlinecode">BaseRepo</code> class <a id="_idIndexMarker896" class="calibre3"/>is responsible for configuring <code class="inlinecode">Sequelize</code>, which is done by reading a configuration section, appending the logging settings, and invoking the constructor. There is an <code class="inlinecode">initModelsAndDatabase</code> model that calls the <code class="inlinecode">initializeModels</code> function and, if configured, resets the database and invokes the <code class="inlinecode">addSeedData</code> method to populate the database with seed data. The <code class="inlinecode">addSeedData</code> method reads a JSON data file and uses the <code class="inlinecode">Sequelize</code> <code class="inlinecode">bulkCreate</code> method to store multiple objects in a single operation, which is a good way to populate the database. The last statement in <em class="italic">Listing 16.38</em> defines a type that will be used to create the <code class="inlinecode">mixin</code> and represents a type that can be instantiated with the <code class="inlinecode">new</code> keyword.</p>
<p class="normal">The next step is to define the query features. Add a file named <code class="inlinecode">queries.ts</code> to the <code class="inlinecode">src/data/orm</code> folder with the content shown in <em class="italic">Listing 16.39</em>.</p>
<p class="packt_figref">Listing 16.39: The contents of the queries.ts file in the src/data/orm folder</p>
<pre class="programlisting"><code class="hljs-code">import { CategoryModel, ProductModel, SupplierModel } from "./models";
import { BaseRepo, Constructor } from "./core"
export function AddQueries&lt;TBase extends Constructor&lt;BaseRepo&gt;&gt;(Base: TBase) {
    return class extends Base {
        getProducts() {
            return ProductModel.findAll({
                include: [
                    {model: SupplierModel, as: "supplier" },
                    {model: CategoryModel, as: "category"}],
                raw: true, nest: true
            });
        }
   
        getCategories() {
            return CategoryModel.findAll({
                raw: true, nest: true
            })
        }
   
        getSuppliers() {
            return SupplierModel.findAll({
                raw: true, nest:true
            });
        }       
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">AddQueries</code> function accepts a base class and returns a new class that adds the <code class="inlinecode">getProducts</code>, <code class="inlinecode">getCategories</code>, and <code class="inlinecode">getSuppliers</code> methods. The <code class="inlinecode">getProducts</code> method includes associated data in its query, and the <code class="inlinecode">model</code> and <code class="inlinecode">as</code> properties are required to match the configuration in <em class="italic">Listing 16.36</em>, where the default property names used by <code class="inlinecode">Sequelize</code> were overridden so that query results conformed to the data model interfaces.</p>
<p class="normal">All of the <a id="_idIndexMarker897" class="calibre3"/>query methods are configured with the <code class="inlinecode">raw</code> and <code class="inlinecode">nest</code> options set to <code class="inlinecode">true</code>. The objects created by <code class="inlinecode">Sequelize</code> cannot be used directly with the Handlebars template engine, which places restrictions on how properties are defined. The <code class="inlinecode">Sequelize</code> object appears like a regular JavaScript object, but values are presented in a way that allows for changes to be tracked so that the database can be updated, which is contrary to the expectations Handlebars has for the data it processes. The <code class="inlinecode">raw</code> option tells <code class="inlinecode">Sequelize</code> not to process the data it receives, which means that simple data objects are created. The <code class="inlinecode">nest</code> option ensures that nested values, such as those produced for associated data, are presented as nested data objects.</p>
<p class="normal">These configuration settings were not required in <em class="italic">Part 2</em> of this book because conversion functions were used, which meant that the objects created by <code class="inlinecode">Sequelize</code> were not the ones consumed by the template engine. Using the <code class="inlinecode">raw</code> setting works when the structure of the data read from the database naturally matches the data structure the application requires, which depends on the query being executed. For queries with complex associations between data – of which there are examples in later chapters – the <code class="inlinecode">raw</code> keyword will produce results that cannot be used directly, and in these cases, the best approach is to allow <code class="inlinecode">Sequelize</code> to process the results, and then use the <code class="inlinecode">toJSON</code> method that is inherited by all <code class="inlinecode">Sequelize</code> model objects to create simple objects that can be used with templates.</p>
<p class="normal">The<a id="_idIndexMarker898" class="calibre3"/> generic type arguments used to describe the <code class="inlinecode">AddQueries</code> function allow TypeScript to understand that the result combines the features defined by the base class, plus the new methods. As noted previously, working this way is not required, but it does allow small amounts of related functionality to be defined in a way that is easy to maintain and combined to produce a more complex component.</p>
<p class="normal">To implement the repository storage methods, add a file named <code class="inlinecode">storage.ts</code> to the <code class="inlinecode">src/data/orm</code> folder, with the content shown in <em class="italic">Listing 16.40</em>.</p>
<p class="packt_figref">Listing 16.40: The contents of the storage.ts file in the src/data/orm folder</p>
<pre class="programlisting"><code class="hljs-code">import { Transaction } from "sequelize";
import { Category, Product, Supplier } from "../catalog_models";
import { CategoryModel, ProductModel, SupplierModel } from "./models";
import { BaseRepo, Constructor } from "./core"
export function AddStorage&lt;TBase extends Constructor&lt;BaseRepo&gt;&gt;(Base: TBase)  {
    return class extends Base {
        storeProduct(p: Product) {
            return  this.sequelize.transaction(async (transaction) =&gt; {
   
                if (p.category) {
                    p.category = await this.storeCategory(p.category)
                }
                if (p.supplier) {
                    p.supplier = await this.storeSupplier(p.supplier);
                }
               
                const [stored] = await ProductModel.upsert({
                    id: p.id, name: p.name, description: p.description,
                    price: p.price, categoryId: p.category?.id,
                    supplierId: p.supplier?.id
                }, { transaction });
                return stored;
            });
        }
   
        async storeCategory(c: Category, transaction?: Transaction) {
            const [stored] = await CategoryModel.upsert({
                id: c.id, name: c.name
            }, { transaction});
            return stored;
        }
   
        async storeSupplier(s: Supplier, transaction?: Transaction) {
            const [stored] = await SupplierModel.upsert({
                id: s.id, name: s.name
            }, {transaction});
            return stored;
        }      
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">storeCategory</code> and <code class="inlinecode">storeSupplier</code> methods define optional parameters that allow <a id="_idIndexMarker899" class="calibre3"/>operations to be included in a transaction. Because these parameters are optional, these methods are valid implementations of the ones defined by the repository interface. The <code class="inlinecode">storeProduct</code> method uses the transaction parameter to ensure that data is written atomically, and the use of the mixin means that the <code class="inlinecode">sequelize</code> property defined in <em class="italic">Listing 16.38</em> is accessible in <em class="italic">Listing 16.40</em>. All three methods use the <code class="inlinecode">upsert</code> method to create or update data if it already exists, which means they can be used to both store and update data.</p>
<p class="normal">To combine the three parts of the mixin into a single class, add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">src/data/orm</code> folder with the content shown in <em class="italic">Listing 16.41</em>.</p>
<p class="packt_figref">Listing 16.41: The contents of the index.ts file in the src/data/orm folder</p>
<pre class="programlisting"><code class="hljs-code">import { CatalogRepository } from "../catalog_repository";
import { BaseRepo } from "./core";
import { AddQueries } from "./queries";
import { AddStorage } from "./storage";
const RepoWithQueries = AddQueries(BaseRepo);
const CompleteRepo = AddStorage(RepoWithQueries);
export const CatalogRepoImpl = CompleteRepo;
</code></pre>
<p class="normal">The <a id="_idIndexMarker900" class="calibre3"/>process of creating a mixin starts by calling the function that adds the query methods to the <code class="inlinecode">BaseRepo</code> class, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
const RepoWithQueries = <strong class="screentext">AddQueries</strong>(BaseRepo);
...
</code></pre>
<p class="normal">The result is a class that combines the base features and the query methods, and this is passed to the function that adds the storage methods:</p>
<pre class="programlisting"><code class="hljs-code">...
const CompleteRepo = <strong class="screentext">AddStorage</strong>(RepoWithQueries);
...
</code></pre>
<p class="normal">The result is a class that defines all the methods and can be instantiated with the new keyword. The combined class can be instantiated and used as an implementation of the <code class="inlinecode">CategoryRepository</code> interface:</p>
<pre class="programlisting"><code class="hljs-code">...
export const <strong class="screentext">CatalogRepoImpl</strong> = CompleteRepo;
...
</code></pre>
<p class="normal">I like being able to compose features this way, and I find it useful to be able to keep the storage methods separate from the query methods, for example, but I appreciate that not everyone dislikes long code files as much as I do. However, even if you don’t want to adopt this technique in your projects, it does serve as a demonstration<a id="_idIndexMarker901" class="calibre3"/> of the flexibility that JavaScript provides to compose features with class expressions.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">I use a repository for the main parts of the <em class="italic">SportsStore</em> application. However, just to show the alternative, the administration features in <em class="italic">Chapter 20</em> are implemented by working directly with <code class="inlinecode">Sequelize</code> in the HTTP request handlers.</p>
</div>
<p class="normal">To instantiate the repository implementation so that an instance can be used by the rest of the application, add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">src/data</code> folder with the content shown in <em class="italic">Listing 16.42</em>.</p>
<p class="packt_figref">Listing 16.42: The contents of the index.ts file in the src/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { CatalogRepository } from "./catalog_repository";
import { CatalogRepoImpl} from "./orm";
export const catalog_repository: CatalogRepository = new CatalogRepoImpl();
</code></pre>
<p class="normal">This file will be the point at which the implementations of repository interfaces will be created and added to in later chapters, as different types of data are added to the application. But for now, the file exports an object named <code class="inlinecode">catalog_repository</code> that implements the <code class="inlinecode">CatalogRepository</code> interface. Notice that the TypeScript compiler can determine that the combination of methods conforms to the <code class="inlinecode">CatalogRepository</code> interface.</p>
<h2 class="heading1" id="_idParaDest-290">Defining the configuration settings</h2>
<p class="normal1">The <a id="_idIndexMarker902" class="calibre3"/>repository is set up using configuration settings, which are defined in <em class="italic">Listing 16.43</em>.</p>
<p class="packt_figref">Listing 16.43: Adding settings to the server.config.json file in the SportsStore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "http": {
        "port": 5000
    },
    "templates": {
        "location": "templates",
        "config": {
            "layoutsDir": "templates",
            "defaultLayout": "main_layout.handlebars",
            "partialsDir": "templates"
        }
    },
    "errors": {
        "400": "not_found",
        "500": "error"
    },
   <strong class="screentext"> "catalog": {</strong>
<strong class="screentext">        "orm_repo": {</strong>
<strong class="screentext">            "settings": {</strong>
<strong class="screentext">                "dialect": "sqlite",</strong>
<strong class="screentext">                "storage": "</strong><strong class="screentext">catalog.db"</strong>
<strong class="screentext">            },</strong>
<strong class="screentext">            "logging": true,</strong>
<strong class="screentext">            "reset_db": true,</strong>
<strong class="screentext">            "seed_file": "products.json"</strong><strong class="screentext"> </strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal">The <code class="inlinecode">catalog:orm_repo</code> section is read by the base class defined in <em class="italic">Listing 16.38</em>. The <code class="inlinecode">settings</code> section is passed to the <code class="inlinecode">Sequelize</code> constructor and specifies that data should be stored in an SQLite database file named <code class="inlinecode">catalog.db</code>. The <code class="inlinecode">logging</code> setting determines whether the repository configures <code class="inlinecode">Sequelize</code> to log messages, and the <code class="inlinecode">rest_db</code> setting determines whether the database is reset and seeded every time the<a id="_idIndexMarker903" class="calibre3"/> repository is created, which can be useful during development but will be disabled when the application is prepared for deployment in <em class="italic">Chapter 21</em>.</p>
<h2 class="heading1" id="_idParaDest-291">Defining the seed data</h2>
<p class="normal1">The <code class="inlinecode">seed_file</code> setting<a id="_idIndexMarker904" class="calibre3"/> added in <em class="italic">Listing 16.43</em> specifies the name of the file that will be used to seed the catalog database with product data. To define the data, add a file named <code class="inlinecode">products.json</code> to the <code class="inlinecode">sportsstore</code> folder with the content shown in <em class="italic">Listing 16.44</em>. </p>
<p class="packt_figref">Listing 16.44: The contents of the products.json file in the SportsStore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "suppliers": [
        { "id": 1, "name": "Acme Industries"},
        { "id": 2, "name": "Big Boat Co"},
        { "id": 3, "name": "London Chess"}
    ],
    "categories": [
        { "id": 1, "name": "Watersports"},
        { "id": 2, "name": "Soccer"},
        { "id": 3, "name": "Chess"}
    ],
    "products": [
        {"id": 1, "name": "Kayak", "description": "A boat for one person",
         "price": 275.00, "categoryId": 1, "supplierId": 2 },
        {"id": 2, "name": "Lifejacket",
            "description": "Protective and fashionable",
            "price": 48.95, "categoryId": 1, "supplierId": 2 },
        { "id": 3, "name": "Soccer Ball",
            "description": "FIFA-approved size and weight",
            "price": 19.50, "categoryId": 2, "supplierId": 1 },
        { "id": 4, "name": "Corner Flags",
            "description": "Give your playing field a professional touch",
            "price": 34.95, "categoryId": 2, "supplierId": 1 },
        { "id": 5, "name": "Stadium",
            "description": "Flat-packed 35,000-seat stadium",
            "price": 79500, "categoryId": 2, "supplierId": 1 },
        { "id": 6, "name": "Thinking Cap",
            "description": "Improve brain efficiency by 75%", "price": 16,
            "categoryId": 3, "supplierId": 3 },           
        { "id": 7, "name": "Unsteady Chair",
            "description": "Secretly give your opponent a disadvantage",
            "price": 29.95, "categoryId": 3, "supplierId": 3 },
        { "id": 8, "name": "Human Chess Board",
            "description": "A fun game for the family", "price": 75,
            "categoryId": 3, "supplierId": 3 },
        { "id": 9, "name": "Bling King",
            "description": "Gold-plated, diamond-studded King",
            "price": 1200, "categoryId": 3, "supplierId": 3 }           
    ]
}
</code></pre>
<p class="normal">This <a id="_idIndexMarker905" class="calibre3"/>data defines three suppliers, three categories, and nine products. Real online stores have larger catalogs, of course, but this data will be enough to continue building the application.</p>
<h2 class="heading1" id="_idParaDest-292">Using the catalog data</h2>
<p class="normal1">The<a id="_idIndexMarker906" class="calibre3"/> next step is to confirm that the repository works as expected by presenting the user with a list of products. <em class="italic">Listing 16.45</em> uses the repository to read the product data from the database.</p>
<p class="packt_figref">Listing 16.45: Querying data in the catalog.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
<strong class="screentext">import { catalog_repository } from "../data";</strong>
export const createCatalogRoutes = (app: Express) =&gt; {
   <strong class="screentext"> app.get("/"</strong><strong class="screentext">, async (req, resp) =&gt; {</strong>
<strong class="screentext">        const products = await catalog_repository.getProducts();</strong>
<strong class="screentext">        resp.render("index", { products });</strong>
<strong class="screentext">    })</strong>
<strong class="screentext">    // app.get("/err", (req, resp) =&gt; {</strong>
<strong class="screentext">    //     throw new Error ("Something bad happened");</strong>
<strong class="screentext">    // });</strong>
<strong class="screentext"> </strong>
<strong class="screentext">    // app.get("/asyncerr", async (req, resp) =&gt; {</strong>
<strong class="screentext">    //     throw new Error ("Something bad happened asynchronously");</strong>
<strong class="screentext">    // });</strong>
}
</code></pre>
<p class="normal">Replace <a id="_idIndexMarker907" class="calibre3"/>the contents of the <code class="inlinecode">index.handlebars</code> file in the <code class="inlinecode">templates</code> folder with the content shown in <em class="italic">Listing 16.46</em>.</p>
<p class="packt_figref">Listing 16.46: The contents of the index.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;table class="table table-sm table-striped"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;
            &lt;th&gt;Price&lt;/th&gt;&lt;th&gt;Category&lt;/th&gt;&lt;th&gt;Supplier&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{#each products }}
            &lt;tr&gt;
                &lt;td&gt;{{id}}&lt;/td&gt;&lt;td&gt;{{name}}&lt;/td&gt;
                &lt;td&gt;{{description}}&lt;/td&gt;&lt;td&gt;{{price}}&lt;/td&gt;
                &lt;td&gt;{{category.name}}&lt;/td&gt;&lt;td&gt;{{supplier.name}}&lt;/td&gt;
            &lt;/tr&gt;
        {{/each}}
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p class="normal">This isn’t the final presentation of the data, but putting the product data into a table is a good way to check that all of the fields are accessible and read from the database, before figuring out the detailed formatting. Use a browser to request <code class="inlinecode">http://localhost:5000</code>, and<a id="_idIndexMarker908" class="calibre3"/> you will see the data shown in <em class="italic">Figure 16.6</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_16_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 16.6: Displaying data</p>
<h1 class="heading" id="_idParaDest-293">Summary</h1>
<p class="normal1">In this chapter, we started work on the <em class="italic">SportsStore</em> project, and we demonstrated how the key features described in earlier chapters are combined to create a more realistic web application:</p>
<ul class="calibre4">
<li class="bulletlist">The development tools monitor TypeScript files and other project resources so that the code is built and executed when changes are detected.</li>
<li class="bulletlist1">The configuration system locates and merges JSON files to present consolidated settings that can be read consistently by the rest of the application and overridden with environment-specific values.</li>
<li class="bulletlist1">Routes defined using the Express package handle HTTP requests and generate responses, using templates rendered by the Handlebars template engine.</li>
<li class="bulletlist1">Custom error handlers produce responses consistent with the rest of the application and deal with errors in asynchronous request handlers.</li>
<li class="bulletlist1">The <code class="inlinecode">Sequelize</code> package creates a database that stores product data in an SQLite database, which will be replaced with PostgreSQL before deployment.</li>
<li class="bulletlist1">The database is reset and reseeded with data every time the application starts.</li>
</ul>
<p class="normal">In the next chapter, we will continue building the SportsStore application by completing the product catalog and introducing a shopping cart.</p>
</div>
</body></html>