<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-171">
    <a id="_idTextAnchor178">
    </a>
    
     6
    
   </h1>
   <h1 id="_idParaDest-172">
    <a id="_idTextAnchor179">
    </a>
    
     Working with Fastify – The Web Framework
    
   </h1>
   <p>
    
     In
    
    <a href="B19212_04.xhtml#_idTextAnchor100">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     , we learned about the low-level APIs provided by Node.js core for building web applications.
    
    
     However, using those APIs can be challenging sometimes, demanding substantial effort to translate conceptual ideas into functional software.
    
    
     For this reason, web frameworks are pivotal for quickly developing robust HTTP servers within the Node.js ecosystem.
    
    
     A web framework abstracts web protocols into higher-level APIs, allowing you to implement your business logic without the need to address everyday tasks, such as parsing the body of an HTTP request or reinventing an
    
    
     
      internal router.
     
    
   </p>
   <p>
    
     This chapter introduces Fastify, the fastest web framework with the lowest overhead available for Node.js.
    
    
     Fastify places a high emphasis on enhancing the developer’s experience, powering you to build APIs while ensuring outstanding application performance.
    
    
     It closely adheres to web standards, ensuring compatibility and reliability.
    
    
     Moreover, it boasts an impressive degree of extensibility, enabling you to customize your server to align precisely with your
    
    
     
      unique requirements.
     
    
   </p>
   <p>
    
     We will explore Fastify through the following
    
    
     
      learning path:
     
    
   </p>
   <ul>
    <li>
     
      Creating an API starter
     
     
      
       using Fastify
      
     
    </li>
    <li>
     
      Splitting the code into
     
     
      
       small plugins
      
     
    </li>
    <li>
     
      
       Adding routes
      
     
    </li>
    <li>
     
      Implementing authentication
     
     
      
       with hooks
      
     
    </li>
    <li>
     
      Breaking the encapsulation
     
     
      
       using hooks
      
     
    </li>
    <li>
     
      Implementing the
     
     
      
       business logic
      
     
    </li>
    <li>
     
      Validating the
     
     
      
       input data
      
     
    </li>
    <li>
     
      Enhancing application performance
     
     
      
       with serialization
      
     
    </li>
    <li>
     
      Configuring and testing a
     
     
      
       Fastify application
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-173">
    <a id="_idTextAnchor180">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To complete this chapter successfully, you will need
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      A Node.js
     
     
      
       v22 installation
      
     
    </li>
    <li>
     
      An IDE such as VS Code
     
     
      
       from
      
     
     <a href="https://code.visualstudio.com/">
      
       
        https://code.visualstudio.com/
       
      
     </a>
    </li>
    <li>
     
      A working command shell with
     
     <strong class="source-inline">
      
       curl
      
     </strong>
     
      
       from
      
     
     <a href="https://curl.se/download.html">
      
       
        https://curl.se/download.html
       
      
     </a>
    </li>
    <li>
     
      A MongoDB installation
     
     
      
       from
      
     
     <a href="https://www.mongodb.com/">
      
       
        https://www.mongodb.com/
       
      
     </a>
    </li>
   </ul>
   <p>
    
     All the snippets in this chapter are on GitHub
    
    
     
      at
     
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06">
     
      
       https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-174">
    <a id="_idTextAnchor181">
    </a>
    
     Creating an API starter using Fastify
    
   </h1>
   <p>
    <strong class="bold">
     
      Fastify
     
    </strong>
    
     (
    
    <a href="https://fastify.dev/">
     
      https://fastify.dev/
     
    </a>
    
     ) is
    
    <a id="_idIndexMarker354">
    </a>
    
     a Node.js
    
    <a id="_idIndexMarker355">
    </a>
    
     web framework for constructing
    
    <a id="_idIndexMarker356">
    </a>
    
     web applications.
    
    
     It facilitates the development of an HTTP server and the creation of your API in a straightforward, efficient, scalable, and secure manner.
    
    
     The first Fastify’s stable release dates back to 2018.
    
    
     Since then, it has garnered a substantial community, boasting over 7 million monthly downloads.
    
    
     Moreover, it maintains a consistent release schedule, with a major version update approximately every
    
    
     
      two years.
     
    
   </p>
   <p>
    
     Because practical experience is often the most effective way to learn, in this chapter, we will undertake the implementation of an API server for our brand-new fantasy restaurant!
    
    
     Our objectives encompass displaying the menu, allowing the chef to add or remove recipes, and enabling guests to place orders that the chef will receive
    
    
     
      and cook!
     
    
   </p>
   <p>
    
     So, let’s start our hands-on session with Fastify, and at the end of this chapter, you will evaluate whether Fastify is simple to use
    
    
     
      or not!
     
    
   </p>
   <h2 id="_idParaDest-175">
    <a id="_idTextAnchor182">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     First, we need to set up the developer environment.
    
    
     To do this, you can create a new Node.js project by running the following commands in
    
    
     
      your terminal:
     
    
   </p>
   <pre class="console">
$ mkdir fastify-restaurant
$ cd fastify-restaurant
$ npm init –yes
$ npm pkg set type=module</pre>
   <p>
    
     We have initiated the
    
    <strong class="source-inline">
     
      fastify-restaurant
     
    </strong>
    
     folder with the installed
    
    <strong class="source-inline">
     
      fastify
     
    </strong>
    
     module at
    
    
     
      this stage.
     
    
   </p>
   <h2 id="_idParaDest-176">
    <a id="_idTextAnchor183">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To build a Fastify
    
    <a id="_idIndexMarker357">
    </a>
    
     server, we
    
    <a id="_idIndexMarker358">
    </a>
    
     need to follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Install the
     
     <strong class="source-inline">
      
       fastify
      
     </strong>
     
      version
     
     
      
       5 module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install fastify@5</strong></pre>
    </li>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       index.js
      
     </strong>
     
      file with the following content to import
     
     
      
       the dependency:
      
     
     <pre class="source-code">
import { fastify } from 'fastify';</pre>
    </li>
    <li>
     
      Thanks to the imported dependency, we can instantiate a Fastify instance by executing the
     
     <strong class="source-inline">
      
       fastify
      
     </strong>
     
      factory function.
     
     
      The
     
     <strong class="source-inline">
      
       app
      
     </strong>
     
      constant will be our
     
     <strong class="bold">
      
       root application instance
      
     </strong>
     
      that
     
     <a id="_idIndexMarker359">
     </a>
     
      identifies the Fastify API at
     
     
      
       your disposal:
      
     
     <pre class="source-code">
const serverOptions = {
  logger: true
};
const app = fastify(serverOptions);</pre>
     <p class="list-inset">
      
       Note that we are passing the
      
      <strong class="source-inline">
       
        serverOptions
       
      </strong>
      
       object as an argument.
      
      
       It contains the
      
      <strong class="source-inline">
       
        logger: true
       
      </strong>
      
       property to turn on the application logger!
      
      
       The
      
      <strong class="source-inline">
       
        fastify
       
      </strong>
      
       factory accepts many options, which we will see later in
      
      
       
        this chapter.
       
      
     </p>
    </li>
    <li>
     
      With the
     
     <strong class="source-inline">
      
       app
      
     </strong>
     
      instance, we can add routes to the server using the
     
     <strong class="source-inline">
      
       get()
      
     </strong>
     
      method.
     
     
      The handler returns the payload that we would like to return as a response.
     
     
      In this case, we add an HTTP
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      handler to the
     
     <strong class="source-inline">
      
       /
      
     </strong>
     
      
       endpoint:
      
     
     <pre class="source-code">
app.get('/', async function homeHandler () {
  return {
    api: 'fastify-restaurant-api',
    version: 1
  };
});</pre>
    </li>
    <li>
     
      We create a
     
     <strong class="source-inline">
      
       port
      
     </strong>
     
      variable in order to select where the server listens for
     
     
      
       HTTP requests:
      
     
     <pre class="source-code">
const port = process.env.PORT || 3000;</pre>
     <p class="list-inset">
      
       We read the variable
      
      <a id="_idIndexMarker360">
      </a>
      
       from
      
      <a id="_idIndexMarker361">
      </a>
      
       the environment settings or set a default value.
      
      
       This is useful because, usually, on the server where we install the application, the PORT setting is already set (for
      
      
       
        example, Heroku).
       
      
     </p>
    </li>
    <li>
     
      Finally, we can start our server by calling the
     
     <strong class="source-inline">
      
       listen
      
     </strong>
     
      method.
     
     
      The
     
     <strong class="source-inline">
      
       host
      
     </strong>
     
      parameter with the
     
     <strong class="source-inline">
      
       0.0.0.0
      
     </strong>
     
      value will configure your server to accept connections from any
     
     
      
       IPv4 address:
      
     
     <pre class="source-code">
await app.listen({ host: '0.0.0.0', port });</pre>
     <p class="list-inset">
      
       This setup is essential for applications running in Docker containers or any application directly accessible on the internet.
      
      
       Without this configuration, external clients won’t be able to access your
      
      
       
        HTTP server.
       
      
     </p>
    </li>
    <li>
     
      We are now ready to start the server with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node index.js</strong>
<strong class="bold">{"level":30,"time":1693925618687,"pid":123,"hostname":"MyPc","msg":"Server listening at http://127.0.0.1:3000"}</strong>
<strong class="bold">{"level":30,"time":1693925618687,"pid":123,"hostname":"MyPc","msg":"Server listening at http://192.168.1.174:3000"}</strong></pre>
     <p class="list-inset">
      
       As you may have noticed, we can see multiple IP addresses where the HTTP server is listening.
      
      
       This is due to the
      
      <strong class="source-inline">
       
        0.0.0.0
       
      </strong>
      
       host configuration, which listens for both the localhost name and the local IP address to handle external calls.
      
      
       If we change
      
      <strong class="source-inline">
       
        0.0.0.0
       
      </strong>
      
       to
      
      <strong class="source-inline">
       
        localhost
       
      </strong>
      
       , our HTTP server will be available only from the local PC, printing a single
      
      
       
        log message.
       
      
     </p>
    </li>
    <li>
     
      The console log tells us that the server has started successfully; therefore, if you open a new terminal and run a
     
     <strong class="source-inline">
      
       curl
      
     </strong>
     
      command, you will get
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">$ curl http://localhost:3000</strong>
<strong class="bold">{"api":"fastify-restaurant-api","version":1}</strong></pre>
    </li>
   </ol>
   <p>
    
     In a few lines of code, you have created a Fastify server with a logger that is ready to use and responds with a JSON payload on the
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     
      route!
     
    
   </p>
   <p>
    
     As we saw, Fastify comes equipped with numerous built-in features, such as the application logger, by using
    
    <a id="_idIndexMarker362">
    </a>
    
     the
    
    <a id="_idIndexMarker363">
    </a>
    
     popular Node.js
    
    <a id="_idIndexMarker364">
    </a>
    
     logger
    
    <strong class="source-inline">
     
      pino
     
    </strong>
    
     (
    
    <a href="https://getpino.io/">
     
      https://getpino.io/
     
    </a>
    
     ) and an automatic handling JSON format without
    
    
     
      additional dependencies.
     
    
   </p>
   <p>
    
     In the next recipe, we will refactor the code to start giving shape to
    
    
     
      our project.
     
    
   </p>
   <h1 id="_idParaDest-177">
    <a id="_idTextAnchor184">
    </a>
    
     Splitting the code into small plugins
    
   </h1>
   <p>
    
     We implemented
    
    <a id="_idIndexMarker365">
    </a>
    
     the API root endpoint in the
    
    <em class="italic">
     
      Creating an API starter using Fastify
     
    </em>
    
     recipe, which is often used as a health check to verify whether the server started successfully.
    
    
     However, we can’t keep adding all the application’s routes to the
    
    <strong class="source-inline">
     
      index.js
     
    </strong>
    
     file; otherwise, it would become unreadable in no time.
    
    
     So, let’s split our
    
    
     <strong class="source-inline">
      
       index.js
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <h2 id="_idParaDest-178">
    <a id="_idTextAnchor185">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To split our
    
    <strong class="source-inline">
     
      index.js
     
    </strong>
    
     file, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      file and move the
     
     <strong class="source-inline">
      
       serverOptions
      
     </strong>
     
      constant with the following
     
     
      
       server configuration:
      
     
     <pre class="source-code">
const serverOptions = {
  logger: true
};</pre>
    </li>
    <li>
     
      We define our first
     
     
      
       plugin interface:
      
     
     <pre class="source-code">
async function appPlugin (app, opts) {
  app.get('/', async function homeHandler () {
    return {
      api: 'fastify-restaurant-api',
      version: 1
    };
  });
}</pre>
     <p class="list-inset">
      
       A plugin is an
      
      <strong class="source-inline">
       
        async
       
      </strong>
      
       function that accepts two arguments: the first is a Fastify server instance, and the second is an
      
      <strong class="source-inline">
       
        options
       
      </strong>
      
       object, which is empty for now.
      
      
       We will use it later in the
      
      <em class="italic">
       
        Implementing authentication with hooks
       
      </em>
      
       recipe.
      
      
       This function may
      
      <a id="_idIndexMarker366">
      </a>
      
       assume a different declaration if it is not an
      
      <strong class="source-inline">
       
        async
       
      </strong>
      
       function.
      
      
       In this case, there would be a third argument:
      
      <strong class="source-inline">
       
        function syncAppPlugin(app, opts, next){}
       
      </strong>
      
       ; it is a function that we must call to tell the Fastify framework when the plugin
      
      
       
        is loaded.
       
      
     </p>
    </li>
    <li>
     
      Finally, we need to export the plugin function as a default and the server configuration as named
     
     
      
       export options:
      
     
     <pre class="source-code">
export default appPlugin;
export { serverOptions as options };</pre>
    </li>
    <li>
     
      Now, we need to create the
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file
     
     
      
       as follows:
      
     
     <pre class="source-code">
import { fastify } from 'fastify';
import appPlugin, { options } from './app.js';
const app = fastify(options);
app.register(appPlugin);
const port = process.env.PORT || 3000;
await app.listen({ host: '0.0.0.0', port });</pre>
    </li>
    <li>
     
      Now, we need to try out that we have completed the refactoring correctly; you can execute the
     
     <strong class="source-inline">
      
       node server.js
      
     </strong>
     
      command, and it should initiate the server, as it did in the previous
     
     <em class="italic">
      
       Creating an API starter using
      
     </em>
     
      <em class="italic">
       
        Fastify
       
      </em>
     
     
      
       recipe.
      
     
    </li>
   </ol>
   <p>
    
     We’ve created our initial Fastify plugin
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       app.js
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-179">
    <a id="_idTextAnchor186">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     It’s important to note that the intention of this section is not to delve deeply into Fastify’s powerful plugin system, which we will explore comprehensively in the
    
    <em class="italic">
     
      Implementing authentication with hooks
     
    </em>
    
     recipe.
    
    
     At this juncture, we are primarily utilizing it as a tool
    
    <a id="_idIndexMarker367">
    </a>
    
     to organize our code into
    
    
     
      manageable components.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      app.js
     
    </strong>
    
     file serves as the entry point for our application.
    
    
     We have chosen to export the recipe’s code in a format that is compatible with
    
    <strong class="source-inline">
     
      fastify-cli
     
    </strong>
    
     (
    
    <a href="https://github.com/fastify/fastify-cli">
     
      https://github.com/fastify/fastify-cli
     
    </a>
    
     ).
    
    
     This
    
    <a id="_idIndexMarker368">
    </a>
    
     tool is designed to facilitate application startup and enhance our developer experience.
    
    
     While we won’t delve into its details in this book, it’s worth noting that the code we write here will provide you with the flexibility to transition to
    
    <strong class="source-inline">
     
      fastify-cli
     
    </strong>
    
     seamlessly, should you choose to do so in
    
    
     
      the future.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     file has a singular purpose; it imports the
    
    <strong class="source-inline">
     
      app.js
     
    </strong>
    
     file and uses the options object to instantiate the root application instance, as we’ve done before in the
    
    <em class="italic">
     
      Creating an API starter using
     
    </em>
    
     <em class="italic">
      
       Fastify
      
     </em>
    
    
     
      recipe.
     
    
   </p>
   <p>
    
     The noteworthy addition here is the
    
    <strong class="source-inline">
     
      register()
     
    </strong>
    
     method.
    
    
     This Fastify function attaches plugins to the Fastify server, ensuring that they are loaded sequentially according to the order in which they are registered.
    
    
     After registering a function plugin, it is not executed until we execute the
    
    <strong class="source-inline">
     
      listen()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      ready()
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      inject()
     
    </strong>
    
     methods.
    
    
     We will explore the latter two methods in the
    
    <em class="italic">
     
      Configuring and testing a Fastify
     
    </em>
    
     <em class="italic">
      
       Application
      
     </em>
    
    
     
      recipe.
     
    
   </p>
   <p>
    
     This minor refactoring represents a significant step forward, as it bolsters our confidence in understanding the Fastify plugin interface.
    
    
     Moreover, it neatly separates the business logic from the technical task of launching the web server.
    
    
     As a result, the
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     file will never change, allowing
    
    <a id="_idIndexMarker369">
    </a>
    
     us to focus on the
    
    <strong class="source-inline">
     
      app.js
     
    </strong>
    
     
      file exclusively.
     
    
   </p>
   <p>
    
     We will add our initial business logic routes in the forthcoming recipe, so
    
    
     
      stay tuned!
     
    
   </p>
   <h1 id="_idParaDest-180">
    <a id="_idTextAnchor187">
    </a>
    
     Adding routes
    
   </h1>
   <p>
    
     To specify how the
    
    <a id="_idIndexMarker370">
    </a>
    
     application responds to client requests, routes must be defined.
    
    
     Each route is identified mainly by an HTTP method and a URL pattern, which must align with the incoming request to execute the associated handler function.
    
    
     We are currently exposing only one single route:
    
    <strong class="source-inline">
     
      GET /
     
    </strong>
    
     .
    
    
     If you try to hit a different endpoint, you will receive a
    
    <strong class="source-inline">
     
      404 Not
     
    </strong>
    
     <strong class="source-inline">
      
       Found
      
     </strong>
    
    
     
      response:
     
    
   </p>
   <pre class="console">
$ curl http://localhost:3000/example
{"message":"Route GET:/example not found","error":"Not Found","statusCode":404}</pre>
   <p>
    
     Fastify automatically handles 404 responses.
    
    
     When a client attempts to access a non-existent route, Fastify will generate and send a 404 response
    
    
     
      by default.
     
    
   </p>
   <p>
    
     As we’re developing a web server to provide APIs for our fantasy restaurant, it’s essential to outline the routes we need to implement in order to fulfill our objectives.
    
    
     Some of the necessary routes may include
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       GET /menu
      
     </strong>
     
      : Retrieves the
     
     
      
       restaurant’s menu
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       GET /recipes
      
     </strong>
     
      : This replies with the same logic as the
     
     <strong class="source-inline">
      
       GET /
      
     </strong>
     
      <strong class="source-inline">
       
        menu
       
      </strong>
     
     
      
       handler
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       POST /recipes
      
     </strong>
     
      : Enables the chef to add a new dish to
     
     
      
       the menu
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       DELETE /recipes/:id
      
     </strong>
     
      : Allows the chef to remove a recipe from
     
     
      
       the menu
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       POST /orders
      
     </strong>
     
      : Allows guests to place orders
     
     
      
       for dishes
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       GET /orders
      
     </strong>
     
      : Returns a list of the
     
     
      
       pending orders
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       PATCH /orders/:orderId
      
     </strong>
     
      : Enables the chef to update the status of
     
     
      
       an order
      
     
    </li>
   </ul>
   <p>
    
     To implement all these routes effectively, we should follow an iterative approach, continuously enhancing our code with each iteration.
    
    
     The steps for our development process will be
    
    
     
      as follows:
     
    
   </p>
   <ol>
    <li>
     <strong class="bold">
      
       Define the route handlers
      
     </strong>
     
      : Begin by defining the route with an empty handler.
     
     
      We will cover it in
     
     
      
       this recipe.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Implement route logic
      
     </strong>
     
      : Incorporate the necessary logic within your route handlers to handle tasks, such as retrieving the menu, adding new menu items, processing orders, and updating order statuses.
     
     
      We will do this in the
     
     <em class="italic">
      
       Implementing authentication with
      
     </em>
     
      <em class="italic">
       
        hooks
       
      </em>
     
     
      
       recipe.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Validation and error handling
      
     </strong>
     
      : Implement validation checks to ensure that incoming data are accurate and handle errors gracefully by providing informative error messages and appropriate HTTP
     
     
      
       status codes.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Testing
      
     </strong>
     
      : Thoroughly test each route to confirm that it functions as expected.
     
     
      Consider various scenarios, including valid and invalid input.
     
     
      We will cover this in the
     
     <em class="italic">
      
       Configuring and testing a Fastify
      
     </em>
     
      <em class="italic">
       
        application
       
      </em>
     
     
      
       recipe.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Documentation
      
     </strong>
     
      : We must not forget to write up a comprehensive
     
     <strong class="source-inline">
      
       README.md
      
     </strong>
     
      file within our source code to ease our
     
     
      
       team’s work.
      
     
    </li>
   </ol>
   <p>
    
     So, let’s begin with the
    
    
     
      first step.
     
    
   </p>
   <h2 id="_idParaDest-181">
    <a id="_idTextAnchor188">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     We can discern two
    
    <a id="_idIndexMarker371">
    </a>
    
     primary entities within our set of endpoints:
    
    <strong class="bold">
     
      recipes
     
    </strong>
    
     and
    
    <strong class="bold">
     
      orders
     
    </strong>
    
     .
    
    
     For defining route handlers, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      To enhance code organization, we’ll create two distinct files, with one for each entity.
     
     
      Additionally, to maintain a structured approach, we’ll establish a
     
     <strong class="source-inline">
      
       routes/
      
     </strong>
     
      folder and create the
     
     <strong class="source-inline">
      
       routes/recipes.js
      
     </strong>
     
      file
     
     
      
       within it.
      
     
    </li>
    <li>
     
      The initial route we need to define is
     
     <strong class="source-inline">
      
       GET /menu
      
     </strong>
     
      .
     
     
      In this scenario, we employ the versatile
     
     <strong class="source-inline">
      
       route()
      
     </strong>
     
      method to construct it.
     
     
      This method requires an input object containing three obligatory parameters:
     
     <strong class="source-inline">
      
       method
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       url
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       handler
      
     </strong>
     
      , as illustrated in the
     
     
      
       following example:
      
     
     <pre class="source-code">
function recipesPlugin (app, opts, next) {
  app.route({
    method: 'GET',
    url: '/menu',
    handler: menuHandler
  });
  next();
}</pre>
     <p class="list-inset">
      
       For a comprehensive list of the acceptable parameters, please consult the documentation at https://fastify.dev/docs/latest/Reference/Routes/#routes-options.
      
      
       Note that we must execute the
      
      <strong class="source-inline">
       
        next
       
      </strong>
      
       argument, as discussed in the
      
      <em class="italic">
       
        Splitting the code into small plugins
       
      </em>
      
       recipe.
      
      
       This is only another style with which to define plugins, and it is the most performant choice when we don’t need async operations during plugin loading.
      
      
       Moreover, it is important to remember that it must be the last operation to execute, and after calling it, it is not possible to
      
      <a id="_idIndexMarker372">
      </a>
      
       add
      
      
       
        more routes.
       
      
     </p>
    </li>
    <li>
     
      Define a new
     
     <strong class="source-inline">
      
       menuHandler
      
     </strong>
     
      function alongside the
     
     <strong class="source-inline">
      
       plugin
      
     </strong>
     
      function, which may prompt the question, How can we access the server’s resources?
     
     
      Fastify simplifies
     
     
      
       this process:
      
     
     <pre class="source-code">
async function menuHandler (request, reply) {
  this.log.info('Logging GET /menu from this');
  request.log.info('Logging GET /menu from request');
  throw new Error('Not implemented');
}
export default recipesPlugin;</pre>
     <p class="list-inset">
      
       When you define a named function, as demonstrated in the preceding code example, you can utilize the
      
      <strong class="source-inline">
       
        this
       
      </strong>
      
       keyword within its context.
      
      
       In this context,
      
      <strong class="source-inline">
       
        this
       
      </strong>
      
       is equivalent to the
      
      <strong class="source-inline">
       
        app
       
      </strong>
      
       variable, granting you access to all of the server’s resources, such as the database or the configuration settings, as we’ll explore in the
      
      <em class="italic">
       
        Adding routes
       
      </em>
      
       recipe.
      
      
       However, as shown in this particular example, we’re introducing
      
      <strong class="source-inline">
       
        this.log
       
      </strong>
      
       and the
      
      <strong class="source-inline">
       
        request.log
       
      </strong>
      
       property, which provide access to the logger object, enabling us to integrate logging into our
      
      
       
        application seamlessly.
       
      
     </p>
    </li>
    <li>
     
      Before continuing, we must not forget to update the
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      file when registering the
     
     
      
       new plugin:
      
     
     <pre class="source-code">
<strong class="bold">import recipesPlugin from './routes/recipes.js';</strong>
async function appPlugin (app, opts) {
  // ...
  <strong class="bold">app.register(recipesPlugin);</strong>
}</pre>
    </li>
    <li>
     
      Now, we can
     
     <a id="_idIndexMarker373">
     </a>
     
      start the server with the
     
     <strong class="source-inline">
      
       node server.js
      
     </strong>
     
      command and execute a call
     
     
      
       against it:
      
     
     <pre class="source-code">
<strong class="bold">$ curl http://localhost:3000/menu</strong>
<strong class="bold">{"statusCode":500,"error":"Internal Server Error","message":"Not implemented"}%</strong></pre>
     <p class="list-inset">
      
       We will discuss the source code for
      
      <strong class="source-inline">
       
        routes/recipes.js
       
      </strong>
      
       in detail in the
      
      <em class="italic">
       
        How it works…
       
      </em>
      
       section of this recipe.
      
      
       Now, we can define the remaining routes within the body of the
      
      <strong class="source-inline">
       
        recipesPlugin
       
      </strong>
      
       function.
      
      
       So, we can delve deeper into Fastify’s syntax by adding the
      
      
       
        new routes.
       
      
     </p>
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       GET /recipes
      
     </strong>
     
      endpoint combines elements from both the
     
     <strong class="source-inline">
      
       get()
      
     </strong>
     
      method that we saw previously in
     
     <em class="italic">
      
       Step 4
      
     </em>
     
      of the
     
     <em class="italic">
      
       Creating an API starter using Fastify
      
     </em>
     
      recipe and the generic
     
     <strong class="source-inline">
      
       route()
      
     </strong>
     
      method.
     
     
      You can designate the
     
     <strong class="source-inline">
      
       url
      
     </strong>
     
      as the first parameter and the route’s options as the
     
     
      
       second one:
      
     
     <pre class="source-code">
  app.get('/recipes', { handler: menuHandler });</pre>
     <p class="list-inset">
      
       The coolest thing here is that we’re utilizing the same
      
      <strong class="source-inline">
       
        menuHandler
       
      </strong>
      
       function for both the
      
      <strong class="source-inline">
       
        /menu
       
      </strong>
      
       and
      
      <strong class="source-inline">
       
        /recipes
       
      </strong>
      
       endpoints, aligning with the requirements we established earlier in the introduction of
      
      
       
        this recipe.
       
      
     </p>
    </li>
    <li>
     
      Now, defining a
     
     <strong class="source-inline">
      
       POST /recipes
      
     </strong>
     
      route appears to be a straightforward task in light of our
     
     
      
       previous work:
      
     
     <pre class="source-code">
  app.post('/recipes', async function addToMenu
    (request, reply) {
      throw new Error('Not implemented');
    });</pre>
    </li>
    <li>
     
      Lastly, let’s discuss further the definition of the
     
     <strong class="source-inline">
      
       DELETE /recipes/:id
      
     </strong>
     
      route.
     
     
      Firstly, the
     
     <strong class="source-inline">
      
       :id
      
     </strong>
     
      pattern within the URL strin
     
     <a id="_idIndexMarker374">
     </a>
     
      g serves as a
     
     <strong class="bold">
      
       path parameter
      
     </strong>
     
      .
     
     
      A path parameter is a positional variable segment of the URL.
     
     
      When a client makes a
     
     <strong class="source-inline">
      
       DELETE
      
     </strong>
     
      request to
     
     <strong class="source-inline">
      
       /recipes/something
      
     </strong>
     
      , the value of
     
     <strong class="source-inline">
      
       something
      
     </strong>
     
      will be assigned to the
     
     <strong class="source-inline">
      
       request.params.id
      
     </strong>
     
      property.
     
     
      It’s worth noting that
     
     <strong class="source-inline">
      
       request.params
      
     </strong>
     
      is a JSON object that contains all the path parameters you may define within the URL.
     
     
      Secondly, we’ve defined the
     
     <strong class="source-inline">
      
       removeFromMenu
      
     </strong>
     
      function
     
     <a id="_idIndexMarker375">
     </a>
     
      as a synchronous function, meaning it is not
     
     <strong class="source-inline">
      
       async
      
     </strong>
     
      .
     
     
      In such cases, we cannot directly return or throw the desired response body.
     
     
      Instead, we must call the
     
     <strong class="source-inline">
      
       reply.send()
      
     </strong>
     
      method, which is responsible for transmitting the response payload to the client.
     
     
      This payload can be a string, a JSON object, a buffer, a stream, or an
     
     
      
       error object:
      
     
     <pre class="source-code">
  app.delete('/recipes/:id', function removeFromMenu
    (request, reply) {
      reply.send(new Error('Not implemented'));
    });</pre>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Don’t mix async with sync: It’s crucial to emphasize that you cannot mix the async and sync handler styles; otherwise, unexpected errors will appear on the console.
    
    
     As a key takeaway, remember the following guidelines: if the handler is asynchronous, return the desired payload; otherwise, if the handler is synchronous, you must use the
    
    <strong class="source-inline">
     
      reply.send()
     
    </strong>
    
     function to send the response.
    
    
     In my experience, it is more effective to stick to the async style in a project to avoid confusion across the team and with different backgrounds.
    
    
     Furthermore, the
    
    <strong class="source-inline">
     
      reply
     
    </strong>
    
     object is a fundamental component of Fastify that provides additional utilities, enabling you to customize the response code or append new response headers as needed.
    
    
     We will show an example in the
    
    <em class="italic">
     
      Implementing authentication with
     
    </em>
    
     <em class="italic">
      
       hooks
      
     </em>
    
    
     
      recipe.
     
    
   </p>
   <h2 id="_idParaDest-182">
    <a id="_idTextAnchor189">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the preceding code snippet, we find ourselves re-iterating a procedure similar to what we’ve previously executed for the
    
    <strong class="source-inline">
     
      GET /
     
    </strong>
    
     route in the
    
    <em class="italic">
     
      Creating an API starter using Fastify
     
    </em>
    
     recipe.
    
    
     However, in this instance, we’re employing an alternative syntax provided by Fastify.
    
    
     In this new plugin, for the
    
    <strong class="source-inline">
     
      ./routes/recipes.js
     
    </strong>
    
     declaration, we use the callback style.
    
    
     It is
    
    <a id="_idIndexMarker376">
    </a>
    
     crucial to note that we are calling the
    
    <strong class="source-inline">
     
      next()
     
    </strong>
    
     function at the end of the plugin.
    
    
     If you omit it, Fastify will fail its startup and will trigger an
    
    <strong class="source-inline">
     
      FST_ERR_PLUGIN_TIMEOUT - Plugin did not start in time: 'recipesPlugin'.
     
     
      You may have forgotten to call 'done' function or to resolve a
     
    </strong>
    
     <strong class="source-inline">
      
       Promise
      
     </strong>
    
    
     
      error.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      curl
     
    </strong>
    
     request illustrates how Fastify employs a default error handler; it captures any thrown errors and responds with a 500 HTTP status code along with the
    
    
     
      error message.
     
    
   </p>
   <p>
    
     In moving to the server’s log output instead, we should see the following alongside the logged error
    
    
     
      stack trace:
     
    
   </p>
   <pre class="source-code">
{"level":30,"time":1694013232783,"pid":1,"hostname":"MyPC","msg":"Logging GET /menu from this"}
{"level":30,"time":1694013232783,"pid":1,"hostname":" MyPC ",<strong class="bold">"reqId":"req-2"</strong>,"msg":"Logging GET /menu from request"}</pre>
   <p>
    
     You can observe the difference highlighted in the preceding code block.
    
    
     When you utilize the request’s
    
    <strong class="source-inline">
     
      log
     
    </strong>
    
     , the log entry will incorporate a
    
    <strong class="source-inline">
     
      reqId
     
    </strong>
    
     field.
    
    
     This feature proves quite useful in discerning which logs relate to a specific request, facilitating the reconstruction of the entire sequence of actions an HTTP request has undertaken within the application.
    
    
     Fastify assigns a unique identifier to each request by default, starting with
    
    <strong class="source-inline">
     
      req-1
     
    </strong>
    
     and incrementing the number.
    
    
     Additionally, this counter resets to its initial state with every
    
    
     
      server restart.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     If you want to customize the request id, you have two options.
    
    
     You can configure the
    
    <strong class="source-inline">
     
      requestIdHeader
     
    </strong>
    
     server option, instructing Fastify to extract the id from a specific HTTP header.
    
    
     Alternatively, you can supply a
    
    <strong class="source-inline">
     
      genReqId
     
    </strong>
    
     function, granting you full control over the id generation process.
    
    
     For further information, please refer to the official documentation
    
    
     
      at
     
    
    <a href="https://fastify.dev/docs/latest/Reference/Server">
     
      
       https://fastify.dev/docs/latest/Reference/Server
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-183">
    <a id="_idTextAnchor190">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     Up to this point, we
    
    <a id="_idIndexMarker377">
    </a>
    
     have established the scaffolding for the
    
    <strong class="source-inline">
     
      recipes.js
     
    </strong>
    
     file.
    
    
     It’s
    
    <a id="_idIndexMarker378">
    </a>
    
     time to create a new
    
    <strong class="source-inline">
     
      routes/orders.js
     
    </strong>
    
     file and define the final three routes required to accomplish our objective.
    
    
     I encourage you to take on this task as an exercise.
    
    
     If you encounter any issues, you can check the following code to
    
    
     
      be inspired:
     
    
   </p>
   <pre class="source-code">
async function ordersPlugin (app, opts) {
  async function notImplemented (request, reply) {
    throw new Error('Not implemented');
  }
  app.post('/orders', { handler: notImplemented });
  app.get('/orders', { handler: notImplemented });
  app.patch('/orders/:orderId', { handler: notImplemented
    });
}
export default ordersPlugin;</pre>
   <p>
    
     Don’t forget to update the
    
    <strong class="source-inline">
     
      app.js
     
    </strong>
    
     file to expose the new
    
    
     
      empty routes.
     
    
   </p>
   <p>
    
     Following this recipe, you should be well equipped to declare various routes and return plain data, such as strings or JSON objects.
    
    
     In the upcoming recipe, we will delve into implementing the fundamental business logic of our APIs by exploring the Fastify plugin system and
    
    
     
      its
     
    
    
     <a id="_idIndexMarker379">
     </a>
    
    
     
      components.
     
    
   </p>
   <h1 id="_idParaDest-184">
    <a id="_idTextAnchor191">
    </a>
    
     Implementing authentication with hooks
    
   </h1>
   <p>
    
     We’ve already utilized Fastify
    
    <a id="_idIndexMarker380">
    </a>
    
     plugins to organize routes and
    
    <a id="_idIndexMarker381">
    </a>
    
     enhance the maintainability of our project, but these are just some of the advantages that the Fastify
    
    <strong class="bold">
     
      plugin system
     
    </strong>
    
     provides.
    
    
     The key features of the plugin system are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Encapsulation
      
     </strong>
     
      : All the hooks, plugins, and
     
     <a id="_idIndexMarker382">
     </a>
     
      decorators added to a plugin are bound to the plugin context, ensuring they remain encapsulated within the
     
     
      
       plugin’s scope.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Isolation
      
     </strong>
     
      : Each plugin instance is self-contained and operates independently, avoiding any modifications to sibling plugins.
     
     
      This isolation ensures that changes or issues in one plugin do not
     
     
      
       affect others.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Inheritance
      
     </strong>
     
      : A plugin inherits the configuration of its parent plugin, allowing for a hierarchical and modular organization of plugins, making it easier to manage complex
     
     
      
       application structures.
      
     
    </li>
   </ul>
   <p>
    
     These concepts might appear complex at first, but in this recipe, we will put them into practical use.
    
    
     Specifically, we will implement protection mechanisms for routes that only a chef should be able to access.
    
    
     This is a crucial step to prevent misuse by unauthorized users who might attempt to make destructive changes to the fantasy
    
    
     
      restaurant’s menu.
     
    
   </p>
   <p>
    
     The authentication must grant access to a chef user to
    
    
     
      these endpoints:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="source-inline">
       
        POST /recipes
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        DELETE /recipes/:id
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        PATCH /orders/:orderId
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     To streamline the logic, we define a chef as any HTTP request that includes the
    
    <strong class="source-inline">
     
      x-api-key
     
    </strong>
    
     header with a valid secret value.
    
    
     The server must return a
    
    <strong class="source-inline">
     
      401 – Unauthorized
     
    </strong>
    
     HTTP response if the authentication fails.
    
    
     This approach simplifies the verification process for
    
    
     
      chef access.
     
    
   </p>
   <h2 id="_idParaDest-185">
    <a id="_idTextAnchor192">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before getting into the code, I recommend testing all the listed endpoints to confirm that you can access them and receive the expected
    
    <strong class="source-inline">
     
      Not implemented
     
    </strong>
    
     error message.
    
    
     By the end of this recipe, we anticipate that executing the following
    
    <strong class="source-inline">
     
      curl
     
    </strong>
    
     commands will result in an
    
    
     <strong class="source-inline">
      
       Unauthorized
      
     </strong>
    
    
     
      error:
     
    
   </p>
   <pre class="console">
$ curl -X POST http://localhost:3000/recipes
$ curl -X DELETE http://localhost:3000/recipes/fake-id
$ curl -X PATCH http://localhost:3000/orders/fake-id</pre>
   <p>
    
     We are going to explore all the plugin system features right now with a trial-and-error example.
    
    
     So, be
    
    <a id="_idIndexMarker383">
    </a>
    
     ready
    
    <a id="_idIndexMarker384">
    </a>
    
     to restart the server and execute the
    
    
     <strong class="source-inline">
      
       curl
      
     </strong>
    
    
     
      commands.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Restarting the Fastify server by manually killing the Node.js process can be cumbersome.
    
    
     To streamline this process, you can run the application using the
    
    <strong class="source-inline">
     
      node --watch server.js
     
    </strong>
    
     argument.
    
    
     Node.js 20 introduces the watch mode feature, which automatically restarts the process whenever a file changes, making development
    
    
     
      more efficient.
     
    
   </p>
   <h2 id="_idParaDest-186">
    <a id="_idTextAnchor193">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To implement the authentication, we need to follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Edit the
     
     <strong class="source-inline">
      
       routes/recipes.js
      
     </strong>
     
      file
     
     <a id="_idIndexMarker385">
     </a>
     
      by adding an
     
     
      <strong class="source-inline">
       
        onRequest
       
      </strong>
     
     
     
     
      <strong class="bold">
       
        hook
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
function recipesPlugin (app, opts, next) {
  app.addHook('<strong class="bold">onRequest</strong>', async function isChef
    (request, reply) {
      if (request.headers['x-api-key'] !== 'fastify-
        rocks') {
          reply.code(401)
          throw new Error('Invalid API key');
      }
    });
  // ...
  next();
}</pre>
     <p class="list-inset">
      
       A hook is a function that executes, as required, throughout the lifecycle of the application or during a single request and response cycle.
      
      
       It provides the capability to inject custom logic into the framework itself, enhancing reusability and allowing
      
      <a id="_idIndexMarker386">
      </a>
      
       for tailored
      
      <strong class="bold">
       
        behavior
       
      </strong>
      
       at
      
      <a id="_idIndexMarker387">
      </a>
      
       specific points in the
      
      
       
        application’s execution.
       
      
     </p>
    </li>
    <li>
     
      Let’s see it in action by running these
     
     
      <strong class="source-inline">
       
        curl
       
      </strong>
     
     
      
       commands:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -X POST http://localhost:3000/recipes</strong>
<strong class="bold">{"statusCode":401,"error":"Unauthorized","message":"Invalid API key"}</strong>
<strong class="bold">$ curl -X PATCH http://localhost:3000/orders/fake-id</strong>
<strong class="bold">{"statusCode":500,"error":"Internal Server Error","message":"Not implemented"}</strong>
<strong class="bold">$ curl -X GET http://localhost:3000/recipes/fake-id</strong>
<strong class="bold">{"statusCode":401,"error":"Unauthorized","message":"Invalid API key"}</strong></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-187">
    <a id="_idTextAnchor194">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We have introduced the
    
    <strong class="source-inline">
     
      onRequest
     
    </strong>
    
     hook.
    
    
     This means the
    
    <strong class="source-inline">
     
      isChef
     
    </strong>
    
     function will run whenever a new HTTP request comes into the server.
    
    
     The logic of this hook is to verify the property of
    
    <strong class="source-inline">
     
      request.headers
     
    </strong>
    
     to check whether the expected header has the
    
    <strong class="source-inline">
     
      fastify-rocks
     
    </strong>
    
     value.
    
    
     If the check is unsuccessful, the hook throws an error after setting the HTTP response status code using the
    
    
     <strong class="source-inline">
      
       reply.code()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     If we analyze the console output, we can see the plugin system
    
    
     
      in action:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Encapsulation
      
     </strong>
     
      : We have incorporated a hook within the
     
     <strong class="source-inline">
      
       recipesPlugin
      
     </strong>
     
      function, and this hook’s function is executed for every route defined within the same plugin scope.
     
     
      As a result, the
     
     <strong class="source-inline">
      
       GET /recipes
      
     </strong>
     
      route returns a 401 error, demonstrating how hooks can encapsulate and apply logic consistently within a
     
     
      
       plugin’s context.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Isolation
      
     </strong>
     
      : Whenever Fastify executes the
     
     <strong class="source-inline">
      
       register()
      
     </strong>
     
      method, it generates a new
     
     <strong class="bold">
      
       plugin instance
      
     </strong>
     
      , analogous
     
     <a id="_idIndexMarker388">
     </a>
     
      to the
     
     <strong class="source-inline">
      
       app
      
     </strong>
     
      argument in the
     
     <strong class="source-inline">
      
       plugin
      
     </strong>
     
      function declaration.
     
     
      This instance acts as a child object of the
     
     <strong class="source-inline">
      
       root application
      
     </strong>
     
      instance, ensuring isolation from sibling plugins and enabling the construction of independent components.
     
     
      This isolation is why the
     
     <strong class="source-inline">
      
       PATCH /orders/fake-id
      
     </strong>
     
      request remains unaffected and continues to return the old
     
     <strong class="source-inline">
      
       Not implemented
      
     </strong>
     
      error.
     
     
      It highlights that the scope of
     
     <strong class="source-inline">
      
       ordersPlugin
      
     </strong>
     
      remains isolated from that of
     
     
      
       the
      
     
     
      <strong class="source-inline">
       
        recipesPlugin
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ul>
   <p>
    
     To evaluate
    
    <a id="_idIndexMarker389">
    </a>
    
     the
    
    <strong class="bold">
     
      Inheritance
     
    </strong>
    
     feature, you
    
    <a id="_idIndexMarker390">
    </a>
    
     must move the
    
    <strong class="source-inline">
     
      onRequest
     
    </strong>
    
     hook from the
    
    <strong class="source-inline">
     
      routes/recipes.js
     
    </strong>
    
     file to the
    
    <strong class="source-inline">
     
      app.js
     
    </strong>
    
     file.
    
    
     After this modification, executing the previous curl commands will indeed result in an
    
    <strong class="source-inline">
     
      Unauthorized
     
    </strong>
    
     error.
    
    
     This outcome occurs because both
    
    <strong class="source-inline">
     
      ordersPlugin
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      recipesPlugin
     
    </strong>
    
     are children of the
    
    <strong class="source-inline">
     
      appPlugin
     
    </strong>
    
     plugin
    
    <a id="_idIndexMarker391">
    </a>
    
     instance and inherit all of its
    
    <a id="_idIndexMarker392">
    </a>
    
     hooks, including the
    
    
     <strong class="source-inline">
      
       onRequest
      
     </strong>
    
    
     
      hook.
     
    
   </p>
   <h2 id="_idParaDest-188">
    <a id="_idTextAnchor195">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     How can we resolve the
    
    <a id="_idIndexMarker393">
    </a>
    
     current scenario where all our routes are protected?
    
    
     Exploring the plugin system offers a multitude of approaches to achieve this objective, as it heavily relies on your project’s structure and the contexts you need to consider.
    
    
     Let’s see two approaches for each plugin in the
    
    
     <strong class="source-inline">
      
       routes/
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <p>
    
     The initial step involves centralizing the authentication logic; to facilitate this, we introduce
    
    <strong class="bold">
     
      Decorators
     
    </strong>
    
     .
    
    
     Decorators
    
    <a id="_idIndexMarker394">
    </a>
    
     empower you to enhance the default functionalities of Fastify components, minimizing code duplication and providing rapid access to the application’s resources, such as a database connection.
    
    
     A decorator can be attached to the server instance, the request, or the reply object; this depends on the context it belongs to.
    
    
     Let’s add this to
    
    <strong class="source-inline">
     
      app.js
     
    </strong>
    
     after removing the
    
    
     <strong class="source-inline">
      
       onRequest
      
     </strong>
    
    
     
      hook:
     
    
   </p>
   <pre class="source-code">
async function appPlugin (app, opts) {
  <strong class="bold">app.decorateRequest</strong>('isChef', function isChef () {
    return this.headers['x-api-key'] === 'fastify-rocks';
  });
  app.decorate('authOnlyChef', async function (request,
    reply) {
      if (!<strong class="bold">request.isChef()</strong>) {
        reply.code(401);
        throw new Error('Invalid API key');
      }
  });
  // ...
}</pre>
   <p>
    
     We’ve defined an
    
    <strong class="source-inline">
     
      isChef
     
    </strong>
    
     request
    
    <a id="_idIndexMarker395">
    </a>
    
     decorator, enabling the execution of the
    
    <strong class="source-inline">
     
      request.isChef()
     
    </strong>
    
     function within the
    
    <strong class="source-inline">
     
      appPlugin
     
    </strong>
    
     context and its child plugin instances.
    
    
     The logic within the
    
    <strong class="source-inline">
     
      isChef
     
    </strong>
    
     function is straightforward, returning a Boolean value of
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     only when a valid header is detected.
    
    
     It’s important to note that when we define a request or reply decorator, the
    
    <strong class="source-inline">
     
      this
     
    </strong>
    
     context refers to the request or reply object, respectively.
    
    
     This context is crucial for accessing these objects within the
    
    
     
      decorator function.
     
    
   </p>
   <p>
    
     Next, we introduced
    
    <a id="_idIndexMarker396">
    </a>
    
     an instance decorator named
    
    <strong class="source-inline">
     
      authOnlyChef
     
    </strong>
    
     .
    
    
     This decorator exposes a function with an identical API to the
    
    <strong class="source-inline">
     
      onRequest
     
    </strong>
    
     hook we previously defined.
    
    
     It can be accessed through the
    
    <strong class="source-inline">
     
      app.authOnlyChef
     
    </strong>
    
     property, offering a convenient way to apply authentication logic specific to chefs across various routes and plugins only
    
    
     
      when needed.
     
    
   </p>
   <p>
    
     Defining decorators doesn’t execute any logic; for them to execute on their own, we need to utilize them within our routes.
    
    
     Let’s proceed to the
    
    <strong class="source-inline">
     
      routes/orders.js
     
    </strong>
    
     file and modify the
    
    <strong class="source-inline">
     
      /orders/:orderId
     
    </strong>
    
     route to
    
    
     
      implement protection:
     
    
   </p>
   <pre class="source-code">
  app.patch('/orders/:orderId', {
    onRequest: app.authOnlyChef,
    handler: notImplemented
  });</pre>
   <p>
    
     We’ve configured the
    
    <strong class="source-inline">
     
      onRequest
     
    </strong>
    
     route’s option property to define a hook specific to this route.
    
    
     Fastify provides you with granularity in hook attachment; you can assign a hook function to an entire server instance or to an individual route.
    
    
     Additionally, you have the flexibility to set the
    
    <strong class="source-inline">
     
      onRequest
     
    </strong>
    
     field as an array of hook functions, which will be executed in the order they are added.
    
    
     This allows for precise control over the request
    
    
     
      processing flow.
     
    
   </p>
   <p>
    
     This syntax is perfect when you have a few routes to set up, but what if we have a lot of routes to
    
    <a id="_idIndexMarker397">
    </a>
    
     protect?
    
    
     Let’s
    
    <a id="_idIndexMarker398">
    </a>
    
     see what we can do in the
    
    
     <strong class="source-inline">
      
       routes/recipes.js
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
function recipesPlugin (app, opts, next) {
  app.get('/menu', { handler: menuHandler });
  app.get('/recipes', { handler: menuHandler });
  <strong class="bold">app.register</strong>(async function protectRoutesPlugin (plugin,
    opts) {
      <strong class="bold">plugin.addHook('onRequest', plugin.authOnlyChef);</strong>
      plugin.post('/recipes', async function addToMenu
        (request, reply) {
          throw new Error('Not implemented');
        });
      plugin.delete('/recipes/:id', function removeFromMenu
        (request, reply) {
          reply.send(new Error('Not implemented'));
        });
    });
  next();
}</pre>
   <p>
    
     To streamline the protection of the recipes routes, which consists of both protected and public routes, you can create a new
    
    <strong class="source-inline">
     
      protectRoutesPlugin
     
    </strong>
    
     plugin instance in
    
    <strong class="source-inline">
     
      recipesPlugin
     
    </strong>
    
     .
    
    
     Within this context, you can add the
    
    <strong class="source-inline">
     
      onRequest
     
    </strong>
    
     hook to all the routes defined in that context.
    
    
     In this case, I’ve named the first argument
    
    <strong class="source-inline">
     
      plugin
     
    </strong>
    
     to distinguish it from the
    
    <strong class="source-inline">
     
      app
     
    </strong>
    
     context.
    
    
     The
    
    <strong class="source-inline">
     
      plugin
     
    </strong>
    
     parameter serves as a child context of
    
    <strong class="source-inline">
     
      app
     
    </strong>
    
     , inheriting all the hooks and decorators up to the root application instance.
    
    
     This allows it to access the
    
    <strong class="source-inline">
     
      authOnlyChef
     
    </strong>
    
     function.
    
    
     Furthermore, we’ve moved only the routes that require protection into this new
    
    <strong class="source-inline">
     
      plugin
     
    </strong>
    
     function, effectively isolating them from the parent’s scope.
    
    
     Keep in mind that inheritance flows from parent to child contexts, not the other way around.
    
    
     This approach enhances code organization and maintains the benefits of encapsulation, isolation, and inheritance within the Fastify
    
    
     
      plugin system.
     
    
   </p>
   <p>
    
     With the changes we’ve made, you can now execute the
    
    <strong class="source-inline">
     
      curl
     
    </strong>
    
     commands that were initially tested in this recipe.
    
    
     You should expect to receive an
    
    <strong class="source-inline">
     
      Unauthorized
     
    </strong>
    
     error only for the routes that require protection, while the other routes should remain freely accessible.
    
    
     This demonstrates the successful implementation of authentication logic for selective
    
    
     
      route protection.
     
    
   </p>
   <p>
    
     Fastify has two distinct systems that govern its internal workflow: the
    
    <strong class="bold">
     
      application lifecycle
     
    </strong>
    
     and
    
    <a id="_idIndexMarker399">
    </a>
    
     the
    
    <strong class="bold">
     
      request lifecycle
     
    </strong>
    
     .
    
    
     While Fastify manages these
    
    <a id="_idIndexMarker400">
    </a>
    
     two lifecycles internally, it provides the flexibility for you to inject your custom logic by listening to and responding to the events associated with these lifecycles.
    
    
     This capability enables you to tailor the data
    
    <a id="_idIndexMarker401">
    </a>
    
     flow
    
    <a id="_idIndexMarker402">
    </a>
    
     around the endpoints according to your specific application requirements and
    
    
     
      use cases.
     
    
   </p>
   <p>
    
     When you are listening for events triggered by the application lifecycle, you should refer to
    
    <a id="_idIndexMarker403">
    </a>
    
     the
    
    <strong class="bold">
     
      application hooks
     
    </strong>
    
     (https://fastify.dev/docs/latest/Reference/Hooks#application-hooks).
    
    
     These hooks allow you to intervene during server startup and shutdown.
    
    
     Here is a quick list of these hooks and when they
    
    
     
      are emitted:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-4">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Hook name
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Emitted when…
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Interface
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           onRoute
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         a new endpoint is added to the
        
        
         
          server instance
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         It must be a
        
        
         
          sync function
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           onRegister
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         a new encapsulated context
        
        
         
          is created
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         It must be a
        
        
         
          sync function
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           onReady
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         the application loaded by the HTTP server is not yet listening for
        
        
         
          incoming requests
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         It can be a sync or an
        
        
         
          async function
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           onListen
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         the application is loaded, and the HTTP server is listening for
        
        
         
          incoming requests
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         It can be a sync or an async function.
        
        
         It does not block the application startup if it throws
        
        
         
          an error
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           preClose
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         the server starts the close phase and is still listening for
        
        
         
          incoming requests
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         It can be a sync or an
        
        
         
          async function
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           onClose
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         the server has stopped listening for new HTTP requests and is in the process of stopping, allowing you to perform cleanup or finalization tasks, such as closing a
        
        
         
          database connection
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         It can be a sync or an async function.
        
        
         This hook is executed in
        
        
         
          reverse order
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 6.1 – Application hooks overview
    
   </p>
   <p>
    <em class="italic">
     
      Table 6.1
     
    </em>
    
     provides a comprehensive overview of all the application hooks.
    
    
     It’s important to note that these hooks are executed in the order of their registration, except for the
    
    <strong class="source-inline">
     
      onClose
     
    </strong>
    
     hook, which follows a reverse order of execution because it ensures that the resources created last are the first to be closed, similar to how a
    
    <strong class="bold">
     
      last-in-first-out
     
    </strong>
    
     (
    
    <strong class="bold">
     
      LIFO
     
    </strong>
    
     ) queue
    
    <a id="_idIndexMarker404">
    </a>
    
     operates.
    
    
     This sequencing is essential for proper resource cleanup during server shutdown.
    
    
     Another important aspect that Fastify ensures is that if any of these hooks fail to execute successfully, the server will not start.
    
    
     This feature is valuable, as these hooks can be used to verify the readiness of essential external resources before they are
    
    <a id="_idIndexMarker405">
    </a>
    
     consumed by
    
    <a id="_idIndexMarker406">
    </a>
    
     the application’s handlers.
    
    
     It ensures that your application starts in a reliable state, enhancing robustness and stability.
    
    
     It’s important to note that the rule of preventing server startup upon hook failure does not apply to the
    
    <strong class="source-inline">
     
      onListen
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      onClose
     
    </strong>
    
     hooks.
    
    
     In these particular cases, Fastify guarantees that all registered hook functions will be executed, regardless of whether one of them encounters an error.
    
    
     This behavior ensures that necessary cleanup and finalization tasks are carried out during server startup and shutdown, even in the presence of errors in
    
    
     
      some hooks.
     
    
   </p>
   <p>
    
     The application hooks serve various purposes, but the main ones include
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Cache warm-up
      
     </strong>
     
      : You can use the
     
     <strong class="source-inline">
      
       onReady
      
     </strong>
     
      hook to prepare and preload a cache when the server is about to start, which can significantly enhance the performance of
     
     
      
       your handlers.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Resource Check
      
     </strong>
     
      : If your handlers rely on a third-party server or external resource, you can use these hooks to verify that the resource is up and running during server startup, ensuring that your application’s dependencies
     
     
      
       are available.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Monitoring
      
     </strong>
     
      : These hooks are valuable for logging and monitoring server startup information, such as configuration details or reasons for server shutdown, aiding in debugging
     
     
      
       and observability.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Aspect-oriented programming
      
     </strong>
     
      : By leveraging the
     
     <strong class="source-inline">
      
       onRegister
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       onRoute
      
     </strong>
     
      hooks, you can apply aspect-oriented programming techniques to manipulate route options and inject additional properties or behavior into your routes.
     
     
      This
     
     <a id="_idIndexMarker407">
     </a>
     
      allows for
     
     <a id="_idIndexMarker408">
     </a>
     
      the powerful customization and modularization of your
     
     
      
       application logic.
      
     
    </li>
   </ul>
   <p>
    
     As an exercise, try to add these hooks into every
    
    
     
      application’s files:
     
    
   </p>
   <pre class="source-code">
app.addHook('onReady', async function hook () {
  this.log.info(`onReady runs from file
    ${import.meta.url}`);
});
app.addHook('onClose', function hook (app, done) {
  app.log.info(`onClose runs from file
    ${import.meta.url}`);
  done()
});</pre>
   <p>
    
     Indeed, the
    
    <strong class="source-inline">
     
      this
     
    </strong>
    
     keyword in the context of these hooks represents the Fastify instance, granting you access to all of the server’s decorators and resources.
    
    
     This includes the application logger, which can be accessed in the common and well-established Fastify style.
    
    
     It’s worth noting that, similar to plugin declarations, the hooks in Fastify support both asynchronous and synchronous interfaces.
    
    
     In the case of asynchronous hooks, you don’t need to take any specific actions.
    
    
     However, in the case of synchronous hooks, you have access to a
    
    <strong class="source-inline">
     
      done
     
    </strong>
    
     argument, as shown in the
    
    <strong class="source-inline">
     
      onClose
     
    </strong>
    
     hook in the previous code snippet.
    
    
     It’s essential to call this function within the synchronous hook to indicate successful execution; otherwise, the hook pipeline will be blocked, and it will not complete until a timeout occurs, potentially leading to the
    
    
     
      server’s shutdown.
     
    
   </p>
   <p>
    
     After this comprehensive
    
    <a id="_idIndexMarker409">
    </a>
    
     overview of the application hooks, let’s now shift our focus to the
    
    <strong class="bold">
     
      request hooks
     
    </strong>
    
     (
    
    <a href="https://fastify.dev/docs/latest/Reference/Hooks#requestreply-hooks">
     
      https://fastify.dev/docs/latest/Reference/Hooks#requestreply-hooks
     
    </a>
    
     ), which are associated with the request lifecycle.
    
    
     This lifecycle delineates the various steps that
    
    <a id="_idIndexMarker410">
    </a>
    
     an
    
    <a id="_idIndexMarker411">
    </a>
    
     HTTP request undergoes when it enters the server.
    
    
     You can visualize this process in the
    
    
     
      following diagram:
     
    
   </p>
   <div><div><img alt="Figure 6.1 – The request lifecycle" src="img/B19212_06_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.1 – The request lifecycle
    
   </p>
   <p>
    
     In
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     , the request lifecycle steps are represented with dashed boxes containing the hook names triggered during that specific phase.
    
    
     Let’s follow the path of an incoming HTTP request and
    
    <a id="_idIndexMarker412">
    </a>
    
     describe what happens inside Fastify in the order
    
    
     
      of occurrence:
     
    
   </p>
   <ol>
    <li>
     <strong class="bold">
      
       Route selection
      
     </strong>
     
      : When an HTTP request is received, Fastify routes it to a specific handler based on the requested URL and HTTP method.
     
     
      If no matching route is found, Fastify’s default 404 handler
     
     
      
       is executed.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Request initiation
      
     </strong>
     
      : After the route handler is determined, the
     
     <strong class="source-inline">
      
       onRequest
      
     </strong>
     
      hook is executed.
     
     
      During this phase, the request’s body has not been parsed yet.
     
     
      The request object does not contain the
     
     <strong class="source-inline">
      
       body
      
     </strong>
     
      property.
     
     
      This is an appropriate point to discard any requests that should not be processed, such as unauthorized ones.
     
     
      Since the request payload has yet to be read, server resources are not wasted on
     
     
      
       unnecessary processing.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Request payload manipulation
      
     </strong>
     
      : If the HTTP request is deemed processable, the
     
     <strong class="source-inline">
      
       preParsing
      
     </strong>
     
      hook provides access to the request’s payload stream, which can be manipulated.
     
     
      Common use cases include decrypting an encrypted request payload or decompressing
     
     
      
       user input.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Payload validation
      
     </strong>
     
      : Fastify includes a built-in validation system, which we will explore further in the
     
     <em class="italic">
      
       Validating the input data
      
     </em>
     
      recipe of this chapter.
     
     
      You can modify the parsed payload before
     
     <a id="_idIndexMarker413">
     </a>
     
      it undergoes validation by listening to the
     
     
      <strong class="source-inline">
       
        preValidation
       
      </strong>
     
     
      
       hook.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Full request parsing
      
     </strong>
     
      : Just before executing the route handler, which contains the business logic, the
     
     <strong class="source-inline">
      
       preHandler
      
     </strong>
     
      hook is executed.
     
     
      During this phase, the request is fully parsed, and you can access its content via the
     
     
      <strong class="source-inline">
       
        request.body
       
      </strong>
     
     
      
       field.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Route handler execution
      
     </strong>
     
      : The request enters the main route handler to execute the function
     
     <a id="_idIndexMarker414">
     </a>
     
      associated with the route definition.
     
     
      When you use
     
     <strong class="source-inline">
      
       reply.send()
      
     </strong>
     
      or return a payload as the response, the last phase begins to send the response payload to
     
     
      
       the client.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Payload serialization
      
     </strong>
     
      : Before the serialization process occurs, the
     
     <strong class="source-inline">
      
       preSerialization
      
     </strong>
     
      hook is triggered.
     
     
      Here, you can manipulate the payload, adapt it to a specific format, or convert non-serializable objects into plain
     
     
      
       JSON objects.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Response preparation
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       onSend
      
     </strong>
     
      hook is called just before sending the response payload to the client.
     
     
      It can access the serialized payload content and apply additional manipulations, such as encryption
     
     
      
       or compression.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Request completion
      
     </strong>
     
      : Finally, the last step in the request lifecycle is the
     
     <strong class="source-inline">
      
       onResponse
      
     </strong>
     
      hook.
     
     
      This hook is executed after the payload has been successfully sent to the client, marking the completion of the
     
     
      
       HTTP request.
      
     
    </li>
   </ol>
   <p>
    
     Indeed, many things are involved when a simple HTTP request enters the Fastify server, as highlighted in the request lifecycle.
    
    
     Moreover,
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     illustrates three additional hooks dedicated to managing errors that may occur throughout the entire request lifecycle.
    
    
     These error-specific hooks provide the means to handle errors gracefully and effectively, ensuring the
    
    <a id="_idIndexMarker415">
    </a>
    
     reliability and robustness of your Fastify
    
    <a id="_idIndexMarker416">
    </a>
    
     application.
    
    
     These three error-specific hooks in Fastify provide ways to manage different
    
    
     
      error scenarios:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       onTimeout
      
     </strong>
     
      : This hook is triggered when a connection socket is in an idle state.
     
     
      To enable this hook, you must set the server’s
     
     <strong class="source-inline">
      
       connectionTimeout
      
     </strong>
     
      option (the default value is
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      , which means disabled).
     
     
      The value you specify in milliseconds determines the maximum time the application has to complete the request lifecycle.
     
     
      If this time limit is exceeded, the
     
     <strong class="source-inline">
      
       onTimeout
      
     </strong>
     
      hook kicks in and closes
     
     
      
       the connection.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       onError
      
     </strong>
     
      : The hook is triggered when the server sends an error as the response payload to the client.
     
     
      It allows you to perform custom actions when errors occur during
     
     
      
       request processing.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       onRequestAbort
      
     </strong>
     
      : This hook is executed when a client prematurely closes the connection before the request is fully processed.
     
     
      In such cases, you won’t be able to send data to the client since the connection has already been closed.
     
     
      This hook is useful for cleaning up any resources associated with the
     
     
      
       aborted request.
      
     
    </li>
   </ul>
   <p>
    
     You’ve now gained a comprehensive understanding of Fastify’s hooks, which will be invaluable as you dive deeper into using the plugin system.
    
    
     So, let’s start to use all of Fastify’s powerful
    
    <a id="_idIndexMarker417">
    </a>
    
     features, including hooks, decorators, and
    
    <a id="_idIndexMarker418">
    </a>
    
     plugins, to implement the fantasy restaurant
    
    
     
      business logic.
     
    
   </p>
   <h1 id="_idParaDest-189">
    <a id="_idTextAnchor196">
    </a>
    
     Breaking the encapsulation
    
   </h1>
   <p>
    
     In this new recipe, we’ll
    
    <a id="_idIndexMarker419">
    </a>
    
     delve deeper into the
    
    <a id="_idIndexMarker420">
    </a>
    
     world of the Fastify plugin system, expanding our understanding beyond what we’ve explored so far.
    
    
     Fastify offers a wide array of tools, each serving specific purposes, and gaining familiarity with them will greatly enhance your ability to customize and control various aspects of your application’s lifecycle
    
    
     
      and behavior.
     
    
   </p>
   <h2 id="_idParaDest-190">
    <a id="_idTextAnchor197">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     In the previous
    
    <em class="italic">
     
      Implementing authentication with hooks
     
    </em>
    
     recipe, we learned about various hooks, but we didn’t see their practical application.
    
    
     Now, let’s apply our knowledge by developing a custom authentication plugin.
    
    
     Currently, our authentication logic is dispersed across the
    
    <strong class="source-inline">
     
      app.js
     
    </strong>
    
     file, which is then utilized by both
    
    <strong class="source-inline">
     
      orders.js
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      recipes.js
     
    </strong>
    
     .
    
    
     While it works, it lacks centralization.
    
    
     To address this, we aim to create a company-wide plugin that can be easily integrated into all our projects, providing standardized authentication logic right out of the box when registering
    
    
     
      the plugin.
     
    
   </p>
   <h2 id="_idParaDest-191">
    <a id="_idTextAnchor198">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To create a common
    
    <a id="_idIndexMarker421">
    </a>
    
     plugin
    
    <a id="_idIndexMarker422">
    </a>
    
     by breaking the
    
    <strong class="bold">
     
      encapsulation
     
    </strong>
    
     , we need to follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       plugins/auth.js
      
     </strong>
     
      instance in a new folder and then move the decorators from
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      to this
     
     
      
       new file:
      
     
     <pre class="source-code">
async function authPlugin (app, opts) {
  app.decorateRequest('isChef', function () {
    return this.headers['x-api-key'] === 'fastify-
      rocks';
  });
  app.decorate('authOnlyChef', async function(request,
    reply){
      if (!request.isChef()) {
        reply.code(401);
        throw new Error('Invalid API key');
      }
    });
}
export default authPlugin;</pre>
    </li>
    <li>
     
      As usual, register the plugin in the
     
     
      <strong class="source-inline">
       
        app.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
import authPlugin from './plugins/auth.js';
async function appPlugin (app, opts) {
  <strong class="bold">app.register(authPlugin);</strong>
<strong class="bold">  app.register(recipesPlugin);</strong>
<strong class="bold">  app.register(ordersPlugin);</strong>
}</pre>
     <p class="list-inset">
      
       This is nothing
      
      <a id="_idIndexMarker423">
      </a>
      
       new
      
      <a id="_idIndexMarker424">
      </a>
      
       so far, but if you try to start the server, it won’t work.
      
      
       Let me show you why by drawing the Fastify
      
      
       
        contexts structure:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 6.2 – Fastify tree structure" src="img/B19212_06_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.2 – Fastify tree structure
    
   </p>
   <p class="list-inset">
    
     In
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     , every node represents a self-contained context.
    
    
     Thanks to the plugin system, each of these contexts can possess its own hooks, decorators, and plugins.
    
    
     On the left side of the figure, you can observe the current structure of our application.
    
    
     Notably, the decorators defined within the
    
    <strong class="source-inline">
     
      authPlugin
     
    </strong>
    
     function are not accessible to either the
    
    <strong class="source-inline">
     
      recipesPlugin
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      ordersPlugin
     
    </strong>
    
     functions due to isolation.
    
    
     To rectify this, we should consider relocating the
    
    <strong class="source-inline">
     
      authPlugin
     
    </strong>
    
     node higher up in the tree structure.
    
    
     By doing so, the recipes and orders plugins would inherit the decorators, allowing for seamless integration and functionality.
    
    
     Implementing this action would entail having
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     register
    
    <strong class="source-inline">
     
      authPlugin
     
    </strong>
    
     and, subsequently,
    
    <strong class="source-inline">
     
      authPlugin
     
    </strong>
    
     register
    
    <strong class="source-inline">
     
      appPlugin
     
    </strong>
    
     .
    
    
     While this approach would work, it leads to a source code that is challenging to comprehend due to its complexity and nested dependencies.
    
    
     For this reason, in this case, we want to
    
    <strong class="bold">
     
      break the encapsulation
     
    </strong>
    
     , as
    
    <a id="_idIndexMarker425">
    </a>
    
     shown
    
    <a id="_idIndexMarker426">
    </a>
    
     on the right side of
    
    
     <em class="italic">
      
       Figure
      
     </em>
    
    
     <em class="italic">
      
       6
      
     </em>
    
    
     <em class="italic">
      
       .2
      
     </em>
    
    
     
      .
     
    
   </p>
   <ol>
    <li value="3">
     
      Install a new module by running
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      <strong class="source-inline">
       
        install fastify-plugin@5
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Wrap the
     
     <strong class="source-inline">
      
       authPlugin
      
     </strong>
     
      function with the
     
     <strong class="source-inline">
      
       fastify-plugin
      
     </strong>
     
      , as shown in the following
     
     
      
       code snippet:
      
     
     <pre class="source-code">
<strong class="bold">import fp from 'fastify-plugin';</strong>
async function authPlugin (app, opts) {
  // ...
}
export default <strong class="bold">fp(</strong>authPlugin<strong class="bold">)</strong>;</pre>
     <p class="list-inset">
      
       Upon restarting the server, everything should function as it did previously.
      
      
       This is because breaking the encapsulation context is like using the parent Fastify instance.
      
      
       If we were to apply
      
      <strong class="source-inline">
       
        fastify-plugin
       
      </strong>
      
       to every file we’ve implemented thus far, we would essentially consolidate everything into a single context, equivalent to the root application context.
      
      
       Unfortunately, this would result in the loss of all the capabilities provided by the plugin system.
      
      
       As a general rule of thumb, you may use
      
      <strong class="source-inline">
       
        fastify-plugin
       
      </strong>
      
       exclusively for those plugins that you intend to reuse across
      
      
       
        your organization.
       
      
     </p>
    </li>
    <li>
     
      Our work is not yet complete, as we have only moved the decorators.
     
     
      Now, our objective is to centralize how the routes apply the authentication logic.
     
     
      To achieve this, we will utilize the
     
     <strong class="source-inline">
      
       onRoute
      
     </strong>
     
      hook.
     
     
      Add this code to the
     
     
      <strong class="source-inline">
       
        auth.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
async function authPlugin (app, opts) {
  // ...
  app.addHook('onRoute', <strong class="bold">function hook (routeOptions)</strong> {
    if (routeOptions.config?.auth === true) {
      routeOptions.onRequest =
      [app.authOnlyChef].concat(routeOptions.onRequest
        || []);
    }
  });
}</pre>
     <p class="list-inset">
      
       As mentioned in the
      
      <em class="italic">
       
        There’s more...
       
      </em>
      
       section of the
      
      <em class="italic">
       
        Implement authentication with hooks
       
      </em>
      
       recipe, the
      
      <strong class="source-inline">
       
        onRoute
       
      </strong>
      
       hook must be a synchronous function.
      
      
       It receives the route’s
      
      <a id="_idIndexMarker427">
      </a>
      
       options
      
      <a id="_idIndexMarker428">
      </a>
      
       as its first argument.
      
      
       The purpose of this function is to check whether
      
      <strong class="source-inline">
       
        routeOptions
       
      </strong>
      
       includes an
      
      <strong class="source-inline">
       
        auth
       
      </strong>
      
       flag set to true.
      
      
       If this condition is met, we inject the
      
      <strong class="source-inline">
       
        authOnlyChef
       
      </strong>
      
       decorator function
      
      
       
        into
       
      
      
       <strong class="source-inline">
        
         routeOptions.onRequest
        
       </strong>
      
      
       
        .
       
      
     </p>
     <p class="list-inset">
      
       It’s worth emphasizing that the code ensures
      
      <strong class="source-inline">
       
        authOnlyChef
       
      </strong>
      
       is the first function in the
      
      <strong class="source-inline">
       
        onRequest
       
      </strong>
      
       chain.
      
      
       This is significant because Fastify executes these functions in the order they appear.
      
      
       Additionally, it’s worth mentioning that the input
      
      <strong class="source-inline">
       
        routeOption.onRequest
       
      </strong>
      
       can either be an array of hooks or a single function.
      
      
       The code example handles both scenarios seamlessly using the
      
      
       <strong class="source-inline">
        
         Array.concat()
        
       </strong>
      
      
       
        function.
       
      
     </p>
    </li>
    <li>
     
      Now, we can go back to the
     
     <strong class="source-inline">
      
       orders.js
      
     </strong>
     
      file and update the
     
     <strong class="source-inline">
      
       PATCH /orders/:orderId
      
     </strong>
     
      handler
     
     
      
       as follows:
      
     
     <pre class="source-code">
  app.patch('/orders/:orderId', {
    <strong class="bold">config: { auth: true },</strong>
    handler: notImplemented
  });</pre>
     <p class="list-inset">
      
       We have replaced the previous
      
      <strong class="source-inline">
       
        onRequest
       
      </strong>
      <strong class="source-inline">
       
        [app.authOnlyChef]
       
      </strong>
      
       configuration with the
      
      
       
        new approach.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     By utilizing the route’s
    
    <strong class="source-inline">
     
      config
     
    </strong>
    
     property, we isolate your application’s properties from Fastify’s fields to prevent conflicts.
    
    
     This updated setup offers several advantages, including the ability of
    
    <strong class="source-inline">
     
      authPlugin
     
    </strong>
    
     to evolve over time without necessitating changes to your routes’ configurations with every update.
    
    
     This pattern aligns with
    
    <strong class="bold">
     
      aspect-oriented programming
     
    </strong>
    
     , as it
    
    <a id="_idIndexMarker429">
    </a>
    
     dynamically introduces a feature through a straightforward
    
    <a id="_idIndexMarker430">
    </a>
    
     
      Boolean
     
    
    
     <a id="_idIndexMarker431">
     </a>
    
    
     
      configuration.
     
    
   </p>
   <h2 id="_idParaDest-192">
    <a id="_idTextAnchor199">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     As an exercise, try to update the
    
    <strong class="source-inline">
     
      recipes.js
     
    </strong>
    
     file by yourself now, and then compare your code with the
    
    
     
      following solution:
     
    
   </p>
   <pre class="source-code">
function recipesPlugin (app, opts, next) {
  // ...
  app.post('/recipes', {
    <strong class="bold">config: { auth: true },</strong>
    handler: async function addToMenu (request, reply) {
      throw new Error('Not implemented');
    }
  });
  app.delete('/recipes/:id', {
    <strong class="bold">config: { auth: true },</strong>
    handler: function removeFromMenu (request, reply) {
      reply.send(new Error('Not implemented'));
    }
  });
  next();
}</pre>
   <p>
    
     As was previously carried out, we have set the
    
    <strong class="source-inline">
     
      config.auth
     
    </strong>
    
     option, and we deleted the
    
    <strong class="source-inline">
     
      protectRoutesPlugin
     
    </strong>
    
     code because creating an encapsulated context is no
    
    
     
      longer necessary.
     
    
   </p>
   <p>
    
     Well done!
    
    
     In this recipe, we’ve covered a lot, beginning with hooks, moving on to decorators, and learning how
    
    <a id="_idIndexMarker432">
    </a>
    
     to
    
    <a id="_idIndexMarker433">
    </a>
    
     manage encapsulated contexts and break them when necessary.
    
    
     In the next recipe, we’ll dive into implementing the business logic for our routes, which we’ve only declared up to this point.
    
    
     So, let’s gear up and
    
    
     
      get started!
     
    
   </p>
   <h1 id="_idParaDest-193">
    <a id="_idTextAnchor200">
    </a>
    
     Implementing business logic using hooks
    
   </h1>
   <p>
    
     The APIs for the
    
    <a id="_idIndexMarker434">
    </a>
    
     fantasy restaurant have a specific goal: to
    
    <a id="_idIndexMarker435">
    </a>
    
     serve our restaurant’s needs.
    
    
     In the
    
    <em class="italic">
     
      Adding
     
    </em>
    <em class="italic">
     
      routes
     
    </em>
    
     recipe, we examined the general flow but didn’t delve into details, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      What constitutes the input for
     
     
      
       each endpoint?
      
     
    </li>
    <li>
     
      What should be the expected output of
     
     
      
       each service?
      
     
    </li>
    <li>
     
      Where should we store
     
     
      
       the data?
      
     
    </li>
   </ul>
   <p>
    
     In this recipe, we will explore these crucial aspects in greater detail.
    
    
     So, let’s start with the data and
    
    
     
      its storage!
     
    
   </p>
   <h2 id="_idParaDest-194">
    <a id="_idTextAnchor201">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     We require a database to store and retrieve application data.
    
    
     For this purpose, we will employ the well-known NoSQL
    
    <a id="_idIndexMarker436">
    </a>
    
     database
    
    <strong class="bold">
     
      MongoDB
     
    </strong>
    
     (
    
    <a href="https://www.mongodb.com/">
     
      https://www.mongodb.com/
     
    </a>
    
     ).
    
    
     MongoDB is a popular NoSQL database that stores data in flexible, JSON-like documents, providing scalability and high performance for various applications.
    
    
     It’s important to note that the details of MongoDB are not the primary focus of this chapter, so I won’t delve into extensive descriptions of its
    
    
     
      inner workings.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     If you have a Docker installation, you can run a MongoDB server by running this command line:
    
    <strong class="source-inline">
     
      docker run -d -p 27017:27017 --name fastify-mongo mongo:5
     
    </strong>
    
     .
    
    
     It will start a container using the official MongoDB image, and it will be ready to use.
    
    
     Finally, to stop it, you can run this command instead:
    
    <strong class="source-inline">
     
      docker container
     
    </strong>
    
     <strong class="source-inline">
      
       stop fastify-mongo
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-195">
    <a id="_idTextAnchor202">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To connect our
    
    <a id="_idIndexMarker437">
    </a>
    
     application
    
    <a id="_idIndexMarker438">
    </a>
    
     to MongoDB, we need to follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Install the official
     
     
      
       Fastify module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm i @fastify/mongodb@9</strong></pre>
    </li>
    <li>
     
      Then, we can create a new plugin in the
     
     <strong class="source-inline">
      
       plugins/datasource.js
      
     </strong>
     
      file, where we will connect to
     
     
      
       the database:
      
     
     <pre class="source-code">
import fp from 'fastify-plugin';
import fastifyMongo from '@fastify/mongodb';
async function datasourcePlugin (app, opts) {
  app.log.info('Connecting to MongoDB')
  app.register(fastifyMongo, {
    url: 'mongodb://localhost:27017/restaurant'
  });
}
export default fp(datasourcePlugin);</pre>
    </li>
    <li>
     
      Update
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      , adding the
     
     <strong class="source-inline">
      
       app.register(datasourcePlugin)
      
     </strong>
     
      code, as was carried out in
     
     <em class="italic">
      
       Step 2
      
     </em>
     
      of the
     
     <em class="italic">
      
       Breaking the
      
     </em>
     
      <em class="italic">
       
        encapsulation
       
      </em>
     
     
      
       recipe.
      
     
    </li>
    <li>
     
      If you launch the application with a properly initialized database, it should start as usual, and you should observe the new log line we added to confirm that our plugin is
     
     
      
       being loaded.
      
     
    </li>
    <li>
     
      Next, we must establish a data layer between the MongoDB data source and our business logic.
     
     
      This allows us to identify the essential actions our routes must execute and extract a subset of these actions to be defined
     
     
      
       as decorators:
      
     
     <pre class="source-code">
async function datasourcePlugin (app, opts) {
  app.register(fastifyMongo, { ... });
  app.decorate('<strong class="bold">source</strong>', {
    async <strong class="bold">insertRecipe</strong> (recipe) { /* todo */ },
    async <strong class="bold">readRecipes</strong> (filters, sort) { /* todo */ },
    async <strong class="bold">deleteRecipe</strong> (recipeId) { /* todo */ },
    async <strong class="bold">insertOrder</strong> (order) { /* todo */ },
    async <strong class="bold">readOrders</strong> (filters, sort) { /* todo */ },
    async <strong class="bold">markOrderAsDone</strong> (orderId) { /* todo */ }
  });
}</pre>
    </li>
    <li>
     
      In the previous
     
     <a id="_idIndexMarker439">
     </a>
     
      code
     
     <a id="_idIndexMarker440">
     </a>
     
      snippet, we added a new
     
     <strong class="source-inline">
      
       source
      
     </strong>
     
      object decorator.
     
     
      Each object’s field references an
     
     <strong class="source-inline">
      
       async
      
     </strong>
     
      function that will perform only what the name says.
     
     
      So, let’s start to implement the
     
     
      
       first function:
      
     
     <pre class="source-code">
    async insertRecipe (recipe) {
      const { db } = app.mongo;
      const _id = new app.mongo.ObjectId();
      recipe._id = _id;
      recipe.id = _id.toString();
      const collection = db.collection('menu');
      const result = await
        collection.insertOne(recipe);
      return result.insertedId;
    }</pre>
     <p class="list-inset">
      
       This function inserts the input JSON object
      
      <strong class="source-inline">
       
        recipe
       
      </strong>
      
       into the
      
      <strong class="source-inline">
       
        menu
       
      </strong>
      
       collection and returns the generated id.
      
      
       As said, this data layer should not perform any business logic.
      
      <strong class="source-inline">
       
        app.mongo
       
      </strong>
      
       is a decorator created by the
      
      <strong class="source-inline">
       
        @fastify/mongodb
       
      </strong>
      
       module, as documented here:
      
      <a href="https://github.com/fastify/fastify-mongodb">
       
        https://github.com/fastify/fastify-mongodb
       
      </a>
      
       , and this refers to the MongoDB Client, so you have total control
      
      
       
        over it.
       
      
     </p>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     In the preceding code block, the
    
    <strong class="source-inline">
     
      _id
     
    </strong>
    
     property in
    
    <strong class="source-inline">
     
      recipe._id = _id;
     
    </strong>
    
     and the
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     property in
    
    <strong class="source-inline">
     
      recipe.id = _id.toString()
     
    </strong>
    
     have the same value.
    
    
     We introduce the
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     property to prevent the exposure of any information related to our database.
    
    
     While we utilize the
    
    <strong class="source-inline">
     
      _id
     
    </strong>
    
     property, it is primarily defined and employed by MongoDB servers for internal purposes, and we opt to use
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     to maintain a level of abstraction and security in our
    
    
     
      application’s data.
     
    
   </p>
   <ol>
    <li value="7">
     
      To use the
     
     <strong class="source-inline">
      
       insertRecipe
      
     </strong>
     
      function, we
     
     <a id="_idIndexMarker441">
     </a>
     
      need to
     
     <a id="_idIndexMarker442">
     </a>
     
      implement the
     
     <strong class="source-inline">
      
       POST /recipes
      
     </strong>
     
      endpoint
     
     
      
       as follows:
      
     
     <pre class="source-code">
  app.post('/recipes', {
    config: { auth: true },
    handler: async function addToMenu (request, reply)
    {
      const { name, country, description, order, price
        } = <strong class="bold">request.body</strong>;
      const newPlateId = await
        <strong class="bold">app.source.insertRecipe</strong>({
          name,
          country,
          description,
          order,
          price,
          createdAt: new Date()
        });
      reply.code(201);
      <strong class="bold">return { id: newPlateId };</strong>
    }
  });</pre>
     <p class="list-inset">
      
       When the
      
      <strong class="source-inline">
       
        addToMenu
       
      </strong>
      
       function handler runs, we are 100% sure that the authentication hook is successful and only a valid chef is executing it.
      
      
       So, the function logic reads from the
      
      <strong class="source-inline">
       
        request.body
       
      </strong>
      
       input data to compose a new JSON object.
      
      
       This
      
      <a id="_idIndexMarker443">
      </a>
      
       step is required to
      
      <a id="_idIndexMarker444">
      </a>
      
       avoid inserting unexpected fields (into the database) that a client may submit to our endpoint.
      
      
       Then, the
      
      <strong class="source-inline">
       
        app.source.insertRecipe
       
      </strong>
      
       decorator is called to save the data.
      
      
       As the last operations, we set the HTTP response status to
      
      <strong class="source-inline">
       
        201 – Created
       
      </strong>
      
       (for a complete list of the standard HTTP status codes, refer to the list
      
      
       
        here:
       
      
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">
       
        
         https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
        
       
      </a>
      
       
        ).
       
      
     </p>
    </li>
    <li>
     
      We can try it now by running this
     
     
      <strong class="source-inline">
       
        curl
       
      </strong>
     
     
      
       command:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -X POST http://localhost:3000/recipes -H "Content-Type: application/json" -H "x-api-key: fastify-rocks" -d '{"name":"Lasagna","country":"Italy","price":12}'</strong>
<strong class="bold">{"id":"64f9f3eaee2d03172a8c5efe"}</strong></pre>
     <p class="list-inset">
      
       Our test is not over yet.
      
      
       You must try to run the same
      
      <strong class="source-inline">
       
        curl
       
      </strong>
      
       command, but you need to remove the
      
      <strong class="source-inline">
       
        x-api-key
       
      </strong>
      
       header or change its value.
      
      
       We expect a
      
      <strong class="source-inline">
       
        401 – Unauthorize
       
      </strong>
      
       error in
      
      
       
        these cases.
       
      
     </p>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Instead of using
    
    <strong class="source-inline">
     
      curl
     
    </strong>
    
     to run HTTP requests against the application server, adopting an HTTP Client
    
    <a id="_idIndexMarker445">
    </a>
    
     with a
    
    <strong class="bold">
     
      graphic user interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GUI
     
    </strong>
    
     ) may be easier.
    
    
     Here is a complete list where you may choose your favorite
    
    
     
      one:
     
    
    <a href="https://github.com/mrmykey/awesome-http-clients/blob/main/Readme.md#gui">
     
      
       https://github.com/mrmykey/awesome-http-clients/blob/main/Readme.md#gui
      
     
    </a>
    
     
      .
     
    
   </p>
   <ol>
    <li value="9">
     
      Before considering
     
     <a id="_idIndexMarker446">
     </a>
     
      this
     
     <a id="_idIndexMarker447">
     </a>
     
      section completed, we need to read from the database, so let’s implement the
     
     <strong class="source-inline">
      
       readRecipes
      
     </strong>
     
      function in the
     
     
      <strong class="source-inline">
       
        plugins/datasource.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
    async readRecipes (filters, sort = { order: 1 }) {
      const collection =
        app.mongo.db.collection('menu');
      const result = await
        collection.find(filters).sort(sort).toArray();
      return result;
    }</pre>
     <p class="list-inset">
      
       In this search function, we are using the standard MongoDB APIs (
      
      <a href="https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/">
       
        https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/
       
      </a>
      
       ).
      
      
       We may want to filter the data, so we expect a
      
      <strong class="source-inline">
       
        filters
       
      </strong>
      
       parameter.
      
      
       The
      
      <strong class="source-inline">
       
        sort
       
      </strong>
      
       argument, instead, is needed to return the dishes array in the right order, whereby, e.g., the appetizer will have
      
      <strong class="source-inline">
       
        order=0
       
      </strong>
      
       , the first course will have
      
      <strong class="source-inline">
       
        order=1
       
      </strong>
      
       , and
      
      
       
        so on.
       
      
     </p>
    </li>
    <li>
     
      Finally, we can update the
     
     <strong class="source-inline">
      
       routes/recipes.js
      
     </strong>
     
      file with the new
     
     
      <strong class="source-inline">
       
        menuHandler
       
      </strong>
     
     
      
       code:
      
     
     <pre class="source-code">
async function menuHandler (request, reply) {
  const recipes = await this.source.readRecipes();
  return recipes;
}</pre>
    </li>
    <li>
     
      As usual, we can try to see if this code is working as expected by calling the server to see
     
     
      
       the result:
      
     
     <pre class="source-code">
<strong class="bold">$ curl http://localhost:3000/menu</strong></pre>
     <p class="list-inset">
      
       The
      
      <strong class="source-inline">
       
        /menu
       
      </strong>
      
       endpoint should answer with an array of all the dishes we stored in the menu collection during our
      
      
       
        testing phase!
       
      
     </p>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Should we implement pagination?
    
    
     Our
    
    <strong class="source-inline">
     
      GET /menu
     
    </strong>
    
     endpoint provides a list of data, and it’s considered a best practice to assess whether the list might be excessively large to return in a single HTTP call.
    
    
     In this specific case, it’s deemed acceptable to return the entire menu.
    
    
     However, if the menu were to contain hundreds of recipes, you might want to consider implementing pagination logic to break the data into manageable chunks.
    
    
     You can find guidance on how to implement two different pagination patterns in this article:
    
    <a href="https://backend.cafe/streaming-postgresql-data-with-fastify">
     
      https://backend.cafe/streaming-postgresql-data-with-fastify
     
    </a>
    
     .
    
    
     Although the article discusses PostgreSQL, these pagination patterns can also be adapted for use
    
    
     
      with MongoDB.
     
    
   </p>
   <p>
    
     In this recipe, we’ve
    
    <a id="_idIndexMarker448">
    </a>
    
     learned
    
    <a id="_idIndexMarker449">
    </a>
    
     how to establish a connection to a database.
    
    
     It’s worth noting that Fastify contributors provide support for various popular databases, including
    
    <strong class="bold">
     
      PostgreSQL
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      MySQL
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      Redis
     
    </strong>
    
     , among
    
    <a id="_idIndexMarker450">
    </a>
    
     others.
    
    
     You can find a comprehensive
    
    <a id="_idIndexMarker451">
    </a>
    
     list of
    
    <a id="_idIndexMarker452">
    </a>
    
     supported databases at
    
    <a href="https://fastify.dev/ecosystem">
     
      https://fastify.dev/ecosystem
     
    </a>
    
     .
    
    
     In the upcoming recipe, we will discuss the data validation used to protect our endpoints from malicious users, and we will keep on implementing the missing
    
    
     
      routes’ handlers.
     
    
   </p>
   <h1 id="_idParaDest-196">
    <a id="_idTextAnchor203">
    </a>
    
     Validating the input data
    
   </h1>
   <p>
    
     In the
    
    <em class="italic">
     
      Implementing the business logic
     
    </em>
    
     recipe, we
    
    <a id="_idIndexMarker453">
    </a>
    
     stored input data from the
    
    <strong class="source-inline">
     
      POST /recipes
     
    </strong>
    
     endpoint in the database.
    
    
     However, we did not implement any validation logic, which means we could potentially insert a string into the
    
    <strong class="source-inline">
     
      price
     
    </strong>
    
     field or a recipe without
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     .
    
    
     Furthermore, it’s important to consider security concerns, as a malicious user could potentially insert a recipe with a description that’s excessively large, posing a risk to your application’s performance
    
    
     
      and storage.
     
    
   </p>
   <p>
    
     In the backend world, there is a rule: never trust the user’s input.
    
    
     Fastify knows it well, so it integrates a powerful and feature-complete validation process.
    
    
     Let’s see it
    
    
     
      in action.
     
    
   </p>
   <h2 id="_idParaDest-197">
    <a id="_idTextAnchor204">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to integrate the
    
    
     
      validation process:
     
    
   </p>
   <ol>
    <li>
     
      Add the
     
     <strong class="source-inline">
      
       schema
      
     </strong>
     
      property to the
     
     <strong class="source-inline">
      
       POST /recipes
      
     </strong>
     
      
       route option:
      
     
     <pre class="source-code">
  const <strong class="bold">jsonSchemaBody</strong> = {
    type: 'object',
    required: ['name', 'country', 'order', 'price'],
    properties: {
      name: { type: 'string', minLength: 3, maxLength:
        50 },
      country: { type: 'string', enum: ['ITA', 'IND']
        },
      description: { type: 'string' },
      order: { type: 'number', minimum: 0, maximum:
        100 },
      price: { type: 'number', minimum: 0, maximum: 50
        }
    }
  };
  app.post('/recipes', {
    config: { auth: true },
    <strong class="bold">schema</strong>: {
      <strong class="bold">body: jsonSchemaBody</strong>
    },
    handler: async function addToMenu (request, reply)
    {
      // ...
    }
  });</pre>
     <p class="list-inset">
      
       The
      
      <strong class="source-inline">
       
        jsonSchemaBody
       
      </strong>
      
       constant is an object defined in
      
      <a id="_idIndexMarker454">
      </a>
      
       the
      
      <strong class="bold">
       
        JSON schema
       
      </strong>
      
       format.
      
      
       This format adheres to the specifications outlined in the JSON schema standard, which provides a framework for describing the structure and constraints of JSON documents, including those in request bodies.
      
      
       By employing a JSON schema interpreter, you can assess whether a given JSON object conforms to a
      
      <a id="_idIndexMarker455">
      </a>
      
       predefined structure and constraints, enhancing the validation process for your API requests.
      
      
       Fastify includes the
      
      <a id="_idIndexMarker456">
      </a>
      
       AJV (
      
      <a href="https://ajv.js.org/">
       
        https://ajv.js.org/
       
      </a>
      
       ) module to process the JSON schemas and validate the
      
      
       
        request’s components.
       
      
     </p>
     <p class="list-inset">
      
       The route option
      
      <strong class="source-inline">
       
        schema
       
      </strong>
      
       property accepts
      
      
       
        these fields:
       
      
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        
         body
        
       </strong>
       
        : This schema is used to validate the
       
       <strong class="source-inline">
        
         request.body
        
       </strong>
       
        during the request evaluation, as we saw in
       
       
        <em class="italic">
         
          Figure 6.2
         
        </em>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         params
        
       </strong>
       
        : This schema validates
       
       <strong class="source-inline">
        
         request.params
        
       </strong>
       
        , which contains the path parameters of the
       
       
        
         request URL.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         headers
        
       </strong>
       
        : It is possible to validate
       
       <strong class="source-inline">
        
         request.headers
        
       </strong>
       
        ; therefore, we may improve the routes protected by the authentication by adding a JSON schema that requires the
       
       <strong class="source-inline">
        
         x-api-key
        
       </strong>
       
        header to
       
       
        
         be set.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         query
        
       </strong>
       
        : We can validate the
       
       <strong class="source-inline">
        
         request.query
        
       </strong>
       
        object that contains all the query string parameters by
       
       
        
         using this.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         response
        
       </strong>
       
        : This field is a special one, and it does not accept a JSON schema out of the box.
       
       
        We will see it in action in the next
       
       <em class="italic">
        
         Enhancing application performance with
        
       </em>
       
        <em class="italic">
         
          serialization
         
        </em>
       
       
        
         recipe.
        
       
      </li>
     </ul>
    </li>
    <li>
     
      Now, if we restart the server with the new route’s configuration, we will hit our first
     
     <strong class="source-inline">
      
       400 –
      
     </strong>
     <strong class="source-inline">
      
       Bad Request
      
     </strong>
     
      response by running the same command as in
     
     <em class="italic">
      
       Step 8
      
     </em>
     
      of the
     
     <em class="italic">
      
       Implementing the business
      
     </em>
     
      <em class="italic">
       
        logic
       
      </em>
     
     
      
       recipe:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -X POST http://localhost:3000/recipes -H "Content-Type: application/json" -H "x-api-key: fastify-rocks" -d '{"name":"Lasagna","country":"Italy","price":12}'</strong>
<strong class="bold">{"statusCode":400,"code":"FST_ERR_VALIDATION","error":"Bad Request","message":"body must have required property 'order'"}%</strong></pre>
     <p class="list-inset">
      
       It’s worth noting
      
      <a id="_idIndexMarker457">
      </a>
      
       that, in your scenario, you received only a single error message when you expected two errors to
      
      
       
        be reported:
       
      
     </p>
     <ol>
      <li class="upper-roman">
       
        The first error should relate to the incorrect
       
       <strong class="source-inline">
        
         country
        
       </strong>
       
        value.
       
       
        The JSON schema specifies an enumeration of just two ISO codes, and the provided value doesn’t match either
       
       
        
         of them.
        
       
      </li>
      <li class="upper-roman">
       
        The second error pertains to the missing
       
       <strong class="source-inline">
        
         order
        
       </strong>
       
        property, but it seems that only this error is being displayed in the
       
       
        
         output message.
        
       
      </li>
     </ol>
     <p class="list-inset">
      
       This situation occurs due to the default AJV configuration that Fastify uses.
      
      
       You can check the default setup
      
      
       
        at
       
      
      <a href="https://github.com/fastify/ajv-compiler#ajv-configuration">
       
        
         https://github.com/fastify/ajv-compiler#ajv-configuration
        
       
      </a>
      
       
        :
       
      
     </p>
     <pre class="source-code">{
  coerceTypes: 'array',
  useDefaults: true,
  removeAdditional: true,
  uriResolver: require('fast-uri'),
  addUsedSchema: false,
  <strong class="bold">allErrors: false</strong>
}</pre>
    </li>
    <li>
     
      To resolve the issue and enable the
     
     <strong class="source-inline">
      
       allErrors
      
     </strong>
     
      option, you should configure the server’s option object that is exported in the
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      file.
     
     
      Here’s how you can modify
     
     
      
       the configuration:
      
     
     <pre class="source-code">
const options = {
  logger: true,
  ajv: {
    customOptions: {
      allErrors: true
    }
  }
};</pre>
    </li>
    <li>
     
      By restarting the
     
     <a id="_idIndexMarker458">
     </a>
     
      application and re-running the
     
     <strong class="source-inline">
      
       curl
      
     </strong>
     
      command, we should get this
     
     
      
       new output:
      
     
     <pre class="source-code">
<strong class="bold">{"statusCode":400,"code":"FST_ERR_VALIDATION","error":"Bad Request","message":"body must have required property 'order', body/country must be equal to one of the allowed values"}</strong></pre>
    </li>
    <li>
     
      Note that the
     
     <strong class="source-inline">
      
       ajv.customOptions
      
     </strong>
     
      field will be merged with the default configuration, so verify each option and set it as it best fits your needs.
     
     
      The validation step is one of the most important and requires additional care to secure your APIs.
     
     
      Let me suggest my
     
     
      
       preferred configuration:
      
     
     <pre class="source-code">
customOptions: {
  <strong class="bold">removeAdditional: 'all'</strong>
}</pre>
     <p class="list-inset">
      
       The
      
      <strong class="source-inline">
       
        removeAdditional
       
      </strong>
      
       option will enforce the removal of all input fields that are not explicitly listed in the route’s JSON schemas.
      
      
       This feature is a valuable addition to enhance security.
      
      
       It’s important to note that if you do not specify a JSON schema for a particular route, the removal logic will not be applied, and all input fields will be
      
      
       
        retained as-is.
       
      
     </p>
    </li>
    <li>
     
      We must implement the
     
     <strong class="source-inline">
      
       deleteRecipe
      
     </strong>
     
      function first; therefore, we go into the
     
     <strong class="source-inline">
      
       plugins/datasource.js
      
     </strong>
     
      file and write the
     
     
      
       following code:
      
     
     <pre class="source-code">
    async deleteRecipe (recipeId) {
      const collection =
        app.mongo.db.collection('menu');
      const result = await collection.deleteOne({ _id:
        new app.mongo.ObjectId(recipeId) });
      return result.deletedCount;
    }</pre>
     <p class="list-inset">
      
       To delete the item
      
      <a id="_idIndexMarker459">
      </a>
      
       from MongoDB, we encapsulate the input for
      
      <strong class="source-inline">
       
        id
       
      </strong>
      
       within
      
      <strong class="source-inline">
       
        ObjectId
       
      </strong>
      
       .
      
      
       This is necessary because MongoDB expects the
      
      <strong class="source-inline">
       
        _id
       
      </strong>
      
       field to be an
      
      <strong class="source-inline">
       
        ObjectId
       
      </strong>
      
       when performing
      
      
       
        document deletions.
       
      
     </p>
    </li>
    <li>
     
      We can proceed to implement the
     
     <strong class="source-inline">
      
       DELETE /recipes/:id
      
     </strong>
     
      handler using all the new things we
     
     
      
       have learned:
      
     
     <pre class="source-code">
  app.delete('/recipes/:id', {
    config: { auth: true },
    schema: {
      <strong class="bold">params</strong>: {
        type: 'object',
        properties: {
          id: { type: 'string', minLength: 24,
            maxLength: 24 }
        }
      }
    },
    handler: async function removeFromMenu (request,
      reply) {
      const { id } = request.params;
      const [recipe] = await <strong class="bold">app.source.readRecipes</strong>({
        id });
      if (!recipe) {
        reply.code(404);
        throw new Error('Not found');
      }
      await <strong class="bold">app.source.deleteRecipe</strong>(id);
      reply.code(204);
    }
  });</pre>
     <p class="list-inset">
      
       The route’s definition
      
      <a id="_idIndexMarker460">
      </a>
      
       incorporates a JSON schema in the
      
      <strong class="source-inline">
       
        schema.params
       
      </strong>
      
       property to validate the input
      
      <strong class="source-inline">
       
        id
       
      </strong>
      
       .
      
      
       We perform a strict check to ensure that
      
      <strong class="source-inline">
       
        id
       
      </strong>
      
       is exactly 24 characters in length, which is a security measure to prevent potential long code injection attacks.
      
      
       Note that this validation is strictly related to MongoDB, and it demonstrates how you can protect your routes from bad actors.
      
      
       So, tweak this configuration based on
      
      
       
        your needs.
       
      
     </p>
     <p class="list-inset">
      
       Meanwhile, in the
      
      <strong class="source-inline">
       
        removeFromMenu
       
      </strong>
      
       function implementation, we retrieve the recipe from the database by first reading it.
      
      
       Note the use of array destructuring because the
      
      <strong class="source-inline">
       
        readRecipes
       
      </strong>
      
       function returns an array.
      
      
       If the item is missing in the database, we will return a
      
      <strong class="source-inline">
       
        404 - Not Found
       
      </strong>
      
       error.
      
      
       Otherwise, we delete the record and return a
      
      <strong class="source-inline">
       
        204
       
      </strong>
      
       response status code, indicating a
      
      
       
        successful deletion.
       
      
     </p>
    </li>
    <li>
     
      It is time to test our code.
     
     
      Therefore, we can try the
     
     <strong class="source-inline">
      
       curl
      
     </strong>
     
      commands
     
     
      
       as usual:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -X POST http://localhost:3000/recipes -H "Content-Type: application/json" -H "x-api-key: fastify-rocks" -d '{"name":"Lasagna","country":"ITA","price":12,"order":1}'</strong>
<strong class="bold">{"id":"64fad8e761d11acc30098d0c"}</strong>
<strong class="bold">$ curl -X DELETE http://localhost:3000/recipes/111111111111111111111111 -H "x-api-key: fastify-rocks"</strong>
<strong class="bold">{"statusCode":404,"error":"Not Found","message":"Not found"}</strong>
<strong class="bold">$ curl -X DELETE http://localhost:3000/recipes/64fad8e761d11acc30098d0c -H "x-api-key: fastify-rocks"</strong></pre>
    </li>
   </ol>
   <p>
    
     In this recipe, we’ve successfully
    
    <a id="_idIndexMarker461">
    </a>
    
     implemented all the routes defined in the
    
    <strong class="source-inline">
     
      routes/recipes.js
     
    </strong>
    
     file.
    
    
     In the upcoming recipe, we will continue by implementing the routes defined in
    
    <strong class="source-inline">
     
      routes/orders.js
     
    </strong>
    
     while also introducing another exciting Fastify
    
    
     
      feature: serialization!
     
    
   </p>
   <h1 id="_idParaDest-198">
    <a id="_idTextAnchor205">
    </a>
    
     Enhancing application performance with serialization
    
   </h1>
   <p>
    
     The serialization step
    
    <a id="_idIndexMarker462">
    </a>
    
     converts the
    
    <a id="_idIndexMarker463">
    </a>
    
     high-level data generated by business logic, including JSON objects or errors, into low-level data, such as strings or buffers, which are then sent as responses to the client’s requests.
    
    
     It involves the transformation of intricate objects into an appropriate data type that can be effectively transmitted to the client.
    
    
     In fact, as mentioned in the
    
    <em class="italic">
     
      Implementing authentication with hooks
     
    </em>
    
     recipe, the serialization process is initiated only if the route handler doesn’t return a string, stream, or buffer, as these objects are already serialized and prepared for transmission as HTTP responses to the client.
    
    
     Nevertheless, this process can’t be avoided when you work with
    
    
     
      JSON objects.
     
    
   </p>
   <p>
    
     Fastify incorporates a serialization module that facilitates the conversion of an object into a JSON string, leveraging a JSON schema definition.
    
    
     This module, known as
    
    <strong class="source-inline">
     
      fast-json-stringify
     
    </strong>
    
     , offers a notable performance boost when compared to the standard
    
    <strong class="source-inline">
     
      JSON.stringify()
     
    </strong>
    
     function.
    
    
     In fact, it accelerates the serialization process by a factor of two for small payloads.
    
    
     Its performance advantage shrinks as payload grows, as demonstrated in their benchmark, which is available
    
    
     
      at
     
    
    <a href="https://github.com/fastify/fast-json-stringify/">
     
      
       https://github.com/fastify/fast-json-stringify/
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-199">
    <a id="_idTextAnchor206">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     We will apply
    
    <a id="_idIndexMarker464">
    </a>
    
     the
    
    <a id="_idIndexMarker465">
    </a>
    
     serialization to the
    
    <strong class="source-inline">
     
      /orders
     
    </strong>
    
     endpoints, but first, we must create an order.
    
    
     For this recipe, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Let’s implement the
     
     
      <strong class="source-inline">
       
        insertOrder
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
    async insertOrder (order) {
      const _id = new app.mongo.ObjectId();
      order._id = _id;
      order.id = _id.toString();
      const collection =
        app.mongo.db.collection('orders');
      const result = await
        collection.insertOne(order);
      return result.insertedId;
    }</pre>
     <p class="list-inset">
      
       The code snippet should be familiar to you.
      
      
       We insert the input object into the
      
      <strong class="source-inline">
       
        orders
       
      </strong>
      
       collection straight away.
      
      
       Then, we can implement the route handler
      
      
       
        in
       
      
      
       <strong class="source-inline">
        
         routes/orders.js
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      Since we need to deal with user input, we can define this
     
     
      
       JSON schema:
      
     
     <pre class="source-code">
  const orderJsonSchema = {
    type: 'object',
    required: ['table', 'dishes'],
    properties: {
      table: { type: 'number', minimum: 1 },
      dishes: {
        type: 'array',
        minItems: 1,
        items: {
          type: 'object',
          required: ['id', 'quantity'],
          properties: {
            id: { type: 'string', minLength: 24,
              maxLength: 24 },
            quantity: { type: 'number', minimum: 1 }
          }
        }
      }
    }
  };</pre>
     <p class="list-inset">
      
       It defines
      
      <a id="_idIndexMarker466">
      </a>
      
       
        two
       
      
      
       <a id="_idIndexMarker467">
       </a>
      
      
       
        properties:
       
      
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        
         table
        
       </strong>
       
        : This helps us understand which
       
       
        
         customer ordered.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         dishes
        
       </strong>
       
        : This is a JSON object array that must have at least one item.
       
       
        Every item must contain the recipe
       
       <strong class="source-inline">
        
         id
        
       </strong>
       
        
         and
        
       
       
        <strong class="source-inline">
         
          quantity
         
        </strong>
       
       
        
         .
        
       
      </li>
     </ul>
     <p class="list-inset">
      
       Thanks to the JSON schema, we can avoid a lot of boring
      
      <strong class="source-inline">
       
        if
       
      </strong>
      
       statements and checks such as checking if the
      
      <strong class="source-inline">
       
        quantity
       
      </strong>
      
       input field is a
      
      
       
        negative value!
       
      
     </p>
    </li>
    <li>
     
      Finally, we can move on to the
     
     
      
       route implementation:
      
     
     <pre class="source-code">
  app.post('/orders', {
    schema: {
      body: orderJsonSchema
    },
    handler: async function createOrder (request,
      reply) {
        const order = {
          status: 'pending',
          createdAt: new Date(),
          items: request.body.dishes
        };
      const orderId = await
        this.source.insertOrder(order);
      reply.code(201);
      return { id: orderId };
    }
  });</pre>
     <p class="list-inset">
      
       You’re likely
      
      <a id="_idIndexMarker468">
      </a>
      
       familiar
      
      <a id="_idIndexMarker469">
      </a>
      
       with the
      
      <strong class="source-inline">
       
        createOrder
       
      </strong>
      
       function by now.
      
      
       For the sake of simplicity, we’ll store the
      
      <strong class="source-inline">
       
        request.body.dishes
       
      </strong>
      
       array as-is without validating the IDs.
      
      
       However, I recommend implementing a
      
      <strong class="source-inline">
       
        preHandler
       
      </strong>
      
       hook to handle this validation step, which the JSON schema can’t perform, and I encourage you to consider it as
      
      
       
        an exercise.
       
      
     </p>
    </li>
    <li>
     
      We are ready to try the
     
     
      
       route out:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -X POST http://localhost:3000/orders -H "Content-Type: application/json" -d '{"table":42,"dishes":[{"id":"64fad8e761d11acc30098d0c","quantity":2},{"id":"64fad8e761d11acc30098d0z","quantity":1}]}'</strong>
<strong class="bold">{"id":"64faeccfac24fcc42c6ffda8"}</strong></pre>
     <p class="list-inset">
      
       Well done!
      
      
       We have consolidated what we have learned in the
      
      <em class="italic">
       
        Implementing the business logic
       
      </em>
      
       recipe.
      
      
       We are now ready to move on to the
      
      <strong class="source-inline">
       
        GET /orders
       
      </strong>
      
       route to see the serialization process
      
      
       
        in action.
       
      
     </p>
    </li>
    <li>
     
      As usual, we should implement the database access first; therefore, in
     
     <strong class="source-inline">
      
       plugins/datasource.js
      
     </strong>
     
      , we can write
     
     
      
       the following:
      
     
     <pre class="source-code">
async readOrders (filters, sort = <strong class="bold">{ createdAt: -1 }</strong>) {
      const collection =
        app.mongo.db.collection('orders');
      const result = await
        collection.find(filters).sort(sort).toArray();
      return result;
    }</pre>
     <p class="list-inset">
      
       In the provided
      
      <a id="_idIndexMarker470">
      </a>
      
       code
      
      <a id="_idIndexMarker471">
      </a>
      
       snippet, there isn’t anything substantially new, except that we’re configuring a default sorting by using
      
      <strong class="source-inline">
       
        createdAt
       
      </strong>
      
       in reverse order.
      
      
       This arrangement prioritizes older orders, ensuring they are
      
      
       
        fulfilled first.
       
      
     </p>
    </li>
    <li>
     
      Then, we can move to the
     
     
      
       endpoint handler:
      
     
     <pre class="source-code">
app.get('/orders', {
  handler: async function readOrders (request, reply)
  {
    const orders = await <strong class="bold">this.source.readOrders</strong>({
      status: 'pending' });
    const recipesIds = orders.flatMap(order =&gt;
      order.items.map(item =&gt; item.id));
    const recipes = await <strong class="bold">this.source.readRecipes</strong>({
      id: { $in: recipesIds } });
    return <strong class="bold">orders.map</strong>(order =&gt; {
      order.items = order.items
        .map(item =&gt; {
          const recipe = recipes.find(recipe =&gt;
            recipe.id === item.id)
          return recipe ? { ...recipe, quantity:
            item.quantity } : undefined;
          })
          .filter(recipe =&gt; recipe !== undefined);
        return order;
      });
    }
  });</pre>
     <p class="list-inset">
      
       The
      
      <strong class="source-inline">
       
        readOrders
       
      </strong>
      
       function
      
      <a id="_idIndexMarker472">
      </a>
      
       introduces a
      
      <a id="_idIndexMarker473">
      </a>
      
       more comprehensive logic compared to what we saw earlier in
      
      <em class="italic">
       
        Step 5
       
      </em>
      
       .
      
      
       Here’s an overview of the steps
      
      
       
        it takes:
       
      
     </p>
     <ol>
      <li class="upper-roman">
       
        Initially, it reads all the
       
       
        
         pending orders.
        
       
      </li>
      <li class="upper-roman">
       
        Then, it collects all the recipe IDs used across all the orders to optimize performance by running a single query to select only those recipes that are
       
       
        
         actually used.
        
       
      </li>
      <li class="upper-roman">
       
        Finally, it iterates through the orders array to replace the items array, which was initially read from the database, with the corresponding recipe items from
       
       
        
         the database.
        
       
      </li>
     </ol>
     <p class="list-inset">
      
       It’s worth mentioning that we have seen how to use multiple datasource methods in one handler.
      
      
       If we would like to optimize the code even further, we could use a MongoDB
      
      <strong class="source-inline">
       
        $lookup
       
      </strong>
      
       to run a single query to the database instead of two, as
      
      
       
        we did.
       
      
     </p>
    </li>
    <li>
     
      One notable detail is the use of a filter to skip recipes that were not found in the system.
     
     
      This is an edge case consideration because an order may include a recipe that was deleted after it was created, and in such cases, we want to ensure that these
     
     <a id="_idIndexMarker474">
     </a>
     
      deleted
     
     <a id="_idIndexMarker475">
     </a>
     
      recipes are not displayed in the output.
     
     
      We are ready to test this implementation by executing a command in
     
     
      
       the shell:
      
     
     <pre class="source-code">
<strong class="bold">$ curl http://localhost:3000/orders</strong></pre>
     <p class="list-inset">
      
       We expect a big output displaying the orders in our system.
      
      
       Here is an example of one
      
      
       
        order output:
       
      
     </p>
     <pre class="source-code">[
  {
    "status": "pending",
    "createdAt": "2023-09-08T09:56:49.750Z",
    "items": [
      {
        "name": "Lasagna",
        "country": "ITA",
        "description": "Lasagna is a traditional Italian dish made with alternating layers of pasta, cheese, and sauce.",
        "order": 1,
        "price": 12,
        "quantity": 1,
        "createdAt": "2023-09-08T09:54:28.904Z",
        "id": "64faefcc9094146c83d2ffd7"
      }
    ],
    "id": "64faefe19094146c83d2ffd8"
  }
]</pre>
     <p class="list-inset">
      
       As you can see, the provided information contains more details than the target user requires.
      
      
       It’s time
      
      <a id="_idIndexMarker476">
      </a>
      
       to
      
      <a id="_idIndexMarker477">
      </a>
      
       configure the serialization process to ensure that the data presented to the user is concise and relevant to
      
      
       
        their needs.
       
      
     </p>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       routes/orders.js
      
     </strong>
     
      file, add this
     
     
      
       JSON schema:
      
     
     <pre class="source-code">
  const orderListSchema = {
    type: 'array',
    items: {
      type: 'object',
      properties: {
        id: { type: 'string' },
        createdAt: { type: 'string', <strong class="bold">format</strong>: 'date-
          time' },
        items: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              order: { type: 'number' },
              quantity: { type: 'number' }
            }
          }
        }
      }
    }
  };</pre>
     <p class="list-inset">
      <strong class="source-inline">
       
        orderListSchema
       
      </strong>
      
       specifically outlines the fields we desire in the response payload, mapping only the properties’ types without specifying attributes to define the maximum string length or valid number ranges.
      
      
       It’s worth noting the
      
      <strong class="source-inline">
       
        format
       
      </strong>
      
       attribute, which allows for the customization of the output for a date field.
      
      
       However, it’s important to clarify that this concept can sometimes be misunderstood: the
      
      <a id="_idIndexMarker478">
      </a>
      
       JSON
      
      <a id="_idIndexMarker479">
      </a>
      
       schema used for serialization does not apply any validation but solely filters the data.
      
      
       Therefore, any additional validation rules added to the JSON schema will be ignored during the
      
      
       
        serialization process.
       
      
     </p>
    </li>
    <li>
     
      To apply the JSON schema to the endpoint, we must edit the route’s option
     
     
      
       as follows:
      
     
     <pre class="source-code">
  app.get('/orders', {
    schema: {
      <strong class="bold">response</strong>: {
        <strong class="bold">200</strong>: orderListSchema
      }
    },
    handler: async function readOrders (request,
      reply) {}
  };</pre>
     <p class="list-inset">
      
       To use a JSON schema during serialization, it’s essential to configure the
      
      <strong class="source-inline">
       
        schema.response
       
      </strong>
      
       object.
      
      
       Notably, you can specify the HTTP status codes to which the particular schema should be applied.
      
      
       You have the flexibility to define different schemas for various status codes.
      
      
       Additionally, there’s another convenient Fastify pattern that you can utilize.
      
      
       By setting the
      
      <strong class="source-inline">
       
        "2xx"
       
      </strong>
      
       property within the schema, it will be used for all HTTP status codes ranging from 200 to 299, simplifying
      
      <a id="_idIndexMarker480">
      </a>
      
       the
      
      <a id="_idIndexMarker481">
      </a>
      
       schema configuration for a range of
      
      
       
        successful responses.
       
      
     </p>
    </li>
    <li>
     
      If we run the
     
     <strong class="source-inline">
      
       curl
      
     </strong>
     
      command from
     
     <em class="italic">
      
       Step 7
      
     </em>
     
      , we will get even
     
     
      
       better output:
      
     
     <pre class="source-code">
[
  {
    "id": "64faefe19094146c83d2ffd8",
    "createdAt": "2023-09-08T09:56:49.750Z",
    "items": [
      {
        "name": "Lasagna",
        "order": 1,
        "quantity": 1
      }
    ]
  }
]</pre>
     <p class="list-inset">
      
       By successfully implementing a JSON schema for serializing the output of the order endpoint, you’ve enhanced both the speed and security of your application.
      
      
       This approach ensures that only the designated fields are returned, safeguarding against the inadvertent exposure of sensitive data as the database evolves over time.
      
      
       Specifying a JSON schema as part of your response is consistently considered good practice for maintaining control over the data exposed to clients and enhancing
      
      
       
        overall security.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     With the knowledge and tools we’ve covered thus far, you should be well equipped to complete the implementation of the final
    
    <strong class="source-inline">
     
      PATH /orders/:orderId
     
    </strong>
    
     route.
    
    
     If you encounter any doubts or need further guidance, you can refer to the complete source code available in the book’s repository
    
    
     
      at
     
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06">
     
      
       https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Once you’ve finished this route, you can consider the overall application complete.
    
    
     While there is room for further improvements, such as adding a JSON schema to all the routes, it might be considered optional to delve into this in detail since we’ve already covered the
    
    <a id="_idIndexMarker482">
    </a>
    
     fundamental
    
    <a id="_idIndexMarker483">
    </a>
    
     concepts behind it.
    
    
     Now, you are ready to move on to the next section, where you’ll learn how to write tests for your
    
    
     
      Fastify application.
     
    
   </p>
   <h1 id="_idParaDest-200">
    <a id="_idTextAnchor207">
    </a>
    
     Configuring and testing a Fastify application
    
   </h1>
   <p>
    
     In the previous recipe, I mentioned
    
    <a id="_idIndexMarker484">
    </a>
    
     that the application could
    
    <a id="_idIndexMarker485">
    </a>
    
     be considered complete.
    
    
     However, as an application truly achieves completeness only when it has a comprehensive test suite, in this recipe, our focus shifts to testing our endpoints to assert their functionality and correctness.
    
    
     This testing ensures that as we make changes to the code in the future, we can reliably verify that we have not introduced any new bugs
    
    
     
      or regressions.
     
    
   </p>
   <p>
    
     We will use the new Node.js test runner in this recipe, providing a sneak peek into
    
    <a href="B19212_08.xhtml#_idTextAnchor243">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     , where we will delve deeper into this subject and do so in a more focused manner.
    
    
     For now, we will cover the basics to get you started with testing.
    
    
     So, let’s start this
    
    
     
      new goal!
     
    
   </p>
   <h2 id="_idParaDest-201">
    <a id="_idTextAnchor208">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     We will begin this recipe by reading the application’s configuration, followed by writing
    
    
     
      application tests.
     
    
   </p>
   <p>
    
     Up until now, we’ve hardcoded certain elements in our code, including
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      The database
     
     
      
       connection URL
      
     
    </li>
    <li>
     
      The API key
     
     
      
       for authentication
      
     
    </li>
   </ul>
   <p>
    
     However, this approach isn’t ideal for our application because we should have the flexibility to change these values as needed, especially in different environments.
    
    
     The best practice in such cases is to access the environment variables provided by the system.
    
    
     Additionally, this is a requirement for writing tests, allowing us to inject different configurations as
    
    <a id="_idIndexMarker486">
    </a>
    
     necessary
    
    <a id="_idIndexMarker487">
    </a>
    
     for testing various scenarios
    
    
     
      and environments.
     
    
   </p>
   <h2 id="_idParaDest-202">
    <a id="_idTextAnchor209">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To achieve this task, we need to follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Install a new
     
     
      
       Fastify module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install @fastify/env@5</strong></pre>
    </li>
    <li>
     
      Then, we need to create a new file,
     
     <strong class="source-inline">
      
       plugins/config.js
      
     </strong>
     
      , with the
     
     
      
       following content:
      
     
     <pre class="source-code">
import fp from 'fastify-plugin';
import fastifyEnv from '@fastify/env';
async function configPlugin (app, opts) {
  const <strong class="bold">envSchema</strong> = {
    type: 'object',
    required: ['API_KEY', 'DATABASE_URL'],
    properties: {
      NODE_ENV: { type: 'string', default:
        'development' },
      PORT: { type: 'integer', default: 3000 },
      API_KEY: { type: 'string' },
      DATABASE_URL: { type: 'string' }
    }
  };
  app.register(fastifyEnv, {
    confKey: <strong class="bold">'appConfig'</strong>,
    schema: envSchema,
    data: <strong class="bold">opts.applicationEnv</strong>
  });
}
export default fp(configPlugin);</pre>
     <p class="list-inset">
      
       The plugin code should
      
      <a id="_idIndexMarker488">
      </a>
      
       be
      
      <a id="_idIndexMarker489">
      </a>
      
       fairly understandable, even if you’re encountering it for the first time.
      
      
       This plugin defines an
      
      <strong class="source-inline">
       
        envSchema
       
      </strong>
      
       constant with a JSON schema.
      
      
       This schema is subsequently used as a configuration for the
      
      <strong class="source-inline">
       
        @fastify/env
       
      </strong>
      
       module.
      
      
       This module validates the
      
      <strong class="source-inline">
       
        process.env
       
      </strong>
      
       object against the provided input schema.
      
      
       Consequently, if the required configuration is missing or incorrect, the application will not start successfully.
      
      
       Moreover, the
      
      <strong class="source-inline">
       
        confKey
       
      </strong>
      
       option lets you set a custom name for the server decorator that this module is going
      
      
       
        to add.
       
      
     </p>
    </li>
    <li>
     
      If you register this plugin in the
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      file and attempt to restart the server, you will encounter an error during the
     
     
      
       startup process:
      
     
     <pre class="source-code">
<strong class="bold">Error: env must have required property 'API_KEY', env must have required property 'DATABASE_URL'</strong></pre>
     <p class="list-inset">
      
       To fix this configuration issue, we need to begin passing the
      
      <strong class="source-inline">
       
        opts
       
      </strong>
      
       argument in our plugin declarations.
      
      
       Let’s address this problem using a
      
      
       
        top-down approach.
       
      
     </p>
    </li>
    <li>
     
      Start by opening the
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file and making the
     
     
      
       following updates:
      
     
     <pre class="source-code">
const app = fastify(options);
app.register(appPlugin, {
  <strong class="bold">applicationEnv</strong>: {
    <strong class="bold">API_KEY</strong>: 'fastify-rocks',
    <strong class="bold">DATABASE_URL</strong>:
<strong class="bold">      </strong>'mongodb://localhost:27017/restaurant',
    <strong class="bold">...process.env</strong>
  }
});</pre>
     <p class="list-inset">
      
       We introduced
      
      <a id="_idIndexMarker490">
      </a>
      
       a
      
      <a id="_idIndexMarker491">
      </a>
      
       configuration object during the registration of
      
      <strong class="source-inline">
       
        appPlugin
       
      </strong>
      
       .
      
      
       The
      
      <strong class="source-inline">
       
        applicationEnv
       
      </strong>
      
       property is derived from merging
      
      <strong class="source-inline">
       
        process.env
       
      </strong>
      
       with the default values specified in the code.
      
      
       In cases where
      
      <strong class="source-inline">
       
        process.env
       
      </strong>
      
       contains values for
      
      <strong class="source-inline">
       
        API_KEY
       
      </strong>
      
       or
      
      <strong class="source-inline">
       
        DATABASE_URL
       
      </strong>
      
       , these environment-specific values take precedence over the defaults defined in
      
      
       
        the code.
       
      
     </p>
    </li>
    <li>
     
      Now, we need to go back to
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      and update
     
     
      
       it accordingly:
      
     
     <pre class="source-code">
import configPlugin from './plugins/config.js';
// ...
async function appPlugin (app, <strong class="bold">opts</strong>) {
  // ...
  app.register(configPlugin, <strong class="bold">opts</strong>);
  // ...
}</pre>
     <p class="list-inset">
      
       In this context, the
      
      <strong class="source-inline">
       
        opts
       
      </strong>
      
       argument corresponds to the second object parameter we recently added in the
      
      <strong class="source-inline">
       
        server.js
       
      </strong>
      
       file.
      
      
       Consequently,
      
      <strong class="source-inline">
       
        configPlugin
       
      </strong>
      
       also receives the same object because we added it during the registration.
      
      
       If we refer back to the initial code snippet in this recipe, which showcases the
      
      <strong class="source-inline">
       
        configPlugin
       
      </strong>
      
       implementation, you’ll observe that we’ve already supplied the
      
      <strong class="source-inline">
       
        opts.applicationEnv
       
      </strong>
      
       option to
      
      <strong class="source-inline">
       
        @fastify/env
       
      </strong>
      
       .
      
      
       This indicates that it’s now reading the
      
      
       
        correct configuration.
       
      
     </p>
    </li>
    <li>
     
      With these adjustments, we should be able to restart the
     
     
      
       server successfully.
      
     
    </li>
    <li>
     
      We have changed a lot of code but still need to remove the hardcoded configuration from
     
     <a id="_idIndexMarker492">
     </a>
     
      the
     
     <a id="_idIndexMarker493">
     </a>
     
      plugins.
     
     
      Let’s do it now, starting with the
     
     
      <strong class="source-inline">
       
        app.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
async function appPlugin (app, opts) {
  // ...
  <strong class="bold">await</strong> app.register(configPlugin, opts);
  app.register(datasourcePlugin, { databaseUrl:
    <strong class="bold">app.appConfig</strong>.DATABASE_URL });
  app.register(authPlugin, { tokenValue:
    <strong class="bold">app.appConfig</strong>.API_KEY });
  // ...
}</pre>
     <p class="list-inset">
      
       In this code snippet, you’ll notice a new syntax:
      
      <strong class="source-inline">
       
        await app.register()
       
      </strong>
      
       .
      
      
       Now,
      
      <strong class="source-inline">
       
        await
       
      </strong>
      
       is crucial because, without it, your server won’t start.
      
      
       As a reminder, in the
      
      <em class="italic">
       
        Splitting the code into small plugins
       
      </em>
      
       recipe, we discussed that plugin functions are not executed until one of the following methods is called:
      
      <strong class="source-inline">
       
        app.listen()
       
      </strong>
      
       ,
      
      <strong class="source-inline">
       
        app.ready()
       
      </strong>
      
       , or
      
      <strong class="source-inline">
       
        app.inject()
       
      </strong>
      
       .
      
      
       While this principle remains accurate, using
      
      <strong class="source-inline">
       
        await app.register()
       
      </strong>
      
       effectively triggers Fastify to initiate the loading process up to the awaited line, ensuring the necessary setup occurs before further execution.
      
      
       In fact, we use the
      
      <strong class="source-inline">
       
        app.appConfig
       
      </strong>
      
       decorator in the following line, and this field will remain undefined if we don’t wait for (
      
      
       
        await)
       
      
      
       <strong class="source-inline">
        
         configPlugin
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       plugins/datasource.js
      
     </strong>
     
      file, we can update the
     
     
      
       MongoDB setup:
      
     
     <pre class="source-code">
  app.register(fastifyMongo, {
    <strong class="bold">url: opts.databaseUrl</strong>
  });</pre>
    </li>
    <li>
     
      In
     
     <strong class="source-inline">
      
       plugins/auth.js
      
     </strong>
     
      , we can remove the hardcoded API key
     
     
      
       as follows:
      
     
     <pre class="source-code">
  app.decorateRequest('isChef', function () {
    return this.headers['x-api-key'] ===
      <strong class="bold">opts.tokenValue</strong>;
  });</pre>
     <p class="list-inset">
      
       Great job!
      
      
       You’ve now achieved a dynamic application that adapts its configuration based on the environment, validates prerequisites before starting, and leverages
      
      <a id="_idIndexMarker494">
      </a>
      
       another
      
      <a id="_idIndexMarker495">
      </a>
      
       feature of Fastify’s plugin system by utilizing the ability to await a plugin.
      
      
       Additionally, you’ve improved the authentication and data source plugins, making them more configurable and suitable for use across your organization’s projects.
      
      
       By configuring the plugins via the
      
      <strong class="source-inline">
       
        register
       
      </strong>
      
       method, we can create plugins that are decoupled from the rest of the application and do not require the
      
      <strong class="source-inline">
       
        app.appConfig
       
      </strong>
      
       decorator
      
      
       
        to work.
       
      
     </p>
     <p class="list-inset">
      
       With all these pieces in place, you’re well prepared to begin writing your test suite.
      
      
       The dynamic configuration you’ve created will prove invaluable as you embark on the testing phase of
      
      
       
        your project.
       
      
     </p>
     <p class="list-inset">
      
       Your Fastify application can be effectively represented by the
      
      <strong class="source-inline">
       
        appPlugin
       
      </strong>
      
       instance and the server’s configuration exported by the
      
      <strong class="source-inline">
       
        app.js
       
      </strong>
      
       file.
      
      
       In fact, there is minimal value in testing the
      
      <strong class="source-inline">
       
        server.js
       
      </strong>
      
       file, as it primarily serves as a straightforward runner that can be readily replaced by the
      
      <strong class="source-inline">
       
        fastify-cli
       
      </strong>
      
       module
      
      
       
        when necessary.
       
      
     </p>
    </li>
    <li>
     
      The initial step of writing tests for a Fastify application is to enable the creation of a
     
     
      <strong class="source-inline">
       
        test/helper.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
import { fastify } from 'fastify';
import appPlugin, { options } from '../app.js';
const defaultTestEnv = {
  NODE_ENV: 'test',
  API_KEY: 'test-suite',
  DATABASE_URL: 'mongodb://localhost:27017/restaurant-
    test-run'
};
async function buildApplication (env, serverOptions =
  { logger: false }) {
    const testServerOptions = Object.assign({},
      options, serverOptions);
    const testEnv = Object.assign({}, defaultTestEnv,
      env);
    const app = fastify(testServerOptions);
    app.register(appPlugin, { applicationEnv: testEnv
    });
  return app;
}
export { buildApplication };</pre>
     <p class="list-inset">
      
       We are ready to
      
      <a id="_idIndexMarker496">
      </a>
      
       write
      
      <a id="_idIndexMarker497">
      </a>
      
       our first test
      
      
       
        file:
       
      
      
       <strong class="source-inline">
        
         test/app.test.js
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      We must import
     
     <a id="_idIndexMarker498">
     </a>
     
      the new
     
     <strong class="bold">
      
       Node.js test
      
     </strong>
     
      <strong class="bold">
       
        runner
       
      </strong>
     
     
      
       modules:
      
     
     <pre class="source-code">
import { test } from 'node:test';
import { strictEqual, deepStrictEqual, ok } from
  'node:assert';</pre>
     <p class="list-inset">
      
       A complete list of its APIs can be found in the official documentation
      
      
       
        at
       
      
      <a href="https://nodejs.org/api/test.html">
       
        
         https://nodejs.org/api/test.html
        
       
      </a>
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      We need to import the
     
     
      <strong class="source-inline">
       
        buildApplication
       
      </strong>
     
     
      
       utility:
      
     
     <pre class="source-code">
import { buildApplication } from './helper.js';</pre>
    </li>
    <li>
     
      We need to define a test case using the
     
     <strong class="source-inline">
      
       test
      
     </strong>
     
      function.
     
     
      The first parameter is a descriptive string that helps identify which test is currently executing.
     
     
      The second argument is
     
     <a id="_idIndexMarker499">
     </a>
     
      an
     
     <a id="_idIndexMarker500">
     </a>
     
      asynchronous function that takes a test
     
     
      
       context parameter:
      
     
     <pre class="source-code">
test('GET /', async function (t) {
  const app = await buildApplication();
  t.after(async function () {
    await app.close();
  });
  const response = await app.inject({
    method: 'GET',
    url: '/'
  });
  strictEqual(response.statusCode, 200);
  deepStrictEqual(response.json(), {
    api: 'fastify-restaurant-api',
    version: 1
  });
});</pre>
    </li>
    <li>
     
      To run the test file, we need to execute
     
     
      
       this command:
      
     
     <pre class="source-code">
<strong class="bold">$ node --test test/app.test.js</strong>
<strong class="bold">✔</strong><strong class="bold"> GET / (56.81025ms)</strong>
<strong class="bold">ℹ tests 1</strong>
<strong class="bold">ℹ suites 0</strong>
<strong class="bold">ℹ</strong><strong class="bold"> pass 1</strong>
<strong class="bold">ℹ fail 0</strong>
<strong class="bold">ℹ cancelled 0</strong>
<strong class="bold">ℹ skipped 0</strong>
<strong class="bold">ℹ todo 0</strong>
<strong class="bold">ℹ duration_ms 341.573042</strong></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-203">
    <a id="_idTextAnchor210">
    </a>
    
     How it works…
    
   </h2>
   <p>
    <strong class="source-inline">
     
      test/helper.js
     
    </strong>
    
     exports a
    
    <strong class="source-inline">
     
      buildApplication
     
    </strong>
    
     function that instantiates the Fastify root server
    
    <a id="_idIndexMarker501">
    </a>
    
     instance
    
    <a id="_idIndexMarker502">
    </a>
    
     and registers
    
    <strong class="source-inline">
     
      appPlugin
     
    </strong>
    
     , as carried out by the
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     file.
    
    
     The differences are
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      The
     
     <strong class="source-inline">
      
       app
      
     </strong>
     
      constant is just returned, and we do not call the
     
     <strong class="source-inline">
      
       listen()
      
     </strong>
     
      method.
     
     
      In this way, we are not blocking a
     
     
      
       host’s port.
      
     
    </li>
    <li>
     
      The default server’s options are the same as
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      with the logger turned off.
     
     
      Anyway, we can customize them by providing a second argument to the
     
     
      
       factory function.
      
     
    </li>
    <li>
     
      The default environment setup does not read the
     
     <strong class="source-inline">
      
       process.env
      
     </strong>
     
      object, but it defines good defaults with which to run the application in every local
     
     
      
       development environment.
      
     
    </li>
   </ul>
   <p>
    
     As we are running the application, a connection to the database will be established.
    
    
     To ensure the test completes successfully, it’s essential to close the server and database connection after the test has executed all the assertions.
    
    
     This cleanup step is crucial for the proper functioning of subsequent tests and to avoid
    
    
     
      resource leaks.
     
    
   </p>
   <p>
    
     Lastly, we can use Fastify’s
    
    <strong class="source-inline">
     
      app.inject()
     
    </strong>
    
     method.
    
    
     Unlike calling the
    
    <strong class="source-inline">
     
      listen
     
    </strong>
    
     method, this approach starts the server without actively listening for incoming HTTP requests, enabling faster execution.
    
    
     The
    
    <strong class="source-inline">
     
      inject
     
    </strong>
    
     method then generates a simulated HTTP request and sends it to the server, which processes it in the same way it would a genuine request, producing an HTTP response.
    
    
     This method returns the HTTP response, allowing us to verify its content to validate our expectations.
    
    
     The
    
    <strong class="source-inline">
     
      inject
     
    </strong>
    
     method accepts an object parameter for specifying various HTTP request components.
    
    
     We’ll explore more examples in the
    
    <em class="italic">
     
      There’s more...
     
    </em>
    
     section of
    
    
     
      this recipe.
     
    
   </p>
   <p>
    
     At the end of the test case, we assert that the response has the correct status code
    
    
     
      and payload.
     
    
   </p>
   <p>
    
     The test output provides a summary of the entire execution process.
    
    
     In the event of an error, it displays a detailed message indicating the failed assertion.
    
    
     For experimental purposes, you can
    
    <a id="_idIndexMarker503">
    </a>
    
     attempt
    
    <a id="_idIndexMarker504">
    </a>
    
     to break the test by modifying the
    
    <strong class="source-inline">
     
      deepStrictEqual
     
    </strong>
    
     check, for instance, by editing the
    
    <strong class="source-inline">
     
      version
     
    </strong>
    
     property.
    
    
     This will help you observe how tests respond to changes and failures, allowing you to refine and improve them
    
    
     
      as needed.
     
    
   </p>
   <h2 id="_idParaDest-204">
    <a id="_idTextAnchor211">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     Before wrapping up this recipe, it would be useful to check a more complex test case, so let’s quickly analyze
    
    
     
      this code:
     
    
   </p>
   <pre class="source-code">
test('An unknown user cannot create a recipe', async function (t) {
  const testApiKey = 'test-suite-api-key';
  const app = await buildApplication({
    API_KEY: testApiKey
  });
  t.after(async function () {
    await app.close();
  });
  const pizzaRecipe = { name: 'Pizza', country: 'ITA',
    price: 8, order: 2 };
  const notChefResponse = await app.inject({
    method: 'POST',
    url: '/recipes',
    payload: pizzaRecipe,
    headers: {
      'x-api-key': 'invalid-key'
    }
  });
  strictEqual(notChefResponse.statusCode, 401);
});</pre>
   <p>
    
     This new test case examines the
    
    <strong class="source-inline">
     
      A unknown user cannot create a recipe
     
    </strong>
    
     condition.
    
    
     In this scenario, we inject a custom API key within the
    
    <strong class="source-inline">
     
      buildApplication
     
    </strong>
    
     function and subsequently confirm that if the
    
    <strong class="source-inline">
     
      POST /recipes
     
    </strong>
    
     request lacks the valid header, it will be rejected.
    
    
     We saw also that the
    
    <strong class="source-inline">
     
      inject
     
    </strong>
    
     method accepts the
    
    <strong class="source-inline">
     
      payload
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      headers
     
    </strong>
    
     fields to control every
    
    
     
      request’s aspect.
     
    
   </p>
   <p>
    
     Furthermore, we can
    
    <a id="_idIndexMarker505">
    </a>
    
     enhance
    
    <a id="_idIndexMarker506">
    </a>
    
     the code by introducing an additional test case to ensure that a valid chef can, indeed, create a recipe and that the newly created recipes appear on the menu.
    
    
     This additional test will further validate the
    
    
     
      application’s functionality:
     
    
   </p>
   <pre class="source-code">
test('Only a Chef can create a recipe', async function (t) {
  const testApiKey = 'test-suite-api-key';
  const app = await buildApplication({
    API_KEY: testApiKey
  });
  t.after(async function () {
    await app.close();
  });
  const pizzaRecipe = { name: 'Pizza', country: 'ITA',
    price: 8, order: 2 };
  const response = await app.inject({
    method: 'POST',
    url: '/recipes',
    payload: pizzaRecipe,
    headers: {
      'x-api-key': testApiKey
    }
  });
  strictEqual(response.statusCode, 201);
  const recipeId = response.json().id;
  const menu = await app.inject('/menu');
  strictEqual(menu.statusCode, 200);
  const recipes = menu.json();
  const expectedPizza = recipes.find(r =&gt; r.id ===
    recipeId);
  ok(expectedPizza, 'Pizza recipe must be found');
});</pre>
   <p>
    
     Note that the
    
    <strong class="source-inline">
     
      app.inject()
     
    </strong>
    
     method has a shortcut to run simple
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     requests also.
    
    
     It requires the URL
    
    
     
      string only.
     
    
   </p>
   <p>
    
     Implementing tests for the application’s routes to cover all use cases is a valuable exercise for becoming proficient with the APIs and the test suite.
    
    
     You now have the fundamental knowledge needed to tackle this task by drawing upon what you’ve learned.
    
    
     Refer to the book’s source code repository for additional code examples and guidance.
    
    
     Good luck, and well done on
    
    
     
      your progress!
     
    
   </p>
   <p>
    
     Throughout this chapter, you’ve delved into some of Fastify’s most crucial features, including the plugin system and the wide number of hooks.
    
    
     You’ve also gained insights into the essential aspects of a Fastify application, such as configuration and code reusability.
    
    
     Moreover, your
    
    <a id="_idIndexMarker507">
    </a>
    
     proficiency in working with MongoDB has
    
    <a id="_idIndexMarker508">
    </a>
    
     
      undoubtedly improved.
     
    
   </p>
   <p>
    
     If you’re enthusiastic about Fastify and eager to explore more, you might find the book
    
    <em class="italic">
     
      Accelerating Server-Side Development with Fastify
     
    </em>
    
     by
    
    <em class="italic">
     
      Packt Publishing
     
    </em>
    
     at
    
    <a href="https://www.packtpub.com/product/accelerating-server-side-development-with-fastify/9781800563582">
     
      https://www.packtpub.com/product/accelerating-server-side-development-with-fastify/9781800563582
     
    </a>
    
     to be an invaluable resource for furthering your knowledge and skills in this powerful framework.
    
    
     Keep up the
    
    
     
      great work!
     
    
   </p>
  </div>
 </body></html>