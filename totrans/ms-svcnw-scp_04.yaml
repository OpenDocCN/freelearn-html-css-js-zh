- en: Advanced Client-Side Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the advanced side of client-side scripting.
    Here, we will take a deeper look into scripting on the client and using some of
    the more advanced techniques that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: UI actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AJAX calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced client script examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI actions are generally considered to be a server-side script, but they can
    also run as client-side script, too. We will cover an introduction to UI actions
    and their basic usage in the server-side basics in the next chapter. Here, though,
    we will look at the more advanced techniques of running UI actions on the client
    side.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side UI actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To change a UI action to run client-side script, we first need to check the
    client field tick box. This brings up some additional fields, including the checkboxes
    to select which list versions the UI actions will be compatible with, but the
    main new field we are interested in is called `onClick`.
  prefs: []
  type: TYPE_NORMAL
- en: The `onClick` field runs the client code contained inside it when the UI action
    is selected. Visually, this is only a small field, and not that appropriate for
    code, so most developers call a function in this field and define the function
    in the main script field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of this usage. For the code in the `onClick` field,
    we only need to call the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the script field, we can define the function and contain the code
    we want to run inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This method of calling a function that resides in the script field is used by
    ServiceNow UI actions that are provided with the out-of-the-box platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what these UI actions would look like in *Figure 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8c8edf6-706f-482a-aefd-058f26360ec6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Example UI action containing client-side script'
  prefs: []
  type: TYPE_NORMAL
- en: In our example in *Figure 4.1*, we can see the UI action as a form button, as
    that is the checkbox that has been selected. The call in the `Onclick` field to
    the `onClick` function allows us to write as much code as we need in the script
    field inside our `onClick` function.
  prefs: []
  type: TYPE_NORMAL
- en: Calling server-side script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to use client-side scripts in UI actions, we can look
    at taking this a step further and using client- and server-side script in the
    same UI action.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved by first calling client-side script in the UI action, which
    then calls the UI action in the code, and therefore runs the server-side script.
    This is a slightly strange concept to imagine at first, so let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to take a look at the line of code that calls the UI action
    from the client-side code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code calls the UI action, but this time, it will run it
    on the server side. When using this technique, you must ensure that the Action
    name field of the UI action is the same as the name referenced in the script.
    The first argument of `gsftSubmit` is for a control, but seeing as we don't want
    to use this, we just pass null. This second argument is to get the form; in our
    case, we just want to get the current HTML form. The third argument is the action
    name, so this needs to be our UI action action name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the server side of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first part of this code is an `if` statement to check that we are running
    on the server side and not the client side anymore. This little piece of code
    also ensures that we do not receive browser errors. If the `if` statement evaluates
    to true, we then call a function to run our server-side code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the preceding example and call the `onClick` function in our script
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This now gives us a UI action that is running client- and server-side code.
    We will look at some further examples later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This type of script can be very useful, often being used on the client side
    to ensure certain fields are filled in or conditions are met before submission
    and the server-side code is run.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AJAX call is a way of calling server-side script from the client side in
    an efficient way. It is possible to simply use `GlideRecord` on the client side,
    but this is not considered best practice. It is worth remembering that every time
    we call the server from the client side, we have to make a round-trip from the
    client to the server and back again. This takes time and shows as a delay in front
    of the user. Therefore, we want to reduce the amount of server calls we make,
    and ensure that any we do are as efficient as possible.
  prefs: []
  type: TYPE_NORMAL
- en: An AJAX call can perform multiple `GlideRecord` queries on the server, which
    saves us having to perform multiple calls to the server. For the AJAX call to
    work, we need to have some client-side script and some server-side script. This
    is most commonly a client script and a script include; we'll look at script includes
    further in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client side of the AJAX call needs to set up the AJAX call and pass the
    relevant parameters to the server side. Once a response is received from the server,
    we can use the returned value or values to decide what changes to make. Let''s
    have a look at how the client side of the AJAX call works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example covers the calling of the AJAX call and the return function,
    based on the results that are returned. In the first line, we create a new AJAX
    call and give it the name of our script include. Following on from this, we can
    add parameters to send to the server.  The first one we need to include every
    time, as the `sysparm_name` parameter is the name of the function we want to call
    on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we can send as many parameters as we like to the server side to
    use in the server-side script. In the example, we are sending the current caller
    in the `sysparm_user_id` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use a `callback` function, which has the result returned to it using
    the `getXML` function. This allows the AJAX call to work asynchronously, and the
    client-side code can continue to run. You can use `getXMLWait` as a synchronous
    call instead, but this will stop the client from running code until the server-side
    code has completed, so is not best practice.
  prefs: []
  type: TYPE_NORMAL
- en: In the `callback` function, we make the answer variable the returned value of
    our server-side code. In this example, we are just showing an alert to the user
    of the result of our server-side script.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen the client aspect of an AJAX call, let's have a look at
    the the server-side code that is required to make this work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, we need to call the script include the same name as our
    AJAX call and make sure it contains a function with the name in the `sysparm_name`
    parameter. We also need to ensure we make the script include the client callable
    for the AJAX call to work, and we can do this by checking the client callable
    tick box on the script include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `getUserLocation` function to return the caller's location
    back to the client. By using `GlideRecord` and the `get` method to obtain the
    user record, we can then return the location from that user record back to the
    client. We are using the display value to display to the user on the client; otherwise,
    we simply display the location record `sys_id`, which does not mean much to an
    end user.
  prefs: []
  type: TYPE_NORMAL
- en: By using AJAX calls, we can pass back single values like in our example, or
    multiple values if needed. An array is a good way to pass multiple values back,
    but you can use other methods, too, as the response is an XML document.
  prefs: []
  type: TYPE_NORMAL
- en: Script examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen some more advanced ways of using client-side script, let's
    look at some examples of how to use these newly learned techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at UI actions. We may want to use a UI action to progress states
    in a change record, but we want to make sure certain fields are filled in before
    we progress on to other states. We can use client- and server-side code to achieve
    this. First we use the client-side code to validate the form, and then the server-side
    code to perform changes to the record.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have a look at how this would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the example, on the client-side script, we are setting the field we want
    populated to `Mandatory` in the script to ensure that it is populated before the
    form is submitted. This is a good way of notifying the user of the additional
    field to fill in, as it uses the ServiceNow `Mandatory` functionality, rather
    than popups appearing to the user. You will notice that after the submission,
    we stop the field being `Mandatory`. This is so that if the user wants to simply
    save the form or change different field values, they are not stopped by the `justification`
    field still being `Mandatory`.
  prefs: []
  type: TYPE_NORMAL
- en: For submitting the form, we use `gsftSubmit` and the action name of our UI action,
    which, in this example, is `authorize`. This allows the server-side script to
    run our server function, `setToAuthorize`. As the `state` field uses numbers as
    its values, we set the field to `-3`, and, as in the example, it is good practice
    to add comments to let other developers know what the value equates to; and it
    can be a good reminder for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take a look at what this UI action would look like in *Figure 4.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ca383de-7ef6-4d03-b4ac-d72cb7c0965c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Authorizing UI action with client- and server-side script'
  prefs: []
  type: TYPE_NORMAL
- en: This method of using client script to validate and server script to perform
    actions is very useful and works very nicely for UI actions.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at an AJAX call example. For this example, we are going
    to look at a catalog item with dependencies on the variables in the catalog item.
    Sometimes users may have certain access that needs to be revoked, perhaps when
    they leave the company. When we select the user, we want to ensure that they have
    some kind of access; otherwise, there will be nothing for them to pick in the
    remaining fields, resulting in a poor user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the client-side script we would put into a catalog client
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This would be put inside a catalog client script as an `onChange` script, and
    therefore dictates our function name. When we use catalog items and variables,
    we have to prefix our variable names with `variables` and then the variable name
    to use `g_form` methods. In the example, we are using a `user` and `access` variable,
    and as you can see, we clear the `access` variable when the user changes so that
    we don't end up with a mismatch of data on the screen where a user picks some
    access and then back fills the user.
  prefs: []
  type: TYPE_NORMAL
- en: Before we initiate the AJAX call, we check that the new value of the user field
    is not blank. If it is, there is no use making a round-trip to the server, so
    we use `return`, essentially exiting the script. If the value is not blank, then
    we use an AJAX call, calling our script include and sending a user parameter containing
    the new value in the user field.
  prefs: []
  type: TYPE_NORMAL
- en: When a response comes back from the server, if the result is that the user has
    no access, then we can assume there will be no access to select and remove for
    the user. Therefore there would be no selections to pick in the access variable.
    Rather than give the user nothing to select, we can clear the user field and let
    the user know the user they selected has no access to remove.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have taken a look at the client side of this example, let''s have
    a look at the server-side code. Remember that the script include name and function
    need to match up with the client code making the AJAX call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the server script, we are using a `GlideRecord` to check a custom access
    table, hence the `u_ prefix` using the `sysparm_user` parameter we passed to filter
    the result down to only records containing that user. If we find a record of access,
    we return `true` back to the client and `false` if no record can be found.
  prefs: []
  type: TYPE_NORMAL
- en: By returning `false` back to the client-side script, we clear the user variable
    on the form and show an error message so that the logged-in user knows that the
    user they selected has no access. If we assume a suitable reference qualifier
    has been set up, this would stop the logged-in user selecting the access variable
    after selecting a user and finding no records to select.
  prefs: []
  type: TYPE_NORMAL
- en: Since AJAX calls are so widely used, let's take a look at another example. In
    this example, we will notify a user on the incident form whether the change they
    have selected related to the incident that still has open tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we''ll use a client script to make the AJAX call. We need it to
    run when the change request field changes on the incident form, so we''ll use
    an `onChange` script. Let''s have a look at how this client script code will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we see an AJAX call again, this time sending the change request
    selected as a parameter. We do not need to run the AJAX call when the `change`
    field value or `newValue` is empty, but this time, we do want our script to run
    on load, so we have removed the `isLoading` check from the beginning of the script.
  prefs: []
  type: TYPE_NORMAL
- en: When we return from the AJAX call, we are using `g_form` to show a field message
    which appears just below the field to show whether the change request selected
    has open tasks or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll take a look at the server-side script that makes this AJAX call
    work. A script include will be used to hold the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the server-side script for this example, we are using a `GlideRecord` to
    find all the change tasks that are still open for the change request we passed
    in as a parameter. In the preceding script, we are using an `addQuery` line for
    the `GlideRecord` where the state is not `3` or `4`, which equates to closed and
    canceled. This allows us to treat any other state as open, even if further active
    states have been added from the out-of-the-box setup.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if any record is found, we can return `true` immediately, as
    we only need to know that at least one task is still open. There is no point in
    running through other change tasks if we find one that is still open, and this
    keeps the processing time down and the code more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Once the return value is sent back, the corresponding field message will display
    to the user using the client-side code. This type of AJAX call can be very useful
    for giving users extra detail on forms about the data they are entering.
  prefs: []
  type: TYPE_NORMAL
- en: The AJAX call is widely used, and I would certainly recommend becoming acquainted
    with it as early as possible for scripting in ServiceNow, as many requirements
    will need an AJAX call so they can be fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the advanced side of client scripting. We saw
    how we can use UI actions to run client-side code and run client- and then server-side
    code. We also took a look at the all-important AJAX call for an efficient way
    to call server-side code from the client. Lastly, we had a look at some examples
    of how to use these advanced client-side techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We will move on to the server side in the next chapter and see how to get started
    writing server-side script. This includes business rules, UI actions, and access
    controls. We'll also look at when these scripts should be written, how to test
    them, and some practical examples to help you get started.
  prefs: []
  type: TYPE_NORMAL
