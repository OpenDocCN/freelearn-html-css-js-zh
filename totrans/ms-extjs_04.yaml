- en: Chapter 4. The Logout and Multilingual Capabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：注销和多语言功能
- en: In this chapter, we are going to implement the multilingual capability of the
    system. This feature will allow the system to display the translation of the labels
    according to the language selected by the user (using some HTML5 features as well).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现系统的多语言功能。这个功能将允许系统根据用户选择的语言显示标签的翻译（同时使用一些HTML5功能）。
- en: We will also learn how to implement the logout capability so that the user can
    end the session, and also for security reasons, we will learn how to implement
    a session timeout warning for the user, in the case of inactivity (not using the
    mouse or keyboard for a while).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何实现注销功能，以便用户可以结束会话，并且出于安全原因，我们将学习如何在用户不活动（一段时间内没有使用鼠标或键盘）的情况下为用户实现会话超时警告。
- en: Also, after the user is authenticated, we need to display the application. In
    this chapter, we will learn how to implement the base of the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在用户认证后，我们需要显示应用程序。在本章中，我们将学习如何实现应用程序的基础。
- en: 'So, in this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖：
- en: The base of the application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的基础
- en: The logout capability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注销功能
- en: Activity monitoring and session timeout warnings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动监控和会话超时警告
- en: Structuring the application to receive the multilingual capability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化应用程序以接收多语言功能
- en: Creating the change language component
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建更改语言组件
- en: Handling the change language component at runtime
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时处理更改语言组件
- en: While we cover all the application capabilities, we will cover some Ext JS components
    as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍所有应用程序功能时，我们还将介绍一些Ext JS组件。
- en: The base of the application – view/main/Main.js
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的基础 – view/main/Main.js
- en: 'When we implemented the `success` function in the **Submit** button listener
    on the login controller, we mentioned the `Packt.view.main.Main` class. We are
    going to reuse this class (it was automatically created by Sencha Cmd when we
    created the project) as the base of our application. Before we start with the
    hands-on approach, let''s take a look at what is going to be the result of the
    application by the end of this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在登录控制器中实现**提交**按钮监听器的`success`函数时，我们提到了`Packt.view.main.Main`类。我们将重用这个类（它是在我们创建项目时由Sencha
    Cmd自动创建的）作为我们应用程序的基础。在我们开始动手实践之前，让我们看看本章结束时应用程序的结果：
- en: '![The base of the application – view/main/Main.js](img/0457OT_04_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序的基础 – view/main/Main.js](img/0457OT_04_01.jpg)'
- en: The Viewport
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视口
- en: Whenever we construct an application entirely with Ext JS (because we do have
    the option of using a single component rendered to a `<div>` tag if we want to,
    in a manner similar to what is done in jQuery), we need to use a component that
    is going to be the base of the application. This component is the Viewport. The
    Viewport is a specialized container representing the viewable application area
    (the browser viewport). The Viewport renders itself to the document body, and
    automatically sizes itself to the size of the browser viewport and manages window
    resizing. There might only be one Viewport created in an application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否完全使用Ext JS构建应用程序（因为我们确实有选择将单个组件渲染到`<div>`标签中的选项，类似于jQuery中执行的方式），我们都需要使用一个将成为应用程序基础的组件。这个组件是视口。视口是一个特殊的容器，代表可查看的应用程序区域（浏览器视口）。视口将自身渲染到文档主体，并自动调整自身大小以匹配浏览器视口的大小，并管理窗口大小调整。应用程序中可能只有一个视口被创建。
- en: Before we create the Viewport, if we click on the **Submit** button of the **Login**
    screen, we will see a grayish screen, even though we are calling `Ext.create('Packt.view.main.Main');`
    inside the `LoginController` class. This means `Packt.view.main.Main` is being
    created, but nothing is being displayed on the screen. This is because the `Main`
    class is not being rendered as a child of any component, and it is also not being
    rendered to the HTML body. But we are going to change this behavior by changing
    it to a Viewport.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建视口之前，如果我们点击**登录**屏幕的**提交**按钮，我们会看到一个灰色屏幕，即使我们在`LoginController`类内部调用了`Ext.create('Packt.view.main.Main');`。这意味着`Packt.view.main.Main`正在被创建，但屏幕上没有显示任何内容。这是因为`Main`类没有被渲染为任何组件的子组件，也没有被渲染到HTML主体中。但我们将通过将其更改为视口来改变这种行为。
- en: 'Open the `app/view/main/Main.js` file. In the second line of code, you will
    find the following snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/view/main/Main.js`文件。在代码的第二行，你会找到以下代码片段：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Main` class that was created by Sencha Cmd is extending the `Container`
    component. The `Container` component is the simplest container component in the
    Ext JS API. It supports adding and removing items to it, and it is also the parent
    class to many other components, such as Panel, Window, and TabPanel. We are going
    to change `Ext.container.Container` to `Ext.container.Viewport` so that we can
    use the `Main` class as the base class of our application. Save the code, refresh
    the browser, and give it a try. The next time you click on the **Submit** button,
    you should see the original code created by Sencha Cmd after you are logged in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Sencha Cmd 创建的 `Main` 类扩展了 `Container` 组件。`Container` 组件是 Ext JS API 中最简单的容器组件。它支持向其中添加和移除项目，同时也是许多其他组件的父类，例如
    Panel、Window 和 TabPanel。我们将把 `Ext.container.Container` 改为 `Ext.container.Viewport`，这样我们就可以将
    `Main` 类作为我们应用程序的基类。保存代码，刷新浏览器，试一试。下次当你点击 **提交** 按钮时，登录后你应该能看到由 Sencha Cmd 创建的原始代码。
- en: Using the Viewport plugin
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Viewport 插件
- en: Extending the `Ext.container.Viewport` class is the classic and traditional
    way of having a Viewport in Ext JS applications. Ext JS 5 introduces a new way
    of using a Viewport by using the Viewport plugin (`Ext.plugin.Viewport`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 应用程序中扩展 `Ext.container.Viewport` 类是经典和传统的方式。Ext JS 5 引入了一种使用 Viewport
    的新方法，即使用 Viewport 插件 (`Ext.plugin.Viewport`)。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about Ext JS plugins, please read [http://www.sencha.com/blog/advanced-plugin-development-with-ext-js/](http://www.sencha.com/blog/advanced-plugin-development-with-ext-js/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Ext JS 插件的信息，请阅读[http://www.sencha.com/blog/advanced-plugin-development-with-ext-js/](http://www.sencha.com/blog/advanced-plugin-development-with-ext-js/)。
- en: 'To use the plugin, first roll back the changes we made in the preceding topic
    (the `Main` class will continue to extend `Ext.container.Container`) and add the
    following code after the `extend` code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个插件，首先撤销前面主题中我们所做的更改（`Main` 类将继续扩展 `Ext.container.Container`），然后在 `extend`
    代码之后添加以下代码：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the `plugins` configuration has the same result as extending the `Viewport`
    class. This plugin transforms any component into a Viewport, making it fill all
    the available space in the browser. The advantage of this plugin is that we can
    still reuse this class in other contexts, for example, inside a window.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `plugins` 配置与扩展 `Viewport` 类有相同的结果。这个插件将任何组件转换为一个 Viewport，使其填充浏览器中的所有可用空间。这个插件的优势在于我们仍然可以在其他上下文中重用这个类，例如在窗口内部。
- en: 'We know that the **ptype** (plugin type) of the Viewport plugin is **viewport**
    by accessing the documentation:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，通过查阅文档，Viewport 插件的 **ptype**（插件类型）是 **viewport**。
- en: '![Using the Viewport plugin](img/0457OT_04_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Viewport 插件](img/0457OT_04_02.jpg)'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always remember that the documentation needs to be your best friend while developing
    Ext JS applications!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，在开发 Ext JS 应用程序时，文档需要成为你的最佳朋友！
- en: Organizing the main screen using the Border layout
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Border 布局组织主屏幕
- en: 'As we learned in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"),
    *Sencha Ext JS Overview*, the Border layout can be used to organize the children
    of a parent container into five regions: north, south, west, east, and center.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](ch01.html "第1章. Sencha Ext JS 概述")中学习到的，*Sencha Ext JS 概述*，Border
    布局可以用来将父容器的子元素组织成五个区域：北、南、西、东和中心。
- en: 'The center region is the only one that is mandatory to have. The other ones
    are optional. Looking at the following screenshot, we can see that we are going
    to organize our main screen into four regions: **center**, **north**, **south**,
    and **west**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 中心区域是唯一必须存在的区域。其他区域是可选的。查看下面的截图，我们可以看到我们将把主屏幕组织成四个区域：**中心**、**北**、**南**和**西**：
- en: '![Organizing the main screen using the Border layout](img/0457OT_04_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Border 布局组织主屏幕](img/0457OT_04_03.jpg)'
- en: 'Let''s take a look at the `items` configuration of the `Main` class (you can
    replace the code that was generated by Sencha Cmd with the following code):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Main` 类的 `items` 配置（你可以用以下代码替换由 Sencha Cmd 生成的代码）：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `center` region, we have `mainpanel` (`#1`). In [Chapter 5](ch05.html
    "Chapter 5. Advanced Dynamic Menu"), *Advanced Dynamic Menu*, we are going to
    create a dynamic menu that will give the options to the user to open the screens
    the user is entitled to. Each screen the user opens will be created as a tab in
    `mainpanel`. We will create it in a minute.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`center`区域，我们有`mainpanel`（`#1`）。在[第5章](ch05.html "第5章。高级动态菜单")，*高级动态菜单*中，我们将创建一个动态菜单，将给用户打开他们有权访问的屏幕的选项。用户打开的每个屏幕都将作为`mainpanel`中的一个标签创建。我们将在下一分钟创建它。
- en: In the `north` region, we have the header (`#2`), and in the `south` region,
    we have the footer (`#3`). We will also work on them in a minute.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`north`区域，我们有头部（`#2`），在`south`区域，我们有页脚（`#3`）。我们也将很快对它们进行处理。
- en: In the `west` region, we have `container` (`#4`), which we will use in the next
    chapter to render the dynamic menu. For now, we will leave the space reserved
    for it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`west`区域，我们有`container`（`#4`），我们将在下一章中使用它来渲染动态菜单。现在，我们将为它预留空间。
- en: It is important to know that for the `center` region, we do not need to specify
    `width` or `height`. The container that is being rendered in the `center` region
    is going to use whatever space is left in the Border layout. For the `south` and
    `north` regions, you are required to specify `height`. We will do this when we
    create `Header` and `Footer`. The `south` and `north` regions are going to use
    all the available horizontal space that is available in the screen—limited by
    `height`—which is why `width` is not required. For the `west` and `east` regions,
    it is required to specify `width`. As we are only using the `west` region, we
    specified `200` pixels (`#4`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，对于`center`区域，我们不需要指定`width`或`height`。在`center`区域渲染的容器将使用Border布局中剩余的任何空间。对于`south`和`north`区域，你需要指定`height`。我们将创建`Header`和`Footer`时这样做。`south`和`north`区域将使用屏幕上所有可用的水平空间——受`height`限制——这就是为什么不需要`width`。对于`west`和`east`区域，需要指定`width`。因为我们只使用`west`区域，所以我们指定了`200`像素（`#4`）。
- en: Creating the main TabPanel component
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建主TabPanel组件
- en: 'We need to create the `mainpanel` component that we are using in the `center`
    region of the `Main` class. To do so, we are going to create a new file named
    `Panel.js` inside the `app/view/main` folder, and we are going to write the following
    code inside it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建在`Main`类的`center`区域使用的`mainpanel`组件。为此，我们将在`app/view/main`文件夹内创建一个名为`Panel.js`的新文件，并在其中编写以下代码：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As usual, we will start with the name of the class. The class name convention
    is *app namespace + folder* (inside `app`) *+ filename* (without the `.js` extension),
    which will result in `Packt.view.main.Panel` (`#1`). The `main.Panel` class is
    extending the TabPanel component (`#2`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将从类的名称开始。类的命名约定是*app命名空间 + 文件夹*（在`app`内部）*+ 文件名*（不带`.js`扩展名），这将导致`Packt.view.main.Panel`（`#1`）。`main.Panel`类是扩展TabPanel组件的（`#2`）。
- en: In line `#3`, we have `xtype` of the `main.Panel` class. This is the `xytpe`
    class we used to instantiate this class inside the `Main` class. In line `#4`,
    we have the `activeTab` configuration. When we set a tab to active, the TabPanel
    component is going to display the contents of the tab, and it is also going to
    highlight it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`#3`行，我们有`main.Panel`类的`xtype`。这是我们用来在`Main`类内部实例化这个类的`xytpe`类。在第`#4`行，我们有`activeTab`配置。当我们设置一个标签为活动状态时，TabPanel组件将显示该标签的内容，并且也会将其突出显示。
- en: As we learned in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"),
    *Sencha Ext JS Overview*, the TabPanel component is a container that has tabs
    as children organized by the Card layout, which means that the user will see the
    content of one active tab at a time. Each child declared inside the `items` configuration
    is an instance of the `tab` class (`Ext.tab.Tab`), and it can be of any type as
    we have in line `#5`. So as not to display an empty screen, we are displaying
    a `'Home'` tab (`#8`) that is a panel (`#5`), which means it can have toolbars
    and other components inside it as well. This `Home` tab cannot be closed (`#6`);
    otherwise, the user will see a blank space in the middle of the main screen, and
    we do not want that. We are also setting a Font Awesome icon in the format of
    `home` in line `#7` for it to look prettier.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](ch01.html "第1章. Sencha Ext JS概述")中学习的，*Sencha Ext JS概述*，TabPanel组件是一个容器，它通过卡片布局组织子标签页，这意味着用户将一次看到一个活动标签页的内容。在`items`配置内部声明的每个子项都是`tab`类的实例（`Ext.tab.Tab`），它可以是我们`#5`行中具有的任何类型。因此，为了不显示空屏幕，我们显示了一个`'Home'`标签页（`#8`），它是一个面板（`#5`），这意味着它也可以包含工具栏和其他组件。这个`Home`标签页不能被关闭（`#6`）；否则，用户将在主屏幕中间看到一个空白区域，我们不希望这样。我们还在`#7`行设置了一个格式为`home`的Font
    Awesome图标，使其看起来更美观。
- en: You can use this **Home** tab to display announcements or to behave like a dashboard,
    where the user will see a summary of all the pending tasks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此**主页**选项卡来显示公告或表现得像一个仪表板，用户将看到所有待办任务的摘要。
- en: Creating the footer
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建页脚
- en: 'The next step is creating the footer of the main screen. We are going to create
    a new file named `Footer.js` inside `app/view/main` with the following code inside
    it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建主屏幕的页脚。我们将在`app/view/main`内部创建一个名为`Footer.js`的新文件，并在其中包含以下代码：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Footer` is going to extend from the `Container` class (`#1`). The `Container`
    class is the lightest component that we can create that can have items inside
    it. We should give preference to use it whenever possible. We will discuss this
    in greater detail later. Then, we declare the `xtype` class (`#2`), which is the
    alias we are using to instantiate this class in the `Main` class.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Footer`将扩展自`Container`类（`#1`）。`Container`类是我们能创建的最轻组件，它可以包含项目。我们应该尽可能优先使用它。我们将在稍后进行更详细的讨论。然后，我们声明`xtype`类（`#2`），这是我们用于在`Main`类中实例化此类的别名。'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always remember that the convention for aliases (`xtype`) is to use all letters
    in lowercase. If you would like to, you can separate words with "`-`" (a hyphen)
    depending on your personal preference.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，别名（`xtype`）的约定是使用所有小写字母。如果您愿意，可以根据个人喜好使用"`-`"（连字符）分隔单词。
- en: If we look at the first image of this chapter, we will note that the footer
    has a top border. We add a style on line `#3` that adds this border to the footer.
    The `cls` configuration allows us to add extra CSS to a component in Ext JS. It
    is available to all components. We will add the style to our CSS in a minute.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看本章的第一幅图像，我们会注意到页脚有一个顶部边框。我们在`#3`行添加了一个样式，将此边框添加到页脚。`cls`配置允许我们在Ext JS中的组件上添加额外的CSS。它适用于所有组件。我们将在一分钟内将样式添加到我们的CSS中。
- en: As we are declaring `Footer` in the south region of the `Main` class, you are
    required to set the `height` parameter. We can do this inside the `Footer` class
    or inside the `Main` class when declaring the south region. In this case, we are
    setting it inside the `Footer` class (`#4`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`Main`类的南部区域声明了`Footer`，因此您需要设置`height`参数。我们可以在`Footer`类内部或声明南部区域时在`Main`类内部完成此操作。在这种情况下，我们是在`Footer`类内部设置它（`#4`）。
- en: Inside the `Footer` class, we want to have only one component in this example,
    which is text (you can use a copyright message), and we are going to display it
    using HTML. We also want this text to be centered. For this reason, we can use
    the `center` layout (`#5`). To use the `center` layout, the parent container needs
    to have only one child component (because it inherits from the `fit` layout, which
    only supports a single child as well). It is also required to declare the `width`
    parameter of the child component (`#7`); in this case, the text we are going to
    display is approximately `350` pixels wide.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Footer`类内部，我们在这个例子中只想有一个组件，即文本（您可以使用版权信息），我们将使用HTML显示它。我们还希望这段文本居中。因此，我们可以使用`center`布局（`#5`）。要使用`center`布局，父容器需要只有一个子组件（因为它继承自`fit`布局，它也只支持单个子组件）。还需要声明子组件的`width`参数（`#7`）；在这种情况下，我们将显示的文本大约宽`350`像素。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Ext JS 4, the Center layout was used as a UX plugin shipped with the Ext
    JS SDK. In Ext JS 5, this layout was promoted to the native API, but it kept backwards
    compatibility. In the layout configuration, you can use `center` (introduced in
    Ext JS 5) and also keep using `ux.center` (from Ext JS 4) if you are migrating
    an application from Ext JS 4 to 5.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS 4中，Center布局被用作与Ext JS SDK一起提供的UX插件。在Ext JS 5中，这个布局被提升为原生API，但保持了向后兼容性。在布局配置中，你可以使用`center`（在Ext
    JS 5中引入）并继续使用`ux.center`（来自Ext JS 4），如果你正在将应用程序从Ext JS 4迁移到5。
- en: To render the HTML, we are going to use the lightest and simplest component
    as possible, which is `component` (`#6`). As we also want to apply some CSS to
    our text, we are going to use the `componentCls` (`#8`) class, which is a CSS
    class that is added to a component's root-level element.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染HTML，我们将使用尽可能轻量和简单的组件，即`component`（`#6`）。因为我们还想要应用一些CSS到我们的文本上，我们将使用`componentCls`（`#8`）类，这是一个添加到组件根级元素的CSS类。
- en: 'Note that there is no text declared anywhere inside the `Footer` class. Instead,
    we are binding the `html` configuration to a value (`#9`) named `footer`. This
    is also part of the new MVVM architecture that we are also going to use in this
    chapter. In the preceding chapter, we only used the `View` and `ViewController`
    classes for the login capability. In this chapter, we are going to use the complete
    feature: View, ViewController, and ViewModel from the MVVM architecture (Sencha
    Cmd already generated these classes when we created the project, so we better
    reuse them!). For now, keep in mind that this is part of the ModelView binding
    that we will dive into in the next topic.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`Footer`类内部没有声明任何文本。相反，我们将`html`配置绑定到一个名为`footer`的值（`#9`）。这也是我们将在本章中使用的新的MVVM架构的一部分。在前一章中，我们只使用了`View`和`ViewController`类来实现登录功能。在本章中，我们将使用完整的特性：从MVVM架构中来的View、ViewController和ViewModel（当我们创建项目时，Sencha
    Cmd已经生成了这些类，所以最好重用它们！）。目前，请记住，这是ModelView绑定的一个部分，我们将在下一个主题中深入探讨。
- en: A quick word about modular CSS
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于模块化CSS的简要说明
- en: Let's discuss another way of adding CSS to our application. We already know
    that the best practice to add CSS to our application is to add using Sass inside
    the `sass/etc` folder as we did in the previous examples. However, there are some
    styles that we create to apply to specific components, and we are not going to
    reuse them throughout the application. Instead of adding these CSS styles to our
    `all.scss` file and having a big file that can give us a headache later if we
    need to maintain it, we can use a more modular CSS approach to create specific
    CSS for our Ext JS views.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论另一种向我们的应用程序添加CSS的方法。我们已经知道，向我们的应用程序添加CSS的最佳实践是在`sass/etc`文件夹内使用Sass，就像我们在前面的例子中所做的那样。然而，有一些样式是为特定组件创建的，我们不会在整个应用程序中重用它们。而不是将这些CSS样式添加到我们的`all.scss`文件中，并得到一个可能会在需要维护时给我们带来头痛的大文件，我们可以使用更模块化的CSS方法来为我们的Ext
    JS视图创建特定的CSS。
- en: 'Inside the `sass` folder, create a new folder named `src` (if it has not been
    created by Sencha Cmd automatically), and inside `src`, create a new folder named
    `view`. Inside `view`, create a new folder named `main`. We will have the directory
    `sass/src/view/main`. Inside this directory, create a file named `Footer.scss`
    with the following content inside it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sass`文件夹内，创建一个名为`src`的新文件夹（如果Sencha Cmd没有自动创建），然后在`src`内部创建一个名为`view`的新文件夹。在`view`内部，创建一个名为`main`的新文件夹。我们将有`sass/src/view/main`这个目录。在这个目录内，创建一个名为`Footer.scss`的文件，并在其中包含以下内容：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In line `#1`, we declare a Sass variable with a bluish color (the same blue
    color as the `TabPanel` background). We are reusing this variable in lines `#2`
    and `#3` in the styles we created to use in our `Footer` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在行`#1`中，我们声明了一个带有蓝色调的Sass变量（与`TabPanel`背景相同的蓝色）。我们在创建用于我们的`Footer`类的样式时，在行`#2`和`#3`中重用了这个变量。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In line `#3`, we use the `darken` function from Sass, which accepts a color
    and a number from 0-100, the percentage to which we want to make the color darker.
    For more information, please refer to the Sass documentation at [http://goo.gl/JsAnVz](http://goo.gl/JsAnVz).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在行`#3`中，我们使用了Sass中的`darken`函数，它接受一个颜色和一个0-100之间的数字，这是我们想要使颜色变暗的百分比。有关更多信息，请参阅Sass文档，网址为[http://goo.gl/JsAnVz](http://goo.gl/JsAnVz)。
- en: The `view/main/Footer.scss` file has the same path as the `view/main/Footer.js`
    file. Note that this way, it is easier to maintain the styles specific to the
    `Footer` class. We will do the same for the `Header` class in the next topic.
    We separate the CSS into modules for it to be easier to read and maintain, and
    when we do the build, all the CSS will be concatenated into a single production
    CSS file—this is called modular CSS. See, developing applications with Ext JS
    is not all about Ext JS; we can apply the knowledge from other frontend technologies
    as well!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`view/main/Footer.scss` 文件与 `view/main/Footer.js` 文件的路径相同。请注意，这样，维护 `Footer`
    类特定的样式就更容易了。我们将在下一个主题中为 `Header` 类做同样的事情。我们将 CSS 分离成模块，以便更容易阅读和维护，当我们进行构建时，所有的
    CSS 都将连接成一个单独的生产 CSS 文件——这被称为模块化 CSS。看看，使用 Ext JS 开发应用程序不仅仅是 Ext JS；我们还可以应用其他前端技术的知识！'
- en: Creating the Header class
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Header 类
- en: 'Next, we are going to create the `Header` class. The `Header` class contains
    the logo of the application along with the application name, the dropdown that
    offers the translation capability, and the **Logout** button. To create the header,
    we are going to create a new file, `Header.js`, inside the `app/view/main` folder
    with the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `Header` 类。`Header` 类包含应用程序的标志、应用程序名称、提供翻译功能的下拉菜单以及**注销**按钮。为了创建标题，我们将在
    `app/view/main` 文件夹内创建一个新的文件，名为 `Header.js`，并包含以下代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our `Header` class is going to extend the `Toolbar` class (`#1`). The `Toolbar`
    class is usually used inside panels and its subclasses (grid, form, tree) to organize
    buttons, but it can also be used to hold other components as we are going to do
    in this example. We will cover more about toolbars in other chapters as well.
    We are also declaring an `xtype` class for the `Header` class that we are making
    a reference to in the `Main` class (`#2`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Header` 类将扩展 `Toolbar` 类（`#1`）。`Toolbar` 类通常用于面板及其子类（网格、表单、树）中，用于组织按钮，但它也可以像我们在这个例子中要做的那样，用来包含其他组件。我们将在其他章节中介绍更多关于工具栏的内容。我们还在
    `Header` 类中声明了一个 `xtype` 类，我们在 `Main` 类（`#2`）中引用了这个类。
- en: Whenever we use an `xtype` class created by ourselves, Ext JS does not understand
    what component we are trying to instantiate. For this reason, we require the class
    we are referring to. For example, in line `#3`, we reference the class of the
    translation component we are instantiating using its `xtype` class in line `#10`.
    We are going to develop this component later in the chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用我们自己创建的 `xtype` 类时，Ext JS 都无法理解我们试图实例化的组件是什么。因此，我们需要引用我们正在使用的类。例如，在第 `#3`
    行中，我们通过在第 `#10` 行中使用的 `xtype` 类引用我们正在实例化的翻译组件的类。我们将在本章后面开发这个组件。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in the `Main` class, we did not use `requires` yet. We need to go
    back and add the required `Header`, `Footer`, and `main.Panel` classes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `Main` 类中，我们还没有使用 `requires`。我们需要回到那里并添加所需的 `Header`、`Footer` 和 `main.Panel`
    类。
- en: 'The `ui` configuration allows us to use a specific theme for a component. The
    `Toolbar` component has the configuration `ui: ''footer''` (`#4`), which gives
    the toolbar a transparent background. The `footer` value is included in the Ext
    JS SDK, and it makes the toolbar transparent. We are going to create some custom
    `ui` configurations when we discuss themes later in this book.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ui` 配置允许我们为组件使用特定的主题。`Toolbar` 组件具有配置 `ui: ''footer''` (`#4`)，这为工具栏提供了透明的背景。`footer`
    值包含在 Ext JS SDK 中，并使工具栏透明。我们将在本书后面讨论主题时创建一些自定义的 `ui` 配置。'
- en: The two first children items of the `Header` class are the icon (`#5`) and the
    application name. For the icon, we are going to use Font Awesome to display an
    icon in the format of a desktop. For the title of the application, we will use
    the same approach we used in the case of the `Footer` class. We are also using
    a `componentCls` configuration (`#7`) to style it. We get both values (icon-`#6`
    and application name-`#8`) from the ViewModel, which we will cover in a minute.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Header` 类的前两个子项是图标（`#5`）和应用程序名称。对于图标，我们将使用 Font Awesome 来显示桌面格式的图标。对于应用程序的标题，我们将使用我们在
    `Footer` 类中使用的相同方法。我们还在使用一个 `componentCls` 配置（`#7`）来对其进行样式化。我们从 ViewModel 中获取这两个值（图标-`#6`
    和应用程序名称-`#8`），我们将在下一分钟进行介绍。'
- en: The next item is a toolbar fill (`#9`). This component will align the `translation`
    (`#10`) and `logout` buttons (`#13`) to the right, filling the `Toolbar` class
    with space in the middle (between the application title and the buttons).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项目是工具栏填充（`#9`）。此组件将 `translation` (`#10`) 和 `logout` 按钮 (`#13`) 对齐到右侧，填充
    `Toolbar` 类中间的空间（在应用程序标题和按钮之间）。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Instead of `{ xtype: ''tbfill'' }`, we could also use `''->''` as a shortcut.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '除了 `{ xtype: ''tbfill'' }`，我们还可以使用 `''->''` 作为快捷方式。'
- en: We also have the `logout` button declared on line `#12`. We are going to assign
    `itemId` so that we can reference this button globally by the application. We
    will need it when we work with the session monitor capability. The `itemId` needs
    to be unique in its scope; in this case, it needs to be unique within this class,
    but it is going to be even better if it is unique at the application level.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在第 `#12` 行声明了 `logout` 按钮。我们将分配 `itemId` 以便我们可以通过应用程序全局引用此按钮。当我们使用会话监控功能时，我们需要它。`itemId`
    在其作用域内需要是唯一的；在这种情况下，它需要在这个类中是唯一的，但如果它在应用程序级别是唯一的会更好。
- en: As we are going to use the `ViewController` class to handle the logout, we will
    declare a `reference` (`#14`) to make it easier to retrieve the button reference
    inside the `ViewController` class, and we are also going to declare the listener
    (`#16`), which means that the `onLogout` function from the `ViewController` class
    is going to be executed when we click on the **Logout** button.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 `ViewController` 类来处理注销，我们将声明一个 `reference` (`#14`) 以便在 `ViewController`
    类内部更容易地检索按钮引用，我们还将声明监听器 (`#16`)，这意味着当我们在 **注销** 按钮上点击时，`ViewController` 类中的 `onLogout`
    函数将被执行。
- en: We are also setting an icon to the `Logout` button from Font Awesome (`#15`).
    By default, the icon will have the color black. The button text is white, and
    we want the icon to have the same color as the text. For this reason, we add a
    custom style (`buttonIcon`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了一个来自 Font Awesome 的图标到 `Logout` 按钮（`#15`）。默认情况下，图标将具有黑色。按钮文本是白色，我们希望图标与文本颜色相同。因此，我们添加了一个自定义样式（`buttonIcon`）。
- en: At last, we have the toolbar separator declared on line `#11`. This simply adds
    a separator ("|") between the buttons.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有工具栏分隔符在第 `#11` 行声明。这只是在按钮之间添加一个分隔符（"|"）。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Likewise, `tbfill`, the toolbar separator, also has a shortcut. Instead of
    `{ xtype: '' tbseparator'' }`, we could also use `''-''`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，`tbfill`，工具栏分隔符，也有一个快捷方式。除了 `{ xtype: ''tbseparator'' }`，我们还可以使用 `''-''`。'
- en: Creating the Header CSS
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建头部 CSS
- en: 'Just as we did with the `Footer` class, we are also going to create a filename,
    `Header.scss`, inside the `sass/view/main` folder with the following content inside
    it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对 `Footer` 类所做的那样，我们也将创建一个文件名，`Header.scss`，在 `sass/view/main` 文件夹中，其中包含以下内容：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `app-header-logo` was created to customize the color of the icon to be the
    same as the application title. We are using the Sass variable inside both styles.
    The text color of the title is a dark blue.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`app-header-logo` 是为了自定义图标颜色与应用程序标题相同而创建的。我们在两种样式中都使用了 Sass 变量。标题的文本颜色是深蓝色。'
- en: Customizing the Font Awesome icon colors
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义 Font Awesome 图标颜色
- en: By default, the Font Awesome icons will be displayed in black. But we want some
    of the icons to have the same color as our theme. We can do this customization
    using CSS as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Font Awesome 图标将以黑色显示。但我们要让一些图标与我们的主题颜色相同。我们可以使用 CSS 来进行这种自定义。
- en: 'We have declared two styles to customize the Font Awesome icons until now.
    The first one was inside the `Panel` class (`tabIcon`), and the second one is
    the **Logout** button (`buttonIcon`). So we also need to add these styles to our
    CSS. To follow the modular CSS approach, let''s create a new file, `iconColors.scss`,
    under `sass/etc` with the following content:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了两种样式来自定义 Font Awesome 图标。第一个是在 `Panel` 类中（`tabIcon`），第二个是 **注销** 按钮（`buttonIcon`）。因此，我们还需要将这些样式添加到我们的
    CSS 中。为了遵循模块化 CSS 方法，让我们在 `sass/etc` 下创建一个新文件，`iconColors.scss`，其中包含以下内容：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We will get used to using Sass variables to make our life easier if we decide
    to customize the Ext JS theme later!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定稍后自定义 Ext JS 主题，我们将习惯于使用 Sass 变量来简化我们的工作！
- en: 'Then, all we need to do is import this file in the `all.scss` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要将此文件导入 `all.scss` 文件中：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The main screen and MVVM
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主屏幕和 MVVM
- en: 'Now, it''s time to put everything together. Let''s take a look at how the `Main`
    class looks with the complete code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将所有内容整合在一起了。让我们看看完整的代码如何使 `Main` 类看起来：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We need to add the `requires` declaration of all the classes we created (and
    we are referencing them by their `xtype` classes) and also the `Main` ViewModel
    and `Main` ViewController class that were already created by Sencha Cmd.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加我们创建的所有类（我们通过它们的 `xtype` 类引用它们）的 `requires` 声明，以及由 Sencha Cmd 创建的 `Main`
    ViewModel 和 `Main` ViewController 类。
- en: The `controller` (`#2`) and `viewModel` (`#3`) declarations were already added
    by Sencha Cmd when we created the project. We are simply reusing them by referencing
    their types.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`controller`（`#2`）和 `viewModel`（`#3`）声明已经在创建项目时由 Sencha Cmd 添加。我们通过引用它们的类型简单地重用它们。'
- en: The main ViewModel
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要 ViewModel
- en: 'If we open the `MainModel.js` file inside the `app/view/main` folder, we will
    see some content inside it already. We are going to add more content to it, and
    the file is going to look as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开 `app/view/main` 文件夹中的 `MainModel.js` 文件，我们将在其中看到一些内容。我们将向其中添加更多内容，文件将如下所示：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s start with the name of the class (`#1`). The naming convention for ViewModel
    suggested by Sencha is the name of the view (`Main`) + "`Model`", resulting in
    `MainModel`. A ViewModel extends from the `ViewModel` class (`#2`) introduced
    in Ext JS 5, along with the MVVM architecture. The alias (`#3`) of a ViewModel
    is defined by "`viewmodel.`" + the name of the type we want to assign. In this
    case, Sencha already created this class for us with the type `main`. That is why
    we can reference this alias in the `View` class using the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从类的名称（`#1`）开始。由 Sencha 提议的 ViewModel 命名规范是视图的名称（`Main`）+ "Model"，结果为 `MainModel`。ViewModel
    从 Ext JS 5 中引入的 `ViewModel` 类（`#2`）扩展，并使用 MVVM 架构。ViewModel 的别名（`#3`）由 "`viewmodel.`"
    加上我们想要分配的类型名称定义。在这种情况下，Sencha 已经为我们创建了此类，类型为 `main`。这就是为什么我们可以在 `View` 类中使用以下代码引用此别名：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `data` configuration allows us to populate values in the `ViewModel` class.
    The `name` field (`#4`) was created by Sencha Cmd, so we are going to keep it
    (you can remove it if you want). The `appName` (`#5`) and `appHeaderIcon` (`#6`)
    properties are being used by `Header` and `footer` (`#7`) is being used by the
    `Footer` class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 配置允许我们在 `ViewModel` 类中填充值。`name` 字段（`#4`）是由 Sencha Cmd 创建的，所以我们将保留它（如果你想移除，也可以移除）。`appName`（`#5`）和
    `appHeaderIcon`（`#6`）属性被 `Header` 使用，而 `footer`（`#7`）被 `Footer` 类使用。'
- en: '`MainModel` is bound to the `Main` class (View). Because `Header` and `Footer`
    are `items` of the `Main` component, they can also reference `MainModel`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainModel` 与 `Main` 类（视图）绑定。因为 `Header` 和 `Footer` 是 `Main` 组件的 `items`，它们也可以引用
    `MainModel`。'
- en: This is the simplest way in which we can create the `ViewModel` class, with
    prepopulated data. We will provide other advanced examples throughout this book,
    but we need to start with baby steps!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们创建带有预填充数据的 `ViewModel` 类的最简单方式。我们将在本书的其余部分提供其他高级示例，但我们需要从小步骤开始！
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about ViewModel, data binding, and how to bind different
    data types, please read the following Sencha guide: [http://goo.gl/qta6kH](http://goo.gl/qta6kH).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 ViewModel、数据绑定以及如何绑定不同数据类型的信息，请阅读以下 Sencha 指南：[http://goo.gl/qta6kH](http://goo.gl/qta6kH)。
- en: Logout capability
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注销功能
- en: As the user has the option to log in to the application, the user can also log
    out from it. Inside the `Header` class, we have already declared the `logout`
    button. The only thing pending is to implement the listener inside `MainController`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户可以选择登录应用程序，用户也可以从应用程序中注销。在 `Header` 类中，我们已经声明了 `logout` 按钮。唯一待办的事情是在 `MainController`
    中实现监听器。
- en: 'As the `MainController` class was created by Sencha Cmd, we are reusing it.
    The file already has some code in it. Let''s remove any listener created by Sencha.
    `MainController` will look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `MainController` 类是由 Sencha Cmd 创建的，我们正在重用它。文件中已经有了一些代码。让我们移除由 Sencha 创建的任何监听器。`MainController`
    将如下所示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `Header` class, we declared the `logout` button, its reference, and
    its listener. So we need to implement the `onLogout` function, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header` 类中，我们声明了 `logout` 按钮、其引用和其监听器。因此，我们需要实现 `onLogout` 函数，如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `me` (`#1`) variable makes a reference to `this`, which is the `MainController`
    class. We will make an Ajax call (`#2`) to `php/security/logout.php` (we will
    create this file soon). We will handle the `success` (`#4`) and `failure` (`#5`)
    callbacks in separate functions that are declared inside the `MainController`
    class as well. That is why the scope is set to the `MainController` class (`#3`)
    itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`me` (`#1`) 变量是对 `this` 的引用，即 `MainController` 类。我们将向 `php/security/logout.php`
    发起一个 Ajax 调用 (`#2`)（我们很快将创建此文件）。我们将在 `MainController` 类内部声明的单独函数中处理 `success`
    (`#4`) 和 `failure` (`#5`) 回调。这就是为什么作用域被设置为 `MainController` 类本身 (`#3`) 的原因。'
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We could declare the `success` and `failure` callbacks directly inside the Ajax
    request. But then, our code will be very long, which would decrease its readability.
    This way, the code stays organized and easier to read. This is always a best practice
    to be followed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在 Ajax 请求中声明 `success` 和 `failure` 回调。但这样，我们的代码会非常长，这会降低其可读性。这种方式可以使代码保持组织结构，更容易阅读。这始终是一个需要遵循的最佳实践。
- en: Handling the logout on the server
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理服务器上的注销
- en: 'To handle the logout capability on the server, we will create a new PHP page
    named `logout.php` under the `php/security` folder. The code is very simple:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理服务器上的注销功能，我们将在 `php/security` 文件夹下创建一个名为 `logout.php` 的新 PHP 页面。代码非常简单：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we need to resume the current session (`#1`), then we need to unset all
    of the session variables (`#2`), and next we need to destroy the session (`#3`).
    Lastly, we need to send the information back to Ext JS that the session has been
    destroyed (`#4` and `#5`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要恢复当前会话 (`#1`)，然后我们需要取消所有会话变量 (`#2`)，接下来我们需要销毁会话 (`#3`)。最后，我们需要将信息发送回
    Ext JS，表明会话已被销毁 (`#4` 和 `#5`)。
- en: Ajax request success versus failure
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ajax 请求成功与失败
- en: We have already taken care of the server-side code. Now, we need to go back
    to the Ext JS code and handle the response from the server. But first, we need
    to understand a very important concept that usually confuses most Ext JS developers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了服务器端代码。现在，我们需要回到 Ext JS 代码，并处理来自服务器的响应。但首先，我们需要理解一个通常让大多数 Ext JS 开发者感到困惑的重要概念。
- en: In [Chapter 3](ch03.html "Chapter 3. The Login Page"), *The Login Page*, we
    mentioned that the ways that the form submit and Ajax requests in Ext JS handle
    the *success x failure* are a little different, and this is what confuses most
    developers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。登录页面")，*登录页面* 中，我们提到 Ext JS 处理表单提交和 Ajax 请求的 *成功
    x 失败* 方式略有不同，这正是大多数开发者感到困惑的地方。
- en: 'The `Ext.Ajax` class is responsible for Ajax requests done by Ext JS. If we
    look at the documentation, this class has three events: `beforerequest`, `requestcomplete`,
    and `requestexception`, which are explained as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.Ajax` 类负责 Ext JS 执行的 Ajax 请求。如果我们查看文档，这个类有三个事件：`beforerequest`、`requestcomplete`
    和 `requestexception`，具体解释如下：'
- en: The event `beforerequest` is fired before the request
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件 `beforerequest` 在请求之前触发
- en: The event `requestcomplete` is fired when Ext JS is able to get a response from
    the server
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Ext JS 能够从服务器获取响应时，会触发事件 `requestcomplete`
- en: The `requestexception` event is fired when an HTTP error status is returned
    from the server
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器返回 HTTP 错误状态时，会触发 `requestexception` 事件
- en: Now, let's go back to the `Ext.Ajax.request` call. We can pass some options
    to the request, including the `url` property we want to connect to, parameters,
    and other options including the `success` and `failure` functions. Now, this is
    where the misunderstanding begins. Some developers understand that if the action
    happened successfully on the server, we usually return `success = true` from the
    server. If something goes wrong, we return `success = false`. Then, on the `success`
    function, `success = true` is handled, and on the `failure` function, `success
    = false` is handled. This is *wrong*, and it is not how Ext JS Ajax requests work;
    however, *that is exactly how form requests work* (as we learned in [Chapter 3](ch03.html
    "Chapter 3. The Login Page"), *The Login Page*). See how it gets confusing?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `Ext.Ajax.request` 调用。我们可以向请求传递一些选项，包括我们想要连接的 `url` 属性、参数以及其他选项，包括
    `success` 和 `failure` 函数。现在，误解就从这里开始了。一些开发者理解，如果服务器上的操作成功执行，我们通常从服务器返回 `success
    = true`。如果出现问题，我们返回 `success = false`。然后，在 `success` 函数中处理 `success = true`，在
    `failure` 函数中处理 `success = false`。这是 *错误的*，并且这与 Ext JS Ajax 请求的工作方式不符；然而，*这正是表单请求的工作方式*（正如我们在
    [第 3 章](ch03.html "第 3 章。登录页面")，*登录页面* 中所学的）。看看它如何变得混乱？
- en: For Ext JS Ajax requests, `success` is when the server returns a response (`success`
    `true` or `false`; it does not matter), and `failure` is when the server returns
    an HTTP error status. This means that if the server was able to return a response,
    we will handle this response on the `success` function (and we will need to handle
    it whether the `success` information is `true` or `false`), and on the `failure`
    message, we need to inform the user that something went wrong and the user should
    contact the system administrator.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ext JS Ajax请求，`success`是指服务器返回响应（`success` `true`或`false`；这并不重要），而`failure`是指服务器返回HTTP错误状态。这意味着如果服务器能够返回响应，我们将在`success`函数中处理这个响应（无论`success`信息是`true`还是`false`），在`failure`消息中，我们需要通知用户出了问题，用户应联系系统管理员。
- en: 'We will implement the `failure` callback function first. So, inside the `ViewController`
    class, we will add the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现`failure`回调函数。因此，在`ViewController`类中，我们将添加以下代码：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What we are going to do is display an alert to the user with an error icon and
    an **OK** button with the HTTP status error information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要执行的操作是向用户显示一个带有错误图标和**确定**按钮的警告框，并包含HTTP状态错误信息。
- en: 'To reproduce an error so the `requestexception` event can be fired, we can
    rename the `logout.php` file to something else (for example, `logout_.php`) only
    for testing purposes. And then, we can execute the code, and we will have the
    following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重现错误以便触发`requestexception`事件，我们可以在测试目的下将`logout.php`文件重命名为其他名称（例如，`logout_.php`）。然后，我们执行代码，将得到以下输出：
- en: '![Ajax request success versus failure](img/0457OT_04_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Ajax请求成功与失败对比](img/0457OT_04_04.jpg)'
- en: And this is all we need for the `failure` function. Note that we are reusing
    the `Packt.util.Util` class that we developed in [Chapter 3](ch03.html "Chapter 3. The
    Login Page"), *The Login Page*, in this chapter again! See how it is nice to reuse
    code?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`failure`函数所需的所有内容。请注意，我们正在重用我们在[第3章](ch03.html "第3章。登录页面")中开发的`Packt.util.Util`类，在本章中再次使用！看看重用代码有多方便？
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are reusing code and saving some lines of duplicated code. We are also creating
    a pattern of how to handle a few things in our project. This is very important
    when working in a project, especially when working in a team. This way, the project
    will look like a single person and not that multiple people developed it, which
    is really good. This is also a best practice to be followed. Reusing code is also
    part of what is called *minimizing the payload size*, which is one of the best
    practices while developing with JavaScript and also a concern of web development.
    To learn more about this, please visit [https://developers.google.com/speed/docs/best-practices/payload](https://developers.google.com/speed/docs/best-practices/payload).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重用代码并节省了一些重复的代码行。我们还在项目中创建了一种处理一些事情的模式。这在项目中工作尤其重要，尤其是在团队中工作。这样，项目看起来就像是一个人开发的，而不是多个人开发的，这非常好。这也是一个需要遵循的最佳实践。重用代码也是所谓的*最小化有效载荷大小*的一部分，这是使用JavaScript开发时的一个最佳实践，也是Web开发的一个关注点。要了解更多信息，请访问[https://developers.google.com/speed/docs/best-practices/payload](https://developers.google.com/speed/docs/best-practices/payload)。
- en: 'To make the code work, remove the following code from the `MainController`
    class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码正常工作，请从`MainController`类中移除以下代码：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write the following code in the preceding code''s position:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码的位置编写以下代码：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s focus on the `success` callback function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于`success`回调函数：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first thing we need to do is decode the JSON message (`#1`) that we received
    from the server. If we log the `conn` parameter sent to the `success` function
    (`console.log(conn)`), this will be the output we will get on the console:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是解码从服务器接收到的JSON消息（`#1`）。如果我们记录发送到`success`函数的`conn`参数（`console.log(conn)`），我们将在控制台得到以下输出：
- en: '![Ajax request success versus failure](img/0457OT_04_05.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Ajax请求成功与失败对比](img/0457OT_04_05.jpg)'
- en: The `conn.responseText` property is where the information we want to retrieve
    is present, the `success` and `msg` values. Recall that in [Chapter 3](ch03.html
    "Chapter 3. The Login Page"), *The Login Page*, we discussed the possibility of
    `responseText` containing an exception other than the JSON we are expecting. So,
    for this reason, we are going to reuse the `decodeJSON` function we created (`#1`)
    so that we can properly handle any results.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要检索的信息位于`conn.responseText`属性中，即`success`和`msg`值。回想一下，在[第3章](ch03.html "第3章。登录页面")中，我们讨论了`responseText`可能包含除我们期望的JSON以外的异常的可能性。因此，出于这个原因，我们将重用我们创建的`decodeJSON`函数（`#1`），以便我们可以正确处理任何结果。
- en: In the case of `success` (`#2`), we are going to `destroy` the `Main` class
    (`#3`), which is our Viewport (this is good to release the browser's memory and
    make the objects available for the JavaScript garbage collector). As the Viewport
    contains all the other components of our application, it is going to destroy them
    as well. Then, we will reload the application displaying the **Login** screen
    again (`#4`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`success`（`#2`）的情况下，我们将`destroy``Main`类（`#3`），即我们的Viewport（这样做可以释放浏览器的内存，并使对象可供JavaScript垃圾回收器回收）。由于Viewport包含我们应用程序的所有其他组件，它将销毁它们。然后，我们将重新加载应用程序，再次显示**登录**屏幕（`#4`）。
- en: If `success` is `false` (or any error occurred), we will display an error alert
    with the error message (`#5`).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`success`为`false`（或发生任何错误），我们将显示一个带有错误消息的错误警报（`#5`）。
- en: Client-side activity monitor
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端活动监控
- en: Let's enhance our application a little bit more. It is very important to let
    the users know that web applications have a timeout and they cannot leave it open
    all day long—mainly for security reasons. Server-side languages also have a timeout.
    Once the user is logged in, the server will not be available forever. This is
    for security reasons. That is why we need to add this capability to our application
    as well.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步增强我们的应用程序。让用户知道网络应用程序有超时，他们不能整天都让它开着——主要是出于安全考虑。服务器端语言也有超时。一旦用户登录，服务器将不会永远可用。这也是出于安全考虑。这就是为什么我们需要将这种功能添加到我们的应用程序中。
- en: We are going to use a plugin to do this. The plugin is called `Packt.util.SessionMonitor`
    and is based on the Activity Monitor plugin from the Sencha Market ([https://market.sencha.com/extensions/extjs-activity-monitor](https://market.sencha.com/extensions/extjs-activity-monitor)).
    After an interval (a default of 15 minutes of inactivity), the plugin will display
    a message to the user asking whether the user wants to keep the session alive.
    If yes, then it will send an Ajax request to the server to keep the server session
    alive. If the user does not do anything after the message is displayed for 60
    seconds, the application will logout automatically.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个插件来完成这个任务。这个插件叫做`Packt.util.SessionMonitor`，它基于Sencha Market（[https://market.sencha.com/extensions/extjs-activity-monitor](https://market.sencha.com/extensions/extjs-activity-monitor)）的活动监控插件。在一段时间（默认为15分钟的空闲时间）后，插件将向用户显示一条消息，询问用户是否希望保持会话活跃。如果用户选择是，那么它将向服务器发送一个Ajax请求以保持服务器会话活跃。如果用户在消息显示60秒后没有任何操作，应用程序将自动注销。
- en: You can get the source code of this plugin from [https://github.com/loiane/masteringextjs/blob/master/app/util/SessionMonitor.js](https://github.com/loiane/masteringextjs/blob/master/app/util/SessionMonitor.js).
    It works in Ext JS 4 and Ext JS 5.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/loiane/masteringextjs/blob/master/app/util/SessionMonitor.js](https://github.com/loiane/masteringextjs/blob/master/app/util/SessionMonitor.js)获取此插件的源代码。它在Ext
    JS 4和Ext JS 5中工作。
- en: At line *53* inside `Ext.ComponentQuery.query` at the preceding URL, we will
    change the `logout` button selector to `button#logout`, which is the selector
    we have for our `logout` button (that is why we created `itemId` for the `logout`
    button).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个URL中的`Ext.ComponentQuery.query`的第*53*行，我们将更改`logout`按钮选择器为`button#logout`，这是我们为`logout`按钮创建的选择器（这就是为什么我们为`logout`按钮创建了`itemId`）。
- en: Also, we will change the `url` property of the Ajax request on line *42* to
    `php/sessionAlive.php` at the preceding URL.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将更改第*42*行Ajax请求的`url`属性，将其更改为前一个URL中的`php/sessionAlive.php`。
- en: If we want to change the inactivity interval, we only need to change the `maxInactive`
    configuration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要更改非活动间隔，我们只需要更改`maxInactive`配置。
- en: 'To start monitoring the session, we only need to add this line of code inside
    the `onLoginSuccess` method of `LoginController` right after we instantiate the
    `Main` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始监控会话，我们只需要在`LoginController`的`onLoginSuccess`方法中添加这一行代码，在我们实例化`Main`类之后立即进行：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We cannot forget to add `'Packt.util.SessionMonitor`' to `requires` in `LoginController`
    as well.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忘记在 `LoginController` 中也将 `'Packt.util.SessionMonitor'` 添加到 `requires` 中。
- en: 'In the `php/sessionAlive.php` file, we will have the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `php/sessionAlive.php` 文件中，我们将有以下的代码：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That is only to keep the server session alive and also to reset the session
    timer back to 15 minutes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了保持服务器会话活跃，并且将会话计时器重置为15分钟。
- en: 'If we run this code and wait for the inactivity time (15 minutes—of course
    we can change the `maxInactive` parameter to wait for less time), we will see
    a message like this one:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码并等待不活动时间（15分钟——当然我们可以将 `maxInactive` 参数改为等待更短的时间），我们将看到如下信息：
- en: '![Client-side activity monitor](img/0457OT_04_06.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![客户端活动监控器](img/0457OT_04_06.jpg)'
- en: Ext JS does not provide this capability natively. But as we can see, it is very
    easy to implement, and we can reuse this plugin for all Ext JS projects that we
    work on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 并没有提供这个功能的原生支持。但是，正如我们所看到的，实现它非常简单，我们可以将这个插件重用于我们正在工作的所有 Ext JS 项目中。
- en: The multilingual capability
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言功能
- en: 'Sometimes you want to ship the project or product that you are working on overseas,
    and so having the translation capability is very important. After all, not everyone
    understands or speaks the same language that you do. And this is what we are going
    to implement in this topic: a multilingual component that we can use to translate
    the labels of this project. So at the end of this topic, this is going to be our
    output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要将你正在海外工作的项目或产品发送出去，因此拥有翻译功能非常重要。毕竟，并不是每个人都理解或说与你相同的语言。这正是我们将在这个主题中要实现的内容：一个多语言组件，我们可以用它来翻译这个项目的标签。所以，在这个主题的结尾，这将是我们输出的结果：
- en: '![The multilingual capability](img/0457OT_04_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![多语言功能](img/0457OT_04_07.jpg)'
- en: The idea is to store the user language preference locally, so the next time
    the user loads the application, the preferred language will be automatically set.
    And when the user changes the language, the application needs to be reloaded,
    so the new translations can be loaded into the memory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将用户的语言偏好本地存储，这样当用户下次加载应用程序时，首选语言将自动设置。并且当用户更改语言时，应用程序需要重新加载，以便将新的翻译加载到内存中。
- en: Creating the change language component
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建更改语言组件
- en: If we take a look at the screenshot we showed at the beginning of this topic,
    we can notice that the multilingual component is a button, and when we click on
    the arrow, a menu pops up with the available languages.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这个主题开头展示的截图，我们可以注意到多语言组件是一个按钮，当我们点击箭头时，会弹出一个包含可用语言的菜单。
- en: The button with the arrow is a split button component, which has a Menu, and
    each language option is a Menu Item of the Menu. So, let's go ahead and create
    a new class named `Packt.view.locale.Translation` containing the characteristics
    we described.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 带有箭头的按钮是一个分割按钮组件，它有一个菜单，每个语言选项都是菜单的一个菜单项。所以，让我们继续创建一个名为 `Packt.view.locale.Translation`
    的新类，包含我们描述的特性。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whenever we name a `View` class (also known as Ext JS widgets or components),
    it is nice to give a name that can quickly remind us what the class does. For
    example, by naming the class `locale.Translation`, we quickly know that the class
    provides capabilities localizing the application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们命名一个 `View` 类（也称为 Ext JS 小部件或组件）时，给出一个可以快速提醒我们该类做什么的名字是很好的。例如，通过将类命名为 `locale.Translation`，我们可以快速知道这个类提供了本地化应用程序的能力。
- en: 'We need to create a new file named `Translation.js` under the `app/view/locale`
    folder with the following code inside it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `app/view/locale` 文件夹下创建一个名为 `Translation.js` 的新文件，并在其中包含以下代码：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, the class that we created is extending from the split button class (`#1`).
    A split button class is one that provides a built-in drop-down arrow that can
    fire an event separately from the default click event of the button. Typically,
    this would be used to display a drop-down menu that provides additional options
    to the primary button action. And we are also assigning the `xtype` class to this
    class (`#2`) that we used to instantiate it in the `Header` class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建的类是从分割按钮类（`#1`）扩展而来的。分割按钮类是一种提供内置下拉箭头的类，它可以独立于按钮的默认点击事件触发事件。通常，这会被用来显示一个下拉菜单，为主要的按钮操作提供额外的选项。我们也将
    `xtype` 类分配给这个类（`#2`），我们在 `Header` 类中用它来实例化它。
- en: 'Then, on `menu` (`#3`) configuration, we need to create an instance of the
    `menu` class (`#4`) followed by `menuitems` of the `menu` class, which are going
    to represent each locale option. So we have: an option to translate to `English`
    (`#5`)—and it will also show the American flag (`en`); an option to translate
    to `Spanish` (`#6`)—and it will also show the flag of Spain (`es`); and also an
    option to translate to `Portuguese` (`#7`)—and it will also display the flag of
    Brazil (`pt_BR`).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`menu`（`#3`）配置中，我们需要创建`menu`类的实例（`#4`），然后是`menu`类的`menuitems`，它们将代表每个区域选项。所以我们有：一个翻译成`英语`的选项（`#5`）——它还将显示美国国旗（`en`）；一个翻译成`西班牙语`的选项（`#6`）——它还将显示西班牙国旗（`es`）；还有一个翻译成`葡萄牙语`的选项（`#7`）——它还将显示巴西国旗（`pt_BR`）。
- en: We can add as many options as we need to. For each translate option, we only
    need to add new `menuitems` of the `menu` class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加我们需要的任何选项。对于每个翻译选项，我们只需要为`menu`类添加新的`menuitems`。
- en: Adding the CSS – country flags
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加CSS – 国家旗帜
- en: 'The next step now is to add the CSS for `iconCls`, which we used in the translation
    component of the application CSS. To keep our code more organized (and leave room
    to add more languages and more flag icons if needed), we are going to create a
    new file named `flagIcons.scss` inside the `sass/etc` folder with the following
    content:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步现在是要添加`iconCls`的CSS，我们在应用程序CSS的翻译组件中使用了它。为了使我们的代码更加有序（并为添加更多语言和更多旗帜图标留出空间），我们将在`sass/etc`文件夹内创建一个名为`flagIcons.scss`的新文件，其内容如下：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the name of the style (`pt_BR`, `en`, and `es`) is the same as the
    `iconCls` property we used for each `menuitem`. This is very important.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，样式的名称（`pt_BR`、`en`和`es`）与我们为每个`menuitem`使用的`iconCls`属性相同。这非常重要。
- en: 'Inside the `all.scss` file, we need to import this file we created. Add the
    following code on the second line (right after we imported the Font Awesome file):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`all.scss`文件中，我们需要导入我们创建的文件。在第二行添加以下代码（在我们导入Font Awesome文件之后）：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: But what about the icons? Font Awesome does not have flag icons. We are going
    to use the Flag set from FamFamFam ([http://www.famfamfam.com/](http://www.famfamfam.com/)),
    which are free to use for any purpose (*Creative Commons License*). Create the
    folder `flags` under the directory `resources/images/app`, and copy and paste
    the flag icons. You might need to rename them to comply with the names we are
    using in this example.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但图标怎么办？Font Awesome没有旗帜图标。我们将使用FamFamFam的旗帜集（[http://www.famfamfam.com/](http://www.famfamfam.com/）），这些图标可以免费用于任何目的（*Creative
    Commons License*）。在`resources/images/app`目录下创建一个名为`flags`的文件夹，并将旗帜图标复制粘贴进去。你可能需要将它们的名称更改为符合我们这个例子中使用的名称。
- en: Using the translation component
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用翻译组件
- en: 'Now, the `translation` component is ready (only what is going to be displayed
    to the user). We are going to use the `translation` component in two places of
    our project: on the **Login** screen and before the **Logout** button on `Header`
    (which is already in place).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`translation`组件已经准备好了（只显示给用户的内容）。我们将在项目的两个地方使用`translation`组件：在**登录**屏幕上，以及在`Header`上的**注销**按钮之前（它已经就位）。
- en: 'Let''s add it to the **Login** screen. Open the `Packt.view.login.Login` class
    again. On the toolbar, we will add it as the first item so that it can look exactly
    as we showed in the screenshot at the beginning of this topic:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到**登录**屏幕。再次打开`Packt.view.login.Login`类。在工具栏上，我们将将其作为第一个项目添加，以便它看起来与我们在这个主题开头所展示的截图完全一样：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We cannot forget to add the class to the `requires` declaration of the **Login**
    screen class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忘记将类添加到**登录**屏幕类的`requires`声明中：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we reload the application (do not forget to have `sencha app watch` executed
    on the terminal while we make all these changes), we are going to be able to see
    what we have developed until now.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新加载应用程序（在做出所有这些更改的同时，不要忘记在终端上执行`sencha app watch`），我们将能够看到到目前为止我们所开发的内容。
- en: Creating the multilingual files
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多语言文件
- en: 'We need to store the translations somewhere in our project. We are going to
    store the translations for each language on a JavaScript file inside the `resources/locale`
    folder. As we are going to use `iconCls` as the ID to load the translation files,
    we need to create three files: `en.js`, `es.js`, and `pt_BR.js`. Inside each file,
    we will create a JavaScript object named `translations`, and each attribute of
    this object will be a translation. All translation files must be the same; the
    only thing that will be different is the value of each attribute that will contain
    the translation.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的项目中某个地方存储翻译。我们打算在`resources/locale`文件夹内的JavaScript文件中存储每种语言的翻译。由于我们将使用`iconCls`作为ID来加载翻译文件，我们需要创建三个文件：`en.js`、`es.js`和`pt_BR.js`。在每个文件中，我们将创建一个名为`translations`的JavaScript对象，并且该对象的每个属性都将是一个翻译。所有翻译文件必须相同；唯一不同的是将包含翻译的每个属性的值。
- en: 'For example, the following code is for the `en.js` file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码是针对`en.js`文件的：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code is for `pt_BR.js`, which contains the Brazilian Portuguese
    translations:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是针对`pt_BR.js`的，其中包含巴西葡萄牙语的翻译：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following code is the `es.js` code, which contains the Spanish translations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`es.js`代码，其中包含西班牙语的翻译：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see, the files are the same; however, the translation is different.
    As the application grows, we will add more translations to it, and it is a good
    practice to maintain the files organized in the same way to facilitate changing
    any translation in the future.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，文件是相同的；然而，翻译是不同的。随着应用程序的增长，我们将向其中添加更多翻译，并且保持文件以相同的方式组织是一个好习惯，以便将来便于更改任何翻译。
- en: Applying the translation on the application's components
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在应用程序组件上应用翻译
- en: 'To apply the translations on the components that we have developed until now
    is very simple: we need to use the `translations` dictionary we created instead
    of the string that is going to represent the label.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要将翻译应用于我们至今开发的组件，非常简单：我们需要使用我们创建的`translations`字典来代替将要表示标签的字符串。
- en: For example, in the `Packt.view.view.Login` class, we have the title of the
    window, the `fieldLabel` of the `username` and `password`, and the text of the
    **Cancel** and **Submit** buttons. The labels are hardcoded, and we want to get
    the translation from the translation files.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`Packt.view.view.Login`类中，我们有关窗口的标题，`username`和`password`字段的`fieldLabel`，以及**取消**和**提交**按钮的文本。标签是硬编码的，我们希望从翻译文件中获取翻译。
- en: 'So, we need to replace the `title` of the :**Login** window with the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将**:Login**窗口的`title`替换为以下内容：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need to replace the `fieldLabel` of `username` `textfield` with the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`username` `textfield`的`fieldLabel`替换为以下内容：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We need to replace the `fieldLabel` of `password` `textfield` with the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`password` `textfield`的`fieldLabel`替换为以下内容：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We need to replace the `text` of the **Cancel** button with the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将**取消**按钮的`text`替换为以下内容：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to replace the `text` of the **Submit** button with the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将**提交**按钮的`text`替换为以下内容：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And so on. We can also apply the translation for the **Logout** button and also
    to the `CapsLockTooltip` class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。我们还可以将翻译应用于**注销**按钮和`CapsLockTooltip`类。
- en: HTML5 local storage
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML5本地存储
- en: Our idea for the `translate` component is to store the language preference of
    the user somewhere. We could use cookies for this, but what we want is very simple,
    and cookies are included with every HTTP request. We want to store this information
    for the long term and also use something that can be persisted beyond a page refresh
    or the fact that the user closed the browser. And the perfect option is to use
    local storage, one of the new features of HTML5.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`translate`组件的想法是将用户的语言偏好存储在某个地方。我们可以使用cookie来做这件事，但我们想要的非常简单，cookie包含在每个HTTP请求中。我们希望长期存储此信息，并使用可以持久化超过页面刷新或用户关闭浏览器的情况的东西。而完美的选择是使用HTML5的新特性之一——本地存储。
- en: Ext JS has support for local storage; it can be used with **LocalStorageProxy**,
    but we need something simpler, and using the HTML5 feature itself on the code
    is simpler. And it also demonstrates that we can use other APIs along with the
    Ext JS API.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS支持本地存储；它可以与**LocalStorageProxy**一起使用，但我们需要更简单的东西，直接在代码中使用HTML5功能会更简单。这也展示了我们可以与其他API一起使用Ext
    JS API。
- en: Local storage is not supported by every browser; it is only supported by IE
    8.0+, Firefox 3.5+, Safari 4.0+, Chrome 4.0+, Opera 10.5+, iPhone 2.0+, and Android
    2.0+. We will build a nice page warning the user to upgrade the browser later
    on in this book. We will also use other HTML5 features along with Ext JS in other
    screens as well. So, for now, we need to know that this code, which we will implement
    now, does not work on every browser.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储不是每个浏览器都支持的；它仅由IE 8.0+、Firefox 3.5+、Safari 4.0+、Chrome 4.0+、Opera 10.5+、iPhone
    2.0+ 和 Android 2.0+ 支持。我们将在本书稍后部分构建一个警告用户升级浏览器的页面。我们还将使用其他HTML5功能以及Ext JS在其他屏幕上。因此，现在我们需要知道，我们现在要实现的这个代码并不适用于每个浏览器。
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about HTML5 storage, please visit [http://diveintohtml5.info/storage.html](http://diveintohtml5.info/storage.html).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于HTML5存储的信息，请访问 [http://diveintohtml5.info/storage.html](http://diveintohtml5.info/storage.html)。
- en: 'We want this code to be loaded right before we instantiate the Ext JS application.
    So, for this reason, we are going to add it right before `Ext.define(''Packt.Application'',
    {` in the `app/Application.js` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这段代码在我们实例化Ext JS应用程序之前加载。因此，出于这个原因，我们将在 `app/Application.js` 文件中的 `Ext.define('Packt.Application',
    {` 之前添加它：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, first, we are going to verify that `localStorage` is available. If it is
    available, we are going to check whether there is an item named `user-lang` stored
    on `localStorage`; if not, English will be the default language. Even if `localStorage`
    is not available, English will be set as the default language.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们将验证 `localStorage` 是否可用。如果可用，我们将检查是否在 `localStorage` 上存储了一个名为 `user-lang`
    的项；如果没有，英语将是默认语言。即使 `localStorage` 不可用，英语也将被设置为默认语言。
- en: Then, we create a variable named `file` that is going to receive the path of
    the translation file that must be loaded by the application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为 `file` 的变量，该变量将接收必须由应用程序加载的翻译文件的路径。
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Ext JS has a class, `Ext.util.Format`, that contains a static method format
    that concatenates the string and the values passed as tokens, which in this case
    is `lang`. It is cleaner than doing manual string concatenation in JavaScript.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 有一个名为 `Ext.util.Format` 的类，其中包含一个静态方法 `format`，该方法将字符串和作为标记传递的值连接起来，在这种情况下是
    `lang`。这比在JavaScript中手动进行字符串连接要干净。
- en: After we have the `url` formatted, we are going to load it using `Ext.Loader`.
    The `loadScript` method loads the specified script URL and calls the supplied
    callbacks (if any). It accepts `onLoad` and `onError` callbacks. In our case,
    there is no need for a success callback (`onLoad`). If there is any error while
    loading the locale file, the application will not load, so the `onError` callback
    is interesting and needed in this case so that the user can contact support in
    the event of an error (try renaming the `en.js` file to simulate an error).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 `url` 格式化后，我们将使用 `Ext.Loader` 加载它。`loadScript` 方法加载指定的脚本URL，并调用提供的回调函数（如果有）。它接受
    `onLoad` 和 `onError` 回调函数。在我们的情况下，不需要成功回调（`onLoad`）。如果在加载区域文件时发生任何错误，应用程序将无法加载，因此
    `onError` 回调函数在这个情况下很有趣且是必需的，以便在发生错误时用户可以联系支持（尝试将 `en.js` 文件重命名以模拟错误）。
- en: To avoid creating global variables (since this is not a good JavaScript practice),
    we wrapped our code in a function. Therefore, we need to call the function (`#1`)
    right before `Ext.define('Packt.Application'`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免创建全局变量（因为这不是一个好的JavaScript实践），我们将我们的代码包装在一个函数中。因此，我们需要在 `Ext.define('Packt.Application'`
    之前调用这个函数（`#1`）。
- en: By the time our application is loaded, it will have all the translations available.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序加载完毕时，它将包含所有可用的翻译。
- en: Handling change language in real time
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时处理更改语言
- en: Now comes the final part of the code of the `translation` component. When the
    user selects a different language, we need to reload the application so that the
    `loadLocale` function is executed again and load the new language chosen by the
    user.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 `translation` 组件代码的最后一部分。当用户选择不同的语言时，我们需要重新加载应用程序，以便 `loadLocale` 函数再次执行并加载用户选择的新语言。
- en: 'To do so, we will create a new Controller in our application just to handle
    the translation component. The question here is: do we use MVC (which we will
    cover in the next chapter) or MVVM now? The answer depends on your personal preference.
    For this capability, we will continue using MVVM, or better, the ViewController,
    for a simple reason: both files (`TranslationController.js` and `Translation.js`)
    are located in the same directory (`app/view/locale`). And this means that it
    is easier to copy and paste this component to use it in other projects (we can
    copy the `locale` folder altogether).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在我们的应用程序中创建一个新的Controller，专门处理翻译组件。这里的问题是：我们现在使用MVC（我们将在下一章中介绍）还是MVVM？答案取决于您的个人喜好。为了这个功能，我们将继续使用MVVM，或者更确切地说，使用ViewController，原因很简单：这两个文件（`TranslationController.js`和`Translation.js`）都位于同一个目录（`app/view/locale`）中。这意味着将这个组件复制粘贴到其他项目中使用会更简单（我们可以整体复制`locale`文件夹）。
- en: 'So we need to create a new class named `Packt.view.locale.TranslationController`,
    and to create this class, we need to create a new file named `TranslationController.js`
    under the `app/view/locale` folder. In this controller, we will need to listen
    to two events: one fired by the `translation` component itself and the other one
    fired by `menuitems`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一个名为`Packt.view.locale.TranslationController`的新类，为了创建这个类，我们需要在`app/view/locale`文件夹下创建一个名为`TranslationController.js`的新文件。在这个控制器中，我们需要监听两个事件：一个由`translation`组件本身触发，另一个由`menuitems`触发：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s go back to the `Translation.js` file and add `TranslationController`
    as the ViewController so that we can start listening to the events:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`Translation.js`文件，并将`TranslationController`添加为ViewController，这样我们就可以开始监听事件：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The split button has two events, which are the `click` (fired because it is
    a button) and the `arrowclick` events, fired when the user clicks on the arrow.
    We are not interested in either event. Inside the split button, there is a `Menu`
    class with `menuitems`, and each `menuitem` represents a locale file. The `MenuItem`
    component also fires the `click` event when clicked on. So we can add the `click`
    listener to each `MenuItem`—or even better, add a `defaults` configuration to
    `menu`, as follows (which is going to be applied to all items):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 分割按钮有两个事件，即`click`（由于它是一个按钮而触发）和`arrowclick`事件，当用户点击箭头时触发。我们对这两个事件都不感兴趣。在分割按钮内部，有一个`Menu`类，其中包含`menuitems`，每个`menuitem`代表一个区域文件。`MenuItem`组件在点击时也会触发`click`事件。因此，我们可以为每个`MenuItem`添加`click`监听器——或者更好的是，为`menu`添加一个`defaults`配置，如下所示（这将应用于所有项目）：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we can go back to `TranslationController` and implement the `onMenuItemClick`
    method, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到`TranslationController`并实现`onMenuItemClick`方法，如下所示：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we will get the reference to the `translation` component (`#1`). Then,
    we will update the split button `iconCls` and `text` with `iconCls` and `text`
    of the selected Menu Item (`#2` and `#3`). Next, we will update the new language
    selected by the user on `localStorage` (`#4`), and finally, we will ask the browser
    to reload the application (`#5`).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将获取对`translation`组件的引用（`#1`）。然后，我们将更新分割按钮的`iconCls`和`text`属性，使其与所选菜单项的`iconCls`和`text`属性相同（`#2`和`#3`）。接下来，我们将更新用户在`localStorage`上选择的新语言（`#4`），最后，我们将要求浏览器重新加载应用程序（`#5`）。
- en: The early life of the ViewController
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ViewController的早期生活
- en: 'There is still one detail missing. When we load the application, the `translation`
    component does not have text or an icon configured. We also need to take care
    of this. We could listen to the `beforerender` or `render` events to update these
    two properties before the component is displayed to the user, but there is a very
    important detail: the ViewController is created very early in the component''s
    life cycle, and for this reason, it is not possible to listen to these events.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个细节需要注意。当加载应用程序时，`translation`组件没有配置文本或图标。我们还需要注意这一点。我们可以监听`beforerender`或`render`事件，在组件显示给用户之前更新这两个属性，但有一个非常重要的细节：ViewController在组件生命周期的早期就已经创建，因此无法监听这些事件。
- en: 'There are three methods that we can use that can execute some tasks during
    the key points of the component''s life cycle according to the Sencha documentation:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Sencha文档，我们可以使用三种方法在组件生命周期的关键点执行一些任务：
- en: '`beforeInit`: This method can be overridden in order to operate on the view
    prior to its `initComponent` method being called. This method is called immediately
    after the controller is created, which occurs during `initConfig` called from
    the component constructor.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeInit`：可以通过覆盖此方法来在调用 `initComponent` 方法之前对视图进行操作。此方法在控制器创建后立即调用，发生在从组件构造函数中调用的
    `initConfig` 期间。'
- en: '`Init`: This is called shortly after `initComponent` has been called on the
    view. This is the typical time to perform initialization for the controller now
    that the view is initialized.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init`：在调用 `initComponent` 后不久在视图中调用。这是为控制器执行初始化的典型时间，因为视图已初始化。'
- en: '`initViewModel`: This is called when the view''s ViewModel is created (if one
    is defined).'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initViewModel`：当视图的 ViewModel 被创建时（如果已定义），将调用此方法。'
- en: 'As we want the `translation` component to have `iconCls` and `text` when it
    is rendered, we can use the `init` method in `TranslationController` to execute
    this logic for us:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望 `translation` 组件在渲染时具有 `iconCls` 和 `text`，因此我们可以使用 `TranslationController`
    中的 `init` 方法来为我们执行此逻辑：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, we will verify that there is `localStorage`, and if positive, we will
    get the language that was stored. If there is no `localStorage`, or the preferred
    language was not stored yet (the first time the user uses the application or the
    user has not changed the language yet), the default language will be `English`.
    Then, we will set the `iconCls` of the split button as the flag of the selected
    language (`#1`).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将验证是否存在 `localStorage`，如果存在，我们将获取存储的语言。如果没有 `localStorage`，或者首选语言尚未存储（用户首次使用应用程序或用户尚未更改语言），则默认语言为
    `English`。然后，我们将设置分割按钮的 `iconCls` 为所选语言的标志（`#1`）。
- en: If the selected language is English, we will set the split button `text` as
    `"English"` (`#2`), and if the selected language is Spanish, we will set the split
    button `text` as `"Español"` (`#8`); otherwise, we will set the text as `"Português"`
    (Portuguese).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择的语言是英语，我们将设置分割按钮的 `text` 为 `"English"` (`#2`)，如果选择的语言是西班牙语，我们将设置分割按钮的 `text`
    为 `"Español"` (`#8`)；否则，我们将设置文本为 `"Português"`（葡萄牙语）。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This controller is also available in the MVC architecture. You can take a look
    at the differences between the MVC and MVVM implementation at [http://goo.gl/ajaIao](http://goo.gl/ajaIao).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器也适用于 MVC 架构。您可以查看 MVC 和 MVVM 实现之间的差异，请参阅[http://goo.gl/ajaIao](http://goo.gl/ajaIao)。
- en: 'If we execute the application, we can change the preferred language and see
    that the result is a translated application, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们可以更改首选语言，并看到结果是已翻译的应用程序，如下所示：
- en: '![The early life of the ViewController](img/0457OT_04_08.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![ViewController 的早期生活](img/0457OT_04_08.jpg)'
- en: Using locale files to translate Ext JS
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用区域文件翻译 Ext JS
- en: 'As usual, there is one last thing missing. We are translating only the labels
    of the application. Form errors and other messages that are part of the Ext JS
    API are not translated. Ext JS provides locale file support. All we need to do
    is add the JavaScript locale file on the HTML page. To do so, we are going to
    add the following code inside the `loadLocale` function in the `Application.js`
    file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，还有一件事尚未完成。我们只翻译了应用程序的标签。表单错误和其他作为 Ext JS API 部分的消息没有翻译。Ext JS 提供了区域文件支持。我们所需做的只是将
    JavaScript 区域文件添加到 HTML 页面中。为此，我们将在 `Application.js` 文件中的 `loadLocale` 函数内添加以下代码：
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The name of `iconCls` used for the flag and translation files (`en.js`, `es,js`,
    `pt_BR.js`) are due to the name of the locale files used by Sencha. So make sure
    you verify what name Sencha is using before naming your own file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 用于标志和翻译文件（`en.js`、`es.js`、`pt_BR.js`）的 `iconCls` 名称是由于 Sencha 使用的区域文件名称。因此，在命名自己的文件之前，请确保您已验证
    Sencha 使用的名称。
- en: 'And now, if we try to execute the application again, we will be able to see
    that all the Ext JS messages will also be translated. For example, if we change
    the translation to Spanish, the form validation errors will also be in Spanish:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次尝试运行应用程序，我们将能够看到所有 Ext JS 消息也将被翻译。例如，如果我们更改翻译为西班牙语，表单验证错误也将是西班牙语：
- en: '![Using locale files to translate Ext JS](img/0457OT_04_09.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![使用区域文件翻译 Ext JS](img/0457OT_04_09.jpg)'
- en: Now, the locale support of the application is completed!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序的区域支持已完成！
- en: Tip
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might want to review the label size (use the `labelWidth` configuration
    to change its default size of 100 pixels) and the message targets for the screens
    after applying locale support. For example, the label **Contraseña** needs more
    width in the screen than **Password**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要在应用本地化支持后检查标签大小（使用`labelWidth`配置来更改其默认的100像素大小）和屏幕的消息目标。例如，标签**Contraseña**在屏幕上比**Password**需要更多的宽度。
- en: After applying the locale, change `labelWidth` to `70` inside the `Login` class.
    You can change `msgTarget` to '`side`' or increase the `height` of the window
    so that the form validation messages can be properly displayed in other languages
    as well.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用本地化后，将`Login`类中的`labelWidth`更改为`70`。你可以将`msgTarget`更改为`'side'`或增加窗口的`height`，以便在运行时以其他语言正确显示表单验证消息。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered how to implement the base of the application we are going to implement
    throughout this book using the Border layout, and you learned how to implement
    a **Logout** button (on the Ext JS side and also on the server side). We also
    covered the Client Activity Monitor and Session Timeout capabilities.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了如何使用Border布局实现本书将要实现的应用程序的基础，你学习了如何实现一个**注销**按钮（在Ext JS端和服务器端）。我们还介绍了客户端活动监控和会话超时功能。
- en: And finally, you learned how to build a `translation` component using HTML5
    features along with Ext JS, which is able to translate all the labels of the application
    and also change the preferred language at runtime. You also learned how to use
    the Ext JS locale support used to translate the framework's messages and labels.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了如何使用HTML5功能和Ext JS构建一个`翻译`组件，该组件能够翻译应用程序的所有标签，并在运行时更改首选语言。你还学习了如何使用Ext
    JS的本地化支持来翻译框架的消息和标签。
- en: We made a great advance in this chapter regarding the implementation of our
    application. We created new files and our application is growing. We will continue
    to create more files and components in the next chapters of this book.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在应用程序的实现方面取得了重大进展。我们创建了新的文件，我们的应用程序正在增长。在本书的下一章中，我们将继续创建更多的文件和组件。
- en: In the next chapter, we will learn how to build a dynamic menu using Accordion
    panels and trees.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用折叠面板和树构建一个动态菜单。
