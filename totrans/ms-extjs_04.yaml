- en: Chapter 4. The Logout and Multilingual Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to implement the multilingual capability of the
    system. This feature will allow the system to display the translation of the labels
    according to the language selected by the user (using some HTML5 features as well).
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how to implement the logout capability so that the user can
    end the session, and also for security reasons, we will learn how to implement
    a session timeout warning for the user, in the case of inactivity (not using the
    mouse or keyboard for a while).
  prefs: []
  type: TYPE_NORMAL
- en: Also, after the user is authenticated, we need to display the application. In
    this chapter, we will learn how to implement the base of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The base of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logout capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity monitoring and session timeout warnings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring the application to receive the multilingual capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the change language component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the change language component at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we cover all the application capabilities, we will cover some Ext JS components
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The base of the application – view/main/Main.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we implemented the `success` function in the **Submit** button listener
    on the login controller, we mentioned the `Packt.view.main.Main` class. We are
    going to reuse this class (it was automatically created by Sencha Cmd when we
    created the project) as the base of our application. Before we start with the
    hands-on approach, let''s take a look at what is going to be the result of the
    application by the end of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The base of the application – view/main/Main.js](img/0457OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Viewport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever we construct an application entirely with Ext JS (because we do have
    the option of using a single component rendered to a `<div>` tag if we want to,
    in a manner similar to what is done in jQuery), we need to use a component that
    is going to be the base of the application. This component is the Viewport. The
    Viewport is a specialized container representing the viewable application area
    (the browser viewport). The Viewport renders itself to the document body, and
    automatically sizes itself to the size of the browser viewport and manages window
    resizing. There might only be one Viewport created in an application.
  prefs: []
  type: TYPE_NORMAL
- en: Before we create the Viewport, if we click on the **Submit** button of the **Login**
    screen, we will see a grayish screen, even though we are calling `Ext.create('Packt.view.main.Main');`
    inside the `LoginController` class. This means `Packt.view.main.Main` is being
    created, but nothing is being displayed on the screen. This is because the `Main`
    class is not being rendered as a child of any component, and it is also not being
    rendered to the HTML body. But we are going to change this behavior by changing
    it to a Viewport.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app/view/main/Main.js` file. In the second line of code, you will
    find the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Main` class that was created by Sencha Cmd is extending the `Container`
    component. The `Container` component is the simplest container component in the
    Ext JS API. It supports adding and removing items to it, and it is also the parent
    class to many other components, such as Panel, Window, and TabPanel. We are going
    to change `Ext.container.Container` to `Ext.container.Viewport` so that we can
    use the `Main` class as the base class of our application. Save the code, refresh
    the browser, and give it a try. The next time you click on the **Submit** button,
    you should see the original code created by Sencha Cmd after you are logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Viewport plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extending the `Ext.container.Viewport` class is the classic and traditional
    way of having a Viewport in Ext JS applications. Ext JS 5 introduces a new way
    of using a Viewport by using the Viewport plugin (`Ext.plugin.Viewport`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about Ext JS plugins, please read [http://www.sencha.com/blog/advanced-plugin-development-with-ext-js/](http://www.sencha.com/blog/advanced-plugin-development-with-ext-js/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the plugin, first roll back the changes we made in the preceding topic
    (the `Main` class will continue to extend `Ext.container.Container`) and add the
    following code after the `extend` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the `plugins` configuration has the same result as extending the `Viewport`
    class. This plugin transforms any component into a Viewport, making it fill all
    the available space in the browser. The advantage of this plugin is that we can
    still reuse this class in other contexts, for example, inside a window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that the **ptype** (plugin type) of the Viewport plugin is **viewport**
    by accessing the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Viewport plugin](img/0457OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always remember that the documentation needs to be your best friend while developing
    Ext JS applications!
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the main screen using the Border layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we learned in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"),
    *Sencha Ext JS Overview*, the Border layout can be used to organize the children
    of a parent container into five regions: north, south, west, east, and center.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The center region is the only one that is mandatory to have. The other ones
    are optional. Looking at the following screenshot, we can see that we are going
    to organize our main screen into four regions: **center**, **north**, **south**,
    and **west**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing the main screen using the Border layout](img/0457OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the `items` configuration of the `Main` class (you can
    replace the code that was generated by Sencha Cmd with the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the `center` region, we have `mainpanel` (`#1`). In [Chapter 5](ch05.html
    "Chapter 5. Advanced Dynamic Menu"), *Advanced Dynamic Menu*, we are going to
    create a dynamic menu that will give the options to the user to open the screens
    the user is entitled to. Each screen the user opens will be created as a tab in
    `mainpanel`. We will create it in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: In the `north` region, we have the header (`#2`), and in the `south` region,
    we have the footer (`#3`). We will also work on them in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: In the `west` region, we have `container` (`#4`), which we will use in the next
    chapter to render the dynamic menu. For now, we will leave the space reserved
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that for the `center` region, we do not need to specify
    `width` or `height`. The container that is being rendered in the `center` region
    is going to use whatever space is left in the Border layout. For the `south` and
    `north` regions, you are required to specify `height`. We will do this when we
    create `Header` and `Footer`. The `south` and `north` regions are going to use
    all the available horizontal space that is available in the screen—limited by
    `height`—which is why `width` is not required. For the `west` and `east` regions,
    it is required to specify `width`. As we are only using the `west` region, we
    specified `200` pixels (`#4`).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the main TabPanel component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to create the `mainpanel` component that we are using in the `center`
    region of the `Main` class. To do so, we are going to create a new file named
    `Panel.js` inside the `app/view/main` folder, and we are going to write the following
    code inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we will start with the name of the class. The class name convention
    is *app namespace + folder* (inside `app`) *+ filename* (without the `.js` extension),
    which will result in `Packt.view.main.Panel` (`#1`). The `main.Panel` class is
    extending the TabPanel component (`#2`).
  prefs: []
  type: TYPE_NORMAL
- en: In line `#3`, we have `xtype` of the `main.Panel` class. This is the `xytpe`
    class we used to instantiate this class inside the `Main` class. In line `#4`,
    we have the `activeTab` configuration. When we set a tab to active, the TabPanel
    component is going to display the contents of the tab, and it is also going to
    highlight it.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"),
    *Sencha Ext JS Overview*, the TabPanel component is a container that has tabs
    as children organized by the Card layout, which means that the user will see the
    content of one active tab at a time. Each child declared inside the `items` configuration
    is an instance of the `tab` class (`Ext.tab.Tab`), and it can be of any type as
    we have in line `#5`. So as not to display an empty screen, we are displaying
    a `'Home'` tab (`#8`) that is a panel (`#5`), which means it can have toolbars
    and other components inside it as well. This `Home` tab cannot be closed (`#6`);
    otherwise, the user will see a blank space in the middle of the main screen, and
    we do not want that. We are also setting a Font Awesome icon in the format of
    `home` in line `#7` for it to look prettier.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this **Home** tab to display announcements or to behave like a dashboard,
    where the user will see a summary of all the pending tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the footer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step is creating the footer of the main screen. We are going to create
    a new file named `Footer.js` inside `app/view/main` with the following code inside
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Footer` is going to extend from the `Container` class (`#1`). The `Container`
    class is the lightest component that we can create that can have items inside
    it. We should give preference to use it whenever possible. We will discuss this
    in greater detail later. Then, we declare the `xtype` class (`#2`), which is the
    alias we are using to instantiate this class in the `Main` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always remember that the convention for aliases (`xtype`) is to use all letters
    in lowercase. If you would like to, you can separate words with "`-`" (a hyphen)
    depending on your personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the first image of this chapter, we will note that the footer
    has a top border. We add a style on line `#3` that adds this border to the footer.
    The `cls` configuration allows us to add extra CSS to a component in Ext JS. It
    is available to all components. We will add the style to our CSS in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: As we are declaring `Footer` in the south region of the `Main` class, you are
    required to set the `height` parameter. We can do this inside the `Footer` class
    or inside the `Main` class when declaring the south region. In this case, we are
    setting it inside the `Footer` class (`#4`).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Footer` class, we want to have only one component in this example,
    which is text (you can use a copyright message), and we are going to display it
    using HTML. We also want this text to be centered. For this reason, we can use
    the `center` layout (`#5`). To use the `center` layout, the parent container needs
    to have only one child component (because it inherits from the `fit` layout, which
    only supports a single child as well). It is also required to declare the `width`
    parameter of the child component (`#7`); in this case, the text we are going to
    display is approximately `350` pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Ext JS 4, the Center layout was used as a UX plugin shipped with the Ext
    JS SDK. In Ext JS 5, this layout was promoted to the native API, but it kept backwards
    compatibility. In the layout configuration, you can use `center` (introduced in
    Ext JS 5) and also keep using `ux.center` (from Ext JS 4) if you are migrating
    an application from Ext JS 4 to 5.
  prefs: []
  type: TYPE_NORMAL
- en: To render the HTML, we are going to use the lightest and simplest component
    as possible, which is `component` (`#6`). As we also want to apply some CSS to
    our text, we are going to use the `componentCls` (`#8`) class, which is a CSS
    class that is added to a component's root-level element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is no text declared anywhere inside the `Footer` class. Instead,
    we are binding the `html` configuration to a value (`#9`) named `footer`. This
    is also part of the new MVVM architecture that we are also going to use in this
    chapter. In the preceding chapter, we only used the `View` and `ViewController`
    classes for the login capability. In this chapter, we are going to use the complete
    feature: View, ViewController, and ViewModel from the MVVM architecture (Sencha
    Cmd already generated these classes when we created the project, so we better
    reuse them!). For now, keep in mind that this is part of the ModelView binding
    that we will dive into in the next topic.'
  prefs: []
  type: TYPE_NORMAL
- en: A quick word about modular CSS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's discuss another way of adding CSS to our application. We already know
    that the best practice to add CSS to our application is to add using Sass inside
    the `sass/etc` folder as we did in the previous examples. However, there are some
    styles that we create to apply to specific components, and we are not going to
    reuse them throughout the application. Instead of adding these CSS styles to our
    `all.scss` file and having a big file that can give us a headache later if we
    need to maintain it, we can use a more modular CSS approach to create specific
    CSS for our Ext JS views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `sass` folder, create a new folder named `src` (if it has not been
    created by Sencha Cmd automatically), and inside `src`, create a new folder named
    `view`. Inside `view`, create a new folder named `main`. We will have the directory
    `sass/src/view/main`. Inside this directory, create a file named `Footer.scss`
    with the following content inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In line `#1`, we declare a Sass variable with a bluish color (the same blue
    color as the `TabPanel` background). We are reusing this variable in lines `#2`
    and `#3` in the styles we created to use in our `Footer` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In line `#3`, we use the `darken` function from Sass, which accepts a color
    and a number from 0-100, the percentage to which we want to make the color darker.
    For more information, please refer to the Sass documentation at [http://goo.gl/JsAnVz](http://goo.gl/JsAnVz).
  prefs: []
  type: TYPE_NORMAL
- en: The `view/main/Footer.scss` file has the same path as the `view/main/Footer.js`
    file. Note that this way, it is easier to maintain the styles specific to the
    `Footer` class. We will do the same for the `Header` class in the next topic.
    We separate the CSS into modules for it to be easier to read and maintain, and
    when we do the build, all the CSS will be concatenated into a single production
    CSS file—this is called modular CSS. See, developing applications with Ext JS
    is not all about Ext JS; we can apply the knowledge from other frontend technologies
    as well!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Header class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we are going to create the `Header` class. The `Header` class contains
    the logo of the application along with the application name, the dropdown that
    offers the translation capability, and the **Logout** button. To create the header,
    we are going to create a new file, `Header.js`, inside the `app/view/main` folder
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our `Header` class is going to extend the `Toolbar` class (`#1`). The `Toolbar`
    class is usually used inside panels and its subclasses (grid, form, tree) to organize
    buttons, but it can also be used to hold other components as we are going to do
    in this example. We will cover more about toolbars in other chapters as well.
    We are also declaring an `xtype` class for the `Header` class that we are making
    a reference to in the `Main` class (`#2`).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we use an `xtype` class created by ourselves, Ext JS does not understand
    what component we are trying to instantiate. For this reason, we require the class
    we are referring to. For example, in line `#3`, we reference the class of the
    translation component we are instantiating using its `xtype` class in line `#10`.
    We are going to develop this component later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in the `Main` class, we did not use `requires` yet. We need to go
    back and add the required `Header`, `Footer`, and `main.Panel` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ui` configuration allows us to use a specific theme for a component. The
    `Toolbar` component has the configuration `ui: ''footer''` (`#4`), which gives
    the toolbar a transparent background. The `footer` value is included in the Ext
    JS SDK, and it makes the toolbar transparent. We are going to create some custom
    `ui` configurations when we discuss themes later in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: The two first children items of the `Header` class are the icon (`#5`) and the
    application name. For the icon, we are going to use Font Awesome to display an
    icon in the format of a desktop. For the title of the application, we will use
    the same approach we used in the case of the `Footer` class. We are also using
    a `componentCls` configuration (`#7`) to style it. We get both values (icon-`#6`
    and application name-`#8`) from the ViewModel, which we will cover in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: The next item is a toolbar fill (`#9`). This component will align the `translation`
    (`#10`) and `logout` buttons (`#13`) to the right, filling the `Toolbar` class
    with space in the middle (between the application title and the buttons).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of `{ xtype: ''tbfill'' }`, we could also use `''->''` as a shortcut.'
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `logout` button declared on line `#12`. We are going to assign
    `itemId` so that we can reference this button globally by the application. We
    will need it when we work with the session monitor capability. The `itemId` needs
    to be unique in its scope; in this case, it needs to be unique within this class,
    but it is going to be even better if it is unique at the application level.
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to use the `ViewController` class to handle the logout, we will
    declare a `reference` (`#14`) to make it easier to retrieve the button reference
    inside the `ViewController` class, and we are also going to declare the listener
    (`#16`), which means that the `onLogout` function from the `ViewController` class
    is going to be executed when we click on the **Logout** button.
  prefs: []
  type: TYPE_NORMAL
- en: We are also setting an icon to the `Logout` button from Font Awesome (`#15`).
    By default, the icon will have the color black. The button text is white, and
    we want the icon to have the same color as the text. For this reason, we add a
    custom style (`buttonIcon`).
  prefs: []
  type: TYPE_NORMAL
- en: At last, we have the toolbar separator declared on line `#11`. This simply adds
    a separator ("|") between the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Likewise, `tbfill`, the toolbar separator, also has a shortcut. Instead of
    `{ xtype: '' tbseparator'' }`, we could also use `''-''`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Header CSS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just as we did with the `Footer` class, we are also going to create a filename,
    `Header.scss`, inside the `sass/view/main` folder with the following content inside
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `app-header-logo` was created to customize the color of the icon to be the
    same as the application title. We are using the Sass variable inside both styles.
    The text color of the title is a dark blue.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Font Awesome icon colors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, the Font Awesome icons will be displayed in black. But we want some
    of the icons to have the same color as our theme. We can do this customization
    using CSS as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have declared two styles to customize the Font Awesome icons until now.
    The first one was inside the `Panel` class (`tabIcon`), and the second one is
    the **Logout** button (`buttonIcon`). So we also need to add these styles to our
    CSS. To follow the modular CSS approach, let''s create a new file, `iconColors.scss`,
    under `sass/etc` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will get used to using Sass variables to make our life easier if we decide
    to customize the Ext JS theme later!
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, all we need to do is import this file in the `all.scss` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The main screen and MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it''s time to put everything together. Let''s take a look at how the `Main`
    class looks with the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We need to add the `requires` declaration of all the classes we created (and
    we are referencing them by their `xtype` classes) and also the `Main` ViewModel
    and `Main` ViewController class that were already created by Sencha Cmd.
  prefs: []
  type: TYPE_NORMAL
- en: The `controller` (`#2`) and `viewModel` (`#3`) declarations were already added
    by Sencha Cmd when we created the project. We are simply reusing them by referencing
    their types.
  prefs: []
  type: TYPE_NORMAL
- en: The main ViewModel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we open the `MainModel.js` file inside the `app/view/main` folder, we will
    see some content inside it already. We are going to add more content to it, and
    the file is going to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the name of the class (`#1`). The naming convention for ViewModel
    suggested by Sencha is the name of the view (`Main`) + "`Model`", resulting in
    `MainModel`. A ViewModel extends from the `ViewModel` class (`#2`) introduced
    in Ext JS 5, along with the MVVM architecture. The alias (`#3`) of a ViewModel
    is defined by "`viewmodel.`" + the name of the type we want to assign. In this
    case, Sencha already created this class for us with the type `main`. That is why
    we can reference this alias in the `View` class using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `data` configuration allows us to populate values in the `ViewModel` class.
    The `name` field (`#4`) was created by Sencha Cmd, so we are going to keep it
    (you can remove it if you want). The `appName` (`#5`) and `appHeaderIcon` (`#6`)
    properties are being used by `Header` and `footer` (`#7`) is being used by the
    `Footer` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainModel` is bound to the `Main` class (View). Because `Header` and `Footer`
    are `items` of the `Main` component, they can also reference `MainModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the simplest way in which we can create the `ViewModel` class, with
    prepopulated data. We will provide other advanced examples throughout this book,
    but we need to start with baby steps!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information about ViewModel, data binding, and how to bind different
    data types, please read the following Sencha guide: [http://goo.gl/qta6kH](http://goo.gl/qta6kH).'
  prefs: []
  type: TYPE_NORMAL
- en: Logout capability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the user has the option to log in to the application, the user can also log
    out from it. Inside the `Header` class, we have already declared the `logout`
    button. The only thing pending is to implement the listener inside `MainController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `MainController` class was created by Sencha Cmd, we are reusing it.
    The file already has some code in it. Let''s remove any listener created by Sencha.
    `MainController` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Header` class, we declared the `logout` button, its reference, and
    its listener. So we need to implement the `onLogout` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `me` (`#1`) variable makes a reference to `this`, which is the `MainController`
    class. We will make an Ajax call (`#2`) to `php/security/logout.php` (we will
    create this file soon). We will handle the `success` (`#4`) and `failure` (`#5`)
    callbacks in separate functions that are declared inside the `MainController`
    class as well. That is why the scope is set to the `MainController` class (`#3`)
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could declare the `success` and `failure` callbacks directly inside the Ajax
    request. But then, our code will be very long, which would decrease its readability.
    This way, the code stays organized and easier to read. This is always a best practice
    to be followed.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the logout on the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle the logout capability on the server, we will create a new PHP page
    named `logout.php` under the `php/security` folder. The code is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to resume the current session (`#1`), then we need to unset all
    of the session variables (`#2`), and next we need to destroy the session (`#3`).
    Lastly, we need to send the information back to Ext JS that the session has been
    destroyed (`#4` and `#5`).
  prefs: []
  type: TYPE_NORMAL
- en: Ajax request success versus failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already taken care of the server-side code. Now, we need to go back
    to the Ext JS code and handle the response from the server. But first, we need
    to understand a very important concept that usually confuses most Ext JS developers.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. The Login Page"), *The Login Page*, we
    mentioned that the ways that the form submit and Ajax requests in Ext JS handle
    the *success x failure* are a little different, and this is what confuses most
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Ext.Ajax` class is responsible for Ajax requests done by Ext JS. If we
    look at the documentation, this class has three events: `beforerequest`, `requestcomplete`,
    and `requestexception`, which are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The event `beforerequest` is fired before the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event `requestcomplete` is fired when Ext JS is able to get a response from
    the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `requestexception` event is fired when an HTTP error status is returned
    from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's go back to the `Ext.Ajax.request` call. We can pass some options
    to the request, including the `url` property we want to connect to, parameters,
    and other options including the `success` and `failure` functions. Now, this is
    where the misunderstanding begins. Some developers understand that if the action
    happened successfully on the server, we usually return `success = true` from the
    server. If something goes wrong, we return `success = false`. Then, on the `success`
    function, `success = true` is handled, and on the `failure` function, `success
    = false` is handled. This is *wrong*, and it is not how Ext JS Ajax requests work;
    however, *that is exactly how form requests work* (as we learned in [Chapter 3](ch03.html
    "Chapter 3. The Login Page"), *The Login Page*). See how it gets confusing?
  prefs: []
  type: TYPE_NORMAL
- en: For Ext JS Ajax requests, `success` is when the server returns a response (`success`
    `true` or `false`; it does not matter), and `failure` is when the server returns
    an HTTP error status. This means that if the server was able to return a response,
    we will handle this response on the `success` function (and we will need to handle
    it whether the `success` information is `true` or `false`), and on the `failure`
    message, we need to inform the user that something went wrong and the user should
    contact the system administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement the `failure` callback function first. So, inside the `ViewController`
    class, we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What we are going to do is display an alert to the user with an error icon and
    an **OK** button with the HTTP status error information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reproduce an error so the `requestexception` event can be fired, we can
    rename the `logout.php` file to something else (for example, `logout_.php`) only
    for testing purposes. And then, we can execute the code, and we will have the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ajax request success versus failure](img/0457OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And this is all we need for the `failure` function. Note that we are reusing
    the `Packt.util.Util` class that we developed in [Chapter 3](ch03.html "Chapter 3. The
    Login Page"), *The Login Page*, in this chapter again! See how it is nice to reuse
    code?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are reusing code and saving some lines of duplicated code. We are also creating
    a pattern of how to handle a few things in our project. This is very important
    when working in a project, especially when working in a team. This way, the project
    will look like a single person and not that multiple people developed it, which
    is really good. This is also a best practice to be followed. Reusing code is also
    part of what is called *minimizing the payload size*, which is one of the best
    practices while developing with JavaScript and also a concern of web development.
    To learn more about this, please visit [https://developers.google.com/speed/docs/best-practices/payload](https://developers.google.com/speed/docs/best-practices/payload).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the code work, remove the following code from the `MainController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code in the preceding code''s position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s focus on the `success` callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do is decode the JSON message (`#1`) that we received
    from the server. If we log the `conn` parameter sent to the `success` function
    (`console.log(conn)`), this will be the output we will get on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ajax request success versus failure](img/0457OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `conn.responseText` property is where the information we want to retrieve
    is present, the `success` and `msg` values. Recall that in [Chapter 3](ch03.html
    "Chapter 3. The Login Page"), *The Login Page*, we discussed the possibility of
    `responseText` containing an exception other than the JSON we are expecting. So,
    for this reason, we are going to reuse the `decodeJSON` function we created (`#1`)
    so that we can properly handle any results.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `success` (`#2`), we are going to `destroy` the `Main` class
    (`#3`), which is our Viewport (this is good to release the browser's memory and
    make the objects available for the JavaScript garbage collector). As the Viewport
    contains all the other components of our application, it is going to destroy them
    as well. Then, we will reload the application displaying the **Login** screen
    again (`#4`).
  prefs: []
  type: TYPE_NORMAL
- en: If `success` is `false` (or any error occurred), we will display an error alert
    with the error message (`#5`).
  prefs: []
  type: TYPE_NORMAL
- en: Client-side activity monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's enhance our application a little bit more. It is very important to let
    the users know that web applications have a timeout and they cannot leave it open
    all day long—mainly for security reasons. Server-side languages also have a timeout.
    Once the user is logged in, the server will not be available forever. This is
    for security reasons. That is why we need to add this capability to our application
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use a plugin to do this. The plugin is called `Packt.util.SessionMonitor`
    and is based on the Activity Monitor plugin from the Sencha Market ([https://market.sencha.com/extensions/extjs-activity-monitor](https://market.sencha.com/extensions/extjs-activity-monitor)).
    After an interval (a default of 15 minutes of inactivity), the plugin will display
    a message to the user asking whether the user wants to keep the session alive.
    If yes, then it will send an Ajax request to the server to keep the server session
    alive. If the user does not do anything after the message is displayed for 60
    seconds, the application will logout automatically.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the source code of this plugin from [https://github.com/loiane/masteringextjs/blob/master/app/util/SessionMonitor.js](https://github.com/loiane/masteringextjs/blob/master/app/util/SessionMonitor.js).
    It works in Ext JS 4 and Ext JS 5.
  prefs: []
  type: TYPE_NORMAL
- en: At line *53* inside `Ext.ComponentQuery.query` at the preceding URL, we will
    change the `logout` button selector to `button#logout`, which is the selector
    we have for our `logout` button (that is why we created `itemId` for the `logout`
    button).
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will change the `url` property of the Ajax request on line *42* to
    `php/sessionAlive.php` at the preceding URL.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to change the inactivity interval, we only need to change the `maxInactive`
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start monitoring the session, we only need to add this line of code inside
    the `onLoginSuccess` method of `LoginController` right after we instantiate the
    `Main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We cannot forget to add `'Packt.util.SessionMonitor`' to `requires` in `LoginController`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `php/sessionAlive.php` file, we will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That is only to keep the server session alive and also to reset the session
    timer back to 15 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code and wait for the inactivity time (15 minutes—of course
    we can change the `maxInactive` parameter to wait for less time), we will see
    a message like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side activity monitor](img/0457OT_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ext JS does not provide this capability natively. But as we can see, it is very
    easy to implement, and we can reuse this plugin for all Ext JS projects that we
    work on.
  prefs: []
  type: TYPE_NORMAL
- en: The multilingual capability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you want to ship the project or product that you are working on overseas,
    and so having the translation capability is very important. After all, not everyone
    understands or speaks the same language that you do. And this is what we are going
    to implement in this topic: a multilingual component that we can use to translate
    the labels of this project. So at the end of this topic, this is going to be our
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The multilingual capability](img/0457OT_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The idea is to store the user language preference locally, so the next time
    the user loads the application, the preferred language will be automatically set.
    And when the user changes the language, the application needs to be reloaded,
    so the new translations can be loaded into the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the change language component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we take a look at the screenshot we showed at the beginning of this topic,
    we can notice that the multilingual component is a button, and when we click on
    the arrow, a menu pops up with the available languages.
  prefs: []
  type: TYPE_NORMAL
- en: The button with the arrow is a split button component, which has a Menu, and
    each language option is a Menu Item of the Menu. So, let's go ahead and create
    a new class named `Packt.view.locale.Translation` containing the characteristics
    we described.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever we name a `View` class (also known as Ext JS widgets or components),
    it is nice to give a name that can quickly remind us what the class does. For
    example, by naming the class `locale.Translation`, we quickly know that the class
    provides capabilities localizing the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new file named `Translation.js` under the `app/view/locale`
    folder with the following code inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, the class that we created is extending from the split button class (`#1`).
    A split button class is one that provides a built-in drop-down arrow that can
    fire an event separately from the default click event of the button. Typically,
    this would be used to display a drop-down menu that provides additional options
    to the primary button action. And we are also assigning the `xtype` class to this
    class (`#2`) that we used to instantiate it in the `Header` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, on `menu` (`#3`) configuration, we need to create an instance of the
    `menu` class (`#4`) followed by `menuitems` of the `menu` class, which are going
    to represent each locale option. So we have: an option to translate to `English`
    (`#5`)—and it will also show the American flag (`en`); an option to translate
    to `Spanish` (`#6`)—and it will also show the flag of Spain (`es`); and also an
    option to translate to `Portuguese` (`#7`)—and it will also display the flag of
    Brazil (`pt_BR`).'
  prefs: []
  type: TYPE_NORMAL
- en: We can add as many options as we need to. For each translate option, we only
    need to add new `menuitems` of the `menu` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CSS – country flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step now is to add the CSS for `iconCls`, which we used in the translation
    component of the application CSS. To keep our code more organized (and leave room
    to add more languages and more flag icons if needed), we are going to create a
    new file named `flagIcons.scss` inside the `sass/etc` folder with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the name of the style (`pt_BR`, `en`, and `es`) is the same as the
    `iconCls` property we used for each `menuitem`. This is very important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `all.scss` file, we need to import this file we created. Add the
    following code on the second line (right after we imported the Font Awesome file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: But what about the icons? Font Awesome does not have flag icons. We are going
    to use the Flag set from FamFamFam ([http://www.famfamfam.com/](http://www.famfamfam.com/)),
    which are free to use for any purpose (*Creative Commons License*). Create the
    folder `flags` under the directory `resources/images/app`, and copy and paste
    the flag icons. You might need to rename them to comply with the names we are
    using in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Using the translation component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, the `translation` component is ready (only what is going to be displayed
    to the user). We are going to use the `translation` component in two places of
    our project: on the **Login** screen and before the **Logout** button on `Header`
    (which is already in place).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add it to the **Login** screen. Open the `Packt.view.login.Login` class
    again. On the toolbar, we will add it as the first item so that it can look exactly
    as we showed in the screenshot at the beginning of this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot forget to add the class to the `requires` declaration of the **Login**
    screen class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we reload the application (do not forget to have `sencha app watch` executed
    on the terminal while we make all these changes), we are going to be able to see
    what we have developed until now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the multilingual files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to store the translations somewhere in our project. We are going to
    store the translations for each language on a JavaScript file inside the `resources/locale`
    folder. As we are going to use `iconCls` as the ID to load the translation files,
    we need to create three files: `en.js`, `es.js`, and `pt_BR.js`. Inside each file,
    we will create a JavaScript object named `translations`, and each attribute of
    this object will be a translation. All translation files must be the same; the
    only thing that will be different is the value of each attribute that will contain
    the translation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code is for the `en.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for `pt_BR.js`, which contains the Brazilian Portuguese
    translations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the `es.js` code, which contains the Spanish translations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the files are the same; however, the translation is different.
    As the application grows, we will add more translations to it, and it is a good
    practice to maintain the files organized in the same way to facilitate changing
    any translation in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the translation on the application's components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To apply the translations on the components that we have developed until now
    is very simple: we need to use the `translations` dictionary we created instead
    of the string that is going to represent the label.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `Packt.view.view.Login` class, we have the title of the
    window, the `fieldLabel` of the `username` and `password`, and the text of the
    **Cancel** and **Submit** buttons. The labels are hardcoded, and we want to get
    the translation from the translation files.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to replace the `title` of the :**Login** window with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to replace the `fieldLabel` of `username` `textfield` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to replace the `fieldLabel` of `password` `textfield` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to replace the `text` of the **Cancel** button with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to replace the `text` of the **Submit** button with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And so on. We can also apply the translation for the **Logout** button and also
    to the `CapsLockTooltip` class.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our idea for the `translate` component is to store the language preference of
    the user somewhere. We could use cookies for this, but what we want is very simple,
    and cookies are included with every HTTP request. We want to store this information
    for the long term and also use something that can be persisted beyond a page refresh
    or the fact that the user closed the browser. And the perfect option is to use
    local storage, one of the new features of HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS has support for local storage; it can be used with **LocalStorageProxy**,
    but we need something simpler, and using the HTML5 feature itself on the code
    is simpler. And it also demonstrates that we can use other APIs along with the
    Ext JS API.
  prefs: []
  type: TYPE_NORMAL
- en: Local storage is not supported by every browser; it is only supported by IE
    8.0+, Firefox 3.5+, Safari 4.0+, Chrome 4.0+, Opera 10.5+, iPhone 2.0+, and Android
    2.0+. We will build a nice page warning the user to upgrade the browser later
    on in this book. We will also use other HTML5 features along with Ext JS in other
    screens as well. So, for now, we need to know that this code, which we will implement
    now, does not work on every browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about HTML5 storage, please visit [http://diveintohtml5.info/storage.html](http://diveintohtml5.info/storage.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We want this code to be loaded right before we instantiate the Ext JS application.
    So, for this reason, we are going to add it right before `Ext.define(''Packt.Application'',
    {` in the `app/Application.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So, first, we are going to verify that `localStorage` is available. If it is
    available, we are going to check whether there is an item named `user-lang` stored
    on `localStorage`; if not, English will be the default language. Even if `localStorage`
    is not available, English will be set as the default language.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a variable named `file` that is going to receive the path of
    the translation file that must be loaded by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ext JS has a class, `Ext.util.Format`, that contains a static method format
    that concatenates the string and the values passed as tokens, which in this case
    is `lang`. It is cleaner than doing manual string concatenation in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: After we have the `url` formatted, we are going to load it using `Ext.Loader`.
    The `loadScript` method loads the specified script URL and calls the supplied
    callbacks (if any). It accepts `onLoad` and `onError` callbacks. In our case,
    there is no need for a success callback (`onLoad`). If there is any error while
    loading the locale file, the application will not load, so the `onError` callback
    is interesting and needed in this case so that the user can contact support in
    the event of an error (try renaming the `en.js` file to simulate an error).
  prefs: []
  type: TYPE_NORMAL
- en: To avoid creating global variables (since this is not a good JavaScript practice),
    we wrapped our code in a function. Therefore, we need to call the function (`#1`)
    right before `Ext.define('Packt.Application'`.
  prefs: []
  type: TYPE_NORMAL
- en: By the time our application is loaded, it will have all the translations available.
  prefs: []
  type: TYPE_NORMAL
- en: Handling change language in real time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now comes the final part of the code of the `translation` component. When the
    user selects a different language, we need to reload the application so that the
    `loadLocale` function is executed again and load the new language chosen by the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will create a new Controller in our application just to handle
    the translation component. The question here is: do we use MVC (which we will
    cover in the next chapter) or MVVM now? The answer depends on your personal preference.
    For this capability, we will continue using MVVM, or better, the ViewController,
    for a simple reason: both files (`TranslationController.js` and `Translation.js`)
    are located in the same directory (`app/view/locale`). And this means that it
    is easier to copy and paste this component to use it in other projects (we can
    copy the `locale` folder altogether).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So we need to create a new class named `Packt.view.locale.TranslationController`,
    and to create this class, we need to create a new file named `TranslationController.js`
    under the `app/view/locale` folder. In this controller, we will need to listen
    to two events: one fired by the `translation` component itself and the other one
    fired by `menuitems`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to the `Translation.js` file and add `TranslationController`
    as the ViewController so that we can start listening to the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The split button has two events, which are the `click` (fired because it is
    a button) and the `arrowclick` events, fired when the user clicks on the arrow.
    We are not interested in either event. Inside the split button, there is a `Menu`
    class with `menuitems`, and each `menuitem` represents a locale file. The `MenuItem`
    component also fires the `click` event when clicked on. So we can add the `click`
    listener to each `MenuItem`—or even better, add a `defaults` configuration to
    `menu`, as follows (which is going to be applied to all items):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go back to `TranslationController` and implement the `onMenuItemClick`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, we will get the reference to the `translation` component (`#1`). Then,
    we will update the split button `iconCls` and `text` with `iconCls` and `text`
    of the selected Menu Item (`#2` and `#3`). Next, we will update the new language
    selected by the user on `localStorage` (`#4`), and finally, we will ask the browser
    to reload the application (`#5`).
  prefs: []
  type: TYPE_NORMAL
- en: The early life of the ViewController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is still one detail missing. When we load the application, the `translation`
    component does not have text or an icon configured. We also need to take care
    of this. We could listen to the `beforerender` or `render` events to update these
    two properties before the component is displayed to the user, but there is a very
    important detail: the ViewController is created very early in the component''s
    life cycle, and for this reason, it is not possible to listen to these events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three methods that we can use that can execute some tasks during
    the key points of the component''s life cycle according to the Sencha documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeInit`: This method can be overridden in order to operate on the view
    prior to its `initComponent` method being called. This method is called immediately
    after the controller is created, which occurs during `initConfig` called from
    the component constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Init`: This is called shortly after `initComponent` has been called on the
    view. This is the typical time to perform initialization for the controller now
    that the view is initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initViewModel`: This is called when the view''s ViewModel is created (if one
    is defined).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we want the `translation` component to have `iconCls` and `text` when it
    is rendered, we can use the `init` method in `TranslationController` to execute
    this logic for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: First, we will verify that there is `localStorage`, and if positive, we will
    get the language that was stored. If there is no `localStorage`, or the preferred
    language was not stored yet (the first time the user uses the application or the
    user has not changed the language yet), the default language will be `English`.
    Then, we will set the `iconCls` of the split button as the flag of the selected
    language (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: If the selected language is English, we will set the split button `text` as
    `"English"` (`#2`), and if the selected language is Spanish, we will set the split
    button `text` as `"Español"` (`#8`); otherwise, we will set the text as `"Português"`
    (Portuguese).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This controller is also available in the MVC architecture. You can take a look
    at the differences between the MVC and MVVM implementation at [http://goo.gl/ajaIao](http://goo.gl/ajaIao).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the application, we can change the preferred language and see
    that the result is a translated application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The early life of the ViewController](img/0457OT_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using locale files to translate Ext JS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, there is one last thing missing. We are translating only the labels
    of the application. Form errors and other messages that are part of the Ext JS
    API are not translated. Ext JS provides locale file support. All we need to do
    is add the JavaScript locale file on the HTML page. To do so, we are going to
    add the following code inside the `loadLocale` function in the `Application.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of `iconCls` used for the flag and translation files (`en.js`, `es,js`,
    `pt_BR.js`) are due to the name of the locale files used by Sencha. So make sure
    you verify what name Sencha is using before naming your own file.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, if we try to execute the application again, we will be able to see
    that all the Ext JS messages will also be translated. For example, if we change
    the translation to Spanish, the form validation errors will also be in Spanish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using locale files to translate Ext JS](img/0457OT_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the locale support of the application is completed!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might want to review the label size (use the `labelWidth` configuration
    to change its default size of 100 pixels) and the message targets for the screens
    after applying locale support. For example, the label **Contraseña** needs more
    width in the screen than **Password**.
  prefs: []
  type: TYPE_NORMAL
- en: After applying the locale, change `labelWidth` to `70` inside the `Login` class.
    You can change `msgTarget` to '`side`' or increase the `height` of the window
    so that the form validation messages can be properly displayed in other languages
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered how to implement the base of the application we are going to implement
    throughout this book using the Border layout, and you learned how to implement
    a **Logout** button (on the Ext JS side and also on the server side). We also
    covered the Client Activity Monitor and Session Timeout capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, you learned how to build a `translation` component using HTML5
    features along with Ext JS, which is able to translate all the labels of the application
    and also change the preferred language at runtime. You also learned how to use
    the Ext JS locale support used to translate the framework's messages and labels.
  prefs: []
  type: TYPE_NORMAL
- en: We made a great advance in this chapter regarding the implementation of our
    application. We created new files and our application is growing. We will continue
    to create more files and components in the next chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to build a dynamic menu using Accordion
    panels and trees.
  prefs: []
  type: TYPE_NORMAL
