<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Application Structure</h1></div></div></div><p>We previously discussed how growing an application organically without any sense of architecture could result in an unmaintainable mess of spaghetti code. One of the great things about imposing structure is that it automatically gives predictability (a kind of filing system with in which we immediately know where a particular piece of code should live).</p><p>The same applies to the files that make up your application. Certainly, we could put all of our files in the root of the website, mixing CSS, JavaScript, configuration and HTML files in a long alphabetical list, but we'd be losing out on a number of opportunities to keep our application organized. In this chapter, we'll look at:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ideas to structure your code</li><li class="listitem" style="list-style-type: disc">The layout of a typical Ext JS application</li><li class="listitem" style="list-style-type: disc">Use of singletons, mixins, and inheritance</li><li class="listitem" style="list-style-type: disc">Why global state is a bad thing</li></ul></div><p>Structuring your application is like keeping your house in order. You'll know where to find your car keys, and you'll be prepared for unexpected guests.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Ideas for structure</h1></div></div></div><p>One of the ways<a id="id78" class="indexterm"/> in which code is structured in large applications involves namespacing (the practice of dividing code up by naming identifiers). One namespace could contain everything relating to Ajax, whereas another could contain classes related to mathematics. Programming languages (such as C# and Java) even incorporate namespaces as a first-class language construct to help with code organization.</p><p>Separating code from directories based on namespace becomes a sensible extension of this:</p><div><img src="img/5308OT_03_01.jpg" alt="Ideas for structure"/><div><p>From left: Java's Platform API, Ext JS 5, and .NET Framework</p></div></div><p>A namespace identifier is made up of one or more name tokens, such as "Java" or "Ext", "Ajax" or "Math", separated by a symbol, in most cases a full stop/period. The top level name will be an overarching identifier for the whole package (such as "Ext") and will become less <a id="id79" class="indexterm"/>specific as names are added and you drill down into the code base.</p><p>The Ext JS source code makes heavy use of this practice to partition UI components, utility classes, and all the other parts of the framework, so let's look at a real example. The <code class="literal">GridPanel</code> component is perhaps one of the most complicated in the framework; a large collection of classes that contribute to features (such as columns, cell editing, selection, and grouping). These work together to create a highly powerful UI widget. Take a look at the following files that make up <code class="literal">GridPanel</code>:</p><div><img src="img/5308OT_03_02.jpg" alt="Ideas for structure"/><div><p>The Ext JS grid component's directory structure</p></div></div><p>The <code class="literal">grid</code> directory reflects the <code class="literal">Ext.grid</code> namespace. Likewise, the subdirectories are child namespaces with the deepest namespace being <code class="literal">Ext.grid.filters.filter</code>.</p><p>The main<a id="id80" class="indexterm"/> <code class="literal">Panel</code> and <code class="literal">View</code> classes: <code class="literal">Ext.grid.Grid</code> and <code class="literal">Ext.grid.View</code> respectively are there in the main director. Then, additional pieces of functionality, for example, the <code class="literal">Column</code> class and the various column subclasses are further grouped together in their own subdirectories. We can also see a <code class="literal">plugins</code> directory, which contains a number of grid-specific plugins.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Ext JS actually already has an <code class="literal">Ext.plugins</code> namespace. It contains classes to support the plugin infrastructure as well as plugins that are generic enough to apply across the entire framework. In the event of uncertainty regarding the best place in the code base for a plugin, we might mistakenly have put it in <code class="literal">Ext.plugins</code>. Instead, Ext JS follows best practice and creates a new, more specific namespace underneath <code class="literal">Ext.grid</code>.</p></div></div><p>Going back to the root of the Ext JS framework, we can see that there are only a few files at the top level. In general, these will be classes that are either responsible for orchestrating other parts of the framework (such as <code class="literal">EventManager</code> or <code class="literal">StoreManager</code>) or classes that are widely reused across the framework (such as <code class="literal">Action</code> or <code class="literal">Component</code>). Any more specific functionality should be namespaced in a suitably specific way.</p><p>As a rule of <a id="id81" class="indexterm"/>thumb, you can take your inspiration from the organization of the Ext JS framework, though as a framework rather than a full-blown application. It's lacking some of the structural aspects we'll talk about shortly.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Getting to know your application</h1></div></div></div><p>When generating <a id="id82" class="indexterm"/>an Ext JS application using Sencha Cmd, we end up with a code base that adheres to the concept of namespacing in class names and in the directory structure, as shown here:</p><div><img src="img/5308OT_03_03.jpg" alt="Getting to know your application"/><div><p>The structure created with Sencha Cmd's "generate app" feature</p></div></div><p>We should be familiar with all of this, as it was already covered when we discussed MVVM in Ext JS. Having said that, there are some parts of this that are worth examining further to see whether they're being used to the full.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>/overrides</h2></div></div></div><p>This is a handy one to help us fall into a positive and predictable pattern. There are some cases where you need to override Ext JS functionality on a global level. Maybe, you want to change the implementation of a low-level class (such as <code class="literal">Ext.data.proxy.Proxy</code>) to provide custom batching behavior<a id="id83" class="indexterm"/> for your application. Sometimes, you might even find a bug in Ext JS itself and use an override to hotfix until the next point release. The <code class="literal">overrides</code> directory provides a logical place to put these changes (just mirror the directory structure and namespacing of the code you're overriding). This also provides us with a helpful rule, that is, subclasses go in <code class="literal">/app</code> and overrides go in <code class="literal">/overrides</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>/.sencha</h2></div></div></div><p>This contains configuration information and build files used by Sencha Cmd. In general, I'd say try and <a id="id84" class="indexterm"/>avoid fiddling around in here too much until you know Sencha Cmd inside out because there's a chance you'll end up with nasty conflicts if you try and upgrade to a newer version of Sencha Cmd. Fortunately, <a class="link" href="ch04.html" title="Chapter 4. Sencha Cmd">Chapter 4</a>, <em>Sencha Cmd</em>, is all about Sencha Cmd, where we'll dive deep into this folder.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>bootstrap.js, bootstrap.json, and bootstrap.css</h2></div></div></div><p>The Ext JS<a id="id85" class="indexterm"/> class system has powerful dependency management through the <code class="literal">requires</code> feature, which gives us the means to create a build that contains only<a id="id86" class="indexterm"/> the code that's in use. The bootstrap files contain information <a id="id87" class="indexterm"/>about the minimum CSS and JavaScript needed to run your application as provided by the dependency system. As we'll see in <a class="link" href="ch04.html" title="Chapter 4. Sencha Cmd">Chapter 4</a>, <em>Sencha Cmd</em>, you can even create custom bootstrap files depending on your requirements.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>/packages</h2></div></div></div><p>In a similar way<a id="id88" class="indexterm"/> to how Ruby has RubyGems and Node.js has npm, Sencha Cmd has the concept of packages (a bundle which can be pulled into your application from a local or remote source).</p><p>This allows you to reuse and publish bundles of functionality (including CSS, images, and other resources) to reduce copy and paste of code, and share your work with the Sencha <a id="id89" class="indexterm"/>community. This directory is empty until you configure packages to be used in your app.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>/resources and SASS</h2></div></div></div><p>SASS is a technology<a id="id90" class="indexterm"/> that aids in the creation of complex CSS by promoting reuse and bringing powerful features (such as mixins and functions) to your style<a id="id91" class="indexterm"/> sheets. Ext JS uses SASS for its theme files and encourages you to use it as well. We'll look at this in <a class="link" href="ch04.html" title="Chapter 4. Sencha Cmd">Chapter 4</a>, <em>Sencha Cmd</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>index.html</h2></div></div></div><p>We know that <code class="literal">index.html</code> is the root HTML page of our application. It can be customized as <a id="id92" class="indexterm"/>you see fit (although, it's rare you'll need to). There's one caveat and it's written in a comment in the file already:</p><div><pre class="programlisting">&lt;!-- The line below must be kept intact for Sencha Cmd to build your application --&gt;
&lt;script id="microloader" type="text/javascript" src="img/bootstrap.js"&gt;&lt;/script&gt;</pre></div><p>We know what <code class="literal">bootstrap.js</code> refers to (loading up our application and starting to fulfill its dependencies according to the current build), so heed the comment and leave this script tag well alone!</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>/build and build.xml</h2></div></div></div><p>The <code class="literal">/build</code> directory contains build artifacts (the files created when the build process is run). If you run a production build, then you'll get a directory inside <code class="literal">/build</code> called <code class="literal">production</code> and you should<a id="id93" class="indexterm"/> use only these files when deploying. The <a id="id94" class="indexterm"/>
<code class="literal">build.xml</code> file allows you to avoid tweaking some of the files in <code class="literal">/.sencha</code> when you want to add some extra functionality to a build process. If you want to do something before, during, or after the build, this is the place to do it. We'll come back to the build process when we look at Sencha Cmd in <a class="link" href="ch04.html" title="Chapter 4. Sencha Cmd">Chapter 4</a>, <em>Sencha Cmd</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>app.js</h2></div></div></div><p>This is the main JavaScript entry point to your application. The comments in this file advise avoiding <a id="id95" class="indexterm"/>editing it in order to allow Sencha Cmd to upgrade it in the future. The <code class="literal">Application.js</code> file at <code class="literal">/app/Application.js</code> can be edited without fear of conflicts and will enable you to do the majority of things you might need to do.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>app.json</h2></div></div></div><p>This contains configuration options related to Sencha Cmd and booting your application. We'll cover this more in <a class="link" href="ch04.html" title="Chapter 4. Sencha Cmd">Chapter 4</a>, <em>Sencha Cmd</em>.</p><p>When we refer to the<a id="id96" class="indexterm"/> subject of this book as a JavaScript application, we need to remember that it's just a website composed of HTML, CSS, and JavaScript as well. However, when dealing with a large application that needs to target different environments, it's incredibly useful to augment this simplicity with tools that assist in the development process. At first, it may seem that the default application template contains a lot of cruft, but they are the key to supporting the tools that will help you craft a solid product.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Cultivating your code</h1></div></div></div><p>As you build your application, there will come a point at which you create a new class and yet it doesn't logically fit into the directory structure Sencha Cmd created for you. Let's look at a few examples.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>I'm a lumberjack – let's go log in</h2></div></div></div><p>Many applications have a centralized <code class="literal">SessionManager</code> to take care of the currently logged in user, perform<a id="id97" class="indexterm"/> authentication operations, and set up persistent storage for session credentials. There's only one <code class="literal">SessionManager</code> in an application. A truncated version might look like this:</p><div><pre class="programlisting">/**
 * @class CultivateCode.SessionManager
 * @extends extendsClass
 * Description
 */
Ext.define('CultivateCode.SessionManager', {
    singleton: true,
    isLoggedIn: false,

    login: function(username, password) {
        // login impl
    },


    logout: function() {
        // logout impl
    },

    isLoggedIn() {
        return isLoggedIn;
    }
});</pre></div><p>We create a singleton class. This class doesn't have to be instantiated using the new keyword. As per its class name, <code class="literal">CultivateCode.SessionManager</code>, it's a top-level class and so it goes<a id="id98" class="indexterm"/> in the top-level directory. In a more complicated application, there could be a dedicated <code class="literal">Session</code> class too and some other ancillary code, so we'd create the following structure:</p><div><img src="img/5308OT_03_04.jpg" alt="I'm a lumberjack – let's go log in"/><div><p>The directory structure for our session namespace</p></div></div><p>What about user interface elements? There's an informal practice in the Ext JS community that helps here. We want to create an extension that shows the coordinates of the currently selected cell (similar to cell references in Excel). In this case, we'd create an <code class="literal">ux</code> directory—user experience or user extensions—and then go with the naming conventions of the Ext JS framework:</p><div><pre class="programlisting">Ext.define('CultivateCode.ux.grid.plugins.CoordViewer', {
    extend: 'Ext.plugin.Abstract',
    alias: 'plugin.coordviewer',

    mixins: {
        observable: 'Ext.util.Observable'
    },

    init: function(grid) {
        this.mon(grid.view, 'cellclick', this.onCellClick, this);
    },

    onCellClick: function(view, cell, colIdx, record, row, rowIdx, e) {
        var coords = Ext.String.format('Cell is at {0}, {1}', colIdx, rowIdx)

        Ext.Msg.alert('Coordinates', coords);
    }
});</pre></div><p>It looks a little<a id="id99" class="indexterm"/> like this, triggering when you click on a grid cell:</p><div><img src="img/5308OT_03_05.jpg" alt="I'm a lumberjack – let's go log in"/></div><p>Also, the corresponding directory structure follows directly from the namespace:</p><div><img src="img/5308OT_03_06.jpg" alt="I'm a lumberjack – let's go log in"/></div><p>You can probably see a pattern emerging already.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>We've<a id="id100" class="indexterm"/> mentioned before that organizing an application is often about setting things up to fall into a position of success. A positive pattern like this is a good sign that you're doing things right.</p></div></div><p>We've got a predictable system that should enable us to create new classes without having to think too hard about where they're going to sit in our application. Let's take a look at one more example of a mathematics helper class (one that is a little less obvious).</p><p>Again, we can look at the Ext JS framework itself for inspiration. There's an <code class="literal">Ext.util</code> namespace containing over 20 general classes that just don't fit anywhere else. So, in this case, let's create <code class="literal">CultivateCode.util.Mathematics</code> that contains our specialized methods for numerical work:</p><div><pre class="programlisting">Ext.define('CultivateCode.util.Mathematics', {
    singleton: true,

    square: function(num) {
        return Math.pow(num, 2);
    },

    circumference: function(radius) {
        return 2 * Math.PI * radius;
    }
}); </pre></div><p>There is one caveat here and it's an important one. There's a real danger that rather than thinking about the namespace for your code and its place in your application, a lot of stuff ends up under the <code class="literal">utils</code> namespace, thereby defeating the whole purpose. Take time to carefully check whether there's a more suitable location for your code before putting it in the <code class="literal">utils</code> bucket.</p><p>This is particularly<a id="id101" class="indexterm"/> applicable if you're considering adding lots of code to a single class in the <code class="literal">utils</code> namespace. Looking again at Ext JS, there are lots of specialized namespaces (such as <code class="literal">Ext.state</code> or <code class="literal">Ext.draw</code>). If you were working with an application with lots of mathematics, perhaps you'd be better off with the following namespace and directory structure:</p><div><pre class="programlisting">Ext.define('CultivateCode.math.Combinatorics', {
    // implementation here!
});
Ext.define('CultivateCode.math.Geometry', {
    // implementation here!
});</pre></div><p>The directory structure for the math namespace is shown in the following screenshot:</p><div><img src="img/5308OT_03_07.jpg" alt="I'm a lumberjack – let's go log in"/></div><p>This is another situation where there is no definitive right answer. It will come to you with experience and will depend entirely on the application you're building. Over time, putting together these high-level applications, building blocks will become second nature.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Money can't buy class</h2></div></div></div><p>Now that we're learning where our classes belong, we need to make sure that we're actually using the right type of class. Here's the<a id="id102" class="indexterm"/> standard way of instantiating an Ext JS class:</p><div><pre class="programlisting">var geometry = Ext.create('MyApp.math.Geometry');</pre></div><p>However, think about your code. Think how rare it's in Ext JS to actually manually invoke <code class="literal">Ext.create</code>. So, how<a id="id103" class="indexterm"/> else are the class instances created?</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec01"/>Singletons</h3></div></div></div><p>A singleton is simply a class that only has one instance across the lifetime of your application. There<a id="id104" class="indexterm"/> are quite a number of singleton classes in the Ext JS framework. While the use of singletons in general is a contentious point in software architecture, they tend to be used fairly well in Ext JS.</p><p>It could be that you prefer to implement the mathematical functions (we discussed earlier) as a singleton. For example, the following command could work:</p><div><pre class="programlisting">var area = CultivateCode.math.areaOfCircle(radius);</pre></div><p>However, most developers would implement a circle class:</p><div><pre class="programlisting">var circle = Ext.create('CultivateCode.math.Circle', { radius: radius });
var area = circle.getArea();</pre></div><p>This keeps the circle-related functionality partitioned off into the circle class. It also enables us to pass the circle variable round to other functions and classes for additional processing.</p><p>On the other hand, look at <code class="literal">Ext.Msg</code>. Each of the methods here are fired and forgotten, there's never going to be anything to do further actions on. The same is true of <code class="literal">Ext.Ajax</code>. So, once more we find ourselves with a question that does not have a definitive answer. It depends entirely on the context.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>This is going to happen a lot, but it's a good thing! This book isn't going to teach you a list of facts and figures; it's going to teach you to think for yourself. Read other people's code and learn from experience. This isn't coding by numbers!</p></div></div><p>The other place you might find yourself reaching for the power of the singleton is when you're creating an overarching manager class (such as the inbuilt <code class="literal">StoreManager</code> or our previous <code class="literal">SessionManager</code> example). One of the objections about singletons is that they tend to be abused to store lots of global state and break down the separation of concerns we've set up in our code, as follows:</p><div><pre class="programlisting">Ext.define('CultivateCode.ux.grid.GridManager', {
    
    singleton: true,
    currentGrid: null,
    grids: [],

    add: function(grid) {
        this.grids.push(grid);
    },

    setCurrentGrid: function(grid) {
        this.focusedGrid = grid;
    }
});</pre></div><p>No one wants to see this sort of thing in a code base. It brings behavior and state to a high level in the <a id="id105" class="indexterm"/>application. In theory, any part of the code base could call this manager with unexpected results. Instead, we'd do something like this:</p><div><pre class="programlisting">Ext.define('CultivateCode.view.main.Main', {
    extend: 'CultivateCode.ux.GridContainer',

    currentGrid: null,
    grids: [],

    add: function(grid) {
        this.grids.push(grid);
    },

    setCurrentGrid: function(grid) {
        this.currentGrid = grid;
    }
});</pre></div><p>We still have the same behavior (a way of collecting together grids), but now, it's limited to a more contextually appropriate part of the grid. Also, we're working with the MVVM system. We avoid global state and organize our code in a more correct manner. A win all round.</p><p>As a general rule, if you can avoid using a singleton, do so. Otherwise, think very carefully to make sure that it's the right choice for your application and that a standard class wouldn't better fit your requirements. In the previous example, we could have taken the easy way out and used a manager singleton, but it would have been a poor choice that would compromise the structure of our code.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Mixins</h2></div></div></div><p>We're used to the concept of inheriting from a subclass in Ext JS—a grid extends a panel to take on all of its functionality. Mixins provide a similar opportunity to reuse functionality to augment an<a id="id106" class="indexterm"/> existing class with a thin slice of behavior. In <em>Code Complete Second Edition</em>, <em>Steve McConnell</em>, <em>Microsoft Press US</em>, <em>Section 6.3</em>, McConnell says:</p><div><blockquote class="blockquote"><p><em>"Think of containment as a "has a" relationship. A car "has an" engine, a person "has a" name, etc."</em></p><p><em>"Think of inheritance as an "is a" relationship. A car "is a" vehicle, a person "is a" mammal, etc."</em></p></blockquote></div><p>An <code class="literal">Ext.Panel</code> "is an" <code class="literal">Ext.Component</code>, but it also "has a" pinnable feature that provides a pin tool via the <code class="literal">Ext.panel.Pinnable</code> mixin.</p><p>In your code, you should be looking at mixins to provide a feature, particularly in cases where this feature can be reused. In the next example, we'll create a UI mixin called <code class="literal">shakeable</code>, which provides a UI component with a shake method that draws the user's attention by rocking it from side to side:</p><div><pre class="programlisting">Ext.define('CultivateCode.util.Shakeable', {
    mixinId: 'shakeable',

    shake: function() {
        var el = this.el,
            box = el.getBox(),
            left = box.x - (box.width / 3),
            right = box.x + (box.width / 3),
            end = box.x;

        el.animate({
            duration: 400,
            keyframes: {
                33: {   
                    x: left
                },
                66: {
                    x: right
                },
                100: {
                    x: end
                }
            }
        });
    }
});</pre></div><p>We use the <a id="id107" class="indexterm"/>
<code class="literal">animate</code> method (which itself is actually mixed in <code class="literal">Ext.Element</code>) to set up some animation keyframes to move the component's element first left, then right, then back to its original <a id="id108" class="indexterm"/>position. Here's a class that implements it:</p><div><pre class="programlisting">Ext.define('CultivateCode.ux.button.ShakingButton', {
    extend: 'Ext.Button',
    mixins: ['CultivateCode.util.Shakeable'],
    xtype: 'shakingbutton'
});</pre></div><p>Also it's used like this:</p><div><pre class="programlisting">var btn = Ext.create('CultivateCode.ux.button.ShakingButton', {
   text: 'Shake It!'
});
btn.on('click', function(btn) {
   btn.shake();
});</pre></div><p>The button has taken on the new shake method provided by the mixin. Now, if we'd like a class to have the <code class="literal">shakeable</code> feature, we can reuse this mixin where necessary.</p><p>In addition, mixins can simply be used to pull out the functionality of a class into logical chunks, rather than having a single file of many thousands of lines. <code class="literal">Ext.Component</code> is an example of this. In fact, most of its core functionality is found in classes that are mixed in <code class="literal">Ext.Component</code>.</p><p>This is also helpful when navigating a code base. Methods that work together to build a feature can be grouped and set aside in a tidy little package. Let's take a look at a practical example of how an existing class could be refactored using a mixin. Here's the skeleton of the original:</p><div><pre class="programlisting">Ext.define('CultivateCode.ux.form.MetaPanel', {
    extend: 'Ext.form.Panel',

    initialize: function() {
        this.callParent(arguments);
        this.addPersistenceEvents();
    },

    loadRecord: function(model) {
        this.buildItemsFromRecord(model);
        this.callParent(arguments);
    },

    buildItemsFromRecord: function(model) {
        // Implementation
    },

    buildFieldsetsFromRecord: function(model){
        // Implementation
    },

    buildItemForField: function(field){
        // Implementation
    },

    isStateAvailable: function(){
        // Implementation
    },

    addPersistenceEvents: function(){
        // Implementation
    },

    persistFieldOnChange: function(){
        // Implementation
    },

    restorePersistedForm: function(){
        // Implementation
    },

    clearPersistence: function(){
        // Implementation
    }
});</pre></div><p>This <code class="literal">MetaPanel</code> does<a id="id109" class="indexterm"/> two things that the normal <code class="literal">FormPanel</code> does not:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It reads the <code class="literal">Ext.data.Fields</code> from an <code class="literal">Ext.data.Model</code> and automatically generates a form layout based on these fields. It can also generate field sets if the fields have the same group configuration value.</li><li class="listitem" style="list-style-type: disc">When the values of the form change, it persists them to <code class="literal">localStorage</code> so that the user can navigate away and resume completing the form later. This is useful for long forms.</li></ul></div><p>In reality, implementing these features would probably require additional methods to the ones shown in the <a id="id110" class="indexterm"/>previous code skeleton. As the two extra features are clearly defined, it's easy enough to refactor this code to better describe our intent:</p><div><pre class="programlisting">Ext.define('CultivateCode.ux.form.MetaPanel', {
    extend: 'Ext.form.Panel',

    mixins: [
        // Contains methods:
        // - buildItemsFromRecord
        // - buildFieldsetsFromRecord
        // - buildItemForField
        'CultivateCode.ux.form.Builder',

        // - isStateAvailable
        // - addPersistenceEvents
        // - persistFieldOnChange
        // - restorePersistedForm
        // - clearPersistence
        'CultivateCode.ux.form.Persistence'
    ],

    initialize: function() {
        this.callParent(arguments);
        this.addPersistenceEvents();
    },

    loadRecord: function(model) {
        this.buildItemsFromRecord(model);
        this.callParent(arguments);
    }
});</pre></div><p>We have a much shorter file and the behavior we're including in this class is described a lot more concisely. Rather than seven or more method bodies that may span a couple of hundred lines of code, we have two mixin lines and the relevant methods extracted to a well-named mixin<a id="id111" class="indexterm"/> class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>The solution to pollution</h1></div></div></div><p>In essence, we're <a id="id112" class="indexterm"/>striving to make sure that a newcomer to a project is never surprised by what they see. Everything should be clearly labeled, decisions should have logic behind them, and code should be in a place that makes sense for its functionality. We've briefly touched on how a namespace (such as <code class="literal">utils</code>) can become a "bucket" for code that doesn't immediately fit. There are a couple of other situations in which we find ourselves creating a dumping ground for functions that nobody knows what to do with.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>A global solution to a local problem</h2></div></div></div><p>Our hero, the plucky programmer with a lot of heart and a burgeoning talent, is writing their latest application when they realize something.</p><p>
<em>I'm going to need this function a lot; potentially, in most of my UI components.</em>
</p><p>Worried, they consider the best way to implement it, then the best place for it to fit in the existing code base.</p><p>I need to call it from anywhere in the application. Also, my application class is already available from everywhere in the app; I'll hang it off there. <code class="literal">MyApp.myFunc()</code>, here we come!</p><p>And so our hero starts down the road to madness. <code class="literal">MyApp.isUserLoggedIn()</code>, they ask? <code class="literal">MyApp.isProduction()</code> or <code class="literal">MyApp.isStaging()</code>, they wonder? Also, for convenient access to configuration, we have the <code class="literal">MyApp.validNames</code> and <code class="literal">MyApp.apiUrl</code> arrays.</p><p>
<em>Look on my global state ye mighty, and despair!</em>
</p><p>A little melodrama to get the point across. It's very easy to use your application singleton as an easy catch-all as shown here:</p><div><pre class="programlisting">Ext.define('CultivateCode.Application', {
    extend: 'Ext.app.Application',
    
    name: 'CultivateCode',

    searchCfg: {
        mode: 'beginsWith',
        dir: 'asc'
    },

    isLoggedIn: false,
    isSecure: false,

    launch: function () {
        this.setupAjaxOverrides();
        this.performCookieCheck();

        Ext.apply(Ext.util.Format, {
            defaultDateFormat: 'd F Y'
        });
    },

    setMasked: function(mask) {
        // Implementation
    },

    setupAjaxOverrides: function() {
        // Implementation
    },

    onAjaxError: function(connection, resp, opt) {
        // Implementation
    }

    performCookieCheck: function() {
        // Implementation
    }
});</pre></div><p>What would be the right thing to do here? Well, <code class="literal">searchCfg</code> needs to be moved to the place it's used, perhaps a search model or view model, maybe on the UI component responsible for search.</p><p>The Ajax<a id="id113" class="indexterm"/> overrides and error handling could be moved to the <code class="literal">/overrides</code> folder and positioned within their correct namespaces, making them much more discoverable.</p><p>The cookie check, which makes sure users have cookies enabled on their browser, could probably be retained in the application class, simply because in this app, cookies could be a requirement.</p><p>Things such as <code class="literal">isLoggedIn</code> would be best taken care of by a <code class="literal">SessionManager</code>, as we previously discussed. Still in a singleton, but a singleton that is in a more discoverable and logical place for this functionality.</p><p>In another place, we <a id="id114" class="indexterm"/>can take our cue from the Ext JS framework: <code class="literal">setMasked</code>. Rather than having this as a method on the application, Ext JS provides it as a method on each <code class="literal">Ext.Container</code>, meaning you can call it directly on panels and grids. This means that the code that masks components will no longer jump up to the global application scope and hope that it's targeting the correct container. Instead, you can be certain that you're affecting the component you're interested in and nothing more, and all without polluting your global application class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Summary – mind your own beeswax</h1></div></div></div><p>In this chapter, we drove several points home.</p><p>When it comes to structuring your application, make life easy for yourself. Go for the principle of least surprise and don't pile all of your classes in a single namespace.</p><p>Keep your code in manageable blocks using architectural devices such as mixins. When you look in a class, you don't want to see thousands of meandering lines, but want a concise logical unit.</p><p>Use the Ext JS framework as structural inspiration. It may not be 100 percent, but it does show us something very important, which should inform every aspect of your application architecture: having a system is always better than not having one and you should be consistent at all times.</p><p>In the next chapter, we will look at Sencha Cmd, a tool that goes hand in hand with Ext JS to help us generate, develop, and deploy our applications.</p></div></body></html>