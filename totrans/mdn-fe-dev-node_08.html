<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-80" lang="en-GB"><a id="_idTextAnchor079"/>8</h1>
<h1 id="_idParaDest-81" lang="en-GB"><a id="_idTextAnchor080"/>Publishing npm Packages</h1>
<p lang="en-GB">Before now, our main focus has been to learn everything about improving and contributing to existing projects, but quite often, this is not everything. Some projects will need to be initiated correctly by you and one part of this process is to decide which packages should actually be reused.</p>
<p lang="en-GB">We’ve already learned that reusability in Node.js is primarily gained through the module system, which can be enhanced by third-party dependencies in the form of npm packages. In this chapter, you’ll learn how you can publish npm packages yourself. This way, a functionality implemented once can be shared among the team working on the same project or with anyone.</p>
<p lang="en-GB">To achieve our goal in this chapter, first, we’ll set up a simple library to serve our case well. Then, we publish this library to the official npm registry in a way that makes the code available to any Node.js developer. If you want to keep your library a bit less exposed, then the following sections will be interesting for you. In these, you will first learn how to select other registries before you actually select a local registry to use for publishing and installation.</p>
<p lang="en-GB">Finally, we’ll also look at ways to broaden the scope of our library – by making it <strong class="bold" lang="">isomorphic</strong> or exposing it as a tool. In summary, we’ll cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Publishing to the official registry</li>
<li lang="en-GB">Selecting another npm registry via <code>.npmrc</code></li>
<li lang="en-GB">Setting up Verdaccio</li>
<li lang="en-GB">Writing isomorphic libraries</li>
<li lang="en-GB">Publishing a cross-platform tool</li>
</ul>
<h1 id="_idParaDest-82" lang="en-GB"><a id="_idTextAnchor081"/>Technical requirements</h1>
<p lang="en-GB">The complete source code for this chapter is available at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter08">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter08</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="https://bit.ly/3UmhN4B">https://bit.ly/3UmhN4B</a>.</p>
<h1 id="_idParaDest-83" lang="en-GB"><a id="_idTextAnchor082"/>Publishing to the official registry</h1>
<p lang="en-GB">Let’s start by creating a <a id="_idIndexMarker293"/>small library that uses a structure that can be seen very often in Node.js projects. The structure consists of an <code>src</code> folder, where the original sources are located, and a <code>lib</code> folder, containing the output to be used by the target system. The target system could either be something such as a bundler for browser applications or a specific version of Node.js.</p>
<p lang="en-GB">To initialize this kind of project, we can use the <code>npm</code> command-line utility as we did before:</p>
<pre class="console" lang="en-GB">
$ npm init -y</pre>
<p lang="en-GB">Now, we’ll set everything up. First, we will install <code>esbuild</code> as a development dependency. This can be very helpful for transforming our source files into usable library files:</p>
<pre class="console" lang="en-GB">
$ npm install esbuild --save-dev</pre>
<p lang="en-GB">Next, we change <code>package.json</code> to fit our needs:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
<pre class="source-code" lang="en-GB">{
  "name": "lib-test-florian-rappl",
  "version": "1.0.0",
  "description": "Just a test library",
  "keywords": [],
  "author": "Florian Rappl",
  "license": "MIT",
  "main": "lib/index.js",
  "source": "src/index.js",
  "scripts": {
    "build": "esbuild src/*.js --platform=node --outdir=lib
      --format=cjs"
  },
  "devDependencies": {
    "esbuild": "^0.15.0"
  }
}</pre>
<p lang="en-GB">Importantly, replace the chosen placeholder’s name (<code>florian-rappl</code> in the <code>name</code> field and <code>Florian Rappl</code> in the <code>author</code> field) with your name. For the <code>name</code> field, make sure to only use <a id="_idIndexMarker294"/>letters allowed for package name identifiers. Also, feel free to change the selected license.</p>
<p class="callout-heading" lang="en-GB">Licenses</p>
<p class="callout" lang="en-GB">An important piece of information in every <code>package.json</code> is the <code>license</code> field. While the MIT License is a very good choice for many open-source projects, it is by no means the only one. Other popular choices include the Apache License 2.0, BSD 3-Clause, and the ISC License.</p>
<p lang="en-GB">Now, we’ll add some content to our source file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/index.js</p>
<pre class="source-code" lang="en-GB">import { readFile } from "fs";
import { resolve } from "path";
export function getLibName() {
  const packagePath = resolve(__dirname,
    "../package.json");
  return new Promise((resolve, reject) =&gt; {
    readFile(packagePath, "utf8", (err, content) =&gt; {
      if (err) {
        reject(err);
      } else {
        const { name, version } = JSON.parse(content);
        resolve(`${name}@${version}`);
      }
    });
  });</pre>
<p lang="en-GB">This file was written in a<a id="_idIndexMarker295"/> way that makes sense for us as developers, but cannot be run by Node.js directly. The problem is twofold. First, we are using ESM syntax without guaranteeing that Node.js supports this. Second, we are mixing ESM constructs such as <code>import</code> and <code>export</code> with CommonJS constructs such as <code>__dirname</code>.</p>
<p lang="en-GB">Luckily, we already installed <code>esbuild</code> to take care of this, with the defined <code>build</code> script actually using it for convenience:</p>
<pre class="console" lang="en-GB">
$ npm run build

&gt; lib-test-florian-rappl@1.0.0 build /home/node/code/example01

&gt; esbuild src/*.js --platform=node --outdir=lib --format=cjs

  lib/index.js  1.4kb

<img alt="" src="img/022.png"/> Done in 2ms</pre>
<p lang="en-GB">At this point, we have two directories in our project: <code>src</code>, containing the original sources, and <code>lib</code>, containing the CommonJS output. This is also reflected in <code>package.json</code>, where the source field points to <code>src/index.js</code> and the <code>main</code> field points to <code>lib/index.js</code>.</p>
<p lang="en-GB">Just as a reminder: the <code>main</code> field tells Node.js what module to use in case the package is included via <code>require</code> – for example, <code>require('lib-test-florian-rappl')</code> would reference and evaluate the <code>lib/index.js</code> file.</p>
<p lang="en-GB">Let’s say you want to <a id="_idIndexMarker296"/>publish this package now to the official npm registry. For this, you first need an account on <a href="https://npmjs.com/signup">npmjs.com/signup</a>. Once successfully registered and logged in, you should see a view similar to that in <em class="italic" lang="">Figure 8</em><em class="italic" lang="">.1</em>:</p>
<div><div><img alt="Figure 8.1 – The view on npmjs.com once logged in " src="img/Figure_8.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The view on npmjs.com once logged in</p>
<p lang="en-GB">On your own machine, you can now authenticate to the official npm registry by running the following:</p>
<pre class="console" lang="en-GB">
$ npm login</pre>
<p lang="en-GB">This will request your username and password. Alternatively, you could authenticate using so-called access tokens. This is especially useful for scripts, such as automation running in a CI/CD pipeline. To generate a new access token, follow the link highlighted in <em class="italic" lang="">Figure 8</em><em class="italic" lang="">.1</em>.</p>
<p lang="en-GB">Now that you have <a id="_idIndexMarker297"/>authenticated the <code>npm</code> utility, you can go ahead and publish your package:</p>
<pre class="console" lang="en-GB">
$ npm publish

npm notice

npm notice <img alt="" src="img/015.png"/>  lib-test-florian-rappl@1.0.0

npm notice === Tarball Contents ===

npm notice 1.5kB lib/index.js

npm notice 425B  src/index.js

npm notice 344B  package.json

npm notice === Tarball Details ===

npm notice name:          lib-test-florian-rappl

npm notice version:       1.0.0

npm notice package size:  1.1 kB

npm notice unpacked size: 2.3 kB

npm notice shasum:        2b5d224949f9112eeaee435a876a8ea15ed3e7cd

npm notice integrity:     sha512-cBq1czwmN4vep[...]/vXrORFGjRjnA==

npm notice total files:   3

npm notice

+ lib-test-florian-rappl@1.0.0</pre>
<p lang="en-GB">This will package your project as a compressed archive. Then, the utility will upload the tarball to the official npm registry.</p>
<p lang="en-GB">Now, you can go<a id="_idIndexMarker298"/> to <a href="https://npmjs.com">npmjs.com</a> to look for your package name. You should see the package info page similar to <em class="italic" lang="">Figure 8</em><em class="italic" lang="">.2</em> with more details about the published package. Note that we did not include a <code>README.md</code> or any keywords:</p>
<div><div><img alt="Figure 8.2 – The details of the published package " src="img/Figure_8.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The details of the published package</p>
<p lang="en-GB">One thing that you might consider is to give your package a scope. When you publish a package with a scope, then you’ll need to configure the access settings of the package. By default, non-scoped packages are public, and scoped packages are private.</p>
<p lang="en-GB">For publishing a scoped package to the official npm registry, you’ll first need to be either a member or owner of an organization on the npm website. The organization name must match the name of the scope.</p>
<p class="callout-heading" lang="en-GB">Package scope</p>
<p class="callout" lang="en-GB">A good way to group packages is to put them in a common scope. The scope has to start with an “@” symbol, which is followed by the name of the scope. The rules for the name of the scope are identical to package names. Besides grouping packages, scopes can be used to place certain packages in a different registry without much trouble. Most importantly, scopes can be reserved on the official npm registry, such that only authorized accounts can publish new packages using a reserved scope.</p>
<p lang="en-GB">To consistently <a id="_idIndexMarker299"/>publish a scoped package such as <code>@foo/bar</code> with public access, you need to modify the <code>package.json</code>. The relevant configuration is stored in a property called <code>publishConfig</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
<pre class="source-code" lang="en-GB">{
  "name": "@foo/bar",
  // ... like beforehand
  "publishConfig": {
    "access": "public"
  }
}</pre>
<p lang="en-GB">Alternatively, the access configuration could also be set directly when using the <code>npm publish</code> command with the <code>--</code><code>access=publish</code> flag.</p>
<p lang="en-GB">So far, we have only discussed how we can publish something to the official npm registry. What about choosing some other npm registry? For this, we need to change the <code>.</code><code>npmrc</code> file.</p>
<h1 id="_idParaDest-84" lang="en-GB"><a id="_idTextAnchor083"/>Selecting another npm registry via .npmrc</h1>
<p lang="en-GB">To configure the<a id="_idIndexMarker300"/> behavior of npm, a special file called <code>.npmrc</code> is used. We’ve already briefly touched on this file in <a href="B18989_03.xhtml#_idTextAnchor033"><em class="italic" lang="">Chapter 3</em></a>, <em class="italic" lang="">Choosing a Package Manager</em>. This file <a id="_idIndexMarker301"/>can be used not only to determine the source of the packages but also to define where to publish to.</p>
<p lang="en-GB">A simple modification might look as follows:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">.npmrc</p>
<pre class="source-code" lang="en-GB">; Lines starting with a semicolon or
# with a hash symbol are comments
registry=https://mycustomregistry.example.org</pre>
<p lang="en-GB">This way, all installations and publish attempts will be performed at <code>https://mycustomregistry.example.org</code> instead of the official registry located at <code>https://registry.npmjs.org</code>.</p>
<p lang="en-GB">Quite often, this extreme approach is unnecessary or even unwanted. Instead, you might only want to use <a id="_idIndexMarker302"/>another registry for a subset of the packages. In the most common case, the subset is already defined by a scope.</p>
<p lang="en-GB">Let’s say the <code>@foo</code> scope that <a id="_idIndexMarker303"/>we used in the previous section with the <code>@foo/bar</code> package should be bound to a custom registry, while all the other packages can still be resolved by the official one. The following <code>.npmrc</code> covers this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">.npmrc</p>
<pre class="source-code" lang="en-GB">@foo:registry=https://mycustomregistry.example.org</pre>
<p lang="en-GB">While the local <code>.npmrc</code> – that is, the one adjacent to a <code>package.json</code> of a project – should be used to define the registries, a global <code>.npmrc</code> – located in your home directory – should be used to provide information regarding authentication. Quite often, a private registry can only be used with such authentication information:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">~/.npmrc</p>
<pre class="source-code" lang="en-GB">//mycustomregistry.example.org/:username="myname"
//mycustomregistry.example.org/:_password="mysecret"
//mycustomregistry.example.org/:email=foo@bar.com
always-auth=true</pre>
<p lang="en-GB">The <code>always-auth</code> setting is used to tell <code>npm</code> that even <code>GET</code> requests – that is, requests for resolving or <a id="_idIndexMarker304"/>downloading packages – need to use the provided authentication.</p>
<p lang="en-GB">An easy way to test<a id="_idIndexMarker305"/> custom configuration is to roll out your own npm registry. A good way of doing that locally is to use the open source project <strong class="bold" lang="">Verdaccio</strong>.</p>
<h1 id="_idParaDest-85" lang="en-GB"><a id="_idTextAnchor084"/>Setting up Verdaccio</h1>
<p lang="en-GB">There are a couple <a id="_idIndexMarker306"/>of commercial registry options out there. Arguably, the most popular option is to get a pro plan for the official npm registry. This way, you’ll be able to publish and manage private packages. Whatever option you pick, you will always have to use a cloud version for publishing your packages.</p>
<p lang="en-GB">Especially for playing around with the publishing process, having a registry locally would be great. A great option is to leverage <code>npx</code>.</p>
<p lang="en-GB">Let’s go for the <code>npx</code> approach:</p>
<pre class="console" lang="en-GB">
$ npx verdaccio

 warn --- config file  - ~/.config/verdaccio/config.yaml

 info --- plugin successfully loaded: verdaccio-htpasswd

 info --- plugin successfully loaded: verdaccio-audit

 warn --- http address - http://localhost:4873/ - verdaccio/5.14.0</pre>
<p lang="en-GB">Now that Verdaccio is running, you can go to the URL shown in the console. You should see Verdaccio’s home page as shown in <em class="italic" lang="">Figure 8</em><em class="italic" lang="">.3</em>:</p>
<div><div><img alt="Figure 8.3 – The home page of Verdaccio with publishing instructions " src="img/Figure_8.3_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The home page of Verdaccio with publishing instructions</p>
<p lang="en-GB">Let’s say we want to publish the package we created earlier to Verdaccio instead of the official npm registry. The steps we need<a id="_idIndexMarker307"/> to follow are these:</p>
<ol>
<li lang="en-GB">Authenticate against the new registry (in Verdaccio, you can use whatever credentials you’d like by default, but <code>npm</code> requires you to authenticate)</li>
<li lang="en-GB">Either configure the URL to your running instance of Verdaccio via a <code>.npmrc</code> file or by explicitly using the <code>--registry</code> flag with the <code>npm </code><code>publish</code> command</li>
</ol>
<p lang="en-GB">In practice, these two steps look as follows:</p>
<pre class="console" lang="en-GB">
$ npm adduser --registry http://localhost:4873/

Username: foo

Password:

Email: (this IS public) foo@bar.com

Logged in as foo on http://localhost:4873/.

$ npm publish --registry http://localhost:4873

npm notice

npm notice <img alt="" src="img/015.png"/>  lib-test-florian-rappl@1.0.0

npm notice === Tarball Contents ===

npm notice 1.5kB lib/index.js

npm notice 425B  src/index.js

npm notice 344B  package.json

npm notice === Tarball Details ===

npm notice name:          lib-test-florian-rappl

npm notice version:       1.0.0

npm notice package size:  1.1 kB

npm notice unpacked size: 2.3 kB

npm notice shasum:        2b5d224949f9112eeaee435a876a8ea15ed3e7cd

npm notice integrity:     sha512-cBq1czwmN4vep[...]/vXrORFGjRjnA==

npm notice total files:   3

npm notice

+ lib-test-florian-rappl@1.0.0</pre>
<p lang="en-GB">Once published, the package is also listed on the website of the Verdaccio instance accessible at http://localhost:4873/. This, of course, is mostly useful for testing out a publishing process or for speeding up npm installations with a local cache. Most of the time, having a local<a id="_idIndexMarker308"/> npm registry is not really necessary.</p>
<p lang="en-GB">One question might come up at this point: how can we make sure that a published package can be used by most users? What requirements need to be fulfilled for actually using a package in a client-based application running in the browser, as well as in a server-based application running in Node.js?</p>
<p lang="en-GB">The concept of being pretty much target-independent is called being isomorphic. The terminology itself does not go uncriticized and some people actually prefer to call it universal. Having<a id="_idIndexMarker309"/> isomorphic code is great for gaining flexibility. Let’s see what is needed to deploy isomorphic packages.</p>
<h1 id="_idParaDest-86" lang="en-GB"><a id="_idTextAnchor085"/>Writing isomorphic libraries</h1>
<p lang="en-GB">The holy grail of web <a id="_idIndexMarker310"/>development is the ability to write code not solely for the frontend or the backend but for both parts. Many frameworks and tools try to give us this capability.</p>
<p lang="en-GB">To be accessible to multiple platforms, we not only need to ship multiple variants of our code but also only use APIs that are available on all supported platforms. For instance, if you want to make an HTTP request, then using <code>fetch</code> would be the right call for modern browsers. However, <code>fetch</code> was not available in less recent versions of Node.js. Therefore, you might need to solve this differently.</p>
<p lang="en-GB">In the case of HTTP requests, there are already isomorphic libraries available – that is, libraries that will just do the right thing depending on the target runtime. You should only depend on these libraries.</p>
<p class="callout-heading" lang="en-GB">Isomorphic fetch</p>
<p class="callout" lang="en-GB">The HTTP request problem can be solved in many ways – that is, by choosing an isomorphic library such as <code>axios</code> or <code>isomorphic-fetch</code>, the issue can be delegated to a dependency. The advantage of this method is that we do not need to find out what ways we need to follow on each platform. Additionally, testing and verification are much simpler that way.</p>
<p lang="en-GB">For now, we will focus on providing multiple variants. If we want to publish our library with support for multiple module formats – say CommonJS and ESM – we can do that by extending the <code>package.json</code>. Setting <code>type</code> to <code>module</code> will tell Node.js that the module referenced by the <code>main</code> field actually follows ESM. In addition, we can define all of the package’s exports explicitly – with an additional option to define what module to use depending on the used target platform and module system.</p>
<p lang="en-GB">Let’s see an example of this kind of configuration:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
<pre class="source-code" lang="en-GB">{
  // ... like beforehand
  "type": "module",
  "main": "dist/index.js",
  "exports": {
    ".": {
      "browser": {
        "require": "./lib/index.min.js",
        "default": "./dist/index.min.js"
      },
      "default": {
        "require": "./lib/index.js",
        "default": "./dist/index.js"
      }
    }
  }
}</pre>
<p lang="en-GB">In the case of our small library, there is a significant difference between the browser version and the non-browser<a id="_idIndexMarker311"/> version. However, for optimization, we’ve used minified modules for the browser, while all other platforms including Node.js will resolve to non-minified modules.</p>
<p lang="en-GB">To create output suitable for CommonJS, we can use the <code>build</code> script that we’ve derived already:</p>
<pre class="console" lang="en-GB">
$ esbuild src/*.js --platform=node --outdir=lib --format=cjs</pre>
<p lang="en-GB">The output for ESM is similar, but contains one important change:</p>
<pre class="console" lang="en-GB">
$ esbuild src/*.js --platform=node --outdir=dist --format=esm --define:__dirname="'.'"</pre>
<p lang="en-GB">The crucial change is to avoid using the <code>__dirname</code> global variable, which only works in Node.js using CommonJS. Instead, we just use the current directory. The change is not perfect, but should get the job done.</p>
<p lang="en-GB">Right now, everything seems to be well prepared – but actually, it’s not. The most important thing is still missing – the removal of the Node.js inbuilt package references. Our simple library references <code>fs</code> and <code>path</code>, but these packages do not exist in the browser. They would not <a id="_idIndexMarker312"/>know how to work there. Luckily, in this case, we have multiple solutions. The best one is arguably to replace the dynamic file read with a static import of the package’s <code>package.json</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.js</p>
<pre class="source-code" lang="en-GB">import { name, version } from '../package.json';
export function getLibName() {
  return `${name}@${version}`;
}</pre>
<p lang="en-GB">Of course, this kind of algorithmic change is not always possible. In the given scenario, we also benefit from <code>esbuild</code>’s bundle option, which will include the necessary parts from the referenced JSON file to produce an output file that matches our expectations.</p>
<p lang="en-GB">With these changes in mind, let’s see how the <code>build</code> scripts are defined:</p>
<pre class="source-code" lang="en-GB">{
  // ... like beforehand
  "scripts": {
    "build-cjs-node": "esbuild src/*.js --platform=node
      --outdir=lib --format=cjs",
    "build-cjs-browser": "esbuild src/*.js --platform=node
      --outdir=lib --bundle --format=cjs --minify --entry-
      names=[name].min",
    "build-cjs": "npm run build-cjs-node &amp;&amp; npm run build-
      cjs-browser",
    "build-esm-node": "esbuild src/*.js --platform=node
      --outdir=dist --format=esm",
    "build-esm-browser": "esbuild src/*.js --platform=node
      --outdir=dist --bundle --format=esm --minify --entry-
      names=[name].min",
    "build-esm": "npm run build-esm-node &amp;&amp; npm run build-
      esm-browser",
    "build": "npm run build-cjs &amp;&amp; npm run build-esm"
  }
}</pre>
<p lang="en-GB">It makes sense to define the scripts so that they can be run independently but also conveniently together without much effort. In many cases, the tool you’ve chosen has to be configured extensively to have the desired behavior. In the case of our example, <code>esbuild</code> was already quite<a id="_idIndexMarker313"/> equipped for the task – everything that we needed could be done via the command-line options.</p>
<p lang="en-GB">One additional case that can be covered with an npm package is to actually provide a tool. Ideally, these are tools to be run with Node.js making it a cross-platform tool. Let’s see how we can write and publish this kind of tool.</p>
<h1 id="_idParaDest-87" lang="en-GB"><a id="_idTextAnchor086"/>Publishing a cross-platform tool</h1>
<p lang="en-GB">Node.js would not be so powerful without its <a id="_idIndexMarker314"/>ecosystem. As we learned in <a href="B18989_01.xhtml#_idTextAnchor015"><em class="italic" lang="">Chapter 1</em></a>, <em class="italic" lang="">Learning the Internals of Node.js</em>, relying on the power of its ecosystem was an elementary design decision. Here, npm takes the leading role by defining the package metadata in <code>package.json</code>, as well as the installation of packages.</p>
<p lang="en-GB">During the installation of a package, a couple of things are happening. After the package has been downloaded, it will be copied to a target directory. For a local installation with <code>npm</code>, this is the <code>node_modules</code> folder. For a global installation with <code>npm</code>, the target will be globally available in your home directory. There is, however, one more thing to do. If the package contains a tool, then <a id="_idIndexMarker315"/>a reference to the tool will be put into a special directory, which is <code>node_modules/.bin</code> for a local installation.</p>
<p lang="en-GB">If you go back to the code from the previous chapter, you will see that, for example, <code>jest</code> is available in <code>node_modules/.bin</code>. This is the same <code>jest</code> executable that we started with <code>npx</code>. Let’s take the following:</p>
<pre class="console" lang="en-GB">
$ ./node_modules/.bin/jest --help</pre>
<p lang="en-GB">We can compare it to this:</p>
<pre class="console" lang="en-GB">
$ npx jest --help</pre>
<p lang="en-GB">Both will yield the same result. The reason is that <code>npx</code> for local installation is just a convenient tool to avoid writing out the path. As a reminder, you should opt for local installations over global installations.</p>
<p class="callout-heading" lang="en-GB">npx and npm</p>
<p class="callout" lang="en-GB"><code>npx</code> is another command that comes together with the installation of npm. From a command perspective, <code>npm</code> is used to manage the dependencies, while <code>npx</code> is used to run packages. The <code>npm</code> utility also has a <code>run</code> subcommand, which runs commands that are defined in the <code>scripts</code> section of <code>package.json</code>, whereas <code>npx</code> runs commands as defined in the <code>bin</code> section of npm packages.</p>
<p lang="en-GB">Now, the question is how can we create a package that also adds a script to the <code>.bin</code> folder so that it just works when installed? The answer lies in the <code>package.json</code> of our previous library.</p>
<p lang="en-GB">Let’s modify <code>package.json</code> a bit:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
<pre class="source-code" lang="en-GB">{
  "name": "@foo/tool",
  "version": "1.0.0",
  "description": "A simple tool greeting the user.",
  "bin": {
    "hello": "lib/hello.js"
  },
  "license": "MIT"
}</pre>
<p lang="en-GB">We added a <code>bin</code> section that defines a single script to be referenced from the <code>.bin</code> directory. The reference should be called <code>hello</code> and pointed to the <code>lib/hello.js</code> file within this package.</p>
<p lang="en-GB">Let’s also add the <a id="_idIndexMarker316"/>script to run when <code>hello</code> is called:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">hello.js</p>
<pre class="source-code" lang="en-GB">#!/usr/bin/env node
// check that at least one argument has been provided
if (process.argv.length &lt; 3) {
  console.log("No argument provided.");
  return process.exit(1);
}
// take the last argument
const name = process.argv.pop();
console.log(`Hello ${name}!`);</pre>
<p lang="en-GB">This will essentially check whether at least one argument was given and print a message in the console using the last argument.</p>
<p lang="en-GB">Let’s see the behavior when running directly via <code>node</code>:</p>
<pre class="console" lang="en-GB">
$ node hello.js

No argument provided.

$ node index.js foo

Hello foo!</pre>
<p lang="en-GB">Now, the package can be published as before – for example, by choosing our local Verdaccio instance:</p>
<pre class="console" lang="en-GB">
$ npm publish --registry http://localhost:4873</pre>
<p lang="en-GB">In a new project, you can now install the dependency and run the tool:</p>
<pre class="console" lang="en-GB">
$ npm install @foo/tool --registry http://localhost:4873

$ npx hello bar

Hello bar!</pre>
<p lang="en-GB">With that, we have seen<a id="_idIndexMarker317"/> the most crucial aspects regarding the publishing process of npm packages. Let’s recap what we have learned.</p>
<h1 id="_idParaDest-88" lang="en-GB"><a id="_idTextAnchor087"/>Summary</h1>
<p lang="en-GB">In this chapter, you have learned about what it takes to publish a package to an npm registry – whether it is an official or private one. You also touched on a commonly used npm registry in the form of Verdaccio.</p>
<p lang="en-GB">Equipped with the knowledge from this chapter, you should now be able to write reusable libraries that work in browser-based applications as well as in Node.js-based applications. You are also now capable of publishing tools that are based on Node.js. In a sense, these tools are just libraries with some additional fields in their associated package metadata.</p>
<p lang="en-GB">In the next chapter, we will have a look at a different approach to structuring code – placing multiple packages in a single repository known as a monorepo.</p>
</div>
</body></html>