- en: Chapter 8. Building a Multiplayer Draw-and-Guess Game with WebSockets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 使用 WebSocket 构建多人画图猜谜游戏
- en: '*We built several local single-player games in the previous chapters. In this
    chapter, we will build a multiplayer game with the help of WebSockets. WebSockets
    enable us to create event-based server-client architecture. The messages are passed
    between all connected browsers instantly. We will combine the Canvas drawing,
    JSON data packing, and several techniques learned in the previous chapters to
    build the draw-and-guess game.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前几章中，我们构建了几个本地单人游戏。在本章中，我们将借助 WebSocket 构建一个多人游戏。WebSocket 允许我们创建基于事件的客户端-服务器架构。消息会在所有连接的浏览器之间即时传递。我们将结合
    Canvas 绘图、JSON 数据打包以及在前几章中学到的几种技术来构建画图猜谜游戏。*'
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Trying an existing multiuser sketchpad that shows drawings from different connected
    users through WebSockets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一个现有的多用户绘图板，该绘图板通过 WebSocket 显示来自不同连接用户的绘画
- en: Installing a WebSocket server that is implemented by node.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装由 node.js 实现的 WebSocket 服务器
- en: Connecting the server from a browser
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从浏览器连接服务器
- en: Creating an instant chat room with the WebSocket API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WebSocket API 创建即时聊天室
- en: Creating a multiuser drawing pad in the Canvas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Canvas 中创建一个多用户绘图板
- en: Building a draw-and-guess game by integrating the chat room and drawing with
    game logic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过整合聊天室和绘图与游戏逻辑来构建画图猜谜游戏
- en: 'The following screenshot shows the draw-and-guess game that we will create
    in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本章我们将创建的画图猜谜游戏：
- en: '![Building a Multiplayer Draw-and-Guess Game with WebSockets](img/B04290_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![使用 WebSocket 构建多人画图猜谜游戏](img/B04290_08_01.jpg)'
- en: So, let's get on with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们继续吧。
- en: Installing a WebSocket server
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 WebSocket 服务器
- en: The HTML5 WebSocket provides a client-side API to connect a browser to a backend
    server. This server has to support the WebSockets protocol in order to keep the
    connection persistent.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 WebSocket 为浏览器提供了一个连接到后端服务器的客户端 API。该服务器必须支持 WebSocket 协议才能保持连接的持续性。
- en: Installing the Node.js WebSocket server
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Node.js WebSocket 服务器
- en: In this section, we will download and install a server named Node.js on which
    we can install a WebSockets module.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将下载并安装一个名为 Node.js 的服务器，我们可以在其上安装 WebSocket 模块。
- en: Time for action – installing Node.js
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候安装 Node.js 了
- en: Go to the URL, [http://nodejs.org](http://nodejs.org), which contains the source
    code of the Node.js server.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问包含 Node.js 服务器源代码的网址，[http://nodejs.org](http://nodejs.org)。
- en: Click on the **Install** button on the page. This downloads the installation
    package based on your operating system.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面上的 **安装** 按钮。这将根据您的操作系统下载安装包。
- en: 'Follow the installer''s instructions to install the Node.js package. After
    the installation, we can check whether Node.js is installed by checking its version
    with the following command:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装程序的说明安装 Node.js 软件包。安装完成后，我们可以通过以下命令检查 Node.js 是否已安装，并查看其版本：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command should print a version number of the node.js. In my case,
    it is version 0.12.0:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令应该打印出 node.js 的版本号。在我的情况下，它是版本 0.12.0：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also need to check whether the `npm` package manager is installed with the
    following command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要检查是否已通过以下命令安装了 `npm` 软件包管理器：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding command should print a version number of npm, Node.js packages
    manager. In my case, it is version 2.5.1.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令应该打印出 npm 的版本号，即 Node.js 软件包管理器。在我的情况下，它是版本 2.5.1。
- en: '*What just happened?*'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just downloaded and installed the `Node.js` server. We will build server
    logic on top of this environment. The WebSocket server does not necessarily run
    on Node.js. There are different server-side implementations of the WebSockets
    protocol. We chose Node.js because it uses JavaScript, and we are familiar with
    it after building four HTML5 games in the previous chapters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚下载并安装了 `Node.js` 服务器。我们将在这一环境之上构建服务器逻辑。WebSocket 服务器不一定运行在 Node.js 上。WebSocket
    协议有不同的服务器端实现。我们选择 Node.js 是因为它使用 JavaScript，我们在前几章构建了四个 HTML5 游戏后对其比较熟悉。
- en: There is a fork from Node.js named io.js ([http://iojs.org](http://iojs.org)).
    At the time of writing this book, io.js is still very new. It's worth checking
    the latest status and their differences on both platforms if you plan on using
    Node in future projects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Node.js 分支出来的一个名为 io.js ([http://iojs.org](http://iojs.org))。在撰写本书时，io.js
    仍然非常新。如果你计划在未来项目中使用 Node.js，值得检查这两个平台上的最新状态和它们之间的差异。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In some Linux distributions, the binary is renamed from `node` to `nodejs`.
    You can create a symbolic link of `nodejs` into `node` by using the following
    command. You may need `sudo` to run the command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Linux发行版中，二进制文件被重命名为`nodejs`。你可以使用以下命令将`nodejs`的符号链接创建到`node`。你可能需要`sudo`来运行此命令：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a WebSocket server to send connection count
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个发送连接数的WebSocket服务器
- en: We just installed the `node.js` server. Now, we will build something with WebSockets.
    Imagine now that we want a server that accepts connections from browsers and then
    sends the connection count to all users.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚安装了`node.js`服务器。现在，我们将使用WebSockets构建一些内容。想象一下，我们想要一个服务器，它可以接受来自浏览器的连接，然后将连接数发送给所有用户。
- en: Time for action – running a WebSocket server
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 运行WebSocket服务器
- en: Create a project folder for our code. Inside it, create a new directory named
    `server`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的代码创建一个项目文件夹。在其内部，创建一个名为`server`的新目录。
- en: Use a terminal or the shell command prompt to change the directory into our
    newly created folder.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用终端或shell命令提示符切换到我们新创建的文件夹。
- en: 'Type the following command that will install a WebSocket server:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以安装WebSocket服务器：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new file named `server.js` under the `server` directory with the following
    content:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server`目录下创建一个名为`server.js`的新文件，内容如下：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the terminal and change to the server directory.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并切换到服务器目录。
- en: 'Type the following command to execute the server:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以执行服务器：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get the following result if this works:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该会得到以下结果：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just created a simple server logic that initialized the WebSockets library
    and listened to the connection event.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个简单的服务器逻辑，初始化了WebSockets库并监听了连接事件。
- en: Initializing the WebSocket server
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化WebSocket服务器
- en: 'In `Node.JS`, different functions are packed into modules. When we need a functionality
    in a specific module, we use `require` to load it. We load the WebSockets module
    and then initialize the server using the following code in the server logic:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Node.JS`中，不同的功能被封装到模块中。当我们需要特定模块的功能时，我们使用`require`来加载它。我们在服务器逻辑中使用以下代码加载WebSockets模块并初始化服务器：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the `ws` module is managed by `npm`, it's installed inside a folder called
    `node_modules`. When we require a library with only the name, the Node.js runtime
    looks for that module in the `node_modules` folder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ws`模块由`npm`管理，它被安装在一个名为`node_modules`的文件夹中。当我们仅使用名称要求一个库时，Node.js运行时会查找`node_modules`文件夹中的该模块。
- en: We used `8000` as the server's port number, with which a client connects to
    this server. We may choose a different port number, but we have to ensure that
    the chosen port number is not overlapped by other common server services.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`8000`作为服务器的端口号，客户端通过这个端口号连接到服务器。我们可以选择不同的端口号，但必须确保所选端口号没有被其他常见服务器服务占用。
- en: Listening to the connection event on the server side
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端监听连接事件
- en: 'The `node.js` server is event based. This means that most of the logic is executed
    when a certain event is fired. The following code that we used in the example
    listens to the `connection` event and handles it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`node.js`服务器是事件驱动的。这意味着大多数逻辑都是在某个事件被触发时执行的。我们在示例中使用的以下代码监听`connection`事件并处理它：'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `connection` event comes with a socket argument. We will need to store this
    socket later because we use this object to interact with the connecting client.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection`事件带有socket参数。我们稍后需要存储这个socket，因为我们使用这个对象与连接的客户端交互。'
- en: Creating a client that connects to a WebSocket server and getting the total
    connections count
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个客户端连接到WebSocket服务器并获取总连接数
- en: We built the server in the last example, and now, we will build a client that
    connects to our WebSocket server and receives messages from the server. The message
    will contain the total connection count from the server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们构建了服务器，现在，我们将构建一个连接到我们的WebSocket服务器并接收服务器消息的客户端。消息将包含来自服务器的总连接数。
- en: Time for action – showing the connection count in a WebSocket application
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 在WebSocket应用程序中显示连接数
- en: 'Carry out the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a new directory named `client`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`client`的新目录。
- en: Create an HTML file named `index.html` in the `client` folder.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`client`文件夹中创建一个名为`index.html`的HTML文件。
- en: 'Now, add a few markups in our HTML file. To do this, put the following code
    in the `index.html` file:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的HTML文件中添加一些标记。为此，将以下代码放入`index.html`文件中：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a directory named `js` and put the jQuery JavaScript file inside it.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`js`的目录，并将jQuery JavaScript文件放入其中。
- en: 'Create a new file named `html5games.websockets.js` as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `html5games.websockets.js` 的新文件，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After these steps, we should have the following folder structure created in
    our project directory:![Time for action – showing the connection count in a WebSocket
    application](img/B04290_08_12.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成这些步骤后，我们应该在我们的项目目录中创建以下文件夹结构：![Time for action – showing the connection count
    in a WebSocket application](img/B04290_08_12.jpg)
- en: We will now test the code. First, you need to run the node server with our `server.js`
    code using `node` `server.js` in the **server** directory in the terminal.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将测试代码。首先，你需要使用 `node` 在终端中的 **server** 目录运行我们的 `server.js` 代码，即使用 `node
    server.js`。
- en: Next, open the `index.html` file in the client directory, in a web browser twice
    so that we have two client instances running side by side.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在客户端目录中，使用网页浏览器打开 `index.html` 文件两次，以便我们有两个客户端实例并行运行。
- en: 'Inspect the server terminal. There should be log messages similar to the following
    indicating the connection information and the total connection count:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查服务器终端。应该有类似于以下内容的日志消息，指示连接信息和总连接数：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the two web browsers, open the console in **Developer Tools**. You should
    also see the **WebSocket connection established** message in the console.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个网页浏览器中，打开 **开发者工具** 中的控制台。你应该在控制台中看到 **WebSocket 连接已建立** 的消息。
- en: '*What just happened?*'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just built a client that established a WebSockets connection to the server
    that we built in the last section. The client would then print any messages that
    are received from the server to the console panel in the **Inspector** of **Developer
    Tools**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个客户端，该客户端建立了与我们在上一节中构建的服务器的 WebSocket 连接。然后客户端会将从服务器接收到的任何消息打印到 **开发者工具**
    的 **检查器** 中的控制台面板。
- en: Establishing a WebSocket connection
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立WebSocket连接
- en: 'In any browser that supports WebSockets, we can establish a connection by creating
    a new WebSocket instance with the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何支持 WebSocket 的浏览器中，我们可以通过创建一个新的 WebSocket 实例来建立连接，以下代码所示：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `url` argument is a string with the WebSockets URL. In our example, we are
    running our server locally. Therefore, the URL we have used is `ws://127.0.0.1:8000`,
    where 8000 represents the port number of the server to which we are connecting.
    It is 8000 because the server was listening to port 8000 when we built the server-side
    logic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`url` 参数是一个包含 WebSocket URL 的字符串。在我们的例子中，我们正在本地运行我们的服务器。因此，我们使用的 URL 是 `ws://127.0.0.1:8000`，其中
    8000 代表我们连接的服务器端口号。它是 8000，因为当我们在服务器端构建逻辑时，服务器正在监听端口号 8000。'
- en: WebSocket client events
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket 客户端事件
- en: 'Similar to the server, we have several WebSocket events on the client side.
    The following table lists the events that we will use to deal with WebSockets:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器类似，客户端也有几个 WebSocket 事件。以下表格列出了我们将用于处理 WebSocket 的事件：
- en: '| Event name | Description |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 事件名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `onopen` | This is fired when a connection to the server is established |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `onopen` | 当建立到服务器的连接时触发 |'
- en: '| `onmessage` | This is fired when any message from the server is received
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `onmessage` | 当收到来自服务器的任何消息时触发 |'
- en: '| `onclose` | This is fired when the server closes the connection |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `onclose` | 当服务器关闭连接时触发 |'
- en: '| `onerror` | This is fired when there is any error in the connection |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `onerror` | 当连接出现任何错误时触发 |'
- en: Sending a message to all connected browsers
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向所有连接的浏览器发送消息
- en: Once the server gets a new `connection` event, we send the updated count of
    the connection to all clients. Sending a message to all clients is easy. We just
    need to call the `sendAll` function in the `server` instance with a `string` argument
    as the message.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器接收到新的 `connection` 事件，我们将连接的更新计数发送给所有客户端。向所有客户端发送消息很简单。我们只需在 `server` 实例中调用
    `sendAll` 函数，并将 `string` 类型的消息作为参数即可。
- en: 'The following code snippet sends a server message to all connected browsers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段向所有连接的浏览器发送服务器消息：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Time for action – sending total count to all users
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Time for action – sending total count to all users
- en: 'Perform the following steps to create our foundation logic for the game:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建游戏的基础逻辑：
- en: In the server folder, we create a new file named `game.js`. We will store the
    room and game logic in this file.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器文件夹中，我们创建一个名为 `game.js` 的新文件。我们将在这个文件中存储房间和游戏逻辑。
- en: We define a `User` class that stores the socket connection object and creates
    a random ID.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个 `User` 类，该类存储套接字连接对象并创建一个随机 ID。
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We also define a `Room` class. We store a collection of user instances in this
    class.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了一个 `Room` 类。我们在这个类中存储用户实例的集合。
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We define the two instance methods in the `Room` class that manages the adding
    and removing of users.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`Room`类中定义了两个实例方法，用于管理用户的添加和删除。
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we define another method that is in charge of sending messages to all
    the connected users in the room:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义另一个负责向房间中所有已连接用户发送消息的方法：
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before moving on, we need to export our newly defined `User` and `Room` classes
    to let other files use them:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要将新定义的`User`和`Room`类导出，以便其他文件可以使用它们：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `server.js` file, we replace the connection handler with the following
    code, which sends the user count to all the connected users:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server.js`文件中，我们用以下代码替换连接处理器，该代码将用户计数发送给所有已连接的用户：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We then move to the client. In the `html5games.websocket.js` file inside the
    **clients** | **js** folder, we add a handler to print out the messages received
    from the server.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着转向客户端。在**clients** | **js**文件夹内的`html5games.websocket.js`文件中，我们添加一个处理器来打印从服务器接收到的消息。
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, we test the code. Launch the server by executing `node` `server.js`
    in the server directory. Then, open the `index.html` file, and we should see something
    similar to the following screenshot on the console:![Time for action – sending
    total count to all users](img/B04290_08_02.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们测试代码。在服务器目录中执行`node server.js`来启动服务器。然后打开`index.html`文件，我们应该在控制台看到以下类似的截图：![行动时间
    - 向所有用户发送总计数](img/B04290_08_02.jpg)
- en: '*What just happened?*'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: We defined two classes, `User` and `Room`, in a `game.js` file, which we use
    to manage all the connected sockets.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`game.js`文件中定义了两个类，`User`和`Room`，我们使用它们来管理所有连接的套接字。
- en: Defining class and instant instance methods
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类和实例方法
- en: In JavaScript, **object-oriented programming** is done by using functions and
    prototypes. When we create a room instance by calling `new` `Room()`, the browser
    clones all properties and methods in `Room.prototype` to the instance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，**面向对象编程**是通过使用函数和原型来实现的。当我们通过调用`new Room()`创建一个房间实例时，浏览器会将`Room.prototype`中的所有属性和方法克隆到实例中。
- en: Handling a newly connected user
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理新连接的用户
- en: For each connected user, we need to interact with them via an events handler.
    We add the user object into an array for easy management. We need to handle the
    `onclose` event when a user disconnects. To do this, we remove that user from
    the array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个已连接的用户，我们需要通过事件处理器与他们交互。我们将用户对象添加到数组中以方便管理。我们需要处理用户断开连接时的`onclose`事件。为此，我们将该用户从数组中删除。
- en: Exporting modules
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出模块
- en: 'After defining our classes in the `game.js` file, we exported them. By exporting
    them to the module, we can import them in the other file by using the `require`
    method, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`game.js`文件中定义我们的类之后，我们将它们导出。通过将它们导出到模块中，我们可以使用`require`方法在其他文件中导入它们，如下所示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sending messages to the client
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向客户端发送消息
- en: 'WebSockets have the ability to send messages from the server to a user. Traditionally,
    the client requests the server and then the server responds. In a socket server,
    all users are connected, so messages can be triggered and sent in both directions.
    Here, we loop through all the users to send a broadcast message:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets具有从服务器向用户发送消息的能力。传统上，客户端请求服务器，然后服务器响应。在套接字服务器中，所有用户都是连接的，因此消息可以双向触发和发送。在这里，我们遍历所有用户以发送广播消息：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then we listen to the server message on the client, by using the `onmessage`
    event handler.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过使用`onmessage`事件处理器在客户端监听服务器消息。
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Building a chatting application with WebSockets
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebSockets构建聊天应用
- en: We now know how many browsers are connected. Suppose we want to build a chat
    room where users can type a message in their respective browsers and send the
    message to all the connected users instantly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道有多少浏览器已连接。假设我们想要构建一个聊天室，用户可以在各自的浏览器中输入消息，并将消息立即发送给所有已连接的用户。
- en: Sending a message to the server
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向服务器发送消息
- en: We will let the user input a message and then send the message to the `node.js`
    server. The server will then forward the message to all the connected browsers.
    Once a browser receives the message, it displays it in the chat area. In this
    case, the users are connected to the instant chat room once they load the web
    page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让用户输入一条消息，然后将消息发送到`node.js`服务器。服务器然后将消息转发给所有已连接的浏览器。一旦浏览器接收到消息，它就会在聊天区域显示出来。在这种情况下，用户在加载网页后就会连接到即时聊天室。
- en: Time for action – sending a message to the server through WebSockets
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 通过WebSockets向服务器发送消息
- en: First, code the server logic.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编写服务器逻辑。
- en: 'Open `servergame.js`. Add the following function to the file that handles user
    messages:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`servergame.js`。向文件中添加以下处理用户消息的功能：
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code inside the `Room.prototype.addUser` method that calls
    our newly created function:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用我们新创建函数的`Room.prototype.addUser`方法内部添加以下代码：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, move on to the `client` folder.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到`client`文件夹。
- en: 'Open the `index.html` file and add the following markup in the `body` section.
    This provides inputs for the user to type and send messages to the server:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.html`文件，在`body`部分添加以下标记。这为用户提供输入以向服务器发送消息：
- en: '[PRE27]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, add the following code to the `html5games.websocket.js` JavaScript file.
    This sends the message to the server when the user clicks on the `send` button
    or presses the *Enter* key:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下代码添加到`html5games.websocket.js` JavaScript文件中。当用户点击`send`按钮或按*Enter*键时，这将向服务器发送消息：
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before testing our code, check the server terminal and see whether the node
    server is still running. Press *Ctrl* + *C* to terminate it and run it again by
    using the `node` `server.js` command.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试我们的代码之前，检查服务器终端，看看node服务器是否仍在运行。按*Ctrl* + *C*来终止它，然后使用`node` `server.js`命令再次运行它。
- en: Open `index.html` in a web browser. You should see an input text field with
    a **Send** button, as shown in the following screenshot:![Time for action – sending
    a message to the server through WebSockets](img/B04290_08_03.jpg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开`index.html`。你应该看到一个带有**发送**按钮的输入文本字段，如下面的截图所示：![执行动作 – 通过WebSockets向服务器发送消息](img/B04290_08_03.jpg)
- en: Try to type something in the input text field and then click on the **Send**
    button or press *Enter*. The input text will be cleared.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入文本字段中输入一些内容，然后点击**发送**按钮或按*Enter*键。输入文本将被清除。
- en: Now, switch to the server terminal, and you will see the server printing the
    text that we just sent. You can also put the browser and server terminal side
    by side to see how the message is sent instantly from the client to the server.
    The following screenshot shows the server terminal with messages from two connected
    browsers:![Time for action – sending a message to the server through WebSockets](img/B04290_08_04.jpg)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到服务器终端，你会看到服务器正在打印我们刚刚发送的文本。你还可以将浏览器和服务器终端并排放置，以查看消息是如何从客户端瞬间发送到服务器的。以下截图显示了包含来自两个连接浏览器的服务器终端：![执行动作
    – 通过WebSockets向服务器发送消息](img/B04290_08_04.jpg)
- en: '*What just happened?*'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just extended our connection example by adding an input text field for the
    users to type some text there and send it out. The text is sent as a message to
    the WebSocket server. The server will then print the received message in the terminal.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为用户添加一个输入文本字段来扩展我们的连接示例，让他们在那里输入一些文本并发送出去。文本作为消息发送到WebSocket服务器。然后，服务器将在终端打印收到的消息。
- en: Sending a message from the client to the server
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端向服务器发送消息
- en: 'In order to send a message from the client to the server, we call the following
    `send` method in the `WebSocket` instance:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从客户端向服务器发送消息，我们在`WebSocket`实例中调用以下`send`方法：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the following code snippet from our example, we get the message from the
    input text field and send it to the server:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们从输入文本字段获取消息并发送到服务器：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Receiving a message on the server side
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端接收消息
- en: On the server side, we need to handle the message we just sent from the client.
    We have an event named `message` in the connection instance in the WebSocket `node.js`
    library. We can listen to the connection message event to receive a message from
    each client connection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们需要处理从客户端发送的刚刚的消息。我们在WebSocket `node.js`库的连接实例中有一个名为`message`的事件。我们可以监听连接消息事件以接收每个客户端连接的消息。
- en: 'The following code snippet shows how we use the message event listener to print
    the message on the server terminal:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用消息事件监听器在服务器终端打印消息：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Sending every received message on the server side to create a chat room
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务器端接收到的每条消息发送出去以创建聊天室
- en: In the last example, the server could receive messages sent from browsers. However,
    the server does nothing except print the received messages in the terminal. Therefore,
    we will add some logic to the server to send the messages out.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，服务器可以接收来自浏览器的消息。然而，服务器除了在终端打印收到的消息外，没有做任何事情。因此，我们将向服务器添加一些逻辑来发送消息。
- en: Time for action – sending messages to all connected browsers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动作 – 向所有连接的浏览器发送消息
- en: 'Carry out the following steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `game.js` file in the **server** folder for the server-side logic.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**服务器**文件夹中打开`game.js`文件以查看服务器端逻辑。
- en: 'Add the following highlighted code to the message event listener handler:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到消息事件监听器处理器中：
- en: '[PRE32]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That is it for the server side. Move on to the `client` folder and open the
    `index.html` file.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端的实现到此结束。接下来，转到`client`文件夹并打开`index.html`文件。
- en: 'We want to display the chat messages in the chat history area. To do this,
    add the following code to the HTML file:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想在聊天历史区域显示聊天消息。为此，将以下代码添加到HTML文件中：
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we need the client-side JavaScript to handle the received message from
    the server. We used it to print it out into the console panel, replace the `console.log`
    code with the following highlighted code in the `onmessage` event handler:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要客户端JavaScript来处理从服务器接收到的消息。我们使用它将消息打印到控制台面板中，将`onmessage`事件处理器中的`console.log`代码替换为以下突出显示的代码：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's test our code. Terminate any running node server by pressing *Ctrl* +
    *C*. Then, run the server again.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试我们的代码。通过按*Ctrl* + *C*终止任何正在运行的node服务器。然后，再次运行服务器。
- en: Open the `index.html` file twice and put them side by side. Type something in
    the text field and press *Enter*. The message will appear on both the opened browsers.
    If you open many instances of the HTML file, the message would appear on all the
    browsers. The following screenshot shows two browsers displaying the chat history
    side by side:![Time for action – sending messages to all connected browsers](img/B04290_08_05.jpg)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开两次`index.html`文件并将它们并排放置。在文本字段中输入一些内容并按*Enter*键。消息将出现在所有打开的浏览器中。如果你打开了多个HTML文件实例，消息将出现在所有浏览器中。以下截图显示了两个浏览器并排显示聊天历史记录：![Time
    for action – sending messages to all connected browsers](img/B04290_08_05.jpg)
- en: '*What just happened?*'
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: This is an extension of our previous examples. We discussed how a server sends
    the connection count to all the connected clients. We also discussed how the client
    sends a message to the server. In this example, we combine these two techniques
    to let the server send the received messages to all the connected users.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前示例的扩展。我们讨论了服务器如何将连接计数发送给所有已连接的客户端。我们还讨论了客户端如何向服务器发送消息。在这个例子中，我们将这两种技术结合起来，让服务器将接收到的消息发送给所有已连接的用户。
- en: Comparing WebSockets with polling approaches
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Comparing WebSockets with polling approaches
- en: If you have ever built a web page's chat room by using a server-side language
    and a database, then you may wonder what the difference is between the WebSocket
    implementation and the traditional one.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用服务器端语言和数据库构建过网页聊天室，那么你可能想知道WebSocket实现与传统实现之间的区别。
- en: The traditional chat room method is often implemented by using a **polling**
    approach. The client asks the server for an update periodically. The server responds
    to the client with either no update or the updated data. However, the traditional
    approach has several problems. The client does not get new data updated from the
    server until the next time it asks the server. This means that the data update
    is periodically delayed with time and the response is not instant enough. If we
    want to improve this issue by shortening the polling duration, then more bandwidth
    is utilized because clients need to keep sending requests to the server.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的聊天室方法通常通过使用**轮询**方法实现。客户端定期向服务器请求更新。服务器以没有更新或更新数据的方式对客户端进行响应。然而，传统方法有几个问题。客户端直到下一次请求服务器之前都不会收到来自服务器的更新数据。这意味着数据更新会随着时间周期性地延迟，响应不够即时。如果我们想通过缩短轮询持续时间来改善这个问题，那么将利用更多的带宽，因为客户端需要不断向服务器发送请求。
- en: 'The following graph shows requests between the client and the server. It shows
    that many useless requests are sent, but the server responds to the client without
    any new data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了客户端和服务器之间的请求。它显示发送了许多无用的请求，但服务器在没有新数据的情况下对客户端进行了响应：
- en: '![Comparing WebSockets with polling approaches](img/B04290_08_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Comparing WebSockets with polling approaches](img/B04290_08_06.jpg)'
- en: 'There is a better polling approach named **long polling**: the client sends
    a request to the server and waits for the response. Instead of the traditional
    polling approach where the server responds with "no update", the server does not
    respond at all until there is something that needs to be pushed to the server.
    In this approach, the server can push something to clients whenever there is an
    update. Once a client receives a response from the server, it creates another
    request and waits for the next server notification. The following graph shows
    the long polling approach where clients ask for updates and the server responds
    only when there is an update:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更好的轮询方法叫做**长轮询**：客户端向服务器发送请求并等待响应。与传统的轮询方法不同，服务器不会在“无更新”时响应，而是在需要将某些内容推送到服务器时才响应。在这种情况下，服务器可以在有更新时随时向客户端推送内容。一旦客户端从服务器收到响应，它就会创建另一个请求并等待下一个服务器通知。以下图表显示了长轮询方法，其中客户端请求更新，服务器只在有更新时响应：
- en: '![Comparing WebSockets with polling approaches](img/B04290_08_07.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![比较WebSocket与轮询方法](img/B04290_08_07.jpg)'
- en: 'In the WebSockets approach, the number of requests are way less than the polling
    approach. This is because the connection between the client and server is persistent.
    Once the connection is established, a request from either the client side or the
    server side is sent only when there is any update. For instance, a client sends
    a message to the server when it wants to update something to the server. The server
    also sends messages to clients only when it needs to notify the clients of a data
    update. No other useless requests are sent during the connection. Therefore, less
    bandwidth is utilized. The following graph shows the WebSockets approach:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebSocket方法中，请求的数量远少于轮询方法。这是因为客户端和服务器之间的连接是持久的。一旦建立连接，只有当有更新时，客户端或服务器才会发送请求。例如，当客户端想要向服务器更新某些内容时，它会向服务器发送消息。服务器也只在需要通知客户端数据更新时向客户端发送消息。在连接期间不会发送其他无用的请求。因此，利用的带宽更少。以下图表显示了WebSocket方法：
- en: '![Comparing WebSockets with polling approaches](img/B04290_08_08.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![比较WebSocket与轮询方法](img/B04290_08_08.jpg)'
- en: Making a shared drawing whiteboard with Canvas and WebSockets
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canvas和WebSocket制作共享绘图白板
- en: Suppose we want a shared sketchpad. Anyone can draw something on the sketchpad
    and all others can view it. We learned how messages are communicated between clients
    and servers. We will go further and send drawing data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个共享的草图板。任何人都可以在草图板上绘制内容，其他人都可以查看。我们学习了客户端和服务器之间如何通信消息。我们将进一步发送绘图数据。
- en: Building a local drawing sketchpad
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建本地绘图草图板
- en: Before we deal with data sending and server handling, let's focus on making
    a drawing whiteboard. We will use the Canvas to build a local drawing sketchpad.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理数据发送和服务器处理之前，让我们专注于制作一个绘图白板。我们将使用Canvas来构建一个本地绘图草图板。
- en: Time for action – making a local drawing whiteboard with the Canvas
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践时间 - 使用Canvas制作本地绘图白板
- en: 'Carry out the following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We will focus only on the client side in this section. Open the `index.html`
    file and add the following `canvas` markup:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，我们将只关注客户端。打开`index.html`文件并添加以下`canvas`标记：
- en: '[PRE35]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will draw something in the Canvas and we will need the mouse position relative
    to the Canvas for this. We did this in [Chapter 4](ch04.html "Chapter 4. Building
    the Untangle Game with Canvas and the Drawing API"), *Building the Untangle Game
    with Canvas and the Drawing API*. Add the following style to the Canvas:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在Canvas上绘制一些内容，为此我们需要Canvas的鼠标位置。我们在[第4章](ch04.html "第4章。使用Canvas和绘图API构建Untangle游戏")中这样做过，即*使用Canvas和绘图API构建Untangle游戏*。向Canvas添加以下样式：
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then, open the `html5games.websocket.js` JavaScript file to add the drawing
    logic.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`html5games.websocket.js`JavaScript文件以添加绘图逻辑。
- en: 'Replace the `websocketGame` global object with the following variable at the
    top of the JavaScript file:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript文件顶部将`websocketGame`全局对象替换为以下变量：
- en: '[PRE37]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the jQuery `ready` function, add the following mouse event handler code.
    The code handles the mouse''s down, move, and up events:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery的`ready`函数中，添加以下鼠标事件处理代码。该代码处理鼠标的按下、移动和抬起事件：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At last, we have the following function to draw a line in the Canvas with the
    given starting and ending points:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有以下函数来在Canvas上根据给定的起始点和结束点绘制线条：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Save all files and open the `index.html` file. You should see an empty space
    where you can draw something by using the mouse. The drawings are not sent to
    the server yet, so others cannot view your drawings:![Time for action – making
    a local drawing whiteboard with the Canvas](img/B04290_08_13.jpg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并打开 `index.html` 文件。你应该看到一个空白区域，你可以使用鼠标在这里绘制东西。绘图尚未发送到服务器，所以其他人无法查看你的绘图：![动手实践
    – 使用 Canvas 创建本地绘图白板](img/B04290_08_13.jpg)
- en: '*What just happened?*'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just created a local drawing pad. This is like a whiteboard where the player
    can draw in the Canvas by dragging the mouse. However, the drawing data is not
    sent to the server yet; all drawings are only displayed locally.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个本地绘图板。这就像一个白板，玩家可以通过拖动鼠标在 Canvas 上绘图。然而，绘图数据尚未发送到服务器；所有绘图都仅在本地显示。
- en: The `drawing` `line` function is the same that we used in [Chapter 4](ch04.html
    "Chapter 4. Building the Untangle Game with Canvas and the Drawing API"), *Building
    the Untangle Game with Canvas and the Drawing API*. We also used the same code
    to get the mouse position relative to the `canvas` element. However, the logic
    of the mouse events is different from [Chapter 4](ch04.html "Chapter 4. Building
    the Untangle Game with Canvas and the Drawing API"), *Building the Untangle Game
    with Canvas and the Drawing API*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawing` `line` 函数与我们之前在 [第 4 章](ch04.html "第 4 章. 使用 Canvas 和绘图 API 构建Untangle游戏")
    中使用的相同，即 *使用 Canvas 和绘图 API 构建 Untangle 游戏*。我们也使用了相同的代码来获取相对于 `canvas` 元素的鼠标位置。然而，鼠标事件的逻辑与
    [第 4 章](ch04.html "第 4 章. 使用 Canvas 和绘图 API 构建 Untangle 游戏") 不同。'
- en: Drawing in the Canvas
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Canvas 中绘图
- en: When we draw something on the computer, it often means that we click on the
    Canvas and drag the mouse (or pen). The line is drawn until the mouse button is
    up. Then, the user clicks on another place and drags again to draw lines.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在电脑上绘图时，通常意味着我们点击 Canvas 并拖动鼠标（或笔）。线条会一直绘制，直到鼠标按钮抬起。然后，用户点击另一个地方并再次拖动以绘制线条。
- en: In our example, we have a Boolean flag named `isDrawing` to indicate whether
    the user is drawing. The `isDrawing` flag is `false` by default. When the mouse
    button is at a point, we turn the flag to `true`. When the mouse is moving, we
    draw a line between the moved point and the last point when the mouse button was.
    Then, we set the `isDrawing` flag to `false` when the mouse button is up. This
    is how the drawing logic works.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们有一个名为 `isDrawing` 的布尔标志，用来指示用户是否在绘图。默认情况下，`isDrawing` 标志为 `false`。当鼠标按钮位于某个点时，我们将标志设置为
    `true`。当鼠标移动时，我们在移动的点与鼠标按钮按下时的最后一个点之间画线。然后，当鼠标按钮抬起时，我们将 `isDrawing` 标志设置为 `false`。这就是绘图逻辑的工作方式。
- en: Have a go hero – drawing with colors
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄试炼 – 使用颜色绘图
- en: Can we modify the drawing sketchpad by adding color support? How about adding
    five buttons with red, blue, green, black, and white colors? The player can choose
    the color when drawing. Alternatively, we can also provide different brush width
    options to the user.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否通过添加颜色支持来修改绘图草图板？比如添加红色、蓝色、绿色、黑色和白色的五个按钮？玩家可以在绘图时选择颜色。或者，我们也可以为用户提供不同的笔宽选项。
- en: Sending the drawing to all the connected browsers
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将绘图发送到所有连接的浏览器
- en: We will go further by sending our drawing data to the server and let the server
    send the drawing to all the connected browsers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进一步通过将我们的绘图数据发送到服务器，并让服务器将绘图发送到所有连接的浏览器。
- en: Time for action – sending the drawing through WebSockets
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 – 通过 WebSocket 发送绘图
- en: 'Carry out the following steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First, we need to modify the server logic. Open the `game.js` file and add
    two constants at the beginning of the file, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要修改服务器逻辑。打开 `game.js` 文件，并在文件开头添加两个常量，如下所示：
- en: '[PRE40]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `Room.prototype.addUser` method, add the following code at the beginning
    of the method:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Room.prototype.addUser` 方法中，在方法开头添加以下代码：
- en: '[PRE41]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We use JSON-formatted string for communicating both drawing actions and chat
    messages. Add the following code to the user sockets on the message event handler:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 JSON 格式的字符串来传递绘图动作和聊天消息。在用户消息事件处理程序的用户套接字上添加以下代码：
- en: '[PRE42]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `server.js`, there is no need to send the welcome message to the room since
    this is now handled by the `Room.addUser` method. Remove the following code from
    the `server.js` file:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `server.js` 文件中，由于现在由 `Room.addUser` 方法处理，因此不需要向房间发送欢迎消息。从 `server.js` 文件中删除以下代码：
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: On the client side, we need the logic to respond to the server with the same
    data object definition. Open the `html5games.websocket.js` JavaScript file in
    the **js** directory under **client**.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端，我们需要逻辑来响应服务器，使用相同的数据对象定义。在**client**目录下的**js**目录中打开`html5games.websocket.js`
    JavaScript文件。
- en: Add the following constants to the `websocketGame` global variable. The same
    constants with the same values are also defined in the server-side logic.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下常量添加到`websocketGame`全局变量中。这些相同的常量及其相同的值也在服务器端逻辑中定义。
- en: '[PRE44]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When handling the message event on the client-side, convert the JSON-formatted
    string back to the data object. If the data is a chat message, then we display
    it as the chat history, otherwise we draw it in the Canvas as a line segment.
    Replace the `onmessage` event handler with the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在客户端处理消息事件时，将JSON格式的字符串转换回数据对象。如果数据是聊天消息，则将其显示为聊天历史，否则将其绘制在Canvas上作为线段。将`onmessage`事件处理器替换为以下代码：
- en: '[PRE45]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the mouse is moving, we not only draw the line in the Canvas but also
    send the line data to the server. Add the following highlighted code to the `mousemove`
    event handler:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当鼠标移动时，我们不仅会在Canvas中绘制线条，还会将线条数据发送到服务器。将以下高亮代码添加到`mousemove`事件处理器中：
- en: '[PRE46]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Lastly, we need to modify the send message logic. We now pack the message in
    an object and format it as JSON when sending it to the server. Change the `sendMessage`
    function to the following code:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要修改发送消息的逻辑。现在，我们在将消息发送到服务器时，将其打包成一个对象并以JSON格式进行格式化。将`sendMessage`函数更改为以下代码：
- en: '[PRE47]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Save all the files and relaunch the server.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并重新启动服务器。
- en: Open the `index.html` file in two browser instances.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个浏览器实例中打开`index.html`文件。
- en: First, try the chat room feature by typing some messages and sending them. Then,
    try drawing something in the Canvas. Both browsers should display the same drawing,
    as shown in the following screenshot:![Time for action – sending the drawing through
    WebSockets](img/B04290_08_10.jpg)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，尝试聊天室功能，输入一些消息并发送它们。然后，尝试在Canvas上绘制一些东西。两个浏览器应该显示相同的绘图，如下面的截图所示：![行动时间 –
    通过WebSockets发送绘图](img/B04290_08_10.jpg)
- en: '*What just happened?*'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just built a multiuser sketchpad. This is similar to the sketchpad we tried
    at the beginning of this chapter. We extended what you learned when building a
    chat room by sending a complex data object as a message.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个多用户绘图板。这与我们在本章开头尝试的绘图板类似。我们通过发送一个复杂的数据对象作为消息，扩展了你在构建聊天室时学到的内容。
- en: Defining a data object to communicate between the client and the server
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数据对象以在客户端和服务器之间通信
- en: In order to communicate correctly between the server and clients when there
    is a lot of data packed into one message, we have to define a data object that
    both the client and server understand.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个消息中包含大量数据时，为了在服务器和客户端之间正确通信，我们必须定义一个客户端和服务器都能理解的数据对象。
- en: 'There are several properties in the data object. The following table lists
    the properties and why we need them:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对象中有几个属性。以下表格列出了属性及其原因：
- en: '| Property name | Why we need this property |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 属性名称 | 我们为什么需要这个属性 |'
- en: '| --- | --- |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `dataType` | This is an important property that helps us to understand the
    entire data. The data is either a chat message or drawing line segment data. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `dataType` | 这是一个重要的属性，帮助我们理解整个数据。数据要么是聊天消息，要么是绘图线段数据。|'
- en: '| `sender` | If the data is a chat message, the client needs to know who sent
    the message. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `sender` | 如果数据是聊天消息，客户端需要知道谁发送了消息。|'
- en: '| `message` | When the data type is a chat message, we surely need to include
    the message content itself into the data object. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `message` | 当数据类型是聊天消息时，我们当然需要将消息内容本身包含到数据对象中。|'
- en: '| `startX` | When the data type is a drawing line segment, we include the *x*/*y*
    coordinates of the starting point of the line. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `startX` | 当数据类型是绘图线段时，我们包括线的起点的*x*/*y*坐标。|'
- en: '| `startY` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `startY` |'
- en: '| `endX` | When the data type is a drawing line segment, we include the *x*/*y*
    coordinates of the ending point of the line. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `endX` | 当数据类型是绘图线段时，我们包括线的终点的*x*/*y*坐标。|'
- en: '| `endY` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `endY` |'
- en: 'In addition, we have the following constants defined on both the client side
    and the server side; these constants are for the `dataType` property:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还在客户端和服务器端定义了以下常量；这些常量用于`dataType`属性：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With these constants, we can compare datatypes with the following readable
    code, instead of using the meaningless Integer:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些常数，我们可以用以下可读的代码来比较数据类型，而不是使用无意义的整数：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Packing the drawing lines data into JSON for sending
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将绘图线条数据打包成JSON以发送
- en: We used the `JSON.stringify` function in the last chapter when we stored a JavaScript
    object into a JSON-formatted string in the local storage. Now, we need to send
    the data in string format between the server and the client. We use the same method
    to pack the drawing lines data into an object and send it as a JSON string.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用`JSON.stringify`函数将JavaScript对象存储到本地存储中的JSON格式字符串。现在，我们需要在服务器和客户端之间以字符串格式发送数据。我们使用相同的方法将绘图线条数据打包成一个对象，并以JSON字符串的形式发送。
- en: 'The following code snippet shows how we pack the line segment data on the client
    side and send it to the server with a JSON-formatted string:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何在客户端打包线段数据，并以JSON格式字符串的形式将其发送到服务器：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Recreating the drawing lines after receiving them from other clients
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在从其他客户端接收到绘图线条后重新创建绘图线条
- en: 'The JSON parsing often comes as a pair of `stringify`. When we receive a message
    from the server, we have to parse it to the JavaScript object. The following code
    on the client side parses the data and either updates the chat history or draws
    a line based on the data:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: JSON解析通常与`stringify`配对。当我们从服务器接收到消息时，我们必须将其解析为JavaScript对象。以下客户端的代码解析数据，并根据数据更新聊天历史或绘制线条：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Building a multiplayer draw-and-guess game
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建多人画猜游戏
- en: We built an instant chat room earlier in this chapter. Moreover, we just built
    a multiuser sketchpad. How about combining these two techniques and building a
    draw-and-guess game? A draw-and-guess game is a game in which one player is given
    a word to draw. All other players do not know the word and guess the word according
    to the drawing. The one who draws and who correctly guesses the word earn points.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们构建了一个即时聊天室。此外，我们刚刚构建了一个多用户绘图板。那么，将这两种技术结合起来构建一个画猜游戏怎么样？画猜游戏是一种游戏，其中一名玩家被分配一个单词来绘制。所有其他玩家不知道这个单词，根据绘图来猜测单词。绘制者和正确猜出单词的玩家得分。
- en: Time for action – building the draw-and-guess game
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 构建画猜游戏
- en: 'We will implement the game flow of the draw-and-guess game as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式实现画猜游戏的游戏流程：
- en: First, we will add the game logic on the client side.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在客户端添加游戏逻辑。
- en: 'Open the `index.html` file in the client directory. Add the following restart
    button right after the *send* button:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端目录中打开`index.html`文件。在*发送*按钮之后添加以下重启按钮：
- en: '[PRE52]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Open the `html5games.websocket.js` JavaScript.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`html5games.websocket.js` JavaScript文件。
- en: 'We need a few more constants to determine different states during the game
    play. Add the following highlighted code to the top of the file:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一些额外的常数来确定游戏过程中的不同状态。将以下突出显示的代码添加到文件顶部：
- en: '[PRE53]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In addition, we want a flag to indicate this player is in charge of drawing.
    Add the following Boolean global variable to the code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还想添加一个标志来指示这位玩家负责绘图。将以下布尔全局变量添加到代码中：
- en: '[PRE54]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When the client receives a message from the server, it parses it and checks
    whether it is a chat message or a line drawing. We have another type of message
    now named `GAME_LOGIC` for handling the game logic. The game logic message contains
    different data for different game states. Add the following code to the `onmessage`
    event handler:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端从服务器接收到消息时，它会解析消息并检查它是否是聊天消息或线条绘图。现在我们有一种新的消息类型名为`GAME_LOGIC`，用于处理游戏逻辑。游戏逻辑消息包含不同游戏状态的不同数据。将以下代码添加到`onmessage`事件处理器中：
- en: '[PRE55]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There is one last step in the client-side logic. We want to restart the game
    by sending a restart signal to the server. At the same time, we clear the drawing
    and chat history. To do this, add the following code inside the `html5games.websocket.js`
    file.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端逻辑中还有最后一步。我们希望通过向服务器发送重启信号来重启游戏。同时，我们清除绘图和聊天历史。为此，在`html5games.websocket.js`文件中添加以下代码。
- en: '[PRE56]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It is now time to move on to the server side. We need more states to control
    the game flow. Replace the constants at the beginning of the `game.js` file with
    the following code.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候转向服务器端了。我们需要更多的状态来控制游戏流程。将`game.js`文件开头的常数替换为以下代码。
- en: '[PRE57]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the previous example, the server side was just in charge of sending any incoming
    message to all connected browsers. This is not enough for a multiplayer game.
    The server will act as the game master that controls the game flow and determination
    of the winning condition. We extend the `Room` class with `GameRoom` that can
    handle the game flow.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的示例中，服务器端只是负责将任何传入的消息发送给所有已连接的浏览器。这对于多人游戏是不够的。服务器将作为游戏主持人，控制游戏流程和获胜条件的确定。我们通过`GameRoom`扩展`Room`类，使其能够处理游戏流程。
- en: Now, add the following code to the end of the `game.js` file. This is the constructor
    function of a new class called `GameRoom`, which initializes game logic.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`game.js`文件的末尾。这是名为`GameRoom`的新类的构造函数，它初始化游戏逻辑。
- en: '[PRE58]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Then, we extend the existing `Room` functionality into the `GameRoom` prototype
    so that `GameRoom` will have access to the `Room` class' prototype function by
    default.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将现有的`Room`功能扩展到`GameRoom`原型中，以便`GameRoom`默认可以访问`Room`类的原型函数。
- en: '[PRE59]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define the following `addUser` function in the `GameRoom` class. Append the
    code after our existing `GameRoom` code. This keeps the original room''s `addUser`
    function and adds extra logic that waits until enough players join to start the
    game:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameRoom`类中定义以下`addUser`函数。在现有的`GameRoom`代码之后附加代码。这保留了原始房间的`addUser`函数并添加了额外的逻辑，等待足够多的玩家加入以开始游戏：
- en: '[PRE60]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Unlike the previous example in which the server only passes user messages to
    all of the connected clients, now the server needs to determine whether the messages
    from the user are part of the game flow. Append the following code after the existing
    `GameRoom` logic; It overrides the original room''s `handleOnUserMessage` function
    into new logic that handles chat messages, line segments, and the control of the
    game flow:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的示例不同，其中服务器只是将用户消息传递给所有已连接的客户端，现在服务器需要确定用户的消息是否是游戏流程的一部分。在现有的`GameRoom`逻辑之后附加以下代码；它覆盖了原始房间的`handleOnUserMessage`函数，并引入了新的逻辑来处理聊天消息、线段和游戏流程的控制：
- en: '[PRE61]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s continue with the `GameRoom` logic. Add the following new function to
    the `game.js` file. This creates a new game inside the room by picking a player
    as a drawer and the others as guessers; then, it randomly picks a word for the
    drawer to draw:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续`GameRoom`逻辑。将以下新函数添加到`game.js`文件中。这个函数在房间内创建一个新的游戏，通过选择一个玩家作为绘图者，其他玩家作为猜测者；然后，随机为绘图者选择一个单词：
- en: '[PRE62]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'At last, we export the `GameRoom` class so that other files, such as `server.js`,
    can access the `GameRoom` class:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们导出`GameRoom`类，以便其他文件，如`server.js`，可以访问`GameRoom`类：
- en: '[PRE63]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In `server.js`, we must call our new `GameRoom` constructor instead of the
    generic `Room` constructor. Replace the original related code to `Room` with the
    following `GameRoom` code:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server.js`中，我们必须调用我们的新`GameRoom`构造函数而不是通用的`Room`构造函数。将原始与`Room`相关的代码替换为以下`GameRoom`代码：
- en: '[PRE64]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We will save all the files and relaunch the server. Then, we will launch the
    `index.html` file in two browser instances. One browser will get a message from
    the server informing the player to draw something. The other browser, on the other
    hand, will inform the player to guess what the other player is drawing within
    one minute.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保存所有文件并重新启动服务器。然后，在两个浏览器实例中启动`index.html`文件。一个浏览器将从服务器接收到一条消息，告知玩家绘制一些东西。另一方面，另一个浏览器将告知玩家在一分钟内猜测其他玩家正在绘制的内容。
- en: The player who is told to draw something can draw in the Canvas. The drawings
    are sent to all the other connected players. The players who are told to guess
    cannot draw anything in the Canvas. Instead, players type what they guess in the
    text field and send it to the server. If the guess is correct, then the game ends.
    Otherwise, the game continues until the one-minute countdown finishes.![Time for
    action – building the draw-and-guess game](img/B04290_08_11.jpg)
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被告知绘制东西的玩家可以在画布上绘制。这些绘画被发送给所有其他已连接的玩家。被告知猜测的玩家不能在画布上绘制任何东西。相反，玩家在文本字段中输入他们的猜测并发送给服务器。如果猜测正确，则游戏结束。否则，游戏将继续进行，直到一分钟倒计时结束。![行动时间
    - 构建绘制和猜测游戏](img/B04290_08_11.jpg)
- en: '*What just happened?*'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just created a multiplayer draw-and-guess game in WebSockets and Canvas.
    The main difference between the game and the multiuser sketchpad is that the server
    now controls the game flow instead of letting all the users draw.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在WebSockets和Canvas中创建了一个多人绘制和猜测游戏。游戏与多用户草图板的主要区别在于，现在服务器控制游戏流程，而不是让所有用户绘制。
- en: Inheriting the Room class
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承Room类
- en: 'In JavaScript, we can inherit a defined class with a new class. We define `GameRoom`
    that inherits the `Room` class. The `GameRoom` class will have the `Room` logic
    that it inherits plus the extra logic that is specifically designed for the game
    flow. Inheritance is done by creating an instance of the class into the prototype,
    as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们可以使用新类继承一个已定义的类。我们定义`GameRoom`类，它继承自`Room`类。`GameRoom`类将具有它继承的`Room`逻辑以及专门为游戏流程设计的额外逻辑。继承是通过将类的实例创建到原型中实现的，如下所示：
- en: '[PRE65]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, `GameRoom` has the prototype methods from `Room`. We can then define more
    logic in `GameRoom` such as the `startGame` method. We can also override the existing
    logic by defining a new prototype method in the `GameRoom` class with the same
    name; for example, we override the `handleOnUserMessage` method to send the game
    starting and winning logic.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`GameRoom`具有从`Room`继承的原型方法。我们可以在`GameRoom`中定义更多逻辑，例如`startGame`方法。我们还可以通过在`GameRoom`类中定义具有相同名称的新原型方法来覆盖现有逻辑；例如，我们覆盖了`handleOnUserMessage`方法来发送游戏开始和获胜逻辑。
- en: 'Sometimes, we want to extend an existing logic instead of replacing the old
    one with a new one. In such a case, we need to execute the logic that we have
    overridden by the method with the same name. We can use the following code to
    execute the method that''s in the original prototype; we used this approach in
    the `addUser` method to keep the original logic:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望扩展现有的逻辑而不是用新的逻辑替换旧的逻辑。在这种情况下，我们需要执行用同名方法覆盖的逻辑。我们可以使用以下代码来执行原始原型中的方法；我们在`addUser`方法中使用了这种方法来保持原始逻辑：
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Controlling the game flow of a multiplayer game
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制多人游戏的游戏流程
- en: Controlling the game flow of a multiplayer game is much more difficult than
    a single game. We can simply use a few variables to control the game flow of a
    single game, but we have to use message passing to inform each player of specific
    updated game flow.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 控制多人游戏的游戏流程比单机游戏要复杂得多。我们可以简单地使用几个变量来控制单机游戏的游戏流程，但我们必须使用消息传递来通知每个玩家特定的更新游戏流程。
- en: 'First, we require the following highlighted `GAME_LOGIC` constant for `dataType`.
    We use this data to send and receive a message that is related to the game logic
    control:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要以下高亮的`GAME_LOGIC`常量来指定`dataType`。我们使用这些数据来发送和接收与游戏逻辑控制相关的消息：
- en: '[PRE67]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: There are several states in the game flow. Before the game starts, the connected
    players are waiting for the game to start. Once there are enough connections for
    the multiplayer game, the server sends a game logic message to all the players
    to inform them of the start of the game.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏流程中有几个状态。在游戏开始之前，连接的玩家正在等待游戏开始。一旦有多人游戏所需的足够连接，服务器就会向所有玩家发送游戏逻辑消息，通知他们游戏开始。
- en: When the game is over, the server sends a game over state to all the players.
    Then, the game finishes and the game logic halts until any player clicks on the
    restart button. Once the restart button is clicked, the client sends a game restart
    state to the server instructing the server to prepare a new game. Then, the game
    starts again.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，服务器向所有玩家发送游戏结束状态。然后，游戏结束，游戏逻辑暂停，直到任何玩家点击重启按钮。一旦点击重启按钮，客户端就会向服务器发送游戏重启状态，指示服务器准备新游戏。然后，游戏再次开始。
- en: 'We declare the four game states as the following constants in both the client
    and server so that they understand them:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在客户端和服务器中都声明了以下四个游戏状态常量，以便他们理解：
- en: '[PRE68]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following code on the server side holds an index to indicate which player''s
    turn is now:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下服务器端的代码包含一个索引，指示现在是哪个玩家的回合：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The data which is sent to the player (whose turn it is) is different from the
    data that is sent to other players. The other players receive the following data
    with only a game start signal:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到玩家（轮到他的玩家）的数据与发送到其他玩家的数据不同。其他玩家只收到以下数据，带有游戏开始信号：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'On the other hand, the player (whose turn is to draw) receives the following
    data with the word information:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，轮到抽卡的玩家会收到以下数据，包含单词信息：
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Room and Game Room
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 房间和游戏房间
- en: 'By the end of this example, we have created two types of rooms: a normal room
    and a game room. Specifically, a normal room has the most basic features: managing
    users and chatting within the room. The game room, which is built on top of the
    normal room, adds another large block of logic to manage a draw-and-guess game
    flow. The game flow includes waiting for the game to start, starting the game,
    determining game over, and triggering time out. All these game flow controls are
    encapsulated into the `GameRoom` class.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到本例结束时，我们创建了两种类型的房间：一个普通房间和一个游戏房间。具体来说，普通房间具有最基本的功能：管理用户和房间内的聊天。游戏房间是在普通房间的基础上构建的，为管理一个画线猜画游戏流程添加了另一个大型逻辑块。游戏流程包括等待游戏开始、开始游戏、确定游戏结束和触发超时。所有这些游戏流程控制都被封装到`GameRoom`类中。
- en: In the future, we can easily expand the multiplayer game by adding different
    types of game into it. For example, we can create a 2-player tic-tac-toe game
    by creating a `TicTacToeGameRoom` class that shares similar waiting and restarting
    game logic in `GameRoom`. However, the `TicTacToeGameRoom` class will handle other
    game flows such as passing the game board data and handling a tied game. Since
    all game logic is encapsulated inside the specific game room, different types
    of multiplayer game won't affect each other.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们可以通过添加不同类型的游戏来轻松扩展多玩家游戏。例如，我们可以通过创建一个`TicTacToeGameRoom`类来创建一个两人井字棋游戏，该类在`GameRoom`中共享类似的等待和重启游戏逻辑。然而，`TicTacToeGameRoom`类将处理其他游戏流程，例如传递游戏板数据和处理平局。由于所有游戏逻辑都封装在特定的游戏房间中，不同类型的多人游戏不会相互影响。
- en: Improving the game
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进游戏
- en: We have just created a multiplayer game that is playable. However, there is
    still a lot to improve. In the following sections, we list two possible improvements
    of the game.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个可玩的多玩家游戏。然而，还有很多可以改进的地方。在接下来的章节中，我们列出了两种可能的改进方法。
- en: Improving the styles
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进样式
- en: The game looks very plain now. We can improve its visual outlook by adding CSS
    styles and decorative images to it. In the code bundle, you will find an example
    with extra CSS styles applied to make the game look better. You may try different
    styling effects also.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在看起来非常简单。我们可以通过添加CSS样式和装饰图像来改善其视觉外观。在代码包中，你可以找到一个示例，其中应用了额外的CSS样式来使游戏看起来更好。你也可以尝试不同的样式效果。
- en: Storing drawn lines on each game
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在每个游戏中存储画出的线条
- en: In the game, the drawer draws lines and other players guess the drawing. Now,
    imagine that two players are playing and the third player joins them. As there
    is no storage for the drawn lines anywhere, the third player cannot see what the
    drawer has drawn. This means that the third player has to wait until the game
    ends to play.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，画图者画线，其他玩家猜测画的是什么。现在，想象有两个玩家正在玩游戏，第三个玩家加入他们。由于没有地方存储画出的线条，第三个玩家看不到画图者画了什么。这意味着第三个玩家必须等到游戏结束才能开始玩。
- en: Have a go hero
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: How can we let a player who has joined late continue the game without losing
    the drawn lines? How can we reconstruct the drawing for a newly connected player?
    How about storing all drawing data of the current game on the server?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何让晚加入游戏的玩家继续游戏而不丢失画出的线条？我们如何为新连接的玩家重建绘画？将当前游戏的全部绘画数据存储在服务器上怎么样？
- en: Improving the answer checking mechanism
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进答案检查机制
- en: The answer checking on the server side compares the message with the `currentAnswer`
    variable to determine whether a player guessed correctly. The answer is treated
    as incorrect if the case does not match. It looks strange when the answer is "apples"
    and the player is told that their answer is wrong when they guess "apple".
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的答案检查将消息与`currentAnswer`变量进行比较，以确定玩家是否猜对了。如果字母大小写不匹配，则答案被视为错误。当答案是"apples"而玩家猜的是"apple"时，告诉玩家他们的答案是错误的看起来很奇怪。
- en: Have a go hero
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: How can we improve the answer checking mechanism? How about improving the answer
    checking logic to treat the answer as correct when using a different case or even
    similar words? The current game is quite plain in style. Please add your decoration
    to the game to make it more appealing to the players.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进答案检查机制？是否可以考虑改进答案检查逻辑，当使用不同的字母大小写或甚至相似的词语时，将答案视为正确？当前的游戏在风格上相当简单。请为游戏添加装饰，使其对玩家更具吸引力。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about connecting browsers to WebSockets. The
    messages and events from one browser are sent to all connected browsers in almost
    real time.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于将浏览器连接到WebSockets的知识。几乎实时地，一个浏览器的消息和事件被发送到所有连接的浏览器。
- en: Specifically, we learned how WebSockets provide real-time events by drawing
    on an existing multiplayer sketchpad. It shows drawings from other users who are
    connected. We chose Node.js as the server-side WebSocket server. By using this
    server, we can easily build an event-based server to handle WebSocket requests
    from browsers. We discussed the relationship between the server and a client,
    which compares WebSockets with other approaches such as long-polling. We built
    an instant chat room application. We learned how to implement a server script
    to send all incoming messages to other connected browsers. We also learned how
    to display a received message from the server on the client side. Next, we built
    a multiuser drawing board and finally a draw-and-guess game by integrating the
    chatting along with the drawing pad.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们学习了如何通过利用现有的多人绘图板来绘制，WebSockets 提供实时事件。它显示了其他连接用户的绘图。我们选择了 Node.js 作为服务器端的
    WebSocket 服务器。通过使用这个服务器，我们可以轻松构建一个基于事件的服务器来处理来自浏览器的 WebSocket 请求。我们讨论了服务器和客户端之间的关系，比较了
    WebSockets 与其他方法，如长轮询。我们构建了一个即时聊天室应用程序。我们还学习了如何实现一个服务器脚本，将所有传入的消息发送到其他连接的浏览器。我们还学习了如何在客户端显示从服务器接收到的消息。接下来，我们构建了一个多用户绘图板，并通过将聊天与绘图板集成，最终构建了一个画图猜谜游戏。
- en: Now that you have learned how to build a multiplayer game, we are ready to build
    physics games with the help of the physics engine in the next chapter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何构建多人游戏，我们准备在下一章中借助物理引擎来构建物理游戏。
