- en: Chapter 8. Building a Multiplayer Draw-and-Guess Game with WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We built several local single-player games in the previous chapters. In this
    chapter, we will build a multiplayer game with the help of WebSockets. WebSockets
    enable us to create event-based server-client architecture. The messages are passed
    between all connected browsers instantly. We will combine the Canvas drawing,
    JSON data packing, and several techniques learned in the previous chapters to
    build the draw-and-guess game.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Trying an existing multiuser sketchpad that shows drawings from different connected
    users through WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a WebSocket server that is implemented by node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the server from a browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an instant chat room with the WebSocket API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multiuser drawing pad in the Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a draw-and-guess game by integrating the chat room and drawing with
    game logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the draw-and-guess game that we will create
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Multiplayer Draw-and-Guess Game with WebSockets](img/B04290_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a WebSocket server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTML5 WebSocket provides a client-side API to connect a browser to a backend
    server. This server has to support the WebSockets protocol in order to keep the
    connection persistent.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Node.js WebSocket server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will download and install a server named Node.js on which
    we can install a WebSockets module.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – installing Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to the URL, [http://nodejs.org](http://nodejs.org), which contains the source
    code of the Node.js server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Install** button on the page. This downloads the installation
    package based on your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow the installer''s instructions to install the Node.js package. After
    the installation, we can check whether Node.js is installed by checking its version
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command should print a version number of the node.js. In my case,
    it is version 0.12.0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to check whether the `npm` package manager is installed with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command should print a version number of npm, Node.js packages
    manager. In my case, it is version 2.5.1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just downloaded and installed the `Node.js` server. We will build server
    logic on top of this environment. The WebSocket server does not necessarily run
    on Node.js. There are different server-side implementations of the WebSockets
    protocol. We chose Node.js because it uses JavaScript, and we are familiar with
    it after building four HTML5 games in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: There is a fork from Node.js named io.js ([http://iojs.org](http://iojs.org)).
    At the time of writing this book, io.js is still very new. It's worth checking
    the latest status and their differences on both platforms if you plan on using
    Node in future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some Linux distributions, the binary is renamed from `node` to `nodejs`.
    You can create a symbolic link of `nodejs` into `node` by using the following
    command. You may need `sudo` to run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating a WebSocket server to send connection count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just installed the `node.js` server. Now, we will build something with WebSockets.
    Imagine now that we want a server that accepts connections from browsers and then
    sends the connection count to all users.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – running a WebSocket server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a project folder for our code. Inside it, create a new directory named
    `server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a terminal or the shell command prompt to change the directory into our
    newly created folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following command that will install a WebSocket server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file named `server.js` under the `server` directory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the terminal and change to the server directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following command to execute the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following result if this works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a simple server logic that initialized the WebSockets library
    and listened to the connection event.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the WebSocket server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `Node.JS`, different functions are packed into modules. When we need a functionality
    in a specific module, we use `require` to load it. We load the WebSockets module
    and then initialize the server using the following code in the server logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since the `ws` module is managed by `npm`, it's installed inside a folder called
    `node_modules`. When we require a library with only the name, the Node.js runtime
    looks for that module in the `node_modules` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We used `8000` as the server's port number, with which a client connects to
    this server. We may choose a different port number, but we have to ensure that
    the chosen port number is not overlapped by other common server services.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to the connection event on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `node.js` server is event based. This means that most of the logic is executed
    when a certain event is fired. The following code that we used in the example
    listens to the `connection` event and handles it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `connection` event comes with a socket argument. We will need to store this
    socket later because we use this object to interact with the connecting client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a client that connects to a WebSocket server and getting the total
    connections count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We built the server in the last example, and now, we will build a client that
    connects to our WebSocket server and receives messages from the server. The message
    will contain the total connection count from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – showing the connection count in a WebSocket application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory named `client`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an HTML file named `index.html` in the `client` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add a few markups in our HTML file. To do this, put the following code
    in the `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a directory named `js` and put the jQuery JavaScript file inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file named `html5games.websockets.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After these steps, we should have the following folder structure created in
    our project directory:![Time for action – showing the connection count in a WebSocket
    application](img/B04290_08_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now test the code. First, you need to run the node server with our `server.js`
    code using `node` `server.js` in the **server** directory in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open the `index.html` file in the client directory, in a web browser twice
    so that we have two client instances running side by side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inspect the server terminal. There should be log messages similar to the following
    indicating the connection information and the total connection count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the two web browsers, open the console in **Developer Tools**. You should
    also see the **WebSocket connection established** message in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just built a client that established a WebSockets connection to the server
    that we built in the last section. The client would then print any messages that
    are received from the server to the console panel in the **Inspector** of **Developer
    Tools**.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a WebSocket connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In any browser that supports WebSockets, we can establish a connection by creating
    a new WebSocket instance with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `url` argument is a string with the WebSockets URL. In our example, we are
    running our server locally. Therefore, the URL we have used is `ws://127.0.0.1:8000`,
    where 8000 represents the port number of the server to which we are connecting.
    It is 8000 because the server was listening to port 8000 when we built the server-side
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket client events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the server, we have several WebSocket events on the client side.
    The following table lists the events that we will use to deal with WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `onopen` | This is fired when a connection to the server is established |'
  prefs: []
  type: TYPE_TB
- en: '| `onmessage` | This is fired when any message from the server is received
    |'
  prefs: []
  type: TYPE_TB
- en: '| `onclose` | This is fired when the server closes the connection |'
  prefs: []
  type: TYPE_TB
- en: '| `onerror` | This is fired when there is any error in the connection |'
  prefs: []
  type: TYPE_TB
- en: Sending a message to all connected browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the server gets a new `connection` event, we send the updated count of
    the connection to all clients. Sending a message to all clients is easy. We just
    need to call the `sendAll` function in the `server` instance with a `string` argument
    as the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet sends a server message to all connected browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – sending total count to all users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create our foundation logic for the game:'
  prefs: []
  type: TYPE_NORMAL
- en: In the server folder, we create a new file named `game.js`. We will store the
    room and game logic in this file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `User` class that stores the socket connection object and creates
    a random ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also define a `Room` class. We store a collection of user instances in this
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the two instance methods in the `Room` class that manages the adding
    and removing of users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define another method that is in charge of sending messages to all
    the connected users in the room:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before moving on, we need to export our newly defined `User` and `Room` classes
    to let other files use them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `server.js` file, we replace the connection handler with the following
    code, which sends the user count to all the connected users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then move to the client. In the `html5games.websocket.js` file inside the
    **clients** | **js** folder, we add a handler to print out the messages received
    from the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we test the code. Launch the server by executing `node` `server.js`
    in the server directory. Then, open the `index.html` file, and we should see something
    similar to the following screenshot on the console:![Time for action – sending
    total count to all users](img/B04290_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We defined two classes, `User` and `Room`, in a `game.js` file, which we use
    to manage all the connected sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Defining class and instant instance methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, **object-oriented programming** is done by using functions and
    prototypes. When we create a room instance by calling `new` `Room()`, the browser
    clones all properties and methods in `Room.prototype` to the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Handling a newly connected user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For each connected user, we need to interact with them via an events handler.
    We add the user object into an array for easy management. We need to handle the
    `onclose` event when a user disconnects. To do this, we remove that user from
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After defining our classes in the `game.js` file, we exported them. By exporting
    them to the module, we can import them in the other file by using the `require`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Sending messages to the client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WebSockets have the ability to send messages from the server to a user. Traditionally,
    the client requests the server and then the server responds. In a socket server,
    all users are connected, so messages can be triggered and sent in both directions.
    Here, we loop through all the users to send a broadcast message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then we listen to the server message on the client, by using the `onmessage`
    event handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Building a chatting application with WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how many browsers are connected. Suppose we want to build a chat
    room where users can type a message in their respective browsers and send the
    message to all the connected users instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message to the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will let the user input a message and then send the message to the `node.js`
    server. The server will then forward the message to all the connected browsers.
    Once a browser receives the message, it displays it in the chat area. In this
    case, the users are connected to the instant chat room once they load the web
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – sending a message to the server through WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, code the server logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `servergame.js`. Add the following function to the file that handles user
    messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code inside the `Room.prototype.addUser` method that calls
    our newly created function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, move on to the `client` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `index.html` file and add the following markup in the `body` section.
    This provides inputs for the user to type and send messages to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following code to the `html5games.websocket.js` JavaScript file.
    This sends the message to the server when the user clicks on the `send` button
    or presses the *Enter* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before testing our code, check the server terminal and see whether the node
    server is still running. Press *Ctrl* + *C* to terminate it and run it again by
    using the `node` `server.js` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `index.html` in a web browser. You should see an input text field with
    a **Send** button, as shown in the following screenshot:![Time for action – sending
    a message to the server through WebSockets](img/B04290_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to type something in the input text field and then click on the **Send**
    button or press *Enter*. The input text will be cleared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, switch to the server terminal, and you will see the server printing the
    text that we just sent. You can also put the browser and server terminal side
    by side to see how the message is sent instantly from the client to the server.
    The following screenshot shows the server terminal with messages from two connected
    browsers:![Time for action – sending a message to the server through WebSockets](img/B04290_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just extended our connection example by adding an input text field for the
    users to type some text there and send it out. The text is sent as a message to
    the WebSocket server. The server will then print the received message in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message from the client to the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to send a message from the client to the server, we call the following
    `send` method in the `WebSocket` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet from our example, we get the message from the
    input text field and send it to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Receiving a message on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the server side, we need to handle the message we just sent from the client.
    We have an event named `message` in the connection instance in the WebSocket `node.js`
    library. We can listen to the connection message event to receive a message from
    each client connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we use the message event listener to print
    the message on the server terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Sending every received message on the server side to create a chat room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last example, the server could receive messages sent from browsers. However,
    the server does nothing except print the received messages in the terminal. Therefore,
    we will add some logic to the server to send the messages out.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – sending messages to all connected browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `game.js` file in the **server** folder for the server-side logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to the message event listener handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is it for the server side. Move on to the `client` folder and open the
    `index.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to display the chat messages in the chat history area. To do this,
    add the following code to the HTML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need the client-side JavaScript to handle the received message from
    the server. We used it to print it out into the console panel, replace the `console.log`
    code with the following highlighted code in the `onmessage` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's test our code. Terminate any running node server by pressing *Ctrl* +
    *C*. Then, run the server again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `index.html` file twice and put them side by side. Type something in
    the text field and press *Enter*. The message will appear on both the opened browsers.
    If you open many instances of the HTML file, the message would appear on all the
    browsers. The following screenshot shows two browsers displaying the chat history
    side by side:![Time for action – sending messages to all connected browsers](img/B04290_08_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an extension of our previous examples. We discussed how a server sends
    the connection count to all the connected clients. We also discussed how the client
    sends a message to the server. In this example, we combine these two techniques
    to let the server send the received messages to all the connected users.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing WebSockets with polling approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have ever built a web page's chat room by using a server-side language
    and a database, then you may wonder what the difference is between the WebSocket
    implementation and the traditional one.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional chat room method is often implemented by using a **polling**
    approach. The client asks the server for an update periodically. The server responds
    to the client with either no update or the updated data. However, the traditional
    approach has several problems. The client does not get new data updated from the
    server until the next time it asks the server. This means that the data update
    is periodically delayed with time and the response is not instant enough. If we
    want to improve this issue by shortening the polling duration, then more bandwidth
    is utilized because clients need to keep sending requests to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph shows requests between the client and the server. It shows
    that many useless requests are sent, but the server responds to the client without
    any new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing WebSockets with polling approaches](img/B04290_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a better polling approach named **long polling**: the client sends
    a request to the server and waits for the response. Instead of the traditional
    polling approach where the server responds with "no update", the server does not
    respond at all until there is something that needs to be pushed to the server.
    In this approach, the server can push something to clients whenever there is an
    update. Once a client receives a response from the server, it creates another
    request and waits for the next server notification. The following graph shows
    the long polling approach where clients ask for updates and the server responds
    only when there is an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing WebSockets with polling approaches](img/B04290_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the WebSockets approach, the number of requests are way less than the polling
    approach. This is because the connection between the client and server is persistent.
    Once the connection is established, a request from either the client side or the
    server side is sent only when there is any update. For instance, a client sends
    a message to the server when it wants to update something to the server. The server
    also sends messages to clients only when it needs to notify the clients of a data
    update. No other useless requests are sent during the connection. Therefore, less
    bandwidth is utilized. The following graph shows the WebSockets approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing WebSockets with polling approaches](img/B04290_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making a shared drawing whiteboard with Canvas and WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we want a shared sketchpad. Anyone can draw something on the sketchpad
    and all others can view it. We learned how messages are communicated between clients
    and servers. We will go further and send drawing data.
  prefs: []
  type: TYPE_NORMAL
- en: Building a local drawing sketchpad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we deal with data sending and server handling, let's focus on making
    a drawing whiteboard. We will use the Canvas to build a local drawing sketchpad.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making a local drawing whiteboard with the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus only on the client side in this section. Open the `index.html`
    file and add the following `canvas` markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will draw something in the Canvas and we will need the mouse position relative
    to the Canvas for this. We did this in [Chapter 4](ch04.html "Chapter 4. Building
    the Untangle Game with Canvas and the Drawing API"), *Building the Untangle Game
    with Canvas and the Drawing API*. Add the following style to the Canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, open the `html5games.websocket.js` JavaScript file to add the drawing
    logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `websocketGame` global object with the following variable at the
    top of the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the jQuery `ready` function, add the following mouse event handler code.
    The code handles the mouse''s down, move, and up events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At last, we have the following function to draw a line in the Canvas with the
    given starting and ending points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all files and open the `index.html` file. You should see an empty space
    where you can draw something by using the mouse. The drawings are not sent to
    the server yet, so others cannot view your drawings:![Time for action – making
    a local drawing whiteboard with the Canvas](img/B04290_08_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a local drawing pad. This is like a whiteboard where the player
    can draw in the Canvas by dragging the mouse. However, the drawing data is not
    sent to the server yet; all drawings are only displayed locally.
  prefs: []
  type: TYPE_NORMAL
- en: The `drawing` `line` function is the same that we used in [Chapter 4](ch04.html
    "Chapter 4. Building the Untangle Game with Canvas and the Drawing API"), *Building
    the Untangle Game with Canvas and the Drawing API*. We also used the same code
    to get the mouse position relative to the `canvas` element. However, the logic
    of the mouse events is different from [Chapter 4](ch04.html "Chapter 4. Building
    the Untangle Game with Canvas and the Drawing API"), *Building the Untangle Game
    with Canvas and the Drawing API*.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing in the Canvas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we draw something on the computer, it often means that we click on the
    Canvas and drag the mouse (or pen). The line is drawn until the mouse button is
    up. Then, the user clicks on another place and drags again to draw lines.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have a Boolean flag named `isDrawing` to indicate whether
    the user is drawing. The `isDrawing` flag is `false` by default. When the mouse
    button is at a point, we turn the flag to `true`. When the mouse is moving, we
    draw a line between the moved point and the last point when the mouse button was.
    Then, we set the `isDrawing` flag to `false` when the mouse button is up. This
    is how the drawing logic works.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – drawing with colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can we modify the drawing sketchpad by adding color support? How about adding
    five buttons with red, blue, green, black, and white colors? The player can choose
    the color when drawing. Alternatively, we can also provide different brush width
    options to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the drawing to all the connected browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will go further by sending our drawing data to the server and let the server
    send the drawing to all the connected browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – sending the drawing through WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to modify the server logic. Open the `game.js` file and add
    two constants at the beginning of the file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Room.prototype.addUser` method, add the following code at the beginning
    of the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use JSON-formatted string for communicating both drawing actions and chat
    messages. Add the following code to the user sockets on the message event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `server.js`, there is no need to send the welcome message to the room since
    this is now handled by the `Room.addUser` method. Remove the following code from
    the `server.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the client side, we need the logic to respond to the server with the same
    data object definition. Open the `html5games.websocket.js` JavaScript file in
    the **js** directory under **client**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following constants to the `websocketGame` global variable. The same
    constants with the same values are also defined in the server-side logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When handling the message event on the client-side, convert the JSON-formatted
    string back to the data object. If the data is a chat message, then we display
    it as the chat history, otherwise we draw it in the Canvas as a line segment.
    Replace the `onmessage` event handler with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the mouse is moving, we not only draw the line in the Canvas but also
    send the line data to the server. Add the following highlighted code to the `mousemove`
    event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we need to modify the send message logic. We now pack the message in
    an object and format it as JSON when sending it to the server. Change the `sendMessage`
    function to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all the files and relaunch the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `index.html` file in two browser instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, try the chat room feature by typing some messages and sending them. Then,
    try drawing something in the Canvas. Both browsers should display the same drawing,
    as shown in the following screenshot:![Time for action – sending the drawing through
    WebSockets](img/B04290_08_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just built a multiuser sketchpad. This is similar to the sketchpad we tried
    at the beginning of this chapter. We extended what you learned when building a
    chat room by sending a complex data object as a message.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a data object to communicate between the client and the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to communicate correctly between the server and clients when there
    is a lot of data packed into one message, we have to define a data object that
    both the client and server understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several properties in the data object. The following table lists
    the properties and why we need them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property name | Why we need this property |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dataType` | This is an important property that helps us to understand the
    entire data. The data is either a chat message or drawing line segment data. |'
  prefs: []
  type: TYPE_TB
- en: '| `sender` | If the data is a chat message, the client needs to know who sent
    the message. |'
  prefs: []
  type: TYPE_TB
- en: '| `message` | When the data type is a chat message, we surely need to include
    the message content itself into the data object. |'
  prefs: []
  type: TYPE_TB
- en: '| `startX` | When the data type is a drawing line segment, we include the *x*/*y*
    coordinates of the starting point of the line. |'
  prefs: []
  type: TYPE_TB
- en: '| `startY` |'
  prefs: []
  type: TYPE_TB
- en: '| `endX` | When the data type is a drawing line segment, we include the *x*/*y*
    coordinates of the ending point of the line. |'
  prefs: []
  type: TYPE_TB
- en: '| `endY` |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, we have the following constants defined on both the client side
    and the server side; these constants are for the `dataType` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'With these constants, we can compare datatypes with the following readable
    code, instead of using the meaningless Integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Packing the drawing lines data into JSON for sending
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the `JSON.stringify` function in the last chapter when we stored a JavaScript
    object into a JSON-formatted string in the local storage. Now, we need to send
    the data in string format between the server and the client. We use the same method
    to pack the drawing lines data into an object and send it as a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we pack the line segment data on the client
    side and send it to the server with a JSON-formatted string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Recreating the drawing lines after receiving them from other clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JSON parsing often comes as a pair of `stringify`. When we receive a message
    from the server, we have to parse it to the JavaScript object. The following code
    on the client side parses the data and either updates the chat history or draws
    a line based on the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Building a multiplayer draw-and-guess game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built an instant chat room earlier in this chapter. Moreover, we just built
    a multiuser sketchpad. How about combining these two techniques and building a
    draw-and-guess game? A draw-and-guess game is a game in which one player is given
    a word to draw. All other players do not know the word and guess the word according
    to the drawing. The one who draws and who correctly guesses the word earn points.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – building the draw-and-guess game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement the game flow of the draw-and-guess game as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will add the game logic on the client side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `index.html` file in the client directory. Add the following restart
    button right after the *send* button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `html5games.websocket.js` JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need a few more constants to determine different states during the game
    play. Add the following highlighted code to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition, we want a flag to indicate this player is in charge of drawing.
    Add the following Boolean global variable to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the client receives a message from the server, it parses it and checks
    whether it is a chat message or a line drawing. We have another type of message
    now named `GAME_LOGIC` for handling the game logic. The game logic message contains
    different data for different game states. Add the following code to the `onmessage`
    event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is one last step in the client-side logic. We want to restart the game
    by sending a restart signal to the server. At the same time, we clear the drawing
    and chat history. To do this, add the following code inside the `html5games.websocket.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is now time to move on to the server side. We need more states to control
    the game flow. Replace the constants at the beginning of the `game.js` file with
    the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous example, the server side was just in charge of sending any incoming
    message to all connected browsers. This is not enough for a multiplayer game.
    The server will act as the game master that controls the game flow and determination
    of the winning condition. We extend the `Room` class with `GameRoom` that can
    handle the game flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add the following code to the end of the `game.js` file. This is the constructor
    function of a new class called `GameRoom`, which initializes game logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we extend the existing `Room` functionality into the `GameRoom` prototype
    so that `GameRoom` will have access to the `Room` class' prototype function by
    default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the following `addUser` function in the `GameRoom` class. Append the
    code after our existing `GameRoom` code. This keeps the original room''s `addUser`
    function and adds extra logic that waits until enough players join to start the
    game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unlike the previous example in which the server only passes user messages to
    all of the connected clients, now the server needs to determine whether the messages
    from the user are part of the game flow. Append the following code after the existing
    `GameRoom` logic; It overrides the original room''s `handleOnUserMessage` function
    into new logic that handles chat messages, line segments, and the control of the
    game flow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s continue with the `GameRoom` logic. Add the following new function to
    the `game.js` file. This creates a new game inside the room by picking a player
    as a drawer and the others as guessers; then, it randomly picks a word for the
    drawer to draw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At last, we export the `GameRoom` class so that other files, such as `server.js`,
    can access the `GameRoom` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `server.js`, we must call our new `GameRoom` constructor instead of the
    generic `Room` constructor. Replace the original related code to `Room` with the
    following `GameRoom` code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will save all the files and relaunch the server. Then, we will launch the
    `index.html` file in two browser instances. One browser will get a message from
    the server informing the player to draw something. The other browser, on the other
    hand, will inform the player to guess what the other player is drawing within
    one minute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player who is told to draw something can draw in the Canvas. The drawings
    are sent to all the other connected players. The players who are told to guess
    cannot draw anything in the Canvas. Instead, players type what they guess in the
    text field and send it to the server. If the guess is correct, then the game ends.
    Otherwise, the game continues until the one-minute countdown finishes.![Time for
    action – building the draw-and-guess game](img/B04290_08_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a multiplayer draw-and-guess game in WebSockets and Canvas.
    The main difference between the game and the multiuser sketchpad is that the server
    now controls the game flow instead of letting all the users draw.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting the Room class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, we can inherit a defined class with a new class. We define `GameRoom`
    that inherits the `Room` class. The `GameRoom` class will have the `Room` logic
    that it inherits plus the extra logic that is specifically designed for the game
    flow. Inheritance is done by creating an instance of the class into the prototype,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now, `GameRoom` has the prototype methods from `Room`. We can then define more
    logic in `GameRoom` such as the `startGame` method. We can also override the existing
    logic by defining a new prototype method in the `GameRoom` class with the same
    name; for example, we override the `handleOnUserMessage` method to send the game
    starting and winning logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want to extend an existing logic instead of replacing the old
    one with a new one. In such a case, we need to execute the logic that we have
    overridden by the method with the same name. We can use the following code to
    execute the method that''s in the original prototype; we used this approach in
    the `addUser` method to keep the original logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the game flow of a multiplayer game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Controlling the game flow of a multiplayer game is much more difficult than
    a single game. We can simply use a few variables to control the game flow of a
    single game, but we have to use message passing to inform each player of specific
    updated game flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we require the following highlighted `GAME_LOGIC` constant for `dataType`.
    We use this data to send and receive a message that is related to the game logic
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: There are several states in the game flow. Before the game starts, the connected
    players are waiting for the game to start. Once there are enough connections for
    the multiplayer game, the server sends a game logic message to all the players
    to inform them of the start of the game.
  prefs: []
  type: TYPE_NORMAL
- en: When the game is over, the server sends a game over state to all the players.
    Then, the game finishes and the game logic halts until any player clicks on the
    restart button. Once the restart button is clicked, the client sends a game restart
    state to the server instructing the server to prepare a new game. Then, the game
    starts again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the four game states as the following constants in both the client
    and server so that they understand them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code on the server side holds an index to indicate which player''s
    turn is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The data which is sent to the player (whose turn it is) is different from the
    data that is sent to other players. The other players receive the following data
    with only a game start signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the player (whose turn is to draw) receives the following
    data with the word information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Room and Game Room
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this example, we have created two types of rooms: a normal room
    and a game room. Specifically, a normal room has the most basic features: managing
    users and chatting within the room. The game room, which is built on top of the
    normal room, adds another large block of logic to manage a draw-and-guess game
    flow. The game flow includes waiting for the game to start, starting the game,
    determining game over, and triggering time out. All these game flow controls are
    encapsulated into the `GameRoom` class.'
  prefs: []
  type: TYPE_NORMAL
- en: In the future, we can easily expand the multiplayer game by adding different
    types of game into it. For example, we can create a 2-player tic-tac-toe game
    by creating a `TicTacToeGameRoom` class that shares similar waiting and restarting
    game logic in `GameRoom`. However, the `TicTacToeGameRoom` class will handle other
    game flows such as passing the game board data and handling a tied game. Since
    all game logic is encapsulated inside the specific game room, different types
    of multiplayer game won't affect each other.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just created a multiplayer game that is playable. However, there is
    still a lot to improve. In the following sections, we list two possible improvements
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The game looks very plain now. We can improve its visual outlook by adding CSS
    styles and decorative images to it. In the code bundle, you will find an example
    with extra CSS styles applied to make the game look better. You may try different
    styling effects also.
  prefs: []
  type: TYPE_NORMAL
- en: Storing drawn lines on each game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the game, the drawer draws lines and other players guess the drawing. Now,
    imagine that two players are playing and the third player joins them. As there
    is no storage for the drawn lines anywhere, the third player cannot see what the
    drawer has drawn. This means that the third player has to wait until the game
    ends to play.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we let a player who has joined late continue the game without losing
    the drawn lines? How can we reconstruct the drawing for a newly connected player?
    How about storing all drawing data of the current game on the server?
  prefs: []
  type: TYPE_NORMAL
- en: Improving the answer checking mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The answer checking on the server side compares the message with the `currentAnswer`
    variable to determine whether a player guessed correctly. The answer is treated
    as incorrect if the case does not match. It looks strange when the answer is "apples"
    and the player is told that their answer is wrong when they guess "apple".
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we improve the answer checking mechanism? How about improving the answer
    checking logic to treat the answer as correct when using a different case or even
    similar words? The current game is quite plain in style. Please add your decoration
    to the game to make it more appealing to the players.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about connecting browsers to WebSockets. The
    messages and events from one browser are sent to all connected browsers in almost
    real time.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we learned how WebSockets provide real-time events by drawing
    on an existing multiplayer sketchpad. It shows drawings from other users who are
    connected. We chose Node.js as the server-side WebSocket server. By using this
    server, we can easily build an event-based server to handle WebSocket requests
    from browsers. We discussed the relationship between the server and a client,
    which compares WebSockets with other approaches such as long-polling. We built
    an instant chat room application. We learned how to implement a server script
    to send all incoming messages to other connected browsers. We also learned how
    to display a received message from the server on the client side. Next, we built
    a multiuser drawing board and finally a draw-and-guess game by integrating the
    chatting along with the drawing pad.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to build a multiplayer game, we are ready to build
    physics games with the help of the physics engine in the next chapter.
  prefs: []
  type: TYPE_NORMAL
