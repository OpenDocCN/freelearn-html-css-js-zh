- en: '20'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SportsStore: Administration'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I will create the *SportsStore* administration features, which
    will allow authorized users to edit the product catalog and change the shipping
    status of customer orders.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the `sportsstore` project from *Chapter 19*. Open a new command
    prompt, navigate to the `sportsstore` folder, and run the command shown in *Listing
    20.1* to start the development tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.1: Starting the development tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Open a new browser window, navigate to `http://localhost:5000`, and you will
    see the product catalog, as shown in *Figure 20.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.1: Running the application'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTML RESTful web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web service created in *Chapter 14* follows the most common approach, which
    is to return JSON data that the client can process and present to the user. This
    is the most flexible approach because it doesn’t limit the way that the data is
    used, allowing clients to be created that use data in ways the developers of the
    web service did not envisage and without their involvement.
  prefs: []
  type: TYPE_NORMAL
- en: For many projects, the developers of the web service are also responsible for
    the client, which leads to the strange situation where all of the state management
    features developed by the round-trip client are recreated, using a framework such
    as Angular or React to create a more responsive set of features.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, an alternative is to create a web service that returns fragments
    of HTML content instead of JSON, and create a client that responds to user interaction
    by sending HTTP requests to the web service, displaying the results that are obtained.
    The web service still relies on HTTP methods to identify the type of operation
    that will be performed, and the URL path to identify the resource that is affected,
    but the result is pre-formatted content that can be displayed to the user, which
    is produced using the same template, session, and data features that were created
    for the conventional HTML application.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t suitable for every project, especially when you need to provide access
    to your application’s data to third parties, but if you find yourself using a
    framework like React or Angular to duplicate the functionality already created
    for the server, then this can be a good approach that avoids the complexity of
    using a big client-side framework.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for client development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package I am going to use to send HTTP requests and process the HTML responses
    is called `htmx` ([https://htmx.org](https://htmx.org)), which is a good choice
    when the server can provide all of the statement management and content generation
    that will be required to create the client, which is the case for the SportsStore
    application. To install the `HTMX` package, run the command shown in *Listing
    20.2* in the `sportsstore` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Another good package to consider is Alpine ([https://alpinejs.dev](https://alpinejs.dev)),
    which is more complex, but it makes it easier to manage state data in the browser
    and can more easily be used with web services that return JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.2: Installing the htmx package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Table 20.1* describes the package for quick reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 20.1: The client-side package'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| The `HTMX` package scans HTML elements for special attributes that configure
    asynchronous HTTP requests, which will be sent to a web service that returns a
    fragment of HTML. |'
  prefs: []
  type: TYPE_TB
- en: The `HTMX` package works by applying attributes to HTML elements, which are
    processed by JavaScript code loaded using a `script` element. This approach means
    that no client-side development toolchain is required, and the developer can simply
    reload the browser to see the effect of changes during development. I find that
    style of development frustrating because I often forget to reload the browser,
    which causes me momentary confusion when the content displayed by the browser
    doesn’t match up with the markup that I have just saved in the code editor. To
    that end, I am going to set up the **webpack** bundler so that I can take advantage
    of the development server `reload` feature.
  prefs: []
  type: TYPE_NORMAL
- en: Some packages just deal with browser reloading, but using webpack is a form
    of insurance because the bundle that it creates means that I can easily add JavaScript
    code to the client side later, without needing to revise the project tooling.
    There is no requirement to use a webpack bundler with an `HTMX` project, but I
    consider it a worthwhile escape hatch that lets me fix awkward problems that would
    otherwise be hard to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Run the commands shown in *Listing 20.3* in the `sportsstore` folder to install
    the packages required to create the client-side bundles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.3: Installing the packages required for the bundler'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Table 20.2* describes these packages for quick reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 20.2: The client-side development tool packages'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| This package contains the webpack bundler. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| This package contains the command line for webpack. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| This package contains the webpack development HTTP server. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| This package allows you to start multiple commands using `npm`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| This package contains an HTTP proxy, which will forward requests to the webpack
    server during development. |'
  prefs: []
  type: TYPE_TB
- en: Add a file named `webpack.config.mjs` to the `sportsstore` folder with the content
    shown in *Listing 20.4*, which configures webpack and sets up its development
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.4: The contents of the webpack.config.mjs file in the sportsstore
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The configuration tells webpack to create a bundle using a file named `client.js`
    in the `src/admin` folder, and also to trigger a browser update if the bundle
    changes or if a file in the `templates/admin` folder changes. The bundle will
    be created in a file named `bundle.js`, which will be written to the `dist/admin`
    folder. Create the `src/admin` folder, and add to it a file named `client.js`
    with the content shown in *Listing 20.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.5: The contents of the client.js file in the src/admin folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code in this file does nothing because the bundle is just a means to use
    the webpack development HTTP server. The bundle will be omitted from the production
    build of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the routes and templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next steps are to configure the route that will be the entry point into
    the administration features and define the template that will be used to generate
    the response. Create the `src/routes/admin` folder, and add to it a file named
    `index.ts` with the content shown in *Listing 20.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.6: The contents of the index.ts file in the src/routes/admin folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `createAdminRoutes` function sets up the administration routes. To get started,
    there is a middleware component that disables the default layout for the template
    engine, and a route that handles `GET` requests to the `/admin` URL by rendering
    a template named `admin/admin_layout`. The name of the template includes the `admin`
    folder so that I can keep the administration templates separate from the rest
    of the application content. The drawback of this approach is that the folder name
    has to be included in all calls to the `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20.7* adds the `createAdminRoutes` to the set of functions called
    to set up the application’s routes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.7: Adding routes to the index.ts file in the src/routes folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To create the initial template, create the `sportsstore/templates/admin` folder,
    and add to it a file named `admin_layout.handlebars` with the content shown in
    *Listing 20.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.8: The contents of the admin_layout.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This template renders an HTML document, with `link` elements for the Bootstrap
    CSS and Icons files, and `script` elements for the webpack bundle and the `HTMX`
    JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete the preparation, *Listing 20.9* sets up request forwarding to the
    webpack dev server and adds the `HTMX` package folder to the set of static file
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.9: Configuring the application in the server.ts file in the src
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the application is configured for the development environment, then the `http-proxy`
    package is used to forward requests to the webpack development HTTP server, which
    will enable automatic browser reloading.
  prefs: []
  type: TYPE_NORMAL
- en: The error handlers have to be moved so that the `404` `-` `Not` `Found` response
    isn’t generated until after the handler for webpack development server has had
    the chance to match the request.
  prefs: []
  type: TYPE_NORMAL
- en: The final preparatory step is to configure the `npm` commands to start both
    the server and webpack, and to prevent the server from being restarted when the
    templates in the `admin` folder are changed, as shown in *Listing 20.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.10: Configuring the application in the package.json file in the
    sportsstore folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Stop the server if it is running, and then run the command shown in *Listing
    20.11* in the `sportsstore` folder to start the client-side build tools and the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.11: Starting the client build tools and server'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Open a browser and navigate to `http://localhost:5000/admin`. The browser will
    display the administration layout, with some placeholder text, as shown in *Figure
    20.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.2: Preparing for the administration features'
  prefs: []
  type: TYPE_NORMAL
- en: Administering the product catalog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the basic structure is in place, it is time to start adding features.
    Create a file named `area_buttons.handlebars` in the `templates/admin` folder
    with the content shown in *Listing 20.12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.12: The contents of the area_buttons.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This template contains the buttons that will allow the user to select an area
    of functionality: managing the catalog or shipping orders. The file is processed
    by the Handlebars template engine, which evaluates the `{{` and `}}` sections
    to produce the HTML content that is included in the response to the client. There
    are two template expressions in this file, which change the value of the class
    attribute applied to the `button` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The classes applied to the elements will show the user which part of the application
    is active and rely on a template helper named `buttonClass`, which I’ll create
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the HTML content is received by the browser, it will be processed a second
    time, by the `HTMX` package, which looks for attributes whose name begins with
    `hx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `hx-get` attributes tell `HTMX` to send a `GET` request to a specific URL.
    By default, `HTMX` uses the HTML in the response to replace the element that triggered
    the requests, but this can be changed with the `hx-target` attribute, which means
    that the `button` elements will request `/api/products/table` or `/api/orders/table`,
    and the response will be displayed using the element whose ID is `content`. (The
    value of the `hx-target` attribute is a CSS selector, and the `#` prefix denotes
    an element’s ID.)
  prefs: []
  type: TYPE_NORMAL
- en: The `hx-swap-oob` attribute allows a fragment of content to specify where it
    will be displayed. The attribute applied to the `swap_wrapper` element tells `HTMX`
    that the content it contains should be used to replace the content of the element
    whose name is `area_buttons`. (The `swap_wrapper` element name is entirely made
    up and was chosen so that it won’t be mistaken for the actual application HTML
    content. You can use any element name in your projects.)
  prefs: []
  type: TYPE_NORMAL
- en: To define the `buttonClass` helper that is used in *Listing 20.12*, add a file
    named `admin_helpers.ts` to the `src/helpers` folder with the content shown in
    *Listing 20.13*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.13: The contents of the admin_helpers.ts file in the src/helpers
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20.14* includes the new helper in the template engine configuration
    when the application starts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.14: Adding helpers to the index.ts file in the src/helpers folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The content in *Listing 20.12* is a partial template, which will be combined
    with other content to produce an HTML response, using the features provided by
    the template engine, and the template also allows small files to be defined and
    managed. Add a file named `product_table.handlebars` to the `templates/admin`
    folder with the content shown in *Listing 20.15*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.15: The contents of the product_table.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This template presents the table of products in the catalog to the user and
    incorporates the `area_buttons` partial template. The template receives a `product`
    data property that is used to populate the contents of a table, using the `each`
    helper.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the web service routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I like to get the basic template features in place and switch between the routes
    and data management as I work, returning to the templates to refine the data presentation
    as features fall into place. To define the route that will provide the initial
    view of the catalog, add a file named `admin_catalog_routes.ts` to the `src/routes/admin`
    folder with the content shown in *Listing 20.16*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.16: The contents of the admin_catalog_routes.ts file in the src/routes/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `createAdminCatalogRoutes` function receives a `Router` object, which allows
    requests to be handled relative to a base URL that is defined elsewhere in the
    application. There is one route that handles the `/table` URL and responds by
    rendering the `admin/product_table` template, which is provided by data read from
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier chapters, I accessed the database through the repository, which is
    my preferred way of isolating details of data access from the rest of the application.
    Not everyone likes using a repository and the additional complexity it introduces,
    so for the administration features, I am going to access the database directly
    through the Sequelize model classes to demonstrate both techniques, showing that
    they can coexist in the same project. To get the data for the template, the request
    handler queries for all `ProductModel` objects and includes the associated `SupplierModel`
    and `CategoryModel` objects. The `raw` property is used to prevent Sequelize from
    transforming the response, which is a useful option when the data that is read
    from the database can be used without modification.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: I still recommend using a repository because doing so ensures that data is accessed
    consistently, and it makes it easier to swap out the data access package. If you
    do choose to work directly with the data access package in your project, remember
    that you will have to go through the initialization process. For the *SportsStore*
    application, this is done in the `core.ts` file in the `src/data/orm` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20.17* calls the `createAdminCatalogRoutes` function when the application
    starts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.17: Adding routes to the index.ts file in the src/routes/admin folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A new `Router` object is created and passed to the `createAdminCatalogRoutes`
    function so that the relative routes can be defined, and it is then added to the
    request pipeline with the `use` method. `Router` is a middleware component that
    tries to match requests with its routes; otherwise, it will pass on requests.
    In this case, the `Router` object passed to the `createAdminCatalogRoutes` function
    is configured to try and match requests with the `/api/products` path, using the
    routes defined in *Listing 20.16*, which means that the `/api/products/table`
    URL will be received by the handler defined in *Listing 20.16*, responding with
    the rendered output from the `admin/product_table` template.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20.18* updates the top-level template so that `HTMX` will send a request
    that will be processed by the handler defined in *Listing 20.16*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.18: Loading data into the admin_layout.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `hx-get` attribute tells `HTMX` to request the `/api/product/table` URL.
    By default, requests are sent when the user interacts with an element, but the
    `hx-trigger` attribute overrides this behavior and tells `HTMX` to send the HTTP
    request when the element is loaded. Use a browser to request `http://localhost:5000/admin`,
    and you will see the content shown in *Figure 20.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.3: Starting the development of the administration features'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, it is worth recapping the process that produces the content
    shown in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: The user requests `http://localhost:5000/admin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The request is handled by rendering the `admin_layout` template, which contains
    an element whose attributes tell `HTMX` to send an HTTP request to `http://localhost:5000/api/products/table`
    once the HTML content has been loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second request is handled by rendering the `product_table` template, and
    the content that is produced is used as the contents of the element that triggered
    the HTTP request, except for the content in the `area_buttons` partial template,
    which is used to replace the contents of the element with the same name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This initial presentation of content may seem like the existing round-trip functionality,
    but the key difference is that some of the content was obtained using the web
    service, whose importance will become more obvious as features are added.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying product data and deleting products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the basic structure is in place, I am going to pick up the pace and
    build out the rest of the product management features, pausing periodically to
    check that everything works as it should. To display the product details correctly,
    add a file named `product_row.handlebars` to the `templates/admin` folder with
    the content shown in *Listing 20.19*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.19: The contents of the product_row.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `button` elements will allow the user to edit or delete products. The **Edit**
    `button` element has an `hx-get` attribute that sends a request when the button
    is clicked, including the `id` value in the requested URL, so that clicking on
    the **Edit** button for the product with `ID` 2, for example, will send an HTTP
    request to `/api/products/edit/2`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Delete` button element has the `hx-delete` attribute, which tells `HTMX`
    to send an HTTP `DELETE` request when the button is clicked. The `hx-swap` attribute
    is set to `delete`, which tells `HTMX` to remove the element specified by the
    `hx-target` attribute. The effect is that the table row for the product will be
    removed when the **Delete** button is clicked, and the server confirms that the
    product has been removed from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20.20* applies the new template to format the product data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.20: Applying a template to the product_table.handlebars file in
    the templates/admin folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20.21* adds a route that handles `DELETE` requests, receiving the
    ID of the product to delete it as a URL parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.21: Adding a route to the admin_catalog_routes.ts file in the src/routes/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Request `http://localhost:5000/admin`, and you will see a more detailed presentation
    of the product data. Clicking the **Delete** button removes a product from the
    database, as shown in *Figure 20.4*. (The application is configured to reset the
    database, which means that the deleted products will be restored the next time
    you change one of the project files.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.4: Product details and deleting a product'
  prefs: []
  type: TYPE_NORMAL
- en: Editing products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Edit** feature will present the user with an HTML form that is populated
    with the details of a product, presenting validation messages when the form is
    submitted with unusual values. I am going to build up the form using a series
    of smaller, more manageable templates, which will be combined to produce an HTML
    response and ensure that each data property is handled consistently. Starting
    with a template to display validation messages, add a file named `validation_messages.handlebars`
    to the `templates/admin` folder, with the content shown in *Listing 20.22*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.22: The contents of the validation_messages.handlebars file in the
    templates/admin folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: I am going to use the existing validation features, which means that the `invalid`
    property will be `true` when there is a validation issue and the `messages` property
    contains the content to be displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the product details will be displayed using `input` elements, allowing
    the user to freely enter a value. To create a template for `input` elements, add
    a file named `product_input.handlebars` to the `templates/admin` folder with the
    content shown in *Listing 20.23*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.23: The contents of the product_input.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The template creates `label` and `input` elements, formatted using the Bootstrap
    CSS styles, and incorporates the `validation messages` template. To simplify data
    management, users won’t be allowed to change the `ID` property of a product, and
    so a `disabled` helper is used to add the `disabled` attribute to the `input`
    element when that element is used for the `ID` property, as shown in *Listing
    20.24*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.24: Adding a helper to the admin_helpers.ts file in the src/helpers
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Some product properties will be edited by picking from a list of values. To
    create a template that will produce a `select` element, add a file named `product_select.handlebars`
    to the `templates/admin` folder with the content shown in *Listing 20.25*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.25: The contents of the product_select.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `select` element is populated with a set of `option` elements from which
    the user can choose, along with a fallback element that will be useful later when
    adding support to create new products. A helper is required to determine whether
    an `option` element is decorated with the `selected` attribute, as shown in *Listing
    20.26*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.26: Adding a helper to the admin_helpers.ts file in the src/helpers
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To create the template that combines the `input` and `select` elements to present
    the user with a complete HTML form, add a file named `product_editor.handlebars`
    to the `templates/admin` folder with the content shown in *Listing 20.27*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.27: The contents of the product_editor.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This template contains a `form` element that is decorated with the `hx-put`
    attribute, which tells `HTMX` to submit the form using an HTTP `PUT` request to
    a URL that combines `/api/products` with the product `ID` (such as `/api/products/1`
    for the product whose `ID` value is `1`).
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the form are created using the templates for `input` and `select`
    elements, along with a `textarea` element that will allow the user to enter multiple
    lines of text for the description. There is also a button that will trigger the
    `PUT` request, as well as a `Cancel` button that instructs `HTMX` to send a `get`
    request to `/api/products/table` and display the results in the `content` element.
  prefs: []
  type: TYPE_NORMAL
- en: Adding product data validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data that is received from the product editing form must be validated before
    it is stored in the database. Add a file named `product_dto_rules.ts` to the `src/data/validation`
    folder with the content shown in *Listing 20.28*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.28: The contents of the product_dto_rules.ts file in the src/data/validation
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductDTO` type represents the data that will be received when the user
    edits a product and submits the form (the term **DTO** means **data transfer object**
    and is used to describe types that represent data when it is transferred). The
    validation rules for the `ProductDTO` type are exported as a constant, named `ProductDTOValidator`.
    Two custom rules are required to ensure that a value corresponds to an existing
    supplier or category in the database. *Listing 20.29* incorporates the new validator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.29: Adding a validator to the index.ts file in the src/data/validation
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Adding the routes for editing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two new routes are required to support editing: the first route receives an
    HTTP `GET` request and responds with a populated HTML form. The second route receives
    the HTTP `PUT` request and is responsible for validating the data and storing
    it. Both routes are defined in *Listing 20.30*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.30: Adding editing routes to the admin_catalog_routes.ts file in
    the src/routes/admin folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `GET` route receives the `ID` of the product that the user wants to edit
    through the URL and queries the database to get the data, which is fed through
    the validator so that the same template can be used when editing starts and invalid
    data is received.
  prefs: []
  type: TYPE_NORMAL
- en: The `PUT` route receives data that the user wants to store, with the `ID` received
    from the URL. The data is validated, and if it is invalid, the `admin/product_editor`
    template is rendered, which will display the validation messages to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data is valid, the database is updated and the browser is redirected,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `303` status code causes the browser to request the specified URL, using
    an HTTP `GET` request, and effectively ends the editing session by displaying
    the product data, which will include the edited data.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with the `303` redirection is that it will fail during development
    because the default security configuration applied by the Helmet package tells
    the browser to upgrade insecure requests. This means that the `303` redirection
    tells the browser to request `http://localhost:5000/api/products/table`; however,
    due to the security policy, the browser will make an HTTPS request instead. *Listing
    20.31* adds a new section to the configuration file that will be used to configure
    the Helmet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.31: Adding a section to the server.config.json file in the sportsstore
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20.32* updates the application configuration to disable insecure upgrades
    when the application is in the development environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.32: Disabling insecure upgrades in the server.ts file in the src
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let the browser reload automatically or navigate to `http://localhost:5000/admin`,
    and click the **Edit** button for one of the products. Clear the **Name** field
    and click the **Save** button to see a validation error. Enter a new name and
    click the **Save** button again, and you will see the modified data displayed
    in the overview table, as shown in *Figure 20.5*.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to clear your browser cache for the change in the security policy
    to take effect. Some browsers, including Chrome, will keep trying to upgrade to
    HTTPS connections until the cache is cleared.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.5: Validating and editing data'
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that the application is configured to reset the database every
    time there is a change, which means that the changes you make will be lost as
    soon as a file change is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final feature is to create new products. *Listing 20.33* adds a new `button`
    element that will send an `HTTP` `GET` request to start the editing process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.33: Adding an element to the product_table.handlebars file in the
    templates/admin folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20.34* updates the editor template so that a different `form` element
    is included in the HTML output, based on the value of a property named `create`,
    so `POST` requests are used when creating new products while `PUT` requests are
    used to modify existing data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.34: Changing the form in the product_editor.handlebars file in the
    templates/admin folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20.35* adds two new routes, which handle the `GET` request that starts
    the creation process and the `POST` request that is sent when the user submits
    the form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.35: Adding routes to the admin_catalog_routes.ts file in the src/routes
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let the browser reload or request `http://localhost:5000/admin`, and then click
    the **Create** button. Fill out the form and click the **Save** button to create
    a new product, as shown in *Figure 20.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.6: Creating a new product'
  prefs: []
  type: TYPE_NORMAL
- en: Administering orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the product features are in place, it is time to turn to the order
    data. Add a file named `admin_order_routes.ts` to the `src/routes/admin` folder
    with the content shown in *Listing 20.36*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.36: The contents of the admin_order_routes.ts file in the src/routes/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The route that handles `GET` requests renders a template named `admin/order_table`,
    which is provided with the orders from the database. Earlier queries used the
    `raw` setting, which tells Sequelize to pass on the data as it is read from the
    database, which is a good technique when the data is naturally in a structure
    that suits the template that consumes it. In this case, the nested `include` properties
    lead to queries that are not readily used without additional processing. Instead
    of using the `raw` setting, `Sequelize` processes the data, which is then converted
    to a simple object format using the `toJSON` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `toJSON` method is required because Sequelize usually creates objects that
    track changes so they can be written to a database, but this confuses the template
    engine. The `toJSON` method creates objects without the tracking functionality
    and which are suitable for template use.
  prefs: []
  type: TYPE_NORMAL
- en: The handler for `POST` requests is used to change the shipping status of orders.
    If a request is received that corresponds to an order in the database, then the
    database is updated and a redirection is performed using the `HTTP 303` status
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 20.37* enables the order routes so that they are reached through the
    `/api/orders` prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.37: Configuring routes in the index.ts file in the src/routes/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To create the template that will present the order data, add a file named `order_table.handlebars`
    to the `templates/admin` folder with the content shown in *Listing 20.38*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.38: The contents of the order_table.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The complexity in this template is the structure of the table, in which order
    details are presented using summary and detail rows. To create a template that
    will present the user with a button to change the shipping status, create a file
    named `order_button.handlebars` in the `templates/admin` folder, with the content
    shown in *Listing 20.39*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.39: The contents of the order_button.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `hx-post` attribute tells `HTMX` to send a `POST` request when the user
    clicks the button. *Listing 20.40* defines the helpers that are required for the
    orders template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.40: Adding a helper to the admin_helpers.ts file in the src/helpers
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `first` helper is used to determine whether a value is the first element
    in an array and to work out where to insert the customer details and the status
    change buttons. This relies on the Handlebars `each` helper, which provides an
    `@index` value that reports the index of the element being processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `total` helper calculates the total value of the product selections in
    the order and is combined with the existing `currency` helper to create a formatted
    total price for the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There are no orders in the seed data, so the first step in checking the administration
    features is to create some orders. Navigate to `http://localhost:5000`, add products
    to the cart, and check out to create an order. Navigate to `http://localhost:5000/admin`,
    click the **Orders** button, and use the buttons to toggle the shipment status
    of orders, as shown in *Figure 20.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.7: Changing the order shipping status'
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `HTMX` package makes asynchronous HTTP requests to the web service and displays
    the results, which is an effective way to create a responsible application, but
    the result doesn’t behave correctly. To see the problem, navigate to `http://localhost:5000/admin`,
    click the **Orders** button, and then click the browser’s reload button. Instead
    of reloading the **Orders** table, the products are displayed, as shown in *Figure
    20.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.8: Reloading the browser'
  prefs: []
  type: TYPE_NORMAL
- en: The browser isn’t aware of the effect of user interaction, and reloading effectively
    resets the client, which displays the product table. To fix this means defining
    a set of routes that allow direct navigation to specific application features,
    as well as configuring `HTMX` to add URLs that will target those routes following
    user interaction. *Listing 20.41* defines the routes required to navigate directly
    to the products table, the orders table, and the editor for a specific product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.41: Adding direct routes to the index.ts file in the src/routes/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The new routes render the `admin_layout` template with a `content` value that
    specifies the URL that `HTMX` should use to request content. For consistency,
    the `/admin` route sends a redirection to the `/admin/products` URL. *Listing
    20.42* updates the template to use the `content` value that is provided by the
    new routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.42: Loading a URL into the admin_layout.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The web service URLs that provide fragments of HTML content are of no use for
    direct navigation because they do not provide a complete HTML document. Fortunately,
    `HTMX` supports the `hx-push-url` attribute, which adds a URL to the browser’s
    history, as shown in *Listing 20.43*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.43: Pushing URLs into the area_buttons.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks on one of the buttons, the `HTMX` package will request
    a fragment of HTML from the web service but will add one of the direct navigation
    URLs to the browser’s history. *Listing 20.44* applies the same attribute to the
    button that starts the editing process for a product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.44: Pushing a URL into the product_row.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to `http://localhost:5000/admin`, and your browser will be redirected
    to `http://localhost:5000/admin/products`. Click the **Orders** button, and the
    URL bar will display `http://localhost:5000/admin/orders`, even though `HTMX`
    sent an HTTP request to the `/api/orders/table` URL.
  prefs: []
  type: TYPE_NORMAL
- en: Click the reload button, and the browser will display the **Orders** list. (The
    database will have been reset when the files changed and will not contain any
    orders.) Request `http://localhost:5000/admin/products/edit/2`, and you will see
    the editor for the `Lifejacket` product, as shown in *Figure 20.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.9: Navigating directly to an application feature'
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to administration features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access to the administration features should be restricted to approved users,
    which means implementing authentication and authorization. The application already
    has support to identify users, using Google accounts, and the quickest way to
    restrict access is to configure the application to restrict access to a predefined
    list of accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Using OAuth to authenticate administrators is a useful way to identify users,
    but care should be taken in real projects to ensure some form of administration
    access if the OAuth service is unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: To start, navigate to [https://console.developers.google.com](https://console.developers.google.com),
    click **Credentials**, and select the **Edit OAuth Client** action, which is represented
    by the pencil icon, as shown in *Figure 20.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.10: Editing the OAuth client'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following URLs to the **Authorized redirect URIs** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:5000/auth-signin-google`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://localhost/auth-signin-google`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should now be four URIs in this section, as shown in *Figure 20.11*. Click
    **Save** to update the OAuth configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.11: The authorized redirection URLs'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the code editor, add a new `configuration` section that provides
    the application with the OAuth redirection and a list of approved administration
    users, as shown in *Listing 20.45*. (You must enter the email address for a Google
    account for which you have the credentials to be able to authenticate yourself.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.45: Adding a configuration section to the server.config.json file
    in the sportsstore folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20.46* creates a new authentication strategy and adds a new property
    to the `User` interface that differentiates between authentication for administration
    and authentication for placing orders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.46: Creating a strategy in the authentication.ts file in the src
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The new strategy is created with the name `admin-auth` to differentiate it from
    the existing OAuth strategy. The new callback URL is read from the configuration
    file and used to create the strategy, and the callback function creates a USER
    with the `adminUser` property set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: There is no persistent data store for administration user details, so the `serializeUser`
    and `deserializeUser` functions have been modified to serialize the entire `User`
    object in the session, but only when the `adminUser` property is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: A new set of routes is required to handle administration authentication, along
    with middleware components to authorize requests, as shown in *Listing 20.47*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.47: Adding routes and middleware to the index.ts file in the src/routes/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The new routes are used to prompt the user to sign in, allow users to sign out
    again, and handle the Google OAuth redirections. The middleware components check
    that the signed-in user is one of the approved users from the configuration file,
    with redirection responses for the direct navigation routes and `401` responses
    for the web service routes.
  prefs: []
  type: TYPE_NORMAL
- en: To define the template that will be rendered when the user needs to sign in,
    add a file named `signin.handlebars` to the `templates/admin` folder with the
    content shown in *Listing 20.48*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.48: The contents of the signin.handlebars file in the templates/admin
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The final step is to show the signed-in user’s name and provide a **Sign out**
    button, as shown in *Listing 20.49*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 20.49: Adding user details to the admin_layout.handlebars file in the
    templates/admin folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to `http://localhost:5000/admin`, and you will be prompted to **Sign
    in with a Google account**, as shown in *Figure 20.12*. If the account matches
    the approved list, then you will be redirected to the administration features
    once the authentication process is complete. Clicking on the button at the top
    of the window will sign the user out of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_20_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.12: Signing in to the administration features'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I created administration tools to manage the catalog and set
    the order shipping status:'
  prefs: []
  type: TYPE_NORMAL
- en: The administration features use a RESTful web service that returns fragments
    of HTML, which are displayed using the `HTMX` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state is managed by the server, which renders templates to produce the HTML
    fragments that are returned by the web service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URLs are added to the browser’s history so that the reload and back buttons
    work as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the administration feature is restricted to authorized users who authenticate
    with their Google account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, I will prepare the *SportsStore* application for deployment.
  prefs: []
  type: TYPE_NORMAL
