- en: Connecting a Lex Bot to DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading the previous chapter, we know how to create a Lex chatbot. Now
    we can start building a chatbot that takes the user through a more complex flow.
    Designing and building larger chatbots is closer to what you are likely to be
    doing, and we'll look at the best ways to approach the design and setup.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using our chatbot to get data from S3 as well as getting and writing
    data to DynamoDB tables. This allows us to persist information about the users'
    choices and progress through the flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating flow diagrams for a larger, more complex chatbot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Lex chatbot to cover all of the intents and flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from an S3 bucket and performing logic upon it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Dynamo table and using it to store and retrieve information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating a Lambda function for our skill, and we'll
    be creating and deploying it using the local development setup that we created
    in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting Started with
    AWS and Amazon CLI*.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code and data required for this chapter can be found at [http://bit.ly/chatbot-ch6.](http://bit.ly/chatbot-ch6)
  prefs: []
  type: TYPE_NORMAL
- en: Designing the flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FAQ chatbot that we built in the previous chapter didn't need to have any
    flows designed as everything was simply a question and an answer. This chatbot
    will be a lot more complex, with multiple flows, some of which will lead to other
    intents and flows.
  prefs: []
  type: TYPE_NORMAL
- en: Perfect conversations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, we can start to build flow diagrams by starting with perfect conversations.
    The difference this time is that we will have a few different conversations. We'll
    have some that go from asking about stock to making a purchase, others will stop
    before checking out, and some people won't even add anything to their basket.
    These are all flows that we will need to design and build.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to start with a conversation that goes through the whole process.
    Here is one such conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd74cd0d-d0c9-4a36-9c0b-36cfb1fec56f.png)'
  prefs: []
  type: TYPE_IMG
- en: Full process conversation
  prefs: []
  type: TYPE_NORMAL
- en: We can also create other conversations that deal with part of the flow. A user
    could add some items to their basket and then save them for later, while another
    user will want to ask what is in their cart before checking out. You can probably
    see that some of these conversations will overlap. This will become more apparent
    as we progress onto our flow diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Flow diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this is a large and complex conversation, we are going to break the flow
    into sections. This will make it easier to create and visualize.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the full conversation, as well as the stock-checking conversation,
    can be used to create a `productFind` flow diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d828097-266f-4006-a24b-c341f4998227.png)'
  prefs: []
  type: TYPE_IMG
- en: The productFind flow diagram
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is some logic that is similar to the logic that we used
    in the Car Helper chatbot in [Chapter 3](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml),
    *Creating Your* *First Alexa Skill*. By the end of this flow, we know what product
    the user is asking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed a new symbol in this flow. This symbol is similar to `intentTrigger`
    but this is for starting another flow. Breaking the whole flow into smaller chunks
    that can call each other is the best way to keep your diagrams organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b91d2c7a-dee7-4a9c-920c-9fb10ae5b3fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Start another flow
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know what product the user is asking about, we can create a flow
    for checking stock and asking whether they want to add that to their cart. This
    starts with a request to S3, and if there is stock and they want it, we add it
    to their basket in Dynamo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5adffcb-a780-467d-a658-456936dc4922.png)'
  prefs: []
  type: TYPE_IMG
- en: Stock and cart
  prefs: []
  type: TYPE_NORMAL
- en: 'The last stage of this conversation is the checkout. This is about getting
    a few details about the user so we can place the order. This would normally include
    taking a card payment, but we won''t be doing that with this chatbot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/474d1365-9297-4ce0-a090-4ae846948f8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Checkout
  prefs: []
  type: TYPE_NORMAL
- en: The reason that we are breaking the conversation into multiple smaller flow
    diagrams is so that each flow does a single thing. This means that we can link
    different flows together. What if we have a user who knows the ID for the item?
    We can have them skip the `productFind` flow and start at the `lookupAndCart`
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we consider a few other conversations, we end up with a web of flows in
    a master flow diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0906373e-0a2a-4bb6-a6c8-a94daad7b648.png)'
  prefs: []
  type: TYPE_IMG
- en: Master flow diagram
  prefs: []
  type: TYPE_NORMAL
- en: This master flow diagram shows how each of the sub-flows can be connected together
    to map any conversation. This web of conversation allows the chatbot to deal with
    the user in a much more human way than older chatbots that had a single path that
    the user had to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Building the chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of the sub-flow diagrams and the master flow diagram, we can start
    to build the chatbot. Another great thing about having these sub-flows is that
    they are quite similar to intents.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start creating intents, we need to set up our Lex bot. In the
    Lex console, click Create and then follow the process for creating a Custom bot
    as described in [Chapter 5](e8792431-53cf-4a17-9837-edbfa381d507.xhtml), *Building
    Your First Amazon Lex Chatbot*.
  prefs: []
  type: TYPE_NORMAL
- en: Product find
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with the most common conversationâ€”finding a product. First, we'll
    create a new intent called `productFind`.
  prefs: []
  type: TYPE_NORMAL
- en: This intent will deal with users who want to find a product to add to their
    cart, as well as users just checking the stock levels, so we need to provide utterances
    to represent this. We also need to deal with user utterances such as, "I want
    a new jacket" and "Do you have any medium, blue shirts in stock?"
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture the slot values from the utterances, we can use curly braces around
    the slot name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/443c54cf-04b3-4ee6-ad35-e9fb8ba3839c.png)'
  prefs: []
  type: TYPE_IMG
- en: Utterances for productFind
  prefs: []
  type: TYPE_NORMAL
- en: 'With some utterances created, we need to create the slots and slot types. For
    the `productFind` intent, we need quite a few slots: `type`, `size`, `color`,
    `length`, and `itemNumber`. The first four are self-explanatory but `itemNumber`
    is less obvious.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to include an item number slot so that if a customer wants to buy a
    product that they already have, they don't need to go through the longer question-answer
    product-finding flow. These small things are what separate good bots from great
    bots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to choose a slot type for each of our slots. For the first four
    slots, we''re going to need to create custom slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type**: We are going to be selling three types of clothing: shirts, jackets,
    and trousers (pants).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the + next to Slot types and choose Create slot type. Name your slot something
    such as `clothingType` and select Restrict to Slot values and Synonyms. It is
    a good idea to be relatively specific with your slot type naming as you can't
    have two slot types with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: We can now add our values of the shirt, jacket, and trousers. We then need to
    add synonyms that the user might type. Instead of `shirt`, they may type `blouse`,
    `top`, or `t-shirt`. For `trousers`, they might type `a pair of trousers`, `pants`,
    or `a pair of pants`. Expand all of the synonyms for all of the values until you
    can't think of anything else.
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**: Size is going to be a very similar process to *type* with values
    of *large*, *medium*, and *small*. If this was for a genuine retailer, you''d
    have a lot more size options, and probably size options based on the type of item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to include some synonyms for each of the color values. We could use
    `AMAZON.Color` for the color but that would allow hundreds of colors through â€“
    to make our lives easier, we're going to have five colors.
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom slot type with the colors of *black*, *white*, *red*, *pink*,
    and *blue*. You can add synonyms of the colors, but it is more likely they are
    just saying a color we don't support.
  prefs: []
  type: TYPE_NORMAL
- en: '`Length`: Length has values of `long`, `standard`, and `short`. Make sure to
    add in any synonyms you can think of, such as `medium` and `normal` as synonyms
    for standard.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item Number**: We don''t need to create a new slot type for order numbers
    as we can use AMAZON.NUMBER. If we wanted to use item numbers, such as *SH429178*,
    where we use numbers and letters, we would have to use a custom slot type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/afdfb667-c905-490e-82c0-f6b262b3a8f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Competed slots
  prefs: []
  type: TYPE_NORMAL
- en: We need to change all of the slots to not be required. This is because if a
    user asks for an item by item number, we don't want to ask them about what size
    and color they want as the item has a size and color already.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Lambda that handles this intent is going to need to do a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to check whether it has an item number or all of the correct slots
    are filled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then needs to get our S3 stock data and check the stock levels of the item
    requested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is stock, it will ask the user whether they want to add it to their
    cart. If there's no stock, it will tell the user and ask whether they want to
    find another product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by creating a new folder in `Lambdas` called `productFind` and create
    an `index.js` file inside there. The `index.js` file can start with our default
    Node 8.10 handler and we will pass the event to a `handleProductFind` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this `handleProductFind` function, we start by checking the slot values.
    The first one to check is `itemNumber`, because if that one is present, we don''t
    need any of the other slots. After that, we check the type, size, and color before
    finally checking the length if the type is `trousers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can copy the code for the `type` check and repeat it for the `size`, `color`,
    and `length` slots, changing just `message` and `slotToElicit` for each test.
    The `length` check needs to be modified further so that it also checks that `type`
    is `trousers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the last check, we can call a function to get the item that the user
    has chosen through their selections. We need to pass through the slots so that
    we can filter down the items by user choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our `getItem()` function we need to do three things: get the data, filter
    out just the item that matches the user answers, and create a response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get all of the stock data from S3, we are going to create a `getStock()`
    function. This is going to be the same as the S3 requests that we have made before.
    We can then call that as the first part of the `getItem()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to require in `aws-sdk` and create an `s3` instance. In your folder,
    run `npm install --save aws-sdk`. Put this code at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the data, we need to filter out the correct item. Arrays have
    a very useful function called `.find`. This function will go through each of the
    items in an array and run some code on that item. This will happen until an item
    returns `true` when the function returns the item that satisfied the function.
    If no item satisfied the function, `undefined` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this to get the item that the user wants. We want to return `true`
    if all of the slots match the values on the item or the `itemNumber` matches.
    We also need to make sure that if the type is `trousers`, then the `length` matches
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we expect that we will have one item. If we don''t, either we''ve
    created the function incorrectly or the data was wrong. Either way, we need to
    tell the user that we haven''t managed to find the item that they were looking
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we found an item but there is no stock, then we can tell the user and ask
    whether they would like to find another product. This means we will be using the
    `confirmIntent` Lex response. This response takes an `intentName`, a `message`,
    and a `slots` object containing all of the slots with values or `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find the product and there is stock, then we need to tell the user how
    many we have in stock. One tricky thing we have to deal with is the plurality
    of the types. If we find more than one *shirt*, they are called *shirts*; when
    a user has chosen *trousers*, we could either have one *pair of trousers* or multiple
    *pairs of trousers*. To avoid making the message string really complicated, we
    can make a function that takes the type and stock and returns the correct unit
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we can create a much neater message for the user. The message
    that we will be asking will be whether they want to add this item to their basket.
    We can use another `confirmIntent` response with an `intentName` of `addToBasket`
    with slots of `itemNumber`, which are set to `matching.itemNumber`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this Lambda, we have been using a lot of `Lex.something` responses.
    These are methods on the `Lex` class. To make these work, we need to create a
    new class called `Lex`, which contains all of the Lex responses we talked about
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `LexResponses.js`, and inside we will create our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The objects that we return from these methods can be found at the end of the
    previous chapter, or the complete `LexResponses.js` file can be found at [bit.ly/chatbot-ch6](http://bit.ly/chatbot-ch6).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to require this class in this file and create a new instance of
    the class. At the top of our `productFind`/`index.js` file, add these two lines
    of code. The first line requires our `Lex` class from our `LexResponses` file,
    before the second line creates a new instance of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Earlier in this Lambda, we wrote that if there is no stock, we ask the user
    whether they want to find another order using `confirmIntent`. This `confirmIntent`
    response will hit our same Lambda, but there will be a slightly different format
    to the call. We need to look for those different requests and handle them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the Lambda was called with `confirmIntent`, then `event.currentIntent.confirmationStatus`
    will have a value of `Confirmed` or `Denied`. If the user denied the question
    (said "no"), then we can give them a goodbye message and close the message. If
    they confirmed, we can let the process fall through to the `handleProductFind()`
    function. The following code needs to be added in the `exports.handler` function
    before the `handleProductFind()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating the data for this Lambda is not difficult, but there is a lot of data
    to generate. A record needs to be created for every combination of color, size,
    and type of item, as well as every pair of trousers needing a short, standard,
    and long length. Each of these rows needs to be in an array with a key of **stock**.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the completed data file at [bit.ly/chatbot-ch6](http://bit.ly/chatbot-ch6).
    This file needs to be put into a new bucket called `shopping-stock` so our Lambda
    can access it. As in previous chapters, we don't need to change any of the permissions
    on the bucket or file from their defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test this Lambda, we can create some tests. These tests should test all
    of the scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the normal slots filled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the `itemNumber` slot filled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing a slot value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Denied` confirmation status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Confirmed` confirmation status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to use four tests to cover all of these scenarios as we can test `Confirmed`
    with any of the slot filled scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Lex console, navigate into the `productFind` Lambda, and at the top
    of the page click Configure test events. The first test event that we can test
    is missing a slot value. We can actually provide no slot values and we expect
    that the Lambda will ask us to choose a shirt, jacket, or trousers. This is the
    input for the first test. Name this test and click Save. When you click Test,
    you should get a successful response in the format we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can test for a Confirmed confirmation status and all slots filled
    in one test. Click the dropdown and select Configure test events again. This test
    object now also has `confirmationStatus` on the `currentIntent` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Similar tests can be created to test `Denied` requests and `itemNumber` requests.
    The exact code for the tests can be found in the `tests` file in the `productFind`
    code folder.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the intent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a Lambda to fulfill the intent, we need to go back into Lex
    and make sure that our intent is triggering that Lambda. As in [Chapter 5](e8792431-53cf-4a17-9837-edbfa381d507.xhtml),
    *Building Your First Amazon Lex Chatbot*, scroll to the Fulfillment section of
    the intent and select Lambda fulfillment. From the drop-down menu, we can choose
    our new `productFind` Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Save the intent and we're ready to move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Add to cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This intent is a simple intent. If a user says `Yes` to adding the item to the
    cart, then it adds the item to a cart in Dynamo and asks whether they want to
    checkout or add another item. If the user says no to adding the item to the cart,
    then it asks the user whether they want to find another product.
  prefs: []
  type: TYPE_NORMAL
- en: Inside Lex, we need to create a new intent called `addToCart` with a single
    slot of `itemNumber`. This `itemNumber` slot can be set to have the slot type
    of AMAZON.NUMBER as we've used simple numbers as our item numbers.
  prefs: []
  type: TYPE_NORMAL
- en: As we did in the last Lambda, we need to set this slot to *not be required*.
    If we required the slot and a user started the intent without one, they would
    be asked for the item number. Most people won't know items by item number so they
    wouldn't know what to put. If they enter anything that isn't valid, Lex will re-prompt
    them for the item number until they guess one or they fail three times. We want
    to be able to check whether there is an item number and to send them to `productFind`
    if there isn't.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start this Lambda, create another folder in the `Lambda` directory called
    `addToCart` with an `index.js` file inside. In your folder, we need to run `npm
    install --save aws-sdk` to make sure that we have access to AWS. We start, as
    normal, with our default node 8.10 function, and there are two things we need
    to do at the start of this function: check whether there is a `Denied` confirmation
    status, and call a `handleAddToCart` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the confirmation status is `denied`, we can ask the user whether they want
    to find another product, using `Lex.confirmIntent`. We have already programmed
    our `productFind` Lambda to deal with `confirmIntent` triggers so that should
    already be working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''re using the same `Lex.confirmIntent` function as in `productFind`,
    we need to copy the `LexResponses.js` file into this folder and add this code
    to the top of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the confirmation status dealt with, we can focus on adding the item to
    the cart. We need to create the `handleAddToCart` function; the first thing that
    this needs to do is check that we have an `itemNumber`. This check will be very
    similar to the checks at the start of our `productFind` Lambda, except a missing
    `itemNumber` will trigger `confirmIntent` on `productFind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If there is an item number, then we need to add the item to the user's cart.
    Next, we will be creating a new class, called `DB`, so that we can make requests,
    but for now we can assume that these methods exist.
  prefs: []
  type: TYPE_NORMAL
- en: To add an item to the user's cart, we need to check whether the user already
    has a cart. If they don't, the request will error and we need to create a new
    cart for them. We are using the same *to* error-catching method that we discussed
    in [Chapter 4](7567de44-8fd8-4f0a-b304-adfe6006e0a3.xhtml), *Connecting Your Alexa
    Skill to External APIs*, for error-handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shopping-cart` table will contain four keys:'
  prefs: []
  type: TYPE_NORMAL
- en: ID is a string of the conversation ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items is a list of `itemNumbers`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` is a name you can give to your cart to save it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TTL is the *time to live* for the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TTL is used so that the record is automatically deleted at a set time. This
    helps keep your database clean, and is very useful if you have to deal with data
    protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to get a record from the database using `DB.get`, which we will
    create later in this section. If it returns a value, we can use this as the existing
    cart. If there isn''t a `cartUser`, we will create a default cart. To ensure that
    the name is unique, we''ll use a UUID (universally unique identifier) by setting
    `name` to `uuidv4()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To get this working, we need to run `npm install --save uuid` while in out
    Lambda folder. We then need to include this line at the top of the `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a value for `cartUser` for both new and existing carts. To update
    this cart row, we can use the `spread` operator. This takes an object or array
    and spreads the values into the new object or array. Any values after the spread
    can overwrite the values in `spread`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This line of code takes the previous cart, adds a new item number to the `Items`
    list, and changes the *time to live* to be `7` days from now.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an updated cart, we need to write it to the table. If there is an error
    writing to the table, we need to tell the user using `Lex.close`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If adding the item to the cart worked, we can ask the user whether they want
    to add another product, checkout, or save the cart. Unlike when we've asked them
    whether they want to find another product or add this item to a cart, it isn't
    a *yes/no* question. They should answer with `I want to checkout`, `I want to
    save my cart`, or `I want to add another item`, which we will set as example utterances
    for the `checkout`, `saveCart`, and `productFind` intents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are trying to find out which intent the user wants to use, we can
    respond to Lex with an `elicitIntent` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we said earlier, we are going to use DynamoDB to store the cart information.
    We are going to have two Dynamo tables, one for current carts and one for placed
    orders. To create these, we need to go onto the AWS console and navigate to the
    `DynamoDB` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32efdd8b-b323-413c-ae43-273abcd3f7cd.png)'
  prefs: []
  type: TYPE_IMG
- en: DynamoDB console page
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Create table to start creating a new table. We are asked to name our
    table and select a primary key. We''re going to call our first table `shopping-cart`
    and set the Primary key to `ID`. The primary key is the value that we will be
    able to use to look up records, and it is best practice to use `ID` as the name
    of the Primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/231a5f1b-9f58-4aab-afdb-c8ecf77799b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Table creation
  prefs: []
  type: TYPE_NORMAL
- en: When we click the Create button, we will be taken to the main DynamoDB console
    page. There is a lot of information available on this page, but we only need to
    see that we have our `shopping-cart` table in the table list. When you have just
    created the table, it may have a loading indicator next to it as the creation
    process finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our table created, we need to write some code that allows us to work with
    it. Because we will be working with Dynamo in multiple intents and Lambdas, it
    is good practice to create reusable code. For this, we will create a `DB` class
    that provides methods to get, write, update, and deletes record from the database.
    Create a new file called `DB.js` in our `addToCart` folder, and inside we''re
    going to create a new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To allow us to access the Dynamo tables, AWS provides us with a DynamoDB document
    client. To create `documentClient`, we need to pass in a configuration object
    containing the region. This code can go at the top of our `DB` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to change your region to the region that your tables are located
    in. This should be either `eu-west-1` or `us-east-1`. If you are not sure, go
    to your AWS console and check your location setting. Ireland is `eu-west-1` and
    US East (N. Virginia) is `us-east-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve created our `documentClient` variable, we can move back into
    our class and create our methods. The first method that we are going to make is
    `write`. We need three things to write to a table: the row ID, the data that we
    want to write, and the table name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the usability of this class, we''re going to return a `Promise`.
    Inside this `Promise`, we first need to check the `ID`, `data`, and `table`. If
    any of them are missing, or if `ID` or `table` aren''t strings, we need to throw
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If `ID`, `data`, and `table` are all correct, we can write our data to the
    table. To write to a table, we need to pass the request into a specific format.
    The `Item` needs to be all of the data with an added `ID` field with a value of
    the row ID that we pass in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This `params` object can then be passed into the `documentClient.put()` method,
    which also takes a `callback` function. We `console.log` out the error or data
    from the response before resolving the data or rejecting the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we are creating this class, we are going to create the `get`, `update`, and
    `delete` methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`get` is very similar to `write`, taking just a `key`, `value`, and `table`.
    Instead of passing in the items that we want to write, we pass in the key that
    we want to match. This `key-value` pair needs to be set inside `params`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`get` works as you would expect for getting items based on the primary index,
    but what if we want to get items by a second value? We can''t use `documentClient.get()`,
    so we need to create a new function called `getDifferent`. This function uses
    `documentClient.query()` instead of `documentClient.get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`delete` is almost identical to `get`, with the main difference being that
    we call `documentClient.delete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method that we need to create is `update`. This is a very simple method
    as it just uses the other methods to do most of the work. It gets the data for
    the `ID` and then writes it back with the new key and value added on or changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve completed the `DB` class, we need to import it into our Lambda
    and create a new instance. At the top of our `index.js` file in the `addToCart`
    folder, we can add these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Our Lambdas have to deal with Dynamo as well as S3; we need to give these Lambdas
    the permissions they need to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Open up the AWS console and navigate to AIM. Under Roles in the menu on the
    left, find the role that we created back in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml),
    *Getting Started with AWS and Amazon CLI*. We're going to add Dynamo permissions
    to this role.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Dynamo permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our Lambdas are working with Dynamo and S3, we need to update our permissions
    the role that we use to build our Lambdas. Navigate to the `IAM` service and select
    the lambdaBasic role that we created in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml),
    *Getting Started with AWS and Amazon CLI*. Click Attach policy and search for
    Dynamo.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add AmazonDynamoDBFullAccess. This gives the Lambda permissions
    to read and write to Dynamo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f461327e-feb6-4c6c-9b13-41f4248ac394.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding DynamoDB policies
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we run any testing, we need to build and deploy our Lambda. Using the
    build script we created in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml),
    *Getting Started with AWS and Amazon CLI*, we can run `./build.sh addToCart` to
    build and deploy our new Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: With this complete, we can navigate to our Lambda console and select our new
    `addToCart` Lambda. Next to Test, we can click Configure test events.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are things that we need to test for this Lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Denied` confirmation status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Confirmed` confirmation status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trigger without an `itemNumber`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an item to a new cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an item to an existing cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `Denied` trigger is the easiest to test. You should get a response asking
    `Would you like to find another product?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test a `Confirmed` confirmation status and a trigger without an `itemNumber`
    in one test. We should get through to the `handleAddToCart` function, and then
    get a response telling us we need to select a product and asking whether we want
    to find one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The test for adding an item to a new cart and to an existing cart will be the
    same; you just have to run the test twice. The first time, there won''t be any
    existing order. The second time, there will be. You need to change the `ID` value
    every time you want to test a new cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Both times, you should get a response asking `Would you like to checkout or
    add another item to your basket?`.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is to add this tested Lambda as the handler for
    the intent. Navigate to the Lex chatbot and to the `addToCart` intent. In the
    Fulfillment section of the page, we can change the fulfillment to Lambda fulfillment
    and select our new `addToCart` Lambda to fulfill it.
  prefs: []
  type: TYPE_NORMAL
- en: Checkout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user wants to checkout, we are going to do a simplified checkout process.
    We are just going to ask them for a mailing address and tell them we'll collect
    payment on delivery. Behind the scenes, we're going to take their cart and move
    it into a new `shopping-orders` table.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we need to create a new intent in Lex called `checkout`. We can add
    utterances such as `I want to checkout`, `can I checkout please`, and just `checkout`.
    You can add more utterances that you expect a user might reply to, such as `Would
    you like to checkout or add another item to your basket?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access their cart using the *userId* on the event so the only other
    information we need is their `deliveryAddress` â€“ so we need to add that as a slot.
    The slot type for this slot can be set to AMAZON.PostalAddress and we can add
    a prompt of `What address do you want your products delivered to?`. We can set
    this slot to be required so that whenever this intent is triggered. This means
    that we should already have the delivery address when the fulfillment Lambda gets
    triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/864e93bc-b2b7-46f0-a8af-39e8b96b78a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Checkout slot
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the intent set up, we can create the Lambda. Create a new folder called
    `checkout` and add an `index.js` file. In your folder, we need to run `npm install
    --save aws-sdk`. We are going to start with the node 8.10 handler with the `confirmationStatus`
    check for a denied status. We may want to trigger this intent with `confirmIntent`
    in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already used `Lex` again, so we need to copy our `LexResponse.js` file
    into this folder and use our setup code at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can get into the bulk of this Lambda with our `handleCheckout` function.
    We are first going to check that we have a value in the `deliveryAddress` slot.
    If we don''t, then we''ll ask them for it using `elicitSlot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Once we know that we have a delivery address, we can turn their cart into an
    order. To do this, we'll get their cart and then put that into a `shopping-orders`
    table with their delivery address and date of order.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can create the code, we need to set up a new table in DynamoDB. Navigate
    to the Dynamo console in AWS and click Create table. Name our new table `shopping-orders`
    and give it a primary key of `ID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our Lambda code, we can now create the logic to place the order. First
    we need to get the cart, and then delete that cart. If we get an error, then we
    need to tell the user and ask whether there is anything else we can help them
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we successfully got a cart back, we can delete the cart, create a new `orders`
    object, and write that to our `shopping-orders` table. We delete the cart because
    we don''t expect to place an order and still have all of the items in your cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We generate a random ID by using `uuidv4()` again. This means that we also need
    to run `npm install --save uuid` and include `const uuidv4 = require('uuid/v4');`
    at the top of this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a `try`/`catch` for this as it allows us to make both of the requests
    and handle any errors in a single handler. If an error is thrown, it is likely
    that our code is wrong so we don''t want to make the user go through that again.
    Therefore, we''ll tell them there was an error and their order can''t be placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If there wasn''t an error, we can tell the user that their order was placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With all paths of the intent completed, we can use our build script to build
    and deploy our Lambda before testing. Navigate into your `Lambdas` folder and
    run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this Lambda, there are a few scenarios to test:'
  prefs: []
  type: TYPE_NORMAL
- en: Confirmed intent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Denied intent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No delivery address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user doesn't have a cart to checkout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user has a cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `Denied` intent should ask us whether we want to find a new product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Confirmed` intent and no delivery address can be tested together. We expect
    the status to have no effect on the process, and the response to ask us for our
    delivery address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To test a user without a cart, we can call the Lambda with a `userId` that
    would never have an order. We can choose a normal word as this will never be used
    as a `userID` in Lex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: From this test, we should be told `We couldn't find your cart.` and then asked
    whether we want to find a product.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last scenario is a successful order placement. This will need a little
    more work as we need to find a valid cart. To do this, we can go onto AWS and
    navigate to Dynamo. Select the `shopping-orders` table and then we can click the
    Items tab. This allows us to look directly at the items in our table so we can
    find a valid cart ID. Copy any of the IDs, and paste it as the value in this next
    test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: From this, we expect to get a response telling us that we have successfully
    placed an order. We can also check in our `shopping-orders` table that we have
    a new row. When running this test, we need to use a valid cart ID. Unfortunately,
    when we create an order, we delete the old cart, meaning that the ID is no longer
    valid so we need to get a new ID for every test.
  prefs: []
  type: TYPE_NORMAL
- en: As with all of the Lambdas and intents so far, the last thing we need to do
    is add this tested Lambda as the handler for the intent. Navigate to the Lex chatbot
    and then to the checkout intent. In the Fulfillment section of the page, we can
    change the fulfillment to Lambda fulfillment and select our new checkout Lambda
    to fulfill it.
  prefs: []
  type: TYPE_NORMAL
- en: Saving our cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created the flow for the perfect conversation, one where the
    user finds one or more products, adds them to their cart, and checks out straight
    away. This is good, but a lot of people will add things to their cart, leave,
    and then come back to checkout.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create an intent that lets the user save their cart and come back
    to it later to checkout. Most shopping websites will have a login system or use
    web caching to save a cart to a user, but we're going to save a cart by a *unique
    name*.
  prefs: []
  type: TYPE_NORMAL
- en: In our Lex console for this chatbot, we can add a new `saveCart` intent. At
    the end of the `addToCart` intent, we ask the user whether they want to `add another
    product, save your cart`, or `checkout`. We need to handle the utterances that
    the user might say to save their cart. Add utterances such as `save my cart` and
    `I want to save my cart for later`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cart` and `basket` words are very similar in meaning, so add some utterances
    with each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c26068a8-532e-402f-87b6-bd34274c3af5.png)'
  prefs: []
  type: TYPE_IMG
- en: saveCart sample utterances
  prefs: []
  type: TYPE_NORMAL
- en: We only need one slot for this intent. Add a slot of `cartName` with a slot
    type of AMAZON.Musician and a prompt of `What name would you like to save your
    cart as?`. Using a slot type of Musician might seem strange, but this slot type
    allows any value to be accepted, thereby allowing users to name their basket whatever
    they want. We can set the `cartName` slot to be required, as we'll always need
    a name to save the cart as.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new folder in the `Lambdas` folder, called `saveCart`, with an `index.js`
    file in it. In that `index.js` file, we''re going to start, as normal, with the
    node 8.10 async handler. We know that we are going to be using Lex responses and
    accessing dynamo, so we add those files and require them into our `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As we're going to be using Dynamo, we need to make sure to install `aws-sdk`
    by running `npm install --save aws-sdk`.
  prefs: []
  type: TYPE_NORMAL
- en: With this intent, we are never going to be doing `confirmIntent` on it, so we
    don't need to handle any confirmation status. This means the only function in
    our handler is a `handleSaveCart(event)` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `handleSaveCart` function, we need to get `userID` and `slots` from
    the event. We can then get `cartName` from the slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We first need to check that there is a `cartName` as there always needs to
    be. This should never be called since the `cartName` slot is required, but it
    is always safer to put it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a valid cart name, we first need to see whether the user has
    a cart to checkout. If they don''t, then we ask them whether they want to add
    an item to their cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can check whether there is already a cart with that name. To do this,
    we can try getting the cart with that name. If we can''t find a cart with that
    name it means that we won''t over-ride another cart when we save. If we do find
    a cart with that name, then we need to ask the user for a new cart name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To save their cart using that cart name, we return a function to add the name
    to the cart. This function starts by setting the cart name as the passed-in slot
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can carry on this function by writing the cart back to the table. If
    there is an error, we tell the user we can''t save their cart, otherwise we tell
    them it''s been saved and how to access it next time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As always, make sure to run the build script to deploy your Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamo changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this Lambda, we did `DB.get` using the `cartName` instead of the `ID`. To
    get this working, we need to index our table by `cartName`. Creating an index
    for a key allow us to search by the values. This is also why we set the default
    name for a cart to `uuidv4()`. Because we can search by the name, it needs to
    be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the Dynamo service in AWS and select the `shopping-cart` table.
    Across the top of this section is a row of tabs, and we''re going to choose *Indexes*
    and click Create index. This will open a popup where we need to enter the key
    we want to index, in this case, `cartName`. Click Create index and the index will
    start to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3429173d-8a40-4af8-ad31-4b6ee66347d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Secondary index
  prefs: []
  type: TYPE_NORMAL
- en: When this finishes the creation process, we will be able to do `getDifferent`
    requests on this table by `cartName`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing our `saveCart` intent requires only dealing with four scenarios: *no
    cart name, no cart to save, cart name already taken,* and *saving a cart.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing when there is no cart name is very simple. We expect this to ask us
    to give a name for our cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To test saving when we don''t have a cart, we can use a nonsense `userId` as
    there is no chance that there will be a cart for them. We need to pass in a valid
    `cartName` now so that we pass the first check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We are going to have to test the last two in a different order. We first test
    a successful saving of a cart. To do this, we need a `userId` with a cart. We
    can find that by going into our Dynamo console and looking at the Items tab on
    our `shopping-cart` table. Choose any of the IDs that are there and copy it into
    the `userId` value in the test object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We expect that this will be successful and we''ll be told how to get our cart
    next time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have saved a cart, we can try saving a different cart with the same
    name. We have to find a new `ID` for this test but leave the rest of the request
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we should be told that we can''t use that cart name and to try a
    different one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: With all of the tests responding as we expected, go back into the Lex console
    for this bot and change the fulfillment of the *saveCart* intent to the `saveCart`
    Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a saved cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the user can save their cart, we need to give them a way to get the
    cart that they saved. We can then change the cart so that it matches their `userId`,
    and then they can continue to add more items or checkout.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `getSavedCart` intent in Lex, and we're only going to be asking
    for the `cartName` of the cart they saved. As we did in the `saveCart` intent,
    we can set the `cartName` slot type to AMAZON.Musician to allow any values through.
    We can also set this slot to be required and have a prompt of `"What was the name
    you saved your cart to?"`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with the other intents so far, we can allow the user to enter the `cartName`
    as part of the utterance. This is done by including the slot name in the utterance
    with curly brackets around it. This can be used for utterances such as `"I want
    to get cart { cartName }"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as utterances that include the `cartName`, we will still have normal
    utterances such as `"I want to get my saved cart"` or `"get my cart"`. This utterance
    will get Lex to prompt the user for the `cartName` using the prompt we provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/407ff7c7-7f6e-4f1d-9f8b-87813caea938.png)'
  prefs: []
  type: TYPE_IMG
- en: Utterances for getSavedCart
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating a `getSavedCart` folder in our `Lambdas` directory, and
    inside we''re going to have an `index.js` file and copy our `DB.js` and `LexResponses.js`
    files from our previous Lambdas. Our `index.js` file will start as normal, with
    us importing and initiating our `DB` and `Lex` classes and using the node 8.10
    handler. We need to make sure to run `npm install --save aws-sdk` in our folder
    as well. We''ll never do a confirmed intent on this intent, so we only need to
    handle a `getSavedCart` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do in our Lambda is to get our `userId`, `slots`,
    and our `cartName` slot. We can then check that we have a `cartName` or ask the
    user for it if we don''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know we have a `cartName`, we can try to get the cart with that
    name. If we can''t get a cart with that name, then we need to ask whether they
    want to try another name or start a new cart. This will have to be an `elicitIntent`
    as they could go with either of two intents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To get this `elicitIntent` to work, we need to also add the utterance of `try
    another name` to `getSavedCart`, and `start a new cart` to the `productFind` intent.
  prefs: []
  type: TYPE_NORMAL
- en: '`DB.getDifferent` gets an array of matching carts, which is why we''re looking
    for `carts[0]`. We also need to extract our cart by adding this line after our
    error-handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If we found a cart for that `cartName`, then we need to do two things. We need
    to create a cart with those items on their current `userId`, and then we need
    to delete the old cart. If we don't delete the old cart, there will be two carts
    with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create the new cart by changing the ID and updating the TTL on the old
    cart. We also need to store the ID of the old cart so we can delete it too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: When we create the new cart and delete the old one, we can wrap them both in
    `try`/`catch` and handle any errors in the same way. If there are any errors,
    then we need to tell the user that we couldn't recover their cart and ask whether
    they want to start a new cart. This can be a `confirmIntent` on the `productFind`
    intent, which will start them at the beginning of the flow again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there''s no error, then we can tell them that we have got their cart and
    ask whether they want to checkout or get another item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: That is the end of this Lambda, so now we can build and deploy using our script
    and move on to testing it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test this, we need to test three things:'
  prefs: []
  type: TYPE_NORMAL
- en: No `cartName`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-existent `cartName`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Successfully getting their cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing no cart name is very simple. We expect to get a response asking for
    the cart name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To test a non-existent cart name, we need to use a name that someone isn''t
    going to use. We expect the response to say that a cart with that name couldn''t
    be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The last test requires us to look in the Dynamo tables again. This time, we
    are looking for an order with a valid name. If we completed the tests for `saveCart`,
    we should have a cart called `testCartSave`. This request should get a response
    saying that the cart has been found and asking whether they want to checkout or
    find another product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Once all of these tests pass, we can add this Lambda as the fulfillment method
    for our `getSavedCart` intent.
  prefs: []
  type: TYPE_NORMAL
- en: What's in my cart?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last intent we are going to make in this chapter. When a user asks
    what they have in their cart, we are going to give them a summary. This involves
    getting their cart and matching their item numbers up with the data in S3.
  prefs: []
  type: TYPE_NORMAL
- en: When we create this intent in Lex, we don't need any slotsâ€”the only information
    we need is their `userId`. The utterances will be questions about what is in their
    cart, such as `what is in my cart` and `how much have I got in my basket`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a new folder called `whatsInMyCart` in our Lambda directory with an
    `index.js` file, as well as copying `DB.js` and `LexResponses.js` into this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is going to need to access Dynamo to access the baskets and S3
    to get the product data. We start the `index.js` file by requiring in `DB.js`,
    `LexResponses.js`, and `aws-sdk`, and then creating new `DB`, `Lex`, and `S3`
    class instances. We don''t have any confirmations on this intent, so we can just
    return a `handleWhatsInMyCart` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'When a user triggers this intent, the first thing we need to do is get their
    cart. If they don''t have a cart, then we need to remind them that they can recover
    a saved cart or add new items to their existing cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If they do have a cart, then we can reformat the items into their cart into
    a more manageable format. The way that items are added to the cart, multiples
    of the same item are just separate items in the array. We can use some array logic
    to convert this into an object with item numbers as keys, which point to objects
    containing the quantity. This code goes through each item, and if we have already
    added that item to the `items` object, it adds 1 to the quantity. If this is the
    first unit of this item, then it sets the quantity to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'With our object of items, we need to map this to item descriptions. For this,
    we need the data from S3\. We can copy the same `getStock()` function that we
    used in `productFind` into this Lambda. If there is an error or we don''t get
    back a list of products, we need to tell the user that we have had a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We have our object of items and all of our products. We can use this to expand
    the data in our `items` object. To do this, we can map over each of the `products`
    and, if the `itemNumber` is in our `items` object, we add those details to that
    item''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an object that contains all the data we need. We can map over this
    and create a string describing the item and quantity. We can use the `Object.values()`
    method, which turns an object into an array that contains the values. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this to get the data for each of the items to create `itemStrings`,
    such as `2 blue jackets` or `1 long, black pair of trousers`. We can use the `units()`
    function that we created in `productFind` to deal with the units and with trousers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now join this array of item strings together into a one-cart summary.
    If there is one item, we can just say that item. Two items mean we need to add
    `and` between them, and we need to separate three or more items with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'With our message created, all we have left to do is to return our `Lex` response,
    which will be an `elicitIntent` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: With the Lambda completed, we need to build and deploy it, and move on to testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are only two situations to test for in this Lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: No cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Successful cart lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test for no cart, we can provide a non-existent `userId`. We should get
    a response telling us that our cart can''t be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To test a successful cart lookup, we need to go into our Dynamo table and find
    a cart with items in it. We should get a nicely formatted sentence describing
    the items in the cart and be asked whether we want to checkout, save, or add another
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: With the testing complete, we can go into the Lex bot and change the fulfilment
    for the `whatsInMyCart` intent to our `whatsInMyCart` Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the whole bot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created all of the Lambdas and tested that they all work, we
    can put it all together and build our chatbot. On the Lex console for this chatbot,
    go through each of the intents and make sure that they are all being fulfilled
    using the correct Lambda, and then we can click Build at the top of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it has finished building, we can start testing it out. We can start with
    finding a product. Typing `I want to buy a shirt` starts the `productFind` intent
    flow, and we can find the stock levels of the found item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4eb00e4a-aec2-4378-8528-73d245cd0128.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing productFind
  prefs: []
  type: TYPE_NORMAL
- en: 'When we get shown a product, we should also be asked whether we want to add
    this to our cart. No matter our answer, we should then be asked whether we want
    to checkout, add another item, or save our cart. We need to try each of these
    methods, starting with adding another item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c22027a-59e2-489c-b4d2-35d82975464b.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding another item to the cart
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, we are sent to the start of the `productFind` flow. Having gone
    through that flow but not added a new item to our cart, we can now test saving
    our cart. When we get to the end of a product find, we can say that we want to
    save our cart. When we provide a cart name, we are told that our cart has been
    saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/669206aa-f872-4b57-9d48-47213b2fff7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing saveCart
  prefs: []
  type: TYPE_NORMAL
- en: 'To test recovering a cart, we can clear the chat in Lex and ask to `get my
    saved cart`*.* We should be asked to enter our cart name and, if found, it will
    be recovered for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e9d9c3b-cd8c-4b07-a4f6-23d6bf3c7905.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing getSavedCart
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve got our saved cart back, we might want to check what we put
    in it. All we need to say is `what is in my cart` and we should get a summary
    of our products. As we only added the first product, we should have just one item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da3e9bf7-ec9e-4ceb-9503-6eed7cbeb92d.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing whatsInMyCart
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to test is checking out. With at least one item in our basket,
    we can ask to checkout. We should be asked for an address and then be told that
    our order has been placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d7353d5-9385-4f20-8ad2-11af84245a7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing checkout
  prefs: []
  type: TYPE_NORMAL
- en: With all of that tested, we have completed our shopping chatbot. If you've had
    any problems with these tests, go back and make sure that all of your code is
    correct and that Lex has been set up correctly. If you are having further issues,
    there is a set of debugging tips at the end of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered a lot. We started by designing a complex chatbot flow
    with multiple sub-flows. We then built these flows into a set of intents, which
    allow a user to go through the full process, or to do part of the process and
    return later. This meant we need to trigger intents directly from other intents,
    pre-populating some of the slots and using *confirmation intents* to change from
    one intent to another. We've also learned how to use DynamoDB tables to store
    and retrieve data about the progress of the users.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main difference between a complex flow and a simple flow?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we make complex flow diagrams easier to understand?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the five types of Lex fulfillment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the part of the AWS SDK that we can use to access DynamoDB
    tables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to learn more about the different ways to interact with Dynamo,
    I would recommend looking through the DocumentClient documentation. You can learn
    how to implement scans, queries, and batch processing. You can read that documentation
    at [https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html).
  prefs: []
  type: TYPE_NORMAL
