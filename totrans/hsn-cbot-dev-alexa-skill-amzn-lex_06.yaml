- en: Connecting a Lex Bot to DynamoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Lex Bot 连接到 DynamoDB
- en: After reading the previous chapter, we know how to create a Lex chatbot. Now
    we can start building a chatbot that takes the user through a more complex flow.
    Designing and building larger chatbots is closer to what you are likely to be
    doing, and we'll look at the best ways to approach the design and setup.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读上一章后，我们知道如何创建 Lex 聊天机器人。现在我们可以开始构建一个引导用户通过更复杂流程的聊天机器人。设计和构建更大的聊天机器人更接近你可能会做的事情，我们将探讨最佳的设计和设置方法。
- en: We'll be using our chatbot to get data from S3 as well as getting and writing
    data to DynamoDB tables. This allows us to persist information about the users'
    choices and progress through the flow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的聊天机器人从 S3 获取数据，以及从 DynamoDB 表中获取和写入数据。这使我们能够持久化关于用户选择和流程进度的信息。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating flow diagrams for a larger, more complex chatbot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为更大、更复杂的聊天机器人创建流程图
- en: Creating a Lex chatbot to cover all of the intents and flows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Lex 聊天机器人来涵盖所有意图和流程
- en: Retrieving data from an S3 bucket and performing logic upon it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 S3 存储桶中检索数据并在其上执行逻辑
- en: Creating a Dynamo table and using it to store and retrieve information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Dynamo 表并使用它来存储和检索信息
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be creating a Lambda function for our skill, and we'll
    be creating and deploying it using the local development setup that we created
    in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting Started with
    AWS and Amazon CLI*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的技能创建一个 Lambda 函数，并使用我们在第 2 章 [入门 AWS 和 Amazon CLI](ac448944-0559-408e-a9c4-972933a03611.xhtml)
    中创建的本地开发设置来创建和部署它。
- en: All of the code and data required for this chapter can be found at [http://bit.ly/chatbot-ch6.](http://bit.ly/chatbot-ch6)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的全部代码和数据可以在 [http://bit.ly/chatbot-ch6](http://bit.ly/chatbot-ch6) 找到。
- en: Designing the flows
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计流程
- en: The FAQ chatbot that we built in the previous chapter didn't need to have any
    flows designed as everything was simply a question and an answer. This chatbot
    will be a lot more complex, with multiple flows, some of which will lead to other
    intents and flows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中我们构建的 FAQ 聊天机器人不需要设计任何流程，因为一切都是简单的问题和答案。这个聊天机器人将更加复杂，具有多个流程，其中一些将引导到其他意图和流程。
- en: Perfect conversations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完美的对话
- en: As always, we can start to build flow diagrams by starting with perfect conversations.
    The difference this time is that we will have a few different conversations. We'll
    have some that go from asking about stock to making a purchase, others will stop
    before checking out, and some people won't even add anything to their basket.
    These are all flows that we will need to design and build.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们可以从完美的对话开始构建流程图。这次的不同之处在于我们将有几个不同的对话。我们将有一些从询问库存到进行购买，其他一些在结账前停止，还有一些人甚至不会将任何东西添加到他们的购物车中。这些都是我们需要设计和构建的流程。
- en: 'It is good to start with a conversation that goes through the whole process.
    Here is one such conversation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从头到尾进行对话是一个好主意。这里有一个这样的对话示例：
- en: '![](img/bd74cd0d-d0c9-4a36-9c0b-36cfb1fec56f.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd74cd0d-d0c9-4a36-9c0b-36cfb1fec56f.png)'
- en: Full process conversation
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 完整流程对话
- en: We can also create other conversations that deal with part of the flow. A user
    could add some items to their basket and then save them for later, while another
    user will want to ask what is in their cart before checking out. You can probably
    see that some of these conversations will overlap. This will become more apparent
    as we progress onto our flow diagrams.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建其他涉及流程一部分的对话。用户可以在他们的购物车中添加一些商品然后保存以备后用，而另一些用户在结账前会想要询问他们的购物车中有何物品。你可能已经看到，这些对话中的一些会有重叠。随着我们继续到流程图，这一点将变得更加明显。
- en: Flow diagrams
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程图
- en: As this is a large and complex conversation, we are going to break the flow
    into sections. This will make it easier to create and visualize.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个大而复杂的对话，我们将把流程分成几个部分。这将使创建和可视化更容易。
- en: 'The first part of the full conversation, as well as the stock-checking conversation,
    can be used to create a `productFind` flow diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完整对话的第一部分以及库存检查对话可以用来创建一个 `productFind` 流程图：
- en: '![](img/6d828097-266f-4006-a24b-c341f4998227.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d828097-266f-4006-a24b-c341f4998227.png)'
- en: The productFind flow diagram
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: productFind 流程图
- en: As you can see, there is some logic that is similar to the logic that we used
    in the Car Helper chatbot in [Chapter 3](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml),
    *Creating Your* *First Alexa Skill*. By the end of this flow, we know what product
    the user is asking about.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这里有一些逻辑与我们在第3章中使用的逻辑相似，在第3章中，我们讨论了如何创建你的第一个Alexa技能，即[创建你的第一个Alexa技能](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml)。在这个流程结束时，我们知道用户在询问什么产品。
- en: 'You may have noticed a new symbol in this flow. This symbol is similar to `intentTrigger`
    but this is for starting another flow. Breaking the whole flow into smaller chunks
    that can call each other is the best way to keep your diagrams organized:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在这个流程中注意到了一个新的符号。这个符号与`intentTrigger`类似，但这是用于启动另一个流程的。将整个流程分解成可以相互调用的较小块是保持图表组织最佳的方式：
- en: '![](img/b91d2c7a-dee7-4a9c-920c-9fb10ae5b3fd.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b91d2c7a-dee7-4a9c-920c-9fb10ae5b3fd.png)'
- en: Start another flow
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 启动另一个流程
- en: 'Now that we know what product the user is asking about, we can create a flow
    for checking stock and asking whether they want to add that to their cart. This
    starts with a request to S3, and if there is stock and they want it, we add it
    to their basket in Dynamo:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道用户在询问什么产品，我们可以创建一个检查库存并询问他们是否想将其添加到购物车的流程。这从请求S3开始，如果有库存并且他们想要，我们就将其添加到他们的Dynamo购物车中：
- en: '![](img/b5adffcb-a780-467d-a658-456936dc4922.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5adffcb-a780-467d-a658-456936dc4922.png)'
- en: Stock and cart
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 库存和购物车
- en: 'The last stage of this conversation is the checkout. This is about getting
    a few details about the user so we can place the order. This would normally include
    taking a card payment, but we won''t be doing that with this chatbot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这次对话的最后阶段是检查。这是获取一些关于用户的信息，以便我们可以下订单。这通常包括接受信用卡支付，但我们将不会在这个聊天机器人中这样做：
- en: '![](img/474d1365-9297-4ce0-a090-4ae846948f8f.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/474d1365-9297-4ce0-a090-4ae846948f8f.png)'
- en: Checkout
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 检查
- en: The reason that we are breaking the conversation into multiple smaller flow
    diagrams is so that each flow does a single thing. This means that we can link
    different flows together. What if we have a user who knows the ID for the item?
    We can have them skip the `productFind` flow and start at the `lookupAndCart`
    flow.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对话分解成多个较小的流程图的原因是，每个流程只做一件事情。这意味着我们可以将不同的流程连接起来。如果我们有一个知道项目ID的用户呢？我们可以让他们跳过`productFind`流程，直接从`lookupAndCart`流程开始。
- en: 'When we consider a few other conversations, we end up with a web of flows in
    a master flow diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑其他一些对话时，我们最终会在主流程图中得到一个流程的网状结构：
- en: '![](img/0906373e-0a2a-4bb6-a6c8-a94daad7b648.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0906373e-0a2a-4bb6-a6c8-a94daad7b648.png)'
- en: Master flow diagram
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 主流程图
- en: This master flow diagram shows how each of the sub-flows can be connected together
    to map any conversation. This web of conversation allows the chatbot to deal with
    the user in a much more human way than older chatbots that had a single path that
    the user had to follow.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主流程图显示了每个子流程如何连接在一起，以映射任何对话。这个对话网使得聊天机器人能够以一种比老式聊天机器人更人性化的方式处理用户，老式聊天机器人只有一个用户必须遵循的路径。
- en: Building the chatbot
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天机器人
- en: With all of the sub-flow diagrams and the master flow diagram, we can start
    to build the chatbot. Another great thing about having these sub-flows is that
    they are quite similar to intents.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有子流程图和主流程图的基础上，我们可以开始构建聊天机器人。拥有这些子流程的另一个好处是，它们与意图非常相似。
- en: Before we can start creating intents, we need to set up our Lex bot. In the
    Lex console, click Create and then follow the process for creating a Custom bot
    as described in [Chapter 5](e8792431-53cf-4a17-9837-edbfa381d507.xhtml), *Building
    Your First Amazon Lex Chatbot*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建意图之前，我们需要设置我们的Lex机器人。在Lex控制台中，点击创建，然后按照[第5章](e8792431-53cf-4a17-9837-edbfa381d507.xhtml)中描述的步骤创建自定义机器人，即*构建你的第一个Amazon
    Lex聊天机器人*。
- en: Product find
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品查找
- en: We will start with the most common conversation—finding a product. First, we'll
    create a new intent called `productFind`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最常见的对话开始——查找产品。首先，我们将创建一个新的意图，称为`productFind`。
- en: This intent will deal with users who want to find a product to add to their
    cart, as well as users just checking the stock levels, so we need to provide utterances
    to represent this. We also need to deal with user utterances such as, "I want
    a new jacket" and "Do you have any medium, blue shirts in stock?"
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个意图将处理想要将产品添加到购物车或只是检查库存水平的用户，因此我们需要提供表示这种意图的话语。我们还需要处理用户的话语，例如，“我想买一件新夹克”和“你们有库存的中号蓝色衬衫吗？”
- en: 'To capture the slot values from the utterances, we can use curly braces around
    the slot name:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获话语中的槽位值，我们可以在槽位名称周围使用花括号：
- en: '![](img/443c54cf-04b3-4ee6-ad35-e9fb8ba3839c.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/443c54cf-04b3-4ee6-ad35-e9fb8ba3839c.png)'
- en: Utterances for productFind
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: productFind的表述
- en: 'With some utterances created, we need to create the slots and slot types. For
    the `productFind` intent, we need quite a few slots: `type`, `size`, `color`,
    `length`, and `itemNumber`. The first four are self-explanatory but `itemNumber`
    is less obvious.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了一些表述之后，我们需要创建槽位和槽位类型。对于`productFind`意图，我们需要相当多的槽位：`type`、`size`、`color`、`length`和`itemNumber`。前四个槽位是显而易见的，但`itemNumber`则不那么明显。
- en: We want to include an item number slot so that if a customer wants to buy a
    product that they already have, they don't need to go through the longer question-answer
    product-finding flow. These small things are what separate good bots from great
    bots.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想包含一个项目编号槽位，这样如果客户想要购买他们已经拥有的产品，他们就不需要通过较长的问答式产品查找流程。这些小事情正是区分优秀机器人与卓越机器人的关键。
- en: 'Next, we need to choose a slot type for each of our slots. For the first four
    slots, we''re going to need to create custom slots:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为每个槽位选择一个槽位类型。对于前四个槽位，我们需要创建自定义槽位：
- en: '**Type**: We are going to be selling three types of clothing: shirts, jackets,
    and trousers (pants).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：我们将销售三种类型的服装：衬衫、夹克和裤子（长裤）。'
- en: Click the + next to Slot types and choose Create slot type. Name your slot something
    such as `clothingType` and select Restrict to Slot values and Synonyms. It is
    a good idea to be relatively specific with your slot type naming as you can't
    have two slot types with the same name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点击槽位类型旁边的+号并选择创建槽位类型。给你的槽位起一个像`clothingType`这样的名字，并选择限制到槽位值和同义词。在槽位类型命名时相对具体是一个好主意，因为你不能有两个同名槽位类型。
- en: We can now add our values of the shirt, jacket, and trousers. We then need to
    add synonyms that the user might type. Instead of `shirt`, they may type `blouse`,
    `top`, or `t-shirt`. For `trousers`, they might type `a pair of trousers`, `pants`,
    or `a pair of pants`. Expand all of the synonyms for all of the values until you
    can't think of anything else.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加衬衫、夹克和裤子的值。然后我们需要添加用户可能会输入的同义词。例如，他们可能会用`blouse`、`top`或`t-shirt`代替`shirt`。对于`trousers`，他们可能会说`a
    pair of trousers`、`pants`或`a pair of pants`。将所有值的同义词都扩展到你想不出更多为止。
- en: '**Size**: Size is going to be a very similar process to *type* with values
    of *large*, *medium*, and *small*. If this was for a genuine retailer, you''d
    have a lot more size options, and probably size options based on the type of item.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸**：尺寸的创建过程将与*类型*非常相似，具有*大*、*中*和*小*等值。如果这是一个真正的零售商，你会有更多的尺寸选项，并且可能基于物品类型提供尺寸选项。'
- en: Make sure to include some synonyms for each of the color values. We could use
    `AMAZON.Color` for the color but that would allow hundreds of colors through –
    to make our lives easier, we're going to have five colors.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为每个颜色值包含一些同义词。我们可以使用AMAZON.Color来表示颜色，但这将允许通过数百种颜色——为了使我们的工作更简单，我们将使用五种颜色。
- en: Create a custom slot type with the colors of *black*, *white*, *red*, *pink*,
    and *blue*. You can add synonyms of the colors, but it is more likely they are
    just saying a color we don't support.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含*黑色*、*白色*、*红色*、*粉色*和*蓝色*等颜色的自定义槽位类型。你可以添加颜色的同义词，但更有可能他们只是说了一个我们不支持的色彩。
- en: '`Length`: Length has values of `long`, `standard`, and `short`. Make sure to
    add in any synonyms you can think of, such as `medium` and `normal` as synonyms
    for standard.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`长度`：长度的值有`long`、`standard`和`short`。确保添加任何你能想到的同义词，例如`medium`和`normal`作为标准的同义词。'
- en: '**Item Number**: We don''t need to create a new slot type for order numbers
    as we can use AMAZON.NUMBER. If we wanted to use item numbers, such as *SH429178*,
    where we use numbers and letters, we would have to use a custom slot type:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目编号**：我们不需要为订单编号创建新的槽位类型，因为我们可以使用AMAZON.NUMBER。如果我们想使用项目编号，例如*SH429178*，其中我们使用数字和字母，我们就必须使用自定义槽位类型：'
- en: '![](img/afdfb667-c905-490e-82c0-f6b262b3a8f4.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afdfb667-c905-490e-82c0-f6b262b3a8f4.png)'
- en: Competed slots
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的槽位
- en: We need to change all of the slots to not be required. This is because if a
    user asks for an item by item number, we don't want to ask them about what size
    and color they want as the item has a size and color already.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将所有槽位改为非必需。这是因为如果用户通过项目编号请求物品，我们不希望询问他们想要什么尺寸和颜色，因为物品已经有尺寸和颜色了。
- en: Creating the Lambda
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Lambda
- en: 'The Lambda that handles this intent is going to need to do a few things:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此意图的Lambda需要做几件事情：
- en: It needs to check whether it has an item number or all of the correct slots
    are filled.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要检查是否有项目编号或者所有正确的槽位都已填写。
- en: It then needs to get our S3 stock data and check the stock levels of the item
    requested.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它需要获取我们的S3库存数据并检查请求商品的库存水平。
- en: If there is stock, it will ask the user whether they want to add it to their
    cart. If there's no stock, it will tell the user and ask whether they want to
    find another product.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有库存，它会询问用户是否想要将其添加到购物车。如果没有库存，它会告诉用户，并询问他们是否想要寻找另一个产品。
- en: 'Start by creating a new folder in `Lambdas` called `productFind` and create
    an `index.js` file inside there. The `index.js` file can start with our default
    Node 8.10 handler and we will pass the event to a `handleProductFind` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`Lambdas`中创建一个名为`productFind`的新文件夹，并在其中创建一个`index.js`文件。`index.js`文件可以以我们的默认Node
    8.10处理程序开始，并将事件传递给`handleProductFind`函数：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside this `handleProductFind` function, we start by checking the slot values.
    The first one to check is `itemNumber`, because if that one is present, we don''t
    need any of the other slots. After that, we check the type, size, and color before
    finally checking the length if the type is `trousers`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleProductFind`函数内部，我们首先检查槽位值。首先检查的是`itemNumber`，因为如果这个槽位存在，我们就不需要检查其他任何槽位。之后，我们检查类型、尺寸和颜色，最后如果类型是`trousers`，再检查长度：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can copy the code for the `type` check and repeat it for the `size`, `color`,
    and `length` slots, changing just `message` and `slotToElicit` for each test.
    The `length` check needs to be modified further so that it also checks that `type`
    is `trousers`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以复制用于类型检查的代码，并重复用于`size`、`color`和`length`槽位，只需为每个测试更改`message`和`slotToElicit`。对于`length`检查，还需要进一步修改，以便它也检查`type`是否为`trousers`：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the last check, we can call a function to get the item that the user
    has chosen through their selections. We need to pass through the slots so that
    we can filter down the items by user choice:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的检查之后，我们可以调用一个函数来获取用户通过选择所选择的商品。我们需要传递槽位，以便我们可以根据用户的选择过滤商品：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside our `getItem()` function we need to do three things: get the data, filter
    out just the item that matches the user answers, and create a response.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`getItem()`函数中，我们需要做三件事：获取数据、过滤出与用户答案匹配的商品，并创建响应。
- en: 'To get all of the stock data from S3, we are going to create a `getStock()`
    function. This is going to be the same as the S3 requests that we have made before.
    We can then call that as the first part of the `getItem()` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从S3获取所有库存数据，我们将创建一个`getStock()`函数。这将与之前我们发出的S3请求相同。然后我们可以将其作为`getItem()`函数的第一部分调用：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also need to require in `aws-sdk` and create an `s3` instance. In your folder,
    run `npm install --save aws-sdk`. Put this code at the top of the file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要引入`aws-sdk`并创建一个`s3`实例。在你的文件夹中运行`npm install --save aws-sdk`。将此代码放在文件顶部：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have the data, we need to filter out the correct item. Arrays have
    a very useful function called `.find`. This function will go through each of the
    items in an array and run some code on that item. This will happen until an item
    returns `true` when the function returns the item that satisfied the function.
    If no item satisfied the function, `undefined` is returned.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，我们需要过滤出正确的商品。数组有一个非常有用的函数叫做`.find`。这个函数将遍历数组中的每个商品，并对该商品执行一些代码。这将会一直发生，直到一个商品返回`true`，此时函数返回满足条件的商品。如果没有商品满足条件，则返回`undefined`。
- en: 'We can use this to get the item that the user wants. We want to return `true`
    if all of the slots match the values on the item or the `itemNumber` matches.
    We also need to make sure that if the type is `trousers`, then the `length` matches
    as well:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个方法来获取用户想要的商品。我们希望如果所有槽位的值与商品上的值匹配，或者`itemNumber`匹配，则返回`true`。我们还需要确保如果类型是`trousers`，则长度也要匹配：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After this, we expect that we will have one item. If we don''t, either we''ve
    created the function incorrectly or the data was wrong. Either way, we need to
    tell the user that we haven''t managed to find the item that they were looking
    for:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们预计将只有一个商品。如果没有，要么是我们创建函数的方式不正确，要么是数据有误。无论如何，我们需要告诉用户我们没有找到他们正在寻找的商品：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we found an item but there is no stock, then we can tell the user and ask
    whether they would like to find another product. This means we will be using the
    `confirmIntent` Lex response. This response takes an `intentName`, a `message`,
    and a `slots` object containing all of the slots with values or `null`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到了一个商品，但没有库存，那么我们可以告诉用户，并询问他们是否想要寻找另一个产品。这意味着我们将使用`confirmIntent` Lex响应。此响应需要一个`intentName`、一个`message`以及包含所有具有值或`null`的槽位的`slots`对象：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we find the product and there is stock, then we need to tell the user how
    many we have in stock. One tricky thing we have to deal with is the plurality
    of the types. If we find more than one *shirt*, they are called *shirts*; when
    a user has chosen *trousers*, we could either have one *pair of trousers* or multiple
    *pairs of trousers*. To avoid making the message string really complicated, we
    can make a function that takes the type and stock and returns the correct unit
    name:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到了产品并且有库存，那么我们需要告诉用户我们有多少库存。我们必须处理的一个棘手问题是类型的复数形式。如果我们找到多个 *shirt*，它们被称为
    *shirts*；当用户选择了 *trousers* 时，我们可能有一 *pair of trousers* 或多 *pairs of trousers*。为了避免使消息字符串变得过于复杂，我们可以创建一个函数，该函数接受类型和库存并返回正确的单位名称：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This means that we can create a much neater message for the user. The message
    that we will be asking will be whether they want to add this item to their basket.
    We can use another `confirmIntent` response with an `intentName` of `addToBasket`
    with slots of `itemNumber`, which are set to `matching.itemNumber`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以为用户创建一个更整洁的消息。我们将询问的消息将是他们是否想要将此项目添加到他们的购物篮中。我们可以使用另一个具有 `intentName`
    为 `addToBasket` 且槽位设置为 `matching.itemNumber` 的 `confirmIntent` 响应：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Throughout this Lambda, we have been using a lot of `Lex.something` responses.
    These are methods on the `Lex` class. To make these work, we need to create a
    new class called `Lex`, which contains all of the Lex responses we talked about
    in the previous chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个 Lambda 中，我们使用了大量的 `Lex.something` 响应。这些是 `Lex` 类上的方法。为了使这些方法工作，我们需要创建一个名为
    `Lex` 的新类，它包含我们在上一章中讨论的所有 Lex 响应。
- en: 'Create a new file called `LexResponses.js`, and inside we will create our class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `LexResponses.js` 的新文件，然后我们在其中创建我们的类：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The objects that we return from these methods can be found at the end of the
    previous chapter, or the complete `LexResponses.js` file can be found at [bit.ly/chatbot-ch6](http://bit.ly/chatbot-ch6).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这些方法返回的对象可以在上一章的末尾找到，或者完整的 `LexResponses.js` 文件可以在 [bit.ly/chatbot-ch6](http://bit.ly/chatbot-ch6)
    找到。
- en: 'We then need to require this class in this file and create a new instance of
    the class. At the top of our `productFind`/`index.js` file, add these two lines
    of code. The first line requires our `Lex` class from our `LexResponses` file,
    before the second line creates a new instance of this class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在这个文件中引入这个类并创建这个类的新实例。在 `productFind`/`index.js` 文件的顶部，添加这两行代码。第一行在第二行创建这个类的新实例之前，从我们的
    `LexResponses` 文件中引入我们的 `Lex` 类：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Earlier in this Lambda, we wrote that if there is no stock, we ask the user
    whether they want to find another order using `confirmIntent`. This `confirmIntent`
    response will hit our same Lambda, but there will be a slightly different format
    to the call. We need to look for those different requests and handle them accordingly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 Lambda 的早期，我们写道，如果没有库存，我们将使用 `confirmIntent` 询问用户是否想要使用 `confirmIntent`
    查找另一个订单。这个 `confirmIntent` 响应将调用我们的同一个 Lambda，但调用格式会有所不同。我们需要寻找这些不同的请求并相应地处理它们。
- en: 'If the Lambda was called with `confirmIntent`, then `event.currentIntent.confirmationStatus`
    will have a value of `Confirmed` or `Denied`. If the user denied the question
    (said "no"), then we can give them a goodbye message and close the message. If
    they confirmed, we can let the process fall through to the `handleProductFind()`
    function. The following code needs to be added in the `exports.handler` function
    before the `handleProductFind()` function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Lambda 被调用为 `confirmIntent`，则 `event.currentIntent.confirmationStatus` 将有一个值为
    `Confirmed` 或 `Denied`。如果用户拒绝问题（说“不”），则我们可以给他们一个告别消息并关闭消息。如果他们确认，我们可以让流程继续到 `handleProductFind()`
    函数。以下代码需要在 `exports.handler` 函数中 `handleProductFind()` 函数之前添加：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating the data
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据
- en: Creating the data for this Lambda is not difficult, but there is a lot of data
    to generate. A record needs to be created for every combination of color, size,
    and type of item, as well as every pair of trousers needing a short, standard,
    and long length. Each of these rows needs to be in an array with a key of **stock**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个 Lambda 创建数据并不困难，但需要生成大量的数据。需要为每种颜色、尺寸和物品类型的组合以及每条需要短、标准或长长度的裤子创建一个记录。每一行都需要在一个带有
    **stock** 键的数组中。
- en: You can download the completed data file at [bit.ly/chatbot-ch6](http://bit.ly/chatbot-ch6).
    This file needs to be put into a new bucket called `shopping-stock` so our Lambda
    can access it. As in previous chapters, we don't need to change any of the permissions
    on the bucket or file from their defaults.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载完成的文件数据在 [bit.ly/chatbot-ch6](http://bit.ly/chatbot-ch6)。这个文件需要放入一个名为 `shopping-stock`
    的新存储桶中，以便我们的 Lambda 可以访问它。正如前几章所述，我们不需要更改存储桶或文件的任何权限。
- en: Lambda testing
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 测试
- en: 'To test this Lambda, we can create some tests. These tests should test all
    of the scenarios:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个 Lambda，我们可以创建一些测试。这些测试应该测试所有场景：
- en: All of the normal slots filled
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有正常槽位都已填写
- en: Only the `itemNumber` slot filled
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有 `itemNumber` 槽位已填写
- en: Missing a slot value
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少槽位值
- en: A `Denied` confirmation status
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Denied` 确认状态'
- en: A `Confirmed` confirmation status
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Confirmed` 确认状态'
- en: We need to use four tests to cover all of these scenarios as we can test `Confirmed`
    with any of the slot filled scenarios.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用四个测试来覆盖所有这些场景，因为我们可以在任何槽位填写场景中使用 `Confirmed` 进行测试。
- en: 'In the Lex console, navigate into the `productFind` Lambda, and at the top
    of the page click Configure test events. The first test event that we can test
    is missing a slot value. We can actually provide no slot values and we expect
    that the Lambda will ask us to choose a shirt, jacket, or trousers. This is the
    input for the first test. Name this test and click Save. When you click Test,
    you should get a successful response in the format we expect:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lex 控制台中，导航到 `productFind` Lambda，然后在页面顶部点击配置测试事件。我们可以测试的第一个测试事件是缺少槽位值。我们实际上可以不提供任何槽位值，并期望
    Lambda 会要求我们选择衬衫、夹克或裤子。这是第一个测试的输入。为此测试命名并点击保存。当你点击测试时，你应该得到我们期望的成功响应格式：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we can test for a Confirmed confirmation status and all slots filled
    in one test. Click the dropdown and select Configure test events again. This test
    object now also has `confirmationStatus` on the `currentIntent` object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在一个测试中测试 `Confirmed` 确认状态以及所有槽位都已填写。点击下拉菜单并选择再次配置测试事件。这个测试对象现在在 `currentIntent`
    对象上也有 `confirmationStatus`：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similar tests can be created to test `Denied` requests and `itemNumber` requests.
    The exact code for the tests can be found in the `tests` file in the `productFind`
    code folder.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建类似的测试来测试 `Denied` 请求和 `itemNumber` 请求。测试的确切代码可以在 `productFind` 代码文件夹中的 `tests`
    文件中找到。
- en: Completing the intent
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成意图
- en: Now that we have a Lambda to fulfill the intent, we need to go back into Lex
    and make sure that our intent is triggering that Lambda. As in [Chapter 5](e8792431-53cf-4a17-9837-edbfa381d507.xhtml),
    *Building Your First Amazon Lex Chatbot*, scroll to the Fulfillment section of
    the intent and select Lambda fulfillment. From the drop-down menu, we can choose
    our new `productFind` Lambda.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 Lambda 来实现这个意图，我们需要回到 Lex 并确保我们的意图正在触发这个 Lambda。正如 [第 5 章](e8792431-53cf-4a17-9837-edbfa381d507.xhtml)，*构建您的第一个
    Amazon Lex 聊天机器人*，滚动到意图的满足部分并选择 Lambda 满足。从下拉菜单中，我们可以选择我们新的 `productFind` Lambda。
- en: Save the intent and we're ready to move on to the next step.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 保存意图，我们就可以继续下一步了。
- en: Add to cart
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到购物车
- en: This intent is a simple intent. If a user says `Yes` to adding the item to the
    cart, then it adds the item to a cart in Dynamo and asks whether they want to
    checkout or add another item. If the user says no to adding the item to the cart,
    then it asks the user whether they want to find another product.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个意图是一个简单的意图。如果用户说 `Yes` 添加项目到购物车，那么它就会将项目添加到 Dynamo 中的购物车，并询问他们是否想要结账或添加另一个项目。如果用户说
    `No` 添加项目到购物车，那么它会询问用户是否想要寻找另一个产品。
- en: Inside Lex, we need to create a new intent called `addToCart` with a single
    slot of `itemNumber`. This `itemNumber` slot can be set to have the slot type
    of AMAZON.NUMBER as we've used simple numbers as our item numbers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lex 中，我们需要创建一个名为 `addToCart` 的新意图，它有一个名为 `itemNumber` 的单个槽位。这个 `itemNumber`
    槽位可以被设置为具有 AMAZON.NUMBER 槽位类型，因为我们已经使用简单的数字作为我们的项目编号。
- en: As we did in the last Lambda, we need to set this slot to *not be required*.
    If we required the slot and a user started the intent without one, they would
    be asked for the item number. Most people won't know items by item number so they
    wouldn't know what to put. If they enter anything that isn't valid, Lex will re-prompt
    them for the item number until they guess one or they fail three times. We want
    to be able to check whether there is an item number and to send them to `productFind`
    if there isn't.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个 Lambda 中所做的那样，我们需要将此槽设置为 *非必需的*。如果我们要求槽，而用户在没有槽的情况下启动了意图，他们将被要求输入商品编号。大多数人不会通过商品编号来识别商品，因此他们不知道该输入什么。如果他们输入任何无效的内容，Lex
    将会重新提示他们输入商品编号，直到他们猜对或者失败三次。我们希望能够检查是否存在商品编号，并在没有商品编号的情况下将他们发送到 `productFind`。
- en: Creating the Lambda
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Lambda
- en: 'To start this Lambda, create another folder in the `Lambda` directory called
    `addToCart` with an `index.js` file inside. In your folder, we need to run `npm
    install --save aws-sdk` to make sure that we have access to AWS. We start, as
    normal, with our default node 8.10 function, and there are two things we need
    to do at the start of this function: check whether there is a `Denied` confirmation
    status, and call a `handleAddToCart` function.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动此 Lambda，请在 `Lambda` 目录中创建一个名为 `addToCart` 的文件夹，并在其中创建一个 `index.js` 文件。在您的文件夹中，我们需要运行
    `npm install --save aws-sdk` 以确保我们有权访问 AWS。我们像往常一样，从默认的 node 8.10 函数开始，在这个函数的开始，我们需要做两件事：检查是否存在
    `Denied` 确认状态，并调用 `handleAddToCart` 函数。
- en: 'If the confirmation status is `denied`, we can ask the user whether they want
    to find another product, using `Lex.confirmIntent`. We have already programmed
    our `productFind` Lambda to deal with `confirmIntent` triggers so that should
    already be working:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确认状态是 `denied`，我们可以使用 `Lex.confirmIntent` 询问用户是否想要寻找另一个产品。我们已经编程了 `productFind`
    Lambda 来处理 `confirmIntent` 触发，所以它应该已经正常工作：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we''re using the same `Lex.confirmIntent` function as in `productFind`,
    we need to copy the `LexResponses.js` file into this folder and add this code
    to the top of this file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用与 `productFind` 中相同的 `Lex.confirmIntent` 函数，我们需要将 `LexResponses.js`
    文件复制到这个文件夹中，并将此代码添加到文件的顶部：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the confirmation status dealt with, we can focus on adding the item to
    the cart. We need to create the `handleAddToCart` function; the first thing that
    this needs to do is check that we have an `itemNumber`. This check will be very
    similar to the checks at the start of our `productFind` Lambda, except a missing
    `itemNumber` will trigger `confirmIntent` on `productFind`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 确认状态处理完毕后，我们可以专注于将商品添加到购物车中。我们需要创建 `handleAddToCart` 函数；这个函数需要做的第一件事是检查我们是否有
    `itemNumber`。这个检查将与我们的 `productFind` Lambda 开始时的检查非常相似，只是缺少 `itemNumber` 将在 `productFind`
    上触发 `confirmIntent`：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If there is an item number, then we need to add the item to the user's cart.
    Next, we will be creating a new class, called `DB`, so that we can make requests,
    but for now we can assume that these methods exist.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有商品编号，那么我们需要将商品添加到用户的购物车中。接下来，我们将创建一个新的类，称为 `DB`，这样我们就可以发出请求，但现在我们可以假设这些方法存在。
- en: To add an item to the user's cart, we need to check whether the user already
    has a cart. If they don't, the request will error and we need to create a new
    cart for them. We are using the same *to* error-catching method that we discussed
    in [Chapter 4](7567de44-8fd8-4f0a-b304-adfe6006e0a3.xhtml), *Connecting Your Alexa
    Skill to External APIs*, for error-handling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要将商品添加到用户的购物车中，我们需要检查用户是否已经有了购物车。如果没有，请求将出错，我们需要为他们创建一个新的购物车。我们正在使用与我们在 [第 4
    章](7567de44-8fd8-4f0a-b304-adfe6006e0a3.xhtml) 中讨论的相同的 *to* 错误捕获方法，即 *将您的 Alexa
    技能连接到外部 API*，用于错误处理。
- en: 'The `shopping-cart` table will contain four keys:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`shopping-cart` 表将包含四个键：'
- en: ID is a string of the conversation ID
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID 是会话 ID 的字符串
- en: Items is a list of `itemNumbers`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商品列表是一个 `itemNumbers` 的列表
- en: '`name` is a name you can give to your cart to save it'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是您可以给您的购物车起的名字以保存它'
- en: TTL is the *time to live* for the data
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TTL 是数据的 *生存时间*
- en: The TTL is used so that the record is automatically deleted at a set time. This
    helps keep your database clean, and is very useful if you have to deal with data
    protection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TTL 用于在设定的时间自动删除记录。这有助于保持数据库的清洁，并且当您必须处理数据保护时非常有用。
- en: 'We can try to get a record from the database using `DB.get`, which we will
    create later in this section. If it returns a value, we can use this as the existing
    cart. If there isn''t a `cartUser`, we will create a default cart. To ensure that
    the name is unique, we''ll use a UUID (universally unique identifier) by setting
    `name` to `uuidv4()`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用`DB.get`从数据库中获取一个记录，我们将在本节稍后创建它。如果它返回一个值，我们可以将其用作现有购物车。如果没有`cartUser`，我们将创建一个默认购物车。为了确保名称是唯一的，我们将使用UUID（通用唯一标识符），将`name`设置为`uuidv4()`：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To get this working, we need to run `npm install --save uuid` while in out
    Lambda folder. We then need to include this line at the top of the `index.js`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个功能正常工作，我们需要在Lambda文件夹中运行`npm install --save uuid`。然后我们需要在`index.js`文件的顶部包含这一行：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we have a value for `cartUser` for both new and existing carts. To update
    this cart row, we can use the `spread` operator. This takes an object or array
    and spreads the values into the new object or array. Any values after the spread
    can overwrite the values in `spread`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为新的和现有的购物车都有一个`cartUser`的值。为了更新这个购物车行，我们可以使用`spread`操作符。这个操作符接受一个对象或数组，并将值扩展到新的对象或数组中。任何在扩展之后的值可以覆盖`spread`中的值：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This line of code takes the previous cart, adds a new item number to the `Items`
    list, and changes the *time to live* to be `7` days from now.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将之前的购物车，添加一个新的项目编号到`Items`列表，并将*生存时间*更改为从现在开始的`7`天。
- en: 'With an updated cart, we need to write it to the table. If there is an error
    writing to the table, we need to tell the user using `Lex.close`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了购物车之后，我们需要将其写入表中。如果写入表时发生错误，我们需要使用`Lex.close`告诉用户：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If adding the item to the cart worked, we can ask the user whether they want
    to add another product, checkout, or save the cart. Unlike when we've asked them
    whether they want to find another product or add this item to a cart, it isn't
    a *yes/no* question. They should answer with `I want to checkout`, `I want to
    save my cart`, or `I want to add another item`, which we will set as example utterances
    for the `checkout`, `saveCart`, and `productFind` intents.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将项目添加到购物车成功，我们可以询问用户他们是否想要添加另一个产品、结账或保存购物车。与询问他们是否想要寻找另一个产品或添加此项目到购物车不同，这不是一个*是/否*问题。他们应该回答“我想结账”、“我想保存我的购物车”或“我想添加另一个项目”，我们将这些设置为`checkout`、`saveCart`和`productFind`意图的示例话语。
- en: 'Because we are trying to find out which intent the user wants to use, we can
    respond to Lex with an `elicitIntent` response:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们试图找出用户想要使用哪个意图，我们可以向Lex发送一个`elicitIntent`响应：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: DynamoDB
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DynamoDB
- en: 'As we said earlier, we are going to use DynamoDB to store the cart information.
    We are going to have two Dynamo tables, one for current carts and one for placed
    orders. To create these, we need to go onto the AWS console and navigate to the
    `DynamoDB` service:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，我们将使用DynamoDB来存储购物车信息。我们将有两个Dynamo表，一个用于当前购物车，另一个用于已下订单。为了创建这些表，我们需要进入AWS控制台并导航到`DynamoDB`服务：
- en: '![](img/32efdd8b-b323-413c-ae43-273abcd3f7cd.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32efdd8b-b323-413c-ae43-273abcd3f7cd.png)'
- en: DynamoDB console page
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB控制台页面
- en: 'Click Create table to start creating a new table. We are asked to name our
    table and select a primary key. We''re going to call our first table `shopping-cart`
    and set the Primary key to `ID`. The primary key is the value that we will be
    able to use to look up records, and it is best practice to use `ID` as the name
    of the Primary key:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 点击创建表以开始创建一个新表。我们需要为我们的表命名并选择一个主键。我们将第一个表命名为`shopping-cart`并将主键设置为`ID`。主键是我们将能够用来查找记录的值，并且将`ID`用作主键的名称是最佳实践：
- en: '![](img/231a5f1b-9f58-4aab-afdb-c8ecf77799b9.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/231a5f1b-9f58-4aab-afdb-c8ecf77799b9.png)'
- en: Table creation
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表创建
- en: When we click the Create button, we will be taken to the main DynamoDB console
    page. There is a lot of information available on this page, but we only need to
    see that we have our `shopping-cart` table in the table list. When you have just
    created the table, it may have a loading indicator next to it as the creation
    process finishes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击创建按钮时，我们将被带到主DynamoDB控制台页面。这个页面上有大量信息，但我们只需要看到我们的`shopping-cart`表在表列表中。当你刚刚创建表时，它旁边可能有一个加载指示器，因为创建过程正在完成。
- en: 'With our table created, we need to write some code that allows us to work with
    it. Because we will be working with Dynamo in multiple intents and Lambdas, it
    is good practice to create reusable code. For this, we will create a `DB` class
    that provides methods to get, write, update, and deletes record from the database.
    Create a new file called `DB.js` in our `addToCart` folder, and inside we''re
    going to create a new class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了表之后，我们需要编写一些代码，使我们能够与之交互。因为我们将在多个意图和 Lambda 中使用 Dynamo，所以创建可重用代码是一个好习惯。为此，我们将创建一个
    `DB` 类，它提供从数据库获取、写入、更新和删除记录的方法。在我们的 `addToCart` 文件夹中创建一个名为 `DB.js` 的新文件，然后我们将在其中创建一个新的类：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To allow us to access the Dynamo tables, AWS provides us with a DynamoDB document
    client. To create `documentClient`, we need to pass in a configuration object
    containing the region. This code can go at the top of our `DB` file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够访问 Dynamo 表，AWS 提供给我们一个 DynamoDB 文档客户端。要创建 `documentClient`，我们需要传递一个包含区域的配置对象。这段代码可以放在我们的
    `DB` 文件顶部。
- en: 'Make sure to change your region to the region that your tables are located
    in. This should be either `eu-west-1` or `us-east-1`. If you are not sure, go
    to your AWS console and check your location setting. Ireland is `eu-west-1` and
    US East (N. Virginia) is `us-east-1`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将您的区域更改为您的表所在的位置。这应该是 `eu-west-1` 或 `us-east-1`。如果您不确定，请访问您的 AWS 控制台并检查您的位置设置。爱尔兰是
    `eu-west-1`，美国东部（弗吉尼亚北部）是 `us-east-1`：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we''ve created our `documentClient` variable, we can move back into
    our class and create our methods. The first method that we are going to make is
    `write`. We need three things to write to a table: the row ID, the data that we
    want to write, and the table name.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 `documentClient` 变量，我们可以回到我们的类中创建我们的方法。我们将要创建的第一个方法是 `write`。要将数据写入表，我们需要三样东西：行
    ID、我们想要写入的数据和表名。
- en: 'To improve the usability of this class, we''re going to return a `Promise`.
    Inside this `Promise`, we first need to check the `ID`, `data`, and `table`. If
    any of them are missing, or if `ID` or `table` aren''t strings, we need to throw
    an error:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高这个类的可用性，我们将返回一个 `Promise`。在这个 `Promise` 中，我们首先需要检查 `ID`、`data` 和 `table`。如果它们中的任何一个缺失，或者如果
    `ID` 或 `table` 不是字符串，我们需要抛出一个错误：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If `ID`, `data`, and `table` are all correct, we can write our data to the
    table. To write to a table, we need to pass the request into a specific format.
    The `Item` needs to be all of the data with an added `ID` field with a value of
    the row ID that we pass in:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ID`、`data` 和 `table` 都正确，我们就可以将数据写入表。要将数据写入表，我们需要将请求传递到特定的格式。`Item` 需要包含所有数据，并添加一个具有我们传递的行
    ID 值的 `ID` 字段：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This `params` object can then be passed into the `documentClient.put()` method,
    which also takes a `callback` function. We `console.log` out the error or data
    from the response before resolving the data or rejecting the error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个 `params` 对象可以被传递到 `documentClient.put()` 方法中，该方法还接受一个 `callback` 函数。我们在解决数据或拒绝错误之前，在控制台中输出错误或响应中的数据：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we are creating this class, we are going to create the `get`, `update`, and
    `delete` methods as well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个类的同时，我们将创建 `get`、`update` 和 `delete` 方法。
- en: '`get` is very similar to `write`, taking just a `key`, `value`, and `table`.
    Instead of passing in the items that we want to write, we pass in the key that
    we want to match. This `key-value` pair needs to be set inside `params`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 与 `write` 非常相似，只需要 `key`、`value` 和 `table`。我们不是传递我们想要写入的项目，而是传递我们想要匹配的键。这个
    `key-value` 对需要在 `params` 中设置：'
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`get` works as you would expect for getting items based on the primary index,
    but what if we want to get items by a second value? We can''t use `documentClient.get()`,
    so we need to create a new function called `getDifferent`. This function uses
    `documentClient.query()` instead of `documentClient.get()`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 在根据主索引获取项目时按预期工作，但如果我们想根据第二个值获取项目怎么办？我们不能使用 `documentClient.get()`，因此我们需要创建一个新的函数
    `getDifferent`。这个函数使用 `documentClient.query()` 而不是 `documentClient.get()`：'
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`delete` is almost identical to `get`, with the main difference being that
    we call `documentClient.delete`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 几乎与 `get` 相同，主要区别在于我们调用 `documentClient.delete`：'
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The last method that we need to create is `update`. This is a very simple method
    as it just uses the other methods to do most of the work. It gets the data for
    the `ID` and then writes it back with the new key and value added on or changed:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个方法是 `update`。这是一个非常简单的函数，因为它只是使用其他方法来完成大部分工作。它获取 `ID` 的数据，然后使用新的键和值添加或更改后写回：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we''ve completed the `DB` class, we need to import it into our Lambda
    and create a new instance. At the top of our `index.js` file in the `addToCart`
    folder, we can add these lines:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 `DB` 类，我们需要将其导入到我们的 Lambda 中并创建一个新的实例。在 `addToCart` 文件夹中的 `index.js`
    文件顶部，我们可以添加这些行：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our Lambdas have to deal with Dynamo as well as S3; we need to give these Lambdas
    the permissions they need to do this.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Lambda 需要处理 Dynamo 以及 S3；我们需要给这些 Lambda 授予它们执行这些操作所需的权限。
- en: Open up the AWS console and navigate to AIM. Under Roles in the menu on the
    left, find the role that we created back in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml),
    *Getting Started with AWS and Amazon CLI*. We're going to add Dynamo permissions
    to this role.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 AWS 控制台并导航到 AIM。在左侧菜单中的角色下，找到我们在 [第 2 章](ac448944-0559-408e-a9c4-972933a03611.xhtml)
    中创建的角色，*AWS 和 Amazon CLI 入门*。我们将向此角色添加 Dynamo 权限。
- en: Adding Dynamo permissions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Dynamo 权限
- en: Now that our Lambdas are working with Dynamo and S3, we need to update our permissions
    the role that we use to build our Lambdas. Navigate to the `IAM` service and select
    the lambdaBasic role that we created in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml),
    *Getting Started with AWS and Amazon CLI*. Click Attach policy and search for
    Dynamo.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们 Lambda 正在与 Dynamo 和 S3 一起工作，我们需要更新我们用于构建 Lambda 的角色权限。导航到 `IAM` 服务并选择我们在
    [第 2 章](ac448944-0559-408e-a9c4-972933a03611.xhtml) 中创建的 `lambdaBasic` 角色，*AWS
    和 Amazon CLI 入门*。点击附加策略并搜索 Dynamo。
- en: 'We need to add AmazonDynamoDBFullAccess. This gives the Lambda permissions
    to read and write to Dynamo:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加 `AmazonDynamoDBFullAccess`。这会给 Lambda 授予读取和写入 Dynamo 的权限：
- en: '![](img/f461327e-feb6-4c6c-9b13-41f4248ac394.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f461327e-feb6-4c6c-9b13-41f4248ac394.png)'
- en: Adding DynamoDB policies
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 DynamoDB 策略
- en: Testing
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Before we run any testing, we need to build and deploy our Lambda. Using the
    build script we created in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml),
    *Getting Started with AWS and Amazon CLI*, we can run `./build.sh addToCart` to
    build and deploy our new Lambda.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行任何测试之前，我们需要构建和部署我们的 Lambda。使用我们在 [第 2 章](ac448944-0559-408e-a9c4-972933a03611.xhtml)
    中创建的构建脚本，*AWS 和 Amazon CLI 入门*，我们可以运行 `./build.sh addToCart` 来构建和部署我们的新 Lambda。
- en: With this complete, we can navigate to our Lambda console and select our new
    `addToCart` Lambda. Next to Test, we can click Configure test events.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以导航到我们的 Lambda 控制台并选择我们的新 `addToCart` Lambda。在测试旁边，我们可以点击配置测试事件。
- en: 'There are things that we need to test for this Lambda:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个 Lambda，我们需要测试一些事情：
- en: A `Denied` confirmation status
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Denied` 确认状态
- en: A `Confirmed` confirmation status
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Confirmed` 确认状态
- en: A trigger without an `itemNumber`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个没有 `itemNumber` 的触发器
- en: Adding an item to a new cart
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向新购物车添加一个项目
- en: Adding an item to an existing cart
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向现有购物车添加一个项目
- en: 'A `Denied` trigger is the easiest to test. You should get a response asking
    `Would you like to find another product?`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Denied` 触发器是最容易测试的。你应该会得到一个询问“你想要找到另一个产品吗？”的响应：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can test a `Confirmed` confirmation status and a trigger without an `itemNumber`
    in one test. We should get through to the `handleAddToCart` function, and then
    get a response telling us we need to select a product and asking whether we want
    to find one:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个测试中测试一个 `Confirmed` 确认状态和一个没有 `itemNumber` 的触发器。我们应该能够到达 `handleAddToCart`
    函数，然后得到一个响应告诉我们需要选择一个产品并询问我们是否想要找到一个：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The test for adding an item to a new cart and to an existing cart will be the
    same; you just have to run the test twice. The first time, there won''t be any
    existing order. The second time, there will be. You need to change the `ID` value
    every time you want to test a new cart:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 添加项目到新购物车和现有购物车的测试将是相同的；你只需要运行测试两次。第一次，不会有任何现有订单。第二次，会有。每次你想测试一个新的购物车时，你都需要更改
    `ID` 值：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Both times, you should get a response asking `Would you like to checkout or
    add another item to your basket?`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 两次，你都应该得到一个询问“你想要结账还是添加另一个项目到你的篮子里？”的响应。
- en: The last thing we need to do is to add this tested Lambda as the handler for
    the intent. Navigate to the Lex chatbot and to the `addToCart` intent. In the
    Fulfillment section of the page, we can change the fulfillment to Lambda fulfillment
    and select our new `addToCart` Lambda to fulfill it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是将这个经过测试的 Lambda 添加为意图的处理程序。导航到 Lex 聊天机器人和 `addToCart` 意图。在页面的履行部分，我们可以将履行方式更改为
    Lambda 履行，并选择我们新的 `addToCart` Lambda 来履行它。
- en: Checkout
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结账
- en: When a user wants to checkout, we are going to do a simplified checkout process.
    We are just going to ask them for a mailing address and tell them we'll collect
    payment on delivery. Behind the scenes, we're going to take their cart and move
    it into a new `shopping-orders` table.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要结账时，我们将进行简化的结账流程。我们只需询问他们的邮寄地址，并告诉他们我们将送货时收取款项。幕后，我们将把他们的购物车移动到一个新的 `shopping-orders`
    表中。
- en: To start, we need to create a new intent in Lex called `checkout`. We can add
    utterances such as `I want to checkout`, `can I checkout please`, and just `checkout`.
    You can add more utterances that you expect a user might reply to, such as `Would
    you like to checkout or add another item to your basket?`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 Lex 中创建一个新的意图，命名为 `checkout`。我们可以添加诸如 `我想结账`、`我可以结账吗` 以及仅仅是 `结账` 这样的语句。你可以添加更多你期望用户可能回复的语句，例如
    `您想要结账还是添加另一个商品到您的购物篮中？`。
- en: 'We can access their cart using the *userId* on the event so the only other
    information we need is their `deliveryAddress` – so we need to add that as a slot.
    The slot type for this slot can be set to AMAZON.PostalAddress and we can add
    a prompt of `What address do you want your products delivered to?`. We can set
    this slot to be required so that whenever this intent is triggered. This means
    that we should already have the delivery address when the fulfillment Lambda gets
    triggered:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用事件中的 *userId* 访问他们的购物车，所以我们需要的其他信息只是他们的 `deliveryAddress` – 因此我们需要将其添加为一个槽位。此槽位的槽位类型可以设置为
    AMAZON.PostalAddress，我们可以添加提示 `您希望将产品送到哪个地址？`。我们可以设置此槽位为必填，这意味着每次此意图被触发时，我们应已经拥有送货地址：
- en: '![](img/864e93bc-b2b7-46f0-a8af-39e8b96b78a0.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/864e93bc-b2b7-46f0-a8af-39e8b96b78a0.png)'
- en: Checkout slot
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 结账槽位
- en: Creating the Lambda
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Lambda
- en: 'With the intent set up, we can create the Lambda. Create a new folder called
    `checkout` and add an `index.js` file. In your folder, we need to run `npm install
    --save aws-sdk`. We are going to start with the node 8.10 handler with the `confirmationStatus`
    check for a denied status. We may want to trigger this intent with `confirmIntent`
    in the future:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好意图后，我们可以创建 Lambda。创建一个名为 `checkout` 的新文件夹，并添加一个 `index.js` 文件。在你的文件夹中，我们需要运行
    `npm install --save aws-sdk`。我们将从 node 8.10 处理器开始，使用 `confirmationStatus` 检查拒绝状态。我们可能希望在将来使用
    `confirmIntent` 触发此意图：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have already used `Lex` again, so we need to copy our `LexResponse.js` file
    into this folder and use our setup code at the top of the file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经再次使用了 `Lex`，因此我们需要将我们的 `LexResponse.js` 文件复制到这个文件夹中，并在文件顶部使用我们的设置代码：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we can get into the bulk of this Lambda with our `handleCheckout` function.
    We are first going to check that we have a value in the `deliveryAddress` slot.
    If we don''t, then we''ll ask them for it using `elicitSlot`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进入 Lambda 的主体部分，使用我们的 `handleCheckout` 函数。我们首先将检查 `deliveryAddress` 槽位中是否有值。如果没有，我们将使用
    `elicitSlot` 请求它：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once we know that we have a delivery address, we can turn their cart into an
    order. To do this, we'll get their cart and then put that into a `shopping-orders`
    table with their delivery address and date of order.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道我们有送货地址，我们可以将他们的购物车转换成订单。为此，我们将获取他们的购物车，然后将其放入一个带有他们的送货地址和订单日期的 `shopping-orders`
    表中。
- en: Before we can create the code, we need to set up a new table in DynamoDB. Navigate
    to the Dynamo console in AWS and click Create table. Name our new table `shopping-orders`
    and give it a primary key of `ID`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以创建代码之前，我们需要在 DynamoDB 中设置一个新的表。导航到 AWS 中的 Dynamo 控制台，点击创建表。将我们的新表命名为 `shopping-orders`
    并将其主键设置为 `ID`。
- en: 'Back in our Lambda code, we can now create the logic to place the order. First
    we need to get the cart, and then delete that cart. If we get an error, then we
    need to tell the user and ask whether there is anything else we can help them
    with:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Lambda 代码中，我们现在可以创建放置订单的逻辑。首先我们需要获取购物车，然后删除该购物车。如果发生错误，我们需要告诉用户，并询问我们是否可以提供其他帮助：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we successfully got a cart back, we can delete the cart, create a new `orders`
    object, and write that to our `shopping-orders` table. We delete the cart because
    we don''t expect to place an order and still have all of the items in your cart:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功获取了购物车，我们可以删除购物车，创建一个新的 `orders` 对象，并将其写入我们的 `shopping-orders` 表。我们删除购物车是因为我们预计不会下订单并且仍然保留购物车中的所有商品：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We generate a random ID by using `uuidv4()` again. This means that we also need
    to run `npm install --save uuid` and include `const uuidv4 = require('uuid/v4');`
    at the top of this file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 `uuidv4()` 生成一个随机 ID。这意味着我们还需要运行 `npm install --save uuid` 并在文件顶部包含 `const
    uuidv4 = require('uuid/v4');`。
- en: 'We will use a `try`/`catch` for this as it allows us to make both of the requests
    and handle any errors in a single handler. If an error is thrown, it is likely
    that our code is wrong so we don''t want to make the user go through that again.
    Therefore, we''ll tell them there was an error and their order can''t be placed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`try`/`catch`来处理这个问题，因为它允许我们在单个处理程序中同时执行这两个请求并处理任何错误。如果抛出错误，那么我们的代码可能有问题，我们不希望用户再次经历这个过程。因此，我们将告诉他们出现了错误，他们的订单无法下单：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If there wasn''t an error, we can tell the user that their order was placed:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，我们可以告诉用户他们的订单已成功下单：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With all paths of the intent completed, we can use our build script to build
    and deploy our Lambda before testing. Navigate into your `Lambdas` folder and
    run the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有意图路径后，我们可以使用我们的构建脚本来构建和部署我们的Lambda，以便在测试之前。导航到您的`Lambdas`文件夹，并运行以下代码：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Testing
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'With this Lambda, there are a few scenarios to test:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个Lambda，有几个场景需要测试：
- en: Confirmed intent
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认意图
- en: Denied intent
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝意图
- en: No delivery address
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有送货地址
- en: The user doesn't have a cart to checkout
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户没有购物车可以结账
- en: The user has a cart
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户有购物车
- en: 'A `Denied` intent should ask us whether we want to find a new product:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Denied`意图应该询问我们是否想要找到一个新产品：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Confirmed` intent and no delivery address can be tested together. We expect
    the status to have no effect on the process, and the response to ask us for our
    delivery address:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Confirmed`意图和没有送货地址可以一起测试。我们预计状态对流程没有影响，并且响应会要求我们提供送货地址：'
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To test a user without a cart, we can call the Lambda with a `userId` that
    would never have an order. We can choose a normal word as this will never be used
    as a `userID` in Lex:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试没有购物车的用户，我们可以调用Lambda，并使用一个永远不会下订单的`userId`。我们可以选择一个普通单词，因为这个单词永远不会在Lex中用作`userID`：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: From this test, we should be told `We couldn't find your cart.` and then asked
    whether we want to find a product.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个测试中，我们应该被告知“我们找不到您的购物车。”然后询问我们是否想要找到一个产品。
- en: 'The last scenario is a successful order placement. This will need a little
    more work as we need to find a valid cart. To do this, we can go onto AWS and
    navigate to Dynamo. Select the `shopping-orders` table and then we can click the
    Items tab. This allows us to look directly at the items in our table so we can
    find a valid cart ID. Copy any of the IDs, and paste it as the value in this next
    test case:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况是成功的订单下单。这需要更多的工作，因为我们需要找到一个有效的购物车。为此，我们可以进入AWS并导航到Dynamo。选择`shopping-orders`表，然后我们可以点击“Items”标签。这允许我们直接查看表中的项目，以便我们可以找到一个有效的购物车ID。复制任何ID，并将其粘贴为下一个测试用例中的值：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: From this, we expect to get a response telling us that we have successfully
    placed an order. We can also check in our `shopping-orders` table that we have
    a new row. When running this test, we need to use a valid cart ID. Unfortunately,
    when we create an order, we delete the old cart, meaning that the ID is no longer
    valid so we need to get a new ID for every test.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个测试中，我们期望得到一个响应，告诉我们我们已经成功下单。我们还可以在我们的`shopping-orders`表中检查是否有新的行。在运行此测试时，我们需要使用有效的购物车ID。不幸的是，当我们创建订单时，我们会删除旧的购物车，这意味着ID不再有效，因此我们需要为每个测试获取一个新的ID。
- en: As with all of the Lambdas and intents so far, the last thing we need to do
    is add this tested Lambda as the handler for the intent. Navigate to the Lex chatbot
    and then to the checkout intent. In the Fulfillment section of the page, we can
    change the fulfillment to Lambda fulfillment and select our new checkout Lambda
    to fulfill it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与迄今为止的所有Lambda和意图一样，最后我们需要做的是将这个经过测试的Lambda添加为意图的处理程序。导航到Lex聊天机器人，然后转到结账意图。在页面的“Fulfillment”部分，我们可以将履行方式更改为Lambda履行，并选择我们新的结账Lambda来履行。
- en: Saving our cart
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存我们的购物车
- en: So far, we have created the flow for the perfect conversation, one where the
    user finds one or more products, adds them to their cart, and checks out straight
    away. This is good, but a lot of people will add things to their cart, leave,
    and then come back to checkout.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了完美对话的流程，即用户找到一到多个产品，将它们添加到购物车，然后立即结账。这是好的，但很多人会将东西添加到购物车，离开，然后回来结账。
- en: We need to create an intent that lets the user save their cart and come back
    to it later to checkout. Most shopping websites will have a login system or use
    web caching to save a cart to a user, but we're going to save a cart by a *unique
    name*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个意图，让用户保存他们的购物车，稍后回来结账。大多数购物网站都会有登录系统或使用Web缓存将购物车保存到用户，但我们将通过一个*唯一的名称*来保存购物车。
- en: In our Lex console for this chatbot, we can add a new `saveCart` intent. At
    the end of the `addToCart` intent, we ask the user whether they want to `add another
    product, save your cart`, or `checkout`. We need to handle the utterances that
    the user might say to save their cart. Add utterances such as `save my cart` and
    `I want to save my cart for later`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个聊天机器人的Lex控制台中，我们可以添加一个新的`saveCart`意图。在`addToCart`意图的末尾，我们询问用户他们是否想要`添加另一个产品、保存购物车`或`结账`。我们需要处理用户可能说的保存购物车的用语。添加诸如`保存我的购物车`和`我想将我的购物车保存起来以后再用`之类的用语。
- en: 'The `cart` and `basket` words are very similar in meaning, so add some utterances
    with each of them:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`cart`和`basket`这两个词在意义上非常相似，所以为它们中的每一个添加一些用语：'
- en: '![](img/c26068a8-532e-402f-87b6-bd34274c3af5.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c26068a8-532e-402f-87b6-bd34274c3af5.png)'
- en: saveCart sample utterances
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: saveCart样本用语
- en: We only need one slot for this intent. Add a slot of `cartName` with a slot
    type of AMAZON.Musician and a prompt of `What name would you like to save your
    cart as?`. Using a slot type of Musician might seem strange, but this slot type
    allows any value to be accepted, thereby allowing users to name their basket whatever
    they want. We can set the `cartName` slot to be required, as we'll always need
    a name to save the cart as.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个意图，我们只需要一个槽位。添加一个名为`cartName`的槽位，槽位类型为AMAZON.Musician，提示为`你希望将你的购物车保存为什么名字？`。使用Musician类型的槽位可能看起来很奇怪，但这个槽位类型允许接受任何值，从而使用户能够将购物车命名为他们想要的任何名字。我们可以将`cartName`槽位设置为必需的，因为我们总是需要一个名字来保存购物车。
- en: Creating the Lambda
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Lambda
- en: 'Create a new folder in the `Lambdas` folder, called `saveCart`, with an `index.js`
    file in it. In that `index.js` file, we''re going to start, as normal, with the
    node 8.10 async handler. We know that we are going to be using Lex responses and
    accessing dynamo, so we add those files and require them into our `index.js`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Lambdas`文件夹中创建一个新的文件夹，命名为`saveCart`，并在其中创建一个`index.js`文件。在`index.js`文件中，我们将像往常一样，从node
    8.10的异步处理程序开始。我们知道我们将使用Lex响应和访问dynamo，因此我们添加这些文件并将它们引入到我们的`index.js`中：
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we're going to be using Dynamo, we need to make sure to install `aws-sdk`
    by running `npm install --save aws-sdk`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用Dynamo，我们需要确保通过运行`npm install --save aws-sdk`来安装`aws-sdk`。
- en: With this intent, we are never going to be doing `confirmIntent` on it, so we
    don't need to handle any confirmation status. This means the only function in
    our handler is a `handleSaveCart(event)` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个意图，我们永远不会对它执行`confirmIntent`，因此我们不需要处理任何确认状态。这意味着我们处理程序中唯一的函数是`handleSaveCart(event)`函数。
- en: 'Inside the `handleSaveCart` function, we need to get `userID` and `slots` from
    the event. We can then get `cartName` from the slots:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleSaveCart`函数内部，我们需要从事件中获取`userID`和`slots`。然后我们可以从槽位中获取`cartName`：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We first need to check that there is a `cartName` as there always needs to
    be. This should never be called since the `cartName` slot is required, but it
    is always safer to put it in:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要检查是否存在`cartName`，因为总是需要。这个函数永远不会被调用，因为`cartName`槽位是必需的，但总是更安全地将它放在那里：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that we have a valid cart name, we first need to see whether the user has
    a cart to checkout. If they don''t, then we ask them whether they want to add
    an item to their cart:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个有效的购物车名称，我们首先需要查看用户是否有可以结账的购物车。如果没有，我们就询问他们是否想要向他们的购物车中添加商品：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we can check whether there is already a cart with that name. To do this,
    we can try getting the cart with that name. If we can''t find a cart with that
    name it means that we won''t over-ride another cart when we save. If we do find
    a cart with that name, then we need to ask the user for a new cart name:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以检查是否已经存在具有该名称的购物车。为此，我们可以尝试获取具有该名称的购物车。如果我们找不到具有该名称的购物车，这意味着我们在保存时不会覆盖另一个购物车。如果我们找到了具有该名称的购物车，那么我们需要要求用户提供一个新的购物车名称：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To save their cart using that cart name, we return a function to add the name
    to the cart. This function starts by setting the cart name as the passed-in slot
    value:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用该购物车名称保存他们的购物车，我们返回一个函数来将名称添加到购物车中。这个函数首先将购物车名称设置为传入的槽位值：
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we can carry on this function by writing the cart back to the table. If
    there is an error, we tell the user we can''t save their cart, otherwise we tell
    them it''s been saved and how to access it next time:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续这个函数，通过将购物车写回表中。如果有错误，我们告诉用户我们无法保存他们的购物车，否则我们告诉他们已经保存，并说明下次如何访问它：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As always, make sure to run the build script to deploy your Lambda.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，确保运行构建脚本来部署你的Lambda。
- en: Dynamo changes
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dynamo更改
- en: In this Lambda, we did `DB.get` using the `cartName` instead of the `ID`. To
    get this working, we need to index our table by `cartName`. Creating an index
    for a key allow us to search by the values. This is also why we set the default
    name for a cart to `uuidv4()`. Because we can search by the name, it needs to
    be unique.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Lambda中，我们使用`cartName`而不是`ID`进行`DB.get`。为了使这正常工作，我们需要按`cartName`索引我们的表。为键创建索引允许我们按值进行搜索。这也是为什么我们将购物车的默认名称设置为`uuidv4()`的原因。因为我们可以通过名称进行搜索，所以它需要是唯一的。
- en: 'Navigate to the Dynamo service in AWS and select the `shopping-cart` table.
    Across the top of this section is a row of tabs, and we''re going to choose *Indexes*
    and click Create index. This will open a popup where we need to enter the key
    we want to index, in this case, `cartName`. Click Create index and the index will
    start to be created:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到AWS中的Dynamo服务并选择`shopping-cart`表。在这个部分的顶部有一行标签，我们将选择*Indexes*并点击创建索引。这将在一个弹出窗口中打开，我们需要输入我们想要索引的键，在这种情况下，是`cartName`。点击创建索引，索引将开始创建：
- en: '![](img/3429173d-8a40-4af8-ad31-4b6ee66347d2.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3429173d-8a40-4af8-ad31-4b6ee66347d2.png)'
- en: Secondary index
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 二级索引
- en: When this finishes the creation process, we will be able to do `getDifferent`
    requests on this table by `cartName`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个创建过程完成时，我们将能够通过`cartName`在这个表上执行`getDifferent`请求。
- en: Testing
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'Testing our `saveCart` intent requires only dealing with four scenarios: *no
    cart name, no cart to save, cart name already taken,* and *saving a cart.*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的`saveCart`意图只需要处理四种情况：*没有购物车名称，没有要保存的购物车，购物车名称已被占用*，以及*保存购物车*。
- en: 'Testing when there is no cart name is very simple. We expect this to ask us
    to give a name for our cart:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有购物车名称时进行测试非常简单。我们期望这会要求我们为我们的购物车提供一个名称：
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To test saving when we don''t have a cart, we can use a nonsense `userId` as
    there is no chance that there will be a cart for them. We need to pass in a valid
    `cartName` now so that we pass the first check:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试在没有购物车时保存，我们可以使用一个无意义的`userId`，因为不可能有他们的购物车。现在我们需要传递一个有效的`cartName`，以便通过第一个检查：
- en: '[PRE57]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We are going to have to test the last two in a different order. We first test
    a successful saving of a cart. To do this, we need a `userId` with a cart. We
    can find that by going into our Dynamo console and looking at the Items tab on
    our `shopping-cart` table. Choose any of the IDs that are there and copy it into
    the `userId` value in the test object.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不以不同的顺序测试最后两个。我们首先测试成功保存购物车。为此，我们需要一个带有购物车的`userId`。我们可以通过进入我们的Dynamo控制台并查看`shopping-cart`表上的“Items”标签来找到它。选择那里的任何ID并将其复制到测试对象中的`userId`值。
- en: 'We expect that this will be successful and we''ll be told how to get our cart
    next time:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望这次会成功，并且下次会被告知如何获取我们的购物车：
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now that we have saved a cart, we can try saving a different cart with the same
    name. We have to find a new `ID` for this test but leave the rest of the request
    the same.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经保存了一个购物车，我们可以尝试用相同的名字保存另一个不同的购物车。我们必须为这次测试找到一个新的`ID`，但其余的请求保持不变。
- en: 'This time, we should be told that we can''t use that cart name and to try a
    different one:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们应该被告知我们不能使用那个购物车名称，并尝试一个不同的名称：
- en: '[PRE59]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: With all of the tests responding as we expected, go back into the Lex console
    for this bot and change the fulfillment of the *saveCart* intent to the `saveCart`
    Lambda.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有的测试都按预期响应时，返回到这个机器人的Lex控制台，并将*saveCart*意图的履行改为`saveCart` Lambda。
- en: Retrieving a saved cart
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取已保存的购物车
- en: Now that the user can save their cart, we need to give them a way to get the
    cart that they saved. We can then change the cart so that it matches their `userId`,
    and then they can continue to add more items or checkout.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以保存他们的购物车了，我们需要给他们一个方法来获取他们保存的购物车。然后我们可以更改购物车，使其与他们的`userId`匹配，然后他们可以继续添加更多项目或结账。
- en: Create a new `getSavedCart` intent in Lex, and we're only going to be asking
    for the `cartName` of the cart they saved. As we did in the `saveCart` intent,
    we can set the `cartName` slot type to AMAZON.Musician to allow any values through.
    We can also set this slot to be required and have a prompt of `"What was the name
    you saved your cart to?"`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lex中创建一个新的`getSavedCart`意图，我们只将询问他们保存的购物车的`cartName`。正如我们在`saveCart`意图中所做的那样，我们可以将`cartName`槽位类型设置为AMAZON.Musician以允许任何值通过。我们还可以将此槽位设置为必填，并有一个提示：“你保存购物车时用的名字是什么？”
- en: Unlike with the other intents so far, we can allow the user to enter the `cartName`
    as part of the utterance. This is done by including the slot name in the utterance
    with curly brackets around it. This can be used for utterances such as `"I want
    to get cart { cartName }"`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与迄今为止的其他意图不同，我们可以允许用户将`cartName`作为语句的一部分输入。这是通过在语句中包含带有大括号的槽名称来完成的。这可以用于诸如`"我想获取购物车
    { cartName }"`之类的语句。
- en: 'As well as utterances that include the `cartName`, we will still have normal
    utterances such as `"I want to get my saved cart"` or `"get my cart"`. This utterance
    will get Lex to prompt the user for the `cartName` using the prompt we provided:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含`cartName`的语句之外，我们还将有正常的语句，例如`"我想获取我的已保存购物车"`或`"获取我的购物车"`。这个语句将使Lex提示用户输入`cartName`，使用我们提供的提示：
- en: '![](img/407ff7c7-7f6e-4f1d-9f8b-87813caea938.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/407ff7c7-7f6e-4f1d-9f8b-87813caea938.png)'
- en: Utterances for getSavedCart
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: getSavedCart的语句
- en: Creating the Lambda
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Lambda
- en: 'We start by creating a `getSavedCart` folder in our `Lambdas` directory, and
    inside we''re going to have an `index.js` file and copy our `DB.js` and `LexResponses.js`
    files from our previous Lambdas. Our `index.js` file will start as normal, with
    us importing and initiating our `DB` and `Lex` classes and using the node 8.10
    handler. We need to make sure to run `npm install --save aws-sdk` in our folder
    as well. We''ll never do a confirmed intent on this intent, so we only need to
    handle a `getSavedCart` event:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在我们的`Lambdas`目录中创建一个`getSavedCart`文件夹，并在其中创建一个`index.js`文件，并将我们的`DB.js`和`LexResponses.js`文件从先前的Lambda中复制过来。我们的`index.js`文件将像往常一样开始，导入并初始化我们的`DB`和`Lex`类，并使用node
    8.10处理器。我们需要确保在我们的文件夹中运行`npm install --save aws-sdk`。在这个意图上我们永远不会做确认意图，所以我们只需要处理一个`getSavedCart`事件：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first thing we need to do in our Lambda is to get our `userId`, `slots`,
    and our `cartName` slot. We can then check that we have a `cartName` or ask the
    user for it if we don''t:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Lambda中，我们首先需要获取我们的`userId`、`slots`以及`cartName`槽。然后我们可以检查我们是否有`cartName`，如果没有，我们可以询问用户：
- en: '[PRE61]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now that we know we have a `cartName`, we can try to get the cart with that
    name. If we can''t get a cart with that name, then we need to ask whether they
    want to try another name or start a new cart. This will have to be an `elicitIntent`
    as they could go with either of two intents:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们有`cartName`，我们可以尝试获取具有该名称的购物车。如果我们无法获取具有该名称的购物车，那么我们需要询问他们是否想要尝试另一个名称或开始一个新的购物车。这将必须是一个`elicitIntent`，因为他们可能选择两个意图中的任何一个：
- en: '[PRE62]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To get this `elicitIntent` to work, we need to also add the utterance of `try
    another name` to `getSavedCart`, and `start a new cart` to the `productFind` intent.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个`elicitIntent`起作用，我们还需要将`try another name`的语句添加到`getSavedCart`中，并将`start
    a new cart`添加到`productFind`意图中。
- en: '`DB.getDifferent` gets an array of matching carts, which is why we''re looking
    for `carts[0]`. We also need to extract our cart by adding this line after our
    error-handler:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`DB.getDifferent`获取一个匹配的购物车数组，这就是为什么我们在错误处理器之后寻找`carts[0]`。我们还需要通过添加以下行来提取我们的购物车：'
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If we found a cart for that `cartName`, then we need to do two things. We need
    to create a cart with those items on their current `userId`, and then we need
    to delete the old cart. If we don't delete the old cart, there will be two carts
    with the same name.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到了名为`cartName`的购物车，那么我们需要做两件事。我们需要为当前`userId`创建一个包含这些商品的购物车，然后我们需要删除旧的购物车。如果我们不删除旧的购物车，将会有两个同名购物车。
- en: 'We can create the new cart by changing the ID and updating the TTL on the old
    cart. We also need to store the ID of the old cart so we can delete it too:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改ID并更新旧购物车的TTL来创建新的购物车。我们还需要存储旧购物车的ID，以便我们也可以删除它：
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When we create the new cart and delete the old one, we can wrap them both in
    `try`/`catch` and handle any errors in the same way. If there are any errors,
    then we need to tell the user that we couldn't recover their cart and ask whether
    they want to start a new cart. This can be a `confirmIntent` on the `productFind`
    intent, which will start them at the beginning of the flow again.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建新的购物车并删除旧的购物车时，我们可以将它们都包裹在`try`/`catch`中，并以相同的方式处理任何错误。如果有任何错误，我们需要告诉用户我们无法恢复他们的购物车，并询问他们是否想要开始一个新的购物车。这可以在`productFind`意图上的`confirmIntent`中完成，这将让他们再次从流程的开始处开始。
- en: 'If there''s no error, then we can tell them that we have got their cart and
    ask whether they want to checkout or get another item:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，我们可以告诉他们我们已经获取了他们的购物车，并询问他们是否想要结账或获取另一个商品：
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That is the end of this Lambda, so now we can build and deploy using our script
    and move on to testing it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个Lambda的结束，所以现在我们可以使用我们的脚本构建和部署，然后继续测试它。
- en: Testing
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'To test this, we need to test three things:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，我们需要测试三件事：
- en: No `cartName`
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有指定`cartName`
- en: A non-existent `cartName`
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不存在的`cartName`
- en: Successfully getting their cart
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功获取他们的购物车
- en: 'Testing no cart name is very simple. We expect to get a response asking for
    the cart name:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 测试没有购物车名称非常简单。我们期望得到一个要求输入购物车名称的响应：
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To test a non-existent cart name, we need to use a name that someone isn''t
    going to use. We expect the response to say that a cart with that name couldn''t
    be found:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一个不存在的购物车名称，我们需要使用一个别人不太可能使用的名称。我们期望的响应会说找不到具有该名称的购物车：
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The last test requires us to look in the Dynamo tables again. This time, we
    are looking for an order with a valid name. If we completed the tests for `saveCart`,
    we should have a cart called `testCartSave`. This request should get a response
    saying that the cart has been found and asking whether they want to checkout or
    find another product:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试需要我们再次查看Dynamo表。这次，我们正在寻找一个具有有效名称的订单。如果我们完成了`saveCart`的测试，我们应该有一个名为`testCartSave`的购物车。这个请求应该得到一个响应，表示找到了购物车，并询问他们是否想要结账或寻找另一个产品：
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Once all of these tests pass, we can add this Lambda as the fulfillment method
    for our `getSavedCart` intent.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些测试都通过，我们就可以将这个Lambda添加为我们的`getSavedCart`意图的履行方法。
- en: What's in my cart?
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的购物车里有啥？
- en: This is the last intent we are going to make in this chapter. When a user asks
    what they have in their cart, we are going to give them a summary. This involves
    getting their cart and matching their item numbers up with the data in S3.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章我们将要创建的最后一个意图。当用户询问他们购物车里的内容时，我们将给他们一个总结。这涉及到获取他们的购物车并将他们的项目编号与S3中的数据匹配起来。
- en: When we create this intent in Lex, we don't need any slots—the only information
    we need is their `userId`. The utterances will be questions about what is in their
    cart, such as `what is in my cart` and `how much have I got in my basket`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Lex中创建这个意图时，我们不需要任何槽位——我们需要的唯一信息是他们的`userId`。话语将是关于他们购物车里的内容的问题，例如“我的购物车里有啥”和“我在篮子里有多少”。
- en: Creating the Lambda
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Lambda
- en: We create a new folder called `whatsInMyCart` in our Lambda directory with an
    `index.js` file, as well as copying `DB.js` and `LexResponses.js` into this folder.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的Lambda目录中创建一个新的名为`whatsInMyCart`的文件夹，并在其中创建一个`index.js`文件，同时将`DB.js`和`LexResponses.js`复制到这个文件夹中。
- en: 'This function is going to need to access Dynamo to access the baskets and S3
    to get the product data. We start the `index.js` file by requiring in `DB.js`,
    `LexResponses.js`, and `aws-sdk`, and then creating new `DB`, `Lex`, and `S3`
    class instances. We don''t have any confirmations on this intent, so we can just
    return a `handleWhatsInMyCart` function:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将需要访问Dynamo以访问购物车，并访问S3以获取产品数据。我们通过在`index.js`文件中引入`DB.js`、`LexResponses.js`和`aws-sdk`，然后创建新的`DB`、`Lex`和`S3`类实例来开始`index.js`文件。我们没有对这个意图的任何确认，所以我们可以直接返回一个`handleWhatsInMyCart`函数：
- en: '[PRE69]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When a user triggers this intent, the first thing we need to do is get their
    cart. If they don''t have a cart, then we need to remind them that they can recover
    a saved cart or add new items to their existing cart:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户触发这个意图时，我们首先需要做的是获取他们的购物车。如果他们没有购物车，那么我们需要提醒他们他们可以恢复一个已保存的购物车或向现有的购物车添加新项目：
- en: '[PRE70]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If they do have a cart, then we can reformat the items into their cart into
    a more manageable format. The way that items are added to the cart, multiples
    of the same item are just separate items in the array. We can use some array logic
    to convert this into an object with item numbers as keys, which point to objects
    containing the quantity. This code goes through each item, and if we have already
    added that item to the `items` object, it adds 1 to the quantity. If this is the
    first unit of this item, then it sets the quantity to 1:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们确实有一个购物车，那么我们可以将购物车中的商品重新格式化为更易于管理的格式。商品添加到购物车的方式是，相同商品的多个实例在数组中只是单独的项目。我们可以使用一些数组逻辑将此转换为以项目编号为键的对象，这些键指向包含数量的对象。此代码遍历每个项目，如果我们已经将该项目添加到`items`对象中，则将数量加1。如果是该商品的第一个单位，则将数量设置为1：
- en: '[PRE71]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'With our object of items, we need to map this to item descriptions. For this,
    we need the data from S3\. We can copy the same `getStock()` function that we
    used in `productFind` into this Lambda. If there is an error or we don''t get
    back a list of products, we need to tell the user that we have had a problem:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目对象，我们需要将其映射到项目描述。为此，我们需要S3中的数据。我们可以将我们在`productFind`中使用的相同的`getStock()`函数复制到这个Lambda中。如果有错误或我们没有收到产品列表，我们需要告诉用户我们遇到了问题：
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We have our object of items and all of our products. We can use this to expand
    the data in our `items` object. To do this, we can map over each of the `products`
    and, if the `itemNumber` is in our `items` object, we add those details to that
    item''s data:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的项目对象和所有产品。我们可以使用这个来扩展 `items` 对象中的数据。为此，我们可以映射每个 `products`，如果 `itemNumber`
    在我们的 `items` 对象中，我们就将那些详细信息添加到那个项目的数据中：
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We have an object that contains all the data we need. We can map over this
    and create a string describing the item and quantity. We can use the `Object.values()`
    method, which turns an object into an array that contains the values. Here is
    an example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含所有所需数据的对象。我们可以映射这个对象并创建一个描述项目和数量的字符串。我们可以使用 `Object.values()` 方法，它将一个对象转换成一个包含值的数组。以下是一个示例：
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can use this to get the data for each of the items to create `itemStrings`,
    such as `2 blue jackets` or `1 long, black pair of trousers`. We can use the `units()`
    function that we created in `productFind` to deal with the units and with trousers:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个来获取每个项目的数据以创建 `itemStrings`，例如 `2 blue jackets` 或 `1 long, black pair
    of trousers`。我们可以使用在 `productFind` 中创建的 `units()` 函数来处理单位和裤子：
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can now join this array of item strings together into a one-cart summary.
    If there is one item, we can just say that item. Two items mean we need to add
    `and` between them, and we need to separate three or more items with commas:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这个项目字符串数组合并成一个购物车总结。如果只有一个项目，我们只需说出这个项目。如果有两个项目，我们需要在它们之间添加 `and`，并且需要用逗号分隔三个或更多项目：
- en: '[PRE76]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'With our message created, all we have left to do is to return our `Lex` response,
    which will be an `elicitIntent` response:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 消息创建完成后，我们剩下要做的就是返回我们的 `Lex` 响应，这将是一个 `elicitIntent` 响应：
- en: '[PRE77]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With the Lambda completed, we need to build and deploy it, and move on to testing.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数完成后，我们需要构建和部署它，然后继续测试。
- en: Testing
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'There are only two situations to test for in this Lambda:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 Lambda 中，我们只需要测试两种情况：
- en: No cart
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有购物车
- en: Successful cart lookup
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功的购物车查找
- en: 'To test for no cart, we can provide a non-existent `userId`. We should get
    a response telling us that our cart can''t be found:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试没有购物车的情况，我们可以提供一个不存在的 `userId`。我们应该得到一个响应告诉我们找不到我们的购物车：
- en: '[PRE78]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To test a successful cart lookup, we need to go into our Dynamo table and find
    a cart with items in it. We should get a nicely formatted sentence describing
    the items in the cart and be asked whether we want to checkout, save, or add another
    item:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试成功的购物车查找，我们需要进入我们的 Dynamo 表并找到一个包含项目的购物车。我们应该得到一个描述购物车内项目的格式良好的句子，并会被问及我们是否想要结账、保存或添加另一个项目：
- en: '[PRE79]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: With the testing complete, we can go into the Lex bot and change the fulfilment
    for the `whatsInMyCart` intent to our `whatsInMyCart` Lambda.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，我们可以进入 Lex 机器人并更改 `whatsInMyCart` 意图的履行方式为我们的 `whatsInMyCart` Lambda。
- en: Testing the whole bot
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试整个机器人
- en: Now that we have created all of the Lambdas and tested that they all work, we
    can put it all together and build our chatbot. On the Lex console for this chatbot,
    go through each of the intents and make sure that they are all being fulfilled
    using the correct Lambda, and then we can click Build at the top of the page.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有的 Lambda 函数并测试了它们都能正常工作，我们可以将它们全部整合起来并构建我们的聊天机器人。在 Lex 控制台中为这个聊天机器人，逐个检查每个意图，确保它们都使用正确的
    Lambda 函数来实现，然后我们可以在页面顶部点击“构建”。
- en: 'Once it has finished building, we can start testing it out. We can start with
    finding a product. Typing `I want to buy a shirt` starts the `productFind` intent
    flow, and we can find the stock levels of the found item:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，我们就可以开始测试它。我们可以从查找一个产品开始。输入 `I want to buy a shirt` 会启动 `productFind`
    意图流程，然后我们可以找到找到的项目库存水平：
- en: '![](img/4eb00e4a-aec2-4378-8528-73d245cd0128.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4eb00e4a-aec2-4378-8528-73d245cd0128.png)'
- en: Testing productFind
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 productFind
- en: 'When we get shown a product, we should also be asked whether we want to add
    this to our cart. No matter our answer, we should then be asked whether we want
    to checkout, add another item, or save our cart. We need to try each of these
    methods, starting with adding another item:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到一个产品时，我们也应该被问及是否想要将其添加到我们的购物车中。无论我们的回答如何，我们随后都应该被问及是否想要结账、添加另一个项目或保存购物车。我们需要尝试这些方法中的每一种，从添加另一个项目开始：
- en: '![](img/5c22027a-59e2-489c-b4d2-35d82975464b.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c22027a-59e2-489c-b4d2-35d82975464b.png)'
- en: Adding another item to the cart
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 向购物车添加另一个项目
- en: 'As expected, we are sent to the start of the `productFind` flow. Having gone
    through that flow but not added a new item to our cart, we can now test saving
    our cart. When we get to the end of a product find, we can say that we want to
    save our cart. When we provide a cart name, we are told that our cart has been
    saved:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们被发送到`productFind`流程的起点。在经历了该流程但未将新项目添加到购物车后，我们现在可以测试保存购物车。当我们到达产品查找的终点时，我们可以表示我们想要保存购物车。当我们提供购物车名称时，我们会被告知我们的购物车已被保存：
- en: '![](img/669206aa-f872-4b57-9d48-47213b2fff7d.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/669206aa-f872-4b57-9d48-47213b2fff7d.png)'
- en: Testing saveCart
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 测试saveCart
- en: 'To test recovering a cart, we can clear the chat in Lex and ask to `get my
    saved cart`*.* We should be asked to enter our cart name and, if found, it will
    be recovered for us:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试恢复购物车，我们可以在Lex中清除聊天并请求`get my saved cart`。我们应该被要求输入购物车名称，如果找到，它将为我们恢复：
- en: '![](img/3e9d9c3b-cd8c-4b07-a4f6-23d6bf3c7905.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e9d9c3b-cd8c-4b07-a4f6-23d6bf3c7905.png)'
- en: Testing getSavedCart
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 测试getSavedCart
- en: 'Now that we''ve got our saved cart back, we might want to check what we put
    in it. All we need to say is `what is in my cart` and we should get a summary
    of our products. As we only added the first product, we should have just one item:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经恢复了我们的保存的购物车，我们可能想检查我们放进去的东西。我们只需要说`what is in my cart`，我们就应该得到我们产品的摘要。由于我们只添加了第一个产品，我们应该只有一个项目：
- en: '![](img/da3e9bf7-ec9e-4ceb-9503-6eed7cbeb92d.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da3e9bf7-ec9e-4ceb-9503-6eed7cbeb92d.png)'
- en: Testing whatsInMyCart
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 测试whatsInMyCart
- en: 'The last thing to test is checking out. With at least one item in our basket,
    we can ask to checkout. We should be asked for an address and then be told that
    our order has been placed:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要测试的是结账。在我们的篮子里至少有一件商品的情况下，我们可以请求结账。我们应该被要求提供地址，然后被告知我们的订单已下单：
- en: '![](img/0d7353d5-9385-4f20-8ad2-11af84245a7a.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d7353d5-9385-4f20-8ad2-11af84245a7a.png)'
- en: Testing checkout
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 测试checkout
- en: With all of that tested, we have completed our shopping chatbot. If you've had
    any problems with these tests, go back and make sure that all of your code is
    correct and that Lex has been set up correctly. If you are having further issues,
    there is a set of debugging tips at the end of this book.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试了所有这些之后，我们已经完成了我们的购物聊天机器人。如果你在这些测试中遇到了任何问题，请返回并确保你的所有代码都是正确的，并且Lex已经正确设置。如果你遇到进一步的问题，这本书的末尾有一组调试技巧。
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered a lot. We started by designing a complex chatbot flow
    with multiple sub-flows. We then built these flows into a set of intents, which
    allow a user to go through the full process, or to do part of the process and
    return later. This meant we need to trigger intents directly from other intents,
    pre-populating some of the slots and using *confirmation intents* to change from
    one intent to another. We've also learned how to use DynamoDB tables to store
    and retrieve data about the progress of the users.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。我们首先设计了一个复杂的聊天机器人流程，其中包含多个子流程。然后我们将这些流程构建成一组意图，使用户能够完成整个流程，或者只完成部分流程并在以后返回。这意味着我们需要直接从其他意图触发意图，预先填充一些槽位，并使用*确认意图*从一个意图切换到另一个意图。我们还学习了如何使用DynamoDB表来存储和检索有关用户进度的数据。
- en: Questions
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main difference between a complex flow and a simple flow?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复杂流程和简单流程之间的主要区别是什么？
- en: How can we make complex flow diagrams easier to understand?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使复杂的流程图更容易理解？
- en: What are the five types of Lex fulfillment?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lex有哪五种满足类型？
- en: What is the name of the part of the AWS SDK that we can use to access DynamoDB
    tables?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用AWS SDK的哪个部分来访问DynamoDB表？
- en: Further reading
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you want to learn more about the different ways to interact with Dynamo,
    I would recommend looking through the DocumentClient documentation. You can learn
    how to implement scans, queries, and batch processing. You can read that documentation
    at [https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于与Dynamo交互的不同方式，我建议查看DocumentClient文档。你可以学习如何实现扫描、查询和批量处理。你可以在[https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html)阅读该文档。
