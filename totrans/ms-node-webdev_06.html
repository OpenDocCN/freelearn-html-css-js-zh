<html><head></head><body>
<div><h1 class="chapternumber">6</h1>
<h1 class="chaptertitle" id="_idParaDest-114">Using Node.js Streams</h1>
<p class="normal1">One of the main tasks required in server-side development is transferring data, either reading data sent by a client or browser or writing data that must be transmitted or stored in some way. In this chapter, I will introduce the Node.js API for dealing with data sources and data destinations, known as <em class="italic">streams</em>. I will explain the concept behind streams, show how they are used to deal with HTTP requests, and explain why one common source of data – the file system – should be used with caution in a server-side project. <em class="italic">Table 6.1</em> puts streams in context.</p>
<p class="packt_figref">Table 6.1: Putting streams in context</p>
<table class="table-container" id="table001-3">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What are they?</p>
</td>
<td class="table-cell">
<p class="normal">Streams are used by Node.js to represent data sources or destinations, including HTTP requests and responses. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why are they useful?</p>
</td>
<td class="table-cell">
<p class="normal">Streams don’t expose the details of how data is produced or consumed, which allows the same code to process data from any source. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How are they used?</p>
</td>
<td class="table-cell">
<p class="normal">Node.js provides streams to deal with HTTP requests. The streams API is used to read data from the HTTP request and write data to the HTTP response. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">The streams API can be a little awkward to work with, but this can be improved with the use of third-party packages, which often provide more convenient methods to perform common tasks.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">Streams are integral to Node.js development. Third-party packages can simplify working with streams, but it is helpful to understand how streams work for when problems arise.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 6.2</em> sums up what the chapter will cover.</p>
<p class="packt_figref">Table 6.2: Chapter summary</p>
<table class="table-container" id="table002-3">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Write data to a stream</p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">write</code> or <code class="inlinecode">end</code> methods.</p>
</td>
<td class="table-cell">
<p class="normal">4</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Set response headers</p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">setHeader</code> method.</p>
</td>
<td class="table-cell">
<p class="normal">5–7</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Manage data buffering</p>
</td>
<td class="table-cell">
<p class="normal">Use the result from the <code class="inlinecode">write</code> method and handle the <code class="inlinecode">drain</code> event.</p>
</td>
<td class="table-cell">
<p class="normal">8–9</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Read data from a stream</p>
</td>
<td class="table-cell">
<p class="normal">Handle the <code class="inlinecode">data</code> and <code class="inlinecode">end</code> events or use an iterator.</p>
</td>
<td class="table-cell">
<p class="normal">10–15</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Connect streams</p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">pipe</code> method.</p>
</td>
<td class="table-cell">
<p class="normal">16</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Transform data </p>
</td>
<td class="table-cell">
<p class="normal">Extend the <code class="inlinecode">Transform</code> class and use the stream object mode.</p>
</td>
<td class="table-cell">
<p class="normal">17–19</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Serve static files</p>
</td>
<td class="table-cell">
<p class="normal">Use the Express static middleware or use the <code class="inlinecode">sendFile</code> and <code class="inlinecode">download</code> methods.</p>
</td>
<td class="table-cell">
<p class="normal">20–26</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Encode and decode data</p>
</td>
<td class="table-cell">
<p class="normal">Use the Express JSON middleware and the <code class="inlinecode">json</code> response method.</p>
</td>
<td class="table-cell">
<p class="normal">27–28</p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-115">Preparing for this chapter</h1>
<p class="normal1">In this chapter, I will continue to use the <code class="inlinecode">webapp</code> project created in <em class="italic">Chapter 4</em> and modified in <em class="italic">Chapter 3</em>. To prepare for this chapter, replace the contents of the <code class="inlinecode">server.ts</code> file in the <code class="inlinecode">src</code> folder with the code shown in <em class="italic">Listing 6.1</em>.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 6.1: Replacing the contents of the server.Ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { basicHandler } from "./handler";
const port = 5000;
const expressApp: Express = express();
expressApp.get("/favicon.ico", (req, resp) =&gt; {
    resp.statusCode = 404;
    resp.end();
});
expressApp.get("*", basicHandler);
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The Express router filters out favicon requests and passes on all other HTTP GET requests to a function named <code class="inlinecode">basicHandler</code>, which is imported from the <code class="inlinecode">handler</code> module. To define the handler, replace the contents of the <code class="inlinecode">handler.ts</code> to the <code class="inlinecode">src</code> folder with the code shown in <em class="italic">Listing 6.2</em>.</p>
<p class="packt_figref">Listing 6.2. The contents of the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const basicHandler = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    resp.end("Hello, World");
};
</code></pre>
<p class="normal">This handler uses the Node.js <code class="inlinecode">IncomingMessage</code> and <code class="inlinecode">ServerResponse</code> types, even though Express is used to route requests. I will demonstrate the enhancements Express provides in the <em class="italic">Using third-party enhancements</em> section, but I am going to start with the built-in features that Node.js provides.</p>
<p class="normal">Some examples in this chapter require an image file. Create the <code class="inlinecode">static</code> folder and add to it an image file named <code class="inlinecode">city.png</code>. You can use any PNG image file as long as you name it <code class="inlinecode">city.png</code>, or you can download the public domain panorama of the New York City skyline that I used, shown in <em class="italic">Figure 6.1</em>, from the code repository for this chapter.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.1: The city.png file in the static folder</p>
<p class="normal">Run the command shown in <em class="italic">Listing 6.3</em> in the <code class="inlinecode">webapp</code> folder to start the watcher that compiles TypeScript files and executes the JavaScript that is produced.</p>
<p class="packt_figref">Listing 6.3: Starting the project</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a web browser and request <code class="inlinecode">http://localhost:5000</code>. You will see the result shown in <em class="italic">Figure 6.2</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.2: Running the example project</p>
<h1 class="heading" id="_idParaDest-116">Understanding streams</h1>
<p class="normal1">The best way to <a id="_idIndexMarker297" class="calibre3"/>understand streams is to ignore data and think about water for a moment. Imagine you are in a room in which a pipe with a faucet enters through one wall. Your job is to build a device that will collect the water from the pipe. There is obviously something connected to the other end of the pipe that produces the water, but you are only able to see the faucet, and so the design of your device will be dictated by what you know: you have to create something that will connect to the pipe and receive the water when the faucet is turned on. Having such a limited view of the system you are working with may feel like a restriction, but the pipe can be connected to any source of water and your device works just as well whether the water comes from a river or a reservoir; it is all just water coming through the pipe via the faucet, and it is always consumed consistently. </p>
<p class="normal">At the other end of the pipe, the producer of the water has a pipe into which they pump their water. The water producer can’t see what you have attached to the other end of the pipe and does not know how you are going to consume the water. And it doesn’t matter, because all the producer has to do is push their water through the pipe, regardless of whether their water will be used to drive a water mill, fill a swimming pool, or run a shower. You can change the device attached to your pipe and nothing would change for the producer, who still keeps pumping water into the same pipe in the same way.</p>
<p class="normal">In the world of<a id="_idIndexMarker298" class="calibre3"/> web development, a <em class="italic">stream</em> solves the problem of distributing data in the same way that the pipe solves the problem of distributing water. Like a pipe, a stream has two ends. At one end is the data producer, also known as the <em class="italic">writer</em>, who puts a sequence of data values into the stream. At the other end is the data consumer, also known as the <em class="italic">reader</em>, who receives the sequence of data values from the stream. The writer and reader each have their own API that allows them to work with the stream, as shown in <em class="italic">Figure 6.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.3: The anatomy of a stream</p>
<p class="normal">This arrangement <a id="_idIndexMarker299" class="calibre3"/>has two important characteristics. The first is that the data arrives in the same order in which it is written, which is why streams are usually described as a <em class="italic">sequence</em> of data values. </p>
<p class="normal">The second characteristic is that the data values can be written to the stream over time so that the writer doesn’t have to have all the data values ready before the first value is written. This means that the reader can receive and start processing data while the writer is still preparing or computing later values in the sequence. This makes streams suitable for a wide range of data sources, and they also integrate well with the Node.js programming model, as the examples in this chapter will demonstrate.</p>
<h1 class="heading" id="_idParaDest-117">Using Node.js streams</h1>
<p class="normal1">The <code class="inlinecode">streams</code> module<a id="_idIndexMarker300" class="calibre3"/> contains classes that represent different kinds of streams, and the two most important are described in <em class="italic">Table 6.3</em>. </p>
<p class="packt_figref">Table 6.3: Useful stream classes</p>
<table class="table-container" id="table003-3">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Writable</code></p>
</td>
<td class="table-cell">
<p class="normal">This class provides the API for writing data to a stream.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Readable</code></p>
</td>
<td class="table-cell">
<p class="normal">This class provides the API for reading data from a stream.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">In Node.js development, one end of a stream is usually connected to something outside of the JavaScript environment, such as a network connection or the file system, and this allows data to be read and written in the same way regardless of where it is going to or coming from.</p>
<p class="normal">For web development, the most important use of streams is they are used to represent HTTP requests and responses. The <code class="inlinecode">IncomingMessage</code> and <code class="inlinecode">ServerResponse</code> classes, which are used to represent HTTP requests and responses, are derived from the <code class="inlinecode">Readable</code> and <code class="inlinecode">Writable</code> classes.</p>
<h2 class="heading1" id="_idParaDest-118">Writing data to a stream</h2>
<p class="normal1">The <code class="inlinecode">Writable</code> class is<a id="_idIndexMarker301" class="calibre3"/> used to write data to a stream. The <a id="_idIndexMarker302" class="calibre3"/>most useful features provided by the <code class="inlinecode">Writable</code> class are described in <em class="italic">Table 6.4</em> and explained in the sections that follow. </p>
<p class="packt_figref">Table 6.4: Useful Writable Features </p>
<table class="table-container" id="table004-2">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">write(data, callback)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method writes data to the stream and invokes the optional callback function when the data has been flushed. Data can be expressed as a <code class="inlinecode">string</code>, <code class="inlinecode">Buffer</code>, or <code class="inlinecode">Uint8Array</code>. For string values, an optional encoding can be specified.</p>
<p class="normal">The method returns a <code class="inlinecode">boolean</code> value that indicates whether the stream is able to accept further data without exceeding its buffer size, as described in the <em class="italic">Avoiding excessive data buffering</em> section.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">end(data, callback)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method tells Node.js that no further data will be sent. The arguments are an optional final chunk of data to write and an optional callback function that will be invoked when the data is finished.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">destroy(error)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method destroys the stream immediately, without waiting for any pending data to be processed. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">closed</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns <code class="inlinecode">true</code> if the stream has been closed.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">destroyed</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns <code class="inlinecode">true</code> if the <code class="inlinecode">destroy</code> method has been called.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">writable</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns <code class="inlinecode">true</code> if the stream can be written to, meaning that the stream has not ended, encountered an error, or been destroyed.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">writableEnded</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns <code class="inlinecode">true</code> if the <code class="inlinecode">end</code> method has been called.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">writableHighWaterMark</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns the size of the data buffer in bytes. The <code class="inlinecode">write</code> method will return <code class="inlinecode">false</code> when the amount of buffered data exceeds this amount.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">errored</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns <code class="inlinecode">true</code> if the stream has encountered an error.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The <code class="inlinecode">Writable</code> class also <a id="_idIndexMarker303" class="calibre3"/>emits events, the most useful of <a id="_idIndexMarker304" class="calibre3"/>which are described in <em class="italic">Table 6.5</em>. </p>
<p class="packt_figref">Table 6.5: Useful Writable Events </p>
<table class="table-container" id="table005-2">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">close</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is emitted when the stream is closed.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">drain</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is emitted when the stream can accept data without buffering.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">error</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is emitted when an error occurs.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">finish</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is emitted when the <code class="inlinecode">end</code> method is called and all of the data in the stream has been processed. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The basic approach to using a writable stream is to call the <code class="inlinecode">write</code> method until all of the data has been sent to the stream, and then call the <code class="inlinecode">end</code> method, as shown in <em class="italic">Listing 6.4</em>.</p>
<p class="packt_figref">Listing 6.4: Writing Data in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const basicHandler = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    <strong class="screentext">for (let i = 0</strong><strong class="screentext">; i &lt; 10; i++) {</strong>
<strong class="screentext">        resp.write(`Message: ${i}\n`);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext"> </strong>
<strong class="screentext">    resp.end("End");</strong>
};
</code></pre>
<p class="normal">Save the changes, allow<a id="_idIndexMarker305" class="calibre3"/> Node.js to restart, and then request <code class="inlinecode">http://localhost:5000</code>. The handler will write its data to the response stream, producing the result shown in <em class="italic">Figure 6.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.4: Writing data to an HTTP response stream</p>
<p class="normal">It is easy to<a id="_idIndexMarker306" class="calibre3"/> think of the endpoint of the stream as being a straight pipe to the ultimate recipient of the data, which is the web browser in this case, but that’s rarely the case. The endpoint for most streams is the part of the Node.js API that interfaces with the operating system, in this case, the code that deals with the operating system’s network stack to send and receive data. This indirect relationship leads to important considerations, as described in the sections that follow.</p>
<h3 class="heading2" id="_idParaDest-119">Understanding stream enhancements</h3>
<p class="normal1">Some<a id="_idIndexMarker307" class="calibre3"/> streams are enhanced to ease development, which means that the data you write to the stream won’t always be the data that is received at the other end. In the case of HTTP responses, for example, the Node.js HTTP API aids development by ensuring that all responses conform to the basic requirements of the HTTP protocol, even when the programmer doesn’t explicitly use the features provided to set the status code and headers. To see the content that the example in <em class="italic">Listing 6.4</em> writes to the stream, open a <a id="_idIndexMarker308" class="calibre3"/>new command prompt and run the Linux command shown in <em class="italic">Listing 6.5</em>. </p>
<p class="packt_figref">Listing 6.5: Making an HTTP Request (Linux)</p>
<pre class="programlisting2"><code class="hljs-code">curl --include http://localhost:5000
</code></pre>
<p class="normal">If you are a Windows user, use PowerShell to run the command shown in <em class="italic">Listing 6.6</em> instead.</p>
<p class="packt_figref">Listing 6.6: Making an HTTP Request (Windows)</p>
<pre class="programlisting1"><code class="hljs-con">(Invoke-WebRequest http://localhost:5000).RawContent
</code></pre>
<p class="normal">These commands make it easy to see the entire response sent by Node.js. The code in <em class="italic">Listing 6.4</em> uses just the <code class="inlinecode">write</code> and <code class="inlinecode">end</code> methods, but the HTTP response will be like this:</p>
<pre class="programlisting"><code class="hljs-code">...
HTTP/1.1 200 OK
Connection: keep-alive
Keep-Alive: timeout=5
Transfer-Encoding: chunked
Date: Wed, 01 Nov 2023 19:46:02 GMT
X-Powered-By: Express
Message: 0
Message: 1
Message: 2
Message: 3
Message: 4
Message: 5
Message: 6
Message: 7
Message: 8
Message: 9
End
...
</code></pre>
<p class="normal">The Node.js HTTP API makes sure the response is legal HTTP by adding an HTTP version number, a status code and message, and a minimal set of headers. This is a useful <a id="_idIndexMarker309" class="calibre3"/>feature, and it helps illustrate the fact that you cannot assume that the data you write to a stream will be the data that arrives at the other end.</p>
<p class="normal">The <code class="inlinecode">ServerResponse</code> class demonstrates another kind of stream enhancement, which is methods or properties that write content to the stream for you, as shown in <em class="italic">Listing 6.7</em>.</p>
<p class="packt_figref">Listing 6.7: Using a Stream Enhancement Method in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const basicHandler = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    <strong class="screentext">resp.setHeader("Content-Type", "text/plain");</strong>
    for (let i = 0; i &lt; 10; i++) {
        resp.write(`Message: ${i}\n`);
    }
   
    resp.end("End");
};
</code></pre>
<p class="normal">Behind the scenes, the <code class="inlinecode">ServerResponse</code> class merges the arguments passed to the <code class="inlinecode">setHeader</code> method with the default content used for responses. The <code class="inlinecode">ServerResponse</code> class is derived from <code class="inlinecode">Writable</code> and implements the methods and properties described in <em class="italic">Table 6.4</em>, but the enhancements make it easier to write content to the stream that is specific to HTTP requests, like setting a header in the response. If you run the commands shown in <em class="italic">Listing 6.6</em> or <em class="italic">Listing 6.7</em> again, you will see the effect of calling the <code class="inlinecode">setHeader</code> method:</p>
<pre class="programlisting"><code class="hljs-code">...
HTTP/1.1 200 OK
Connection: keep-alive
Keep-Alive: timeout=5
Transfer-Encoding: chunked
<strong class="screentext">Content-Type: text/plain</strong>
Date: Wed, 01 Nov 2023 21:19:45 GMT
X-Powered-By: Express
...
</code></pre>
<h3 class="heading2" id="_idParaDest-120">Avoiding excessive data buffering</h3>
<p class="normal1">Writable streams <a id="_idIndexMarker310" class="calibre3"/>are created with a buffer in which data is stored before it is processed. The buffer is a way of improving performance, by allowing the producer of data to write data to the stream in bursts faster than the stream endpoint can process them.</p>
<p class="normal">Each time the stream processes a chunk of data, it is said to have <em class="italic">flushed</em> the data. When all of the data in the stream’s buffer has been processed, the stream buffer is said to have been <em class="italic">drained</em>. The amount of data that can be stored in the buffer is known as the <em class="italic">high-water mark</em>. </p>
<p class="normal">A writable stream will always accept data, even if it has to increase the size of its buffer, but this is undesirable because it increases the demand for memory that can be required for an extended period while the stream flushes the data it contains.</p>
<p class="normal">The ideal approach is to write data to a stream until its buffer is full and then wait until that data is flushed before further data is written. To help achieve this goal, the <code class="inlinecode">write</code> method returns a <code class="inlinecode">boolean</code> value that indicates whether the stream can receive more data without expanding its buffer beyond its target high-water mark.</p>
<p class="normal"><em class="italic">Listing 6.8</em> uses the value returned by the <code class="inlinecode">write</code> method to indicate when the stream buffer has reached capacity.</p>
<p class="packt_figref">Listing 6.8: Checking Stream Capacity in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const basicHandler = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    resp.setHeader("Content-Type", "text/plain");
   <strong class="screentext"> for (let i = 0; i &lt; </strong><strong class="screentext">10_000; i++) {</strong>
<strong class="screentext">        if (resp.write(`Message: ${i}\n`)) {</strong>
<strong class="screentext">            console.log("Stream buffer is at capacity");</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
   
    resp.end("End");
};
</code></pre>
<p class="normal">You may <a id="_idIndexMarker311" class="calibre3"/>need to increase the maximum value used by the <code class="inlinecode">for</code> loop, but for my development PC, rapidly writing 10,000 messages to the stream will reliably reach the stream limits. Use a browser to request <code class="inlinecode">http://localhost:5000</code>, and you will see messages like these produced by the Node.js console:</p>
<pre class="programlisting1"><code class="hljs-con">...
Stream buffer is at capacity
Stream buffer is at capacity
Stream buffer is at capacity
...
</code></pre>
<p class="normal">Writable streams emit the <code class="inlinecode">drain</code> event when their buffers have been drained, at which point more data can be written. In <em class="italic">Listing 6.9</em>, data is written to the HTTP response stream until the <code class="inlinecode">write</code> method returns <code class="inlinecode">false</code> and then stops writing until the <code class="inlinecode">drain</code> event is received. (If you want to know when an individual chunk of data is flushed, then you can pass a callback function to the stream’s <code class="inlinecode">write</code> method.)</p>
<p class="packt_figref">Listing 6.9: Avoiding Excessive Data Buffering in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const basicHandler = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    resp.setHeader("Content-Type", "text/plain");
    <strong class="screentext">let i = 0;</strong>
<strong class="screentext">    let canWrite = true;</strong>
<strong class="screentext">    const writeData = () =&gt; {</strong>
<strong class="screentext"> </strong><strong class="screentext">console.log("Started writing data"); </strong>
<strong class="screentext">        do {</strong>
<strong class="screentext">            canWrite = resp.write(`Message: ${i++}\n`);</strong>
<strong class="screentext">        } while (i &lt; 10_000 &amp;&amp; canWrite);</strong>
<strong class="screentext">        console.</strong><strong class="screentext">log("Buffer is at capacity");</strong>
<strong class="screentext">        if (i &lt; 10_000) {</strong>
<strong class="screentext">            resp.once("drain", () =&gt; {</strong>
<strong class="screentext">                console.log("Buffer has been drained");</strong>
<strong class="screentext"> </strong><strong class="screentext">writeData();</strong>
<strong class="screentext">            });</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            resp.end("End");</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    writeData();</strong>
};
</code></pre>
<p class="normal">The <code class="inlinecode">writeData</code> function<a id="_idIndexMarker312" class="calibre3"/> enters a <code class="inlinecode">do...while</code> loop that writes data to the stream until the <code class="inlinecode">write</code> method returns <code class="inlinecode">false</code>. The <code class="inlinecode">once</code> method is used to register a handler that will be invoked once when the <code class="inlinecode">drain</code> event is emitted, and which invokes the <code class="inlinecode">writeData</code> function to resume writing. Once all of the data has been written, the <code class="inlinecode">end</code> method is called to finalize the stream.</p>
<div><p class="normal"><strong class="screentext">Avoiding the Early End Pitfall</strong></p>
<p class="normal">A common mistake – and one that I make regularly – is to put the call to the <code class="inlinecode">end</code> method outside of the callback functions that write the data, like this: </p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">...</code>
<code class="inlinecode2">const writeData = () =&gt; {</code>
<code class="inlinecode2">    console.log("Started writing data"); </code>
<code class="inlinecode2">    do {</code>
<code class="inlinecode2">        canWrite = resp.write(`Message: ${i++}\n`);</code>
<code class="inlinecode2">    } while (i &lt; 10_000 &amp;&amp; canWrite);</code>
<code class="inlinecode2">    console.log("Buffer is at capacity");</code>
<code class="inlinecode2">    if (i &lt; 10_000) {</code>
<code class="inlinecode2">        resp.once("drain", () =&gt; {</code>
<code class="inlinecode2">            console.log("Buffer has been drained");</code>
<code class="inlinecode2">            writeData();</code>
<code class="inlinecode2">        });</code>
<code class="inlinecode2">    }</code>
<code class="inlinecode2">}</code>
<code class="inlinecode2">writeData();</code>
<code class="inlinecode2">resp.end("End");</code>
<code class="inlinecode2">...</code>
</code></pre>
<p class="normal">The outcome can differ but is usually an error because the callback will invoke the <code class="inlinecode">write</code> method after the stream has been closed, or not all the data will be written to the stream because the <code class="inlinecode">drain</code> event won’t be emitted. To avoid this mistake, ensure that the <code class="inlinecode">end</code> method is invoked within the callback function once the data has been written.</p>
</div>
<p class="normal">Use a <a id="_idIndexMarker313" class="calibre3"/>browser to request <code class="inlinecode">http://localhost:5000</code>, and you will see Node.js console messages that show the writing stops as the buffer reaches capacity, resuming once the buffer is drained:</p>
<pre class="programlisting1"><code class="hljs-con">...
Started writing data
Buffer is at capacity
Buffer has been drained
Started writing data
...
</code></pre>
<h2 class="heading1" id="_idParaDest-121">Reading data from a stream</h2>
<p class="normal1">The most<a id="_idIndexMarker314" class="calibre3"/> important source of data in a web application<a id="_idIndexMarker315" class="calibre3"/> comes from HTTP request bodies. The example project needs a little preparation so that the client-side code can make an HTTP request with a body. Add a file named <code class="inlinecode">index.html</code> to the <code class="inlinecode">static</code> folder with the content shown in <em class="italic">Listing 6.10</em>. </p>
<p class="packt_figref">Listing 6.10: The Contents of the index.html File in the static Folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script&gt;
            document.addEventListener('DOMContentLoaded', function() {
                document.getElementById("btn")
                    .addEventListener("click", sendReq);
            });
            sendReq = async () =&gt; {
                let payload = "";
                for (let i = 0; i &lt; 10_000; i++) {
                    payload += `Payload Message: ${i}\n`;
                }
                const response = await fetch("/read", {
                    method: "POST", body: payload
                })
                document.getElementById("msg").textContent
                     = response.statusText;
                document.getElementById("body").textContent
                    = await response.text();
            }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
       &lt;button id="btn"&gt;Send Request&lt;/button&gt;
       &lt;div id="msg"&gt;&lt;/div&gt;
       &lt;div id="body"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">This is a<a id="_idIndexMarker316" class="calibre3"/> simple HTML document that contains some <a id="_idIndexMarker317" class="calibre3"/>JavaScript code. I’ll make improvements later in the chapter, including separating the JavaScript and HTML content into separate files, but this is enough to get started. The JavaScript code in <em class="italic">Listing 6.10</em> uses the browser’s Fetch API to send an HTTP POST request with a body that contains 1,000 lines of text. <em class="italic">Listing 6.11</em> updates the existing request handler so that it responds with the contents of the HTML file.</p>
<p class="packt_figref">Listing 6.11: Updating the Handlers in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">import { readFileSync } from "fs";</strong>
export const basicHandler = (req: IncomingMessage, resp: ServerResponse) =&gt; { 
    <strong class="screentext">resp.write(readFileSync("static/index.html"));</strong>
<strong class="screentext">    resp.end();</strong>
};
</code></pre>
<p class="normal">I use<a id="_idIndexMarker318" class="calibre3"/> the <code class="inlinecode">readFileSync</code> function to perform a blocking<a id="_idIndexMarker319" class="calibre3"/> read of the <code class="inlinecode">index.html</code> file, which is simple but is not the best way to read files, as I explain later in this chapter. To create a new handler that will be used to read the data sent by the browser, add a file named <code class="inlinecode">readHandler.ts</code> to the <code class="inlinecode">src</code> folder with the contents shown in <em class="italic">Listing 6.12</em>. For the moment, this handler is a placeholder that ends the response without producing any content.</p>
<p class="packt_figref">Listing 6.12: The Contents of the readHandler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const readHandler = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    // TODO - read request body
    resp.end();
}
</code></pre>
<p class="normal"><em class="italic">Listing 6.13</em> completes the preparation by adding a route that matches POST requests and sends them to the new handler.</p>
<p class="packt_figref">Listing 6.13: Adding a Route in the server.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { basicHandler } from "./handler";
<strong class="screentext">import { readHandler } from "./readHandler";</strong>
const port = 5000;
const expressApp: Express = express();
expressApp.get("/favicon.ico", (req, resp) =&gt; {
    resp.statusCode = 404;
    resp.end();
});
expressApp.get("*", basicHandler);
<strong class="screentext">expressApp.post("/read", readHandler);</strong>
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">Use a<a id="_idIndexMarker320" class="calibre3"/> browser to request <code class="inlinecode">http://localhost:5000</code>, and you will see the button defined by the HTML document. Click<a id="_idIndexMarker321" class="calibre3"/> the button, and the browser will send an HTTP POST request and display the status message from the response it receives, as shown in <em class="italic">Figure 6.5</em>. The content presented by the browser is completely unstyled, but this is enough for now.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.5: Sending an HTTP POST request</p>
<h3 class="heading2" id="_idParaDest-122">Understanding the Readable class</h3>
<p class="normal1">The <code class="inlinecode">Readable</code> class<a id="_idIndexMarker322" class="calibre3"/> is used to read data from a stream. <em class="italic">Table 6.6</em> describes <a id="_idIndexMarker323" class="calibre3"/>the most useful <code class="inlinecode">Readable</code> features. </p>
<p class="packt_figref"><em class="italic">Table 6.6</em>: Useful Readable Features</p>
<table class="table-container" id="table006-2">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">pause()</code></p>
</td>
<td class="table-cell">
<p class="normal">Calling this method tells the stream to temporarily stop emitting the <code class="inlinecode">data</code> event.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">resume()</code></p>
</td>
<td class="table-cell">
<p class="normal">Calling this method tells the stream to resume emitting the <code class="inlinecode">data</code> event.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">isPaused()</code></p>
</td>
<td class="table-cell">
<p class="normal">This method returns <code class="inlinecode">true</code> if the stream’s <code class="inlinecode">data</code> events have been paused.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">pipe(writable)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method is used to transfer the stream’s data to a <code class="inlinecode">Writable</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">destroy(error)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method destroys the stream immediately, without waiting for any pending data to be processed.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">closed</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns <code class="inlinecode">true</code> if the stream has been closed.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">destroyed</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns <code class="inlinecode">true</code> if the <code class="inlinecode">destroy</code> method has been called.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">errored</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns <code class="inlinecode">true</code> if the stream has encountered an error.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The <code class="inlinecode">Readable</code> class also emits events, the most useful of which are described in <em class="italic">Table 6.7</em>. </p>
<p class="packt_figref">Table 6.7: Useful Readable Events</p>
<table class="table-container" id="table007-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">data</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is emitted when the stream is in flowing mode and provides access to the data in the stream. See the <em class="italic">Reading Data with events</em> section for details.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">end</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is emitted when there is no more data to be read from the stream.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">close</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is emitted when the stream is closed. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">pause</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is emitted when data reading is paused by calling the <code class="inlinecode">pause</code> method.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">resume</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is emitted when data reading is restarted by calling the <code class="inlinecode">resume</code> method.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">error</code></p>
</td>
<td class="table-cell">
<p class="normal">This event is triggered if there is an error reading data from the stream.</p>
</td>
</tr>
</tbody>
</table>
<h3 class="heading2" id="_idParaDest-123">Reading data with events</h3>
<p class="normal1">Data can be read <a id="_idIndexMarker324" class="calibre3"/>from the stream using events, as shown in <em class="italic">Listing 6.14</em>, where a callback function is used to process data as it becomes available. </p>
<p class="packt_figref">Listing 6.14: Reading Data in the readHandler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const readHandler = (req: IncomingMessage, resp: ServerResponse) =&gt; <strong class="screentext">{</strong>
<strong class="screentext">    req.setEncoding("utf-8");</strong>
<strong class="screentext">    req.on("data", (data: string) =&gt; {</strong>
<strong class="screentext">        console</strong><strong class="screentext">.log(data);</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    req.on("end", () =&gt; {</strong>
<strong class="screentext">        console.log("End: all data read");</strong>
<strong class="screentext">        resp.end();</strong>
<strong class="screentext">    });   </strong>
}
</code></pre>
<p class="normal">The <code class="inlinecode">data</code> event is emitted when data is available to be read from the stream and is available for processing by the callback function used to handle the event. The data is passed to the callback function as a <code class="inlinecode">Buffer</code>, which represents an array of unsigned bytes, unless the <code class="inlinecode">setEncoding</code> method has been used to specify character encoding, in which case the data is expressed as a <code class="inlinecode">string</code>.</p>
<p class="normal">This example sets the character encoding to UTF-8 so that the callback function for the <code class="inlinecode">data</code> event will receive <code class="inlinecode">string</code> values, which are then written out using the <code class="inlinecode">console.log</code> method.</p>
<p class="normal">The <code class="inlinecode">end</code> event is emitted when all of the data has been read from the stream. To avoid a variation of the early-end pitfall I described earlier, I call the response’s <code class="inlinecode">end</code> method only when the readable stream’s <code class="inlinecode">end</code> method is emitted. Use a browser to request <code class="inlinecode">http://localhost:5000</code> and click the <strong class="screentext">Send Request</strong> button, and you<a id="_idIndexMarker325" class="calibre3"/> will see a sequence of Node.js console messages as the data is read from the stream:</p>
<pre class="programlisting1"><code class="hljs-con">...
Payload Message: 0
Payload Message: 1
Payload Message: 2
Payload Message: 3
...
Payload Message: 9997
Payload Message: 9998
Payload Message: 9999
End: all data read
...
</code></pre>
<p class="normal">The JavaScript main thread ensures that <code class="inlinecode">data</code> events are processed sequentially, but the basic idea is that data is read and processed as quickly as possible, such that the <code class="inlinecode">data</code> event will be emitted as soon as possible once data is available to be read.</p>
<h3 class="heading2" id="_idParaDest-124">Reading data with an iterator</h3>
<p class="normal1">Instances of the <code class="inlinecode">Readable</code> class <a id="_idIndexMarker326" class="calibre3"/>can be used as a source of data in a <code class="inlinecode">for</code> loop, which can provide a more familiar way to read data from a stream, as shown in <em class="italic">Listing 6.15</em>. </p>
<p class="packt_figref">Listing 6.15: Reading Data in a Loop in the readHandler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">export const readHandler = async (req: IncomingMessage, resp: ServerResponse) =&gt; {</strong>
    req.setEncoding("utf-8");
<strong class="screentext">    for await (const data of req) {</strong>
<strong class="screentext">        console.log(data);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    console.</strong><strong class="screentext">log("End: all data read");</strong>
<strong class="screentext">    resp.end();</strong>
}
</code></pre>
<p class="normal">The <code class="inlinecode">async</code> and <code class="inlinecode">await</code> keywords must be used as shown in the example, but the result is that <a id="_idIndexMarker327" class="calibre3"/>the <code class="inlinecode">for</code> loop reads data from the stream until it is all consumed. This example produces the same output as <em class="italic">Listing 6.14</em>.</p>
<h3 class="heading2" id="_idParaDest-125">Piping data to a writable stream</h3>
<p class="normal1">The <code class="inlinecode">pipe</code> method<a id="_idIndexMarker328" class="calibre3"/> is used to connect a <code class="inlinecode">Readable</code> stream to a <code class="inlinecode">Writeable</code> stream, ensuring that all of the data is read from the <code class="inlinecode">Readable</code> and written to the <code class="inlinecode">Writable</code> without further intervention, as shown in <em class="italic">Listing 6.16</em>. </p>
<p class="packt_figref">Listing 6.16: Piping Data into the readHandler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const readHandler = async (req: IncomingMessage, resp: ServerResponse) =&gt; {
    <strong class="screentext">req.pipe(resp);</strong>
}
</code></pre>
<p class="normal">This is the simplest way to transfer data between streams, and the <code class="inlinecode">end</code> method is called automatically on the <code class="inlinecode">Writeable</code> stream once all of the data has been transferred. Use a browser to request <code class="inlinecode">http://localhost:5000</code> and click the <strong class="screentext">Send Request</strong> button. The data that is sent in the HTTP request is piped to the HTTP response and displayed in the browser window, as shown in <em class="italic">Figure 6.6</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.6: Piping data</p>
<h1 class="heading" id="_idParaDest-126">Transforming data</h1>
<p class="normal1">The <code class="inlinecode">Transform</code> class is<a id="_idIndexMarker329" class="calibre3"/> used to create objects, known as <em class="italic">transformers</em>, that receive data from a <code class="inlinecode">Readable</code> stream, process it in some way, and then pass it on. Transformers are applied to streams with the <code class="inlinecode">pipe</code> method, as shown in <em class="italic">Listing 6.17</em>. </p>
<p class="packt_figref">Listing 6.17: Creating a Transformer in the readHandler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">import { Transform } from "stream";</strong>
export const readHandler = async (req: IncomingMessage, resp: ServerResponse) =&gt; {
<strong class="screentext">    req.pipe(createLowerTransform()).pipe(resp);</strong>
<strong class="screentext">}</strong>
<strong class="screentext">const</strong><strong class="screentext"> createLowerTransform = () =&gt;  new Transform({</strong>
<strong class="screentext">    transform(data, encoding, callback) {</strong>
<strong class="screentext">        callback(null, data.toString().toLowerCase());</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">});</strong>
</code></pre>
<p class="normal">The <a id="_idIndexMarker330" class="calibre3"/>argument to the <code class="inlinecode">Transform</code> constructor is an object whose <code class="inlinecode">transform</code> property value is a function that will be invoked when there is data to process. The function receives three arguments: a chunk of data to process, which can be of any data type, a string encoding type, and a callback function that is used to pass on the transformed data. In this example, the data that is received is converted to a string on which the <code class="inlinecode">toLowerCase</code> method is called. The result is passed to the callback function, whose arguments are an object that represents any error that has occurred and the transformed data.</p>
<p class="normal">The transformer is applied with the <code class="inlinecode">pipe</code> method and, in this case, is chained so that the data read from the HTTP request is transformed and then written to the HTTP response. Note that a new <code class="inlinecode">Transform</code> object must be created for every request, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
req.pipe(<strong class="screentext">createLowerTransform()</strong>).pipe(resp);
...
</code></pre>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000</code>, and click on the <strong class="screentext">Send Request</strong> button. The content displayed by the browser, which comes from the HTTP response body, is all lowercase, as shown in <em class="italic">Figure 6.7</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_07.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.7: Using a simple transformer</p>
<h2 class="heading1" id="_idParaDest-127">Using object mode</h2>
<p class="normal1">The streams created <a id="_idIndexMarker331" class="calibre3"/>by the Node.js API, such as the ones used for HTTP requests or files, work only on strings and byte arrays. This isn’t always convenient, and so some streams, including transformers, can use <em class="italic">object mode</em>, which allows objects to be read or written. To prepare for this example, <em class="italic">Listing 6.18</em> updates the JavaScript code contained within the static HTML file to send a request containing an array of JSON-formatted objects. </p>
<p class="packt_figref">Listing 6.18: Sending a JSON Request Body in the index.html File in the static Folder</p>
<pre class="programlisting"><code class="hljs-code">...
&lt;script&gt;
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById("btn").addEventListener("click", sendReq);
    });
    sendReq = async () =&gt; {
        <strong class="screentext">let payload = [];</strong>
<strong class="screentext">        for (let i = 0; i &lt; 5; i++) {</strong>
<strong class="screentext">            payload.push({ id: i, message: `Payload Message: ${i}\n`</strong><strong class="screentext">});</strong>
<strong class="screentext">        }</strong>
        const response = await fetch("/read", {
           <strong class="screentext"> method: "POST", body: JSON.stringify</strong><strong class="screentext">(payload),</strong>
<strong class="screentext">            headers: {</strong>
<strong class="screentext">                "Content-Type": "application/json"</strong>
<strong class="screentext">            }</strong>
        });
        document.getElementById("msg").textContent = response.statusText;
        document.getElementById("body").textContent = await response.text();
    }
&lt;/script&gt;
...
</code></pre>
<p class="normal">The <a id="_idIndexMarker332" class="calibre3"/>data sent by the client can still be read as a string or a byte array, but a transform can be used to convert the request payload into a JavaScript object or convert a JavaScript object into a string or byte array, known as <em class="italic">object mode</em>. Two <code class="inlinecode">Transform</code> constructor configuration settings are used to tell Node.js how a transformer will behave, as described in <em class="italic">Table 6.8</em>.</p>
<p class="packt_figref">Table 6.8: The Transform Constructor Configuration Settings</p>
<table class="table-container" id="table008-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">readableObjectMode</code></p>
</td>
<td class="table-cell">
<p class="normal">When set to <code class="inlinecode">true</code>, the transformer will consume string/byte data and produce an object.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">writableObjectMode</code></p>
</td>
<td class="table-cell">
<p class="normal">When set to <code class="inlinecode">true</code>, the transformer will consume an object and produce string/byte data.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Listing 6.19</em> shows a transformer that sets the <code class="inlinecode">readableObjectMode</code> setting to <code class="inlinecode">true</code>, which means that it will read string data from the HTTP request payload but produce a JavaScript object when its data is read.</p>
<p class="packt_figref">Listing 6.19: Parsing JSON in the readHandler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { Transform } from "stream";
export const readHandler = async (req: IncomingMessage, resp: ServerResponse) =&gt; {   
    <strong class="screentext">if (req.headers["content-type"] == "application/json") {</strong>
<strong class="screentext">        req.pipe(createFromJsonTransform()).on("data", (payload) =&gt;</strong><strong class="screentext"> {</strong>
<strong class="screentext">            if (payload instanceof Array) {</strong>
<strong class="screentext">                resp.write(`Received an array with ${payload.length} items`)</strong>
<strong class="screentext">            }  else {</strong>
<strong class="screentext">                resp.write("Did not receive an array");</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">            resp.end</strong><strong class="screentext">();</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">    } else {</strong>
<strong class="screentext">        req.pipe(resp);</strong>
<strong class="screentext">    }</strong>
}
<strong class="screentext">const createFromJsonTransform = () =&gt; new Transform({</strong>
<strong class="screentext">    readableObjectMode: true,</strong>
<strong class="screentext">    transform(data, encoding, callback</strong><strong class="screentext">) {</strong>
<strong class="screentext">        callback(null, JSON.parse(data));</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">});</strong>
</code></pre>
<p class="normal">If the<a id="_idIndexMarker333" class="calibre3"/> HTTP request has a <code class="inlinecode">Content-Type</code> header that indicates the payload is JSON, then the transformer is used to parse the data, which is received by the request handler using the <code class="inlinecode">data </code>event. The parsed payload is checked to see if it is an array, and if it is, then its length is used to generate a response. Use a browser to request <code class="inlinecode">http://localhost:5000</code> (or make sure to reload the browser so that the changes in <em class="italic">Listing 6.18</em> take effect), click the <strong class="screentext">Send Request</strong> button, and you will see the response shown in <em class="italic">Figure 6.8</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_08.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.8: Using a transformer in object mode</p>
<h1 class="heading" id="_idParaDest-128">Using third-party enhancements</h1>
<p class="normal1">In the sections<a id="_idIndexMarker334" class="calibre3"/> that follow, I describe useful enhancements provided by the Express package to deal with streams and tasks that are related to HTTP. Express isn’t the only package that provides these kinds of features, but it is a good default choice for new projects and gives you a foundation from which to compare alternatives. </p>
<h2 class="heading1" id="_idParaDest-129"><a id="_idIndexMarker335" class="calibre3"/><a id="_idIndexMarker336" class="calibre3"/><a id="_idIndexMarker337" class="calibre3"/>Working with files</h2>
<p class="normal1">One of the most<a id="_idIndexMarker338" class="calibre3"/> important tasks for a web server is to respond to requests for files, which provide browsers with the HTML, JavaScript, and other static content required by the client-side part of the application. </p>
<p class="normal">Node.js provides a comprehensive API to deal with files in the <code class="inlinecode">fs</code> module, and it has support for reading and writing streams, along with convenience features that read or write complete files, such as the <code class="inlinecode">readFileSync</code> function I used to read the contents of an HTML file.</p>
<p class="normal">The reason I have not described the API in any detail is that working directly with files within a web server project is incredibly dangerous and should be avoided whenever possible. There is a huge scope to create malicious requests whose paths <a id="_idIndexMarker339" class="calibre3"/>attempt to access files outside of the expected locations, for example. And, through personal experience, I have learned not to let clients create or modify files on the server under any circumstances. </p>
<p class="normal">I have worked on too many projects where malicious requests have been able to overwrite system files or simply overwhelm servers by writing so much data that storage space is exhausted.</p>
<p class="normal">The best way to deal with files is to use a well-tested package, rather than write custom code, and it is for this reason that I have not described the features of the <code class="inlinecode">fs</code> module.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">If you decide to ignore my warning, then you can find details of the <code class="inlinecode">fs</code> module and the features it provides at <a href="https://nodejs.org/dist/latest-v20.x/docs/api/fs.html" class="calibre3">https://nodejs.org/dist/latest-v20.x/docs/api/fs.html</a>.</p>
</div>
<p class="normal">The Express package has integrated support to serve requests for files. To prepare, add a file named <code class="inlinecode">client.js</code> to the <code class="inlinecode">static</code> folder with the content shown in <em class="italic">Listing 6.20</em>. </p>
<p class="packt_figref">Listing 6.20: The Contents of the client.js File in the static Folder</p>
<pre class="programlisting"><code class="hljs-code">document.addEventListener('DOMContentLoaded', function() {
    document.getElementById("btn").addEventListener("click", sendReq);
});
sendReq = async () =&gt; {
    let payload = [];
    for (let i = 0; i &lt; 5; i++) {
        payload.push({ id: i, message: `Payload Message: ${i}\n`});
    }
    const response = await fetch("/read", {
        method: "POST", body: JSON.stringify(payload),
        headers: {
            "Content-Type": "application/json"
        }
    })
    document.getElementById("msg").textContent = response.statusText;
    document.getElementById("body").textContent = await response.text();
}
</code></pre>
<p class="normal">This is the <a id="_idIndexMarker340" class="calibre3"/>same JavaScript code used in earlier examples but put into a separate file, which is the typical way of distributing JavaScript to clients. <em class="italic">Listing 6.21</em> updates the HTML file to link to the new JavaScript file, and it also includes the image file that was added to the project at the start of the chapter.</p>
<p class="packt_figref">Listing 6.21: Changing Content in the index.html File in the static Folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
       <strong class="screentext"> &lt;script src="img/client.js"&gt;&lt;/script&gt;</strong>
    &lt;/head&gt;
    &lt;body&gt;
       <strong class="screentext">&lt;img src="img/city.png"</strong>
<strong class="screentext">           style="width: 100%; display: block; margin-bottom: 2px;"&gt;</strong>
       &lt;button id="btn"&gt;Send Request&lt;/button&gt;
       &lt;div id="msg"&gt;&lt;/div&gt;
       &lt;div id="body"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">Having prepared the content, the next step is to configure Express to serve the files. Express comes with support for middleware components, which just means request handlers that can inspect and intercept all the HTTP requests the server receives. Middleware components are set up with the <code class="inlinecode">use</code> method, and <em class="italic">Listing 6.22</em> sets up the middleware component that Express provides to serve files.</p>
<p class="packt_figref">Listing 6.22: Adding Support for Static Files in the server.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
<strong class="screentext">//import { basicHandler } from "./handler";</strong>
import { readHandler } from "./readHandler";
const port = 5000;
const expressApp: Express = express();
<strong class="screentext">// expressApp.get("/favicon.ico", (req, resp) =&gt; {</strong>
<strong class="screentext">//     resp.statusCode = 404;</strong>
<strong class="screentext">//     resp.end();</strong>
<strong class="screentext">// });</strong>
<strong class="screentext">//expressApp.get("*", basicHandler);</strong>
expressApp.post("/read", readHandler);
<strong class="screentext">expressApp.use(express.static("static"));</strong>
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The <code class="inlinecode">express</code> object, <a id="_idIndexMarker341" class="calibre3"/>which is the default export from the <code class="inlinecode">express</code> module, defines a method named <code class="inlinecode">static</code> that creates the middleware component that serves static files. The argument to the <code class="inlinecode">static</code> method is the directory that contains the files, which is also named <code class="inlinecode">static</code>. The result is a request handler that can be registered with the <code class="inlinecode">Express.use</code> method.</p>
<p class="normal">The middleware component will attempt to match request URLs to files in the <code class="inlinecode">static</code> directory. The name of the directory that contains the files is omitted from the URLs, so a request for <code class="inlinecode">http://localhost:5000/client.js</code>, for example, will be handled by returning the contents of the <code class="inlinecode">client.js</code> file in the <code class="inlinecode">static</code> folder.</p>
<p class="normal">The <code class="inlinecode">static</code> method can accept a configuration object, but the default values are well-chosen and suit most projects, including using the <code class="inlinecode">index.html</code> as the default for requests.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">If you need to change the settings, you can see the options at <a href="https://expressjs.com/en/4x/api.html#express.static" class="calibre3">https://expressjs.com/en/4x/api.html#express.static</a>.</p>
</div>
<p class="normal">The <a id="_idIndexMarker342" class="calibre3"/>middleware component sets the response headers to help the client process the contents of the files that are used. This includes setting the <code class="inlinecode">Content-Length</code> header to specify the amount of data the file contains, and the <code class="inlinecode">Content-Type</code> header to specify the type of data.</p>
<p class="normal">Notice that I can remove some of the existing handlers from the example. The handler for <code class="inlinecode">favicon.ico</code> requests is no longer required because the new middleware will automatically generate “not found” responses when requests ask for files that don’t exist. The catch-all route is no longer required because the <code class="inlinecode">static</code> middleware responds to requests with the contents of the <code class="inlinecode">index.html</code> file. Use a browser to request <code class="inlinecode">http://localhost:5000</code>, and you will see the response shown in <em class="italic">Figure 6.9</em>, which also shows the data types that the browser has received.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_09.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.9: Using the Express static middleware</p>
<h3 class="heading2" id="_idParaDest-130">Serving files from client-side packages</h3>
<p class="normal1">One source<a id="_idIndexMarker343" class="calibre3"/> of static files is packages that are added to the Node.js project, but whose files are intended for consumption by browsers (or other HTTP clients). A good example is the Bootstrap CSS package, which contains CSS stylesheets and JavaScript files that are used to style the HTML content displayed by browsers.</p>
<p class="normal">If you are using a client-side framework such as Angular or React, these CSS and JavaScript files will be incorporated into a single compressed file as part of the project build process. </p>
<p class="normal">For projects that don’t use these frameworks, the simplest way to make the files available is to set up additional instances of the static file middleware. To prepare, run the command shown in <em class="italic">Listing 6.23</em> in the <code class="inlinecode">webapp</code> folder to add the Bootstrap package to the example project. </p>
<p class="packt_figref">Listing 6.23: Adding a Package to the Example Project</p>
<pre class="programlisting1"><code class="hljs-con">npm install bootstrap@5.3.2
</code></pre>
<p class="normal"><em class="italic">Listing 6.24</em> configures Express to serve files from the package directory.</p>
<p class="packt_figref">Listing 6.24. Adding Middleware in the server.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { readHandler } from "./readHandler";
const port = 5000;
const expressApp: Express = express();
expressApp.post("/read", readHandler);
expressApp.use(express.static("static"));
<strong class="screentext">expressApp.use(express.static("node_modules/bootstrap/dist"));</strong>
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">Some<a id="_idIndexMarker344" class="calibre3"/> knowledge of the packages you are using is required. In the case of the Bootstrap package, I know that the files used by clients are in the <code class="inlinecode">dist</code> folder, and so this is the folder that I specified when setting up the middleware clients. The final step is to add a reference to a Bootstrap stylesheet and apply the styles it contains, as shown in <em class="italic">Listing 6.25</em>.</p>
<p class="packt_figref">Listing 6.25. Adding a Stylesheet Reference in the index.html File in the static Folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="img/client.js"&gt;&lt;/script&gt;
       <strong class="screentext"> &lt;</strong><strong class="screentext">link href="css/bootstrap.min.css" rel="stylesheet" /&gt;</strong>
    &lt;/head&gt;
    &lt;body&gt;
       &lt;img src="img/city.png"
           style="width: 100%; display: block; margin-bottom: 2px;"&gt;
       <strong class="screentext">&lt;button id="btn" class="</strong><strong class="screentext">btn btn-primary my-2"&gt;Send Request&lt;/button&gt;</strong>
       &lt;div id="msg"&gt;&lt;/div&gt;
       &lt;div id="body"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The <code class="inlinecode">bootstrap.min.css</code> file contains the styles I want to use, which are applied by adding the <code class="inlinecode">button</code> element to classes. Use a browser to request <code class="inlinecode">http://localhost:5000</code>, and you will see the effect of the styles, as shown in <em class="italic">Figure 6.10</em>.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">See <a href="https://getbootstrap.com" class="calibre3">https://getbootstrap.com</a> for details of the features the Bootstrap package provides, some of which I use in later chapters. There are other CSS packages available if you can’t get along with Bootstrap. A popular alternative is Tailwind (<a href="https://tailwindcss.com" class="calibre3">https://tailwindcss.com</a>), but a quick web search will present you with a long list of alternatives to consider.</p>
</div>
<figure class="mediaobject"><img alt="" src="img/B21959_06_10.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.10: Using static content from a third-party package</p>
<h3 class="heading2" id="_idParaDest-131">Sending and downloading files</h3>
<p class="normal1">The <code class="inlinecode">Response</code> class, through <a id="_idIndexMarker345" class="calibre3"/>which Express<a id="_idIndexMarker346" class="calibre3"/> provides <code class="inlinecode">ServerResponse</code> enhancements, defines the methods described in <em class="italic">Table 6.9</em> to deal with files directly. </p>
<p class="packt_figref">Table 6.9: Useful Response Methods for Files </p>
<table class="table-container" id="table009-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">sendFile(path, config)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method sends the contents of the specified file. The response <code class="inlinecode">Content-Type</code> header is set based on the file extension.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">download(path)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method sends the contents of the specified file such that most browsers will prompt the user to save the file. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The <code class="inlinecode">sendFile</code> and <code class="inlinecode">download</code> methods are useful because they provide solutions to problems that cannot be solved using the <code class="inlinecode">static</code> middleware. <em class="italic">Listing 6.26</em> creates simple routes that use these methods.</p>
<p class="packt_figref">Listing 6.26: Adding Routes in the server.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
<strong class="screentext">import</strong><strong class="screentext"> express, {Express, Request, Response } from "express";</strong>
import { readHandler } from "./readHandler";
const port = 5000;
const expressApp: Express = express();
expressApp.post("/read", readHandler);
<strong class="screentext">expressApp.get("/sendcity", (req, resp</strong><strong class="screentext">) =&gt; {</strong>
<strong class="screentext">    resp.sendFile("city.png", { root: "static"});</strong>
<strong class="screentext">});</strong>
<strong class="screentext">expressApp.get("/downloadcity", (req: Request, resp: Response) =&gt; {</strong>
<strong class="screentext">    resp.</strong><strong class="screentext">download("static/city.png");</strong>
<strong class="screentext">});</strong>
expressApp.get("/json", (req: Request, resp: Response) =&gt; {
    resp.json("{name: Bob}");
});
   
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The <code class="inlinecode">sendFile</code> method<a id="_idIndexMarker347" class="calibre3"/> is useful when you need to <a id="_idIndexMarker348" class="calibre3"/>respond with the content of a file but the request path doesn’t contain the filename. The arguments are the name of the file and a configuration object, whose root property specifies the directory that contains the file. </p>
<p class="normal">The <code class="inlinecode">download</code> method sets the <code class="inlinecode">Content-Disposition</code> response header, which causes most <a id="_idIndexMarker349" class="calibre3"/>browsers to treat the file contents as a <a id="_idIndexMarker350" class="calibre3"/>download that should be saved. Use a browser to request <code class="inlinecode">http://localhost:5000/sendcity</code> and <code class="inlinecode">http://localhost:5000/downloadcity</code>. The first URL will cause the browser to display the image in the browser window. The second URL will prompt the user to save the file. Both responses are shown in <em class="italic">Figure 6.11</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_11.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.11: Using the file response enhancements</p>
<h2 class="heading1" id="_idParaDest-132">Automatically decoding and encoding JSON</h2>
<p class="normal1">The Express package<a id="_idIndexMarker351" class="calibre3"/> includes a middleware component that decodes JSON response bodies automatically, performing the same task as the stream <a id="_idIndexMarker352" class="calibre3"/>transformer I created earlier in the chapter. <em class="italic">Listing 6.27</em> enables this middleware by calling the <code class="inlinecode">json</code> method defined on the default export from the <code class="inlinecode">express</code> module. </p>
<p class="packt_figref">Listing 6.27: Enabling JSON Middleware in the server.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express, Request, Response } from "express";
import { readHandler } from "./readHandler";
const port = 5000;
const expressApp: Express = express();
<strong class="screentext">expressApp.use(express.json());</strong>
expressApp.post("/read", readHandler);
expressApp.get("/sendcity", (req, resp) =&gt; {
    resp.sendFile("city.png", { root: "static"});
});
expressApp.get("/downloadcity", (req: Request, resp: Response) =&gt; {
    resp.download("static/city.png");
});
expressApp.get("/json", (req: Request, resp: Response) =&gt; {
    resp.json("{name: Bob}");
});
   
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The <a id="_idIndexMarker353" class="calibre3"/>middleware component must be registered <a id="_idIndexMarker354" class="calibre3"/>before the routes that read response bodies so that JSON requests are parsed before they are matched to a handler.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The <code class="inlinecode">json</code> method can accept a configuration object that changes the way that JSON is parsed. The defaults are suitable for most projects, but see <a href="https://expressjs.com/en/4x/api.html#express.json" class="calibre3">https://expressjs.com/en/4x/api.html#express.json</a> for details of the available options.</p>
</div>
<p class="normal">The <code class="inlinecode">Request</code> class through which Express provides enhancements to the <code class="inlinecode">IncomingRequest</code> class defines a <code class="inlinecode">body</code> property, which is assigned the object created by the JSON middleware.</p>
<p class="normal">The <code class="inlinecode">Response</code> body, which provides <code class="inlinecode">ServerResponse</code> enhancements, defines the <code class="inlinecode">json</code> method, which <a id="_idIndexMarker355" class="calibre3"/>accepts an object that is serialized to JSON<a id="_idIndexMarker356" class="calibre3"/> and used as the response body.</p>
<p class="normal"><em class="italic">Listing 6.28</em> updates the handler to use the <code class="inlinecode">Request</code> class, disables the custom transformer, and sends a JSON response to the client.</p>
<p class="packt_figref">Listing 6.28: Using the JSON Object in the readHandler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">//import { Transform } from "stream";</strong>
<strong class="screentext">import { Request, Response } from "express";</strong>
export const readHandler = async (req: Request, resp: Response) =&gt; {   
    <strong class="screentext">if (req.headers["content-type"] == "application/json") {</strong>
<strong class="screentext">        const payload = req.body;</strong>
<strong class="screentext">        if (payload instanceof Array) {</strong>
<strong class="screentext"> </strong><strong class="screentext">//resp.write(`Received an array with ${payload.length} items`)</strong>
<strong class="screentext">            resp.json({arraySize: payload.length});</strong>
<strong class="screentext">        }  else {</strong>
<strong class="screentext">            resp.write("Did not receive an array");</strong>
        }
        resp.end();
    } else {
        req.pipe(resp);
    }
}
<strong class="screentext">// const createFromJsonTransform = () =&gt; new Transform({</strong>
<strong class="screentext">//     readableObjectMode: true,</strong>
<strong class="screentext">//     transform(data, encoding, callback) {</strong>
<strong class="screentext">//         callback(null, JSON.parse(data));</strong>
<strong class="screentext">//     }</strong>
<strong class="screentext">// });</strong>
</code></pre>
<p class="normal">Use a <a id="_idIndexMarker357" class="calibre3"/>web browser to request <code class="inlinecode">http://localhost:5000</code>, and click the <strong class="screentext">Send Request</strong> button. The response will confirm that the JSON <a id="_idIndexMarker358" class="calibre3"/>request body was parsed into a JavaScript array and the response was sent back as JSON as well, as shown in <em class="italic">Figure 6.12</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_06_12.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 6.12: Using the Express JSON middleware</p>
<h1 class="heading" id="_idParaDest-133">Summary</h1>
<p class="normal1">In this chapter, I described the API features that Node.js provides to read and write data, particularly when processing an HTTP request:</p>
<ul class="calibre4">
<li class="bulletlist">Streams are used as abstract representations of sources and destinations for data, including HTTP requests and responses.</li>
<li class="bulletlist1">Data is buffered when it is written to a stream, but it is a good idea to avoid excessive buffering because it can exhaust system resources.</li>
<li class="bulletlist1">Data can be read from a stream by handling events or using a <code class="inlinecode">for</code> loop.</li>
<li class="bulletlist1">Data can be piped from a readable stream to a writable stream.</li>
<li class="bulletlist1">Data can be transformed as it is piped and can be between JavaScript objects and strings/byte arrays.</li>
<li class="bulletlist1">Node.js provides an API to work with files, but third-party packages are the safest way to work with files in a web server project.</li>
<li class="bulletlist1">Third-party packages, such as Express, provide enhancements to the Node.js streams to perform common tasks, such as decoding JSON data.</li>
</ul>
<p class="normal">In the next chapter, I describe two aspects of web development in which Node.js works together with other components to deliver an application.</p>
</div>
</body></html>