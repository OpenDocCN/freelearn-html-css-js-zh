<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-64"><a id="_idTextAnchor063"/>4</h1>
<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Ensuring Framework Usability and Quality</h1>
<p>Continuing on the theme of framework architecture from the previous chapter, we will begin to look at the more architectural aspects of JavaScript frameworks. While technical architecture plays the core role and provides the guts of the framework, there are additional pieces of system architecture that engineers can add so that the project has a higher grade of usability and quality. As we mainly specialize in JavaScript projects, we will find a variety of tools that help us focus on quality. These tools are often built with JavaScript, but they also integrate with other systems, making it easier for those familiar with the language to cherish the benefits.</p>
<p>Supporting the technical usability of a framework is a series of development quality and usability patterns. These include the additional infrastructure that is used as part of framework development and framework usage. Generally, we look at these components as tools that improve our framework’s life cycle. First are the techniques that ensure the framework’s usability, for framework authors, contributors, and users. Second is the supporting infrastructure, such as documentation and many types of tests.</p>
<p>We are going to explore these important topics in this chapter, focusing on development support patterns that help us build frameworks. Just like the technical architectures, these skills and tools can be applied while building any type of JavaScript framework. This chapter’s topics include exploring the following:</p>
<ul>
<li><strong class="bold">Framework documentation</strong> – a set of written or generated materials that provide information on framework features and how to utilize the framework for new projects. To learn from the best, in this section, we will take a look at how other JavaScript frameworks produce public and internal documentation.</li>
<li><strong class="bold">Variety of framework tests</strong> – used extensively to check the correctness of the framework using different types of tooling, such as unit tests, end-to-end tests, and more. Focusing further on JavaScript projects, this section explores the testing abilities of framework projects.</li>
<li><strong class="bold">Development tooling</strong> – external tools that help with the development process. This includes additional configurations and tooling that assist with the internal workflow of the framework, such as continuous integration, source control enhancements, and development tweaks. In the upcoming sections, we will see what type of developer tools are used by JavaScript projects such as Vue.js and Nest.js.</li>
<li><strong class="bold">Generic framework structure</strong> – understanding how we can create our own framework structure based on lessons from other open source framework architectures and patterns that we have seen in the book so far. This will give us a good outline of how authors organize the JavaScript framework code in large projects.</li>
</ul>
<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Technical requirements</h1>
<p>You can find the resources for this chapter in the book’s repository: <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>. To make it easier to interact with the practical portion of this chapter, use the <code>chapter4</code> directory. The interactive script will make it easier for you to run the samples from this chapter. It works as follows from your command prompt or terminal window on your machine:</p>
<pre class="console">
&gt; npm install
...
&gt; npm start
Welcome to Chapter 4!
? Select the demo to run: (Use arrow keys)
&gt; Next.js with Tailwind CSS
  Practical Docus.dev example</pre>
<p>As with other chapters, the code in the repository is designed to work in operating systems that can run the Node.js runtime, such as Windows, macOS, and most variants of Linux.</p>
<p class="callout-heading">JavaScript testing refresher</p>
<p class="callout">In this chapter, we will be discussing topics related to JavaScript testing. If you require a refresher or additional resources to give you in-depth information on various types of testing techniques, then check out additional Packt publications at <a href="http://subscription.packtpub.com/search?query=javascript+testing">subscription.packtpub.com/search?query=javascript+testing</a>.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Development support</h1>
<p>Let's dive into a series <a id="_idIndexMarker337"/>of techniques and tools that enable developers to build quality frameworks focused on usability and ease of use. Learning and utilizing these types of development support strategies will help us with our framework development, making our projects more usable in internal (work projects) or public contexts (open source/publicly published projects).</p>
<p>Some of these development methodologies and skills are not specific to JavaScript framework development; they are used across many JavaScript and web application development undertakings. However, in the context of framework development, the approach to these tooling and usability patterns is different from a regular application project. For example, a framework might have a particular expanded set of tests that ensures that new features and changes do not break the existing applications that use it. This type of extended testing is a particular case that only applies to framework projects and not application projects.</p>
<p>In addition, a framework may focus more on technical design benchmarking and compatibility testing, supporting a variety of use cases. A lot of this comes from the requirements of the framework consumers and stakeholders.</p>
<p>In the <em class="italic">Core APIs</em> section of <a href="B19014_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, we saw examples of interfaces and features, such as <em class="italic">dependency injection</em>. These<a id="_idIndexMarker338"/> interfaces are designed to empower framework users with their flexibility and feature set. However, these interfaces need to be documented to be accessible to the developers. Otherwise, even if the framework interface is simple enough or powerful but not discoverable or explained, it probably won’t be utilized by users. These interfaces also need to be thoroughly tested, in isolation and as part of a greater system. Finally, we need various types of infrastructure to enable this process of testing, maintenance, and documentation. Luckily, there are many existing solutions that make framework development and maintenance much easier through the tools provided by the greater JavaScript community and external software services.</p>
<p>Let us focus on the three categories of usability and quality patterns that will help us build a great framework:</p>
<ul>
<li><strong class="bold">Documentation</strong> – a collection <a id="_idIndexMarker339"/>of materials targeting different framework stakeholders. These could be generated or written by the framework’s developers. This reference can also be internal, showcasing the design decisions and the technical architecture.</li>
<li><strong class="bold">Framework testing</strong> – the testing infrastructure is crucial to development, feature set, and maintenance as they ensure framework quality. This includes using a variety of tools, such as unit, end-to-end, and integration testing.</li>
<li><strong class="bold">Development tooling</strong> – the supplementary tools that improve the internal workflow of developers. The tools incorporate technologies that simplify working with the project. They do this by introducing processes such as source control improvements, continuous integration, and others.</li>
</ul>
<p>Each category of <a id="_idIndexMarker340"/>these patterns has several subtypes. In most cases, multiple existing frameworks rely on these types of techniques in their projects. We are going to get into an in-depth look at those patterns in this chapter.</p>
<p><em class="italic">Figure 4</em><em class="italic">.1</em> presents a detailed outlook at an assortment of documentation kinds, types of tests, and additional tooling that is used by JavaScript frameworks today:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Documentation</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Framework testing</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Development tooling</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Public API</p>
</td>
<td class="No-Table-Style">
<p>Unit tests</p>
</td>
<td class="No-Table-Style">
<p>Continuous integration</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Examples</p>
</td>
<td class="No-Table-Style">
<p>Integration tests</p>
</td>
<td class="No-Table-Style">
<p>Source control</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Internal documentation</p>
</td>
<td class="No-Table-Style">
<p>End-to-end tests</p>
</td>
<td class="No-Table-Style">
<p>Package configuration</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Benchmarks</p>
</td>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Subtypes of tools and patterns utilized in frameworks</p>
<p>We begin by looking<a id="_idIndexMarker341"/> at the documentation, something that our framework cannot survive without.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Documentation</h2>
<p>Writing up documentation is <a id="_idIndexMarker342"/>one of the most crucial things for framework adaptation and usability. The reference materials produced can enable developers to properly utilize the provided tools. Framework developers spent a lot of time writing and tweaking their documentation, focusing on providing the most detailed and simple explanations of the components of the framework function. With a typical web application, you would already have some existing documentation on how to run it and configure parts of it. However, while developing a framework, a lot more documentation is required, consisting of API methods, learning materials, and other solutions to make it easier to utilize the framework to its maximum potential. Today, most frameworks invest in showcasing the framework’s API methods, writing up articles that help developers learn the framework from scratch, creating interactive tutorials, and providing detailed examples demonstrating how a framework can approach the challenges of a particular feature set.</p>
<p>A great role model example of documentation comes from the creators of React – with the recently launched new learning platform at <a href="https://react.dev">https://react.dev</a>, which encourages the use of the library across the ecosystem and within frameworks. To help encourage adaption and successful knowledge transfer, their focus was on creating a learning environment alongside the API reference.</p>
<p>As you begin to build out your framework, keep in mind that providing a list of programmatic APIs is not enough. In <em class="italic">Figure 4</em><em class="italic">.2</em>, we can see excellent examples of valuable reference material:</p>
<div><div><img alt="Figure 4.2: Learning React documentation" src="img/Figure_4.2_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: Learning React documentation</p>
<p>Even though React is a library, there is still much we can learn about how the documentation is structured for this project. It consists of several vital items. The installation guide comes first and foremost; this can consist of package installation guidelines and the ability to scaffold a new project using a framework. Then, the existing or potential framework user is presented with a tutorial and an explanation of the thinking model behind the tool. Lastly, a series of articles explains the most important topics that a developer needs to know about the tool they are about to use.</p>
<p>Your framework should aspire to a similar form of learning documentation. Even in cases of internal <a id="_idIndexMarker343"/>framework development, you or your team should still document and create learning reference material to encourage proper usage of your framework procedures. This kind of approach leads us to the next important part of documentation – the API.</p>
<h3>Public API</h3>
<p>In <a href="B19014_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, as part of <a id="_idIndexMarker344"/>exploring framework packages, we have examined the framework entry points. Documentation serves as another type of entry point; developers interact with the framework by utilizing the provided documentation. Primarily, this interaction can be facilitated by<a id="_idIndexMarker345"/> the <strong class="bold">public API</strong> or <strong class="bold">API reference</strong>, created<a id="_idIndexMarker346"/> from the framework’s code and its interfaces.</p>
<p>Every framework we have seen in this book has an API reference published alongside the framework. This type of API reference can be statically or dynamically generated. In <em class="italic">Figure 4</em><em class="italic">.3</em>, we see an example of such documentation; the Vue.js docs are generated from the <a href="http://github.com/vuejs/docs">github.com/vuejs/docs</a> repository <a id="_idIndexMarker347"/>and assembled using a static site generator:</p>
<div><div><img alt="Figure 4.3: Part of the Vue.js API reference" src="img/Figure_4.3_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: Part of the Vue.js API reference</p>
<p>There are many open source projects that can make it easier for you to generate and maintain documentation files:</p>
<ul>
<li><strong class="bold">Docusaurus</strong> (<a href="http://docusaurus.io">docusaurus.io</a>) – a static<a id="_idIndexMarker348"/> documentation <a id="_idIndexMarker349"/>site generator. Specifically for frameworks, it provides features such as search, versioning according to framework releases, and more.</li>
<li><strong class="bold">MarkDoc</strong> (<a href="http://markdoc.dev">markdoc.dev</a>) – another open<a id="_idIndexMarker350"/> source for custom documentation sites. It is extensible and aims to provide the best documentation authoring and publishing experience.</li>
<li><strong class="bold">Docus</strong> (<a href="http://docus.dev">docus.dev</a>) – a documentation<a id="_idIndexMarker351"/> generator that utilizes familiar to us frameworks such as Nuxt.js and Vue.js. Supports Markdown syntax and zero-configuration deploys across many services.</li>
<li><strong class="bold">TypeDoc</strong> (<a href="http://typedoc.org">typedoc.org</a>) – a documentation <a id="_idIndexMarker352"/>generator for TypeScript source code. Creates static sites based on the comments inside of the TypeScript files. The tool also has the ability to output the parsed source as a JSON file. A similar tool, <strong class="bold">JSDoc</strong> (<a href="http://jsdoc.app">jsdoc.app</a>), is also <a id="_idIndexMarker353"/>available for pure JavaScript projects.</li>
<li><strong class="bold">TSDoc</strong> (<a href="http://tsdoc.org">tsdoc.org</a>) – a similar <a id="_idIndexMarker354"/>project to TypeDoc, backed by Microsoft. It focuses on standardization efforts around documentation generators by providing an engine<a id="_idIndexMarker355"/> for other tools to generate comment-based documentation. Has integrations with several other projects, such as ESLint and Visual Studio Code.</li>
</ul>
<p>Using one of the tools<a id="_idIndexMarker356"/> we just listed might be going overboard if your framework is just starting up, but given that documentation is critically necessary to the framework’s usability, you need to make sure to make it easier for yourself to maintain readable and clean documentation. You can also draw inspiration from a larger and more complex framework such as Angular. The project already provides the in-depth API reference (<a href="http://angular.io/api">angular.io/api</a>), but in addition, the authors also deliver an exhaustive reference to concepts, error types, and diagnostics. All of these can be found in the <strong class="bold">guides</strong> section (e.g., <a href="http://angular.io/guide/file-structure">angular.io/guide/file-structure</a>) of the Angular website.</p>
<p>As you develop your framework, you will likely introduce drastic breaking changes as you go along from version to version. If you are in a context where you already have existing framework consumers, then you should spend the time creating a migration reference document. Good migration guidelines help your stakeholders keep up to date with the changes and use the latest fixes. Some examples of good migration guides include the Electron <em class="italic">Breaking Changes</em> guides (<a href="http://electronjs.org/docs/latest/breaking-changes">electronjs.org/docs/latest/breaking-changes</a>) and the Express migration overview (<a href="http://expressjs.com/en/guide/migrating-5.html">expressjs.com/en/guide/migrating-5.html</a>).</p>
<p class="callout-heading">Practical use of documentation tools</p>
<p class="callout">The repository directory for this chapter has an example of one of the documentation tools in action. In this case, the example uses Docus, with the Nuxt.js framework powering the behind-the-scenes infrastructure of the project. You can try this out on your own computer by running the interactive script in the <code>chapter4</code> directory or manually navigating to <code>practical-docus</code> and running <code>npm install</code>, and then <code>npm run dev</code>. The documentation site will run on port <code>3001</code> and you can live edit and interact with the docs tooling by editing files in the directory.</p>
<p>Basic documentation can improve your framework experience greatly, but there is more you can do to make adaptation more effortless. In the next section, we will focus on the importance of providing<a id="_idIndexMarker357"/> examples of framework usage. These meaningful resources can highlight the strong elements of your framework and ease of integration with other systems.</p>
<h3>Examples</h3>
<p>Providing examples<a id="_idIndexMarker358"/> drastically helps reduce one of the most challenging aspects of adapting frameworks – the learning curve. To encourage adoption and reduce friction, framework developers invest time to produce examples of framework usage. These could be included as part of the reference documentation or provided alongside the framework source code. If you are working on an internal framework, investing in examples is still beneficial. If your project will be used by many internal teams or new hires, maintaining a base case of examples can reduce the number of questions and confusion.</p>
<p>As part of my experience contributing to JavaScript testing frameworks, one of the most effective development investments was my focus on creating integration guides and developing examples. This was particularly important for a testing framework project, as the availability of these resources made it easier for developers to add the testing framework into their systems. It also showcased the maturity of the project, showing that it is capable of working with many different systems. It’s not just my experience, almost all JavaScript frameworks concentrate on providing instantly-runnable samples. These projects utilize tools<a id="_idIndexMarker359"/> such as <strong class="bold">StackBlitz</strong> (<a href="http://stackblitz.com">stackblitz.com</a>) and <strong class="bold">CodePen</strong> (<a href="http://codepen.io">codepen.io</a>) to enable<a id="_idIndexMarker360"/> potential developers to get into the framework environment within seconds. For example, navigating to <a href="http://stackblitz.com/fork/angular">stackblitz.com/fork/angular</a> presents you with a ready-to-go Angular framework application.</p>
<p>For more inspiration, Next.js takes the approach to examples thoughtfully; the framework maintains over 50 samples at <a href="http://github.com/vercel/next.js/tree/canary/examples">github.com/vercel/next.js/tree/canary/examples</a>. These include showcases of GraphQL support, CMS and blog use cases, integrations with other tooling, and deployment targets. To quickly enable users to run the samples, the <code>create-next-app</code> CLI supports the <code>example</code> argument to scaffold based on the sample:</p>
<pre class="source-code">
npx create-next-app --example with-tailwindcss-emotion next-example-app</pre>
<p>When developing examples for your framework, keep in mind that you will later need to maintain all the examples you create, just like the documentation reference. If some example code gets out of date and no longer functions as it should, then it will cause more burden for <a id="_idIndexMarker361"/>you as the framework maintainer.</p>
<p class="callout-heading">Practical example with Next.js</p>
<p class="callout">You can check out this<a id="_idIndexMarker362"/> example in the <code>chapter4</code> directory in the <code>next-example-app</code> directory. Follow the <code>README.md</code> file for guidelines on setting up the Firebase project. The project requires Firebase project credentials to run properly. To initialize the Next.js app, run <code>npm install</code> and then <code>npm run dev</code>. You can also use the interactive script directly from the <code>chapter4</code> directory.</p>
<p class="callout">To open the application, use the localhost URL, which will likely be <code>http://localhost:3000</code>. Follow the terminal output for instructions. To edit the files, open the <code>next-example-app</code> project directory with Visual Studio Code.</p>
<p>Depending on the nature of your framework, you can use the JavaScript runtime tools to create a playground environment for your framework. In <em class="italic">Figure 4</em><em class="italic">.4</em>, we see a sample of the Vue.js component playground; this kind of environment takes the idea of examples further:</p>
<div><div><img alt="Figure 4.4: Vue.js single-file component playground" src="img/Figure_4.4_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Vue.js single-file component playground</p>
<p>With every “playground” example, you can teach the framework using the most basic features to more advanced use cases.</p>
<p>As you are starting up with your own framework, it is better to include your examples as part of your framework repository. To lessen the maintenance burden, make sure you execute your examples as part of your testing infrastructure (more on that later in <a href="B19014_10.xhtml#_idTextAnchor173"><em class="italic">Chapter 10</em></a>, related to<a id="_idIndexMarker363"/> framework maintenance). If you are working on the framework alone or with a small team, the usage of included examples in your framework can greatly enhance the development process, helping you iterate quickly.</p>
<h3>Internal documentation</h3>
<p>The internal <a id="_idIndexMarker364"/>documentation is all about helping the framework authors to continue developing the framework. Even if you are the only author of the framework, it is still useful to maintain internal documentation, even for your own sake. This way, you can look back on the code and design decisions from the past and make it easier to make updates to your project. Primarily, this type of documentation should not be consumed by the framework users or stakeholders. However, it can still be useful to expose these materials for debugging use cases.</p>
<p>The internal documentation can potentially include detailed interfaces of internal modules. It could potentially describe the design principles of the internal implementation. For instance, the Nuxt.js framework combines both public-facing and internal documentation on its reference pages. The framework’s renderer, builders, generator, and other classes are described in the Internals Glossary (<a href="http://github.com/nuxt/nuxtjs.org/tree/main/content/en/docs/6.internals-glossary">github.com/nuxt/nuxtjs.org/tree/main/content/en/docs/6.internals-glossary</a>). For instance, Nuxt provides its own module system (<a href="http://nuxtjs.org/docs/directory-structure/modules">nuxtjs.org/docs/directory-structure/modules</a>) to extend the framework functionality, and the internals of that feature are supported by the <code>ModuleContainer</code> class. This class is part of the framework’s internals and should still be documented. It also enables framework plugin development for external developers to understand and extend the framework.</p>
<p>Another example of using this type of documentation for the framework’s benefit can be seen in Vue.js. The framework utilizes the TSDoc tooling internally to ensure the specification of its functions, such as the shared utility methods.</p>
<p>The following code taken from the developer tools repository of the framework (<a href="http://github.com/vuejs/devtools/blob/main/packages/shared-utils/src/util.ts">github.com/vuejs/devtools/blob/main/packages/shared-utils/src/util.ts</a>) is a simpler example of documentation annotations that are available to framework developers while browsing the file, can later be exported to an external document, or can be previewed by an IDE <a id="_idIndexMarker365"/>while accessing this helper function:</p>
<pre class="source-code">
/**
 * Compares two values
 * @param {*} value Mixed type value that will be cast to string
 * @param {string} searchTerm Search string
 * @returns {boolean} Search match
 */
function compare (value, searchTerm) {
  return ('' + value).toLowerCase().indexOf(searchTerm) !== -1
}</pre>
<p><strong class="bold">Contribution guidelines</strong> are also<a id="_idIndexMarker366"/> part of this type of internal documentation. For both open and closed frameworks, you will potentially have someone who wants to make changes or contribute to the framework, either helping you fix issues or introducing new features. Contribution documentation helps enable this, providing the steps to quickly write and test new framework changes. As part of the contribution instruction, it is often important to list several important pieces of information:</p>
<ul>
<li>First, how to modify the framework, build it, and test it. This includes pointers to all the relevant scripts that make the development process more approachable.</li>
<li>Second, how to successfully write a patch, both in open source and internal environments. This includes following the source control guidelines and commit history rules.</li>
<li>To make framework contributions easier, this type of documentation should mention the coding rules around public and internal APIs, file formatting, and other potential style guides.</li>
</ul>
<p>To provide some<a id="_idIndexMarker367"/> examples, Ember.js has a page on their contribution guidelines at <a href="http://guides.emberjs.com/release/contributing">guides.emberjs.com/release/contributing</a>, and other frameworks such as Angular include a <code>CONTRIBUTING.md</code> file in their repositories at <a href="http://github.com/angular/angular/blob/main/CONTRIBUTING.md">github.com/angular/angular/blob/main/CONTRIBUTING.md</a>.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Framework testing</h2>
<p>Just like any software<a id="_idIndexMarker368"/> project, frameworks require a number of tests to ensure that the framework is functioning as intended. In the framework context, you will find much in-depth testing focused on correctness, performance, and special framework use cases that need to be handled for all possible usage scenarios. We have seen examples of testing frameworks in the <em class="italic">Testing frameworks</em> section of <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>; those can be used from within our frameworks to simplify the testing workflow. In this section, we are going to look at what techniques JavaScript frameworks use internally to ensure that the final framework product is of high quality.</p>
<h3>Unit tests</h3>
<p>Just like most<a id="_idIndexMarker369"/> software projects, frameworks also include unit tests for their interfaces. They utilize a testing framework similar to the ones we have seen listed in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. Often, you will see these types of tests called “specs” as well, meaning they are <em class="italic">specification tests</em>. This means that, given a certain component of a framework, there is a technical specification that it should adhere to. In the framework context, comprehensive tests help with refactoring major components much more quickly. Open source frameworks also benefit from a good unit testing suite when receiving external code contributions. It is much easier to review and be confident in the code change when there is a vast collection of existing tests and new tests being added as part of the change.</p>
<p>Depending on the type of JavaScript framework, the testing environment and testing challenges can be different. In frameworks that target the browser, the unit testing requires mocking out browser and web APIs. For instance, Angular introduces several internal testing interfaces to simplify working with components that are injected into the DOM. Angular’s “change detection” and other DOM-related functionality use these testing interfaces to abstract away working with the <code>document</code> object instance directly. For example, Angular developers create several test wrappers to make it easier to attach the framework’s<a id="_idIndexMarker370"/> node tree to the DOM body, as seen in this function:</p>
<pre class="source-code">
export function withBody&lt;T extends Function&gt;(html: string, blockFn: T): T {
 return wrapTestFn(() =&gt; document.body, html, blockFn);
}</pre>
<p>The <code>change_detection_spec.ts</code> file relies on the <code>withBody</code> helper from the test utilities; these utilities rely on executing many frameworks’ tests in an environment where a <code>document</code> object is present.</p>
<p>In backend frameworks, projects may choose to mock out or create test-only classes based on the existing interfaces. For instance, Nest.js has defined a <code>NoopHttpAdapter</code> class (<a href="https://github.com/nestjs/nest/blob/master/packages/core/test/utils/noop-adapter.spec.ts">https://github.com/nestjs/nest/blob/master/packages/core/test/utils/noop-adapter.spec.ts</a>) that extends <code>AbstractHttpAdapter</code>, which we have seen before in the <em class="italic">Backend abstraction</em> section of <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>. The following code shows how the testing adapter is structured to make it easier to use it in framework tests:</p>
<pre class="source-code">
export class NoopHttpAdapter extends AbstractHttpAdapter {
  constructor(instance: any) {
    super(instance);
  }
  close(): any {}
  initHttpServer(options: any): any {}
  // …
  }
}</pre>
<p>This <code>HttpAdapter</code> TypeScript class is used within the framework’s specification testing to ensure that the main <code>Application</code>, <code>Routing</code>, and <code>Middleware</code> classes function as they should.</p>
<p>While developing your JavaScript framework, ensure to unit test every new component or interface that you add. This process will help you in several ways:</p>
<ul>
<li>It will increase the code quality and help you organize your framework such that its components fit better together.</li>
<li>The framework development process is full of constant refactoring or changes. Your unit testing suite will grow as your framework grows and will increase your confidence in the changes as you code along.</li>
</ul>
<p>Finally, ensure that your unit testing suite runs efficiently. For example, Vue.js uses the Vitest test runner. Vue has over 2,500 unit tests, which execute in about 20 seconds. The unit tests of your <a id="_idIndexMarker371"/>framework should run as fast as possible to provide you with a blazing-fast feedback loop while you are busy developing new framework features.</p>
<h3>Integration tests</h3>
<p>Integration tests<a id="_idIndexMarker372"/> are created with the purpose of testing how multiple interfaces or components of the framework fit together. These tests can catch issues that are not detected by unit/specification testing due to the fact that those types of tests are designed to test the component in isolation. Integration tests simulate the interaction between the components, making sure that the functionality fits well together.</p>
<p>In the context of frameworks, the internal core architecture has to fit together. This means the integration tests would be verifying that behavior. For instance, a good integration test for a full stack framework would be ensuring that a component is rendered when a particular <code>router</code> route is called to. This kind of test ensures that all those components are behaving nicely together.</p>
<p>In addition, frameworks usually have to integrate with other systems. This means developers also need to produce integration tests between a framework and that external system. For example, the Gatsby framework has integration tests (<a href="http://github.com/gatsbyjs/gatsby/tree/master/integration-tests">github.com/gatsbyjs/gatsby/tree/master/integration-tests</a>) for its static-site rendering, command-line interface, and caching infrastructure. These tests verify the framework’s features. However, Gatsby also includes integration tests to verify that it works with other technologies. The framework has an integration test to verify compatibility with the JavaScript ESM module standard.</p>
<p>Writing integration tests can be challenging, as you have to verify that all sorts of interface combinations are working faultlessly together. Though it is an essential part of the framework <a id="_idIndexMarker373"/>development process, this type of testing can ultimately be much more beneficial than unit testing if you are in a rush to deliver your new framework project.</p>
<h3>End-to-end tests</h3>
<p>End-to-end tests<a id="_idIndexMarker374"/> evaluate how the framework is functioning as a system overall. Usually, these tests simulate almost real user interaction. For a frontend framework, creating these tests usually means configuring one of the end-to-end testing frameworks. For server-side frameworks, the end-to-end tests usually simulate real requests to a server that is powered by the framework. Similar to its set of integration tests, Gatsby also maintains a suite<a id="_idIndexMarker375"/> of <code>transition</code>, <code>grid</code>, and <code>tree-view</code> interfaces. These can be found at <a href="http://github.com/vuejs/core/tree/main/packages/vue/__tests__/e2e">github.com/vuejs/core/tree/main/packages/vue/__tests__/e2e</a>. These tests use Puppeteer to execute commands in a headless Chrome browser, thus simulating real browser and user behavior.</p>
<p>An extensive E2E test suite can support the development of your framework in several ways:</p>
<ul>
<li>Catch regressions of the whole system, such as simulating common framework commands and expected functionality.</li>
<li>Confirm that all components of your framework can work together as you make changes and develop new features.</li>
<li>Integrate performance trials into E2E tests to be able to detect the slow performance of your framework.</li>
<li>Ensure that the framework works correctly with external systems. These systems can include different types of web browsers or different backend environments.</li>
</ul>
<p>Another important<a id="_idIndexMarker376"/> form of testing for frameworks that is relevant in many projects today is benchmarking.</p>
<h3>Benchmarks</h3>
<p>The process of <a id="_idIndexMarker377"/>benchmarking runs a set of assessments and trials on a particular scenario of your framework. These benchmark tests can be written by framework authors or an external party. For the purposes of framework building, we are focusing on the former, where a framework includes a series of benchmarks as part of its internal testing. Frameworks can potentially compete on their benchmarking scores for tasks such as rendering a particular component configuration, or, in the case of backend frameworks, the time it takes to process a large number of requests.</p>
<p>For JavaScript frameworks, it is essential to benchmark the performance of the code in the runtime. In the browser runtime, the benchmarks are focused on efficient rendering and processing large inputs. In the full stack Next.js framework, the authors include several benchmarking scripts to test various features (found at <a href="http://github.com/vercel/next.js/blob/canary/bench">github.com/vercel/next.js/blob/canary/bench</a>). When you are developing benchmarks of your own, keep in mind that you probably do not need any complex tooling. Instead, you can rely on built-in methods of the runtime – in this case, in Node.js.</p>
<p><em class="italic">Figure 4</em><em class="italic">.5</em> shows one of the simpler benchmarking scripts <a href="http://github.com/vercel/next.js/blob/canary/bench/recursive-copy/run.js">github.com/vercel/next.js/blob/canary/bench/recursive-copy/run.js</a>):</p>
<div><div><img alt="Figure 4.5: Benchmarking in the Next.js repository" src="img/Figure_4.5_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Benchmarking in the Next.js repository</p>
<p>In <em class="italic">Figure 4</em><em class="italic">.5</em>, the main function provides a recursive copy implementation to the test. Executing the <code>run</code> function with two different implementations provides us with comparison results of these two functions.</p>
<p>For backend frameworks, factors such as memory utilization, request throughput, and latency are often benchmarked. For inspiration, Nest.js maintains a set of benchmarking tools to compare the performance of the HTTP servers provided by the framework at <a href="http://github.com/nestjs/nest/tree/master/benchmarks">github.com/nestjs/nest/tree/master/benchmarks</a>. In other types of frameworks, such as application development (Electron) and testing frameworks, the benchmarks are also focused on <a id="_idIndexMarker378"/>performance. As we saw in the <em class="italic">Framework testing</em> section earlier in this chapter, the testing framework itself needs to execute the test suites as efficiently as possible.</p>
<p>You, as a framework developer, should focus on setting up benchmarks for two use cases:</p>
<ul>
<li>First, the benchmark for the public interfaces your framework exposes. These would allow you to gauge how long it takes for your framework to complete the tasks.</li>
<li>Second, you want to look into the micro-benchmarks of the framework internals. These internal benchmarks help optimize particular parts of the framework’s core, enabling speed improvements in the internal functions.</li>
</ul>
<p>As you further develop your project, keep an eye on measurements of your benchmarks, ensuring that you do <a id="_idIndexMarker379"/>not regress the speed of your framework.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Development tooling</h2>
<p>The framework development<a id="_idIndexMarker380"/> and the release process can greatly benefit from the inclusion of additional tools that elevate the quality and usability of the framework project. These workflows could be applied to various aspects of the framework, such as dependency management, testing, editor configuration, formatting, and more. We already saw a similar approach of relying on additional scripts and tooling in the <em class="italic">Binaries and scripts</em> section of <a href="B19014_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>. Additional tooling that can improve our framework’s development life cycle includes the introduction of continuous integration steps, improving the source control, and the addition of package-level utilities.</p>
<h3>Continuous integration</h3>
<p>As part of the development cycle, just like many web application projects, frameworks configure <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) steps to<a id="_idIndexMarker381"/> test the code changes and new releases. These CI systems run tests of all types, such as the ones mentioned in the <em class="italic">Framework testing</em> section of this chapter. Every change committed using a version control system has to pass the existing test suite. This ensures that the changes do not introduce breaking changes or bugs. Besides running the tests, CI runs other types of analysis, such as formatting checks, linting, and more. These ensure consistency, usability, and quality.</p>
<p>If we focus on framework development, there are a few special uses for CI. It ensures that the framework works properly in different JavaScript environments. For a frontend framework, this means executing tests in a variety of browsers on different platforms. Browser support testing goes both ways – new features must work in older browser versions, and new browsers should not break any of the existing framework features. Node.js and Deno frameworks that run on the backend keep track of newer runtime versions, following the <a href="http://github.com/nodejs/release">github.com/nodejs/release</a> release schedule. Running these compatibility checks in CI is the best solution; the CI platforms allow to quickly spin up different versions of environments and parallelize the test execution in those environments.</p>
<p>Besides the focus on testing in various environments, the CI step can run a series of tests of projects that depend on your framework. For example, it can generate and run a sample application or an external script with the new framework changes applied. This way, it can check whether the changes are compatible.</p>
<p>Depending on the framework CI configuration, the integration story may be different. In <em class="italic">Figure 4</em><em class="italic">.6</em>, we see four successful checks; this is part of the Vue.js CI pipeline:</p>
<div><div><img alt="Figure 4.6: Vue.js reporting its CI status" src="img/Figure_4.6_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Vue.js reporting its CI status</p>
<p>In the case of Angular, there are over 20 checks in the CI pipeline before a code change can be merged into the repository. The reason for a growing number of integration steps is the execution tasks that are not tests. These could be formatting, spelling, and JavaScript code usability checks.</p>
<p>The CI steps can vary in complexity and type, and they can also contribute to the release process of your framework. No matter what type of framework you are working on, internal or public, it <a id="_idIndexMarker382"/>is highly advised to configure a CI step as part of your framework development. This approach will ensure the quality of the code and help you maintain efficiency in your framework development.</p>
<h3>Source control</h3>
<p>Using source control for <a id="_idIndexMarker383"/>frameworks is similar to using it for other application projects. Nevertheless, JavaScript frameworks rely on source control tooling for tagging framework releases and keeping track of feature development branches. The use of source control in this context is a bit more in-depth. For instance, a framework author might need to write patches for an older version of the framework, which means jumping back to an older Git tag to introduce that change. In many cases, large framework refactoring also takes place in a temporary Git branch.</p>
<p>Most JavaScript frameworks also configure supplementary source control scripts that improve the workflow as new features and changes get developed. In <em class="italic">Figure 4</em><em class="italic">.7</em>, we see the Nest framework using the Git pre-commit hook to execute JavaScript linting scripts:</p>
<div><div><img alt="Figure 4.7: The pre-commit hook configuration" src="img/Figure_4.7_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: The pre-commit hook configuration</p>
<p>The pre-commit hook, in this case (<em class="italic">Figure 4</em><em class="italic">.7</em>), enforces the code quality standards before the changes are committed. The step to configure this kind of behavior is simplified using a JavaScript module <a id="_idIndexMarker384"/>called <strong class="bold">Husky</strong> (<a href="http://typicode.github.io/husky">typicode.github.io/husky</a>). You will find this pattern in a lot of the frameworks, as this is a handy addition to make the development process much more friendly.</p>
<p>At this point, it is a given that you will use source control for your new framework. However, you can<a id="_idIndexMarker385"/> invest in additional tooling by learning from some of the existing frameworks that we’ve seen in this book to improve your coding workflow.</p>
<h3>Package configuration</h3>
<p>The <code>package.json</code> file <a id="_idIndexMarker386"/>and the additional files in the root of the framework directory define the package configurations of the project. The number of such configurations may vary depending on the types of tools you use in your framework.</p>
<p>The package configuration of Nest.js consists of many tools, such as ESLint, Git, npm, and Gulp, to name a few. Similar to the Nest.js configuration seen in <em class="italic">Figure 4</em><em class="italic">.8</em>, the <code>package.json</code> file will be the development entry point of your framework:</p>
<div><div><img alt="Figure 4.8: Package configurations of Nest.js" src="img/Figure_4.8_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: Package configurations of Nest.js</p>
<p>The <code>package.json</code> file consists of the information about your framework, its dependencies, and auxiliary configuration used by other tools. For example, the Nest.js package file (<a href="http://github.com/nestjs/nest/blob/master/package.json">github.com/nestjs/nest/blob/master/package.json</a>) stores configuration for the <code>nyc</code> code coverage tooling, the <code>mocha</code> test runner configuration, and commands for the changelog tooling. Besides those configuration entries, the package file has the <code>scripts</code> object. This object consists of commands that can be used during framework <a id="_idIndexMarker387"/>development. In the Nest.js case, these commands run some of the following operations:</p>
<ul>
<li><strong class="bold">Build</strong> – the command <a id="_idIndexMarker388"/>that compiles or builds the framework. Nest.js executes the TypeScript compiler as part of this command.</li>
<li><strong class="bold">Clean</strong> – a quick command that cleans the working directory of the framework project. Usually, this means getting rid of any generated or built files.</li>
<li><strong class="bold">Test</strong> – commands that run all types of tests that are included in the framework. In the cases of Nest.js and many other frameworks, these types of commands are usually split by the type of tests they are running.</li>
<li><strong class="bold">Lint</strong> – analyzes the JavaScript code in the project, looking for coding style errors, pitfalls, and potential issues. Nest.js uses ESLint, running in parallel to quickly diagnose the framework files.</li>
<li><code>npm</code>.</li>
<li><strong class="bold">Install</strong> – installs the dependencies of the project. In the case of Nest.js, the dependency modules provide the functionality that is required to run a backend service. The developer dependency list has all the infrastructure modules to work on the framework project.</li>
<li><strong class="bold">Coverage</strong> – runs testing<a id="_idIndexMarker389"/> code coverage tooling to determine whether more tests are required to fully cover all the framework logic. For instance, Nest.js uses <strong class="bold">Istanbul</strong> (<a href="http://istanbul.js.org">istanbul.js.org</a>) for the code coverage report.</li>
</ul>
<p>This is not an extensive list, but it provides some inspiration for command types you can include in your project. The <code>scripts</code> part of the <code>package.json</code> file usually follows the reference material at <a href="http://docs.npmjs.com/cli/using-npm/scripts">docs.npmjs.com/cli/using-npm/scripts</a>, but different JavaScript package managers may treat these commands a bit differently. Your framework should utilize <code>package.json</code> to your advantage, creating quickly accessible scripts and configuring the <code>package.json</code> file as the entry point for your framework’s development workflow.</p>
<p>As we have seen in this section, there are a lot of development tools that empower framework development and are crucial to make the project successful. These development <a id="_idIndexMarker390"/>patterns have been improving over many years and are now deeply embedded in many JavaScript projects. In the next section, we shall take a look at the overall picture of a framework structure, which will give us a solid outline for our own framework project.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Learnings from other architectures</h1>
<p>In the current and<a id="_idIndexMarker391"/> previous chapters, we’ve seen all the different technical structures, tools, and patterns that frameworks use for their benefit. If we browse through the sources of frameworks gathered in the <em class="italic">Framework showcase</em> section of <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we can start to clearly see repeating patterns. Following these practices, we can take advantage of them in our own framework development. By gathering knowledge from the existing designs from different types of JavaScript frameworks, we can conceive a structural system that can serve us well in building our project. We can fuse all those methods and practices into a general framework structure.</p>
<p>The following code shows the generic JavaScript framework structure:</p>
<pre class="source-code">
&lt;root framework directory&gt;
  | &lt;main framework packages&gt;
<strong class="bold">    + &lt;core framework interfaces...&gt;</strong>
    + &lt;compiler / bundler&gt;
  | &lt;tests&gt;
    + &lt;unit tests&gt;
    + &lt;integration and end-to-end tests&gt;
    + &lt;benchmarks&gt;
  | &lt;static / dynamic typings&gt;
  | &lt;documentation&gt;
  | &lt;examples / samples&gt;
  | &lt;framework scripts&gt;
  | LICENSE
  | README documentation
  | package.json (package configuration)
  | &lt;.continuous integration&gt;
  | &lt;.source control add-ons&gt;
  | &lt;.editor and formatting configurations&gt;</pre>
<p>This project structure should help demystify the approach to our framework project structure and empower you, as a developer, to design your own. The framework file and directory structure is the culmination of the last two chapters, combining many of the components that we have seen so far – framework packages, the compiler infrastructure, framework testing, documentation, scripts, and more. Future chapters will be using this structure for our own framework building.</p>
<p>As we look at the core architectures and the examples of what the framework projects consist of, it helps us form what our framework will include and look like. Not everything that we see in the current architecture example will be necessary for our framework to function or succeed. In fact, if you will be building a framework for internal project use only, then you will be <a id="_idIndexMarker392"/>choosing a different combination of tools that help you with development.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Summary</h1>
<p>This chapter covered the importance of framework documentation, the variety of tests that improve stability, and the array of internal tools that establish efficient framework workflows. The investment in good documentation helps both framework authors and framework users. The lack of well-defined documents can be devastating to the framework’s success. Luckily, there are a ton of tools that help simplify the approach to documentation. In the same sense, there are existing tools for testing workflows, covering all aspects of code testing within the framework. Finally, the additional tooling, such as improved source control and editor configurations, makes it much more pleasant to work on the framework and helps authors focus on the framework internals. All of these development support factors play an essential role in framework development and architecture. Learning from other projects and utilizing the patterns that support the development process helps us expand our architectural skills and be more efficient.</p>
<p>At this point, we have learned a lot about existing framework technologies that enable web application and backend service development targeting the JavaScript runtime. In the next chapters, using these learnings and detailed exposure to existing framework projects, we will dive into the aspects of our framework building. This means starting a brand-new project from scratch. Utilizing the patterns, abstractions, and lessons learned from existing projects, we get to experience what it takes to build our own framework.</p>
<p>The next chapter will focus on some of the considerations a framework author needs to take into account before starting off with a new project.</p>
</div>


<div><h1 id="_idParaDest-73" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor072"/>Part 2: Framework Development</h1>
<p>In this part, the book builds on top of the real-world framework examples and switches gears to focus on the programming aspects of framework creation from scratch. The goal is to cover the complete process of planning, architecting, and publishing a new full stack framework. These stages include several important considerations and a lesson in the architecture of various types of components. The emphasis is on the practical approach and guidance of each process’s steps that benefit developers of all types.</p>
<p>In this part, we cover the following chapters:</p>
<ul>
<li><a href="B19014_05.xhtml#_idTextAnchor073"><em class="italic">Chapter 5</em></a>, <em class="italic">Framework Considerations</em></li>
<li><a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a>, <em class="italic">Building a Framework by Example</em></li>
<li><a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a><em class="italic">, Creating a Full Stack Framework</em></li>
<li><a href="B19014_08.xhtml#_idTextAnchor138"><em class="italic">Chapter 8</em></a><em class="italic">, Architecting Frontend Frameworks</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>