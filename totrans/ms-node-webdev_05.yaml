- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling HTTP Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The foundation of server-side web development is the ability to receive HTTP
    requests from clients and generate responses. In this chapter, I introduce the
    Node.js API for creating HTTP servers and explain how it can be used to receive
    and respond to requests. *Table 5.1* puts the Node.js HTTP API in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.1: Putting the Node.js API in context'
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| What is it? | The `http` and `https` modules contain the functions and classes
    required to create HTTP and HTTPS servers, receive requests, and generate responses.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Why is it useful? | Receiving and responding to HTTP requests is the core
    feature of server-side web application development. |'
  prefs: []
  type: TYPE_TB
- en: '| How is it used? | Servers are created with the `createServer` function, which
    emits events when requests are received. Callback functions are invoked to handle
    the request and generate a response. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | Handler functions can become complex
    and mix the statements that match requests with the statements that generate responses.
    Third-party packages, such as the Express package introduced in this chapter,
    build on the Node.js API to streamline request handling. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | No. The Node.js HTTP and HTTPS APIs are integral
    to server-side web application development. Third-party packages can make the
    API easier to use but are built on the same features. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 5.2* summarizes the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.2: Chapter summary'
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  prefs: []
  type: TYPE_TB
- en: '| Listing for HTTP requests | Use the `createServer` function to create a `Server`
    object and use the `listen` method to start listening for requests. | *4* |'
  prefs: []
  type: TYPE_TB
- en: '| Inspect an HTTP request | Use the features provided by the `IncomingRequest`
    class. | *5* |'
  prefs: []
  type: TYPE_TB
- en: '| Parse a request URL | Use the `URL` class in the `url` module. | *6* |'
  prefs: []
  type: TYPE_TB
- en: '| Create an HTTP response | Use the features provided by the `ServerResponse`
    class. | *7* |'
  prefs: []
  type: TYPE_TB
- en: '| Listen for HTTPS requests | Use the features provided by the `https` module.
    | *8, 9* |'
  prefs: []
  type: TYPE_TB
- en: '| Detect HTTPS requests | Check the value of the `socket.encrypted` property
    on the `IncomingRequest` object. | *10* |'
  prefs: []
  type: TYPE_TB
- en: '| Redirect insecure requests | Send a 302 header to the HTTPS port. | *11,
    12* |'
  prefs: []
  type: TYPE_TB
- en: '| Simplify request processing | Use a third-party router and enhanced request
    and response classes. | *13-19* |'
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I continue to use the `webapp` project created in *Chapter
    4*. To prepare for this chapter, replace the contents of the `handler.ts` file
    in the `src` folder with the code shown in *Listing 5.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.1: Replacing the contents of the handler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Replace the contents of the `server.ts` file in the `src` folder with the code
    shown in *Listing 5.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.2: Replacing the contents of the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Run the command shown in *Listing 5.3* in the `webapp` folder to start the watcher
    that compiles TypeScript files and executes the JavaScript that is produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.3: Starting the project'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `server.ts` file in the `src` folder will be compiled to produce a pure
    JavaScript file named `server.js` in the `dist` folder. The JavaScript code will
    be executed by the Node.js runtime, which will start listening for HTTP requests.
    Open a web browser and request `http://localhost:5000` and you will see the response
    shown in *Figure 5.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Running the example project'
  prefs: []
  type: TYPE_NORMAL
- en: Listening for HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 4*, I created a simple web server so that I could demonstrate the
    way that JavaScript code is executed. In doing so, I skipped over the details
    of how the code worked, but now it is time to go back and dig into the details.
  prefs: []
  type: TYPE_NORMAL
- en: The `createServer` function in the `http` module is used to create `Server`
    objects that can be used to listen for and process HTTP requests. The `Server`
    object requires configuration before it starts listening for requests and the
    most useful methods and properties defined by the `Server` class are described
    in *Table 5.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.3: Useful server methods and properties'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| This method starts listening for requests on a specified port. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| This method stops listening for requests. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| This property gets or sets the request timeout period, which can also be
    used using the configuration object passed to the `createServer` function. |'
  prefs: []
  type: TYPE_TB
- en: Once the `Server` object has been configured, it emits events that denote important
    changes in state. The most useful events are described in *Table 5.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.4: Useful server events'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| This event is triggered when the server starts listening for requests. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| This event is triggered when a new request is received. The callback function
    that handles this event is invoked with arguments that represent the HTTP request
    and response. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| This event is triggered when there is a network error. |'
  prefs: []
  type: TYPE_TB
- en: The use of events to invoke callback functions is typical of the JavaScript
    code execution model described in *Chapter 4*. The `request` event will be triggered
    each time an HTTP request is received, and the JavaScript execution model means
    that only one HTTP request will be handled at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js API often allows event handlers to be specified through other methods.
    The `createServer` function used to create a `Server` object accepts an optional
    function argument that is registered as a handler for the `request` event, and
    the `Server.listen` method accepts an optional function argument that is used
    to handle the `listening` event.
  prefs: []
  type: TYPE_NORMAL
- en: These convenience features can be used to combine the statements that create
    and configure the HTTP server with the callback functions that handle the events,
    as shown in *Listing 5.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.4: Using the event convenience features in the server.ts file in
    the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code has the same effect as *Listing 5.2* but is more concise and easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Server configuration object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arguments for the `createServer` function are a configuration object and
    a request-handling function. The configuration object is used to change the way
    that requests are received, and the most useful settings are described in *Table
    5.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.5: Useful createServer configuration object settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `IncomingMessage` | This property specifies the class used to represent requests.
    The default is the `IncomingMessage` class, defined in the `http` module. |'
  prefs: []
  type: TYPE_TB
- en: '| `ServerResponse` | This property specifies the class used to represent responses.
    The default is the `ServerResponse` class, defined in the `http` module. |'
  prefs: []
  type: TYPE_TB
- en: '| `requestTimeout` | This property specifies the amount of time, in milliseconds,
    allowed for a client to send requests, after which the request times out. The
    default value is 300,000 milliseconds. |'
  prefs: []
  type: TYPE_TB
- en: 'The configuration object can be omitted if the default values are required.
    The handler function is invoked when an HTTP request has been received and its
    parameters are objects whose types are those specified by the `IncomingMessage`
    and `ServerResponse` properties, or the default types if the configuration hasn’t
    been changed. The code in *Listing 5.4* omits the configuration object, which
    means that the default types will be used to represent the HTTP request and response
    when the handler function for the request event is invoked, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Later examples in this chapter demonstrate using different types, but the default
    representations of the HTTP request and response provide all the features needed
    to process HTTP, as explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js represents HTTP requests using the `IncomingMessage` class, which is
    defined in the `http` module. The four main building blocks of an HTTP request
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP method, which describes the operation the client wants to perform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL, which identifies the resource the request should be applied to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The headers, which provide additional information about the request and the
    capabilities of the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request body, which provides the data required for the requested operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IncomingMessage` class provides access to all of these building blocks,
    allowing them to be inspected so the server can generate a suitable response.
    *Table 5.6* lists the properties provided for the first three request building
    blocks, and I explain how to deal with the request body in *Chapter 6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.6: Useful IncomingMessage properties'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `headers` | This property returns an `IncomingHttpHeaders` object, which
    defines properties for common headers and can also be used as a key/value object
    that maps the names of the headers in the request to the header values. The headers
    are normalized, as described below. |'
  prefs: []
  type: TYPE_TB
- en: '| `headersDistinct` | This property returns a key/value object that maps the
    names of the headers in the request to the header values. The values are normalized,
    as described below this table. |'
  prefs: []
  type: TYPE_TB
- en: '| `httpVersion` | This property returns a `string` value containing the version
    of HTTP used in the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `method` | This property returns a `string` value containing the HTTP method
    specified by the request. This value may be `undefined.` |'
  prefs: []
  type: TYPE_TB
- en: '| `url` | This property returns a `string` value containing the request URL.
    This value may be `undefined`. |'
  prefs: []
  type: TYPE_TB
- en: '| `socket` | This property returns an object that represents the network socket
    used to receive the connection, which is useful when detecting HTTPS requests,
    as demonstrated in the *Detecting HTTPS requests* section. |'
  prefs: []
  type: TYPE_TB
- en: HTTP headers can be difficult to work with and the `headers` and `headersDistinct`
    properties normalize headers so that they are easier to use. Some HTTP headers
    should only appear once in a request, so Node.js removes duplicate values. Other
    headers can have multiple values, and these are concatenated into a single `string`
    value by the `headers` property and into an array of strings by the `headersDistinct`
    property. The exception is the `set-cookie` header, which is always presented
    as a `string` array. (I describe how cookies are used in detail in *Part 2*.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: The `IncomingRequest` class also defines the `rawHeaders` property, which provides
    access to the headers as they were received, with no normalization. This property
    can be useful if you need to perform custom normalization, but the `headers` and
    `headersDistinct` properties are more useful for mainstream development projects.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, the `headers` property is more useful for displaying or
    logging headers, while the `headersDistinct` property is more useful when using
    headers to decide what kind of response to produce. *Listing 5.5* updates the
    example to log the details of the request to the Node.js console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.5: Logging request details in the handler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This example writes out the HTTP method, the request URL, and three headers:
    the `host` header, which specifies the hostname and port to which the request
    was sent; the `accept` header, which specifies the formats the client is willing
    to accept in the response; and the `user-agent` header, which identifies the client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I used the `headers` property in *Listing 5.5*, which allows me to access headers
    using properties that correspond to the header name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Not all HTTP header names can be used as JavaScript property names, and there
    is no property for the `user-agent` header because JavaScript property names cannot
    contain hyphens. Instead, I have to access the `user-agent` header by specifying
    the property name as a string, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a browser to request `http://localhost:5000` and you will see output similar
    to the following, although you may see different values for the headers (and I
    have elided the header values for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This output shows two requests because browsers will often request `/favicon.ico`,
    which is used as the icon for the tab. You may not see the `favicon.ico` request
    if you recently used your browser for the examples in the previous chapter, where
    a `404 Not Found` response was produced. You can clear your browser’s cache if
    you want to see both requests, but it isn’t important for the examples that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js provides the `URL` class in the `url` module to parse URLs into their
    parts, making it easier to inspect URLs to make decisions about what kind of response
    will be sent. URLs are parsed by creating a new `URL` object and reading the properties
    described in *Table 5.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.7: Useful URL properties'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `hostname` | This property returns a `string` containing the URL hostname
    component. |'
  prefs: []
  type: TYPE_TB
- en: '| `pathname` | This property returns a `string` containing the URL pathname
    component. |'
  prefs: []
  type: TYPE_TB
- en: '| `port` | This property returns a `string` containing the URL port component.
    The value will be an empty string if the request has been made to the default
    port for the URL’s protocol (such as port `80` for unsecured HTTP requests). |'
  prefs: []
  type: TYPE_TB
- en: '| `protocol` | This property returns a `string` containing the URL protocol
    component. |'
  prefs: []
  type: TYPE_TB
- en: '| `search` | This property returns a `string` containing the entire query portion
    of the URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `searchParams` | This property returns a `URLSeachParams` object that provides
    key/value access to the query portion of the URL. |'
  prefs: []
  type: TYPE_TB
- en: '*Listing 5.6* creates a new URL object to parse the request URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.6: Parsing a URL in the handler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a `URL` object to parse a URL requires a little work. The `IncomingMessage.url`
    property returns a relative URL, which the `URL` class constructor will accept
    as an argument, but only if the base part of the URL (the protocol, hostname,
    and port) is specified as a second argument. The hostname and port can be obtained
    from the `host` request header, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The missing piece is the protocol. The example only accepts regular unsecured
    HTTP requests so I can specify `http` as the protocol, safe in the knowledge that
    it will be correct. I will demonstrate how to determine the protocol properly
    when I demonstrate the use of HTTPS later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The properties described in *Table 5.7* can be used to inspect the individual
    parts of the URL once the `URL` object has been created, and the example writes
    out the `protocol`, `hostname`, `port`, and `pathname` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `URL` class parses the query section of the URL and presents it as a set
    of key/value pairs and these are also written out. Use a browser to request the
    following URL: `http://localhost:5000/myrequest?first=Bob&last=Smith`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This URL has a path and a query, and you will see output similar to the following
    when the URL is parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the browser has sent a second request, for `/favicon.ico`,
    in addition to the URL that was explicitly requested.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of inspecting an HTTP request is to determine what kind of response
    is required. Responses are produced using the features provided by the `ServerResponse`
    class, the most useful of which are described in *Table 5.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.8: Useful ServerResponse members'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `sendDate` | This `boolean` property determines whether Node.js automatically
    generates the `Date` header and adds it to the response. The default is `true`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setHeader(name, value)` | This method sets a response header using the specified
    name and value. |'
  prefs: []
  type: TYPE_TB
- en: '| `statusCode` | This `number` property is used to set the response status
    code. |'
  prefs: []
  type: TYPE_TB
- en: '| `statusMessage` | This `string` property is used to set the response status
    message. |'
  prefs: []
  type: TYPE_TB
- en: '| `writeHead(code, msg, headers)` | This method is used to set the status code
    and, optionally, the status message and response headers. |'
  prefs: []
  type: TYPE_TB
- en: '| `write(data)` | This method writes data to the response body, which is expressed
    as a `string` or a `Buffer`. This method accepts optional arguments that specify
    the encoding for the data and a callback function that is invoked when the operation
    is complete. |'
  prefs: []
  type: TYPE_TB
- en: '| `end()` | This method tells Node.js that the response is complete and can
    be sent to the client. The method can be invoked with an optional `data` argument,
    which will be added to the response body, an encoding for the data, and a callback
    function that will be invoked when the response has been sent. |'
  prefs: []
  type: TYPE_TB
- en: The basic approach to generating a response is to set the status code and status
    message, define any headers that will help the client process the response, write
    the data for the body – if there is one – and then send the response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5.7* inspects the requests that are received to determine how the
    features provided by the `ServerResponse` class are used to create a response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.7: Generating HTTP responses in the handler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This example generates three different responses. For requests that don’t specify
    the HTTP GET method or request `/favicon.ico`, the status code is set to 404,
    which tells the browser the requested resource doesn’t exist, the human-readable
    status message is set to `Not Found`, and the `end` method is called to complete
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: For all other requests, the status code is set to 200, indicating a successful
    response and the status message is set to `OK`. The query component of the request
    URL is checked to see if there is a `keyword` parameter and, if there is, the
    value is included in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I use the `return` keyword after calling the `end` method. This
    is not a requirement, but it is an error to set headers or write data after the
    `end` method has been called, and explicitly returning from the function avoids
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000/favicon.ico`, `http://localhost:5000?keyword=World`,
    and `http://localhost:5000` and you will see the responses shown in *Figure 5.2*.
    (The browser usually requests the `favicon.ico` file behind the scenes, but requesting
    it explicitly makes it easier to see the `HTTP 404` response.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Generating HTTP responses'
  prefs: []
  type: TYPE_NORMAL
- en: Supporting HTTPS requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most web applications use HTTPS, where HTTP requests are sent over an encrypted
    network connection using the TLS/SSL protocol. Using HTTPS ensures that the request
    and response cannot be inspected as they traverse public networks.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting SSL requires a certificate that establishes the identity of the server
    and is used as the basis for the encryption that secures HTTPS requests. For this
    chapter, I am going to use a self-signed certificate, which is sufficient for
    development and testing, but should not be used for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: See [https://letsencrypt.org](https://letsencrypt.org) if you want a certificate
    for deployment. The Let’s Encrypt service is supported by a non-profit organization
    and offers free certificates suitable for use with HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the self-signed certificate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to create a self-signed certificate is to use the OpenSSL package,
    which is an open-source toolkit for security-related tasks. The OpenSSL project
    can be found at [https://www.openssl.org](https://www.openssl.org) and OpenSSL
    is part of many popular Linux distributions. A list of binaries and installers,
    including installers for Windows, can be found at [https://wiki.openssl.org/index.php/binaries](https://wiki.openssl.org/index.php/binaries).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the Git client includes OpenSSL in the `usr/bin` folder (`C:\Program
    Files\Git\usr\bin` on Windows), which can be used to create self-signed certificates
    without needing to install the OpenSSL package.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the OpenSSL executable is in your command prompt path and run the
    command shown in *Listing 5.8* in the `webapp` folder, entering the entire command
    on one line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.8: Generating a self-signed certificate'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command prompts for the details that will be included in the certificate.
    Press the *Enter* key to select the default value for each option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The details don’t matter because the certificate will be used only for development.
    When the command completes, there will be two new files in the `webapp` folder:
    the `cert.pem` file (which contains the self-signed certificate) and the `key.pem`
    file (which contains the private key for the certificate).'
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTPS requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to use the API provided by Node.js to receive HTTPS requests,
    as shown in *Listing 5.9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.9: Handling HTTPS requests in the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The process for receiving HTTPS requests is similar to regular HTTP, to the
    extent that the function for creating an HTTPS server is named `createServer`,
    which is the same name used for HTTP. To use both versions of the `createServer`
    function in the same code file, I have used an alias in the `import` statement,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This statement imports the `createServer` function from the `https` module and
    the `as` keyword is used to assign a name that doesn’t conflict with other imports.
    In this case, the name I have chosen is `createHttpsServer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A configuration object is required to specify the certificate files that were
    created in the previous section with properties named `key` and `cert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `key` and `cert` properties can be assigned `string` or `Buffer` values.
    I use the `readFileSync` functions from the `fs` module to read the contents of
    the `key.pem` and `cert.pem` files, which produces `Buffer` values that contain
    byte arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding synchronous file reads**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 4*, I explained that it can make sense to use blocking operations
    when you know that there is no other work to be performed by the main thread.
    In this case, I need to read the contents of the `key.pem` and `cert.pem` files
    as part of the application startup. There is little benefit to using a callback
    or a promise because I need the contents of those files to configure Node.js to
    listen for HTTPS requests and using non-blocking operations produces code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code shows you *can* read the files using the non-blocking `readFile` function,
    but the nested callbacks are harder to make sense of. Promises don’t help either
    because the `await` keyword can only be used within functions, which means the
    `then` syntax demonstrated in *Chapter 4* must be used.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to avoid blocking the main thread in almost every situation,
    but there are a few occasions when it doesn’t matter, and non-blocking features
    are less useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many configuration options available, described at [https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener](https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener),
    but the `key` and `cert` options are enough to get started. The configuration
    object is passed to the `createServer` function, which I have aliased as `createHttpsServer`
    in this example, and the `listen` method is called on the result to start listening
    for HTTPS requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Open a web browser and request `https://localhost:5500`, which will send an
    HTTPS request to the port on which Node.js has been configured to listen. Browsers
    will display warnings for self-signed certificates, and you will typically have
    to confirm you want to proceed, as shown in *Figure 5.3*, which shows the warning
    presented by Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Accepting a self-signed certificate'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is still listening for regular HTTP requests on port `5000`, which you
    can confirm by requesting `http://localhost:5000`.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting HTTPS requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js API uses the `IncomingMessage` and `ServerResponse` classes for
    both HTTP and HTTPS requests, which means that the same handler function can be
    used for both request types. However, it can be useful to know which kind of request
    is being processed so that different responses can be generated, as shown in *Listing
    5.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.10: Detecting HTTPS requests in the handler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `socket` property defined by the `IncomingMessage` class will return an
    instance of the `TLSSocket` class for secure requests and this class defines an
    `encrypted` property that always returns `true`. Checking if this property exists
    allows HTTPS and HTTP connections to be identified so that different responses
    can be produced.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: A common deployment pattern for Node.js is to use a proxy that receives HTTPS
    requests from clients and fans them out to Node.js servers using plain HTTP. In
    this situation, you can usually check the `X-Forwarded-Proto` request header,
    which proxies use to pass on details of the encryption used by the client. See
    [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000` and `https://localhost:5500`
    and you will see the responses shown in *Figure 5.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Identifying HTTPS requests'
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting insecure requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTPS has become the preferred way to offer web functionality and it is common
    practice to respond to regular HTTP requests with a response that directs the
    client to use HTTPS instead, as shown in *Listing 5.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.11: Redirecting HTTP requests in the handler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The new handler uses the `writeHead` method to set the status code to `302`,
    which denotes a redirection, and sets the `Location` header, which specifies the
    URL the browser should request instead. *Listing 5.12* applies the new handler
    so that it is used to generate responses for all HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.12: Applying a handler in the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you use the browser to request `http://localhost:5000`, the response sent
    by the new handler will cause the browser to request `https://localhost:5500`.
    If you examine the network connections made by the browser in the *F12* developer
    tools window, you will see the redirection response and the subsequent HTTPS request,
    as shown in *Figure 5.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using HTTP Strict Transport Security (HSTS)**'
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting HTTP requests to an HTTPS URL means that the initial communication
    between the client and server is unencrypted, which presents the potential for
    the HTTP request to be hijacked by a man-in-the-middle attack that redirects clients
    to a malicious URL instead. The **HTTP Strict Transport Security** (**HSTS**)
    header can be used to tell browsers not to only use HTTPS requests for a domain.
    See [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Redirecting HTTP requests'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding HTTP/2**'
  prefs: []
  type: TYPE_NORMAL
- en: All the examples in this chapter use HTTP/1.1, which tends to be the default
    for Node.js web application development.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2 is an update to the HTTP protocol that is intended to improve performance.
    HTTP/2 uses a single network connection to interleave multiple requests from the
    client, sends headers in a compact binary format, and allows the server to “push”
    content to the client before it is requested. Node.js provides support for HTTP/2
    in the `http2` module and even includes a compatibility API that uses the approach
    shown in this chapter to handle HTTP/1.1 and HTTP/2 requests with the same code.
    (See [https://nodejs.org/dist/latest-v20.x/docs/api/http2.html](https://nodejs.org/dist/latest-v20.x/docs/api/http2.html)
    for details.)
  prefs: []
  type: TYPE_NORMAL
- en: But HTTP/2 isn’t an automatic choice for Node.js projects, even though it is
    more efficient. That’s because HTTP/2 benefits applications that have a large
    volume of requests, and applications of that size use a proxy to receive requests
    and fan them out to multiple Node.js servers. The proxy receives HTTP/2 requests
    from clients but communicates with Node.js using HTTP/1.1 requests because the
    HTTP/2 features don’t have much impact inside the data center. You can see an
    example of this type of deployment in *Part 3* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that don’t use a proxy, the volume of requests is small enough
    that the efficiencies of HTTP/2 don’t justify the additional complexity that HTTP/2
    adds to development, such as requiring encryption for all requests.
  prefs: []
  type: TYPE_NORMAL
- en: Most Node.js applications still use HTTP/1.1 and you can see this reflected
    in the way that open-source packages for Node.js, such as the Express package
    I use in the next section, remain hugely popular even though they don’t support
    HTTP/2.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API that Node.js provides for HTTP and HTTPS is comprehensive but can produce
    verbose code that is difficult to read and maintain. One of the joys of JavaScript
    development is the huge range of open-source packages that are available and there
    are many packages that are built on the Node.js API to simplify request handling.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular of these packages is Express. Run the commands shown in *Listing
    5.13* in the `webapp` folder to install the Express package and the TypeScript
    types for Express in the example project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you don’t like the way that Express works because there are plenty
    of other packages available that do similar things. A quick web search for Express
    alternatives will give you several options to consider. Bear in mind when choosing
    a package that, as I noted in *Chapter 2*, not all JavaScript packages receive
    long-term support from their creators, and it is worth considering how widely
    a package has been adopted before using it in a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.13: Installing the Express package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Express has many features, which are described in detail at [https://expressjs.com](https://expressjs.com),
    but the two that are most useful are the request router and the enhanced request/response
    types, both of which are described in the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Express router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Request handler functions that use the Node.js API mix the statements that inspect
    requests with the code that generates responses. A new branch of code is required
    every time a new URL is supported by the application, as shown in *Listing 5.14*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.14: Supporting a new URL in the handler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Each new addition makes the code more complex and increases the chances of a
    coding error that either doesn’t match the right requests or generates the wrong
    response.
  prefs: []
  type: TYPE_NORMAL
- en: The Express *router* solves this problem by separating request matching from
    generating responses. The first step towards using the Express router is to refactor
    the existing request handler code into separate functions that generate responses
    without the statements that inspect requests, as shown in *Listing 5.15*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.15: Refactoring in the handler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The responses are generated in the same way as earlier examples, but each response
    is created by a separate handler function, without the code that matches requests.
    The next step is to use the Express router to match requests and select one of
    the handlers from *Listing 5.15* to produce a result, as shown in *Listing 5.16*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.16: Using the Express router in the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Express` package contains a default export, which is a function named
    `express`, and this is why the new `import` statement looks different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `express` function is invoked to create an `Express` object, which provides
    methods for mapping requests to handler functions. *Table 5.9* describes the most
    useful methods, most of which incorporate the HTTP method into the matching process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.9: Useful Express methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '| This method routes HTTP GET requests that match the path to the specified
    handler function. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '| This method routes HTTP POST requests that match the path to the specified
    handler function. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '| This method routes HTTP PUT requests that match the path to the specified
    handler function. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '| This method routes HTTP DELETE requests that match the path to the specified
    handler function. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '| This method routes all requests that match the path to the specified handler
    function. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '| This method adds a middleware component, which is able to inspect and intercept
    all requests. Later chapters contain examples that use middleware. |'
  prefs: []
  type: TYPE_TB
- en: 'I am only interested in GET requests in this chapter, and so I used the `get`
    method to specify URL paths and the functions that will generate responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These statements are *routes*, and the URLs are specified as patterns that
    allow wildcards, such as the `*` character in this route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This matches any GET request and routes it to the `defaultHandler` function.
    Express matches requests to routes in the order in which they are defined, and
    so this is a catch-all route that will be applied if requests are not matched
    by the other routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the methods described in *Table 5.9*, the `Express` object is
    also a handler function that can be used with the Node.js `createServer` functions
    defined in the `http` and `https` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Express processes all the HTTP requests that Node.js receives and routes them
    to the appropriate handler.
  prefs: []
  type: TYPE_NORMAL
- en: Using the request and response enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to routing, Express provides enhancements to the `IncomingRequest`
    and `ServerResponse` objects that are passed to handler functions. The object
    that represents the HTTP request is named `Request` and it extends the `IncomingRequest`
    type. The most useful `Request` enhancements are described in *Table 5.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.10: Useful Express request enhancements'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `hostname` | This property provides convenient access to the value of the
    `hostname` header. |'
  prefs: []
  type: TYPE_TB
- en: '| `params` | This property provides access to the route parameters, which are
    described in the *Using Express route parameters* section of this chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | This property returns the path component of the request URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `protocol` | This property returns the protocol used to make the request,
    which will be either `http` or `https`. |'
  prefs: []
  type: TYPE_TB
- en: '| `query` | This property returns an object whose properties correspond to
    the query string parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `secure` | This property returns `true` if the request has been made using
    HTTPS. |'
  prefs: []
  type: TYPE_TB
- en: '| `body` | This property is assigned the parsed contents of the request body,
    as demonstrated in *Chapter 6*. |'
  prefs: []
  type: TYPE_TB
- en: The object that Express uses to represent the HTTP response is named `Response`
    and it extends the `ServerResponse` type. The most useful basic `Response` enhancements
    are described in *Table 5.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.11: Useful basic Express response enhancements'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `redirect(code, path)``redirect(path)` | This method sends a redirection
    response. The `code` argument is used to set the response status code and message.
    The `path` argument is used to set the value of the `Location` header. If the
    `code` argument is omitted, then a temporary redirection, with status code `302`,
    is sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `send(data)` | This method is used to send a response to the server. The
    status code is set to `200`. This method sets response headers to describe the
    content, including the `Content-Length` and `Content-Type` headers. |'
  prefs: []
  type: TYPE_TB
- en: '| `sendStatus(code)` | This method is used to send a status code response and
    will automatically set the status message for well-known status codes, so that
    a status code of `200` will lead to the **OK** message being used, for example.
    |'
  prefs: []
  type: TYPE_TB
- en: Other Express enhancements relate to features described in later chapters, but
    the basic additions described in *Table 5.10* and *Table 5.11* are enough to simplify
    the way that responses are generated by the example application, as shown in *Listing
    5.17*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.17: Using the Express enhancements in the handler.ts file in the
    src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Express automatically parses the request URL and makes its parts accessible
    through the `Response` properties described in *Table 5.10*, which means I don’t
    have to parse the URL explicitly. The convenient `secure` property means that
    I can remove the `isHttps` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `Response` methods described in *Table 5.11* reduce the number of statements
    required to produce responses. The `send` method, for example, takes care of setting
    the response status code, sets some useful headers, and calls the `end` method
    to tell Node.js that the response is complete.
  prefs: []
  type: TYPE_NORMAL
- en: If you request `https://localhost:5500/newurl` and `https://localhost:5500?keyword=Express`,
    you will see the responses shown in *Figure 5.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Your browser may use a different font to display these responses, which happens
    because the `Response` methods used to generate responses in *Listing 5.17* set
    the `Content-Type` header in the response to `text/html`. This header was not
    set in previous examples, and it alters the way that most browsers display the
    content.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Generating responses using Express'
  prefs: []
  type: TYPE_NORMAL
- en: Using Express route parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to understand that Express doesn’t do anything magical and its
    features are built on those provided by Node.js described earlier in the chapter.
    The value of Express is that it makes the Node.js API easier to consume, with
    the result that the code is easier to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: One especially useful feature that Express provides is specifying *route parameters*,
    which extract values from URL paths when matching requests and make them easily
    accessible through the `Response.params` property, as shown in *Listing 5.18*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.18: Using route parameters in the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The modified route matches requests when the path begins with `/newurl`. The
    second segment in the URL path is assigned to a route parameter named `message`.
    The parameter is denoted by the colon (the `:` character). For the URL path `/newurl/London`,
    for example, the `message` parameter will be assigned the value `London`. The
    question mark (the `?` character) denotes this is an optional parameter, which
    means the route will match requests even if there is no second URL segment.
  prefs: []
  type: TYPE_NORMAL
- en: Route parameters are an effective way to increase the range of URLs that a route
    can match. *Listing 5.19* uses the `Response.params` property to get the value
    of the `message` parameter and incorporate it into the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.19: Consuming a route parameter in the handler.ts file in the src
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `https://localhost:5500/newurl/London` and you will
    see the response shown in *Figure 5.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Using a route parameter'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I described the API features that Node.js provides for receiving
    HTTP requests and producing responses, which is the backbone of server-side web
    application development:'
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js API provides support for receiving HTTP and HTTPS requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js emits events when requests are received and invokes callback functions
    to handle those requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some additional work, such as parsing URLs, is generally required when using
    the Node.js API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party packages, such as Express, build on the Node.js APIs to streamline
    request processing and simplify the code that generates responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, I describe the features Node.js provides for reading and
    writing data.
  prefs: []
  type: TYPE_NORMAL
