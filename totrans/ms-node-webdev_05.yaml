- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling HTTP Requests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The foundation of server-side web development is the ability to receive HTTP
    requests from clients and generate responses. In this chapter, I introduce the
    Node.js API for creating HTTP servers and explain how it can be used to receive
    and respond to requests. *Table 5.1* puts the Node.js HTTP API in context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.1: Putting the Node.js API in context'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
- en: '| What is it? | The `http` and `https` modules contain the functions and classes
    required to create HTTP and HTTPS servers, receive requests, and generate responses.
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
- en: '| Why is it useful? | Receiving and responding to HTTP requests is the core
    feature of server-side web application development. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
- en: '| How is it used? | Servers are created with the `createServer` function, which
    emits events when requests are received. Callback functions are invoked to handle
    the request and generate a response. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | Handler functions can become complex
    and mix the statements that match requests with the statements that generate responses.
    Third-party packages, such as the Express package introduced in this chapter,
    build on the Node.js API to streamline request handling. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | No. The Node.js HTTP and HTTPS APIs are integral
    to server-side web application development. Third-party packages can make the
    API easier to use but are built on the same features. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
- en: '*Table 5.2* summarizes the chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.2: Chapter summary'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| Listing for HTTP requests | Use the `createServer` function to create a `Server`
    object and use the `listen` method to start listening for requests. | *4* |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| Inspect an HTTP request | Use the features provided by the `IncomingRequest`
    class. | *5* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| Parse a request URL | Use the `URL` class in the `url` module. | *6* |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| Create an HTTP response | Use the features provided by the `ServerResponse`
    class. | *7* |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| Listen for HTTPS requests | Use the features provided by the `https` module.
    | *8, 9* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| Detect HTTPS requests | Check the value of the `socket.encrypted` property
    on the `IncomingRequest` object. | *10* |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| Redirect insecure requests | Send a 302 header to the HTTPS port. | *11,
    12* |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| Simplify request processing | Use a third-party router and enhanced request
    and response classes. | *13-19* |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I continue to use the `webapp` project created in *Chapter
    4*. To prepare for this chapter, replace the contents of the `handler.ts` file
    in the `src` folder with the code shown in *Listing 5.1*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* to get help if you have problems running the examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.1: Replacing the contents of the handler.ts file in the src folder'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Replace the contents of the `server.ts` file in the `src` folder with the code
    shown in *Listing 5.2*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.2: Replacing the contents of the server.ts file in the src folder'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run the command shown in *Listing 5.3* in the `webapp` folder to start the watcher
    that compiles TypeScript files and executes the JavaScript that is produced.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.3: Starting the project'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `server.ts` file in the `src` folder will be compiled to produce a pure
    JavaScript file named `server.js` in the `dist` folder. The JavaScript code will
    be executed by the Node.js runtime, which will start listening for HTTP requests.
    Open a web browser and request `http://localhost:5000` and you will see the response
    shown in *Figure 5.1*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Running the example project'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Listening for HTTP requests
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 4*, I created a simple web server so that I could demonstrate the
    way that JavaScript code is executed. In doing so, I skipped over the details
    of how the code worked, but now it is time to go back and dig into the details.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The `createServer` function in the `http` module is used to create `Server`
    objects that can be used to listen for and process HTTP requests. The `Server`
    object requires configuration before it starts listening for requests and the
    most useful methods and properties defined by the `Server` class are described
    in *Table 5.3*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.3: Useful server methods and properties'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| This method starts listening for requests on a specified port. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| This method stops listening for requests. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| This property gets or sets the request timeout period, which can also be
    used using the configuration object passed to the `createServer` function. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: Once the `Server` object has been configured, it emits events that denote important
    changes in state. The most useful events are described in *Table 5.4*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.4: Useful server events'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| This event is triggered when the server starts listening for requests. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| This event is triggered when a new request is received. The callback function
    that handles this event is invoked with arguments that represent the HTTP request
    and response. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| This event is triggered when there is a network error. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: The use of events to invoke callback functions is typical of the JavaScript
    code execution model described in *Chapter 4*. The `request` event will be triggered
    each time an HTTP request is received, and the JavaScript execution model means
    that only one HTTP request will be handled at a time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js API often allows event handlers to be specified through other methods.
    The `createServer` function used to create a `Server` object accepts an optional
    function argument that is registered as a handler for the `request` event, and
    the `Server.listen` method accepts an optional function argument that is used
    to handle the `listening` event.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: These convenience features can be used to combine the statements that create
    and configure the HTTP server with the callback functions that handle the events,
    as shown in *Listing 5.4*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.4: Using the event convenience features in the server.ts file in
    the src folder'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code has the same effect as *Listing 5.2* but is more concise and easier
    to read.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Server configuration object
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arguments for the `createServer` function are a configuration object and
    a request-handling function. The configuration object is used to change the way
    that requests are received, and the most useful settings are described in *Table
    5.5*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.5: Useful createServer configuration object settings'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| `IncomingMessage` | This property specifies the class used to represent requests.
    The default is the `IncomingMessage` class, defined in the `http` module. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| `ServerResponse` | This property specifies the class used to represent responses.
    The default is the `ServerResponse` class, defined in the `http` module. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| `requestTimeout` | This property specifies the amount of time, in milliseconds,
    allowed for a client to send requests, after which the request times out. The
    default value is 300,000 milliseconds. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: 'The configuration object can be omitted if the default values are required.
    The handler function is invoked when an HTTP request has been received and its
    parameters are objects whose types are those specified by the `IncomingMessage`
    and `ServerResponse` properties, or the default types if the configuration hasn’t
    been changed. The code in *Listing 5.4* omits the configuration object, which
    means that the default types will be used to represent the HTTP request and response
    when the handler function for the request event is invoked, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Later examples in this chapter demonstrate using different types, but the default
    representations of the HTTP request and response provide all the features needed
    to process HTTP, as explained in the following sections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP requests
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js represents HTTP requests using the `IncomingMessage` class, which is
    defined in the `http` module. The four main building blocks of an HTTP request
    are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP method, which describes the operation the client wants to perform.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL, which identifies the resource the request should be applied to.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The headers, which provide additional information about the request and the
    capabilities of the client.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request body, which provides the data required for the requested operation.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IncomingMessage` class provides access to all of these building blocks,
    allowing them to be inspected so the server can generate a suitable response.
    *Table 5.6* lists the properties provided for the first three request building
    blocks, and I explain how to deal with the request body in *Chapter 6*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.6: Useful IncomingMessage properties'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `headers` | This property returns an `IncomingHttpHeaders` object, which
    defines properties for common headers and can also be used as a key/value object
    that maps the names of the headers in the request to the header values. The headers
    are normalized, as described below. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| `headersDistinct` | This property returns a key/value object that maps the
    names of the headers in the request to the header values. The values are normalized,
    as described below this table. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| `httpVersion` | This property returns a `string` value containing the version
    of HTTP used in the request. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| `method` | This property returns a `string` value containing the HTTP method
    specified by the request. This value may be `undefined.` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| `url` | This property returns a `string` value containing the request URL.
    This value may be `undefined`. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| `socket` | This property returns an object that represents the network socket
    used to receive the connection, which is useful when detecting HTTPS requests,
    as demonstrated in the *Detecting HTTPS requests* section. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: HTTP headers can be difficult to work with and the `headers` and `headersDistinct`
    properties normalize headers so that they are easier to use. Some HTTP headers
    should only appear once in a request, so Node.js removes duplicate values. Other
    headers can have multiple values, and these are concatenated into a single `string`
    value by the `headers` property and into an array of strings by the `headersDistinct`
    property. The exception is the `set-cookie` header, which is always presented
    as a `string` array. (I describe how cookies are used in detail in *Part 2*.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The `IncomingRequest` class also defines the `rawHeaders` property, which provides
    access to the headers as they were received, with no normalization. This property
    can be useful if you need to perform custom normalization, but the `headers` and
    `headersDistinct` properties are more useful for mainstream development projects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, the `headers` property is more useful for displaying or
    logging headers, while the `headersDistinct` property is more useful when using
    headers to decide what kind of response to produce. *Listing 5.5* updates the
    example to log the details of the request to the Node.js console.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.5: Logging request details in the handler.ts file in the src folder'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example writes out the HTTP method, the request URL, and three headers:
    the `host` header, which specifies the hostname and port to which the request
    was sent; the `accept` header, which specifies the formats the client is willing
    to accept in the response; and the `user-agent` header, which identifies the client.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'I used the `headers` property in *Listing 5.5*, which allows me to access headers
    using properties that correspond to the header name, like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Not all HTTP header names can be used as JavaScript property names, and there
    is no property for the `user-agent` header because JavaScript property names cannot
    contain hyphens. Instead, I have to access the `user-agent` header by specifying
    the property name as a string, like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use a browser to request `http://localhost:5000` and you will see output similar
    to the following, although you may see different values for the headers (and I
    have elided the header values for brevity):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This output shows two requests because browsers will often request `/favicon.ico`,
    which is used as the icon for the tab. You may not see the `favicon.ico` request
    if you recently used your browser for the examples in the previous chapter, where
    a `404 Not Found` response was produced. You can clear your browser’s cache if
    you want to see both requests, but it isn’t important for the examples that follow.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Parsing URLs
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js provides the `URL` class in the `url` module to parse URLs into their
    parts, making it easier to inspect URLs to make decisions about what kind of response
    will be sent. URLs are parsed by creating a new `URL` object and reading the properties
    described in *Table 5.7*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.7: Useful URL properties'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `hostname` | This property returns a `string` containing the URL hostname
    component. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `pathname` | This property returns a `string` containing the URL pathname
    component. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `port` | This property returns a `string` containing the URL port component.
    The value will be an empty string if the request has been made to the default
    port for the URL’s protocol (such as port `80` for unsecured HTTP requests). |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `protocol` | This property returns a `string` containing the URL protocol
    component. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| `search` | This property returns a `string` containing the entire query portion
    of the URL. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| `searchParams` | This property returns a `URLSeachParams` object that provides
    key/value access to the query portion of the URL. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '*Listing 5.6* creates a new URL object to parse the request URL.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.6: Parsing a URL in the handler.ts file in the src folder'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Creating a `URL` object to parse a URL requires a little work. The `IncomingMessage.url`
    property returns a relative URL, which the `URL` class constructor will accept
    as an argument, but only if the base part of the URL (the protocol, hostname,
    and port) is specified as a second argument. The hostname and port can be obtained
    from the `host` request header, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The missing piece is the protocol. The example only accepts regular unsecured
    HTTP requests so I can specify `http` as the protocol, safe in the knowledge that
    it will be correct. I will demonstrate how to determine the protocol properly
    when I demonstrate the use of HTTPS later in the chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The properties described in *Table 5.7* can be used to inspect the individual
    parts of the URL once the `URL` object has been created, and the example writes
    out the `protocol`, `hostname`, `port`, and `pathname` values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The `URL` class parses the query section of the URL and presents it as a set
    of key/value pairs and these are also written out. Use a browser to request the
    following URL: `http://localhost:5000/myrequest?first=Bob&last=Smith`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'This URL has a path and a query, and you will see output similar to the following
    when the URL is parsed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output shows that the browser has sent a second request, for `/favicon.ico`,
    in addition to the URL that was explicitly requested.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP responses
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of inspecting an HTTP request is to determine what kind of response
    is required. Responses are produced using the features provided by the `ServerResponse`
    class, the most useful of which are described in *Table 5.8*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.8: Useful ServerResponse members'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `sendDate` | This `boolean` property determines whether Node.js automatically
    generates the `Date` header and adds it to the response. The default is `true`.
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `setHeader(name, value)` | This method sets a response header using the specified
    name and value. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `statusCode` | This `number` property is used to set the response status
    code. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `statusMessage` | This `string` property is used to set the response status
    message. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `writeHead(code, msg, headers)` | This method is used to set the status code
    and, optionally, the status message and response headers. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `write(data)` | This method writes data to the response body, which is expressed
    as a `string` or a `Buffer`. This method accepts optional arguments that specify
    the encoding for the data and a callback function that is invoked when the operation
    is complete. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `end()` | This method tells Node.js that the response is complete and can
    be sent to the client. The method can be invoked with an optional `data` argument,
    which will be added to the response body, an encoding for the data, and a callback
    function that will be invoked when the response has been sent. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: The basic approach to generating a response is to set the status code and status
    message, define any headers that will help the client process the response, write
    the data for the body – if there is one – and then send the response to the client.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5.7* inspects the requests that are received to determine how the
    features provided by the `ServerResponse` class are used to create a response.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.7: Generating HTTP responses in the handler.ts file in the src folder'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example generates three different responses. For requests that don’t specify
    the HTTP GET method or request `/favicon.ico`, the status code is set to 404,
    which tells the browser the requested resource doesn’t exist, the human-readable
    status message is set to `Not Found`, and the `end` method is called to complete
    the request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: For all other requests, the status code is set to 200, indicating a successful
    response and the status message is set to `OK`. The query component of the request
    URL is checked to see if there is a `keyword` parameter and, if there is, the
    value is included in the response body.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I use the `return` keyword after calling the `end` method. This
    is not a requirement, but it is an error to set headers or write data after the
    `end` method has been called, and explicitly returning from the function avoids
    this problem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000/favicon.ico`, `http://localhost:5000?keyword=World`,
    and `http://localhost:5000` and you will see the responses shown in *Figure 5.2*.
    (The browser usually requests the `favicon.ico` file behind the scenes, but requesting
    it explicitly makes it easier to see the `HTTP 404` response.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_02.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Generating HTTP responses'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Supporting HTTPS requests
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most web applications use HTTPS, where HTTP requests are sent over an encrypted
    network connection using the TLS/SSL protocol. Using HTTPS ensures that the request
    and response cannot be inspected as they traverse public networks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Supporting SSL requires a certificate that establishes the identity of the server
    and is used as the basis for the encryption that secures HTTPS requests. For this
    chapter, I am going to use a self-signed certificate, which is sufficient for
    development and testing, but should not be used for deployment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: See [https://letsencrypt.org](https://letsencrypt.org) if you want a certificate
    for deployment. The Let’s Encrypt service is supported by a non-profit organization
    and offers free certificates suitable for use with HTTPS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Creating the self-signed certificate
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to create a self-signed certificate is to use the OpenSSL package,
    which is an open-source toolkit for security-related tasks. The OpenSSL project
    can be found at [https://www.openssl.org](https://www.openssl.org) and OpenSSL
    is part of many popular Linux distributions. A list of binaries and installers,
    including installers for Windows, can be found at [https://wiki.openssl.org/index.php/binaries](https://wiki.openssl.org/index.php/binaries).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the Git client includes OpenSSL in the `usr/bin` folder (`C:\Program
    Files\Git\usr\bin` on Windows), which can be used to create self-signed certificates
    without needing to install the OpenSSL package.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the OpenSSL executable is in your command prompt path and run the
    command shown in *Listing 5.8* in the `webapp` folder, entering the entire command
    on one line.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.8: Generating a self-signed certificate'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command prompts for the details that will be included in the certificate.
    Press the *Enter* key to select the default value for each option:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The details don’t matter because the certificate will be used only for development.
    When the command completes, there will be two new files in the `webapp` folder:
    the `cert.pem` file (which contains the self-signed certificate) and the `key.pem`
    file (which contains the private key for the certificate).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTPS requests
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to use the API provided by Node.js to receive HTTPS requests,
    as shown in *Listing 5.9*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.9: Handling HTTPS requests in the server.ts file in the src folder'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The process for receiving HTTPS requests is similar to regular HTTP, to the
    extent that the function for creating an HTTPS server is named `createServer`,
    which is the same name used for HTTP. To use both versions of the `createServer`
    function in the same code file, I have used an alias in the `import` statement,
    like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This statement imports the `createServer` function from the `https` module and
    the `as` keyword is used to assign a name that doesn’t conflict with other imports.
    In this case, the name I have chosen is `createHttpsServer`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'A configuration object is required to specify the certificate files that were
    created in the previous section with properties named `key` and `cert`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `key` and `cert` properties can be assigned `string` or `Buffer` values.
    I use the `readFileSync` functions from the `fs` module to read the contents of
    the `key.pem` and `cert.pem` files, which produces `Buffer` values that contain
    byte arrays.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding synchronous file reads**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 4*, I explained that it can make sense to use blocking operations
    when you know that there is no other work to be performed by the main thread.
    In this case, I need to read the contents of the `key.pem` and `cert.pem` files
    as part of the application startup. There is little benefit to using a callback
    or a promise because I need the contents of those files to configure Node.js to
    listen for HTTPS requests and using non-blocking operations produces code like
    this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code shows you *can* read the files using the non-blocking `readFile` function,
    but the nested callbacks are harder to make sense of. Promises don’t help either
    because the `await` keyword can only be used within functions, which means the
    `then` syntax demonstrated in *Chapter 4* must be used.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: It is important to avoid blocking the main thread in almost every situation,
    but there are a few occasions when it doesn’t matter, and non-blocking features
    are less useful.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many configuration options available, described at [https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener](https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener),
    but the `key` and `cert` options are enough to get started. The configuration
    object is passed to the `createServer` function, which I have aliased as `createHttpsServer`
    in this example, and the `listen` method is called on the result to start listening
    for HTTPS requests:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Open a web browser and request `https://localhost:5500`, which will send an
    HTTPS request to the port on which Node.js has been configured to listen. Browsers
    will display warnings for self-signed certificates, and you will typically have
    to confirm you want to proceed, as shown in *Figure 5.3*, which shows the warning
    presented by Chrome.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_03.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Accepting a self-signed certificate'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is still listening for regular HTTP requests on port `5000`, which you
    can confirm by requesting `http://localhost:5000`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Detecting HTTPS requests
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js API uses the `IncomingMessage` and `ServerResponse` classes for
    both HTTP and HTTPS requests, which means that the same handler function can be
    used for both request types. However, it can be useful to know which kind of request
    is being processed so that different responses can be generated, as shown in *Listing
    5.10*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.10: Detecting HTTPS requests in the handler.ts file in the src folder'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `socket` property defined by the `IncomingMessage` class will return an
    instance of the `TLSSocket` class for secure requests and this class defines an
    `encrypted` property that always returns `true`. Checking if this property exists
    allows HTTPS and HTTP connections to be identified so that different responses
    can be produced.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: A common deployment pattern for Node.js is to use a proxy that receives HTTPS
    requests from clients and fans them out to Node.js servers using plain HTTP. In
    this situation, you can usually check the `X-Forwarded-Proto` request header,
    which proxies use to pass on details of the encryption used by the client. See
    [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto)
    for details.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000` and `https://localhost:5500`
    and you will see the responses shown in *Figure 5.4*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_04.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Identifying HTTPS requests'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting insecure requests
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTPS has become the preferred way to offer web functionality and it is common
    practice to respond to regular HTTP requests with a response that directs the
    client to use HTTPS instead, as shown in *Listing 5.11*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.11: Redirecting HTTP requests in the handler.ts file in the src folder'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The new handler uses the `writeHead` method to set the status code to `302`,
    which denotes a redirection, and sets the `Location` header, which specifies the
    URL the browser should request instead. *Listing 5.12* applies the new handler
    so that it is used to generate responses for all HTTP requests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.12: Applying a handler in the server.ts file in the src folder'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you use the browser to request `http://localhost:5000`, the response sent
    by the new handler will cause the browser to request `https://localhost:5500`.
    If you examine the network connections made by the browser in the *F12* developer
    tools window, you will see the redirection response and the subsequent HTTPS request,
    as shown in *Figure 5.5*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**Using HTTP Strict Transport Security (HSTS)**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting HTTP requests to an HTTPS URL means that the initial communication
    between the client and server is unencrypted, which presents the potential for
    the HTTP request to be hijacked by a man-in-the-middle attack that redirects clients
    to a malicious URL instead. The **HTTP Strict Transport Security** (**HSTS**)
    header can be used to tell browsers not to only use HTTPS requests for a domain.
    See [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)
    for details.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_05.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Redirecting HTTP requests'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding HTTP/2**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: All the examples in this chapter use HTTP/1.1, which tends to be the default
    for Node.js web application development.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2 is an update to the HTTP protocol that is intended to improve performance.
    HTTP/2 uses a single network connection to interleave multiple requests from the
    client, sends headers in a compact binary format, and allows the server to “push”
    content to the client before it is requested. Node.js provides support for HTTP/2
    in the `http2` module and even includes a compatibility API that uses the approach
    shown in this chapter to handle HTTP/1.1 and HTTP/2 requests with the same code.
    (See [https://nodejs.org/dist/latest-v20.x/docs/api/http2.html](https://nodejs.org/dist/latest-v20.x/docs/api/http2.html)
    for details.)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: But HTTP/2 isn’t an automatic choice for Node.js projects, even though it is
    more efficient. That’s because HTTP/2 benefits applications that have a large
    volume of requests, and applications of that size use a proxy to receive requests
    and fan them out to multiple Node.js servers. The proxy receives HTTP/2 requests
    from clients but communicates with Node.js using HTTP/1.1 requests because the
    HTTP/2 features don’t have much impact inside the data center. You can see an
    example of this type of deployment in *Part 3* of this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: For applications that don’t use a proxy, the volume of requests is small enough
    that the efficiencies of HTTP/2 don’t justify the additional complexity that HTTP/2
    adds to development, such as requiring encryption for all requests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Most Node.js applications still use HTTP/1.1 and you can see this reflected
    in the way that open-source packages for Node.js, such as the Express package
    I use in the next section, remain hugely popular even though they don’t support
    HTTP/2.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party enhancements
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API that Node.js provides for HTTP and HTTPS is comprehensive but can produce
    verbose code that is difficult to read and maintain. One of the joys of JavaScript
    development is the huge range of open-source packages that are available and there
    are many packages that are built on the Node.js API to simplify request handling.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The most popular of these packages is Express. Run the commands shown in *Listing
    5.13* in the `webapp` folder to install the Express package and the TypeScript
    types for Express in the example project.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you don’t like the way that Express works because there are plenty
    of other packages available that do similar things. A quick web search for Express
    alternatives will give you several options to consider. Bear in mind when choosing
    a package that, as I noted in *Chapter 2*, not all JavaScript packages receive
    long-term support from their creators, and it is worth considering how widely
    a package has been adopted before using it in a project.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.13: Installing the Express package'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Express has many features, which are described in detail at [https://expressjs.com](https://expressjs.com),
    but the two that are most useful are the request router and the enhanced request/response
    types, both of which are described in the sections that follow.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Using the Express router
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Request handler functions that use the Node.js API mix the statements that inspect
    requests with the code that generates responses. A new branch of code is required
    every time a new URL is supported by the application, as shown in *Listing 5.14*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.14: Supporting a new URL in the handler.ts file in the src folder'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each new addition makes the code more complex and increases the chances of a
    coding error that either doesn’t match the right requests or generates the wrong
    response.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The Express *router* solves this problem by separating request matching from
    generating responses. The first step towards using the Express router is to refactor
    the existing request handler code into separate functions that generate responses
    without the statements that inspect requests, as shown in *Listing 5.15*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.15: Refactoring in the handler.ts file in the src folder'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The responses are generated in the same way as earlier examples, but each response
    is created by a separate handler function, without the code that matches requests.
    The next step is to use the Express router to match requests and select one of
    the handlers from *Listing 5.15* to produce a result, as shown in *Listing 5.16*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.16: Using the Express router in the server.ts file in the src folder'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `Express` package contains a default export, which is a function named
    `express`, and this is why the new `import` statement looks different:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `express` function is invoked to create an `Express` object, which provides
    methods for mapping requests to handler functions. *Table 5.9* describes the most
    useful methods, most of which incorporate the HTTP method into the matching process.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.9: Useful Express methods'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| This method routes HTTP GET requests that match the path to the specified
    handler function. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| This method routes HTTP POST requests that match the path to the specified
    handler function. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| This method routes HTTP PUT requests that match the path to the specified
    handler function. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| This method routes HTTP DELETE requests that match the path to the specified
    handler function. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| This method routes all requests that match the path to the specified handler
    function. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| This method adds a middleware component, which is able to inspect and intercept
    all requests. Later chapters contain examples that use middleware. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: 'I am only interested in GET requests in this chapter, and so I used the `get`
    method to specify URL paths and the functions that will generate responses:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These statements are *routes*, and the URLs are specified as patterns that
    allow wildcards, such as the `*` character in this route:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This matches any GET request and routes it to the `defaultHandler` function.
    Express matches requests to routes in the order in which they are defined, and
    so this is a catch-all route that will be applied if requests are not matched
    by the other routes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the methods described in *Table 5.9*, the `Express` object is
    also a handler function that can be used with the Node.js `createServer` functions
    defined in the `http` and `https` modules:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Express processes all the HTTP requests that Node.js receives and routes them
    to the appropriate handler.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Using the request and response enhancements
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to routing, Express provides enhancements to the `IncomingRequest`
    and `ServerResponse` objects that are passed to handler functions. The object
    that represents the HTTP request is named `Request` and it extends the `IncomingRequest`
    type. The most useful `Request` enhancements are described in *Table 5.10*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.10: Useful Express request enhancements'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| `hostname` | This property provides convenient access to the value of the
    `hostname` header. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| `params` | This property provides access to the route parameters, which are
    described in the *Using Express route parameters* section of this chapter. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| `path` | This property returns the path component of the request URL. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| `protocol` | This property returns the protocol used to make the request,
    which will be either `http` or `https`. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| `query` | This property returns an object whose properties correspond to
    the query string parameters. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| `secure` | This property returns `true` if the request has been made using
    HTTPS. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| `body` | This property is assigned the parsed contents of the request body,
    as demonstrated in *Chapter 6*. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: The object that Express uses to represent the HTTP response is named `Response`
    and it extends the `ServerResponse` type. The most useful basic `Response` enhancements
    are described in *Table 5.11*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.11: Useful basic Express response enhancements'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| `redirect(code, path)``redirect(path)` | This method sends a redirection
    response. The `code` argument is used to set the response status code and message.
    The `path` argument is used to set the value of the `Location` header. If the
    `code` argument is omitted, then a temporary redirection, with status code `302`,
    is sent. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| `send(data)` | This method is used to send a response to the server. The
    status code is set to `200`. This method sets response headers to describe the
    content, including the `Content-Length` and `Content-Type` headers. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| `sendStatus(code)` | This method is used to send a status code response and
    will automatically set the status message for well-known status codes, so that
    a status code of `200` will lead to the **OK** message being used, for example.
    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: Other Express enhancements relate to features described in later chapters, but
    the basic additions described in *Table 5.10* and *Table 5.11* are enough to simplify
    the way that responses are generated by the example application, as shown in *Listing
    5.17*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 5.17: Using the Express enhancements in the handler.ts file in the
    src folder'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Express automatically parses the request URL and makes its parts accessible
    through the `Response` properties described in *Table 5.10*, which means I don’t
    have to parse the URL explicitly. The convenient `secure` property means that
    I can remove the `isHttps` function.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The `Response` methods described in *Table 5.11* reduce the number of statements
    required to produce responses. The `send` method, for example, takes care of setting
    the response status code, sets some useful headers, and calls the `end` method
    to tell Node.js that the response is complete.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: If you request `https://localhost:5500/newurl` and `https://localhost:5500?keyword=Express`,
    you will see the responses shown in *Figure 5.6*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Your browser may use a different font to display these responses, which happens
    because the `Response` methods used to generate responses in *Listing 5.17* set
    the `Content-Type` header in the response to `text/html`. This header was not
    set in previous examples, and it alters the way that most browsers display the
    content.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_05_06.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Generating responses using Express'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Using Express route parameters
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to understand that Express doesn’t do anything magical and its
    features are built on those provided by Node.js described earlier in the chapter.
    The value of Express is that it makes the Node.js API easier to consume, with
    the result that the code is easier to understand and maintain.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: One especially useful feature that Express provides is specifying *route parameters*,
    which extract values from URL paths when matching requests and make them easily
    accessible through the `Response.params` property, as shown in *Listing 5.18*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Express 提供的一个特别有用的功能是指定 *路由参数*，当匹配请求时从 URL 路径中提取值，并通过 `Response.params` 属性使它们易于访问，如
    *列表 5.18* 所示。
- en: 'Listing 5.18: Using route parameters in the server.ts file in the src folder'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.18：在 src 文件夹中的 server.ts 文件中使用路由参数
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The modified route matches requests when the path begins with `/newurl`. The
    second segment in the URL path is assigned to a route parameter named `message`.
    The parameter is denoted by the colon (the `:` character). For the URL path `/newurl/London`,
    for example, the `message` parameter will be assigned the value `London`. The
    question mark (the `?` character) denotes this is an optional parameter, which
    means the route will match requests even if there is no second URL segment.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的路由在路径以 `/newurl` 开头时匹配请求。URL 路径的第二部分被分配给名为 `message` 的路由参数。参数由冒号（`:` 字符）表示。例如，对于
    URL 路径 `/newurl/London`，`message` 参数将被分配值 `London`。问号（`?` 字符）表示这是一个可选参数，这意味着即使没有第二个
    URL 段，路由也会匹配请求。
- en: Route parameters are an effective way to increase the range of URLs that a route
    can match. *Listing 5.19* uses the `Response.params` property to get the value
    of the `message` parameter and incorporate it into the response.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 路由参数是增加路由可以匹配的 URL 范围的有效方法。*列表 5.19* 使用 `Response.params` 属性获取 `message` 参数的值并将其纳入响应中。
- en: 'Listing 5.19: Consuming a route parameter in the handler.ts file in the src
    folder'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.19：在 src 文件夹中的 handler.ts 文件中消耗路由参数
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Use a browser to request `https://localhost:5500/newurl/London` and you will
    see the response shown in *Figure 5.7*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求 `https://localhost:5500/newurl/London`，你将看到 *图 5.7* 中显示的响应。
- en: '![](img/B21959_05_07.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_05_07.png)'
- en: 'Figure 5.7: Using a route parameter'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：使用路由参数
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, I described the API features that Node.js provides for receiving
    HTTP requests and producing responses, which is the backbone of server-side web
    application development:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了 Node.js 提供的用于接收 HTTP 请求和生成响应的 API 功能，这是服务器端 Web 应用程序开发的基础：
- en: The Node.js API provides support for receiving HTTP and HTTPS requests.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js API 提供了接收 HTTP 和 HTTPS 请求的支持。
- en: Node.js emits events when requests are received and invokes callback functions
    to handle those requests.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当收到请求时，Node.js 会发出事件并调用回调函数来处理这些请求。
- en: Some additional work, such as parsing URLs, is generally required when using
    the Node.js API.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 Node.js API 时，通常需要执行一些额外的工作，例如解析 URL。
- en: Third-party packages, such as Express, build on the Node.js APIs to streamline
    request processing and simplify the code that generates responses.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方包，例如 Express，基于 Node.js API 来简化请求处理并简化生成响应的代码。
- en: In the next chapter, I describe the features Node.js provides for reading and
    writing data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将描述 Node.js 提供的用于读取和写入数据的功能。
