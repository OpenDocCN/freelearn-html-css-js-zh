<html><head></head><body>
<div><h1 class="chapternumber">4</h1>
<h1 class="chaptertitle" id="_idParaDest-77">Understanding Node.js Concurrency</h1>
<p class="normal1">Server-side web development is characterized by processing large volumes of HTTP requests as quickly and efficiently as possible. JavaScript is different from other languages and platforms because it has a single thread of execution, which means that HTTP requests are processed one at a time. Behind the scenes, however, there is a lot more going on, and in this chapter, I explain why the JavaScript approach is unusual, how the Node.js API performs work on behalf of JavaScript code, and how additional execution threads can be created to handle computationally intense tasks. <em class="italic">Table 4.1</em> puts JavaScript concurrency in context.</p>
<p class="packt_figref">Table 4.1: Putting Node.js concurrency in context</p>
<table class="table-container" id="table001-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What is it?</p>
</td>
<td class="table-cell">
<p class="normal">Concurrency is the execution of multiple threads of code. Node.js has support for concurrency, but it hides the details from the developer.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why is it useful?</p>
</td>
<td class="table-cell">
<p class="normal">Concurrency allows servers to achieve greater throughput by accepting and processing multiple HTTP requests simultaneously. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How is it used?</p>
</td>
<td class="table-cell">
<p class="normal">Node.js has a single thread of execution for JavaScript code called the main thread, and it relies on events to coordinate the work required to process different threads of work. The Node.js API makes extensive use of concurrent execution in its APIs, but this is largely hidden from the developer.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">Care must be taken not to block the main thread; otherwise, performance will be impaired. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">No. The concurrency model is core to Node.js and understanding it is essential to create web applications that scale economically. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 4.2</em> summarizes the chapter.</p>
<p class="packt_figref">Table 4.2: Chapter summary</p>
<table class="table-container" id="table002-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Perform tasks concurrently</p>
</td>
<td class="table-cell">
<p class="normal">Use the Node.js API and handle events with callback functions or promises.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">10-15</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Wrap code as promises or callbacks</p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">promisify</code> and <code class="inlinecode">callbackify</code> functions.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">16, 17</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Avoid blocking the main thread for simple tasks</p>
</td>
<td class="table-cell">
<p class="normal">Break up work into smaller chunks that can be interleaved with other work.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">21</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Avoid blocking the main thread for complex tasks</p>
</td>
<td class="table-cell">
<p class="normal">Use worker threads.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">22-27</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-78">Preparing for this chapter</h1>
<p class="normal1">To create the project for this chapter, open a new command prompt, navigate to a convenient location, and create a folder named <code class="inlinecode">webapp</code>. Run the command shown in <em class="italic">Listing 4.1</em> in the <code class="inlinecode">webapp</code> folder to create the <code class="inlinecode">package.json</code> file.</p>
<p class="packt_figref">Listing 4.1: Initializing the project</p>
<pre class="programlisting1"><code class="hljs-con">npm init -y
</code></pre>
<p class="normal">Run the commands shown in <em class="italic">Listing 4.2</em> in the <code class="inlinecode">webapp</code> folder to install the packages that will be used to compile TypeScript files and monitor files for changes.</p>
<div><p class="normal"><strong class="screentext">Tip</strong> </p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 4.2: Installing tool packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install --save-dev typescript@5.2.2
npm install --save-dev tsc-watch@6.0.4
</code></pre>
<p class="normal">Run the commands shown in <em class="italic">Listing 4.3</em> in the <code class="inlinecode">webapp</code> folder to add the packages that will configure the TypeScript compiler for Node.js projects and describe the types used by the Node.js API.</p>
<p class="packt_figref">Listing 4.3. Adding the Compiler Configuration and Type Packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install --save-dev @tsconfig/node20
npm install --save @types/node@20.6.1
</code></pre>
<p class="normal">To configure the TypeScript compiler, create a file named <code class="inlinecode">tsconfig.json</code> in the <code class="inlinecode">webapp</code> folder with the contents shown in <em class="italic">Listing 4.4</em>.</p>
<p class="packt_figref">Listing 4.4: The contents of the tsconfig.json file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">{
   "extends": "@tsconfig/node20/tsconfig.json",
    "compilerOptions": {                      
        "rootDir": "src",  
        "outDir": "dist",                                   
    }
}
</code></pre>
<p class="normal">This configuration file extends the one provided by the TypeScript developers for working with Node.js. The TypeScript files will be created in the <code class="inlinecode">src</code> folder, and the compiled JavaScript will be written to the <code class="inlinecode">dist</code> folder.</p>
<p class="normal">Open the <code class="inlinecode">package.json</code> file and add the command shown in <em class="italic">Listing 4.5</em> to the <code class="inlinecode">script</code> section to define the command that will start the build tools.</p>
<p class="packt_figref">Listing 4.5: Adding a Script Command in the package.json File in the webapp Folder</p>
<pre class="programlisting"><code class="hljs-code">{
  "name": "webapp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    <strong class="screentext">"start": "tsc-watch --onsuccess \"node dist/server.js\""</strong>
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "tsc-watch": "^6.0.4",
    "typescript": "^5.2.2"
  }
}
</code></pre>
<h2 class="heading1" id="_idParaDest-79">Creating a simple web application</h2>
<p class="normal1">With the packages <a id="_idIndexMarker176" class="calibre3"/>and build tools in place, it is time to create a simple web application. Create the <code class="inlinecode">webapp/src</code> folder and add to it a file named <code class="inlinecode">handler.ts</code> with the content shown in <em class="italic">Listing 4.6</em>.</p>
<p class="packt_figref">Listing 4.6: The contents of the handler.ts file in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    res.end("Hello World");
};
</code></pre>
<p class="normal">This file defines the code that will process HTTP requests. I describe the HTTP features that Node.js provides in <em class="italic">Chapter 5</em>, but for this chapter, it is enough to know that the HTTP request is represented by an <code class="inlinecode">IncomingMessage</code> object, and the response is created using the <code class="inlinecode">ServerResponse</code> object. The code in <em class="italic">Listing 4.6</em> responds to all requests with a simple <code class="inlinecode">Hello World</code> message.</p>
<p class="normal">Next, add a file named <code class="inlinecode">server.ts</code> to the <code class="inlinecode">src</code> folder with the content shown in <em class="italic">Listing 4.7</em>.</p>
<p class="packt_figref">Listing 4.7: The contents of the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import { handler } from "./handler";
const port = 5000;
const server = createServer(handler);
server.listen(port, function() {
    console.log(`Server listening on port ${port}`);
});
</code></pre>
<p class="normal">This <a id="_idIndexMarker177" class="calibre3"/>code creates a simple HTTP server that listens for HTTP requests on port 5000 and processes them using the function defined in the <code class="inlinecode">handler.ts</code> file in <em class="italic">Listing 4.6</em>.</p>
<p class="normal">Add a file named <code class="inlinecode">data.json</code> to the <code class="inlinecode">webapp</code> folder with the content shown in <em class="italic">Listing 4.8</em>. This file will be used later in the chapter.</p>
<p class="packt_figref">Listing 4.8: The contents of the data.json file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "products": [
        { "id": 1, "name": "Kayak", "category": "Watersports",
            "description": "A boat for one person", "price": 275 },
        { "id": 2, "name": "Lifejacket", "category": "Watersports",
            "description": "Protective and fashionable", "price": 48.95 },
        { "id": 3, "name": "Soccer Ball", "category": "Soccer",
            "description": "FIFA-approved size and weight",
            "price": 19.50 },
        { "id": 4, "name": "Corner Flags", "category": "Soccer",
            "description": "Give your playing field a professional touch",
            "price": 34.95 }
    ]
}
</code></pre>
<p class="normal">Run the commands shown in <em class="italic">Listing 4.9</em> in the <code class="inlinecode">webapp</code> folder to start the watcher that will monitor and compile TypeScript files and execute the JavaScript that is produced.</p>
<p class="packt_figref">Listing 4.9: Starting the project</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">The <code class="inlinecode">server.ts</code> file in the <code class="inlinecode">src</code> folder will be compiled to produce a pure JavaScript file named <code class="inlinecode">server.js</code> in the <code class="inlinecode">dist</code> folder, which will produce the following output when it is executed:</p>
<pre class="programlisting1"><code class="hljs-con">Server listening on port 5000
</code></pre>
<p class="normal">Open a <a id="_idIndexMarker178" class="calibre3"/>web browser and navigate to <code class="inlinecode">http://localhost:5000</code> to send a request to the HTTP server, which will produce the response shown in <em class="italic">Figure 4.1</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.1: Running the example application</p>
<h1 class="heading" id="_idParaDest-80">Understanding (simplified) server code execution</h1>
<p class="normal1">A disclaimer <a id="_idIndexMarker179" class="calibre3"/>is required: this chapter omits some details, is a little loose with some explanations, and blurs the lines between some fine details.</p>
<p class="normal">The topics covered in this chapter are complex, with endless nuance and detail and terminology that means different things on different platforms. And so, with brevity in mind, I have focused on what’s important for JavaScript web application development, even though that means glossing over some topics.</p>
<p class="normal">Concurrency is a<a id="_idIndexMarker180" class="calibre3"/> genuinely fascinating subject, and it can be a rewarding area of research. But before digging into the details, bear in mind that to be an effective JavaScript developer, you only need a basic overview of concurrency – like the one in this chapter.</p>
<h2 class="heading1" id="_idParaDest-81">Understanding multi-threaded execution</h2>
<p class="normal1">Server-side web applications<a id="_idIndexMarker181" class="calibre3"/> need to be able to process many HTTP requests simultaneously to scale up economically so that a small amount of server capacity can be used to support a large number of clients. </p>
<p class="normal">The conventional approach is to take advantage of the multi-threaded features of modern server hardware by creating a pool of handler threads. When a new HTTP request arrives, it is added to a queue where it waits until one of the threads is available to process it. The thread processes the request, sends the response back to the client, and then returns to the queue for the next request.</p>
<p class="normal">The server hardware can execute multiple threads simultaneously, as illustrated in <em class="italic">Figure 4.2</em>, so that a large volume of requests can be received and processed concurrently.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.2: Handling HTTP requests concurrently</p>
<p class="normal">This <a id="_idIndexMarker182" class="calibre3"/>approach makes full use of the server hardware, but it requires developers to consider how requests might interfere with each other. A common problem is that one handler thread modifies data as it is being read by another thread, producing an unexpected result.</p>
<p class="normal">To avoid this kind of issue, most programming languages include keywords that are used to restrict interactions between threads. The details vary, but keywords like <code class="inlinecode">lock</code> and <code class="inlinecode">synchronize</code> are used to ensure that threads safely use shared resources and data by creating protected regions of code that can only be executed by one thread at a time.</p>
<p class="normal">Writing code that uses threads is a balance of safety and performance. Protected regions of code are potential performance bottlenecks, and if protections are applied too widely, then performance suffers and the number of requests that can be processed concurrently falls. However, requests may interfere with one another and produce unexpected results if protections are applied too sparsely.</p>
<h3 class="heading2" id="_idParaDest-82">Understanding blocking and non-blocking operations</h3>
<p class="normal1">In most server-side applications, the<a id="_idIndexMarker183" class="calibre3"/> thread processing an HTTP request spends most of its time waiting. This<a id="_idIndexMarker184" class="calibre3"/> can be waiting for a database to produce a result, waiting for the next chunk of data from a file, or waiting for access to a protected region of code.</p>
<p class="normal">When a thread is waiting, it is said to be <em class="italic">blocked</em>. A blocked thread is unable to do any other work until the <a id="_idIndexMarker185" class="calibre3"/>operation it is waiting for has been completed, during which time the capacity of the server to process requests is reduced. In busy applications, there is a constant flow of new requests arriving, and having threads tied up doing nothing leads to queues of requests waiting to be processed and reduced overall throughput.</p>
<p class="normal">One solution is <a id="_idIndexMarker186" class="calibre3"/>to use <em class="italic">non-blocking</em> operations, also known as <em class="italic">asynchronous</em> operations. These<a id="_idIndexMarker187" class="calibre3"/> terms can be confusing. The best way to understand them is with a real-world example: a pizza restaurant. </p>
<p class="normal">Imagine that, after <a id="_idIndexMarker188" class="calibre3"/>taking an order, an employee in the restaurant went into the kitchen, assembled your pizza, put it in the oven, stood there waiting for it to cook for 10 minutes, and then served it to you. This is the blocking – or synchronous – approach to preparing pizza. Customers will be happy if they enter the restaurant when there is an employee available to take an order because they will get their pizza in the shortest amount of time. But no one else is happy. The other customers in the queue aren’t happy because they have to wait in the queue while pizzas for all of the customers ahead of them are assembled, cooked, and served, at which point an employee will be available to make their pizza. The restaurant owner is unhappy because the pizza throughput is equal to the number of employees, who spend most of their time waiting for pizza to cook.</p>
<p class="normal">There is a more sensible approach. One employee – let’s name them Bob – is given the job of monitoring the oven. The other employees take orders, assemble the pizzas, and put them in the oven just as before, but rather than waiting for them to cook, they ask Bob to tell them when the pizza is cooked.</p>
<p class="normal">While Bob watches the pizzas in the oven, the employees can carry on working, taking the order of the next customer in the queue, preparing the next pizza, and so on. Bob can watch lots of pizzas, so the limit to the number of pizzas that can be produced is the size of the oven and not the number of employees.</p>
<p class="normal">Cooking a pizza has become a non-blocking operation for everyone except Bob. There is no way around waiting for the oven, but the performance of the restaurant is improved by making one person do all the waiting. Everyone is happy.</p>
<p class="normal">Well, almost. The <a id="_idIndexMarker189" class="calibre3"/>owner is happy because the restaurant produces <a id="_idIndexMarker190" class="calibre3"/>more pizzas. The customers in the queue are happy because employees can start working on their pizza while Bob is watching earlier orders. But individual orders may take longer: Bob may tell another employee that a pizza is ready, but they won’t be able to serve it if they are busy with another customer. The overall restaurant performance improves, but individual orders may take longer to complete.</p>
<p class="normal">The same approach can be taken with HTTP requests, as shown in <em class="italic">Figure 4.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.3: Freeing request handlers from a blocking operation</p>
<p class="normal">Instead of waiting for an operation to complete, handler threads rely on a monitor thread while they continue to process requests from the queue. When the blocking operation has finished, the monitor thread puts the request back in the queue so that a handler thread can continue processing the request.</p>
<p class="normal">The process of handing off an operation for monitoring is usually integrated into the API used to write web applications, so that performing a read from a file, for example, automatically releases the handler thread so it can do other work and can be trusted to put <a id="_idIndexMarker191" class="calibre3"/>the request in the queue for processing when the file read operation is complete.</p>
<p class="normal">It is important to <a id="_idIndexMarker192" class="calibre3"/>understand that the terms <em class="italic">non-blocking</em> and <em class="italic">asynchronous</em> are from the perspective of the handler thread. The operations still take time to complete, but the handler thread can do other work during that period. There are still blocking threads, but they are not the ones responsible for processing HTTP requests, which are the threads we care about the most.</p>
<h2 class="heading1" id="_idParaDest-83">Understanding JavaScript code execution</h2>
<p class="normal1">JavaScript’s<a id="_idIndexMarker193" class="calibre3"/> origins as a browser-based language have shaped the way that JavaScript code is written and executed. JavaScript was originally used to provide user interaction with HTML elements. Each type of element <a id="_idIndexMarker194" class="calibre3"/>defines <em class="italic">events</em> that describe the different ways the user can interact with that element. A button element, for example, has events for when the user clicks the button, moves the pointer over the button, and so on. </p>
<p class="normal">The programmer writes JavaScript <a id="_idIndexMarker195" class="calibre3"/>functions, known as <em class="italic">callbacks</em>, and uses the browser’s API to associate those functions with specific events on elements. When the browser detects an event, it adds the callback to a queue so it can be executed by the JavaScript runtime.</p>
<p class="normal">The JavaScript runtime has a single <a id="_idIndexMarker196" class="calibre3"/>thread – called the <em class="italic">main thread</em> – that is responsible for executing the callbacks. The main thread runs in a loop, taking callbacks from the queue and executing them, which is referred to as the JavaScript <em class="italic">event loop</em>. The <a id="_idIndexMarker197" class="calibre3"/>event loop is how the native code of the browser, which is written for a specific operating system, interacts with the JavaScript code, which runs on any compatible runtime. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The event loop is more complicated but the idea of a queue of callbacks is close enough for effective JavaScript web development. The details are worth exploring if you, like me, find this sort of thing interesting. A good place to start is <a href="https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick" class="calibre3">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick</a>.</p>
</div>
<p class="normal">Events often <a id="_idIndexMarker198" class="calibre3"/>occur in clusters, such as when the pointer moves across several elements, and so the queue can contain multiple callbacks waiting to be executed, as shown in <em class="italic">Figure 4.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.4: The callback queue</p>
<p class="normal">Using a single thread means that any operation in a callback that takes time to complete causes the application to freeze as callbacks queue up waiting to be processed. To help manage this issue, many browser API features are non-blocking and use the callback pattern to deliver their results.</p>
<p class="normal">Over the years, features have been added to the JavaScript language and the browser APIs, but the event loop and callback functions are used to execute JavaScript. The API the browser provides for HTTP requests, for example, defines a series of events that describe the request lifecycle, and these events are handled with callback functions, as shown in <em class="italic">Figure 4.5</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.5: Results from the browser API are processed with JavaScript callback functions</p>
<p class="normal">Behind the scenes, the browser uses native threads to perform the HTTP request and wait for the response, which is then passed to the JavaScript runtime using a callback.</p>
<p class="normal">The JavaScript runtime<a id="_idIndexMarker199" class="calibre3"/> only ever executes one callback, so the JavaScript language doesn’t need keywords like <code class="inlinecode">lock</code> and <code class="inlinecode">synchronize</code>. JavaScript code interacts with the browser through an API that hides away the implementation details and receives results consistently.</p>
<h2 class="heading1" id="_idParaDest-84">Understanding Node.js code execution</h2>
<p class="normal1">Node.js retains <a id="_idIndexMarker200" class="calibre3"/>the main thread and the event loop, which means that server-side code is executed in the same way as client-side JavaScript. For HTTP servers, the main thread is the only request handler, and callbacks are used to handle incoming HTTP connections. The example application demonstrates the use of a callback to handle an HTTP request:</p>
<pre class="programlisting"><code class="hljs-code">...
const server = createServer(<strong class="screentext">handler</strong>);
...
</code></pre>
<p class="normal">The callback function passed to the <code class="inlinecode">createServer</code> function will be invoked when Node.js receives an HTTP connection. The function defines parameters that represent the request that has been received and the response that will be returned to the client:</p>
<pre class="programlisting"><code class="hljs-code">...
export const handler = (<strong class="screentext">req: IncomingMessage, res: ServerResponse</strong>) =&gt; {
    res.end("Hello World");
};
...
</code></pre>
<p class="normal">I describe the API Node.js provides for HTTP in <em class="italic">Chapter 5</em>, but the callback function uses its parameters to prepare the response that will be sent to the client. The details of how Node.js receives HTTP requests and returns HTTP responses are hidden away in native code, as shown in <em class="italic">Figure 4.6</em>. </p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.6: Handling HTTP requests in Node.js</p>
<p class="normal">Node.js<a id="_idIndexMarker201" class="calibre3"/> may only have a single handler thread, but the performance can be excellent because modern server hardware is incredibly fast. Even so, a single thread doesn’t take full advantage of the multi-core and multi-processor hardware to which most applications are deployed.</p>
<p class="normal">To scale up, multiple instances of Node.js are started. HTTP requests are received by a load balancer (or ingress controller or primary node, depending on how the application is deployed, as described in <em class="italic">Part 3</em>) and distributed to the Node.js instances, as shown in <em class="italic">Figure 4.7</em>. </p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_07.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.7: Scaling up with multiple Node.js instances</p>
<p class="normal">The individual Node.js instances still have a single JavaScript thread but collectively they can process a higher volume of requests.</p>
<p class="normal">One important consequence of applying the JavaScript execution model to HTTP requests is that blocking the main thread stops all requests from being processed by that Node.js <a id="_idIndexMarker202" class="calibre3"/>instance, creating the same kind of deadlock that can arise in client-side JavaScript. Node.js helps programmers avoid blocking the main thread in two ways: an API that performs many tasks asynchronously, known <a id="_idIndexMarker203" class="calibre3"/>as the <em class="italic">worker pool</em>, and support for starting extra threads to execute blocking<a id="_idIndexMarker204" class="calibre3"/> JavaScript code, known as <em class="italic">worker threads</em>. Both of these features are described in the sections that follow. </p>
<h1 class="heading" id="_idParaDest-85">Using the Node.js API</h1>
<p class="normal1">Node.js replaces <a id="_idIndexMarker205" class="calibre3"/>the API provided by the browser with one that supports common server-side tasks, such as processing HTTP requests and reading files. Behind the scenes, Node.js uses native threads, known as the worker pool, to perform operations asynchronously. </p>
<p class="normal">To demonstrate, <em class="italic">Listing 4.10</em> uses the Node.js API to read the contents of a file. </p>
<p class="packt_figref">Listing 4.10: Using the Node.js API in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">import { readFile } from "fs";</strong>
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    <strong class="screentext">readFile</strong><strong class="screentext">("data.json", (err: Error | null, data: Buffer) =&gt; {</strong>
<strong class="screentext">        if (err == null) {</strong>
<strong class="screentext">            res.end(data, () =&gt; console</strong><strong class="screentext">.log("File sent"));</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            console.log(`Error: ${err.message}`);</strong>
<strong class="screentext">            res.statusCode = 500;</strong>
<strong class="screentext">            res.end</strong><strong class="screentext">();</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    });</strong>
};
</code></pre>
<p class="normal">As its name suggests, the <code class="inlinecode">readFile</code> function reads the contents of a file. Use a web browser to request <code class="inlinecode">http://localhost:5000</code> and you will see the output shown in <em class="italic">Figure 4.8</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_08.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.8: Sending the contents of a file to the client</p>
<p class="normal">The read <a id="_idIndexMarker206" class="calibre3"/>operation is asynchronous and is implemented using a native thread. The contents of the file are passed to a callback function, which sends them to the HTTP client.</p>
<p class="normal">There are three callbacks in the code. The first callback is the one passed to the <code class="inlinecode">createServer</code> function, which is invoked when an HTTP request is received:</p>
<pre class="programlisting"><code class="hljs-code">...
const server = createServer(<strong class="screentext">handler</strong>);
...
</code></pre>
<p class="normal">The second callback is the one passed to the <code class="inlinecode">readFile</code> function, which is invoked when the contents of the file have been read or if an error occurs:</p>
<pre class="programlisting"><code class="hljs-code">...
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    readFile("data.json", (<strong class="screentext">err: Error</strong><strong class="screentext"> | null, data: Buffer) =&gt; {</strong>
<strong class="screentext">if (err == null) {</strong>
<strong class="screentext">            res.end(data, () =&gt; console.log("File sent"));</strong>
<strong class="screentext">        } else</strong><strong class="screentext"> {</strong>
<strong class="screentext">            console.log(`Error: ${err.message}`);</strong>
<strong class="screentext">            res.statusCode = 500;</strong>
<strong class="screentext">            res.end();</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    });</strong>
};
...
</code></pre>
<p class="normal">I used type<a id="_idIndexMarker207" class="calibre3"/> annotations to help describe the way the results from reading the file are presented. The type of the first argument of the callback is <code class="inlinecode">Error | null</code> and is used to indicate the outcome. If the first argument is <code class="inlinecode">null</code>, then the operation has been completed successfully, and the contents of the file will be available in the second argument, whose type is <code class="inlinecode">Buffer</code>. (Buffers are how Node.js represents arrays of bytes.) If the first argument isn’t <code class="inlinecode">null</code>, then the <code class="inlinecode">Error</code> object will provide details of the problem that prevented the file from being read. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">You may see two messages written to the command prompt when you send an HTTP request from a browser. Browsers often request the <code class="inlinecode">favicon.ico</code> file to get an icon that can be displayed in the tab header, and this is the reason why you will sometimes see <code class="inlinecode">File sent</code> appear twice in the output.</p>
</div>
<p class="normal">The third callback is invoked when the data read from the file has been sent to the client:</p>
<pre class="programlisting"><code class="hljs-code">...
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    readFile("data.json", (err: Error | null, data: Buffer) =&gt; {
        if (err == null) {
            res.end(data, <strong class="screentext">() =&gt; console.log("File sent")</strong>);
        } else {
            console.log(`Error: ${err.message}`);
            res.statusCode = 500;
            res.end();
        }
    });
};
...
</code></pre>
<p class="normal">Breaking up <a id="_idIndexMarker208" class="calibre3"/>the process of producing an HTTP response with callbacks means that the JavaScript main thread doesn’t have to wait for the file system to read the contents of the file, and this allows requests from other clients to be processed, as illustrated in <em class="italic">Figure 4.9</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_09.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.9: Breaking down request handling with multiple callbacks</p>
<h2 class="heading1" id="_idParaDest-86">Handling events</h2>
<p class="normal1">Events are <a id="_idIndexMarker209" class="calibre3"/>used to provide notifications that the state of the application has changed and provide an opportunity to execute a callback function to handle that change. Events are used throughout the Node.js API, although there are often convenience features that hide away the details. <em class="italic">Listing 4.11</em> revises the code that listens for HTTP requests to use events directly.</p>
<p class="packt_figref">Listing 4.11: Handling Events in the server.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import { handler } from "./handler";
<strong class="screentext">const port = 5000;</strong>
<strong class="screentext">const server = createServer();</strong>
<strong class="screentext">server.on("</strong><strong class="screentext">request", handler)</strong>
<strong class="screentext">server.listen(port);</strong>
<strong class="screentext">server.on("listening", () =&gt; {</strong>
<strong class="screentext">    console.log(`(Event) Server listening on port ${port}</strong><strong class="screentext">`);</strong>
<strong class="screentext">});</strong>
</code></pre>
<p class="normal">Many of<a id="_idIndexMarker210" class="calibre3"/> the objects created with the Node.js API extend the <code class="inlinecode">EventEmitter</code> class, which denotes a source of events. The <code class="inlinecode">EventEmitter</code> class defines the methods described in <em class="italic">Table 4.3</em> for receiving events.</p>
<p class="packt_figref">Table 4.3: Useful eventemitter methods</p>
<table class="table-container" id="table003-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">on(event, callback)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method registers a <code class="inlinecode">callback</code> to be invoked whenever the specified event is emitted. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">off(event, callback)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method stops invoking the <code class="inlinecode">callback</code> when the specific event is emitted.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">once(event, callback)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method registers a <code class="inlinecode">callback</code> to be invoked the next time the specified event is emitted but not thereafter.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Classes that extend <code class="inlinecode">EventEmitter</code> define events and specify when they will be emitted. The <code class="inlinecode">Server</code> class returned by the <code class="inlinecode">createServer</code> method extends <code class="inlinecode">EventEmitter</code> and it defines two events that are used in <em class="italic">Listing 4.11</em>: the <code class="inlinecode">request</code> and <code class="inlinecode">listening</code> events. The code in <em class="italic">Listing 4.7</em> and <em class="italic">Listing 4.11</em> has the same effect and the only difference is that the <code class="inlinecode">createServer</code> function registers its function argument as a callback for the <code class="inlinecode">request</code> event behind the scenes, while the <code class="inlinecode">listen</code> method registers its function argument as a callback for the <code class="inlinecode">listening</code> event.</p>
<p class="normal">It is important to understand that events are an integral part of the Node.js API and that they can<a id="_idIndexMarker211" class="calibre3"/> be used directly, with the methods described in <em class="italic">Table 4.3</em>, or indirectly through other features.</p>
<h2 class="heading1" id="_idParaDest-87">Working with promises</h2>
<p class="normal1">Promises are <a id="_idIndexMarker212" class="calibre3"/>an alternative to callbacks and some parts of the Node.js API provide features using both callbacks and promises. A promise serves the same purpose as a callback, which is to define the code that will be executed when an asynchronous operation is completed. The difference is that code written with promises can often be simpler than the equivalent code using callbacks. One part of the API where Node.js provides promises and callbacks is for working with files, as shown in <em class="italic">Listing 4.12</em>. </p>
<p class="packt_figref">Listing 4.12: Using a Promise in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">//import { readFile } from "fs";</strong>
<strong class="screentext">import { readFile } from</strong><strong class="screentext"> "fs/promises";</strong>
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
 <strong class="screentext">   const p: Promise&lt;</strong><strong class="screentext">Buffer&gt; = readFile("data.json");</strong>
<strong class="screentext">    p.then((data: Buffer) =&gt; res.end(data, () =&gt; console.log("</strong><strong class="screentext">File sent")));</strong>
<strong class="screentext">    p.catch((err: Error) =&gt; {</strong>
<strong class="screentext">        console.log(`Error: ${err.message}`);</strong>
<strong class="screentext">        res.statusCode = 500</strong><strong class="screentext">;</strong>
<strong class="screentext">        res.end();</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">};</strong>
</code></pre>
<p class="normal">This isn’t how promises are usually used, which is why the code looks more complex than earlier examples. But this code emphasizes the way that promises work. This is the statement that creates the promise:</p>
<pre class="programlisting"><code class="hljs-code">...
const p: Promise&lt;Buffer&gt; = readFile("data.json");
...
</code></pre>
<p class="normal">The <code class="inlinecode">readFile</code> function has the same name as the function used for callbacks but is defined in the <code class="inlinecode">fs/promises</code> module. The result returned by the <code class="inlinecode">readFile</code> function is <code class="inlinecode">Promise&lt;Buffer&gt;</code>, which is a promise that will produce a <code class="inlinecode">Buffer</code> object when its <a id="_idIndexMarker213" class="calibre3"/>asynchronous operation is complete.</p>
<div><p class="normal"><strong class="screentext">Understanding when synchronous methods are useful</strong></p>
<p class="normal">In addition to callbacks and promises, some parts of the Node.js API also offer synchronous features that block the main thread until they are complete. One example is the <code class="inlinecode">readFileSync</code> function, which performs the same task as <code class="inlinecode">readFile</code>, but blocks execution until the file contents have been read.</p>
<p class="normal">In most cases, you should use the non-blocking features that Node.js provides to maximize the number of requests that Node.js can handle, but there are two situations when blocking operations make more sense. The first situation arises when you know for certain that the operations will be completed so quickly that it is quicker than setting up a promise or a callback. There is a resource and time cost associated with performing an asynchronous operation and this can sometimes be avoided. This situation doesn’t arise often, and you should carefully consider the potential performance impact.</p>
<p class="normal">The second situation is more common, and that’s when you know that the next block of code that the main thread will execute will be the result of the operation you are about to perform. You can see an example of this in <em class="italic">Chapter 6</em>, where I read configuration files synchronously before Node.js starts listening for HTTP requests.</p>
</div>
<p class="normal">Promises are either <em class="italic">resolved</em> or <em class="italic">rejected</em>. A promise that completes successfully and produces its result is resolved. The <code class="inlinecode">then</code> method is used to register the function that will be invoked if the promise is resolved, meaning that the file has been read successfully, like this: </p>
<pre class="programlisting"><code class="hljs-code">...
p.<strong class="screentext">then</strong>((data: Buffer) =&gt; res.end(data, () =&gt; console.log("File sent")));
...
</code></pre>
<p class="normal">A rejected promise is one where an error has occurred. The <code class="inlinecode">catch</code> method is used to register a function that handles the error produced by a rejected promise, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
p.<strong class="screentext">catch</strong>((err: Error) =&gt; {
    console.log(`Error: ${err.message}`);
    res.statusCode = 500;
    res.end();
});
...
</code></pre>
<p class="normal">Notice that <a id="_idIndexMarker214" class="calibre3"/>using a promise doesn’t change the data types used to describe the outcomes: a <code class="inlinecode">Buffer</code> is used to describe the data read from the file and an <code class="inlinecode">Error</code> is used to describe errors.</p>
<p class="normal">The use of the <code class="inlinecode">then</code> and <code class="inlinecode">catch</code> methods separates successful results from errors, unlike the callback API, which presents both and requires the callback function to work out what happened.</p>
<p class="normal">The <code class="inlinecode">then</code> and <code class="inlinecode">catch</code> methods can be chained together, which is one small improvement in simplifying the code, as shown in <em class="italic">Listing 4.13</em>, and is a more typical way to use promises.</p>
<p class="packt_figref">Listing 4.13: Chaining promise methods in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { readFile } from "fs/promises";
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    <strong class="screentext">readFile("data.json")</strong>
<strong class="screentext">        .then((data: Buffer) =&gt; res.end(data, () =&gt; </strong><strong class="screentext">console.log("File sent")))</strong>
<strong class="screentext">        .catch((err: Error) =&gt; {</strong>
<strong class="screentext">            console.log(`Error: ${err.message}`</strong><strong class="screentext">);</strong>
<strong class="screentext">            res.statusCode = 500;</strong>
<strong class="screentext">            res.end();</strong>
<strong class="screentext">        });</strong>
};
</code></pre>
<p class="normal">This is a little neater, but<a id="_idIndexMarker215" class="calibre3"/> the real improvement comes with the use of the <code class="inlinecode">async</code> and <code class="inlinecode">await</code> keywords, which allow asynchronous operations to be performed using syntax that doesn’t require nested functions or chained methods, as shown in <em class="italic">Listing 4.14</em>.</p>
<p class="packt_figref">Listing 4.14: Using the async and await Keywords in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { readFile } from "fs/promises";
<strong class="screentext">export const handler = async (req: IncomingMessage, res: ServerResponse</strong><strong class="screentext">) =&gt; {</strong>
<strong class="screentext">    const data: Buffer = await readFile("data.json");</strong>
<strong class="screentext">    res.end(data, () =&gt; console.log</strong><strong class="screentext">("File sent"));</strong>
<strong class="screentext">};</strong>
</code></pre>
<p class="normal">Using the <code class="inlinecode">async</code> and <code class="inlinecode">await</code> keywords flattens the code by removing the need for the <code class="inlinecode">then</code> method and its function. The <code class="inlinecode">async</code> keyword is applied to the function used to handle requests: </p>
<pre class="programlisting"><code class="hljs-code">...
export const handler = <strong class="screentext">async</strong> (req: IncomingMessage, res: ServerResponse) =&gt; {
...
</code></pre>
<p class="normal">The <code class="inlinecode">await</code> keyword is applied to statements that return promises, like this:</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">...</strong>
<strong class="screentext">const data: Buffer = await readFile("data.json");</strong>
<strong class="screentext">...</strong>
</code></pre>
<p class="normal">These keywords don’t change the behavior of the <code class="inlinecode">readFile</code> function, which still reads a file asynchronously and still returns a <code class="inlinecode">Promise&lt;Buffer&gt;</code>, but the JavaScript runtime takes the result asynchronously produced by the promise, a <code class="inlinecode">Buffer</code> object in this case, assigns it to a constant named <code class="inlinecode">data</code>, and then executes the statements that follow. The result is the same – and the way that the result is obtained is also the same – but the syntax is simpler and easier to read.</p>
<p class="normal">This isn’t the<a id="_idIndexMarker216" class="calibre3"/> final version of the code. To support error handling, the <code class="inlinecode">catch</code> method used on <code class="inlinecode">Promise</code> objects is replaced with a <code class="inlinecode">try/catch</code> block when using the <code class="inlinecode">await</code> keyword, as shown in <em class="italic">Listing 4.15</em>. </p>
<p class="packt_figref">Listing 4.15: Adding error handling in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { readFile } from "fs/promises";
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
<strong class="screentext">    try {</strong>
        const data: Buffer = await readFile("data.json");
        res.end(data, () =&gt; console.log("File sent"));
<strong class="screentext">    } catch (err: any) {</strong>
<strong class="screentext">        console.log(`Error: ${err?.message ?? err}</strong><strong class="screentext">`);</strong>
<strong class="screentext">        res.statusCode = 500;</strong>
<strong class="screentext">        res.end();  </strong>
<strong class="screentext">    }</strong>
};
</code></pre>
<p class="normal">The type of the value provided to the <code class="inlinecode">catch</code> exception is <code class="inlinecode">any</code>, not <code class="inlinecode">Error</code>, because JavaScript doesn’t restrict the types that can be used to represent errors.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">One advantage of callbacks over promises is that callbacks can be invoked more than once for the same operation, allowing a series of updates to be provided while asynchronous work is being performed. Promises are intended to produce a single result without any interim updates. You can see an example of this difference at the end of the chapter.</p>
</div>
<h2 class="heading1" id="_idParaDest-88">Wrapping callbacks and unwrapping promises</h2>
<p class="normal1">Not every part of <a id="_idIndexMarker217" class="calibre3"/>the Node.js API supports both<a id="_idIndexMarker218" class="calibre3"/> promises and callbacks, and that can lead to both approaches being mixed in the same code. You can see this problem in the example, where the <code class="inlinecode">readFile</code> function returns a promise, but the <code class="inlinecode">end</code> method, which sends data to the client and finishes the HTTP response, uses a callback:</p>
<pre class="programlisting"><code class="hljs-code">...
const data: Buffer = await readFile("data.json");
res.end(data, <strong class="screentext">() =&gt; </strong><strong class="screentext">console.log("File sent")</strong>);
...
</code></pre>
<p class="normal">The promise and callback APIs can be mixed without problems, but the result can be awkward code. To help ensure consistency, the Node.js API includes two useful functions in the <code class="inlinecode">util</code> module, which are described in <em class="italic">Table 4.4</em>. </p>
<p class="packt_figref">Table 4.4: The Functions for wrapping callbacks and unwrapping promises </p>
<table class="table-container" id="table004">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">promisify</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This function creates a <code class="inlinecode">Promise</code> from a function that accepts a conventional callback. The convention is that the arguments passed to the callback are an error object and the result of the operation. There is support for other arrangements of arguments using a custom symbol – see <a href="https://nodejs.org/docs/latest/api/util.html#utilpromisifycustom" class="calibre3">https://nodejs.org/docs/latest/api/util.html#utilpromisifycustom</a> for details.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">callbackify</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This function accepts a <code class="inlinecode">Promise</code> object and returns a function that will accept a conventional callback.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The idea behind these functions is good, but they have limitations, especially when trying to create promises from callbacks so that the <code class="inlinecode">await</code> keyword can be used. The biggest restriction is that the <code class="inlinecode">promisify</code> function doesn’t work seamlessly on class methods unless care is taken to deal with the way that JavaScript handles the <code class="inlinecode">this</code> keyword. There is also an issue specific to TypeScript, where the compiler doesn’t correctly identify the types involved.</p>
<p class="normal">Add a file named <code class="inlinecode">promises.ts</code> to the <code class="inlinecode">src</code> folder with the contents shown in <em class="italic">Listing 4.16</em>.</p>
<p class="packt_figref">Listing 4.16: The Contents of the promises.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { ServerResponse } from "http";
import { promisify } from "util";
export const endPromise = promisify(ServerResponse.prototype.end) as
    (data: any) =&gt; Promise&lt;void&gt;;
</code></pre>
<p class="normal">The <a id="_idIndexMarker219" class="calibre3"/>first step is to use <code class="inlinecode">promisify</code> to create a function <a id="_idIndexMarker220" class="calibre3"/>that returns a promise, which I do by passing the <code class="inlinecode">ServerResponse.prototype.end</code> function to <code class="inlinecode">promisify</code>. I use the <code class="inlinecode">as</code> keyword to override the type inferred by the TypeScript compiler with a description of the method parameters and result:</p>
<pre class="programlisting"><code class="hljs-code">...
export const endPromise = promisify(ServerResponse.prototype.end) as
    <strong class="screentext">(data: any) =&gt; Promise&lt;void&gt;;</strong>
...
</code></pre>
<p class="normal"><em class="italic">Listing 4.17</em> imports the function defined in <em class="italic">Listing 4.16</em> and uses the promise it produces.</p>
<p class="packt_figref">Listing 4.17: Using a Promise in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { readFile } from "fs/promises";
<strong class="screentext">import { endPromise } from "./promises";</strong>
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    try {
        const data: Buffer = await readFile("data.json");
<strong class="screentext">        await endPromise.bind(res)(data);</strong>
<strong class="screentext">        console.log("File sent");</strong>
    } catch (err: any) {
        console.log(`Error: ${err?.message ?? err}`);
        res.statusCode = 500;
        res.end();  
    }
};
</code></pre>
<p class="normal">I have to use the <code class="inlinecode">bind</code> method when using the <code class="inlinecode">await</code> keyword on the function that <code class="inlinecode">promisify</code> creates, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
await endPromise.<strong class="screentext">bind(res)</strong>(data);
...
</code></pre>
<p class="normal">The <code class="inlinecode">bind</code> method <a id="_idIndexMarker221" class="calibre3"/>associates the <code class="inlinecode">ServerResponse</code> object <a id="_idIndexMarker222" class="calibre3"/>for which the function is being invoked. The result is a new function, which is invoked by passing the data that will be sent to the client:</p>
<pre class="programlisting"><code class="hljs-code">...
await endPromise.bind(res)(<strong class="screentext">data</strong>);
...
</code></pre>
<p class="normal">The result is that the <code class="inlinecode">await</code> keyword can be used instead of the callback, even though it is a slightly awkward process.</p>
<h1 class="heading" id="_idParaDest-89">Executing custom code</h1>
<p class="normal1">All JavaScript code is <a id="_idIndexMarker223" class="calibre3"/>executed by the main thread, which means that any operation that doesn’t use the non-blocking API provided by Node.js will block the thread. For the sake of consistency, add the statement shown in <em class="italic">Listing 4.18</em> to the <code class="inlinecode">promises.ts</code> file to wrap the <code class="inlinecode">write</code> method defined by the <code class="inlinecode">ServerResponse</code> class in a promise.</p>
<p class="packt_figref">Listing 4.18: Adding a Function in the promises.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { ServerResponse } from "http";
import { promisify } from "util";
export const endPromise = promisify(ServerResponse.prototype.end) as
    (data: any) =&gt; Promise&lt;void&gt;;
<strong class="screentext">export const writePromise = promisify(ServerResponse.prototype.write) as</strong>
<strong class="screentext">    (data: any) =&gt; Promise&lt;void&gt;;</strong>
</code></pre>
<p class="normal"><em class="italic">Listing 4.19</em> filters out<a id="_idIndexMarker224" class="calibre3"/> the requests for the <code class="inlinecode">favicon.ico</code> file, which was fine in earlier examples, but will add unwanted requests in this section.</p>
<p class="packt_figref">Listing 4.19: Filtering Requests in the server.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import { handler } from "./handler";
const port = 5000;
const server = createServer();
<strong class="screentext">server.on("request", (req, res) =&gt;</strong><strong class="screentext"> {</strong>
<strong class="screentext">    if (req.url?.endsWith("favicon.ico")) {</strong>
<strong class="screentext">        res.statusCode = 404;</strong>
<strong class="screentext">        res.end();</strong>
<strong class="screentext">    } else {</strong>
<strong class="screentext">        handler(req, res)</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">});</strong>
server.listen(port);
server.on("listening", () =&gt; {
    console.log(`(Event) Server listening on port ${port}`);
});
</code></pre>
<p class="normal"><em class="italic">Listing 4.20</em> demonstrates the problem of thread blocking by introducing a time-consuming operation that is implemented entirely in JavaScript.</p>
<p class="packt_figref">Listing 4.20: A Blocking Operation in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">//import { readFile } from "fs/promises";</strong>
import { endPromise, writePromise } from "./promises";
<strong class="screentext">const total = 2_000_000_000;</strong>
<strong class="screentext">const</strong><strong class="screentext"> iterations = 5;</strong>
<strong class="screentext">let shared_counter = 0;</strong>
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
   <strong class="screentext"> const</strong><strong class="screentext"> request = shared_counter++;</strong>
<strong class="screentext">    for (let iter = 0; iter &lt; iterations; iter++) {</strong>
<strong class="screentext">        for (let count = 0; count &lt; total; count++) {</strong>
<strong class="screentext">            count++;</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        const msg = `Request: ${request}, Iteration: ${(iter)}`</strong><strong class="screentext">;</strong>
<strong class="screentext">        console.log(msg);</strong>
<strong class="screentext">        await writePromise.bind(res)(msg + "\n");</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    await endPromise.bind(res)("Done");</strong>
};
</code></pre>
<p class="normal">Two <code class="inlinecode">for</code> loops<a id="_idIndexMarker225" class="calibre3"/> repeatedly increment a number value and, since this operation is written entirely in JavaScript, the main thread is blocked until both the loops have completed. To see the effect of the blocked thread, open two browser tabs and request <a href="http://localhost:5000" class="calibre3">http://localhost:5000</a> in both of them. You need to start the request in the second tab before the first one has finished, and you may need to adjust the <code class="inlinecode">total</code> value to give yourself time. The <code class="inlinecode">total</code> value in <em class="italic">Listing 4.20</em> takes three or four seconds to complete on my system, which is long enough to start requests in both browser tabs.</p>
<div><p class="normal"><strong class="screentext">Avoiding the browser cache problem</strong></p>
<p class="normal">Some browsers, including Chrome, won’t make simultaneous requests for the same URL. This means that the request from the second browser tab won’t be started until the response from the first tab’s request has been received, which can make it look like requests are always blocking.</p>
<p class="normal">Browsers do this to see if the result from the first request can be added to their cache and used for subsequent requests. This is not usually an issue, but it can be confusing, especially for features like the ones discussed in this chapter.</p>
<p class="normal">You can avoid this problem by disabling the browser cache (Chrome has a <strong class="screentext">Disable Cache</strong> checkbox on the <strong class="screentext">Network</strong> tab in the <em class="italic">F12</em> developer tools window, for example) or requesting different URLs, such as <code class="inlinecode">http://localhost:5000?id=1</code> and <code class="inlinecode">http://localhost:5000?id=2</code>.</p>
</div>
<p class="normal">You will see <a id="_idIndexMarker226" class="calibre3"/>that both browser tabs get results, as shown in <em class="italic">Figure 4.10</em>. Each request is identified by incrementing the <code class="inlinecode">shared_counter</code> value, which makes it easy to correlate the output displayed in the browser with the Node.js console messages.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_10.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.10: Blocking the main thread</p>
<p class="normal">Examine the Node.js console output and you will see that all of the iterations from the first request were completed before the work for the second request was started:</p>
<pre class="programlisting1"><code class="hljs-con">...
Request: 0, Iteration: 0
Request: 0, Iteration: 1
Request: 0, Iteration: 2
Request: 0, Iteration: 3
Request: 0, Iteration: 4
Request: 1, Iteration: 0
Request: 1, Iteration: 1
Request: 1, Iteration: 2
Request: 1, Iteration: 3
Request: 1, Iteration: 4
...
</code></pre>
<p class="normal">This is a typical, albeit exaggerated, example of blocking the JavaScript thread, so that requests <a id="_idIndexMarker227" class="calibre3"/>queue up waiting for their turn to be handled and the overall request throughput drops.</p>
<h2 class="heading1" id="_idParaDest-90">Yielding control of the main thread</h2>
<p class="normal1">One way to <a id="_idIndexMarker228" class="calibre3"/>address blocking is to break up work into smaller chunks that are interleaved with other requests. The work is still done entirely with the main thread, but the blocking occurs in a series of shorter periods, which means that access to the main thread is more equitable.</p>
<p class="normal"><em class="italic">Table 4.5</em> describes the functions that are available for telling Node.js to invoke a function in the future. (As before, I am simplifying things here to avoid getting into the low-level details of the Node.js event loop.) </p>
<p class="packt_figref">Table 4.5: The scheduling functions</p>
<table class="table-container" id="table005">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">setImmediate</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This function tells Node.js to add a function to the callback queue.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">setTimeout</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This function tells Node.js to add a function to the callback queue that should not be invoked for at least a specified number of milliseconds.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">These are <em class="italic">global </em>functions, which means they can be used without a module import. <em class="italic">Listing 4.21</em> uses the <code class="inlinecode">setImmediate</code> function so that the counting operation is broken up into smaller blocks of work. </p>
<p class="packt_figref">Listing 4.21: Using the setImmediate Function in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { endPromise, writePromise } from "./promises";
const total = 2_000_000_000;
const iterations = 5;
let shared_counter = 0;
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    const request = shared_counter++;
    <strong class="screentext">const iterate = async (iter: number = 0) =&gt; {</strong>
<strong class="screentext">        for (let count = 0; count &lt; total; count++) {</strong>
<strong class="screentext">            count++;</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        const msg = `Request: ${request}, Iteration: ${(iter)}`;</strong>
<strong class="screentext">        console.log(msg);</strong>
<strong class="screentext">        await writePromise.bind(res)(msg + "\n"</strong><strong class="screentext">);</strong>
<strong class="screentext">        if (iter == iterations -1) {</strong>
<strong class="screentext">            await endPromise.bind(res)("Done");</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            setImmediate(() =&gt; iterate</strong><strong class="screentext">(++iter));</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    iterate();</strong>
};
</code></pre>
<p class="normal">The <code class="inlinecode">iterate</code> function <a id="_idIndexMarker229" class="calibre3"/>performs one block of counting and then uses the <code class="inlinecode">setImmediate</code> function to defer the next block. Use two browser tabs to request <code class="inlinecode">http://localhost:5000</code> (or <code class="inlinecode">http://localhost:5000?id=1</code> and <code class="inlinecode">http://localhost:5000?id=2</code> if you have not disabled the browser cache) and you will see the console messages generated by Node.js show that the work performed for the two requests has been interleaved:</p>
<pre class="programlisting1"><code class="hljs-con">...
Request: 0, Iteration: 0
Request: 0, Iteration: 1
Request: 1, Iteration: 0
Request: 0, Iteration: 2
Request: 1, Iteration: 1
Request: 0, Iteration: 3
Request: 1, Iteration: 2
Request: 0, Iteration: 4
Request: 1, Iteration: 3
Request: 1, Iteration: 4
...
</code></pre>
<p class="normal">You may<a id="_idIndexMarker230" class="calibre3"/> see a different sequence of iterations, but the important point is that the work for HTTP requests is broken up and interleaved.</p>
<div><p class="normal"><strong class="screentext">Avoiding the pure JavaScript promise pitfall</strong></p>
<p class="normal">A common mistake is to try and wrap blocking JavaScript code in a promise, like this:</p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">...</code>
<code class="inlinecode2">await new Promise&lt;void&gt;(resolve =&gt; {</code>
<code class="inlinecode2">    // executor - perform one unit of blocking work</code>
<code class="inlinecode2">    resolve();</code>
<code class="inlinecode2">}).then(() =&gt; {</code>
<code class="inlinecode2">    // follow on - set up next unit of work</code>
<code class="inlinecode2">});</code>
<code class="inlinecode2">...</code>
</code></pre>
<p class="normal">There are two pitfalls for the unwary developer with this approach. The first is that the <em class="italic">executor</em>, which is the function that performs the work, is performed synchronously. This may seem odd, but remember that all JavaScript code is executed synchronously, and the expectation is that the executor will be used to invoke asynchronous API methods that will produce results in the future and be added to the callback queue for eventual processing.</p>
<p class="normal">The second pitfall is that the <em class="italic">follow-on</em> <em class="italic">function</em>, passed to the <code class="inlinecode">then</code> method, is executed as soon as the executor completes, before the main thread returns to the callback queue to get another function to execute, with the effect that there is no interleaving of work.</p>
<p class="normal">Promises are a useful way of consuming an API that uses native threads to perform asynchronous work but they don’t help when executing pure JavaScript code.</p>
</div>
<h2 class="heading1" id="_idParaDest-91">Using worker threads</h2>
<p class="normal1">The key limitation of<a id="_idIndexMarker231" class="calibre3"/> the previous example is there is still only one main thread, and it still has to do all the work, regardless of how equitably that work is done. </p>
<p class="normal">Node.js supports <em class="italic">worker threads</em>, which are additional threads for executing JavaScript code, albeit with restrictions. JavaScript doesn’t have the features for coordinating threads that are found in other languages, such as C# or Java, and trying to add them would be difficult. Instead, worker threads run in separate instances of the Node.js engine, executing code in isolation from the main thread. Communication between the main thread and worker threads is done using events, as shown in <em class="italic">Figure 4.11</em>, which fits nicely into the JavaScript event loop, so that the results produced by worker threads are processed by callback functions, just like any other JavaScript code.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_11.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.11: The main thread and worker threads</p>
<p class="normal">Worker threads are not the solution to every problem because there is overhead in creating and managing them, but they provide an effective way to execute JavaScript code without blocking the main thread.</p>
<div><p class="normal"><strong class="screentext">Understanding worker threads versus the worker pool</strong></p>
<p class="normal">There is a terminology overlap that can cause confusion because Node.js uses two similar terms: <em class="italic">worker threads</em> and the <em class="italic">worker pool</em>. Worker threads are the topic of this part of the chapter and are started by the programmer to perform JavaScript code without blocking the main thread. The worker pool is the set of threads that Node.js uses to implement the asynchronous features of its API, such as the functions used in this chapter to read files and write HTTP responses. You don’t interact directly with the worker pool, which is managed by Node.js automatically.</p>
<p class="normal">Just to add to the confusion, worker threads are often grouped into a pool for performance reasons, allowing individual worker threads to be reused instead of used once and then discarded. I will explain how this is done in <em class="italic">Part 2</em>.</p>
</div>
<h3 class="heading2" id="_idParaDest-92">Writing the worker code</h3>
<p class="normal1">The code<a id="_idIndexMarker232" class="calibre3"/> that worker threads execute is defined separately from the rest of the JavaScript application. Add a file named <code class="inlinecode">count_worker.ts</code> to the <code class="inlinecode">src</code> folder with the content shown in <em class="italic">Listing 4.22</em>. </p>
<p class="packt_figref">Listing 4.22: The contents of the count_worker.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { workerData, parentPort  } from "worker_threads";
console.log(`Worker thread ${workerData.request} started`);
for (let iter = 0; iter &lt; workerData.iterations; iter++) {
    for (let count = 0; count &lt; workerData.total; count++) {
        count++;
    }
    parentPort?.postMessage(iter);
}
console.log(`Worker thread ${workerData.request} finished`);
</code></pre>
<p class="normal">Worker threads’ features are defined in the <code class="inlinecode">worker_theads</code> module, and two of those features are used in <em class="italic">Listing 4.22</em>. The first, <code class="inlinecode">workerData</code>, is an object or value used to pass configuration data from the main thread to the worker. In this case, the worker receives three values through <code class="inlinecode">workerData</code>, which specify the request ID, the number of iterations, and the target value for each block of counting work:</p>
<pre class="programlisting"><code class="hljs-code">...
console.log(`Worker thread ${<strong class="screentext">workerData.request</strong>} started`);
for (let iter = 0; iter &lt; <strong class="screentext">workerData.iterations</strong>; iter++) {
    for (let count = 0; count &lt; <strong class="screentext">workerData.total</strong>; count++) {
...
</code></pre>
<p class="normal">The other<a id="_idIndexMarker233" class="calibre3"/> feature is <code class="inlinecode">parentPort</code>, which is used to emit events that will be received by the main thread, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
parentPort?.<strong class="screentext">postMessage</strong>(iter);
...
</code></pre>
<p class="normal">The <code class="inlinecode">postMessage</code> method emits a message event and takes care of transferring the argument value from the worker thread’s JavaScript runtime to the main thread. The <code class="inlinecode">parentPort</code> value may be <code class="inlinecode">null</code>, which is why the <code class="inlinecode">?</code> operator is required when calling the <code class="inlinecode">postMessage</code> method.</p>
<h3 class="heading2" id="_idParaDest-93">Creating a worker thread</h3>
<p class="normal1">The next step is <a id="_idIndexMarker234" class="calibre3"/>to update the request-handling code so that it creates a worker thread using the code defined in the previous section, as shown in <em class="italic">Listing 4.23</em>. </p>
<p class="packt_figref">Listing 4.23: Using a worker thread in the handler.ts File in the src Folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { endPromise, writePromise } from "./promises";
<strong class="screentext">import { Worker } from "worker_threads";</strong>
const total = 2_000_000_000;
const iterations = 5;
let shared_counter = 0;
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    const request = shared_counter++;
   
<strong class="screentext">    const worker = new Worker(__dirname + "/count_worker.js", {</strong>
<strong class="screentext">        workerData: {</strong>
<strong class="screentext">            iterations,</strong>
<strong class="screentext">            total,</strong>
<strong class="screentext">            request</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    worker.on("message", </strong><strong class="screentext">async (iter: number) =&gt; {</strong>
<strong class="screentext">        const msg = `Request: ${request}, Iteration: ${(iter)}`;</strong>
<strong class="screentext">        console.log(msg);</strong>
<strong class="screentext">        await writePromise.bind(res)(msg + "</strong><strong class="screentext">\n");</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    worker.on("exit", async (code: number) =&gt; {</strong>
<strong class="screentext">        if (code == 0) {</strong>
<strong class="screentext">            await endPromise.bind(res)("</strong><strong class="screentext">Done");</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            res.statusCode = 500;</strong>
<strong class="screentext">            await res.end();</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    worker.on("error", async (err) =&gt; {</strong>
<strong class="screentext">        console.</strong><strong class="screentext">log(err)</strong>
<strong class="screentext">        res.statusCode = 500;</strong>
<strong class="screentext">        await res.end();           </strong>
<strong class="screentext">    });</strong>
};
</code></pre>
<p class="normal">Worker threads <a id="_idIndexMarker235" class="calibre3"/>are created by instantiating the <code class="inlinecode">Worker</code> class, which is defined in the <code class="inlinecode">worker_threads</code> module. The constructor arguments are the JavaScript code file to execute and a configuration object:</p>
<pre class="programlisting"><code class="hljs-code">...
const worker = new <strong class="screentext">Worker</strong>(__dirname + "/count_worker.js", {
    workerData: {
        iterations,
        total,
        request
    }
});
...
</code></pre>
<p class="normal">Node.js <a id="_idIndexMarker236" class="calibre3"/>provides two global values that provide path information about the current module and are useful for specifying file paths, which are described in <em class="italic">Table 4.6</em> for quick reference. To specify the code file created in <em class="italic">Listing 4.22</em>, I combine the <code class="inlinecode">__dirname</code> value with the name of the compiled JavaScript file (not the TypeScript file, which can’t be executed directly by Node.js).</p>
<p class="packt_figref">Table 4.6: The global values for the current module</p>
<table class="table-container" id="table006">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><strong class="keyword">Name</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyword">Description</strong></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">__filename</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This value contains the file name of the current module. Remember this will be the name of the JavaScript file and not the TypeScript file.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">__dirname</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This value contains the name of the directory that contains the current module. Remember this will be the directory that contains the compiled JavaScript file and not the TypeScript file.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The configuration object passed to the <code class="inlinecode">Worker</code> constructor supports configuration settings for managing the way a worker thread is executed, but the only option required for this example is <code class="inlinecode">workerData</code>, which allows the data values used by the worker thread to be defined.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">See <a href="https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options" class="calibre3">https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options</a> for the other worker configuration options, although the others are rarely required.</p>
</div>
<p class="normal">Worker threads communicate with the main thread by emitting events, which are handled by functions registered by the <code class="inlinecode">on</code> method, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
worker.<strong class="screentext">on</strong>("message", async (iter: number) =&gt; {
    const msg = `Request: ${request}, Iteration: ${(iter)}`;
    console.log(msg);
    await writePromise.bind(res)(msg + "\n");
});
...
</code></pre>
<p class="normal">The <a id="_idIndexMarker237" class="calibre3"/>first argument to the <code class="inlinecode">on</code> method is a string that specifies the name of the event that will be handled. This handler is for the <code class="inlinecode">message</code> event, which is emitted when the worker uses the <code class="inlinecode">parentPort.postMessage</code> method. In this example, the <code class="inlinecode">message</code> event signals that the worker thread has completed one of its counting iterations.</p>
<p class="normal">There are two other events handled in this example. The <code class="inlinecode">exit</code> event is triggered by Node.js when the worker thread finishes, and the event provides an exit code that indicates whether the worker finished normally or was terminated with an error. There is also an <code class="inlinecode">error</code> event, which is sent if the JavaScript code executed by the worker thread throws an uncaught exception.</p>
<p class="normal">Use two browser tabs to request <code class="inlinecode">http://localhost:5000</code> (or <code class="inlinecode">http://localhost:5000?id=1</code> and <code class="inlinecode">http://localhost:5000?id=2</code> if you have not disabled the browser cache) and you will see Node.js console messages that show calculations performed for the requests overlapping, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
Worker thread 0 started
Request: 0, Iteration: 0
Request: 0, Iteration: 1
Worker thread 1 started
Request: 0, Iteration: 2
Request: 1, Iteration: 0
Request: 0, Iteration: 3
Request: 1, Iteration: 1
Request: 0, Iteration: 4
Worker thread 0 finished
Request: 1, Iteration: 2
Request: 1, Iteration: 3
Request: 1, Iteration: 4
Worker thread 1 finished
...
</code></pre>
<p class="normal">The important <a id="_idIndexMarker238" class="calibre3"/>difference from earlier examples is that work for requests is being performed in parallel, rather than all of the work being performed on a single thread.</p>
<h2 class="heading1" id="_idParaDest-94">Packaging worker threads into a callback</h2>
<p class="normal1">The <a id="_idIndexMarker239" class="calibre3"/>code in <em class="italic">Listing 4.23</em> can be wrapped up so that it is consistent with the Node.js API, using a callback. For the callback, add a file named <code class="inlinecode">counter_cb.ts</code> to the <code class="inlinecode">src</code> folder with the content shown in <em class="italic">Listing 4.24</em>.</p>
<p class="packt_figref">Listing 4.24: The contents of the counter_cb.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { Worker } from "worker_threads";
export const Count = (request: number, iterations: number, total: number,
        callback: (err: Error | null, update: number | boolean) =&gt; void) =&gt; {
    const worker = new Worker(__dirname + "/count_worker.js", {
        workerData: {
            iterations,
            total,
            request
        }
    });
   
    worker.on("message", async (iter: number) =&gt; {
        callback(null, iter);
    });
   
    worker.on("exit", async (code: number) =&gt; {
        callback(code === 0 ? null : new Error(), true);
    });
   
    worker.on("error", async (err) =&gt; {
        callback(err, true);
    });       
}
</code></pre>
<p class="normal">The <code class="inlinecode">Count</code> function <a id="_idIndexMarker240" class="calibre3"/>accepts arguments that describe the work to be done, and a callback function that will be invoked when there is an error, when an iteration completes, and when all of the work is done. <em class="italic">Listing 4.25</em> updates the request-handling code to use the <code class="inlinecode">Count</code> function.</p>
<p class="packt_figref">Listing 4.25: Using a callback function in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { endPromise, writePromise } from "./promises";
<strong class="screentext">//import { Worker } from "worker_threads";</strong>
<strong class="screentext">import { Count } from "./counter_cb";</strong>
const total = 2_000_000_000;
const iterations = 5;
let shared_counter = 0;
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    const request = shared_counter++;
    C<strong class="screentext">ount</strong><strong class="screentext">(request, iterations, total, async (err, update) =&gt; {</strong>
<strong class="screentext">        if (err !== null) {</strong>
<strong class="screentext">            console.log(err)</strong>
<strong class="screentext">            res.statusCode = 500;</strong>
<strong class="screentext">            await res.end();                       </strong>
<strong class="screentext">        } else</strong><strong class="screentext"> if (update !== true) {</strong>
<strong class="screentext">            const msg = `Request: ${request}, Iteration: ${(update)}`;</strong>
<strong class="screentext">            console.log(msg);</strong>
<strong class="screentext">            await writePromise.bind</strong><strong class="screentext">(res)(msg + "\n");</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            await endPromise.bind(res)("Done");           </strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    });</strong>
};
</code></pre>
<p class="normal">This example produces the same results as the previous example but is more consistent with <a id="_idIndexMarker241" class="calibre3"/>the majority of the Node.js API, the key parts of which are described in the chapters that follow.</p>
<h2 class="heading1" id="_idParaDest-95">Packaging worker threads into a promise</h2>
<p class="normal1">Worker threads can <a id="_idIndexMarker242" class="calibre3"/>also be wrapped up in a promise, although promises are not suited to receive interim updates in the way that callbacks are, and so using a promise will only produce a result when all of the work has been completed or when there is a problem. Add a file named <code class="inlinecode">count_promise.ts</code> to the <code class="inlinecode">src</code> folder with the content shown in <em class="italic">Listing 4.26</em>.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">It is possible to produce interim updates with promises, but it requires generating a series of promises that have to be used with the <code class="inlinecode">await</code> keyword in a loop. The result is messy code that doesn’t behave the way that promises usually work and is best avoided. Use a callback if you need interim updates from a worker thread.</p>
</div>
<p class="packt_figref">Listing 4.26: The contents of the count_promise.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { Worker } from "worker_threads";
export const Count = (request: number,
        iterations: number, total: number) : Promise&lt;void&gt; =&gt; {
    return new Promise&lt;void&gt;((resolve, reject) =&gt; {
        const worker = new Worker(__dirname + "/count_worker.js", {
            workerData: {
                iterations, total, request
            }
        });
        worker.on("message", (iter) =&gt; {
            const msg = `Request: ${request}, Iteration: ${(iter)}`;           
            console.log(msg);           
        });
       worker.on("exit", (code) =&gt; {
            if (code !== 0) {
                reject();
            } else {
                resolve();
            }
        });
       
       worker.on("error", reject);       
    });
}
</code></pre>
<p class="normal">The <code class="inlinecode">Count</code> function <a id="_idIndexMarker243" class="calibre3"/>returns a <code class="inlinecode">Promise&lt;void&gt;</code> whose executor starts a worker thread and sets up handlers for the events it emits. The functions that handle the <code class="inlinecode">exit</code> and <code class="inlinecode">error</code> events resolve or reject the promise, which will either signal that the promise is complete or throw an exception. The handler function for the <code class="inlinecode">message</code> event writes out console messages to show progress but doesn’t affect the outcome of the promise. <em class="italic">Listing 4.27</em> revises the request handler to use the promise-based version of the <code class="inlinecode">Count</code> function.</p>
<p class="packt_figref">Listing 4.27: Using a promise in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { endPromise, writePromise } from "./promises";
<strong class="screentext">//import { Count } from "./counter_cb";</strong>
<strong class="screentext">import { Count } from "./count_promise";</strong>
const total = 2_000_000_000;
const iterations = 5;
let shared_counter = 0;
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    const request = shared_counter++;
  <strong class="screentext"> </strong><strong class="screentext">try {</strong>
<strong class="screentext">        await Count(request, iterations, total);</strong>
<strong class="screentext">        const msg = `Request: ${request}, Iterations: ${(iterations)}`;</strong>
<strong class="screentext">        await writePromise.bind(res)(msg + "\n");</strong>
<strong class="screentext"> </strong><strong class="screentext">await endPromise.bind(res)("Done");</strong>
<strong class="screentext">    } catch (err: any) {</strong>
<strong class="screentext">        console.log(err);</strong>
<strong class="screentext">        res.statusCode = 500;</strong>
<strong class="screentext">        res.end();</strong>
<strong class="screentext">    }</strong>
};
</code></pre>
<p class="normal">This is <a id="_idIndexMarker244" class="calibre3"/>similar to earlier examples, except the response sent to the client doesn’t include any messages generated at the end of each block of work, as shown in <em class="italic">Figure 4.12</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_04_12.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 4.12: The result from the promise-wrapped worker thread</p>
<h1 class="heading" id="_idParaDest-96">Summary</h1>
<p class="normal1">In this chapter, I described the way that JavaScript code is executed and explained the effect this has on HTTP request processing and why this approach is different from other platforms. I explained that JavaScript code is executed on a single main thread and demonstrated the features that Node.js provides for offloading work on other threads.</p>
<ul class="calibre4">
<li class="bulletlist">JavaScript code is executed on a single thread, known as the main thread</li>
<li class="bulletlist1">The Node.js API uses native threads to perform many operations to avoid blocking the main thread</li>
<li class="bulletlist1">The Node.js API largely uses callbacks, but there is also some support for promises</li>
<li class="bulletlist1">Node.js provides functions for converting callbacks and promises</li>
<li class="bulletlist1">Node.js supports worker threads for executing JavaScript code without blocking the main thread</li>
</ul>
<p class="normal">In the next chapter, I will describe the features that Node.js provides for working with HTTP requests.</p>
</div>
</body></html>