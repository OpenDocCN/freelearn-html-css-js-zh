<html><head></head><body>
<div class="calibre1" id="_idContainer043">
<h1 class="chapternumber"><span class="kobospan" id="kobo.1.1">4</span></h1>
<h1 class="chaptertitle" id="_idParaDest-77"><span class="kobospan" id="kobo.2.1">Understanding Node.js Concurrency</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.3.1">Server-side web development is characterized by processing large volumes of HTTP requests as quickly and efficiently as possible. </span><span class="kobospan" id="kobo.3.2">JavaScript is different from other languages and platforms because it has a single thread of execution, which means that HTTP requests are processed one at a time. </span><span class="kobospan" id="kobo.3.3">Behind the scenes, however, there is a lot more going on, and in this chapter, I explain why the JavaScript approach is unusual, how the Node.js API performs work on behalf of JavaScript code, and how additional execution threads can be created to handle computationally intense tasks. </span><em class="italic"><span class="kobospan" id="kobo.4.1">Table 4.1</span></em><span class="kobospan" id="kobo.5.1"> puts JavaScript concurrency in context.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.6.1">Table 4.1: Putting Node.js concurrency in context</span></p>
<table class="table-container" id="table001-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.7.1">Question</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.8.1">Answer</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.9.1">What is it?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.10.1">Concurrency is the execution of multiple threads of code. </span><span class="kobospan4" id="kobo.10.2">Node.js has support for concurrency, but it hides the details from the developer.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.11.1">Why is it useful?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.12.1">Concurrency allows servers to achieve greater throughput by accepting and processing multiple HTTP requests simultaneously. </span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.13.1">How is it used?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.14.1">Node.js has a single thread of execution for JavaScript code called the main thread, and it relies on events to coordinate the work required to process different threads of work. </span><span class="kobospan4" id="kobo.14.2">The Node.js API makes extensive use of concurrent execution in its APIs, but this is largely hidden from the developer.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.15.1">Are there any pitfalls or limitations?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.16.1">Care must be taken not to block the main thread; otherwise, performance will be impaired. </span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.17.1">Are there any alternatives?</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.18.1">No. </span><span class="kobospan4" id="kobo.18.2">The concurrency model is core to Node.js and understanding it is essential to create web applications that scale economically. </span></p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.19.1">Table 4.2</span></em><span class="kobospan" id="kobo.20.1"> summarizes the chapter.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.21.1">Table 4.2: Chapter summary</span></p>
<table class="table-container" id="table002-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.22.1">Problem</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.23.1">Solution</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.24.1">Listing</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.25.1">Perform tasks concurrently</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.26.1">Use the Node.js API and handle events with callback functions or promises.</span></p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1"><span class="kobospan2" id="kobo.27.1">10-15</span></em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.28.1">Wrap code as promises or callbacks</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.29.1">Use the </span><code class="inlinecode"><span class="kobospan2" id="kobo.30.1">promisify</span></code><span class="kobospan" id="kobo.31.1"> and </span><code class="inlinecode"><span class="kobospan2" id="kobo.32.1">callbackify</span></code><span class="kobospan4" id="kobo.33.1"> functions.</span></p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1"><span class="kobospan2" id="kobo.34.1">16, 17</span></em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.35.1">Avoid blocking the main thread for simple tasks</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.36.1">Break up work into smaller chunks that can be interleaved with other work.</span></p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1"><span class="kobospan2" id="kobo.37.1">21</span></em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.38.1">Avoid blocking the main thread for complex tasks</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.39.1">Use worker threads.</span></p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1"><span class="kobospan2" id="kobo.40.1">22-27</span></em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-78"><span class="kobospan" id="kobo.41.1">Preparing for this chapter</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.42.1">To create the project for this chapter, open a new command prompt, navigate to a convenient location, and create a folder named </span><code class="inlinecode"><span class="kobospan" id="kobo.43.1">webapp</span></code><span class="kobospan" id="kobo.44.1">. </span><span class="kobospan" id="kobo.44.2">Run the command shown in </span><em class="italic"><span class="kobospan" id="kobo.45.1">Listing 4.1</span></em><span class="kobospan" id="kobo.46.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.47.1">webapp</span></code><span class="kobospan" id="kobo.48.1"> folder to create the </span><code class="inlinecode"><span class="kobospan" id="kobo.49.1">package.json</span></code><span class="kobospan" id="kobo.50.1"> file.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.51.1">Listing 4.1: Initializing the project</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.52.1">npm init -y
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.53.1">Run the commands shown in </span><em class="italic"><span class="kobospan" id="kobo.54.1">Listing 4.2</span></em><span class="kobospan" id="kobo.55.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.56.1">webapp</span></code><span class="kobospan" id="kobo.57.1"> folder to install the packages that will be used to compile TypeScript files and monitor files for changes.</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.58.1">Tip</span></strong> </p>
<p class="normal"><span class="kobospan" id="kobo.59.1">You can download the example project for this chapter – and for all the other chapters in this book – from </span><a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.60.1">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</span></span></a><span class="kobospan" id="kobo.61.1">. </span><span class="kobospan" id="kobo.61.2">See </span><em class="italic"><span class="kobospan" id="kobo.62.1">Chapter 1</span></em><span class="kobospan" id="kobo.63.1"> for how to get help if you have problems running the examples.</span></p>
</div>
<p class="packt_figref"><span class="kobospan" id="kobo.64.1">Listing 4.2: Installing tool packages</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.65.1">npm install --save-dev typescript@5.2.2
npm install --save-dev tsc-watch@6.0.4
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.66.1">Run the commands shown in </span><em class="italic"><span class="kobospan" id="kobo.67.1">Listing 4.3</span></em><span class="kobospan" id="kobo.68.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.69.1">webapp</span></code><span class="kobospan" id="kobo.70.1"> folder to add the packages that will configure the TypeScript compiler for Node.js projects and describe the types used by the Node.js API.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.71.1">Listing 4.3. </span><span class="kobospan" id="kobo.71.2">Adding the Compiler Configuration and Type Packages</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.72.1">npm install --save-dev @tsconfig/node20
npm install --save @types/node@20.6.1
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.73.1">To configure the TypeScript compiler, create a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.74.1">tsconfig.json</span></code><span class="kobospan" id="kobo.75.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.76.1">webapp</span></code><span class="kobospan" id="kobo.77.1"> folder with the contents shown in </span><em class="italic"><span class="kobospan" id="kobo.78.1">Listing 4.4</span></em><span class="kobospan" id="kobo.79.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.80.1">Listing 4.4: The contents of the tsconfig.json file in the webapp folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.81.1">{
   "extends": "@tsconfig/node20/tsconfig.json",
    "compilerOptions": {                      
        "rootDir": "src",  
        "outDir": "dist",                                   
    }
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.82.1">This configuration file extends the one provided by the TypeScript developers for working with Node.js. </span><span class="kobospan" id="kobo.82.2">The TypeScript files will be created in the </span><code class="inlinecode"><span class="kobospan" id="kobo.83.1">src</span></code><span class="kobospan" id="kobo.84.1"> folder, and the compiled JavaScript will be written to the </span><code class="inlinecode"><span class="kobospan" id="kobo.85.1">dist</span></code><span class="kobospan" id="kobo.86.1"> folder.</span></p>
<p class="normal"><span class="kobospan" id="kobo.87.1">Open the </span><code class="inlinecode"><span class="kobospan" id="kobo.88.1">package.json</span></code><span class="kobospan" id="kobo.89.1"> file and add the command shown in </span><em class="italic"><span class="kobospan" id="kobo.90.1">Listing 4.5</span></em><span class="kobospan" id="kobo.91.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.92.1">script</span></code><span class="kobospan" id="kobo.93.1"> section to define the command that will start the build tools.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.94.1">Listing 4.5: Adding a Script Command in the package.json File in the webapp Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.95.1">{
  "name": "webapp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    </span><strong class="screentext"><span class="kobospan" id="kobo.96.1">"start": "tsc-watch --onsuccess \"node dist/server.js\""</span></strong><span class="kobospan" id="kobo.97.1">
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "tsc-watch": "^6.0.4",
    "typescript": "^5.2.2"
  }
}
</span></code></pre>
<h2 class="heading1" id="_idParaDest-79"><span class="kobospan" id="kobo.98.1">Creating a simple web application</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.99.1">With the packages </span><a id="_idIndexMarker176" class="calibre3"/><span class="kobospan" id="kobo.100.1">and build tools in place, it is time to create a simple web application. </span><span class="kobospan" id="kobo.100.2">Create the </span><code class="inlinecode"><span class="kobospan" id="kobo.101.1">webapp/src</span></code><span class="kobospan" id="kobo.102.1"> folder and add to it a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.103.1">handler.ts</span></code><span class="kobospan" id="kobo.104.1"> with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.105.1">Listing 4.6</span></em><span class="kobospan" id="kobo.106.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.107.1">Listing 4.6: The contents of the handler.ts file in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.108.1">import { IncomingMessage, ServerResponse } from "http";
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    res.end("Hello World");
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.109.1">This file defines the code that will process HTTP requests. </span><span class="kobospan" id="kobo.109.2">I describe the HTTP features that Node.js provides in </span><em class="italic"><span class="kobospan" id="kobo.110.1">Chapter 5</span></em><span class="kobospan" id="kobo.111.1">, but for this chapter, it is enough to know that the HTTP request is represented by an </span><code class="inlinecode"><span class="kobospan" id="kobo.112.1">IncomingMessage</span></code><span class="kobospan" id="kobo.113.1"> object, and the response is created using the </span><code class="inlinecode"><span class="kobospan" id="kobo.114.1">ServerResponse</span></code><span class="kobospan" id="kobo.115.1"> object. </span><span class="kobospan" id="kobo.115.2">The code in </span><em class="italic"><span class="kobospan" id="kobo.116.1">Listing 4.6</span></em><span class="kobospan" id="kobo.117.1"> responds to all requests with a simple </span><code class="inlinecode"><span class="kobospan" id="kobo.118.1">Hello World</span></code><span class="kobospan" id="kobo.119.1"> message.</span></p>
<p class="normal"><span class="kobospan" id="kobo.120.1">Next, add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.121.1">server.ts</span></code><span class="kobospan" id="kobo.122.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.123.1">src</span></code><span class="kobospan" id="kobo.124.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.125.1">Listing 4.7</span></em><span class="kobospan" id="kobo.126.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.127.1">Listing 4.7: The contents of the server.ts file in the src folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.128.1">import { createServer } from "http";
import { handler } from "./handler";
const port = 5000;
const server = createServer(handler);
server.listen(port, function() {
    console.log(`Server listening on port ${port}`);
});
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.129.1">This </span><a id="_idIndexMarker177" class="calibre3"/><span class="kobospan" id="kobo.130.1">code creates a simple HTTP server that listens for HTTP requests on port 5000 and processes them using the function defined in the </span><code class="inlinecode"><span class="kobospan" id="kobo.131.1">handler.ts</span></code><span class="kobospan" id="kobo.132.1"> file in </span><em class="italic"><span class="kobospan" id="kobo.133.1">Listing 4.6</span></em><span class="kobospan" id="kobo.134.1">.</span></p>
<p class="normal"><span class="kobospan" id="kobo.135.1">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.136.1">data.json</span></code><span class="kobospan" id="kobo.137.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.138.1">webapp</span></code><span class="kobospan" id="kobo.139.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.140.1">Listing 4.8</span></em><span class="kobospan" id="kobo.141.1">. </span><span class="kobospan" id="kobo.141.2">This file will be used later in the chapter.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.142.1">Listing 4.8: The contents of the data.json file in the webapp folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.143.1">{
    "products": [
        { "id": 1, "name": "Kayak", "category": "Watersports",
            "description": "A boat for one person", "price": 275 },
        { "id": 2, "name": "Lifejacket", "category": "Watersports",
            "description": "Protective and fashionable", "price": 48.95 },
        { "id": 3, "name": "Soccer Ball", "category": "Soccer",
            "description": "FIFA-approved size and weight",
            "price": 19.50 },
        { "id": 4, "name": "Corner Flags", "category": "Soccer",
            "description": "Give your playing field a professional touch",
            "price": 34.95 }
    ]
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.144.1">Run the commands shown in </span><em class="italic"><span class="kobospan" id="kobo.145.1">Listing 4.9</span></em><span class="kobospan" id="kobo.146.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.147.1">webapp</span></code><span class="kobospan" id="kobo.148.1"> folder to start the watcher that will monitor and compile TypeScript files and execute the JavaScript that is produced.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.149.1">Listing 4.9: Starting the project</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.150.1">npm start
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.151.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.152.1">server.ts</span></code><span class="kobospan" id="kobo.153.1"> file in the </span><code class="inlinecode"><span class="kobospan" id="kobo.154.1">src</span></code><span class="kobospan" id="kobo.155.1"> folder will be compiled to produce a pure JavaScript file named </span><code class="inlinecode"><span class="kobospan" id="kobo.156.1">server.js</span></code><span class="kobospan" id="kobo.157.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.158.1">dist</span></code><span class="kobospan" id="kobo.159.1"> folder, which will produce the following output when it is executed:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.160.1">Server listening on port 5000
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.161.1">Open a </span><a id="_idIndexMarker178" class="calibre3"/><span class="kobospan" id="kobo.162.1">web browser and navigate to </span><code class="inlinecode"><span class="kobospan" id="kobo.163.1">http://localhost:5000</span></code><span class="kobospan" id="kobo.164.1"> to send a request to the HTTP server, which will produce the response shown in </span><em class="italic"><span class="kobospan" id="kobo.165.1">Figure 4.1</span></em><span class="kobospan" id="kobo.166.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.167.1"><img alt="" src="../Images/B21959_04_01.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.168.1">Figure 4.1: Running the example application</span></p>
<h1 class="heading" id="_idParaDest-80"><span class="kobospan" id="kobo.169.1">Understanding (simplified) server code execution</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.170.1">A disclaimer </span><a id="_idIndexMarker179" class="calibre3"/><span class="kobospan" id="kobo.171.1">is required: this chapter omits some details, is a little loose with some explanations, and blurs the lines between some fine details.</span></p>
<p class="normal"><span class="kobospan" id="kobo.172.1">The topics covered in this chapter are complex, with endless nuance and detail and terminology that means different things on different platforms. </span><span class="kobospan" id="kobo.172.2">And so, with brevity in mind, I have focused on what’s important for JavaScript web application development, even though that means glossing over some topics.</span></p>
<p class="normal"><span class="kobospan" id="kobo.173.1">Concurrency is a</span><a id="_idIndexMarker180" class="calibre3"/><span class="kobospan" id="kobo.174.1"> genuinely fascinating subject, and it can be a rewarding area of research. </span><span class="kobospan" id="kobo.174.2">But before digging into the details, bear in mind that to be an effective JavaScript developer, you only need a basic overview of concurrency – like the one in this chapter.</span></p>
<h2 class="heading1" id="_idParaDest-81"><span class="kobospan" id="kobo.175.1">Understanding multi-threaded execution</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.176.1">Server-side web applications</span><a id="_idIndexMarker181" class="calibre3"/><span class="kobospan" id="kobo.177.1"> need to be able to process many HTTP requests simultaneously to scale up economically so that a small amount of server capacity can be used to support a large number of clients. </span></p>
<p class="normal"><span class="kobospan" id="kobo.178.1">The conventional approach is to take advantage of the multi-threaded features of modern server hardware by creating a pool of handler threads. </span><span class="kobospan" id="kobo.178.2">When a new HTTP request arrives, it is added to a queue where it waits until one of the threads is available to process it. </span><span class="kobospan" id="kobo.178.3">The thread processes the request, sends the response back to the client, and then returns to the queue for the next request.</span></p>
<p class="normal"><span class="kobospan" id="kobo.179.1">The server hardware can execute multiple threads simultaneously, as illustrated in </span><em class="italic"><span class="kobospan" id="kobo.180.1">Figure 4.2</span></em><span class="kobospan" id="kobo.181.1">, so that a large volume of requests can be received and processed concurrently.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.182.1"><img alt="" src="../Images/B21959_04_02.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.183.1">Figure 4.2: Handling HTTP requests concurrently</span></p>
<p class="normal"><span class="kobospan" id="kobo.184.1">This </span><a id="_idIndexMarker182" class="calibre3"/><span class="kobospan" id="kobo.185.1">approach makes full use of the server hardware, but it requires developers to consider how requests might interfere with each other. </span><span class="kobospan" id="kobo.185.2">A common problem is that one handler thread modifies data as it is being read by another thread, producing an unexpected result.</span></p>
<p class="normal"><span class="kobospan" id="kobo.186.1">To avoid this kind of issue, most programming languages include keywords that are used to restrict interactions between threads. </span><span class="kobospan" id="kobo.186.2">The details vary, but keywords like </span><code class="inlinecode"><span class="kobospan" id="kobo.187.1">lock</span></code><span class="kobospan" id="kobo.188.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.189.1">synchronize</span></code><span class="kobospan" id="kobo.190.1"> are used to ensure that threads safely use shared resources and data by creating protected regions of code that can only be executed by one thread at a time.</span></p>
<p class="normal"><span class="kobospan" id="kobo.191.1">Writing code that uses threads is a balance of safety and performance. </span><span class="kobospan" id="kobo.191.2">Protected regions of code are potential performance bottlenecks, and if protections are applied too widely, then performance suffers and the number of requests that can be processed concurrently falls. </span><span class="kobospan" id="kobo.191.3">However, requests may interfere with one another and produce unexpected results if protections are applied too sparsely.</span></p>
<h3 class="heading2" id="_idParaDest-82"><span class="kobospan" id="kobo.192.1">Understanding blocking and non-blocking operations</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.193.1">In most server-side applications, the</span><a id="_idIndexMarker183" class="calibre3"/><span class="kobospan" id="kobo.194.1"> thread processing an HTTP request spends most of its time waiting. </span><span class="kobospan" id="kobo.194.2">This</span><a id="_idIndexMarker184" class="calibre3"/><span class="kobospan" id="kobo.195.1"> can be waiting for a database to produce a result, waiting for the next chunk of data from a file, or waiting for access to a protected region of code.</span></p>
<p class="normal"><span class="kobospan" id="kobo.196.1">When a thread is waiting, it is said to be </span><em class="italic"><span class="kobospan" id="kobo.197.1">blocked</span></em><span class="kobospan" id="kobo.198.1">. </span><span class="kobospan" id="kobo.198.2">A blocked thread is unable to do any other work until the </span><a id="_idIndexMarker185" class="calibre3"/><span class="kobospan" id="kobo.199.1">operation it is waiting for has been completed, during which time the capacity of the server to process requests is reduced. </span><span class="kobospan" id="kobo.199.2">In busy applications, there is a constant flow of new requests arriving, and having threads tied up doing nothing leads to queues of requests waiting to be processed and reduced overall throughput.</span></p>
<p class="normal"><span class="kobospan" id="kobo.200.1">One solution is </span><a id="_idIndexMarker186" class="calibre3"/><span class="kobospan" id="kobo.201.1">to use </span><em class="italic"><span class="kobospan" id="kobo.202.1">non-blocking</span></em><span class="kobospan" id="kobo.203.1"> operations, also known as </span><em class="italic"><span class="kobospan" id="kobo.204.1">asynchronous</span></em><span class="kobospan" id="kobo.205.1"> operations. </span><span class="kobospan" id="kobo.205.2">These</span><a id="_idIndexMarker187" class="calibre3"/><span class="kobospan" id="kobo.206.1"> terms can be confusing. </span><span class="kobospan" id="kobo.206.2">The best way to understand them is with a real-world example: a pizza restaurant. </span></p>
<p class="normal"><span class="kobospan" id="kobo.207.1">Imagine that, after </span><a id="_idIndexMarker188" class="calibre3"/><span class="kobospan" id="kobo.208.1">taking an order, an employee in the restaurant went into the kitchen, assembled your pizza, put it in the oven, stood there waiting for it to cook for 10 minutes, and then served it to you. </span><span class="kobospan" id="kobo.208.2">This is the blocking – or synchronous – approach to preparing pizza. </span><span class="kobospan" id="kobo.208.3">Customers will be happy if they enter the restaurant when there is an employee available to take an order because they will get their pizza in the shortest amount of time. </span><span class="kobospan" id="kobo.208.4">But no one else is happy. </span><span class="kobospan" id="kobo.208.5">The other customers in the queue aren’t happy because they have to wait in the queue while pizzas for all of the customers ahead of them are assembled, cooked, and served, at which point an employee will be available to make their pizza. </span><span class="kobospan" id="kobo.208.6">The restaurant owner is unhappy because the pizza throughput is equal to the number of employees, who spend most of their time waiting for pizza to cook.</span></p>
<p class="normal"><span class="kobospan" id="kobo.209.1">There is a more sensible approach. </span><span class="kobospan" id="kobo.209.2">One employee – let’s name them Bob – is given the job of monitoring the oven. </span><span class="kobospan" id="kobo.209.3">The other employees take orders, assemble the pizzas, and put them in the oven just as before, but rather than waiting for them to cook, they ask Bob to tell them when the pizza is cooked.</span></p>
<p class="normal"><span class="kobospan" id="kobo.210.1">While Bob watches the pizzas in the oven, the employees can carry on working, taking the order of the next customer in the queue, preparing the next pizza, and so on. </span><span class="kobospan" id="kobo.210.2">Bob can watch lots of pizzas, so the limit to the number of pizzas that can be produced is the size of the oven and not the number of employees.</span></p>
<p class="normal"><span class="kobospan" id="kobo.211.1">Cooking a pizza has become a non-blocking operation for everyone except Bob. </span><span class="kobospan" id="kobo.211.2">There is no way around waiting for the oven, but the performance of the restaurant is improved by making one person do all the waiting. </span><span class="kobospan" id="kobo.211.3">Everyone is happy.</span></p>
<p class="normal"><span class="kobospan" id="kobo.212.1">Well, almost. </span><span class="kobospan" id="kobo.212.2">The </span><a id="_idIndexMarker189" class="calibre3"/><span class="kobospan" id="kobo.213.1">owner is happy because the restaurant produces </span><a id="_idIndexMarker190" class="calibre3"/><span class="kobospan" id="kobo.214.1">more pizzas. </span><span class="kobospan" id="kobo.214.2">The customers in the queue are happy because employees can start working on their pizza while Bob is watching earlier orders. </span><span class="kobospan" id="kobo.214.3">But individual orders may take longer: Bob may tell another employee that a pizza is ready, but they won’t be able to serve it if they are busy with another customer. </span><span class="kobospan" id="kobo.214.4">The overall restaurant performance improves, but individual orders may take longer to complete.</span></p>
<p class="normal"><span class="kobospan" id="kobo.215.1">The same approach can be taken with HTTP requests, as shown in </span><em class="italic"><span class="kobospan" id="kobo.216.1">Figure 4.3</span></em><span class="kobospan" id="kobo.217.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.218.1"><img alt="" src="../Images/B21959_04_03.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.219.1">Figure 4.3: Freeing request handlers from a blocking operation</span></p>
<p class="normal"><span class="kobospan" id="kobo.220.1">Instead of waiting for an operation to complete, handler threads rely on a monitor thread while they continue to process requests from the queue. </span><span class="kobospan" id="kobo.220.2">When the blocking operation has finished, the monitor thread puts the request back in the queue so that a handler thread can continue processing the request.</span></p>
<p class="normal"><span class="kobospan" id="kobo.221.1">The process of handing off an operation for monitoring is usually integrated into the API used to write web applications, so that performing a read from a file, for example, automatically releases the handler thread so it can do other work and can be trusted to put </span><a id="_idIndexMarker191" class="calibre3"/><span class="kobospan" id="kobo.222.1">the request in the queue for processing when the file read operation is complete.</span></p>
<p class="normal"><span class="kobospan" id="kobo.223.1">It is important to </span><a id="_idIndexMarker192" class="calibre3"/><span class="kobospan" id="kobo.224.1">understand that the terms </span><em class="italic"><span class="kobospan" id="kobo.225.1">non-blocking</span></em><span class="kobospan" id="kobo.226.1"> and </span><em class="italic"><span class="kobospan" id="kobo.227.1">asynchronous</span></em><span class="kobospan" id="kobo.228.1"> are from the perspective of the handler thread. </span><span class="kobospan" id="kobo.228.2">The operations still take time to complete, but the handler thread can do other work during that period. </span><span class="kobospan" id="kobo.228.3">There are still blocking threads, but they are not the ones responsible for processing HTTP requests, which are the threads we care about the most.</span></p>
<h2 class="heading1" id="_idParaDest-83"><span class="kobospan" id="kobo.229.1">Understanding JavaScript code execution</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.230.1">JavaScript’s</span><a id="_idIndexMarker193" class="calibre3"/><span class="kobospan" id="kobo.231.1"> origins as a browser-based language have shaped the way that JavaScript code is written and executed. </span><span class="kobospan" id="kobo.231.2">JavaScript was originally used to provide user interaction with HTML elements. </span><span class="kobospan" id="kobo.231.3">Each type of element </span><a id="_idIndexMarker194" class="calibre3"/><span class="kobospan" id="kobo.232.1">defines </span><em class="italic"><span class="kobospan" id="kobo.233.1">events</span></em><span class="kobospan" id="kobo.234.1"> that describe the different ways the user can interact with that element. </span><span class="kobospan" id="kobo.234.2">A button element, for example, has events for when the user clicks the button, moves the pointer over the button, and so on. </span></p>
<p class="normal"><span class="kobospan" id="kobo.235.1">The programmer writes JavaScript </span><a id="_idIndexMarker195" class="calibre3"/><span class="kobospan" id="kobo.236.1">functions, known as </span><em class="italic"><span class="kobospan" id="kobo.237.1">callbacks</span></em><span class="kobospan" id="kobo.238.1">, and uses the browser’s API to associate those functions with specific events on elements. </span><span class="kobospan" id="kobo.238.2">When the browser detects an event, it adds the callback to a queue so it can be executed by the JavaScript runtime.</span></p>
<p class="normal"><span class="kobospan" id="kobo.239.1">The JavaScript runtime has a single </span><a id="_idIndexMarker196" class="calibre3"/><span class="kobospan" id="kobo.240.1">thread – called the </span><em class="italic"><span class="kobospan" id="kobo.241.1">main thread</span></em><span class="kobospan" id="kobo.242.1"> – that is responsible for executing the callbacks. </span><span class="kobospan" id="kobo.242.2">The main thread runs in a loop, taking callbacks from the queue and executing them, which is referred to as the JavaScript </span><em class="italic"><span class="kobospan" id="kobo.243.1">event loop</span></em><span class="kobospan" id="kobo.244.1">. </span><span class="kobospan" id="kobo.244.2">The </span><a id="_idIndexMarker197" class="calibre3"/><span class="kobospan" id="kobo.245.1">event loop is how the native code of the browser, which is written for a specific operating system, interacts with the JavaScript code, which runs on any compatible runtime. </span></p>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.246.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.247.1">The event loop is more complicated but the idea of a queue of callbacks is close enough for effective JavaScript web development. </span><span class="kobospan" id="kobo.247.2">The details are worth exploring if you, like me, find this sort of thing interesting. </span><span class="kobospan" id="kobo.247.3">A good place to start is </span><a href="https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.248.1">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick</span></span></a><span class="kobospan" id="kobo.249.1">.</span></p>
</div>
<p class="normal"><span class="kobospan" id="kobo.250.1">Events often </span><a id="_idIndexMarker198" class="calibre3"/><span class="kobospan" id="kobo.251.1">occur in clusters, such as when the pointer moves across several elements, and so the queue can contain multiple callbacks waiting to be executed, as shown in </span><em class="italic"><span class="kobospan" id="kobo.252.1">Figure 4.4</span></em><span class="kobospan" id="kobo.253.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.254.1"><img alt="" src="../Images/B21959_04_04.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.255.1">Figure 4.4: The callback queue</span></p>
<p class="normal"><span class="kobospan" id="kobo.256.1">Using a single thread means that any operation in a callback that takes time to complete causes the application to freeze as callbacks queue up waiting to be processed. </span><span class="kobospan" id="kobo.256.2">To help manage this issue, many browser API features are non-blocking and use the callback pattern to deliver their results.</span></p>
<p class="normal"><span class="kobospan" id="kobo.257.1">Over the years, features have been added to the JavaScript language and the browser APIs, but the event loop and callback functions are used to execute JavaScript. </span><span class="kobospan" id="kobo.257.2">The API the browser provides for HTTP requests, for example, defines a series of events that describe the request lifecycle, and these events are handled with callback functions, as shown in </span><em class="italic"><span class="kobospan" id="kobo.258.1">Figure 4.5</span></em><span class="kobospan" id="kobo.259.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.260.1"><img alt="" src="../Images/B21959_04_05.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.261.1">Figure 4.5: Results from the browser API are processed with JavaScript callback functions</span></p>
<p class="normal"><span class="kobospan" id="kobo.262.1">Behind the scenes, the browser uses native threads to perform the HTTP request and wait for the response, which is then passed to the JavaScript runtime using a callback.</span></p>
<p class="normal"><span class="kobospan" id="kobo.263.1">The JavaScript runtime</span><a id="_idIndexMarker199" class="calibre3"/><span class="kobospan" id="kobo.264.1"> only ever executes one callback, so the JavaScript language doesn’t need keywords like </span><code class="inlinecode"><span class="kobospan" id="kobo.265.1">lock</span></code><span class="kobospan" id="kobo.266.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.267.1">synchronize</span></code><span class="kobospan" id="kobo.268.1">. </span><span class="kobospan" id="kobo.268.2">JavaScript code interacts with the browser through an API that hides away the implementation details and receives results consistently.</span></p>
<h2 class="heading1" id="_idParaDest-84"><span class="kobospan" id="kobo.269.1">Understanding Node.js code execution</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.270.1">Node.js retains </span><a id="_idIndexMarker200" class="calibre3"/><span class="kobospan" id="kobo.271.1">the main thread and the event loop, which means that server-side code is executed in the same way as client-side JavaScript. </span><span class="kobospan" id="kobo.271.2">For HTTP servers, the main thread is the only request handler, and callbacks are used to handle incoming HTTP connections. </span><span class="kobospan" id="kobo.271.3">The example application demonstrates the use of a callback to handle an HTTP request:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.272.1">...
</span><span class="kobospan" id="kobo.272.2">const server = createServer(</span><strong class="screentext"><span class="kobospan" id="kobo.273.1">handler</span></strong><span class="kobospan" id="kobo.274.1">);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.275.1">The callback function passed to the </span><code class="inlinecode"><span class="kobospan" id="kobo.276.1">createServer</span></code><span class="kobospan" id="kobo.277.1"> function will be invoked when Node.js receives an HTTP connection. </span><span class="kobospan" id="kobo.277.2">The function defines parameters that represent the request that has been received and the response that will be returned to the client:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.278.1">...
</span><span class="kobospan" id="kobo.278.2">export const handler = (</span><strong class="screentext"><span class="kobospan" id="kobo.279.1">req: IncomingMessage, res: ServerResponse</span></strong><span class="kobospan" id="kobo.280.1">) =&gt; {
    res.end("Hello World");
};
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.281.1">I describe the API Node.js provides for HTTP in </span><em class="italic"><span class="kobospan" id="kobo.282.1">Chapter 5</span></em><span class="kobospan" id="kobo.283.1">, but the callback function uses its parameters to prepare the response that will be sent to the client. </span><span class="kobospan" id="kobo.283.2">The details of how Node.js receives HTTP requests and returns HTTP responses are hidden away in native code, as shown in </span><em class="italic"><span class="kobospan" id="kobo.284.1">Figure 4.6</span></em><span class="kobospan" id="kobo.285.1">. </span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.286.1"><img alt="" src="../Images/B21959_04_06.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.287.1">Figure 4.6: Handling HTTP requests in Node.js</span></p>
<p class="normal"><span class="kobospan" id="kobo.288.1">Node.js</span><a id="_idIndexMarker201" class="calibre3"/><span class="kobospan" id="kobo.289.1"> may only have a single handler thread, but the performance can be excellent because modern server hardware is incredibly fast. </span><span class="kobospan" id="kobo.289.2">Even so, a single thread doesn’t take full advantage of the multi-core and multi-processor hardware to which most applications are deployed.</span></p>
<p class="normal"><span class="kobospan" id="kobo.290.1">To scale up, multiple instances of Node.js are started. </span><span class="kobospan" id="kobo.290.2">HTTP requests are received by a load balancer (or ingress controller or primary node, depending on how the application is deployed, as described in </span><em class="italic"><span class="kobospan" id="kobo.291.1">Part 3</span></em><span class="kobospan" id="kobo.292.1">) and distributed to the Node.js instances, as shown in </span><em class="italic"><span class="kobospan" id="kobo.293.1">Figure 4.7</span></em><span class="kobospan" id="kobo.294.1">. </span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.295.1"><img alt="" src="../Images/B21959_04_07.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.296.1">Figure 4.7: Scaling up with multiple Node.js instances</span></p>
<p class="normal"><span class="kobospan" id="kobo.297.1">The individual Node.js instances still have a single JavaScript thread but collectively they can process a higher volume of requests.</span></p>
<p class="normal"><span class="kobospan" id="kobo.298.1">One important consequence of applying the JavaScript execution model to HTTP requests is that blocking the main thread stops all requests from being processed by that Node.js </span><a id="_idIndexMarker202" class="calibre3"/><span class="kobospan" id="kobo.299.1">instance, creating the same kind of deadlock that can arise in client-side JavaScript. </span><span class="kobospan" id="kobo.299.2">Node.js helps programmers avoid blocking the main thread in two ways: an API that performs many tasks asynchronously, known </span><a id="_idIndexMarker203" class="calibre3"/><span class="kobospan" id="kobo.300.1">as the </span><em class="italic"><span class="kobospan" id="kobo.301.1">worker pool</span></em><span class="kobospan" id="kobo.302.1">, and support for starting extra threads to execute blocking</span><a id="_idIndexMarker204" class="calibre3"/><span class="kobospan" id="kobo.303.1"> JavaScript code, known as </span><em class="italic"><span class="kobospan" id="kobo.304.1">worker threads</span></em><span class="kobospan" id="kobo.305.1">. </span><span class="kobospan" id="kobo.305.2">Both of these features are described in the sections that follow. </span></p>
<h1 class="heading" id="_idParaDest-85"><span class="kobospan" id="kobo.306.1">Using the Node.js API</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.307.1">Node.js replaces </span><a id="_idIndexMarker205" class="calibre3"/><span class="kobospan" id="kobo.308.1">the API provided by the browser with one that supports common server-side tasks, such as processing HTTP requests and reading files. </span><span class="kobospan" id="kobo.308.2">Behind the scenes, Node.js uses native threads, known as the worker pool, to perform operations asynchronously. </span></p>
<p class="normal"><span class="kobospan" id="kobo.309.1">To demonstrate, </span><em class="italic"><span class="kobospan" id="kobo.310.1">Listing 4.10</span></em><span class="kobospan" id="kobo.311.1"> uses the Node.js API to read the contents of a file. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.312.1">Listing 4.10: Using the Node.js API in the handler.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.313.1">import { IncomingMessage, ServerResponse } from "http";
</span><strong class="screentext"><span class="kobospan" id="kobo.314.1">import { readFile } from "fs";</span></strong><span class="kobospan" id="kobo.315.1">
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    </span><strong class="screentext"><span class="kobospan" id="kobo.316.1">readFile</span></strong><strong class="screentext"><span class="kobospan" id="kobo.317.1">("data.json", (err: Error | null, data: Buffer) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.318.1">        if (err == null) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.319.1">            res.end(data, () =&gt; console</span></strong><strong class="screentext"><span class="kobospan" id="kobo.320.1">.log("File sent"));</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.321.1">        } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.322.1">            console.log(`Error: ${err.message}`);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.323.1">            res.statusCode = 500;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.324.1">            res.end</span></strong><strong class="screentext"><span class="kobospan" id="kobo.325.1">();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.326.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.327.1">    });</span></strong><span class="kobospan" id="kobo.328.1">
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.329.1">As its name suggests, the </span><code class="inlinecode"><span class="kobospan" id="kobo.330.1">readFile</span></code><span class="kobospan" id="kobo.331.1"> function reads the contents of a file. </span><span class="kobospan" id="kobo.331.2">Use a web browser to request </span><code class="inlinecode"><span class="kobospan" id="kobo.332.1">http://localhost:5000</span></code><span class="kobospan" id="kobo.333.1"> and you will see the output shown in </span><em class="italic"><span class="kobospan" id="kobo.334.1">Figure 4.8</span></em><span class="kobospan" id="kobo.335.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.336.1"><img alt="" src="../Images/B21959_04_08.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.337.1">Figure 4.8: Sending the contents of a file to the client</span></p>
<p class="normal"><span class="kobospan" id="kobo.338.1">The read </span><a id="_idIndexMarker206" class="calibre3"/><span class="kobospan" id="kobo.339.1">operation is asynchronous and is implemented using a native thread. </span><span class="kobospan" id="kobo.339.2">The contents of the file are passed to a callback function, which sends them to the HTTP client.</span></p>
<p class="normal"><span class="kobospan" id="kobo.340.1">There are three callbacks in the code. </span><span class="kobospan" id="kobo.340.2">The first callback is the one passed to the </span><code class="inlinecode"><span class="kobospan" id="kobo.341.1">createServer</span></code><span class="kobospan" id="kobo.342.1"> function, which is invoked when an HTTP request is received:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.343.1">...
</span><span class="kobospan" id="kobo.343.2">const server = createServer(</span><strong class="screentext"><span class="kobospan" id="kobo.344.1">handler</span></strong><span class="kobospan" id="kobo.345.1">);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.346.1">The second callback is the one passed to the </span><code class="inlinecode"><span class="kobospan" id="kobo.347.1">readFile</span></code><span class="kobospan" id="kobo.348.1"> function, which is invoked when the contents of the file have been read or if an error occurs:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.349.1">...
</span><span class="kobospan" id="kobo.349.2">export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    readFile("data.json", (</span><strong class="screentext"><span class="kobospan" id="kobo.350.1">err: Error</span></strong><strong class="screentext"><span class="kobospan" id="kobo.351.1"> | null, data: Buffer) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.352.1">if (err == null) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.353.1">            res.end(data, () =&gt; console.log("File sent"));</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.354.1">        } else</span></strong><strong class="screentext"><span class="kobospan" id="kobo.355.1"> {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.356.1">            console.log(`Error: ${err.message}`);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.357.1">            res.statusCode = 500;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.358.1">            res.end();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.359.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.360.1">    });</span></strong><span class="kobospan" id="kobo.361.1">
};
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.362.1">I used type</span><a id="_idIndexMarker207" class="calibre3"/><span class="kobospan" id="kobo.363.1"> annotations to help describe the way the results from reading the file are presented. </span><span class="kobospan" id="kobo.363.2">The type of the first argument of the callback is </span><code class="inlinecode"><span class="kobospan" id="kobo.364.1">Error | null</span></code><span class="kobospan" id="kobo.365.1"> and is used to indicate the outcome. </span><span class="kobospan" id="kobo.365.2">If the first argument is </span><code class="inlinecode"><span class="kobospan" id="kobo.366.1">null</span></code><span class="kobospan" id="kobo.367.1">, then the operation has been completed successfully, and the contents of the file will be available in the second argument, whose type is </span><code class="inlinecode"><span class="kobospan" id="kobo.368.1">Buffer</span></code><span class="kobospan" id="kobo.369.1">. </span><span class="kobospan" id="kobo.369.2">(Buffers are how Node.js represents arrays of bytes.) If the first argument isn’t </span><code class="inlinecode"><span class="kobospan" id="kobo.370.1">null</span></code><span class="kobospan" id="kobo.371.1">, then the </span><code class="inlinecode"><span class="kobospan" id="kobo.372.1">Error</span></code><span class="kobospan" id="kobo.373.1"> object will provide details of the problem that prevented the file from being read. </span></p>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.374.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.375.1">You may see two messages written to the command prompt when you send an HTTP request from a browser. </span><span class="kobospan" id="kobo.375.2">Browsers often request the </span><code class="inlinecode"><span class="kobospan" id="kobo.376.1">favicon.ico</span></code><span class="kobospan" id="kobo.377.1"> file to get an icon that can be displayed in the tab header, and this is the reason why you will sometimes see </span><code class="inlinecode"><span class="kobospan" id="kobo.378.1">File sent</span></code><span class="kobospan" id="kobo.379.1"> appear twice in the output.</span></p>
</div>
<p class="normal"><span class="kobospan" id="kobo.380.1">The third callback is invoked when the data read from the file has been sent to the client:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.381.1">...
</span><span class="kobospan" id="kobo.381.2">export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    readFile("data.json", (err: Error | null, data: Buffer) =&gt; {
        if (err == null) {
            res.end(data, </span><strong class="screentext"><span class="kobospan" id="kobo.382.1">() =&gt; console.log("File sent")</span></strong><span class="kobospan" id="kobo.383.1">);
        } else {
            console.log(`Error: ${err.message}`);
            res.statusCode = 500;
            res.end();
        }
    });
};
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.384.1">Breaking up </span><a id="_idIndexMarker208" class="calibre3"/><span class="kobospan" id="kobo.385.1">the process of producing an HTTP response with callbacks means that the JavaScript main thread doesn’t have to wait for the file system to read the contents of the file, and this allows requests from other clients to be processed, as illustrated in </span><em class="italic"><span class="kobospan" id="kobo.386.1">Figure 4.9</span></em><span class="kobospan" id="kobo.387.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.388.1"><img alt="" src="../Images/B21959_04_09.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.389.1">Figure 4.9: Breaking down request handling with multiple callbacks</span></p>
<h2 class="heading1" id="_idParaDest-86"><span class="kobospan" id="kobo.390.1">Handling events</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.391.1">Events are </span><a id="_idIndexMarker209" class="calibre3"/><span class="kobospan" id="kobo.392.1">used to provide notifications that the state of the application has changed and provide an opportunity to execute a callback function to handle that change. </span><span class="kobospan" id="kobo.392.2">Events are used throughout the Node.js API, although there are often convenience features that hide away the details. </span><em class="italic"><span class="kobospan" id="kobo.393.1">Listing 4.11</span></em><span class="kobospan" id="kobo.394.1"> revises the code that listens for HTTP requests to use events directly.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.395.1">Listing 4.11: Handling Events in the server.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.396.1">import { createServer } from "http";
import { handler } from "./handler";
</span><strong class="screentext"><span class="kobospan" id="kobo.397.1">const port = 5000;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.398.1">const server = createServer();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.399.1">server.on("</span></strong><strong class="screentext"><span class="kobospan" id="kobo.400.1">request", handler)</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.401.1">server.listen(port);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.402.1">server.on("listening", () =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.403.1">    console.log(`(Event) Server listening on port ${port}</span></strong><strong class="screentext"><span class="kobospan" id="kobo.404.1">`);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.405.1">});</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.406.1">Many of</span><a id="_idIndexMarker210" class="calibre3"/><span class="kobospan" id="kobo.407.1"> the objects created with the Node.js API extend the </span><code class="inlinecode"><span class="kobospan" id="kobo.408.1">EventEmitter</span></code><span class="kobospan" id="kobo.409.1"> class, which denotes a source of events. </span><span class="kobospan" id="kobo.409.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.410.1">EventEmitter</span></code><span class="kobospan" id="kobo.411.1"> class defines the methods described in </span><em class="italic"><span class="kobospan" id="kobo.412.1">Table 4.3</span></em><span class="kobospan" id="kobo.413.1"> for receiving events.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.414.1">Table 4.3: Useful eventemitter methods</span></p>
<table class="table-container" id="table003-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.415.1">Name</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.416.1">Description</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.417.1">on(event, callback)</span></code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.418.1">This method registers a </span><code class="inlinecode"><span class="kobospan2" id="kobo.419.1">callback</span></code><span class="kobospan4" id="kobo.420.1"> to be invoked whenever the specified event is emitted. </span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.421.1">off(event, callback)</span></code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.422.1">This method stops invoking the </span><code class="inlinecode"><span class="kobospan2" id="kobo.423.1">callback</span></code><span class="kobospan4" id="kobo.424.1"> when the specific event is emitted.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.425.1">once(event, callback)</span></code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.426.1">This method registers a </span><code class="inlinecode"><span class="kobospan2" id="kobo.427.1">callback</span></code><span class="kobospan4" id="kobo.428.1"> to be invoked the next time the specified event is emitted but not thereafter.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="kobospan" id="kobo.429.1">Classes that extend </span><code class="inlinecode"><span class="kobospan" id="kobo.430.1">EventEmitter</span></code><span class="kobospan" id="kobo.431.1"> define events and specify when they will be emitted. </span><span class="kobospan" id="kobo.431.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.432.1">Server</span></code><span class="kobospan" id="kobo.433.1"> class returned by the </span><code class="inlinecode"><span class="kobospan" id="kobo.434.1">createServer</span></code><span class="kobospan" id="kobo.435.1"> method extends </span><code class="inlinecode"><span class="kobospan" id="kobo.436.1">EventEmitter</span></code><span class="kobospan" id="kobo.437.1"> and it defines two events that are used in </span><em class="italic"><span class="kobospan" id="kobo.438.1">Listing 4.11</span></em><span class="kobospan" id="kobo.439.1">: the </span><code class="inlinecode"><span class="kobospan" id="kobo.440.1">request</span></code><span class="kobospan" id="kobo.441.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.442.1">listening</span></code><span class="kobospan" id="kobo.443.1"> events. </span><span class="kobospan" id="kobo.443.2">The code in </span><em class="italic"><span class="kobospan" id="kobo.444.1">Listing 4.7</span></em><span class="kobospan" id="kobo.445.1"> and </span><em class="italic"><span class="kobospan" id="kobo.446.1">Listing 4.11</span></em><span class="kobospan" id="kobo.447.1"> has the same effect and the only difference is that the </span><code class="inlinecode"><span class="kobospan" id="kobo.448.1">createServer</span></code><span class="kobospan" id="kobo.449.1"> function registers its function argument as a callback for the </span><code class="inlinecode"><span class="kobospan" id="kobo.450.1">request</span></code><span class="kobospan" id="kobo.451.1"> event behind the scenes, while the </span><code class="inlinecode"><span class="kobospan" id="kobo.452.1">listen</span></code><span class="kobospan" id="kobo.453.1"> method registers its function argument as a callback for the </span><code class="inlinecode"><span class="kobospan" id="kobo.454.1">listening</span></code><span class="kobospan" id="kobo.455.1"> event.</span></p>
<p class="normal"><span class="kobospan" id="kobo.456.1">It is important to understand that events are an integral part of the Node.js API and that they can</span><a id="_idIndexMarker211" class="calibre3"/><span class="kobospan" id="kobo.457.1"> be used directly, with the methods described in </span><em class="italic"><span class="kobospan" id="kobo.458.1">Table 4.3</span></em><span class="kobospan" id="kobo.459.1">, or indirectly through other features.</span></p>
<h2 class="heading1" id="_idParaDest-87"><span class="kobospan" id="kobo.460.1">Working with promises</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.461.1">Promises are </span><a id="_idIndexMarker212" class="calibre3"/><span class="kobospan" id="kobo.462.1">an alternative to callbacks and some parts of the Node.js API provide features using both callbacks and promises. </span><span class="kobospan" id="kobo.462.2">A promise serves the same purpose as a callback, which is to define the code that will be executed when an asynchronous operation is completed. </span><span class="kobospan" id="kobo.462.3">The difference is that code written with promises can often be simpler than the equivalent code using callbacks. </span><span class="kobospan" id="kobo.462.4">One part of the API where Node.js provides promises and callbacks is for working with files, as shown in </span><em class="italic"><span class="kobospan" id="kobo.463.1">Listing 4.12</span></em><span class="kobospan" id="kobo.464.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.465.1">Listing 4.12: Using a Promise in the handler.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.466.1">import { IncomingMessage, ServerResponse } from "http";
</span><strong class="screentext"><span class="kobospan" id="kobo.467.1">//import { readFile } from "fs";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.468.1">import { readFile } from</span></strong><strong class="screentext"><span class="kobospan" id="kobo.469.1"> "fs/promises";</span></strong><span class="kobospan" id="kobo.470.1">
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
 </span><strong class="screentext"><span class="kobospan" id="kobo.471.1">   const p: Promise&lt;</span></strong><strong class="screentext"><span class="kobospan" id="kobo.472.1">Buffer&gt; = readFile("data.json");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.473.1">    p.then((data: Buffer) =&gt; res.end(data, () =&gt; console.log("</span></strong><strong class="screentext"><span class="kobospan" id="kobo.474.1">File sent")));</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.475.1">    p.catch((err: Error) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.476.1">        console.log(`Error: ${err.message}`);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.477.1">        res.statusCode = 500</span></strong><strong class="screentext"><span class="kobospan" id="kobo.478.1">;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.479.1">        res.end();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.480.1">    });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.481.1">};</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.482.1">This isn’t how promises are usually used, which is why the code looks more complex than earlier examples. </span><span class="kobospan" id="kobo.482.2">But this code emphasizes the way that promises work. </span><span class="kobospan" id="kobo.482.3">This is the statement that creates the promise:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.483.1">...
</span><span class="kobospan" id="kobo.483.2">const p: Promise&lt;Buffer&gt; = readFile("data.json");
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.484.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.485.1">readFile</span></code><span class="kobospan" id="kobo.486.1"> function has the same name as the function used for callbacks but is defined in the </span><code class="inlinecode"><span class="kobospan" id="kobo.487.1">fs/promises</span></code><span class="kobospan" id="kobo.488.1"> module. </span><span class="kobospan" id="kobo.488.2">The result returned by the </span><code class="inlinecode"><span class="kobospan" id="kobo.489.1">readFile</span></code><span class="kobospan" id="kobo.490.1"> function is </span><code class="inlinecode"><span class="kobospan" id="kobo.491.1">Promise&lt;Buffer&gt;</span></code><span class="kobospan" id="kobo.492.1">, which is a promise that will produce a </span><code class="inlinecode"><span class="kobospan" id="kobo.493.1">Buffer</span></code><span class="kobospan" id="kobo.494.1"> object when its </span><a id="_idIndexMarker213" class="calibre3"/><span class="kobospan" id="kobo.495.1">asynchronous operation is complete.</span></p>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.496.1">Understanding when synchronous methods are useful</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.497.1">In addition to callbacks and promises, some parts of the Node.js API also offer synchronous features that block the main thread until they are complete. </span><span class="kobospan" id="kobo.497.2">One example is the </span><code class="inlinecode"><span class="kobospan" id="kobo.498.1">readFileSync</span></code><span class="kobospan" id="kobo.499.1"> function, which performs the same task as </span><code class="inlinecode"><span class="kobospan" id="kobo.500.1">readFile</span></code><span class="kobospan" id="kobo.501.1">, but blocks execution until the file contents have been read.</span></p>
<p class="normal"><span class="kobospan" id="kobo.502.1">In most cases, you should use the non-blocking features that Node.js provides to maximize the number of requests that Node.js can handle, but there are two situations when blocking operations make more sense. </span><span class="kobospan" id="kobo.502.2">The first situation arises when you know for certain that the operations will be completed so quickly that it is quicker than setting up a promise or a callback. </span><span class="kobospan" id="kobo.502.3">There is a resource and time cost associated with performing an asynchronous operation and this can sometimes be avoided. </span><span class="kobospan" id="kobo.502.4">This situation doesn’t arise often, and you should carefully consider the potential performance impact.</span></p>
<p class="normal"><span class="kobospan" id="kobo.503.1">The second situation is more common, and that’s when you know that the next block of code that the main thread will execute will be the result of the operation you are about to perform. </span><span class="kobospan" id="kobo.503.2">You can see an example of this in </span><em class="italic"><span class="kobospan" id="kobo.504.1">Chapter 6</span></em><span class="kobospan" id="kobo.505.1">, where I read configuration files synchronously before Node.js starts listening for HTTP requests.</span></p>
</div>
<p class="normal"><span class="kobospan" id="kobo.506.1">Promises are either </span><em class="italic"><span class="kobospan" id="kobo.507.1">resolved</span></em><span class="kobospan" id="kobo.508.1"> or </span><em class="italic"><span class="kobospan" id="kobo.509.1">rejected</span></em><span class="kobospan" id="kobo.510.1">. </span><span class="kobospan" id="kobo.510.2">A promise that completes successfully and produces its result is resolved. </span><span class="kobospan" id="kobo.510.3">The </span><code class="inlinecode"><span class="kobospan" id="kobo.511.1">then</span></code><span class="kobospan" id="kobo.512.1"> method is used to register the function that will be invoked if the promise is resolved, meaning that the file has been read successfully, like this: </span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.513.1">...
</span><span class="kobospan" id="kobo.513.2">p.</span><strong class="screentext"><span class="kobospan" id="kobo.514.1">then</span></strong><span class="kobospan" id="kobo.515.1">((data: Buffer) =&gt; res.end(data, () =&gt; console.log("File sent")));
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.516.1">A rejected promise is one where an error has occurred. </span><span class="kobospan" id="kobo.516.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.517.1">catch</span></code><span class="kobospan" id="kobo.518.1"> method is used to register a function that handles the error produced by a rejected promise, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.519.1">...
</span><span class="kobospan" id="kobo.519.2">p.</span><strong class="screentext"><span class="kobospan" id="kobo.520.1">catch</span></strong><span class="kobospan" id="kobo.521.1">((err: Error) =&gt; {
    console.log(`Error: ${err.message}`);
    res.statusCode = 500;
    res.end();
});
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.522.1">Notice that </span><a id="_idIndexMarker214" class="calibre3"/><span class="kobospan" id="kobo.523.1">using a promise doesn’t change the data types used to describe the outcomes: a </span><code class="inlinecode"><span class="kobospan" id="kobo.524.1">Buffer</span></code><span class="kobospan" id="kobo.525.1"> is used to describe the data read from the file and an </span><code class="inlinecode"><span class="kobospan" id="kobo.526.1">Error</span></code><span class="kobospan" id="kobo.527.1"> is used to describe errors.</span></p>
<p class="normal"><span class="kobospan" id="kobo.528.1">The use of the </span><code class="inlinecode"><span class="kobospan" id="kobo.529.1">then</span></code><span class="kobospan" id="kobo.530.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.531.1">catch</span></code><span class="kobospan" id="kobo.532.1"> methods separates successful results from errors, unlike the callback API, which presents both and requires the callback function to work out what happened.</span></p>
<p class="normal"><span class="kobospan" id="kobo.533.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.534.1">then</span></code><span class="kobospan" id="kobo.535.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.536.1">catch</span></code><span class="kobospan" id="kobo.537.1"> methods can be chained together, which is one small improvement in simplifying the code, as shown in </span><em class="italic"><span class="kobospan" id="kobo.538.1">Listing 4.13</span></em><span class="kobospan" id="kobo.539.1">, and is a more typical way to use promises.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.540.1">Listing 4.13: Chaining promise methods in the handler.ts file in the src folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.541.1">import { IncomingMessage, ServerResponse } from "http";
import { readFile } from "fs/promises";
export const handler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    </span><strong class="screentext"><span class="kobospan" id="kobo.542.1">readFile("data.json")</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.543.1">        .then((data: Buffer) =&gt; res.end(data, () =&gt; </span></strong><strong class="screentext"><span class="kobospan" id="kobo.544.1">console.log("File sent")))</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.545.1">        .catch((err: Error) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.546.1">            console.log(`Error: ${err.message}`</span></strong><strong class="screentext"><span class="kobospan" id="kobo.547.1">);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.548.1">            res.statusCode = 500;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.549.1">            res.end();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.550.1">        });</span></strong><span class="kobospan" id="kobo.551.1">
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.552.1">This is a little neater, but</span><a id="_idIndexMarker215" class="calibre3"/><span class="kobospan" id="kobo.553.1"> the real improvement comes with the use of the </span><code class="inlinecode"><span class="kobospan" id="kobo.554.1">async</span></code><span class="kobospan" id="kobo.555.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.556.1">await</span></code><span class="kobospan" id="kobo.557.1"> keywords, which allow asynchronous operations to be performed using syntax that doesn’t require nested functions or chained methods, as shown in </span><em class="italic"><span class="kobospan" id="kobo.558.1">Listing 4.14</span></em><span class="kobospan" id="kobo.559.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.560.1">Listing 4.14: Using the async and await Keywords in the handler.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.561.1">import { IncomingMessage, ServerResponse } from "http";
import { readFile } from "fs/promises";
</span><strong class="screentext"><span class="kobospan" id="kobo.562.1">export const handler = async (req: IncomingMessage, res: ServerResponse</span></strong><strong class="screentext"><span class="kobospan" id="kobo.563.1">) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.564.1">    const data: Buffer = await readFile("data.json");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.565.1">    res.end(data, () =&gt; console.log</span></strong><strong class="screentext"><span class="kobospan" id="kobo.566.1">("File sent"));</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.567.1">};</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.568.1">Using the </span><code class="inlinecode"><span class="kobospan" id="kobo.569.1">async</span></code><span class="kobospan" id="kobo.570.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.571.1">await</span></code><span class="kobospan" id="kobo.572.1"> keywords flattens the code by removing the need for the </span><code class="inlinecode"><span class="kobospan" id="kobo.573.1">then</span></code><span class="kobospan" id="kobo.574.1"> method and its function. </span><span class="kobospan" id="kobo.574.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.575.1">async</span></code><span class="kobospan" id="kobo.576.1"> keyword is applied to the function used to handle requests: </span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.577.1">...
</span><span class="kobospan" id="kobo.577.2">export const handler = </span><strong class="screentext"><span class="kobospan" id="kobo.578.1">async</span></strong><span class="kobospan" id="kobo.579.1"> (req: IncomingMessage, res: ServerResponse) =&gt; {
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.580.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.581.1">await</span></code><span class="kobospan" id="kobo.582.1"> keyword is applied to statements that return promises, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.583.1">...</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.584.1">const data: Buffer = await readFile("data.json");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.585.1">...</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.586.1">These keywords don’t change the behavior of the </span><code class="inlinecode"><span class="kobospan" id="kobo.587.1">readFile</span></code><span class="kobospan" id="kobo.588.1"> function, which still reads a file asynchronously and still returns a </span><code class="inlinecode"><span class="kobospan" id="kobo.589.1">Promise&lt;Buffer&gt;</span></code><span class="kobospan" id="kobo.590.1">, but the JavaScript runtime takes the result asynchronously produced by the promise, a </span><code class="inlinecode"><span class="kobospan" id="kobo.591.1">Buffer</span></code><span class="kobospan" id="kobo.592.1"> object in this case, assigns it to a constant named </span><code class="inlinecode"><span class="kobospan" id="kobo.593.1">data</span></code><span class="kobospan" id="kobo.594.1">, and then executes the statements that follow. </span><span class="kobospan" id="kobo.594.2">The result is the same – and the way that the result is obtained is also the same – but the syntax is simpler and easier to read.</span></p>
<p class="normal"><span class="kobospan" id="kobo.595.1">This isn’t the</span><a id="_idIndexMarker216" class="calibre3"/><span class="kobospan" id="kobo.596.1"> final version of the code. </span><span class="kobospan" id="kobo.596.2">To support error handling, the </span><code class="inlinecode"><span class="kobospan" id="kobo.597.1">catch</span></code><span class="kobospan" id="kobo.598.1"> method used on </span><code class="inlinecode"><span class="kobospan" id="kobo.599.1">Promise</span></code><span class="kobospan" id="kobo.600.1"> objects is replaced with a </span><code class="inlinecode"><span class="kobospan" id="kobo.601.1">try/catch</span></code><span class="kobospan" id="kobo.602.1"> block when using the </span><code class="inlinecode"><span class="kobospan" id="kobo.603.1">await</span></code><span class="kobospan" id="kobo.604.1"> keyword, as shown in </span><em class="italic"><span class="kobospan" id="kobo.605.1">Listing 4.15</span></em><span class="kobospan" id="kobo.606.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.607.1">Listing 4.15: Adding error handling in the handler.ts file in the src folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.608.1">import { IncomingMessage, ServerResponse } from "http";
import { readFile } from "fs/promises";
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
</span><strong class="screentext"><span class="kobospan" id="kobo.609.1">    try {</span></strong><span class="kobospan" id="kobo.610.1">
        const data: Buffer = await readFile("data.json");
        res.end(data, () =&gt; console.log("File sent"));
</span><strong class="screentext"><span class="kobospan" id="kobo.611.1">    } catch (err: any) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.612.1">        console.log(`Error: ${err?.message ?? </span><span class="kobospan" id="kobo.612.2">err}</span></strong><strong class="screentext"><span class="kobospan" id="kobo.613.1">`);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.614.1">        res.statusCode = 500;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.615.1">        res.end();  </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.616.1">    }</span></strong><span class="kobospan" id="kobo.617.1">
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.618.1">The type of the value provided to the </span><code class="inlinecode"><span class="kobospan" id="kobo.619.1">catch</span></code><span class="kobospan" id="kobo.620.1"> exception is </span><code class="inlinecode"><span class="kobospan" id="kobo.621.1">any</span></code><span class="kobospan" id="kobo.622.1">, not </span><code class="inlinecode"><span class="kobospan" id="kobo.623.1">Error</span></code><span class="kobospan" id="kobo.624.1">, because JavaScript doesn’t restrict the types that can be used to represent errors.</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.625.1">Tip</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.626.1">One advantage of callbacks over promises is that callbacks can be invoked more than once for the same operation, allowing a series of updates to be provided while asynchronous work is being performed. </span><span class="kobospan" id="kobo.626.2">Promises are intended to produce a single result without any interim updates. </span><span class="kobospan" id="kobo.626.3">You can see an example of this difference at the end of the chapter.</span></p>
</div>
<h2 class="heading1" id="_idParaDest-88"><span class="kobospan" id="kobo.627.1">Wrapping callbacks and unwrapping promises</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.628.1">Not every part of </span><a id="_idIndexMarker217" class="calibre3"/><span class="kobospan" id="kobo.629.1">the Node.js API supports both</span><a id="_idIndexMarker218" class="calibre3"/><span class="kobospan" id="kobo.630.1"> promises and callbacks, and that can lead to both approaches being mixed in the same code. </span><span class="kobospan" id="kobo.630.2">You can see this problem in the example, where the </span><code class="inlinecode"><span class="kobospan" id="kobo.631.1">readFile</span></code><span class="kobospan" id="kobo.632.1"> function returns a promise, but the </span><code class="inlinecode"><span class="kobospan" id="kobo.633.1">end</span></code><span class="kobospan" id="kobo.634.1"> method, which sends data to the client and finishes the HTTP response, uses a callback:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.635.1">...
</span><span class="kobospan" id="kobo.635.2">const data: Buffer = await readFile("data.json");
res.end(data, </span><strong class="screentext"><span class="kobospan" id="kobo.636.1">() =&gt; </span></strong><strong class="screentext"><span class="kobospan" id="kobo.637.1">console.log("File sent")</span></strong><span class="kobospan" id="kobo.638.1">);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.639.1">The promise and callback APIs can be mixed without problems, but the result can be awkward code. </span><span class="kobospan" id="kobo.639.2">To help ensure consistency, the Node.js API includes two useful functions in the </span><code class="inlinecode"><span class="kobospan" id="kobo.640.1">util</span></code><span class="kobospan" id="kobo.641.1"> module, which are described in </span><em class="italic"><span class="kobospan" id="kobo.642.1">Table 4.4</span></em><span class="kobospan" id="kobo.643.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.644.1">Table 4.4: The Functions for wrapping callbacks and unwrapping promises </span></p>
<table class="table-container" id="table004">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.645.1">Name</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.646.1">Description</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.647.1">promisify</span></code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.648.1">This function creates a </span><code class="inlinecode"><span class="kobospan2" id="kobo.649.1">Promise</span></code><span class="kobospan" id="kobo.650.1"> from a function that accepts a conventional callback. </span><span class="kobospan" id="kobo.650.2">The convention is that the arguments passed to the callback are an error object and the result of the operation. </span><span class="kobospan" id="kobo.650.3">There is support for other arrangements of arguments using a custom symbol – see </span><a href="https://nodejs.org/docs/latest/api/util.html#utilpromisifycustom" class="calibre3"><span class="url"><span class="kobospan2" id="kobo.651.1">https://nodejs.org/docs/latest/api/util.html#utilpromisifycustom</span></span></a><span class="kobospan4" id="kobo.652.1"> for details.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.653.1">callbackify</span></code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.654.1">This function accepts a </span><code class="inlinecode"><span class="kobospan2" id="kobo.655.1">Promise</span></code><span class="kobospan4" id="kobo.656.1"> object and returns a function that will accept a conventional callback.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="kobospan" id="kobo.657.1">The idea behind these functions is good, but they have limitations, especially when trying to create promises from callbacks so that the </span><code class="inlinecode"><span class="kobospan" id="kobo.658.1">await</span></code><span class="kobospan" id="kobo.659.1"> keyword can be used. </span><span class="kobospan" id="kobo.659.2">The biggest restriction is that the </span><code class="inlinecode"><span class="kobospan" id="kobo.660.1">promisify</span></code><span class="kobospan" id="kobo.661.1"> function doesn’t work seamlessly on class methods unless care is taken to deal with the way that JavaScript handles the </span><code class="inlinecode"><span class="kobospan" id="kobo.662.1">this</span></code><span class="kobospan" id="kobo.663.1"> keyword. </span><span class="kobospan" id="kobo.663.2">There is also an issue specific to TypeScript, where the compiler doesn’t correctly identify the types involved.</span></p>
<p class="normal"><span class="kobospan" id="kobo.664.1">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.665.1">promises.ts</span></code><span class="kobospan" id="kobo.666.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.667.1">src</span></code><span class="kobospan" id="kobo.668.1"> folder with the contents shown in </span><em class="italic"><span class="kobospan" id="kobo.669.1">Listing 4.16</span></em><span class="kobospan" id="kobo.670.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.671.1">Listing 4.16: The Contents of the promises.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.672.1">import { ServerResponse } from "http";
import { promisify } from "util";
export const endPromise = promisify(ServerResponse.prototype.end) as
    (data: any) =&gt; Promise&lt;void&gt;;
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.673.1">The </span><a id="_idIndexMarker219" class="calibre3"/><span class="kobospan" id="kobo.674.1">first step is to use </span><code class="inlinecode"><span class="kobospan" id="kobo.675.1">promisify</span></code><span class="kobospan" id="kobo.676.1"> to create a function </span><a id="_idIndexMarker220" class="calibre3"/><span class="kobospan" id="kobo.677.1">that returns a promise, which I do by passing the </span><code class="inlinecode"><span class="kobospan" id="kobo.678.1">ServerResponse.prototype.end</span></code><span class="kobospan" id="kobo.679.1"> function to </span><code class="inlinecode"><span class="kobospan" id="kobo.680.1">promisify</span></code><span class="kobospan" id="kobo.681.1">. </span><span class="kobospan" id="kobo.681.2">I use the </span><code class="inlinecode"><span class="kobospan" id="kobo.682.1">as</span></code><span class="kobospan" id="kobo.683.1"> keyword to override the type inferred by the TypeScript compiler with a description of the method parameters and result:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.684.1">...
</span><span class="kobospan" id="kobo.684.2">export const endPromise = promisify(ServerResponse.prototype.end) as
    </span><strong class="screentext"><span class="kobospan" id="kobo.685.1">(data: any) =&gt; Promise&lt;void&gt;;</span></strong><span class="kobospan" id="kobo.686.1">
...
</span></code></pre>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.687.1">Listing 4.17</span></em><span class="kobospan" id="kobo.688.1"> imports the function defined in </span><em class="italic"><span class="kobospan" id="kobo.689.1">Listing 4.16</span></em><span class="kobospan" id="kobo.690.1"> and uses the promise it produces.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.691.1">Listing 4.17: Using a Promise in the handler.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.692.1">import { IncomingMessage, ServerResponse } from "http";
import { readFile } from "fs/promises";
</span><strong class="screentext"><span class="kobospan" id="kobo.693.1">import { endPromise } from "./promises";</span></strong><span class="kobospan" id="kobo.694.1">
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    try {
        const data: Buffer = await readFile("data.json");
</span><strong class="screentext"><span class="kobospan" id="kobo.695.1">        await endPromise.bind(res)(data);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.696.1">        console.log("File sent");</span></strong><span class="kobospan" id="kobo.697.1">
    } catch (err: any) {
        console.log(`Error: ${err?.message ?? </span><span class="kobospan" id="kobo.697.2">err}`);
        res.statusCode = 500;
        res.end();  
    }
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.698.1">I have to use the </span><code class="inlinecode"><span class="kobospan" id="kobo.699.1">bind</span></code><span class="kobospan" id="kobo.700.1"> method when using the </span><code class="inlinecode"><span class="kobospan" id="kobo.701.1">await</span></code><span class="kobospan" id="kobo.702.1"> keyword on the function that </span><code class="inlinecode"><span class="kobospan" id="kobo.703.1">promisify</span></code><span class="kobospan" id="kobo.704.1"> creates, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.705.1">...
</span><span class="kobospan" id="kobo.705.2">await endPromise.</span><strong class="screentext"><span class="kobospan" id="kobo.706.1">bind(res)</span></strong><span class="kobospan" id="kobo.707.1">(data);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.708.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.709.1">bind</span></code><span class="kobospan" id="kobo.710.1"> method </span><a id="_idIndexMarker221" class="calibre3"/><span class="kobospan" id="kobo.711.1">associates the </span><code class="inlinecode"><span class="kobospan" id="kobo.712.1">ServerResponse</span></code><span class="kobospan" id="kobo.713.1"> object </span><a id="_idIndexMarker222" class="calibre3"/><span class="kobospan" id="kobo.714.1">for which the function is being invoked. </span><span class="kobospan" id="kobo.714.2">The result is a new function, which is invoked by passing the data that will be sent to the client:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.715.1">...
</span><span class="kobospan" id="kobo.715.2">await endPromise.bind(res)(</span><strong class="screentext"><span class="kobospan" id="kobo.716.1">data</span></strong><span class="kobospan" id="kobo.717.1">);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.718.1">The result is that the </span><code class="inlinecode"><span class="kobospan" id="kobo.719.1">await</span></code><span class="kobospan" id="kobo.720.1"> keyword can be used instead of the callback, even though it is a slightly awkward process.</span></p>
<h1 class="heading" id="_idParaDest-89"><span class="kobospan" id="kobo.721.1">Executing custom code</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.722.1">All JavaScript code is </span><a id="_idIndexMarker223" class="calibre3"/><span class="kobospan" id="kobo.723.1">executed by the main thread, which means that any operation that doesn’t use the non-blocking API provided by Node.js will block the thread. </span><span class="kobospan" id="kobo.723.2">For the sake of consistency, add the statement shown in </span><em class="italic"><span class="kobospan" id="kobo.724.1">Listing 4.18</span></em><span class="kobospan" id="kobo.725.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.726.1">promises.ts</span></code><span class="kobospan" id="kobo.727.1"> file to wrap the </span><code class="inlinecode"><span class="kobospan" id="kobo.728.1">write</span></code><span class="kobospan" id="kobo.729.1"> method defined by the </span><code class="inlinecode"><span class="kobospan" id="kobo.730.1">ServerResponse</span></code><span class="kobospan" id="kobo.731.1"> class in a promise.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.732.1">Listing 4.18: Adding a Function in the promises.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.733.1">import { ServerResponse } from "http";
import { promisify } from "util";
export const endPromise = promisify(ServerResponse.prototype.end) as
    (data: any) =&gt; Promise&lt;void&gt;;
</span><strong class="screentext"><span class="kobospan" id="kobo.734.1">export const writePromise = promisify(ServerResponse.prototype.write) as</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.735.1">    (data: any) =&gt; Promise&lt;void&gt;;</span></strong>
</code></pre>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.736.1">Listing 4.19</span></em><span class="kobospan" id="kobo.737.1"> filters out</span><a id="_idIndexMarker224" class="calibre3"/><span class="kobospan" id="kobo.738.1"> the requests for the </span><code class="inlinecode"><span class="kobospan" id="kobo.739.1">favicon.ico</span></code><span class="kobospan" id="kobo.740.1"> file, which was fine in earlier examples, but will add unwanted requests in this section.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.741.1">Listing 4.19: Filtering Requests in the server.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.742.1">import { createServer } from "http";
import { handler } from "./handler";
const port = 5000;
const server = createServer();
</span><strong class="screentext"><span class="kobospan" id="kobo.743.1">server.on("request", (req, res) =&gt;</span></strong><strong class="screentext"><span class="kobospan" id="kobo.744.1"> {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.745.1">    if (req.url?.endsWith("favicon.ico")) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.746.1">        res.statusCode = 404;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.747.1">        res.end();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.748.1">    } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.749.1">        handler(req, res)</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.750.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.751.1">});</span></strong><span class="kobospan" id="kobo.752.1">
server.listen(port);
server.on("listening", () =&gt; {
    console.log(`(Event) Server listening on port ${port}`);
});
</span></code></pre>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.753.1">Listing 4.20</span></em><span class="kobospan" id="kobo.754.1"> demonstrates the problem of thread blocking by introducing a time-consuming operation that is implemented entirely in JavaScript.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.755.1">Listing 4.20: A Blocking Operation in the handler.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.756.1">import { IncomingMessage, ServerResponse } from "http";
</span><strong class="screentext"><span class="kobospan" id="kobo.757.1">//import { readFile } from "fs/promises";</span></strong><span class="kobospan" id="kobo.758.1">
import { endPromise, writePromise } from "./promises";
</span><strong class="screentext"><span class="kobospan" id="kobo.759.1">const total = 2_000_000_000;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.760.1">const</span></strong><strong class="screentext"><span class="kobospan" id="kobo.761.1"> iterations = 5;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.762.1">let shared_counter = 0;</span></strong><span class="kobospan" id="kobo.763.1">
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
   </span><strong class="screentext"><span class="kobospan" id="kobo.764.1"> const</span></strong><strong class="screentext"><span class="kobospan" id="kobo.765.1"> request = shared_counter++;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.766.1">    for (let iter = 0; iter &lt; iterations; iter++) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.767.1">        for (let count = 0; count &lt; total; count++) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.768.1">            count++;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.769.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.770.1">        const msg = `Request: ${request}, Iteration: ${(iter)}`</span></strong><strong class="screentext"><span class="kobospan" id="kobo.771.1">;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.772.1">        console.log(msg);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.773.1">        await writePromise.bind(res)(msg + "\n");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.774.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.775.1">    await endPromise.bind(res)("Done");</span></strong><span class="kobospan" id="kobo.776.1">
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.777.1">Two </span><code class="inlinecode"><span class="kobospan" id="kobo.778.1">for</span></code><span class="kobospan" id="kobo.779.1"> loops</span><a id="_idIndexMarker225" class="calibre3"/><span class="kobospan" id="kobo.780.1"> repeatedly increment a number value and, since this operation is written entirely in JavaScript, the main thread is blocked until both the loops have completed. </span><span class="kobospan" id="kobo.780.2">To see the effect of the blocked thread, open two browser tabs and request </span><a href="http://localhost:5000" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.781.1">http://localhost:5000</span></span></a><span class="kobospan" id="kobo.782.1"> in both of them. </span><span class="kobospan" id="kobo.782.2">You need to start the request in the second tab before the first one has finished, and you may need to adjust the </span><code class="inlinecode"><span class="kobospan" id="kobo.783.1">total</span></code><span class="kobospan" id="kobo.784.1"> value to give yourself time. </span><span class="kobospan" id="kobo.784.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.785.1">total</span></code><span class="kobospan" id="kobo.786.1"> value in </span><em class="italic"><span class="kobospan" id="kobo.787.1">Listing 4.20</span></em><span class="kobospan" id="kobo.788.1"> takes three or four seconds to complete on my system, which is long enough to start requests in both browser tabs.</span></p>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.789.1">Avoiding the browser cache problem</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.790.1">Some browsers, including Chrome, won’t make simultaneous requests for the same URL. </span><span class="kobospan" id="kobo.790.2">This means that the request from the second browser tab won’t be started until the response from the first tab’s request has been received, which can make it look like requests are always blocking.</span></p>
<p class="normal"><span class="kobospan" id="kobo.791.1">Browsers do this to see if the result from the first request can be added to their cache and used for subsequent requests. </span><span class="kobospan" id="kobo.791.2">This is not usually an issue, but it can be confusing, especially for features like the ones discussed in this chapter.</span></p>
<p class="normal"><span class="kobospan" id="kobo.792.1">You can avoid this problem by disabling the browser cache (Chrome has a </span><strong class="screentext"><span class="kobospan" id="kobo.793.1">Disable Cache</span></strong><span class="kobospan" id="kobo.794.1"> checkbox on the </span><strong class="screentext"><span class="kobospan" id="kobo.795.1">Network</span></strong><span class="kobospan" id="kobo.796.1"> tab in the </span><em class="italic"><span class="kobospan" id="kobo.797.1">F12</span></em><span class="kobospan" id="kobo.798.1"> developer tools window, for example) or requesting different URLs, such as </span><code class="inlinecode"><span class="kobospan" id="kobo.799.1">http://localhost:5000?id=1</span></code><span class="kobospan" id="kobo.800.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.801.1">http://localhost:5000?id=2</span></code><span class="kobospan" id="kobo.802.1">.</span></p>
</div>
<p class="normal"><span class="kobospan" id="kobo.803.1">You will see </span><a id="_idIndexMarker226" class="calibre3"/><span class="kobospan" id="kobo.804.1">that both browser tabs get results, as shown in </span><em class="italic"><span class="kobospan" id="kobo.805.1">Figure 4.10</span></em><span class="kobospan" id="kobo.806.1">. </span><span class="kobospan" id="kobo.806.2">Each request is identified by incrementing the </span><code class="inlinecode"><span class="kobospan" id="kobo.807.1">shared_counter</span></code><span class="kobospan" id="kobo.808.1"> value, which makes it easy to correlate the output displayed in the browser with the Node.js console messages.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.809.1"><img alt="" src="../Images/B21959_04_10.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.810.1">Figure 4.10: Blocking the main thread</span></p>
<p class="normal"><span class="kobospan" id="kobo.811.1">Examine the Node.js console output and you will see that all of the iterations from the first request were completed before the work for the second request was started:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.812.1">...
</span><span class="kobospan" id="kobo.812.2">Request: 0, Iteration: 0
Request: 0, Iteration: 1
Request: 0, Iteration: 2
Request: 0, Iteration: 3
Request: 0, Iteration: 4
Request: 1, Iteration: 0
Request: 1, Iteration: 1
Request: 1, Iteration: 2
Request: 1, Iteration: 3
Request: 1, Iteration: 4
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.813.1">This is a typical, albeit exaggerated, example of blocking the JavaScript thread, so that requests </span><a id="_idIndexMarker227" class="calibre3"/><span class="kobospan" id="kobo.814.1">queue up waiting for their turn to be handled and the overall request throughput drops.</span></p>
<h2 class="heading1" id="_idParaDest-90"><span class="kobospan" id="kobo.815.1">Yielding control of the main thread</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.816.1">One way to </span><a id="_idIndexMarker228" class="calibre3"/><span class="kobospan" id="kobo.817.1">address blocking is to break up work into smaller chunks that are interleaved with other requests. </span><span class="kobospan" id="kobo.817.2">The work is still done entirely with the main thread, but the blocking occurs in a series of shorter periods, which means that access to the main thread is more equitable.</span></p>
<p class="normal"><em class="italic"><span class="kobospan" id="kobo.818.1">Table 4.5</span></em><span class="kobospan" id="kobo.819.1"> describes the functions that are available for telling Node.js to invoke a function in the future. </span><span class="kobospan" id="kobo.819.2">(As before, I am simplifying things here to avoid getting into the low-level details of the Node.js event loop.) </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.820.1">Table 4.5: The scheduling functions</span></p>
<table class="table-container" id="table005">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.821.1">Name</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.822.1">Description</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.823.1">setImmediate</span></code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.824.1">This function tells Node.js to add a function to the callback queue.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.825.1">setTimeout</span></code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan2" id="kobo.826.1">This function tells Node.js to add a function to the callback queue that should not be invoked for at least a specified number of milliseconds.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="kobospan" id="kobo.827.1">These are </span><em class="italic"><span class="kobospan" id="kobo.828.1">global </span></em><span class="kobospan" id="kobo.829.1">functions, which means they can be used without a module import. </span><em class="italic"><span class="kobospan" id="kobo.830.1">Listing 4.21</span></em><span class="kobospan" id="kobo.831.1"> uses the </span><code class="inlinecode"><span class="kobospan" id="kobo.832.1">setImmediate</span></code><span class="kobospan" id="kobo.833.1"> function so that the counting operation is broken up into smaller blocks of work. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.834.1">Listing 4.21: Using the setImmediate Function in the handler.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword"><span class="kobospan" id="kobo.835.1">import</span></span><span class="kobospan" id="kobo.836.1"> { </span><span class="hljs-title"><span class="kobospan" id="kobo.837.1">IncomingMessage</span></span><span class="kobospan" id="kobo.838.1">, </span><span class="hljs-title"><span class="kobospan" id="kobo.839.1">ServerResponse</span></span><span class="kobospan" id="kobo.840.1"> } </span><span class="hljs-keyword"><span class="kobospan" id="kobo.841.1">from</span></span> <span class="hljs-string"><span class="kobospan" id="kobo.842.1">"http"</span></span><span class="kobospan" id="kobo.843.1">;
</span><span class="hljs-keyword"><span class="kobospan" id="kobo.844.1">i</span></span><span class="kobospan" id="kobo.845.1">mport { endPromise, writePromise } from "./promises";
const total = 2_000_000_000;
const iterations = 5;
let shared_counter = 0;
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    const request = shared_counter++;
    </span><strong class="screentext"><span class="kobospan" id="kobo.846.1">const iterate = async (iter: number = 0) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.847.1">        for (let count = 0; count &lt; total; count++) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.848.1">            count++;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.849.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.850.1">        const msg = `Request: ${request}, Iteration: ${(iter)}`;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.851.1">        console.log(msg);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.852.1">        await writePromise.bind(res)(msg + "\n"</span></strong><strong class="screentext"><span class="kobospan" id="kobo.853.1">);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.854.1">        if (iter == iterations -1) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.855.1">            await endPromise.bind(res)("Done");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.856.1">        } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.857.1">            setImmediate(() =&gt; iterate</span></strong><strong class="screentext"><span class="kobospan" id="kobo.858.1">(++iter));</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.859.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.860.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.861.1">    iterate();</span></strong><span class="kobospan" id="kobo.862.1">
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.863.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.864.1">iterate</span></code><span class="kobospan" id="kobo.865.1"> function </span><a id="_idIndexMarker229" class="calibre3"/><span class="kobospan" id="kobo.866.1">performs one block of counting and then uses the </span><code class="inlinecode"><span class="kobospan" id="kobo.867.1">setImmediate</span></code><span class="kobospan" id="kobo.868.1"> function to defer the next block. </span><span class="kobospan" id="kobo.868.2">Use two browser tabs to request </span><code class="inlinecode"><span class="kobospan" id="kobo.869.1">http://localhost:5000</span></code><span class="kobospan" id="kobo.870.1"> (or </span><code class="inlinecode"><span class="kobospan" id="kobo.871.1">http://localhost:5000?id=1</span></code><span class="kobospan" id="kobo.872.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.873.1">http://localhost:5000?id=2</span></code><span class="kobospan" id="kobo.874.1"> if you have not disabled the browser cache) and you will see the console messages generated by Node.js show that the work performed for the two requests has been interleaved:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.875.1">...
</span><span class="kobospan" id="kobo.875.2">Request: 0, Iteration: 0
Request: 0, Iteration: 1
Request: 1, Iteration: 0
Request: 0, Iteration: 2
Request: 1, Iteration: 1
Request: 0, Iteration: 3
Request: 1, Iteration: 2
Request: 0, Iteration: 4
Request: 1, Iteration: 3
Request: 1, Iteration: 4
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.876.1">You may</span><a id="_idIndexMarker230" class="calibre3"/><span class="kobospan" id="kobo.877.1"> see a different sequence of iterations, but the important point is that the work for HTTP requests is broken up and interleaved.</span></p>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.878.1">Avoiding the pure JavaScript promise pitfall</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.879.1">A common mistake is to try and wrap blocking JavaScript code in a promise, like this:</span></p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2"><span class="kobospan" id="kobo.880.1">...</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.881.1">await new Promise&lt;void&gt;(resolve =&gt; {</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.882.1">    // executor - perform one unit of blocking work</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.883.1">    resolve();</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.884.1">}).then(() =&gt; {</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.885.1">    // follow on - set up next unit of work</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.886.1">});</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.887.1">...</span></code>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.888.1">There are two pitfalls for the unwary developer with this approach. </span><span class="kobospan" id="kobo.888.2">The first is that the </span><em class="italic"><span class="kobospan" id="kobo.889.1">executor</span></em><span class="kobospan" id="kobo.890.1">, which is the function that performs the work, is performed synchronously. </span><span class="kobospan" id="kobo.890.2">This may seem odd, but remember that all JavaScript code is executed synchronously, and the expectation is that the executor will be used to invoke asynchronous API methods that will produce results in the future and be added to the callback queue for eventual processing.</span></p>
<p class="normal"><span class="kobospan" id="kobo.891.1">The second pitfall is that the </span><em class="italic"><span class="kobospan" id="kobo.892.1">follow-on</span></em> <em class="italic"><span class="kobospan" id="kobo.893.1">function</span></em><span class="kobospan" id="kobo.894.1">, passed to the </span><code class="inlinecode"><span class="kobospan" id="kobo.895.1">then</span></code><span class="kobospan" id="kobo.896.1"> method, is executed as soon as the executor completes, before the main thread returns to the callback queue to get another function to execute, with the effect that there is no interleaving of work.</span></p>
<p class="normal"><span class="kobospan" id="kobo.897.1">Promises are a useful way of consuming an API that uses native threads to perform asynchronous work but they don’t help when executing pure JavaScript code.</span></p>
</div>
<h2 class="heading1" id="_idParaDest-91"><span class="kobospan" id="kobo.898.1">Using worker threads</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.899.1">The key limitation of</span><a id="_idIndexMarker231" class="calibre3"/><span class="kobospan" id="kobo.900.1"> the previous example is there is still only one main thread, and it still has to do all the work, regardless of how equitably that work is done. </span></p>
<p class="normal"><span class="kobospan" id="kobo.901.1">Node.js supports </span><em class="italic"><span class="kobospan" id="kobo.902.1">worker threads</span></em><span class="kobospan" id="kobo.903.1">, which are additional threads for executing JavaScript code, albeit with restrictions. </span><span class="kobospan" id="kobo.903.2">JavaScript doesn’t have the features for coordinating threads that are found in other languages, such as C# or Java, and trying to add them would be difficult. </span><span class="kobospan" id="kobo.903.3">Instead, worker threads run in separate instances of the Node.js engine, executing code in isolation from the main thread. </span><span class="kobospan" id="kobo.903.4">Communication between the main thread and worker threads is done using events, as shown in </span><em class="italic"><span class="kobospan" id="kobo.904.1">Figure 4.11</span></em><span class="kobospan" id="kobo.905.1">, which fits nicely into the JavaScript event loop, so that the results produced by worker threads are processed by callback functions, just like any other JavaScript code.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.906.1"><img alt="" src="../Images/B21959_04_11.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.907.1">Figure 4.11: The main thread and worker threads</span></p>
<p class="normal"><span class="kobospan" id="kobo.908.1">Worker threads are not the solution to every problem because there is overhead in creating and managing them, but they provide an effective way to execute JavaScript code without blocking the main thread.</span></p>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.909.1">Understanding worker threads versus the worker pool</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.910.1">There is a terminology overlap that can cause confusion because Node.js uses two similar terms: </span><em class="italic"><span class="kobospan" id="kobo.911.1">worker threads</span></em><span class="kobospan" id="kobo.912.1"> and the </span><em class="italic"><span class="kobospan" id="kobo.913.1">worker pool</span></em><span class="kobospan" id="kobo.914.1">. </span><span class="kobospan" id="kobo.914.2">Worker threads are the topic of this part of the chapter and are started by the programmer to perform JavaScript code without blocking the main thread. </span><span class="kobospan" id="kobo.914.3">The worker pool is the set of threads that Node.js uses to implement the asynchronous features of its API, such as the functions used in this chapter to read files and write HTTP responses. </span><span class="kobospan" id="kobo.914.4">You don’t interact directly with the worker pool, which is managed by Node.js automatically.</span></p>
<p class="normal"><span class="kobospan" id="kobo.915.1">Just to add to the confusion, worker threads are often grouped into a pool for performance reasons, allowing individual worker threads to be reused instead of used once and then discarded. </span><span class="kobospan" id="kobo.915.2">I will explain how this is done in </span><em class="italic"><span class="kobospan" id="kobo.916.1">Part 2</span></em><span class="kobospan" id="kobo.917.1">.</span></p>
</div>
<h3 class="heading2" id="_idParaDest-92"><span class="kobospan" id="kobo.918.1">Writing the worker code</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.919.1">The code</span><a id="_idIndexMarker232" class="calibre3"/><span class="kobospan" id="kobo.920.1"> that worker threads execute is defined separately from the rest of the JavaScript application. </span><span class="kobospan" id="kobo.920.2">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.921.1">count_worker.ts</span></code><span class="kobospan" id="kobo.922.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.923.1">src</span></code><span class="kobospan" id="kobo.924.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.925.1">Listing 4.22</span></em><span class="kobospan" id="kobo.926.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.927.1">Listing 4.22: The contents of the count_worker.ts file in the src folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.928.1">import { workerData, parentPort  } from "worker_threads";
console.log(`Worker thread ${workerData.request} started`);
for (let iter = 0; iter &lt; workerData.iterations; iter++) {
    for (let count = 0; count &lt; workerData.total; count++) {
        count++;
    }
    parentPort?.postMessage(iter);
}
console.log(`Worker thread ${workerData.request} finished`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.929.1">Worker threads’ features are defined in the </span><code class="inlinecode"><span class="kobospan" id="kobo.930.1">worker_theads</span></code><span class="kobospan" id="kobo.931.1"> module, and two of those features are used in </span><em class="italic"><span class="kobospan" id="kobo.932.1">Listing 4.22</span></em><span class="kobospan" id="kobo.933.1">. </span><span class="kobospan" id="kobo.933.2">The first, </span><code class="inlinecode"><span class="kobospan" id="kobo.934.1">workerData</span></code><span class="kobospan" id="kobo.935.1">, is an object or value used to pass configuration data from the main thread to the worker. </span><span class="kobospan" id="kobo.935.2">In this case, the worker receives three values through </span><code class="inlinecode"><span class="kobospan" id="kobo.936.1">workerData</span></code><span class="kobospan" id="kobo.937.1">, which specify the request ID, the number of iterations, and the target value for each block of counting work:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.938.1">...
</span><span class="kobospan" id="kobo.938.2">console.log(`Worker thread ${</span><strong class="screentext"><span class="kobospan" id="kobo.939.1">workerData.request</span></strong><span class="kobospan" id="kobo.940.1">} started`);
for (let iter = 0; iter &lt; </span><strong class="screentext"><span class="kobospan" id="kobo.941.1">workerData.iterations</span></strong><span class="kobospan" id="kobo.942.1">; iter++) {
    for (let count = 0; count &lt; </span><strong class="screentext"><span class="kobospan" id="kobo.943.1">workerData.total</span></strong><span class="kobospan" id="kobo.944.1">; count++) {
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.945.1">The other</span><a id="_idIndexMarker233" class="calibre3"/><span class="kobospan" id="kobo.946.1"> feature is </span><code class="inlinecode"><span class="kobospan" id="kobo.947.1">parentPort</span></code><span class="kobospan" id="kobo.948.1">, which is used to emit events that will be received by the main thread, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.949.1">...
</span><span class="kobospan" id="kobo.949.2">parentPort?.</span><strong class="screentext"><span class="kobospan" id="kobo.950.1">postMessage</span></strong><span class="kobospan" id="kobo.951.1">(iter);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.952.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.953.1">postMessage</span></code><span class="kobospan" id="kobo.954.1"> method emits a message event and takes care of transferring the argument value from the worker thread’s JavaScript runtime to the main thread. </span><span class="kobospan" id="kobo.954.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.955.1">parentPort</span></code><span class="kobospan" id="kobo.956.1"> value may be </span><code class="inlinecode"><span class="kobospan" id="kobo.957.1">null</span></code><span class="kobospan" id="kobo.958.1">, which is why the </span><code class="inlinecode"><span class="kobospan" id="kobo.959.1">?</span></code><span class="kobospan" id="kobo.960.1"> operator is required when calling the </span><code class="inlinecode"><span class="kobospan" id="kobo.961.1">postMessage</span></code><span class="kobospan" id="kobo.962.1"> method.</span></p>
<h3 class="heading2" id="_idParaDest-93"><span class="kobospan" id="kobo.963.1">Creating a worker thread</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.964.1">The next step is </span><a id="_idIndexMarker234" class="calibre3"/><span class="kobospan" id="kobo.965.1">to update the request-handling code so that it creates a worker thread using the code defined in the previous section, as shown in </span><em class="italic"><span class="kobospan" id="kobo.966.1">Listing 4.23</span></em><span class="kobospan" id="kobo.967.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.968.1">Listing 4.23: Using a worker thread in the handler.ts File in the src Folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.969.1">import { IncomingMessage, ServerResponse } from "http";
import { endPromise, writePromise } from "./promises";
</span><strong class="screentext"><span class="kobospan" id="kobo.970.1">import { Worker } from "worker_threads";</span></strong><span class="kobospan" id="kobo.971.1">
const total = 2_000_000_000;
const iterations = 5;
let shared_counter = 0;
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    const request = shared_counter++;
   
</span><strong class="screentext"><span class="kobospan" id="kobo.972.1">    const worker = new Worker(__dirname + "/count_worker.js", {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.973.1">        workerData: {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.974.1">            iterations,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.975.1">            total,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.976.1">            request</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.977.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.978.1">    });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.979.1">    worker.on("message", </span></strong><strong class="screentext"><span class="kobospan" id="kobo.980.1">async (iter: number) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.981.1">        const msg = `Request: ${request}, Iteration: ${(iter)}`;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.982.1">        console.log(msg);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.983.1">        await writePromise.bind(res)(msg + "</span></strong><strong class="screentext"><span class="kobospan" id="kobo.984.1">\n");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.985.1">    });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.986.1">    worker.on("exit", async (code: number) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.987.1">        if (code == 0) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.988.1">            await endPromise.bind(res)("</span></strong><strong class="screentext"><span class="kobospan" id="kobo.989.1">Done");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.990.1">        } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.991.1">            res.statusCode = 500;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.992.1">            await res.end();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.993.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.994.1">    });</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.995.1">    worker.on("error", async (err) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.996.1">        console.</span></strong><strong class="screentext"><span class="kobospan" id="kobo.997.1">log(err)</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.998.1">        res.statusCode = 500;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.999.1">        await res.end();           </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1000.1">    });</span></strong><span class="kobospan" id="kobo.1001.1">
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1002.1">Worker threads </span><a id="_idIndexMarker235" class="calibre3"/><span class="kobospan" id="kobo.1003.1">are created by instantiating the </span><code class="inlinecode"><span class="kobospan" id="kobo.1004.1">Worker</span></code><span class="kobospan" id="kobo.1005.1"> class, which is defined in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1006.1">worker_threads</span></code><span class="kobospan" id="kobo.1007.1"> module. </span><span class="kobospan" id="kobo.1007.2">The constructor arguments are the JavaScript code file to execute and a configuration object:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1008.1">...
</span><span class="kobospan" id="kobo.1008.2">const worker = new </span><strong class="screentext"><span class="kobospan" id="kobo.1009.1">Worker</span></strong><span class="kobospan" id="kobo.1010.1">(__dirname + "/count_worker.js", {
    workerData: {
        iterations,
        total,
        request
    }
});
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1011.1">Node.js </span><a id="_idIndexMarker236" class="calibre3"/><span class="kobospan" id="kobo.1012.1">provides two global values that provide path information about the current module and are useful for specifying file paths, which are described in </span><em class="italic"><span class="kobospan" id="kobo.1013.1">Table 4.6</span></em><span class="kobospan" id="kobo.1014.1"> for quick reference. </span><span class="kobospan" id="kobo.1014.2">To specify the code file created in </span><em class="italic"><span class="kobospan" id="kobo.1015.1">Listing 4.22</span></em><span class="kobospan" id="kobo.1016.1">, I combine the </span><code class="inlinecode"><span class="kobospan" id="kobo.1017.1">__dirname</span></code><span class="kobospan" id="kobo.1018.1"> value with the name of the compiled JavaScript file (not the TypeScript file, which can’t be executed directly by Node.js).</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1019.1">Table 4.6: The global values for the current module</span></p>
<table class="table-container" id="table006">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><strong class="keyword"><span class="kobospan2" id="kobo.1020.1">Name</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyword"><span class="kobospan2" id="kobo.1021.1">Description</span></strong></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.1022.1">__filename</span></code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.1023.1">This value contains the file name of the current module. </span><span class="kobospan4" id="kobo.1023.2">Remember this will be the name of the JavaScript file and not the TypeScript file.</span></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1"><span class="kobospan2" id="kobo.1024.1">__dirname</span></code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal"><span class="kobospan3" id="kobo.1025.1">This value contains the name of the directory that contains the current module. </span><span class="kobospan4" id="kobo.1025.2">Remember this will be the directory that contains the compiled JavaScript file and not the TypeScript file.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="kobospan" id="kobo.1026.1">The configuration object passed to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1027.1">Worker</span></code><span class="kobospan" id="kobo.1028.1"> constructor supports configuration settings for managing the way a worker thread is executed, but the only option required for this example is </span><code class="inlinecode"><span class="kobospan" id="kobo.1029.1">workerData</span></code><span class="kobospan" id="kobo.1030.1">, which allows the data values used by the worker thread to be defined.</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.1031.1">Tip</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.1032.1">See </span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options" class="calibre3"><span class="calibre3"><span class="kobospan" id="kobo.1033.1">https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options</span></span></a><span class="kobospan" id="kobo.1034.1"> for the other worker configuration options, although the others are rarely required.</span></p>
</div>
<p class="normal"><span class="kobospan" id="kobo.1035.1">Worker threads communicate with the main thread by emitting events, which are handled by functions registered by the </span><code class="inlinecode"><span class="kobospan" id="kobo.1036.1">on</span></code><span class="kobospan" id="kobo.1037.1"> method, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1038.1">...
</span><span class="kobospan" id="kobo.1038.2">worker.</span><strong class="screentext"><span class="kobospan" id="kobo.1039.1">on</span></strong><span class="kobospan" id="kobo.1040.1">("message", async (iter: number) =&gt; {
    const msg = `Request: ${request}, Iteration: ${(iter)}`;
    console.log(msg);
    await writePromise.bind(res)(msg + "\n");
});
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1041.1">The </span><a id="_idIndexMarker237" class="calibre3"/><span class="kobospan" id="kobo.1042.1">first argument to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1043.1">on</span></code><span class="kobospan" id="kobo.1044.1"> method is a string that specifies the name of the event that will be handled. </span><span class="kobospan" id="kobo.1044.2">This handler is for the </span><code class="inlinecode"><span class="kobospan" id="kobo.1045.1">message</span></code><span class="kobospan" id="kobo.1046.1"> event, which is emitted when the worker uses the </span><code class="inlinecode"><span class="kobospan" id="kobo.1047.1">parentPort.postMessage</span></code><span class="kobospan" id="kobo.1048.1"> method. </span><span class="kobospan" id="kobo.1048.2">In this example, the </span><code class="inlinecode"><span class="kobospan" id="kobo.1049.1">message</span></code><span class="kobospan" id="kobo.1050.1"> event signals that the worker thread has completed one of its counting iterations.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1051.1">There are two other events handled in this example. </span><span class="kobospan" id="kobo.1051.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1052.1">exit</span></code><span class="kobospan" id="kobo.1053.1"> event is triggered by Node.js when the worker thread finishes, and the event provides an exit code that indicates whether the worker finished normally or was terminated with an error. </span><span class="kobospan" id="kobo.1053.2">There is also an </span><code class="inlinecode"><span class="kobospan" id="kobo.1054.1">error</span></code><span class="kobospan" id="kobo.1055.1"> event, which is sent if the JavaScript code executed by the worker thread throws an uncaught exception.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1056.1">Use two browser tabs to request </span><code class="inlinecode"><span class="kobospan" id="kobo.1057.1">http://localhost:5000</span></code><span class="kobospan" id="kobo.1058.1"> (or </span><code class="inlinecode"><span class="kobospan" id="kobo.1059.1">http://localhost:5000?id=1</span></code><span class="kobospan" id="kobo.1060.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.1061.1">http://localhost:5000?id=2</span></code><span class="kobospan" id="kobo.1062.1"> if you have not disabled the browser cache) and you will see Node.js console messages that show calculations performed for the requests overlapping, like this:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1063.1">...
</span><span class="kobospan" id="kobo.1063.2">Worker thread 0 started
Request: 0, Iteration: 0
Request: 0, Iteration: 1
Worker thread 1 started
Request: 0, Iteration: 2
Request: 1, Iteration: 0
Request: 0, Iteration: 3
Request: 1, Iteration: 1
Request: 0, Iteration: 4
Worker thread 0 finished
Request: 1, Iteration: 2
Request: 1, Iteration: 3
Request: 1, Iteration: 4
Worker thread 1 finished
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1064.1">The important </span><a id="_idIndexMarker238" class="calibre3"/><span class="kobospan" id="kobo.1065.1">difference from earlier examples is that work for requests is being performed in parallel, rather than all of the work being performed on a single thread.</span></p>
<h2 class="heading1" id="_idParaDest-94"><span class="kobospan" id="kobo.1066.1">Packaging worker threads into a callback</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1067.1">The </span><a id="_idIndexMarker239" class="calibre3"/><span class="kobospan" id="kobo.1068.1">code in </span><em class="italic"><span class="kobospan" id="kobo.1069.1">Listing 4.23</span></em><span class="kobospan" id="kobo.1070.1"> can be wrapped up so that it is consistent with the Node.js API, using a callback. </span><span class="kobospan" id="kobo.1070.2">For the callback, add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.1071.1">counter_cb.ts</span></code><span class="kobospan" id="kobo.1072.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1073.1">src</span></code><span class="kobospan" id="kobo.1074.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.1075.1">Listing 4.24</span></em><span class="kobospan" id="kobo.1076.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1077.1">Listing 4.24: The contents of the counter_cb.ts file in the src folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1078.1">import { Worker } from "worker_threads";
export const Count = (request: number, iterations: number, total: number,
        callback: (err: Error | null, update: number | boolean) =&gt; void) =&gt; {
    const worker = new Worker(__dirname + "/count_worker.js", {
        workerData: {
            iterations,
            total,
            request
        }
    });
   
    worker.on("message", async (iter: number) =&gt; {
        callback(null, iter);
    });
   
    worker.on("exit", async (code: number) =&gt; {
        callback(code === 0 ? </span><span class="kobospan" id="kobo.1078.2">null : new Error(), true);
    });
   
    worker.on("error", async (err) =&gt; {
        callback(err, true);
    });       
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1079.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1080.1">Count</span></code><span class="kobospan" id="kobo.1081.1"> function </span><a id="_idIndexMarker240" class="calibre3"/><span class="kobospan" id="kobo.1082.1">accepts arguments that describe the work to be done, and a callback function that will be invoked when there is an error, when an iteration completes, and when all of the work is done. </span><em class="italic"><span class="kobospan" id="kobo.1083.1">Listing 4.25</span></em><span class="kobospan" id="kobo.1084.1"> updates the request-handling code to use the </span><code class="inlinecode"><span class="kobospan" id="kobo.1085.1">Count</span></code><span class="kobospan" id="kobo.1086.1"> function.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1087.1">Listing 4.25: Using a callback function in the handler.ts file in the src folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1088.1">import { IncomingMessage, ServerResponse } from "http";
import { endPromise, writePromise } from "./promises";
</span><strong class="screentext"><span class="kobospan" id="kobo.1089.1">//import { Worker } from "worker_threads";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1090.1">import { Count } from "./counter_cb";</span></strong><span class="kobospan" id="kobo.1091.1">
const total = 2_000_000_000;
const iterations = 5;
let shared_counter = 0;
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    const request = shared_counter++;
    C</span><strong class="screentext"><span class="kobospan" id="kobo.1092.1">ount</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1093.1">(request, iterations, total, async (err, update) =&gt; {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1094.1">        if (err !== null) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1095.1">            console.log(err)</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1096.1">            res.statusCode = 500;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1097.1">            await res.end();                       </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1098.1">        } else</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1099.1"> if (update !== true) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1100.1">            const msg = `Request: ${request}, Iteration: ${(update)}`;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1101.1">            console.log(msg);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1102.1">            await writePromise.bind</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1103.1">(res)(msg + "\n");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1104.1">        } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1105.1">            await endPromise.bind(res)("Done");           </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1106.1">        }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1107.1">    });</span></strong><span class="kobospan" id="kobo.1108.1">
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1109.1">This example produces the same results as the previous example but is more consistent with </span><a id="_idIndexMarker241" class="calibre3"/><span class="kobospan" id="kobo.1110.1">the majority of the Node.js API, the key parts of which are described in the chapters that follow.</span></p>
<h2 class="heading1" id="_idParaDest-95"><span class="kobospan" id="kobo.1111.1">Packaging worker threads into a promise</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1112.1">Worker threads can </span><a id="_idIndexMarker242" class="calibre3"/><span class="kobospan" id="kobo.1113.1">also be wrapped up in a promise, although promises are not suited to receive interim updates in the way that callbacks are, and so using a promise will only produce a result when all of the work has been completed or when there is a problem. </span><span class="kobospan" id="kobo.1113.2">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.1114.1">count_promise.ts</span></code><span class="kobospan" id="kobo.1115.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1116.1">src</span></code><span class="kobospan" id="kobo.1117.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.1118.1">Listing 4.26</span></em><span class="kobospan" id="kobo.1119.1">.</span></p>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.1120.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.1121.1">It is possible to produce interim updates with promises, but it requires generating a series of promises that have to be used with the </span><code class="inlinecode"><span class="kobospan" id="kobo.1122.1">await</span></code><span class="kobospan" id="kobo.1123.1"> keyword in a loop. </span><span class="kobospan" id="kobo.1123.2">The result is messy code that doesn’t behave the way that promises usually work and is best avoided. </span><span class="kobospan" id="kobo.1123.3">Use a callback if you need interim updates from a worker thread.</span></p>
</div>
<p class="packt_figref"><span class="kobospan" id="kobo.1124.1">Listing 4.26: The contents of the count_promise.ts file in the src folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1125.1">import { Worker } from "worker_threads";
export const Count = (request: number,
        iterations: number, total: number) : Promise&lt;void&gt; =&gt; {
    return new Promise&lt;void&gt;((resolve, reject) =&gt; {
        const worker = new Worker(__dirname + "/count_worker.js", {
            workerData: {
                iterations, total, request
            }
        });
        worker.on("message", (iter) =&gt; {
            const msg = `Request: ${request}, Iteration: ${(iter)}`;           
            console.log(msg);           
        });
       worker.on("exit", (code) =&gt; {
            if (code !== 0) {
                reject();
            } else {
                resolve();
            }
        });
       
       worker.on("error", reject);       
    });
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1126.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1127.1">Count</span></code><span class="kobospan" id="kobo.1128.1"> function </span><a id="_idIndexMarker243" class="calibre3"/><span class="kobospan" id="kobo.1129.1">returns a </span><code class="inlinecode"><span class="kobospan" id="kobo.1130.1">Promise&lt;void&gt;</span></code><span class="kobospan" id="kobo.1131.1"> whose executor starts a worker thread and sets up handlers for the events it emits. </span><span class="kobospan" id="kobo.1131.2">The functions that handle the </span><code class="inlinecode"><span class="kobospan" id="kobo.1132.1">exit</span></code><span class="kobospan" id="kobo.1133.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.1134.1">error</span></code><span class="kobospan" id="kobo.1135.1"> events resolve or reject the promise, which will either signal that the promise is complete or throw an exception. </span><span class="kobospan" id="kobo.1135.2">The handler function for the </span><code class="inlinecode"><span class="kobospan" id="kobo.1136.1">message</span></code><span class="kobospan" id="kobo.1137.1"> event writes out console messages to show progress but doesn’t affect the outcome of the promise. </span><em class="italic"><span class="kobospan" id="kobo.1138.1">Listing 4.27</span></em><span class="kobospan" id="kobo.1139.1"> revises the request handler to use the promise-based version of the </span><code class="inlinecode"><span class="kobospan" id="kobo.1140.1">Count</span></code><span class="kobospan" id="kobo.1141.1"> function.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1142.1">Listing 4.27: Using a promise in the handler.ts file in the src folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1143.1">import { IncomingMessage, ServerResponse } from "http";
import { endPromise, writePromise } from "./promises";
</span><strong class="screentext"><span class="kobospan" id="kobo.1144.1">//import { Count } from "./counter_cb";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1145.1">import { Count } from "./count_promise";</span></strong><span class="kobospan" id="kobo.1146.1">
const total = 2_000_000_000;
const iterations = 5;
let shared_counter = 0;
export const handler = async (req: IncomingMessage, res: ServerResponse) =&gt; {
    const request = shared_counter++;
  </span><strong class="screentext"> </strong><strong class="screentext"><span class="kobospan" id="kobo.1147.1">try {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1148.1">        await Count(request, iterations, total);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1149.1">        const msg = `Request: ${request}, Iterations: ${(iterations)}`;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1150.1">        await writePromise.bind(res)(msg + "\n");</span></strong>
<strong class="screentext"> </strong><strong class="screentext"><span class="kobospan" id="kobo.1151.1">await endPromise.bind(res)("Done");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1152.1">    } catch (err: any) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1153.1">        console.log(err);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1154.1">        res.statusCode = 500;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1155.1">        res.end();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1156.1">    }</span></strong><span class="kobospan" id="kobo.1157.1">
};
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1158.1">This is </span><a id="_idIndexMarker244" class="calibre3"/><span class="kobospan" id="kobo.1159.1">similar to earlier examples, except the response sent to the client doesn’t include any messages generated at the end of each block of work, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1160.1">Figure 4.12</span></em><span class="kobospan" id="kobo.1161.1">.</span></p>
<figure class="mediaobject"><span class="kobospan" id="kobo.1162.1"><img alt="" src="../Images/B21959_04_12.png" class="calibre7"/></span></figure>
<p class="packt_figref"><span class="kobospan" id="kobo.1163.1">Figure 4.12: The result from the promise-wrapped worker thread</span></p>
<h1 class="heading" id="_idParaDest-96"><span class="kobospan" id="kobo.1164.1">Summary</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.1165.1">In this chapter, I described the way that JavaScript code is executed and explained the effect this has on HTTP request processing and why this approach is different from other platforms. </span><span class="kobospan" id="kobo.1165.2">I explained that JavaScript code is executed on a single main thread and demonstrated the features that Node.js provides for offloading work on other threads.</span></p>
<ul class="calibre4">
<li class="bulletlist"><span class="kobospan" id="kobo.1166.1">JavaScript code is executed on a single thread, known as the main thread</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1167.1">The Node.js API uses native threads to perform many operations to avoid blocking the main thread</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1168.1">The Node.js API largely uses callbacks, but there is also some support for promises</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1169.1">Node.js provides functions for converting callbacks and promises</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1170.1">Node.js supports worker threads for executing JavaScript code without blocking the main thread</span></li>
</ul>
<p class="normal"><span class="kobospan" id="kobo.1171.1">In the next chapter, I will describe the features that Node.js provides for working with HTTP requests.</span></p>
</div>
</body></html>