<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Understanding and Responding to Natural Language</h1></div></div></div><p>We've built bots that can play games, store data, and provide useful information. The next step isn't information gathering, it's processing. This chapter will introduce <strong>natural language processing</strong> (<strong>NLP</strong>) and show how we can use it to enhance our bots even further.</p><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A brief introduction to natural language</li><li class="listitem" style="list-style-type: disc">A Node implementation</li><li class="listitem" style="list-style-type: disc">Natural language processing</li><li class="listitem" style="list-style-type: disc">Natural language generation</li><li class="listitem" style="list-style-type: disc">Displaying data in a natural way</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>A brief introduction to natural language</h1></div></div></div><p>You should always <a class="indexterm" id="id193"/>strive to make your bot as helpful as possible. In all the bots we've made so far, we've awaited clear instructions via a key word from the user and then followed said instructions as far as the bot is capable. What if we could infer instructions from users without them actually providing a key word? Enter <strong>natural language processing</strong> (<strong>NLP</strong>).</p><p>NLP can be described as a field of computer science that strives to understand communication and interactions between computers and human (natural) languages.</p><p>In layman's terms, NLP is the process of a computer interpreting conversational language and responding by executing a command or replying to the user in an equally conversational tone.</p><p>Examples of NLP projects are digital assistants such as the iPhone's Siri. Users can ask questions or give commands and receive answers or confirmation in natural language, seemingly from a human.</p><p>One of the more famous projects using NLP is IBM's Watson system. In 2011, Watson famously competed against human opponents in the TV show Jeopardy! and won first place.</p><p>The NLP field is a large and complicated one, with many years of research performed by prestigious academic institutions and by large technology companies. Watson alone took 5 years, $3 million, and a small army of academics and engineers to build. In this chapter, the main concepts will briefly be described and a practical example given.</p><p>First, let's take a step back and see how NLP might benefit our bots. If we built a bot that retrieves the weather report, we could imagine the command to look something like this:</p><div><pre class="programlisting">
<strong>weather amsterdam tomorrow</strong>
</pre></div><p>This would return <a class="indexterm" id="id194"/>tomorrow's weather report for the city of Amsterdam. What if the bot could retrieve the weather report without requiring a command to be issued? For instance, if a Slack user were to send the message "Will it rain tomorrow?", then the bot would respond with tomorrow's weather report. This is NLP at work; it is the breakdown of natural language into instructions that can be interpreted by the program as a command.</p><p>To help us in our understanding of NLP, we will be using a helper library that abstracts the more complicated algorithms away. A good NLP framework is the Python language-based <strong>natural language </strong><a class="indexterm" id="id195"/>
<strong>toolkit</strong> (<strong>NLTK</strong>) available at <a class="ulink" href="http://www.nltk.org/">http://www.nltk.org/</a>.</p><p>Luckily for us, a project to port the major functions of NLTK to Node has been functioning for some time and has reached a high enough level of maturity for us to use it seamlessly with our existing <a class="indexterm" id="id196"/>JavaScript projects. Known as Natural (<a class="ulink" href="https://github.com/NaturalNode/natural">https://github.com/NaturalNode/natural</a>), this library will be our key point of entry to the world of NLP.</p><p>Let's start by introducing some of the more common NLP algorithms. Afterwards, we'll use our newfound knowledge by building a simple weather bot, as outlined earlier.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Fundamentals of NLP</h1></div></div></div><p>NLP, at its <a class="indexterm" id="id197"/>core, works by splitting a chunk of text (also referred to as a corpus) into individual segments or tokens and then analyzing them. These tokens might simply be individual words but might also be word contractions. Let's look at how a computer might interpret the phrase: <em>I have watered the plants</em>.</p><p>If we were to split this corpus into tokens, it would probably look something like this:</p><div><pre class="programlisting">['I', 'have', 'watered', 'the', 'plants']</pre></div><p>The word <code class="literal">the</code> in our corpus is unnecessary as it does not help to understand the phrase's intent— the same for the word <code class="literal">have</code>. We should therefore remove the surplus words:</p><div><pre class="programlisting">['I', 'watered', 'plants']</pre></div><p>Already, this is starting to look more usable. We have a personal pronoun in the form of an actor (<code class="literal">I</code>), an action or verb (<code class="literal">watered</code>), and a recipient or noun (<code class="literal">plants</code>). From this, we can deduce exactly which action is enacted to what and by whom. Furthermore, by conjugating the verb <code class="literal">watered</code>, we can establish that this action occurred in the past. Consider how the context and meaning of the phrase changes when we make minor changes: <em>We are watering the plant</em>.</p><p>By using the same <a class="indexterm" id="id198"/>process as previously, we get the following:</p><div><pre class="programlisting">['We', 'watering', 'plant']</pre></div><p>The meaning of the phrase has dramatically changed: there are multiple actors involved, the action is in the present and the recipient is singular. The challenge of NLP is the ability to analyze such nuances, arrive at a conclusion with a high enough confidence level, and then perform actions based on that conclusion.</p><p>A computer, much like a person, learns this nuance by practice and by picking up patterns. A common NLP term is to train your system to recognize context in a corpus. By providing a large amount of predefined phrases to our system, we can analyze said phrases and look for similar ones in other corpus'. We will talk more about how to use this training or classifying technique later.</p><p>Let's now look at how we can actually perform the actions explained in the beginning of this section, starting with the splitting of a corpus into a series of tokens, also known as <strong>tokenizing</strong>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Tokenizers</h1></div></div></div><p>Start by creating a new <a class="indexterm" id="id199"/>project with <code class="literal">npm init</code>. Name your bot "weatherbot" (or something similar), and install the Slack and Natural APIs with the following command:</p><div><pre class="programlisting">
<strong>npm install @slack/client natural –save</strong>
</pre></div><p>Copy our <code class="literal">Bot</code> class from the previous chapters and enter the following in <code class="literal">index.js</code>:</p><div><pre class="programlisting">'use strict';

// import the natural library
const natural = require('natural');

const Bot = require('./Bot');

// initalize the tokenizer
const tokenizer = new natural.WordTokenizer();

const bot = new Bot({
  token: process.env.SLACK_TOKEN,
  autoReconnect: true,
  autoMark: true
});

// respond to any message that comes through
bot.respondTo('', (message, channel, user) =&gt; {

  let tokenizedMessage = tokenizer.tokenize(message.text);

  bot.send(`Tokenized message: ${JSON.stringify(tokenizedMessage)}`, channel);
});</pre></div><p>Start up your Node <a class="indexterm" id="id200"/>process and type a test phrase into Slack:</p><div><img alt="Tokenizers" src="img/B05384_05_01.jpg"/><div><p>The returned tokenized message</p></div></div><p>Through the use of tokenization, the bot has split the given phrase into short fragments or <strong>tokens</strong>, ignoring punctuation and special characters. Note that we are using the native <code class="literal">JSON</code> object's <code class="literal">stringify</code> method to convert the JavaScript array into a string before sending it to the channel.</p><p>This particular tokenized algorithm will handle contractions (for example, <code class="literal">hasn't</code>) by removing the punctuation and splitting the word. Depending on our use case, we might want to use a different algorithm. Luckily, <code class="literal">natural</code> provides three different algorithms. Each algorithm returns <a class="indexterm" id="id201"/>slightly different results for a corpus. To learn more about these algorithms, visit the <code class="literal">natural</code> GitHub page: <a class="ulink" href="https://github.com/NaturalNode/natural#tokenizers">https://github.com/NaturalNode/natural#tokenizers</a>.</p><p>A majority of these algorithms use punctuation (spaces, apostrophes, and so on) to tokenize phrases, whereas the Treebank algorithm analyses contractions (for example, <code class="literal">wanna</code> and <code class="literal">gimme</code>) to split them into regular words (<code class="literal">want to</code> and <code class="literal">give me</code> in the case of <code class="literal">wanna</code> and <code class="literal">gimme</code>). Let's use Treebank for the next example, and replace the line where the tokenizer is initialized with the following:</p><div><pre class="programlisting">const tokenizer = new natural.TreebankWordTokenizer();</pre></div><p>Now, return to Slack and <a class="indexterm" id="id202"/>try another test message:</p><div><img alt="Tokenizers" src="img/B05384_05_02.jpg"/><div><p>The Treebank algorithm handles contractions differently</p></div></div><p>Notice two important things here: the <code class="literal">haven't</code> contraction was split into two parts, the root verb (<code class="literal">have</code>) and the contracted add-on (<code class="literal">not</code>). Furthermore, the word <code class="literal">cannot</code> was split into two separate words, making the command easier to deal with. This also makes certain slang words like <code class="literal">lemme</code> and <code class="literal">gotta</code> easier to process. By splitting the contracted word into two, we can more easily infer whether the phrase is positive or negative. <code class="literal">Can</code> by itself means positive; however, if it is followed by <code class="literal">not</code> it changes the context of the phrase to be negative.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Stemmers</h1></div></div></div><p>Sometimes, it is <a class="indexterm" id="id203"/>useful to find the root or <code class="literal">stem</code> of a word. In the English language, irregular verb conjugations are not uncommon. By deducing the root of a verb, we can dramatically decrease the amount of calculations needed to find the action of the phrase. Take the verb <code class="literal">searching</code> for example; for the purpose of bots, it would be much easier to process the verb in its root form <code class="literal">search</code>. Here, a stemmer can help us determine said root. Replace the contents of <code class="literal">index.js</code> with the following to demonstrate stemmers:</p><div><pre class="programlisting">'use strict';

// import the natural library
const natural = require('natural');

const Bot = require('./Bot');

// initialize the stemmer
const stemmer = natural.PorterStemmer;

// attach the stemmer to the prototype of String, enabling
// us to use it as a native String function
stemmer.attach();

const bot = new Bot({
  token: process.env.SLACK_TOKEN,
  autoReconnect: true,
  autoMark: true
});

// respond to any message that comes through
bot.respondTo('', (message, channel, user) =&gt; {
  let stemmedMessage = stemmer.stem(message.text);
  
  bot.send(`Stemmed message: ${JSON.stringify(stemmedMessage)}`, channel);
});</pre></div><p>Now, let's see <a class="indexterm" id="id204"/>what stemming a word returns:</p><div><img alt="Stemmers" src="img/B05384_05_03.jpg"/><div><p>The conjugated versions of a verb are often different from its root</p></div></div><p>As expected, <code class="literal">searching</code> is stemmed into <code class="literal">search</code> but (more interestingly) the token <code class="literal">shining</code> is stemmed into <code class="literal">shine</code>. This shows that the process of stemming is more than simply removing <code class="literal">-ing</code> from the tail end of a token. Now, we can analyze our tokenized and stemmed corpus and pick out certain verbs or actions. For instance, after stemming, the phrases <em>I went swimming</em> and <em>I swam</em>, both contain the verb <code class="literal">swim</code>, which means we only have to search for one term (<code class="literal">swim</code>) rather than two (<code class="literal">swimming</code> and <code class="literal">swam</code>).</p><p>Stemming also works for <a class="indexterm" id="id205"/>removing plurals from words. For instance, <code class="literal">searches</code> stems into <code class="literal">search</code> and <code class="literal">rains</code> into <code class="literal">rain</code>.</p><p>Let's combine the concepts of tokenizing and stemming into one program to see its effects. Once again, replace <code class="literal">index.js</code> with the following:</p><div><pre class="programlisting">'use strict';

// import the natural library
const natural = require('natural');

const Bot = require('./Bot');

// initialize the stemmer
const stemmer = natural.PorterStemmer;

<strong>// attach the stemmer to the prototype of String, enabling</strong>
<strong>// us to use it as a native String function</strong>
<strong>stemmer.attach();</strong>

const bot = new Bot({
  token: process.env.SLACK_TOKEN,
  autoReconnect: true,
  autoMark: true
});

// respond to any message that comes through
bot.respondTo('', (message, channel, user) =&gt; {
  let stemmedMessage = message.text.tokenizeAndStem();

  bot.send(`Tokenize and stemmed message: ${JSON.stringify(stemmedMessage)}`, channel);
});</pre></div><p>Note that we call <code class="literal">tokenizeAndStem</code> on <code class="literal">message.text</code>. This might seem odd, until you realize that we have attached the <code class="literal">tokenizeAndStem</code> method to the <code class="literal">String</code> object's prototype in earlier code, highlighted in the preceding code.</p><p>Switch over to the Slack client and you should see:</p><div><img alt="Stemmers" src="img/B05384_05_04.jpg"/><div><p>Tokenizing and stemming to produce useful results</p></div></div><p>The tokenizer and stemming combination has automatically left out very common words such as <code class="literal">it</code> and <code class="literal">in</code>, leaving <a class="indexterm" id="id206"/>us with a sentence distilled into the most important tokens of the original input.</p><p>Using just the tokenized and stemmed result, we can infer that the user wishes to know about the weather in Amsterdam. Furthermore, we can choose to exclude the word <code class="literal">is</code> from our results. This leaves us with <code class="literal">rain amsterdam</code>, which is enough information for us to make a weather API call.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>String distance</h1></div></div></div><p>A string distance measuring <a class="indexterm" id="id207"/>algorithm is a calculation of how similar two strings are to one another. The strings <code class="literal">smell</code> and <code class="literal">bell</code> can be defined as similar, as they share three characters. The strings <code class="literal">bell</code> and <code class="literal">fell</code> are even closer, as they share three characters and are only one character apart from one another. When calculating string distance, the string <code class="literal">fell</code> will receive a higher ranking than <code class="literal">smell</code> when the distance is measured between them and <code class="literal">bell</code>.</p><p>The NPM package <code class="literal">natural</code> provides three different algorithms for string distance calculation: Jaro-Winkler, the Dice coefficient, and the Levenshtein distance. Their main differences can be described as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Dice coefficient</strong>: This <a class="indexterm" id="id208"/>calculates the difference between strings and represents the difference as a value between zero and one. Zero being completely different and one meaning identical.</li><li class="listitem" style="list-style-type: disc"><strong>Jaro-Winkler</strong>: This is <a class="indexterm" id="id209"/>similar to the Dice Coefficient, but gives greater weighting to similarities at the beginning of the string.</li><li class="listitem" style="list-style-type: disc"><strong>Levenshtein distance</strong>: This calculates the amount of edits or steps required to transform one <a class="indexterm" id="id210"/>string into another. Zero steps means the strings are identical.</li></ul></div><p>Let's use the Levenshtein distance algorithm to demonstrate its use:</p><div><pre class="programlisting">let distance = natural.LevenshteinDistance('weather', 'heater');

console.log('Distance:', distance); // distance of 10

let distance2 = natural.LevenshteinDistance('weather', 'weather');

console.log('Distance2:', distance2); // distance of 0</pre></div><p>A popular use for string <a class="indexterm" id="id211"/>distances is to perform a fuzzy search, where the search returns values that are a low string distance from the requested query. String distance calculation can be particularly useful for bots when processing a command with a typo in it. For instance, if a user meant to request the weather report for Amsterdam by sending the command <code class="literal">weather amsterdam</code>, but instead typed <code class="literal">weater amsterdam</code>. By calculating the Levenshtein distance between the strings, we can make an educated guess as to the user's intent. Check out the following snippet:</p><div><pre class="programlisting">bot.respondTo('', (message, channel, user) =&gt; {
  // grab the command from the message's text
  let command = message.text.split(' ')[0];

  let distance = natural.LevenshteinDistance('weather', command);

  // our typo tolerance, a higher number means a larger 
  // string distance
  let tolerance = 2;

  // if the distance between the given command and 'weather' is
  // only 2 string distance, then that's considered close enough
  if (distance &lt;= tolerance) {
    bot.send(`Looks like you were trying to get the weather, ${user.name}!`, channel);
  }}, true);</pre></div><p>Here's the result in Slack:</p><div><img alt="String distance" src="img/B05384_05_05.jpg"/><div><p>Calculating string distance can make your bot a lot more user friendly</p></div></div><p>We set our tolerance to be quite low in this case, allowing for two mistakes or <code class="literal">steps</code> to indicate a hit. In production <a class="indexterm" id="id212"/>code, it would make sense to reduce the tolerance to only one step.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>Be careful when choosing which string similarity algorithm to use, as each might determine distance differently. For instance, when using the Jaro-Winkler and Dice Coefficient algorithms, a score of 1 indicates that the two strings are identical. With the Levenshtein difference, it is the opposite, where 0 means identical and the higher the number the larger the string distance.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Inflection</h1></div></div></div><p>An inflector can be used to <a class="indexterm" id="id213"/>convert a noun back and forth from its singular and plural forms. This is useful when generating natural language, as the plural versions of nouns might not be obvious:</p><div><pre class="programlisting">let inflector = new natural.NounInflector();

console.log(inflector.pluralize('virus'));
console.log(inflector.singularize('octopi'));</pre></div><p>The preceding code will output <code class="literal">viri</code> and <code class="literal">octopus</code>, respectively.</p><p>Inflectors may also be used to transform numbers into their ordinal forms; for example, 1 becomes 1st, 2 becomes 2nd, and so on:</p><div><pre class="programlisting">let inflector = natural.CountInflector;

console.log(inflector.nth(25));
console.log(inflector.nth(42));
console.log(inflector.nth(111)); </pre></div><p>This outputs <code class="literal">25th</code>, <code class="literal">42nd</code>, and <code class="literal">111th</code>, respectively.</p><p>Here's an example of the inflector used in a simple bot command:</p><div><pre class="programlisting">let inflector = natural.CountInflector;

bot.respondTo('what day is it', (message, channel) =&gt; {
  let date = new Date();

  // use the ECMAScript Internationalization API to convert 
  // month numbers into names
  let locale = 'en-us';
  let month = date.toLocaleString(locale, { month: 'long' });
  bot.send(`It is the ${inflector.nth(date.getDate())} of ${month}.`, channel);
}, true);</pre></div><p>Now when asked what day it is, our bot can respond a little more naturally:</p><div><img alt="Inflection" src="img/B05384_05_06.jpg"/><div><p>Inflection can make your bot more personable</p></div></div><p>This leads us to our <a class="indexterm" id="id214"/>next topic: how to display data in an easy-to-understand way.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Displaying data in a natural way</h1></div></div></div><p>Let's build our bot's weather <a class="indexterm" id="id215"/>functionality. To do this, we will be using a <a class="indexterm" id="id216"/>third-party API called <strong>Open Weather Map</strong>. The API is free to use for up to 60 calls per minute, with further pricing options available. To obtain the API key, you will need to sign up here: <a class="ulink" href="https://home.openweathermap.org/users/sign_up">https://home.openweathermap.org/users/sign_up</a>.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>Remember that you can pass variables such as API keys into Node from the command line. To run the weather bot, you could use the following command:</p><div><pre class="programlisting">
<strong>SLACK_TOKEN=[YOUR_SLACK_TOKEN] WEATHER_API_KEY=[YOUR_WEATHER_KEY] nodemon index.js</strong>
</pre></div></div></div><p>Once you signed up and obtained your API key, copy and paste the following code into <code class="literal">index.js</code>, replacing <code class="literal">process.env.WEATHER_API_KEY</code> with your newly acquired Open Weather Map key:</p><div><pre class="programlisting">'use strict';

// import the natural library
const natural = require('natural');

const request = require('superagent');

const Bot = require('./Bot');

const weatherURL = `http://api.openweathermap.org/data/2.5/weather?&amp;units=metric&amp;appid=${process.env.WEATHER_API_KEY}&amp;q=`;

// initialize the stemmer
const stemmer = natural.PorterStemmer;

// attach the stemmer to the prototype of String, enabling
// us to use it as a native String function
stemmer.attach();

const bot = new Bot({
  token: process.env.SLACK_TOKEN,
  autoReconnect: true,
  autoMark: true
});

bot.respondTo('weather', (message, channel, user) =&gt; {
  let args = getArgs(message.text);

  let city = args.join(' ');

  getWeather(city, (error, fullName, description, temperature) =&gt; {
    if (error) {
      bot.send(error.message, channel);
      return;
    }

    bot.send(`The weather for ${fullName} is ${description} with a temperature of ${Math.round(temperature)} celsius.`, channel);
  });
}, true);

function getWeather(location, callback) {
  // make an AJAX GET call to the Open Weather Map API
  request.get(weatherURL + location)
    .end((err, res) =&gt; {
      if (err) throw err;
      let data = JSON.parse(res.text);

      if (data.cod === '404') {     
        return callback(new Error('Sorry, I can\'t find that location!')); 
      }

      console.log(data);

      let weather = [];
      data.weather.forEach((feature) =&gt; {
        weather.push(feature.description);
      });

      let description = weather.join(' and ');

      callback(data.name, description, data.main.temp);
    });
}

// Take the message text and return the arguments
function getArgs(msg) {
  return msg.split(' ').slice(1);
}</pre></div><p>Using familiar code, our bot performs the following tasks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initializes the stemmer from the natural package and attaches it to the string prototype</li><li class="listitem" style="list-style-type: disc">Awaits the <code class="literal">weather</code> command and uses the <code class="literal">getWeather</code> function to retrieve the Open Weather Map weather data via an <strong>Asynchronous JavaScript and XML</strong> (<strong>AJAX</strong>) call</li><li class="listitem" style="list-style-type: disc">Sends a formatted weather message to the channel</li></ul></div><p>Here's the bot in action:</p><div><img alt="Displaying data in a natural way" src="img/B05384_05_07.jpg"/><div><p>A simple weatherbot</p></div></div><p>After receiving the command and the place name, the bot sends an AJAX request to Open Weather Map with the place name as the argument. In return, we get a JSON response that looks like this:</p><div><pre class="programlisting">{ 
  coord: { lon: 4.89, lat: 52.37 },
  weather:
   [ { id: 310,
       main: 'Drizzle',
       description: 'light intensity drizzle rain',
       icon: '09n' } ],
  base: 'cmc stations',
  main: { temp: 7, pressure: 1021, humidity: 93, temp_min: 7, temp_max: 7 },
  wind: { speed: 5.1, deg: 340 },
  clouds: { all: 75 },
  dt: 1458500100,
  sys:
   { type: 1,
     id: 5204,
     message: 0.0103,
     country: 'NL',
     sunrise: 1458452421,
     sunset: 1458496543 },
  id: 2759794,
  name: 'Amsterdam',
  cod: 200 
}</pre></div><p>Note how among the plethora of information we get back there is the full, capitalized name of the place and useful information such as minimum and maximum temperature. For our bot's initial purpose, we will use the temperature object (<code class="literal">main</code>), the <code class="literal">name</code> property, and the <code class="literal">description</code> inside the <code class="literal">weather</code> object.</p><p>Now that we have a simple bot which responds to the command <code class="literal">weather</code>, let's see if we can use NLP to get more specific answers.</p><p>Notice how the Open Weather Map AJAX call was abstracted out into the <code class="literal">getWeather</code> function. This means we can use the same function for both command calls and NLP calls.</p><p>Before we continue, we should discuss the right use case for NLP techniques.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>When to use NLP?</h1></div></div></div><p>It might be tempting to <a class="indexterm" id="id217"/>have weatherbot listen to and process all messages sent in the channel. This immediately poses some problems:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How do we know if the message sent is a query on the weather or is completely unrelated?</li><li class="listitem" style="list-style-type: disc">Which geographic location is the query about?</li><li class="listitem" style="list-style-type: disc">Is the message a question or a statement? For example, the difference between <em>Is it cold in Amsterdam</em> and <em>It is cold in Amsterdam</em>.</li></ul></div><p>Although an NLP-powered solution to the preceding questions could probably be found, we have to face facts: it's likely that our bot will get at least one of the above points wrong when listening to generic messages. This will lead the bot to either provide bad information or provide unwanted information, thus becoming annoying. If there's one thing we need to avoid at all costs, it's a bot that sends too many wrong messages too often.</p><p>Here's an example of a bot <a class="indexterm" id="id218"/>using NLP and completely missing the point of the message sent:</p><div><img alt="When to use NLP?" src="img/B05384_05_08.jpg"/><div><p>A clearly misunderstood message</p></div></div><p>If a bot were to often mistake your unrelated messages for actual commands, you can imagine users disabling your bot very quickly after enabling it.</p><p>The best possible solution would be to create a bot that has human-level natural language processing. If that sentence doesn't concern you, then consider that human-level natural language processing is considered an AI-complete problem. Essentially, it is equivalent to attempting to solve the problem of making computers as intelligent as humans.</p><p>Instead, we should focus on how to make our bot perform as best as possible with the resources at hand. We can start by introducing a new rule: use NLP as an enhancement for your bot, not as a main feature.</p><p>An example of this is to only use NLP techniques when the bot is directly addressed in a mention. A mention in a Slack channel is when a user sends a message directly to another user in a public channel. This is done by prefacing the user's name with the <code class="literal">@</code> symbol. Bots can also be mentioned, which means we should be able to process the weather command in two ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The user prefaces their request with the command <code class="literal">weather</code>: <code class="literal">weather is it raining in Amsterdam</code></li><li class="listitem" style="list-style-type: disc">The user uses a mention <code class="literal">@weatherbot is it raining in Amsterdam</code></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Mentions</h1></div></div></div><p>To implement the second <a class="indexterm" id="id219"/>point, we need to revisit our <code class="literal">Bot</code> class and add mention functionality. In the <code class="literal">Bot</code> class' constructor, replace the <code class="literal">RTM_CONNECTION_OPENED</code> event listener block with the following:</p><div><pre class="programlisting">this.slack.on(CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, () =&gt; {
  let user = this.slack.dataStore.getUserById(this.slack.activeUserId)
  let team = this.slack.dataStore.getTeamById(this.slack.activeTeamId);

  this.name = user.name;
<strong>  this.id = user.id;</strong>

  console.log(`Connected to ${team.name} as ${user.name}`);
});</pre></div><p>The only change here is the addition of the bot's <code class="literal">id</code> to the <code class="literal">this</code> object. This will help us later. Now, replace the <code class="literal">respondTo</code> function with this:</p><div><pre class="programlisting">respondTo(opts, callback, start) {
  if (!this.id) {
    // if this.id doesn't exist, wait for slack to connect
    // before continuing
    this.slack.on(CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, () =&gt; {
      createRegex(this.id, this.keywords);
    });  
  } else {
    createRegex(this.id, this.keywords);
  }
      
  function createRegex(id, keywords) {
    // if opts is an object, treat it as options
    // otherwise treat it as the keywords string
    if (opts === Object(opts)) {
      opts = {
        mention: opts.mention || false,
        keywords: opts.keywords || '',
        start: start || false
      };
    } else {
      opts = {
        mention: false,
        keywords: opts,
        start: start || false
      };
    }

    // mention takes priority over start variable
    if (opts.mention) {         
      // if 'mention' is truthy, make sure the bot only 
      // responds to mentions of the bot
      opts.keywords = `&lt;@${id}&gt;:* ${opts.keywords}`;
    } else {
      // If 'start' is truthy, prepend the '^' anchor to instruct
      // the expression to look for matches at the beginning of
      // the string
      opts.keywords = start ? '^' + opts.keywords : opts.keywords;
    }

    // Create a new regular expression, setting the case 
    // insensitive (i) flag
    // Note: avoid using the global (g) flag
    let regex = new RegExp(opts.keywords, 'i');
    
    // Set the regular expression to be the key, with the callback 
    // function as the value
    keywords.set(regex, callback);
  }
}</pre></div><p>We've improved the <code class="literal">respondTo</code> function by first checking whether <code class="literal">this.id</code> exists. If not, it means that we've <a class="indexterm" id="id220"/>not yet successfully connected to Slack. Therefore, we wait till Slack has connected (remember how we set <code class="literal">this.id</code> in the constructor after connecting) and then proceed. This is the second time we listen for the <code class="literal">RTM_CONNECTION_OPENED</code> event. Luckily, the first time it happens in the <code class="literal">Bot</code> class' constructor, which means this listener will always trigger second as it was added later. This ensures that <code class="literal">this.id</code> is defined once the event triggers.</p><p>The function now takes either a string (the keywords we're looking for) or an object as its first parameter. In the case of an object, we check to see whether the mention property is truthy; if so, we create a regular expression that purposefully looks for the mention syntax. When a message is received, a mention takes the following structure:</p><p>
<code class="literal">&lt;@[USER_ID]&gt;: [REST OF MESSAGE]</code>
</p><p>Switch back to <code class="literal">index.js</code> and let's try out our new code by replacing the previous <code class="literal">respondTo</code> block of <code class="literal">weather</code>:</p><div><pre class="programlisting">bot.respondTo({ mention: true }, (message, channel, user) =&gt; {
  let args = getArgs(message.text);

  let city = args.join(' ');

  getWeather(city, (error, fullName, description, temperature) =&gt; {
    if (error) {
      bot.send(error.message, channel);
      return;
    }

    bot.send(`The weather for ${fullName} is ${description} with a temperature of ${Math.round(temperature)} celsius.`, channel);
  });
});</pre></div><p>Now when we mention our bot and pass a city name, we get the following result:</p><div><img alt="Mentions" src="img/B05384_05_09.jpg"/><div><p>Mentions can be used to identify specific behavior</p></div></div><div><div><h3 class="title"><a id="note29"/>Note</h3><p>Mentions are a great way to ensure that the message sent is meant to be a command for your bot. When implementing a natural language solution, it is highly recommended you use mentions.</p></div></div><p>Now with mentions in place, let's <a class="indexterm" id="id221"/>look at how we're going to answer weather-related questions in an NLP way. We briefly talked about classification and the training of NLP systems earlier. Let's revisit that topic and see how we can use it for our weather bot.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Classifiers</h1></div></div></div><p>Classification is the <a class="indexterm" id="id222"/>process of training your bot to recognize a phrase or pattern of words and to associate them with an identifier. To do this, we use a classification system built into <code class="literal">natural</code>. Let's start with a small example:</p><div><pre class="programlisting">const classifier = new natural.BayesClassifier();

classifier.addDocument('is it hot', ['temperature', 'question','hot']);
classifier.addDocument('is it cold', ['temperature', 'question' 'cold']);
classifier.addDocument('will it rain today', ['conditions', 'question', 'rain']);
classifier.addDocument('is it drizzling', ['conditions', 'question', 'rain']);

classifier.train();


console.log(classifier.classify('will it drizzle today'));
console.log(classifier.classify('will it be cold out'));</pre></div><p>The first log prints:</p><div><pre class="programlisting">conditions,question,rain</pre></div><p>The second log prints:</p><div><pre class="programlisting">temperature,question,cold</pre></div><p>The classifier stems the string <a class="indexterm" id="id223"/>to be classified first, and then calculates which of the trained phrases it is the most similar to by assigning a weighting to each possibility.</p><p>You can view the weightings by using the following code:</p><div><pre class="programlisting">console.log(classifier.getClassifications('will it drizzle today'));</pre></div><p>The output is as follows:</p><div><pre class="programlisting">[ { label: 'conditions,question,rain',
    value: 0.17777777777777773 },
  { label: 'temperature,question,hot', value: 0.05 },
  { label: 'temperature,question,cold', value: 0.05 } ]</pre></div><p>To get accurate and reliable results, you must train your bot with potentially hundreds of phrases. Luckily, you can also import training data JSON files into the classifier.</p><p>Save your classifier training data by creating a <code class="literal">classifier.json</code> file in your directory:</p><div><pre class="programlisting">classifier.save('classifier.json', (err, classifier) =&gt; {
  // the classifier is saved to the classifier.json file!
});</pre></div><p>Retrieve the same file with the following code:</p><div><pre class="programlisting">natural.BayesClassifier.load('classifier.json', null, (err, classifier) =&gt; {
  if (err) {
    throw err;
  }

  console.log(classifier.classify('will it drizzle today'));
});</pre></div><p>Now let's try and use <a class="indexterm" id="id224"/>classifiers to power our weatherbot.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Using trained classifiers</h1></div></div></div><p>An example <a class="indexterm" id="id225"/>
<code class="literal">classifier.json </code>file that contains training data for weather is included with this book. For the rest of this chapter, we will assume that the file is present and that we are loading it in via the preceding method.</p><p>Replace your <code class="literal">respondTo</code> <a class="indexterm" id="id226"/>method call with the following snippet:</p><div><pre class="programlisting">let settings = {};

bot.respondTo({ mention: true }, (message, channel, user) =&gt; {
  let args = getArgs(message.text);

  if (args[0] === 'set') {
    let place = args.slice(1).join(' ');
    settings[user.name] = place
    
    bot.send(`Okay ${user.name}, I've set ${place} as your default location`, channel);
    return;
  }

  if (args.indexOf('in') &lt; 0 &amp;&amp; !settings[user.name]) {
    bot.send(`Looks like you didn\'t specify a place name, you can set a city by sending \`@weatherbot set [city name]\` or by sending \`@weatherbot ${args.join(' ')} in [city name]\``, channel);
    return;
  }

  // The city is usually preceded by the word 'in'  
  let city = args.indexOf('in') &gt; 0 ? args.slice(args.indexOf('in') + 1) : settings[user.name];

  let option = classifier.classify(message.text).split(',');

  console.log(option);

  // Set the typing indicator as we're doing an asynchronous request
  bot.setTypingIndicator(channel);

  getWeather(city, (error, fullName, description, temperature) =&gt; {
    if (error) {
      bot.send(`Oops, an error occurred, please try again later!`, channel);
      return;
    }

    let response = '';

    switch(option[0]) {
      case 'weather':
        response = `It is currently ${description} with a temperature of ${Math.round(temperature)} celsius in ${fullName}.`;
        break;

      case 'conditions':
        response = `${fullName} is experiencing ${description} right now.`;
        break;

      case 'temperature':
        let temp = Math.round(temperature);
        let flavorText = temp &gt; 25 ? 'hot!' : (temp &lt; 10 ? 'cold!' : 'nice!');  

        response = `It's currently ${temp} degrees celsius in ${fullName}, that's ${flavorText}`;
    } 

    bot.send(response, channel);
  });
});</pre></div><p>Run the Node <a class="indexterm" id="id227"/>process and ask weatherbot a series of natural <a class="indexterm" id="id228"/>language questions:</p><div><img alt="Using trained classifiers" src="img/B05384_05_10.jpg"/><div><p>Weatherbot can now understand conversational language</p></div></div><p>Let's look at the <a class="indexterm" id="id229"/>code and see what's going on:</p><div><pre class="programlisting">let settings = {};

bot.respondTo({ mention: true }, (message, channel, user) =&gt; {
  let args = getArgs(message.text);

  if (args[0] === 'set') {
    let place = args.slice(1).join(' ');
    settings[user.name] = place
    
    bot.send(`Okay ${user.name}, I've set ${place} as your default location`, channel);
    return;
  }</pre></div><p>First, we check to see whether the keyword <code class="literal">set</code> is used immediately after the <code class="literal">@weatherbot</code> mention. If yes, this <a class="indexterm" id="id230"/>sets the following arguments to be the default city of the user. We use a simple settings object here, but this could be improved by using a data store such as Redis, explained in <a class="link" href="ch04.html" title="Chapter 4. Using Data">Chapter 4</a>, <em>Using Data</em>.</p><p>You can see an example <a class="indexterm" id="id231"/>of the <code class="literal">set</code> behavior in the following screenshot:</p><div><img alt="Using trained classifiers" src="img/B05384_05_11.jpg"/><div><p>Setting a city saves users from having to type in their place name for each query</p></div></div><p>Next, we attempt to find the place we want to get weather information for:</p><div><pre class="programlisting">if (args.indexOf('in') &lt; 0 &amp;&amp; !settings[user.name]) {
    bot.send(`Looks like you didn\'t specify a place name, you can set a city by sending \`@weatherbot set [city name]\` or by sending \`@weatherbot ${args.join(' ')} in [city name]\``, channel);
    return;
  }

  // The city is usually preceded by the word 'in'  
  let city = args.indexOf('in') &gt; 0 ? args.slice(args.indexOf('in') + 1) : settings[user.name];</pre></div><p>We expect all weather <a class="indexterm" id="id232"/>queries with a place name to follow the pattern <code class="literal">[condition] in [place name]</code>. This means we can make a reasonable assumption that all tokens after the word <code class="literal">in</code> are the place name to use in our AJAX call.</p><p>If the word <code class="literal">in</code> does not appear and there is no set place name, then we send back an error message with a best guess example of how to use weatherbot.</p><p>This is, of course, not <a class="indexterm" id="id233"/>the most ideal way to detect a place name—determining which part of the phrase is a place name is notoriously difficult, especially when the name in question comprises multiple words like <code class="literal">New York</code> or <code class="literal">Dar es Salaam</code>. One possible solution would be to train our bot with a series of city name classifiers (essentially one training phrase per city). Other solutions include the Query <a class="indexterm" id="id234"/>GeoParser <a class="ulink" href="http://www2009.eprints.org/239/">http://www2009.eprints.org/239/</a> and the Stanford Named Entity Recognizer <a class="ulink" href="http://nlp.stanford.edu/software/CRF-NER.shtml">http://nlp.stanford.edu/software/CRF-NER.shtml</a>.</p><p>Next we use the classifier to <a class="indexterm" id="id235"/>identify which key words the message should be associated with:</p><div><pre class="programlisting">let option = classifier.classify(message.text).split(',');

  console.log(option);

  // Set the typing indicator as we're doing an 
  // asynchronous request
  bot.setTypingIndicator(channel);</pre></div><p>Some of the classifier's phrases are added with an array as the second argument, for example:</p><div><pre class="programlisting">classifier.addDocument('is it hot outside', ['temperature', 'question', 'hot']);</pre></div><p>This means that the returned value from the <code class="literal">classifier.classify</code> method is a comma-separated string value. We transform it into a JavaScript array by using the <code class="literal">Array.split</code> method.</p><p>Finally, we set the typing indicator, which is good practice when making an asynchronous call:</p><div><pre class="programlisting">getWeather(city, (error, fullName, description, temperature) =&gt; {
    if (error) {
      bot.send(`Oops, an error occurred, please try again later!`, channel);
      return;
    }

    let response = '';

    switch(option[0]) {
      case 'weather':
        response = `It is currently ${description} with a temperature of ${Math.round(temperature)} celsius in ${fullName}.`;
        break;

      case 'conditions':
        response = `${fullName} is experiencing ${description} right now.`;
        break;

      case 'temperature':
        let temp = Math.round(temperature);
        let flavorText = temp &gt; 25 ? 'hot!' : (temp &lt; 10 ? 'cold!' : 'nice!');  

        response = `It's currently ${temp} degrees celsius in ${fullName}, that's ${flavorText}`;
    } 

    bot.send(response, channel);
  });
});</pre></div><p>The value at index 0 of <a class="indexterm" id="id236"/>the option object is the state of the question, in <a class="indexterm" id="id237"/>this case whether the message is related to the temperature, condition, or generic weather.</p><p>Our options are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Temperature</strong>: Send the temperature (in Celsius) to the channel</li><li class="listitem" style="list-style-type: disc"><strong>Conditions</strong>: Send the weather conditions (for example, raining and windy) to the channel</li><li class="listitem" style="list-style-type: disc"><strong>Weather</strong>: Send both the conditions and temperature to the channel</li></ul></div><p>It is important to understand the underlying concepts of classification and training to build a smarter bot. It is, however, possible to abstract the problem of obtaining training data by using the third-party service wit.ai (<a class="ulink" href="https://wit.ai/">https://wit.ai/</a>). wit.ai is a free service, created by Facebook, which <a class="indexterm" id="id238"/>allows you to train phrases (referred to as <strong>entities</strong> by wit.ai) and to retrieve analysis on a given phrase easily and quickly via an AJAX request.</p><p>Alternatively, you could use services such as api.ai (<a class="ulink" href="https://api.ai/">https://api.ai/</a>) or Microsoft's LUIS (<a class="ulink" href="https://www.luis.ai/">https://www.luis.ai/</a>). Bear in mind, however, that although these services are free and easy to use, it is not guaranteed that they will be free or even around in the future. Unless you are attempting to build something that requires extremely accurate NLP services, it is almost always better to create your own implementation with open source NLP libraries. This has the added benefit of controlling and owning your own data, something which is not guaranteed when using a third-party service.</p><p>Now that we know how to process language, we should take a look at how to transform our data into human <a class="indexterm" id="id239"/>understandable natural language.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Natural language generation</h1></div></div></div><p>Natural language can be <a class="indexterm" id="id240"/>defined as a conversational tone in a bot's response. The purpose here is not to hide the fact that the bot is not human, but to make the information easier to digest.</p><p>The <code class="literal">flavorText</code> variable from the previous snippet is an attempt to make the bot's responses sound more natural; in addition, it is a useful technique to cheat our way out of performing more complex processing to reach a conversational tone in our response.</p><p>Take the following example:</p><div><img alt="Natural language generation" src="img/B05384_05_14.jpg"/><div><p>Weatherbot's politician-like response</p></div></div><p>Notice how the first weather query is asking whether it's cold or not. Weatherbot gets around giving a yes or no answer by making a generic statement on the temperature to every question.</p><p>This might seem like a <a class="indexterm" id="id241"/>cheat, but it is important to remember a very important aspect of NLP. <em>The more complex the generated language, the more likely it is to go wrong.</em> Generic answers are better than outright wrong answers.</p><p>This particular problem could be solved by adding more keywords to our classifiers and adding more phrases. Currently, our <code class="literal">classifier.json</code> file contains 50 phrases related to the weather; adding more phrases could get us a clearer idea of what is being asked of weatherbot.</p><p>This leads us to a very important point in the pursuit of natural language generation.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>When should we use natural language generation?</h1></div></div></div><p>Sparingly, is the <a class="indexterm" id="id242"/>answer. Consider Slackbot, Slack's own in-house bot used for setting up new users, amongst other things. Here's the first thing Slackbot says to a new user:</p><div><img alt="When should we use natural language generation?" src="img/B05384_05_15.jpg"/><div><p>The humble bot</p></div></div><p>Immediately, the bot's restrictions are outlined and no attempts to hide the fact that it is not human are made. Natural language generation is at its best when used to transform data-intensive constructs such as JSON objects into easy to comprehend phrases.</p><p>The Turing Test is a famous test developed in 1950 by Alan Turing to assess a machine's ability to make itself indistinguishable from a human in a text-only sense. Like Slackbot, you should not strive to make your bot Turing Test complete. Instead, focus on how your bot can be the most useful and use natural language generation to make your bot as easy to use as possible.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>The uncanny valley</h1></div></div></div><p>The uncanny valley is a term used to <a class="indexterm" id="id243"/>describe systems that act and sound like humans, but are somehow slightly off. This slight discrepancy actually leads to the bot feeling a lot more unnatural, and this is the exact opposite of what we are trying to accomplish with natural language generation. Instead, we should avoid trying to make the bot perfect in its natural language responses; the chances of finding ourselves in the uncanny valley get higher the more human-like we try to make a bot sound.</p><p>Instead, we should focus on making our bots useful and easy to use, over making its responses natural. A good principle to follow is to build your bot to <em>be as smart as a puppy</em>, a concept <a class="indexterm" id="id244"/>championed by Matt Jones (<a class="ulink" href="http://berglondon.com/blog/2010/09/04/b-a-s-a-a-p/">http://berglondon.com/blog/2010/09/04/b-a-s-a-a-p/</a>):</p><div><blockquote class="blockquote"><p><em>"Making smart things that don't try to be too smart and fail, and indeed, by design, make endearing failures in their attempts to learn and improve. Like puppies."</em></p></blockquote></div><p>Let's expand our weatherbot to make the generated response sound a little more natural (but not too natural).</p><p>First, edit the <code class="literal">getWeather</code> <a class="indexterm" id="id245"/>function to include <code class="literal">data</code> as a final argument in its callback call:</p><div><pre class="programlisting">callback(null, data.name, condition, data.main.temp, data);</pre></div><p>Then add the <code class="literal">data</code> variable to the callback we assign in the mention <code class="literal">respondsTo</code>:</p><div><pre class="programlisting">getWeather(city, (error, fullName, description, temperature, data) =&gt; {</pre></div><p>In the <code class="literal">switch</code> statement within the <code class="literal">getWeather</code> call, replace the <code class="literal">weather</code> case with this:</p><div><pre class="programlisting">case 'weather':
        // rain is an optional variable
        let rain = data.rain ? `Rainfall in the last 3 hours has been ${data.rain['3h']} mm.` : ''

        let expression = data.clouds.all &gt; 80 ? 'overcast' : (data.clouds.all &lt; 25 ? 'almost completely clear' : 'patchy');
        // in case of 0 cloud cover
        expression = data.clouds.all === 0 ? 'clear skies' : expression;

        let clouds = `It's ${expression} with a cloud cover of ${data.clouds.all}%.`;

        response = `It is currently ${description} with a temperature of ${Math.round(temperature)} celsius in ${fullName}. The predicted high for today is ${Math.round(data.main.temp_max)} with a low of ${Math.round(data.main.temp_min)} celsius and ${data.main.humidity}% humidity. ${clouds} ${rain}`;
        break;</pre></div><p>Asking for the weather in a city will now instruct our bot to send this:</p><div><img alt="The uncanny valley" src="img/B05384_05_16.jpg"/><div><p>Weatherbot can now be a bit more specific with its reporting</p></div></div><p>Here, we've simply taken the JSON returned from the AJAX call and formatted the data into something a bit more legible by humans. Rainfall is included, but only if there actually was any in the last 3 hours (if not, the <code class="literal">rain</code> property is omitted from the returned data). Cloud cover is represented by a percentage, which is perfect for us as we can assign predetermined statements (<code class="literal">patchy</code>, <code class="literal">almost completely clear</code> and <code class="literal">clear skies</code>) depending on that percentage.</p><p>When generating natural language, think of how your data can be presented. Percentages are an excellent way of assigning a verbal value. For example, anything between 80 and 100 percent can use adverbs like <code class="literal">extremely</code> or <code class="literal">very</code>, whereas we can use <code class="literal">barely</code> and <code class="literal">very little</code> for 0 to 20 percent.</p><p>For some data sets, a paragraph <a class="indexterm" id="id246"/>might be easier to digest rather than a list or pure data.</p><p>The result is a bot that, in a conversational tone, can give a weatherman-like weather report on the area in question.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Summary</h1></div></div></div><p>In this chapter, we discussed what NLP is and how it can be leveraged to make a bot seem far more complex than it really is. By using these techniques, natural language can be read, processed, and responded to in equally natural tones. We also covered the limitations of NLP and understood how to differentiate between good and bad uses of NLP.</p><p>In the next chapter, we will explore the creation of web-based bots, which can interact with Slack using webhooks and slash commands.</p></div></body></html>