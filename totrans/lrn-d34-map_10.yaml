- en: Adding Interactivity to Your Canvas Map
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的Canvas地图添加交互性
- en: 'In the preceding chapter, you saw one of the shining qualities of Canvas in
    action – animating thousands of points on the screen in a smooth animation. In
    this chapter, you will deal with one Canvas caveat: interaction. While interaction
    with HTML or SVG elements is straightforward, it requires a little more thought
    and some tricks to achieve with Canvas. In this chapter, you will follow along
    these thoughts and learn the tricks needed to do the following things:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您看到了Canvas的一个闪亮特性——在屏幕上以平滑动画的方式动画化成千上万的点。在本章中，您将处理Canvas的一个注意事项：交互。虽然与HTML或SVG元素的交互是直接的，但使用Canvas进行交互需要更多的思考和一些技巧。在本章中，您将跟随这些思路，学习完成以下任务所需的技巧：
- en: Making a globe move, and adding zoom and rotation interaction to it
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使地球移动，并为其添加缩放和旋转交互
- en: Learning how to interact with Canvas elements through **picking**
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何通过**拾取**与Canvas元素交互
- en: Retrieving data from a Canvas element to display it in a tooltip
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Canvas元素中检索数据以在工具提示中显示
- en: After this chapter, you will have covered all important facets of Canvas, drawing,
    animating, and, finally, interacting with Canvas.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，您将涵盖Canvas、绘图、动画以及最终与Canvas交互的所有重要方面。
- en: Why Canvas interaction is different
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么Canvas交互是不同的
- en: In the preceding chapter, you achieved a smooth animation of thousands of points
    by doing away with the DOM. The DOM is a representation of each element in browser
    memory. Bypassing it, you were dealing with much less overhead during animation.
    However, the DOM can be very useful for other goals in web development. High up
    on that list – especially for data visualization – is the **interaction** with
    elements on screen.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您通过移除DOM实现了成千上万点的平滑动画。DOM是浏览器内存中每个元素的表示。绕过它，您在动画过程中处理的开销要小得多。然而，DOM在Web开发的其他目标中非常有用。在列表中高居榜首——特别是对于数据可视化——是屏幕上元素的**交互**。
- en: You can just add an `onmousemove` or `onclick` listener to an element. You can’t
    do that to elements on a Canvas. They are a pixel manifestation of past code,
    not represented as a model within the browser.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为元素添加一个`onmousemove`或`onclick`监听器。您不能对Canvas上的元素这样做。它们是过去代码的像素表现，在浏览器中不表示为模型。
- en: 'However, don’t despair, there are indirect yet simple techniques to interact
    with your Canvas. We’ll be looking at the most important techniques in this chapter,
    building an interactive globe:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要绝望，有一些间接但简单的技术可以与您的Canvas交互。我们将在本章中查看最重要的技术，构建一个交互式地球：
- en: '![](img/56ecc99f-4a88-4175-9571-e33a954922e0.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56ecc99f-4a88-4175-9571-e33a954922e0.png)'
- en: A map of the world’s forest cover by country
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 按国家划分的世界森林覆盖率地图
- en: Leaving flying planes behind, you will build a globe showing each country's
    forest cover percentage. The greener a country is (you guessed it), the higher
    the forest cover. As you can see in the preceding figure, you will have a tooltip
    showing country-specific information when hovering over each country. Users will
    further be able to rotate the globe and zoom into specific areas at their leisure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃飞行飞机，您将构建一个显示每个国家森林覆盖率百分比的地球。一个国家越绿（您猜对了），森林覆盖率就越高。正如您在前面的图中可以看到，当您悬停在每个国家上时，您将有一个显示特定国家信息的工具提示。用户还可以随意旋转地球并放大到特定区域。
- en: You can view the final app at [https://larsvers.github.io/learning-d3-mapping-10-4](https://larsvers.github.io/learning-d3-mapping-10-4)
    and a c[ode example at](https://larsvers.github.io/learning-d3-mapping-10-4) [10_04.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://larsvers.github.io/learning-d3-mapping-10-4](https://larsvers.github.io/learning-d3-mapping-10-4)查看最终的应用程序，以及一个[代码示例](https://larsvers.github.io/learning-d3-mapping-10-4)在[10_04.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html)。
- en: At the conclusion of each step, you will find two links in an info box close
    to the relevant image. The first link brings you to a working implementation of
    this step that you can view in the browser. The second *code example* link brings
    you to the full code. If you're reading the print version, you can find all code
    examples at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)
    in their relevant chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤结束时，您将在靠近相关图像的信息框中找到两个链接。第一个链接将带您到一个可以浏览器的实际实现步骤。第二个*代码示例*链接将带您到完整的代码。如果您正在阅读印刷版，您可以在[https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)的相关章节中找到所有代码示例。
- en: Drawing the world on a Canvas
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Canvas上绘制世界
- en: Let’s start drawing a globe. This is straightforward, very much building on
    the preceding chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从绘制地球仪开始。这很简单，很大程度上是基于前面的章节。
- en: Setting up
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'First, you will create a few variables required for initialization. We’ll come
    back to this list as the application grows, but, for now, it’s lean:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将创建一些初始化所需的变量。随着应用程序的增长，我们将回到这个列表，但到目前为止，它很简单：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You are setting the `width` and `height` of the Canvas as well as the scale
    and the translation of the globe. Each projection has their own ideal starting
    scale. You can play with this number to find the right scale. You will use the
    `width` and `height` straight away, setting up the Canvas and its context:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在设置Canvas的`width`和`height`以及地球仪的缩放和转换。每个投影都有自己的理想起始缩放。您可以调整这个数字以找到合适的缩放。您将直接使用`width`和`height`来设置Canvas及其上下文：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: No magic here. Note that we have a `div` with the `#canvas-container` ID in
    our HTML, in which you add the main Canvas.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有魔法。请注意，在我们的HTML中有一个带有`#canvas-container` ID的`div`，在其中添加主Canvas。
- en: 'Let’s also produce a `bufferCanvas`. You learned about the benefits of buffer
    Canvases in the preceding chapter. In short, rendering an image in memory and
    copying it onto your main Canvas is more performant than rendering an image directly
    onto the main Canvas:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再生成一个`bufferCanvas`。您在前面的章节中学习了buffer Canvas的好处。简而言之，在内存中渲染图像并将其复制到主Canvas上比直接在主Canvas上渲染图像更高效：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A rather central part of building a globe is the right projection. Building
    a globe reduces our options dramatically to the `d3.geoOrthographic()` projection,
    a 2D globe projection which is part of the standard d3-geo module. You already
    used it in [chapter 5](d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml), *Click-Click
    Boom! Applying Interactivity to Your Map*. Let''s set it up first:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 构建地球仪的一个相当核心的部分是正确的投影。构建地球仪将我们的选择大大减少到`d3.geoOrthographic()`投影，这是一个2D地球投影，它是标准d3-geo模块的一部分。您已经在[第5章](d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml)，“点击-点击-爆炸！将交互性应用于您的地图”中使用过它。让我们首先设置它：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We applied the scale and translation array we specified above, as well as the
    `.clipAngle()` to 90 degrees to always clip the backside of the projection, our
    globe.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用了上面指定的缩放和转换数组，以及将`.clipAngle()`设置为90度，以便始终裁剪投影的背面，即我们的地球仪。
- en: 'As we use the `bufferCanvas` for all our drawings, we will tie our projection
    to a path generator that will exclusively draw to the buffer Canvas , as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`bufferCanvas`进行所有绘图，因此我们将投影绑定到一个仅绘制到buffer Canvas的路径生成器，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are two more geo helpers you will create: a base **sphere** and a **graticule**:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建两个更多的地理辅助工具：一个基本的**球体**和一个**经纬网**：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both are geo-visualization primitives. The **sphere** is, well, a sphere you
    use to underlay your globe with. You can then fill it or give it an outline to
    give your globe a round shape beyond the countries. A **graticule** is a grid
    of the main meridians (longitude lines) and parallels (latitude lines) 10 degrees
    apart from each other (and, yes, you need four parentheses to produce the actual
    graticule object). We shall see them in action very soon.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是地理可视化原语。**球体**是一个您用来在地表下构建地球的球体。然后您可以填充它或给它一个轮廓，以使地球在各国之外呈现圆形。**经纬网**是主要子午线（经度线）和纬度线（纬度线）的网格，彼此之间相隔10度（是的，您需要四个括号来生成实际的经纬网对象）。我们很快就会看到它们的作用。
- en: Drawing the world
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制世界
- en: 'The scene is set. In this section, you will load some country shape data to
    draw the world. You will set up four small functions to achieve the draw:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 场景已经设定。在本节中，您将加载一些国家形状数据来绘制世界。您将设置四个小函数来实现绘制：
- en: A `data load` function
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`数据加载`函数
- en: A `ready()` function that prepares the data and passes it on to the render function
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ready()`函数，它准备数据并将其传递给渲染函数
- en: A `renderScene()` function that kicks off the world draw and copies the final
    image from the buffer onto the main Canvas
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个启动世界绘制并将最终图像从缓冲区复制到主Canvas上的`renderScene()`函数
- en: A `drawScene()` function that renders the world onto the `bufferCanvas`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将世界渲染到`bufferCanvas`上的`drawScene()`函数。
- en: This might sound overkill for just drawing a static globe, and let me assure
    you it is. However, we are aiming for higher goals, which will be greatly helped
    by having this structure set up already.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来只是为了绘制一个静态地球而有些过度，但请让我向你保证，它确实是。然而，我们正在追求更高的目标，这将大大有助于我们已经建立的结构。
- en: 'The data load function just requests the data and passes it on to the `ready()`
    function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加载函数只是请求数据并将其传递给`ready()`函数：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `ready()` function doesn’t really add much more complexity so far:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`ready()`函数并没有增加多少复杂性：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It turns the TopoJSON to an array of GeoJSON `countries` and calls `renderScene()`.
    `renderScene()` does what we’ve already described in the preceding code. It draws
    the globe on the `bufferContext` in thin air, and as soon as it’s done, copies
    it over to the freshly cleared main Canvas:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它将TopoJSON转换为GeoJSON `countries`数组，并调用`renderScene()`。`renderScene()`做的是我们在前面的代码中已经描述过的。它在`bufferContext`上绘制地球，完成后立即将其复制到刚刚清除的主Canvas上：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Although `drawScene()` is our longest function, it’s not very complex:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`drawScene()`是我们最长的函数，但它并不复杂：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It clears the `buffer` context, then draws a base sphere in a light blue and
    a graticule grid in a slightly more saturated blue. It then fills the countries
    in a light gray color and strokes each country in a darker gray. That’s it. Here’s
    your very own Canvas globe:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它清除`buffer`上下文，然后以浅蓝色绘制一个基础球体，以略带饱和度的蓝色绘制经纬网格。然后以浅灰色填充国家，并以较深的灰色勾勒每个国家。就是这样。这就是你自己的Canvas地球：
- en: '![](img/6915f37c-f7cf-4031-9c94-d8b518d15d60.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6915f37c-f7cf-4031-9c94-d8b518d15d60.png)'
- en: A static Canvas globe
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态的Canvas地球
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-10-1](https://larsvers.github.io/learning-d3-mapping-10-1)
    and a code example at [10_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_01.html).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤的[https://larsvers.github.io/learning-d3-mapping-10-1](https://larsvers.github.io/learning-d3-mapping-10-1)和代码示例[10_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_01.html)。
- en: Great! You learned to draw a Canvas globe, which is nice, even if a little mono-dimensional.
    So, let’s add our first bit of interaction with it and let the users (and ourselves)
    zoom and rotate the globe.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你学会了绘制Canvas地球，这很好，即使有点单维。那么，让我们添加与它的第一次交互，并让用户（以及我们自己）放大和旋转地球。
- en: Making the world move
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让世界移动
- en: Zooming into and rotating a globe projection is a truly joyous pastime, I find.
    Apart from being such fun, it’s also extremely useful when dealing with globe
    projections, as the user needs to be able to view the world from different angles.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现放大和旋转地球投影是一项真正愉快的消遣活动。除了很有趣之外，当处理地球投影时，它也非常有用，因为用户需要能够从不同的角度查看世界。
- en: 'In this section, we will add our first bit of Canvas interactivity to the globe.
    We will equip the users with the ability to zoom into and rotate the globe. Apart
    from setting up two additional global variables, we will exclusively do work in
    the `ready()` function–our central function tasked to prepare the data. From now
    onward, it will also deal with interactivity, right here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向地球添加第一点Canvas交互功能。我们将使用户能够放大和旋转地球。除了设置两个额外的全局变量外，我们将在`ready()`函数中独家进行工作——我们的中心函数，负责准备数据。从现在开始，它还将处理交互性，就在这里：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Also, note that we wrapped our `renderScene()` function into a `requestAnimationFrame()`
    function to always let the browser decide the best time point for a new render.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们将`renderScene()`函数包装在`requestAnimationFrame()`函数中，以便浏览器始终决定最佳时间点进行新的渲染。
- en: Note, that here is a prominent and often preferred way to deal with zooming
    and panning (not so much rotating) in D3 using `context.scale()` and `context.translate()`.
    However, to implement both zooming and rotating, we won’t use these in-built methods,
    but will change the projection instead. We’ll get back to the why a little later
    as it becomes clear on the way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里是一个处理D3中缩放和平移（不是旋转）的突出和常用方法，使用`context.scale()`和`context.translate()`。然而，为了实现缩放和旋转，我们不会使用这些内置方法，而是会改变投影。我们稍后会回到为什么这样做的原因，因为随着过程的进行，它将变得清晰。
- en: Setting up the behavior
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置行为
- en: 'Zooming is no more than changing the scale for our projection. Rotating is
    no more than changing the rotation values of our projection. When you want the
    user to mandate zoom and rotation, you will need to listen to their mouse movement.
    As such, you will need to set up a zoom listener to track the user''s mouse wheel
    and drag moves, and attach it to the Canvas. We implemented zoom and rotation
    already in [chapter 5](d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml), *Click-Click
    Boom! Applying Interactivity to Your Map*. In our `ready()` function, as specified
    above, we will use D3’s zoom behavior to deliver all the user interaction changes
    we need:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放不过是改变我们的投影比例。旋转不过是改变我们投影的旋转值。当你想让用户控制缩放和旋转时，你需要监听他们的鼠标移动。因此，你需要设置一个缩放监听器来跟踪用户的鼠标滚轮和拖动操作，并将其附加到画布上。我们已经在[第5章](d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml)中实现了缩放和旋转，*点击-点击-爆炸！将交互性应用于您的地图*。在我们的`ready()`函数中，如上所述，我们将使用D3的缩放行为来提供我们需要的所有用户交互变化：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, you create the zoom behavior with `d3.zoom()`, define scaling bounds
    between *0.5* and *4*, and inform the behavior to trigger our `zoomed()` handler
    as soon as a `“zoom”` event has been triggered. However, so far, this has been
    a blunt tool. To understand what it does, you have to call it on an element. Call
    it on your Canvas element, and that element will be the sensor of all zoom-related
    user events. Importantly, it will listen for mouse wheel and drag events and expose
    the event information in the global `d3.event` object. It will further store the
    information in the base element it got called on (in our case, the main Canvas),
    but we’ll be happily served by the `d3.event` object you can tap into at each
    event.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用`d3.zoom()`创建缩放行为，定义介于*0.5*和*4*之间的缩放限制，并通知行为在触发“缩放”事件时立即触发我们的`zoomed()`处理程序。然而，到目前为止，这只是一个粗糙的工具。要了解它做什么，你必须在一个元素上调用它。在你的画布元素上调用它，那么这个元素将成为所有与缩放相关的用户事件的传感器。重要的是，它将监听鼠标滚轮和拖动事件，并在全局的`d3.event`对象中暴露事件信息。它还将存储在它被调用的基本元素中的信息（在我们的情况下，是主画布），但我们将由可以在每个事件中访问的`d3.event`对象所服务。
- en: 'Further, we want to set up some variables for tracking our scale and rotation
    whereabouts during zoom. We do this at the very top of our code with the following
    global variables:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想在缩放期间设置一些变量来跟踪我们的比例和旋转位置。我们在代码的顶部这样做，使用以下全局变量：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The newcomers in the preceding code are `origProjectionScale`, `projectionScaleChange`,
    `prevTransformScale`, and `rotation`. Their mission will become clear in the following
    paragraphs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的新变量是`origProjectionScale`、`projectionScaleChange`、`prevTransformScale`和`rotation`。它们的作用将在接下来的段落中变得清晰。
- en: Handling zoom and rotation
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理缩放和旋转
- en: We set up the zoom behavior, meaning that our Canvas is
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了缩放行为，这意味着我们的画布
- en: listening on every mouse wheel and drag
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听每个鼠标滚轮和拖动
- en: firing the `zoomed()` handler on each of these events
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个这些事件上触发`zoomed()`处理程序
- en: Let’s now fill our handler to do something to the globe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们填充我们的处理程序，对地球进行一些操作。
- en: 'What do we want to do? From a bird’s perspective, for each zoom, we want to
    establish the scale for the projection, apply it to the path, and redraw the globe
    a little bit bigger or a little smaller. For each drag, we would want to establish
    the new rotation values, apply them to the projection and path, and redraw the
    globe a little bit rotated. To get there, the handler should distinguish between
    a zoom and a drag. A zoom should lead to a projection-scale change and a drag
    should lead to a rotation change. For each path, you calculate the position change.
    Once that’s done, you will need to redraw the globe. It’s the game-loop mantra:
    process user-input, clear the Canvas, then redraw the Canvas with updated data.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想做什么？从鸟瞰的角度来看，对于每次缩放，我们想要为投影建立比例，将其应用于路径，并稍微放大或缩小地球。对于每次拖动，我们想要建立新的旋转值，将其应用于投影和路径，并稍微旋转地球。为了达到这个目的，处理程序应该区分缩放和拖动。缩放应该导致投影比例的变化，而拖动应该导致旋转的变化。对于每个路径，你计算位置变化。一旦完成，你需要重新绘制地球。这是游戏循环的咒语：处理用户输入，清除画布，然后使用更新后的数据重新绘制画布。
- en: 'Let’s start with the zoom action:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从缩放动作开始：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At first, we will need to distinguish between a zoom and a drag event. D3 makes
    this easy for us with the `d3.event` object holding a `sourceEvent` property specifying
    what event `type` the user triggers. If it’s a `wheel` event, we change the scale
    if it's a `mousemove` event, we change the rotation. Simple.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要区分缩放和拖动事件。D3通过`d3.event`对象持有`sourceEvent`属性来指定用户触发的事件`type`，使我们很容易做到这一点。如果是`wheel`事件，我们改变比例；如果是`mousemove`事件，我们改变旋转。很简单。
- en: Changing the scale looks involved but is pretty straightforward. Before we dive
    into the code, let’s make one important distinction. The projection has a scale,
    and the transformation upon user zoom also has a scale. However, they are different.
    Projection scales differ between projections. Our `d3.geoOrthographic()` projection
    has an initial scale of around *286* (we set it to *height / 2.1 = 286*). Our
    transformation has an initial scale of *1*. That’s the default.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 改变比例看起来很复杂，但实际上相当简单。在我们深入代码之前，让我们做一个重要的区分。投影有一个比例，用户缩放时的变换也有一个比例。然而，它们是不同的。投影比例在不同投影之间是不同的。我们的`d3.geoOrthographic()`投影的初始比例大约是*286*（我们将其设置为*height
    / 2.1 = 286*）。我们的变换的初始比例是*1*。这是默认值。
- en: So, you retrieve the current `transformScale` via `d3.transform.k`. You note
    down the change of this scale to the previous transform scale, which can be negative
    for zoom in or positive for zoom out. However, as your projection scale is quite
    a big number (as in *286* to start with) and the transform scale change per zoom
    will be small (for a normal mouse wheel turn the change might be around *0.005*),
    you will want to boost this number up to get a noticeable change in your projection.
    Hence, you will multiply it with a larger number. You can choose any large number
    you like, but choosing your initial projection scale we called `origProjectionScale`
    allows you to port this calculation over to any other projection, and it should
    work nicely. You then just change the current `projectionScale` by this `projectionScaleChange.`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以通过`d3.transform.k`检索当前的`transformScale`。您记录下这个比例与之前变换比例的变化，这可能对于放大是负数，对于缩小是正数。然而，由于您的投影比例是一个相当大的数字（例如，初始为*286*）并且变换比例的变化每次缩放都会很小（对于正常的鼠标滚轮转动，变化可能大约是*0.005*），您可能希望将这个数字放大以在投影中获得明显的变化。因此，您需要将它乘以一个较大的数字。您可以选择任何您喜欢的较大数字，但选择我们称为`origProjectionScale`的初始投影比例可以使您将这个计算转移到任何其他投影上，并且应该工作得很好。然后，您只需通过这个`projectionScaleChange`更改当前的`projectionScale`。
- en: The rest is simple. Just apply it to your globe’s projection with `projection.scale(projectionScale)`,
    set the previous transform scale to the updated transform scale, and re-render
    the globe. Note, that you don’t need to update the path generator, as whenever
    it’s called, it will use the projection as is at the moment of being called, which
    we’ve changed accordingly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的都是简单的。只需使用`projection.scale(projectionScale)`将其应用于地球的投影，将之前的变换比例设置为更新的变换比例，并重新渲染地球。注意，您不需要更新路径生成器，因为每次调用它时，它都会使用调用时的投影，我们已经相应地更改了它。
- en: 'That was the hard bit. Rotating is even simpler. You just need to track the
    changes in the user’s mouse movements and apply them to D3’s `projection.rotate()`
    parameters. Let’s track the change in mouse coordinates right at the top of the
    `zoomed()` handler:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最困难的部分。旋转甚至更简单。您只需要跟踪用户鼠标移动的变化并将其应用到D3的`projection.rotate()`参数上。让我们在`zoomed()`处理器的顶部跟踪鼠标坐标的变化：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note, that the two `MouseEvent` properties `.movementX` and `.movementY` are
    not available in Safari or Internet Explorer. You can see a cross-browser implementation,
    which is calculating the two values on the fly in code example [10_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html#L237)
    at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Safari或Internet Explorer中不可用两个`MouseEvent`属性`.movementX`和`.movementY`。您可以在代码示例[10_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html#L237)中看到一个跨浏览器的实现，该示例在[https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)计算这两个值。
- en: 'The rotation logic will trigger when the user drags or rather triggers the
    `mousemove` event, which goes into the `else if` part of our conditional:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转逻辑将在用户拖动或触发`mousemove`事件时触发，这进入我们条件语句的`else if`部分：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we first retrieve the current rotation values from the
    projection in the variable `r`. Then, you change the `r[0]`, the yaw value (responsible
    for rotating the world around its normal or vertical axis) by the *x* change of
    the mouse coordinates. You further change `r[1]`, the roll value (rotating the
    world around its lateral axis, going horizontally from left to right) by the y
    change of the mouse coordinates. We leave the third pitch value as is, and yes,
    the best way is to throttle these values to a reasonable speed of rotation with
    `dx * 0.4` and `dy * 0.5`, respectively. Note that this is the straightforward
    but naive way to rotate the globe. It will fully do in our case. If you want to
    apply utmost precision, you could use **versor** dragging (check out [http://tiny.cc/versor](http://tiny.cc/versor)).
    The key difference is that versor dragging rotates the globe in the right direction
    even when it's upside down.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先从投影变量`r`中检索当前的旋转值。然后，通过鼠标坐标的x变化改变`r[0]`，即偏航值（负责围绕其法线或垂直轴旋转世界），通过鼠标坐标的y变化进一步改变`r[1]`，即翻滚值（围绕横向轴旋转世界，从左到右水平移动）。我们保留第三个俯仰值不变，并且是的，最佳方式是将这些值通过`dx
    * 0.4`和`dy * 0.5`分别限制在一个合理的旋转速度。请注意，这是旋转地球的直接但天真方法。在我们的情况下，这完全足够。如果你想应用极致的精度，可以使用**向量拖动**（查看[http://tiny.cc/versor](http://tiny.cc/versor)）。关键区别在于，即使地球倒置，向量拖动也能使地球向正确的方向旋转。
- en: 'That’s it for rotation. Remember, the world gets re-rendered after this conditional
    as we do this in the following Canvas game loop: get user input – calculate the
    new position – re-render.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转就到这里。记住，在这个条件之后，世界会被重新渲染，因为我们这样做是在接下来的Canvas游戏循环中：获取用户输入 - 计算新位置 - 重新渲染。
- en: 'Here’s a static attempt to show dynamic zooming and rotations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里尝试静态展示动态缩放和旋转：
- en: '![](img/ed98d35d-88fb-4cf9-bf78-115e400d2056.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed98d35d-88fb-4cf9-bf78-115e400d2056.png)'
- en: Zooming and rotating a Canvas globe
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放和旋转Canvas地球
- en: View the step shown in the preceding screenshot in the browser at [https://larsvers.github.io/learning-d3-mapping-10-2](https://larsvers.github.io/learning-d3-mapping-10-2)
    and its code example at [10_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看前面截图所示的步骤，网址为[https://larsvers.github.io/learning-d3-mapping-10-2](https://larsvers.github.io/learning-d3-mapping-10-2)，以及其代码示例在[10_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html)。
- en: The main benefit of zooming via a projection change is that it allows rotating
    (that’s a win) and guarantees **semantic zooming** of the world rather than **geometric
    zooming**. When you zoom into a Canvas object with `context.scale()`, it naively
    enlarges anything that’s on the Canvas. So, a country border, for example, gets
    wider and wider, the more you scale it. That’s **geometric zooming**. We, however,
    want to keep everything constant, apart from the area of the individual country
    polygons. This is called **semantic zooming**. Another benefit of the **projection
    change** is that getting the coordinate of a Canvas object by mouse-over is more
    straightforward. This is our next stop.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过投影变化进行缩放的主要好处是它允许旋转（这是一个优点）并保证世界的**语义缩放**而不是**几何缩放**。当你使用`context.scale()`对Canvas对象进行缩放时，它会天真地放大Canvas上的任何内容。例如，国家边界会随着缩放程度的增加而越来越宽。这就是**几何缩放**。然而，我们希望保持一切恒定，除了个别国家多边形的面积。这被称为**语义缩放**。**投影变化**的另一个好处是，通过鼠标悬停获取Canvas对象的坐标更加直接。这是我们下一步要做的。
- en: Finding the Canvas object under the mouse - Picking
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 找到鼠标下的Canvas对象 - 选择
- en: 'We’ve done zooming and rotating. Let’s celebrate by adding another key piece
    of interactivity: the mouseover. In fact, we don’t want just any mouseover. We
    want to mouse over an object drawn on the Canvas and retrieve information from
    that object. Once we have that, we have a lot—we can create tooltips, we can highlight
    the object, we can link views with another graph showing the same data point,
    and so on.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了缩放和旋转。让我们通过添加另一个关键交互性元素来庆祝：鼠标悬停。实际上，我们不仅仅想要任何鼠标悬停。我们想要鼠标悬停在Canvas上绘制的对象上，并从该对象中检索信息。一旦我们有了这些，我们就有很多——我们可以创建工具提示，我们可以突出显示对象，我们可以将视图与显示相同数据点的另一个图表链接，等等。
- en: Picking, the theory
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择，理论
- en: So, how are we doing this? As established many times above, we can’t just add
    a listener to a set of pixels, because an event is an object maintained by the
    browser, interacting with DOM nodes. However, our browser doesn’t know about the
    pixel. It doesn’t have a representation of the Canvas pixels it wants to interact
    with. So, how?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们是如何做到这一点的？如上所述多次建立，我们不能仅仅向一组像素添加监听器，因为事件是浏览器维护的对象，与DOM节点交互。然而，我们的浏览器不知道像素。它没有它想要与之交互的画布像素的表示。那么，怎么办？
- en: 'The answer is relatively simple: we build it ourselves. Not the DOM, that would
    be madness, but a representation of our Canvas drawing in which the target object’s
    pixel are charged with this object’s information.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 答案相对简单：我们自己去构建。不是DOM，那将是疯狂的行为，而是我们画布绘制的表示，其中目标对象的像素被赋予这个对象的信息。
- en: So, what do we need to build our own little visual object representation? In
    short, you will build two Canvases. One **main Canvas** that produces our visual
    (done already) and one **hidden Canvas** (as in you can’t see it) that produces
    the same visual. The key here is that all elements on the second Canvas will be
    at the same position in relation to the Canvas origin compared to the first Canvas.
    We will bend this rule a little in practice, but, for now, imagine that the northern
    tip of Scotland is at pixel position *250, 100* of the main Canvas and that it
    is also at *250, 100* of the hidden Canvas.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们需要构建自己的小视觉对象表示？简而言之，你将构建两个画布。一个**主画布**用于生成我们的视觉（已经完成）和一个**隐藏画布**（就像你看不见它一样），用于生成相同的视觉。关键在于，第二个画布上的所有元素相对于画布原点与第一个画布上的位置相同。在实践中，我们会稍微弯曲这个规则，但，现在，想象一下苏格兰的北端在主画布的像素位置*250,
    100*，并且它也在隐藏画布的*250, 100*位置。
- en: 'There is only one key difference between the main and the hidden Canvas. Each
    element on the hidden Canvas will get a **unique color**. What’s more, these color
    values will be indexes to look up our data values. In our case, we will assign
    *rgb(0,0,0)* to the first country in our country list: Afghanistan. Our second
    country will get the color value *rgb(1,0,0)* and so on until our last country–Zimbabwe–will
    get the color value *rgb(176,0,0)*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 主画布和隐藏画布之间只有一个关键区别。隐藏画布上的每个元素都将获得**独特的颜色**。更重要的是，这些颜色值将是查找我们的数据值的索引。在我们的情况下，我们将*rgb(0,0,0)*分配给国家列表中的第一个国家：阿富汗。我们的第二个国家将获得颜色值*rgb(1,0,0)*，以此类推，直到我们的最后一个国家——津巴布韦——将获得颜色值*rgb(176,0,0)*。
- en: Why? Because, next, we will attach a mousemove listener to the main Canvas to
    retrieve a flow of mouse positions as we move the mouse. At each mouse position,
    we can use the Canvas's own method `context.getImageData()` to pick the color
    of the pixel at this exact position. We just extract the R value from our RGB
    color and can query our data array to get the object we need.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为，接下来，我们将为主画布附加一个mousemove监听器，以获取我们移动鼠标时的鼠标位置流。在每个鼠标位置，我们可以使用画布的自身方法`context.getImageData()`来获取此确切位置的像素颜色。我们只需从我们的RGB颜色中提取R值，然后查询我们的数据数组以获取所需的对象。
- en: Our itinerary is clear and, with three steps, relatively short. First, we will
    create the hidden Canvas. Secondly, we will draw the world with a unique color
    per country. Finally, we will write the mousemove handler to pick the color and
    get the data. Lastly, we have to decide what to do with all that data we can access.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的行程清晰，并且，通过三个步骤，相对较短。首先，我们将创建隐藏画布。其次，我们将用每个国家的独特颜色绘制世界。最后，我们将编写mousemove处理程序来拾取颜色并获取数据。最后，我们必须决定如何处理我们可以访问的所有数据。
- en: 'Before we start, let’s make sure that we actually have some data for each country.
    Here’s our GeoJSON country object that shows the contents of the first two of
    177 countries:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们确保我们确实为每个国家有一些数据。这是我们的GeoJSON国家对象，显示了177个国家中的前两个国家的数据内容：
- en: '![](img/51458214-8499-4fd2-87cf-988d935ffcd7.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51458214-8499-4fd2-87cf-988d935ffcd7.png)'
- en: The data properties of the country’s array
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 国家数组的属性
- en: 'Our GeoJSON world is a `FeatureCollection` with one feature per country, ascendingly
    sorted by country name. Each feature is an object holding a `type` property, the
    `geometry` for the country polygon, and a property called `properties`. In here,
    we have three data points: the country abbreviation, the country name, and even
    an estimate of the country’s population. Now, let’s get to that data by mouse
    over.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GeoJSON世界是一个`FeatureCollection`，每个国家有一个特征，按国家名称升序排序。每个特征是一个包含`type`属性、国家多边形的`geometry`和称为`properties`的属性的对象。在这里，我们有三个数据点：国家缩写、国家名称，甚至还有国家人口的估计。现在，让我们通过鼠标悬停来获取这些数据。
- en: Creating all things hidden
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建所有隐藏的事物
- en: 'By now, you’ve set up so many Canvases that, at worst, this code just bores
    you:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经设置了这么多Canvas，在最坏的情况下，这段代码只会让你感到无聊：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only thing we want to make sure of here is to apply the same width and height
    that we applied to the main Canvas.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里唯一想要确保的是应用与主Canvas相同的宽度和高度。
- en: 'Next, we will draw the world to it. In order to do so, we have to build a projection
    and path generator and then loop through all countries to draw each country to
    the Canvas; let''s do that:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制世界地图。为了做到这一点，我们必须构建一个投影和路径生成器，然后遍历所有国家，将每个国家绘制到Canvas上；让我们这样做：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We, of course, need a new path generator, as we need to feed our now hidden
    drawing context to the `.context()` method. However–hold on–we already have a
    projection for the main Canvas. Shouldn’t we use it for the hidden Canvas also?
    Especially, as we said above that ideally the objects on our hidden Canvas should
    be in the exact same position as the objects on our main Canvas to query the hidden
    positions easily? However, here, we use an **equi-rectangular** projection, which
    will draw the world in a rather different way to our **orthographic** projection
    on the main Canvas. Don’t we need the same projection to produce the same globe?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然需要一个新路径生成器，因为我们需要将现在隐藏的绘图上下文传递给`.context()`方法。然而——等等——我们已经有了一个主Canvas的投影。我们不应该也使用它来绘制隐藏Canvas吗？特别是，正如我们上面所说的，理想情况下，隐藏Canvas上的对象应该与主Canvas上的对象在确切的位置上，以便轻松查询隐藏位置？然而，在这里，我们使用了一个**等距**投影，这将以与我们主Canvas上的**正射投影**截然不同的方式绘制世界。我们不需要相同的投影来生成相同的地球吗？
- en: The answer is no, we don’t need the same projection. When our mouse is on a
    specific position on the main Canvas, we just need to find the same position on
    the hidden Canvas. No doubt, the easiest way to do this is to use the exact same
    coordinates. However, we can also use the main projection’s `projection.invert([x,y])`
    function to retrieve this position’s longitude and latitude values. We will then
    use the hidden projection to convert the geo-coordinates to pixel coordinates
    on the hidden Canvas. Long-winded? Yes, a little. However, with a moving object
    such as a zooming and rotating globe, this saves us from re-drawing the hidden
    Canvas. We shall see this in action very soon when we build the handler in the
    third step.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的，我们不需要相同的投影。当我们的鼠标位于主Canvas上的特定位置时，我们只需要找到隐藏Canvas上相同的位置。毫无疑问，最简单的方法是使用确切的相同坐标。然而，我们也可以使用主投影的`projection.invert([x,y])`函数来检索该位置的经纬度值。然后我们将使用隐藏投影将地理坐标转换为隐藏Canvas上的像素坐标。冗长吗？是的，有一点。然而，对于像缩放和旋转的地球这样的移动对象，这可以让我们避免重新绘制隐藏Canvas。我们将在第三步构建处理程序时很快看到这一点。
- en: First, let’s draw the hidden Canvas.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们绘制隐藏Canvas。
- en: Drawing the hidden Canvas
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制隐藏Canvas
- en: 'There’s just a single simple function that does what you need in this step:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，只有一个简单的函数可以完成你需要的功能：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only argument—`world`—is our GeoJSON feature collection. `countries` pulls
    out just the array of country information, including the polygons and the additional
    data we’re after. We loop through all of them, drawing each country with the `hiddenContext`
    and — most importantly—we gave each country a color using the `rgb(<country index>,
    0, 0)` pattern.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的参数——`world`——是我们的GeoJSON要素集合。`countries`提取出包含多边形和我们所追求的额外数据的国家信息数组。我们遍历所有这些信息，使用`hiddenContext`绘制每个国家，并且——最重要的是——我们使用`rgb(<country
    index>, 0, 0)`模式为每个国家分配了一种颜色。
- en: Here we have it! A graph-like structure of our Canvas visual, representing our
    data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是它！我们Canvas视觉的图状结构，代表我们的数据。
- en: 'So far, it’s only a function, so let’s invoke it. We only need to call `drawHiddenCanvas()`
    once whenever we have the data available. So, we venture to the `ready()` function
    and invoke it right after we draw the main Canvas with `renderScene()`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它只是一个函数，所以让我们调用它。我们只需要在有数据可用时调用一次`drawHiddenCanvas()`。因此，我们进入`ready()`函数，并在使用`renderScene()`绘制主Canvas之后立即调用它：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here they are; our two worlds:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是它们；我们的两个世界：
- en: '![](img/c5b95c2f-20ad-4338-8e97-53477c1ec9f7.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b95c2f-20ad-4338-8e97-53477c1ec9f7.png)'
- en: The main and the hidden Canvas
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 主Canvas和隐藏Canvas
- en: 'Each country has a slightly different color, ranging from black to red or from
    *rgb(0,0,0)* = *Afghanistan* to *rbg(176,0,0) = Zimbabwe*. You can see how countries
    that start high up in the alphabet—Antarctica, Australia, Brasil, or Canada—are
    much darker than countries that are low down in the alphabet—the United States
    or Russia. Note that we’ll keep our hidden Canvas visible for demonstration purposes,
    but, in production, we can just add the CSS rule `{ display: hidden }` to hide
    our Canvas. No one needs to know about our little trick.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '每个国家都有略微不同的颜色，从黑色到红色，或从 *rgb(0,0,0)* = *阿富汗* 到 *rbg(176,0,0) = 津巴布韦*。你可以看到，字母表中排名靠前的国家——南极洲、澳大利亚、巴西或加拿大——比字母表中排名靠后的国家——美国或俄罗斯——要暗得多。注意，为了演示目的，我们将保持隐藏
    Canvas 可见，但在生产中，我们只需添加 CSS 规则 `{ display: hidden }` 来隐藏我们的 Canvas。没有人需要知道我们的这个小技巧。'
- en: Picking the values
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择值
- en: 'At this point, you have all tools at hands to implement a hover. Now, you will
    need to make it happen. To wire it all up, you need to do the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经拥有了所有实现悬停的工具。现在，你需要让它发生。为了连接所有这些，你需要执行以下步骤：
- en: Listen to mousemoves on the main Canvas.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听主 Canvas 上的鼠标移动。
- en: Translate these coordinates to positions on the hidden Canvas.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些坐标转换到隐藏 Canvas 上的位置。
- en: Pick the color from that position.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那个位置选择颜色。
- en: Strip out the color value that represents the data array index for your data.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取代表数据数组索引的数据的颜色值。
- en: Lean back and think of ways to use it.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退后一步，想想如何使用它。
- en: 'Listening on mousemove is easy; you just need to perform the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 监听鼠标移动很简单；你只需要执行以下命令：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Done. The first thing we will do in `highlightPicking()` is translate the mouse
    position on the main Canvas to the coordinates on the hidden Canvas:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。在 `highlightPicking()` 中，我们首先将主 Canvas 上的鼠标位置转换为隐藏 Canvas 上的坐标：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We first get the *x, y* mouse coordinates. This will be updated whenever we
    move the mouse. An example value of the `pos` variable is *[488, 85]*, which is
    in the north of France. We use D3’s own `projection.invert()` which is the inverse
    of `projection()`. What does `projection()` do? It takes an array of [longitude,
    latitude] values and returns a pair of [x, y] pixel coordinates. Well, `projection.invert()`
    does the opposite. It takes a pixel coordinate array and returns the respective
    longitude and latitude array. In our case, that will be [2.44, 48.81]. The longitude
    is a bit further right of *0*, which is Greenwich, so yes, that seems right. Note,
    that this projection is our main Canvas projection. Next, we use our `hiddenProjection()`
    function to reproject our `longlat` values to the pixel coordinates of this very
    place. In our example, `hiddenPos` gets the pixel coordinates [485.83, 183.17]
    assigned to it. That’s the very same spot in the north of France on the hidden
    Canvas! Exactly what we were after.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取 *x, y* 鼠标坐标。每当鼠标移动时，这个坐标将会更新。`pos` 变量的一个示例值是 *[488, 85]*，这位于法国的北部。我们使用
    D3 的 `projection.invert()`，它是 `projection()` 的逆操作。`projection()` 做什么呢？它接受一个 [经度,
    纬度] 值的数组，并返回一对 [x, y] 像素坐标。嗯，`projection.invert()` 做的是相反的操作。它接受一个像素坐标数组，并返回相应的经纬度数组。在我们的例子中，这将是一个
    [2.44, 48.81] 的数组。经度稍微偏向 *0* 的右边，即格林尼治，所以，这似乎是正确的。注意，这个投影是我们主要的 Canvas 投影。接下来，我们使用我们的
    `hiddenProjection()` 函数将 `longlat` 值重新投影到这个位置的像素坐标。在我们的例子中，`hiddenPos` 被分配了像素坐标
    [485.83, 183.17]。这就是法国北部的同一位置在隐藏的 Canvas 上！这正是我们想要的。
- en: 'To demonstrate this, take a look at the following screenshots:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，请看以下截图：
- en: '![](img/6b5b3bee-eb0d-421b-bf5c-ece23935491a.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b5b3bee-eb0d-421b-bf5c-ece23935491a.png)'
- en: Translating the main Canvas mouse coordinates to the hidden Canvas coordinates
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将主 Canvas 鼠标坐标转换为隐藏 Canvas 坐标
- en: Our mouse position on the upper main Canvas represented by `pos` gets translated
    to the lower orange circle represented by the `hiddenPos` variable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主 Canvas 上表示的鼠标位置 `pos` 被转换成表示为 `hiddenPos` 变量的下方的橙色圆圈。
- en: 'Now, we finally get to pick that color:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以挑选那个颜色了：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This returns a special array with the unwieldy name `Uint8ClampedArray` representing
    the R, the G, the B, and the alpha value (peculiarly also ranging from *0* to
    *255*) at exactly that pixel. In our case, for example, for France (the left most
    pick in the preceding screenshot), the color is `52`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了一个名为 `Uint8ClampedArray` 的特殊数组，这个名字听起来很复杂，它代表了在精确像素处的 R、G、B 和 alpha 值（特别地，这些值也范围从
    *0* 到 *255*）。在我们的例子中，例如，对于法国（前一个截图中最左侧的选择），颜色是 `52`：
- en: '![](img/82452b63-cb05-49c3-bce9-aa1860dde291.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82452b63-cb05-49c3-bce9-aa1860dde291.png)'
- en: The picked color array
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的颜色数组
- en: Cross-checking with our `countries` array, we can confirm that the array element
    with the index `52` is **France**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与我们的`countries`数组进行交叉检查，我们可以确认索引为`52`的数组元素是**法国**。
- en: 'However, we will build in two security checks before we can be sure of hovering
    over a country. First, you will check whether the user’s mouse is on the globe
    and not somewhere in the outer space:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够确信鼠标悬停在某个国家之前，我们将设置两个安全检查。首先，你需要检查用户的鼠标是否在地球上，而不是在太空中某个地方：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In an ideal world, for our purpose, `projection.invert(pos)` above would return
    `undefined` or similar when we move beyond the globe; however, it still returns
    actual pixel coordinates, which is not what we want. The problem is that `projection.invert()`
    is not **bijective**, meaning it can in fact return the same *[long, lat]* coordinates
    for different pixel position inputs. This is especially the case when we move
    the mouse beyond the globe bounds. To alleviate this issue, we do a so called
    **forward projection** here. This just means that we project the inverse of our
    projection. We take in the pixel coordinates, translate them to *[long, lat]*
    values and project them back to pixel coordinates. If our mouse is within the
    globe, this will return our exact mouse position (in fact we give it a leeway
    of +/- 0.5 pixels here). If our mouse is outside the globe, the forward projection
    will deviate from our mouse position in pixel.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，为了我们的目的，`projection.invert(pos)`上面在移动到地球之外时会返回`undefined`或类似值；然而，它仍然返回实际的像素坐标，这并不是我们想要的。问题是`projection.invert()`不是**双射**的，这意味着它可以实际上为不同的像素位置输入返回相同的*[经度,
    纬度]*坐标。这在我们移动鼠标超出地球边界时尤其如此。为了减轻这个问题，我们在这里进行所谓的**正向投影**。这仅仅意味着我们投影投影的反向。我们接收像素坐标，将它们转换为*[经度,
    纬度]*值，并将它们重新投影回像素坐标。如果我们的鼠标在地球内，这将返回我们的确切鼠标位置（实际上我们在这里给了它+/- 0.5像素的容差）。如果鼠标在地球外，正向投影将偏离鼠标的像素位置。
- en: 'The second check we perform is to make sure that our mouse is over a country
    and not a country border:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行的第二次检查是确保鼠标位于一个国家而不是国家边界上：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s take this one by one. `selected` will hold the index. You will, however,
    only get the index if the user’s mouse is inside the globe (`inGlobe` === `true`).
    This is our first check. Secondly, the fourth element of our special `pickedColor`
    array has to be exactly *255*. Otherwise, selected will be false. This second
    check is to surpass **antialiasing** effects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一来看。`selected`将保存索引。然而，你只有在用户的鼠标在地球内(`inGlobe` === `true`)时才会得到索引。这是我们的第一个检查。其次，我们特殊`pickedColor`数组的第四个元素必须正好是*255*。否则，`selected`将为`false`。这个第二个检查是为了超越**抗锯齿**效果。
- en: 'Why do we need that? The problem with pixels in browsers is that they outsmart
    us. Lines are feathered at the edges to allow the impression of a smooth transition
    from line to background:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要这样做呢？浏览器中像素的问题在于它们比我们聪明。边缘的线条被羽化，以允许从线条到背景的平滑过渡印象：
- en: '![](img/e529dada-a2c0-4afb-a9f9-ef0b1f473653.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e529dada-a2c0-4afb-a9f9-ef0b1f473653.png)'
- en: An aliased line above an antialiased line
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在抗锯齿线之上的别名线
- en: Picking values at these feathered edges would not return fully opaque colors,
    but transparent values of varying degree. These values have an alpha channel lower
    than 255, so checking for our alpha to be 255 allows us to pick only from aliased
    areas.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些羽化边缘选择值不会返回完全不透明的颜色，而是不同程度的透明值。这些值具有低于255的alpha通道，因此检查我们的alpha是否为255可以让我们只从别名区域中选择。
- en: Fabulous! We’ve built ourself a second Canvas that functions as a memory of
    the objects on our main data. Next, we’ll use it. The Canvas way of changing anything
    with our elements and objects is to pass the information to the redrawing part
    of our app to use it in there accordingly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经为自己构建了一个第二个Canvas，它充当了我们主要数据上对象的记忆。接下来，我们将使用它。Canvas改变任何元素和对象的方式是将信息传递给我们的应用程序的重绘部分，以便在那里相应地使用它。
- en: Storing more data and using a lookup array
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储更多数据和使用查找数组
- en: We are blessed with the fact that the world we visualize only has 176 countries.
    This way, we only need to keep track of 176 indeces. However, you often deal with
    more data objects so that 256 (as in 0-255) will be used up rather quickly. Luckily,
    we not only have R but also G and B values and their unique combinations, which
    gets us to *256*256*256 = 16,777,216* possible indeces you can store. That will
    bring you far.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运，因为我们可视化的世界只有176个国家。这样，我们只需要跟踪176个索引。然而，你经常处理更多的数据对象，所以256（就像0-255）会很快用完。幸运的是，我们不仅有R、G和B值及其独特的组合，这使我们达到了
    *256*256*256 = 16,777,216* 个可能的索引可以存储。这将带你走得很远。
- en: Check the tutorial at [http://tiny.cc/d3-canvas](http://tiny.cc/d3-canvas) for
    more details.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 查看教程[http://tiny.cc/d3-canvas](http://tiny.cc/d3-canvas)以获取更多详情。
- en: Highlighting the country on mouse over
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标悬停时突出显示国家
- en: 'Whenever a country is picked, we just pass the selected variable through to
    our `drawScene()` function that draws the world at each mouseover:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每当选择一个国家时，我们只需将选定的变量传递给我们的 `drawScene()` 函数，该函数在每个鼠标悬停时绘制世界：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the end of our highlight handler, we didn’t only pass the `countries` to
    our render function, we also sent our newly created `selected` on the way. The
    `renderScene()` function just passes it through to `drawScene()`, which draws
    the world to the `buffer` Canvas. Remember that `renderScene()` just calls `drawScene()`,
    then clears the main Canvas and copies the `buffer` image over to the main Canvas.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的高亮处理程序结束时，我们不仅将 `countries` 传递给我们的渲染函数，我们还沿着路发送了我们新创建的 `selected`。`renderScene()`
    函数只是将其传递给 `drawScene()`，该函数将世界绘制到 `buffer` Canvas 上。记住，`renderScene()` 只是调用 `drawScene()`，然后清除主Canvas，并将
    `buffer` 图像复制到主Canvas上。
- en: 'In `drawCanvas()`, we will add a single block:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `drawCanvas()` 中，我们将添加一个单独的块：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will receive the `selected` index via the `countryIndex` argument and check
    whether it''s larger or equal to *0* (remember, that would be *Afghanistan*).
    If so, we draw a dashed path around the country. How do we know which country?
    We access the right country via `countries.features[countryIndex]` and draw it
    accordingly. The mind boggles:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 `countryIndex` 参数接收 `selected` 索引，并检查它是否大于或等于 *0*（记住，那将是 *阿富汗*）。如果是这样，我们将在国家周围绘制一条虚线。我们如何知道是哪个国家？我们通过
    `countries.features[countryIndex]` 访问正确的国家，并相应地绘制它。这让人感到困惑：
- en: '![](img/d94adbe9-f76b-4d32-a236-72c2363a7d6f.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d94adbe9-f76b-4d32-a236-72c2363a7d6f.png)'
- en: A dashed line around the US, just because we picked the right color
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 美国周围的一条虚线，仅仅因为我们选对了颜色
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-10-3](https://larsvers.github.io/learning-d3-mapping-10-3)
    and the code example at [10_03.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_03.html).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤[https://larsvers.github.io/learning-d3-mapping-10-3](https://larsvers.github.io/learning-d3-mapping-10-3)和代码示例[10_03.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_03.html)。
- en: Visualizing data per country and adding a tooltip
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按国家可视化数据和添加工具提示
- en: You learned to build a data-driven and -giving representation of your visual.
    You have also used it to highlight the country at hover. However, you haven’t
    really tapped into the plentiful options of interaction this gives you. Let’s
    do this now. There’s a lot you could do, but I think a tooltip would be a reasonable
    place to start.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何构建一个数据驱动的和给予的视觉表示。你也用它来突出显示鼠标悬停时的国家。然而，你还没有真正挖掘出这个交互选项的丰富性。让我们现在就做这件事。你可以做很多事情，但我认为工具提示是一个合理的起点。
- en: Before we embark on the tooltip build, let’s add some more interesting data
    to the globe. So far, we have **country name**, **country name abbreviation**,
    and **population estimate**. That’s already something to work with. However, let’s
    task ourselves with adding an additional data source to our globe, visualize it
    appropriately, and add a sensible interaction for user exploration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建工具提示之前，让我们给地球添加一些更有趣的数据。到目前为止，我们有 **国家名称**、**国家名称缩写**和**人口估计**。这已经是有东西可以工作了。然而，让我们给自己一个任务，向我们的地球添加一个额外的数据源，适当地可视化它，并为用户探索添加合理的交互。
- en: 'As a little reminder, this is what you will build:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小提醒，这就是你将要构建的内容：
- en: '![](img/c7d07b70-2fa9-414f-ae6e-93ed530c9f35.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7d07b70-2fa9-414f-ae6e-93ed530c9f35.png)'
- en: Our final Canvas adventure
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终Canvas冒险
- en: View the final app at [https://larsvers.github.io/learning-d3-mapping-10-4](https://larsvers.github.io/learning-d3-mapping-10-4)
    and the code example at [10_04.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://larsvers.github.io/learning-d3-mapping-10-4](https://larsvers.github.io/learning-d3-mapping-10-4)查看最终应用程序，并在[10_04.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html)查看代码示例。
- en: The preceding screenshot shows a globe visualization of forest cover per country.
    The data comes from the source of all solid wisdom, Wikipedia. The suggestion
    is to visualize it as a choropleth map. Arguably, choropleth maps have been overused
    in recent years, but they are nonetheless a great option to show percentage comparisons
    of geo-areas.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了按国家森林覆盖率的地球可视化。数据来自所有智慧之源，维基百科。建议将其可视化为一个等值线图。虽然近年来等值线图可能被过度使用，但它们无疑是一个展示地理区域百分比比较的好选择。
- en: The data is from [https://en.wikipedia.org/wiki/List_of_countries_by_forest_area](https://en.wikipedia.org/wiki/List_of_countries_by_forest_area).
    The missing North Cyprus, Somaliland, and Haiti have been estimated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数据来自[https://en.wikipedia.org/wiki/List_of_countries_by_forest_area](https://en.wikipedia.org/wiki/List_of_countries_by_forest_area)。北塞浦路斯、索马里兰和海地的数据已估算。
- en: The steps are relatively simple. First, we add our forest data to our GeoJSON
    world object. We’ll move on swiftly to color our countries according to the new
    data, and finally add a tooltip with HTML and SVG.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤相对简单。首先，我们将森林数据添加到我们的GeoJSON世界对象中。我们将迅速继续根据新数据为各国着色，并最终添加带有HTML和SVG的提示信息。
- en: Adding new data to our old globe
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的旧地球添加新数据
- en: 'After copying and pasting or scraping the data from Wikipedia, you should save
    your forest file in a data format of your choice. We saved it in CSV, and as we
    now have several data sources to load for one visual, we will use `d3.queue()`
    to wait for both files to load before invoking `ready()`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制粘贴或从维基百科抓取数据后，您应该将森林文件保存为您选择的数据格式。我们将其保存为CSV，因为我们现在有多个数据源需要加载以创建一个视觉图表，我们将使用`d3.queue()`等待两个文件加载完毕后再调用`ready()`：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, adapt your `ready()` function arguments and start accordingly:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据需要调整`ready()`函数的参数并开始：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Leave the country data prep as is (in that we push the world’s country arrays
    into a variable called `countries`) and move on to including the forest data into
    the world. What we want is this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 保持国家数据准备状态不变（即我们将世界国家的数组推入一个名为`countries`的变量中）并继续将森林数据包含到世界中。我们想要的是这个：
- en: '![](img/17c00718-1299-4794-b0a5-84855436574a.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17c00718-1299-4794-b0a5-84855436574a.png)'
- en: The updated data object we strive for
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们努力追求的更新后的数据对象
- en: The properties we need for the coloring and the tooltip are country name (`admin`),
    `forest_percent`, and `forest_area`. Note, that we also have `forest_color` here.
    This is the choropleth color for that country. It’s often beneficial to have your
    data in place before the draw. Hefty calculations during redraw can slow down
    performance and re-render.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用于着色和提示的属性是国家名称（`admin`）、`forest_percent`和`forest_area`。注意，我们这里也有`forest_color`。这是该国家的等值线颜色。在绘图之前将数据准备好通常是有益的。在重绘期间进行大量计算可能会降低性能并重新渲染。
- en: The forest CSV country names have been changed to match the exact naming of
    the countries GeoJSON. This way, you can use the names to join the two datasets.
    To join the data speedily, we will use **binary search**. Binary search leverages
    the sorted nature of our `countries` array to find a country match quickly. In
    short, it looks at the country name we want to find, and instead of looping through
    all countries in the GeoJSON, it splits the `countries` array in two halves and
    checks whether the search term is in the upper or the lower half. It does that
    repeatedly until it finds the term. This is much quicker than **linear search**
    (looping through all data); in our case, around 10 times faster.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 森林CSV国家的名称已更改为与GeoJSON中国家的确切命名相匹配。这样，您可以使用这些名称将两个数据集连接起来。为了快速连接数据，我们将使用**二分查找**。二分查找利用我们`countries`数组的排序特性快速找到匹配的国家。简而言之，它会查看我们想要找到的国家名称，而不是在GeoJSON中遍历所有国家，而是将`countries`数组分成两半，并检查搜索项是否在上半部分或下半部分。它会重复这样做，直到找到该术语。这比**线性搜索**（遍历所有数据）快得多；在我们的案例中，大约快10倍。
- en: 'You can implement binary search in D3 with `d3.bisect()` and that’s what we
    shall use. We add the data with a function we call `insertForestDataBinary()`.
    We shall add this function call and the function to the data preparation flow
    in the `ready()` function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用D3中的`d3.bisect()`实现二分搜索，这正是我们将要使用的。我们通过一个我们称之为`insertForestDataBinary()`的函数添加数据。我们将在`ready()`函数中将此函数调用和函数添加到数据准备流程中：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, you create a *bisector* function so that D3 knows which variable we want
    to find a name (`d.properties.admin`, the country name). You then iterate through
    all forest objects. Each forest object holds the `country` (the name we match),
    `forest_percent` and `forest_area` properties. The bisector will search the array
    and return the index after the matching `countries` object (or to the `.right`,
    as we specified above). Once you have that, you can add the new properties one
    index position before.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个*bisector*函数，这样D3就知道我们想要找到哪个变量的名称（`d.properties.admin`，国家名称）。然后，你遍历所有森林对象。每个森林对象包含`country`（我们要匹配的名称）、`forest_percent`和`forest_area`属性。二分搜索将搜索数组，并在匹配的`countries`对象之后返回索引（或到`.right`，如我们上面指定的）。一旦你有了这个，你就可以在索引位置之前添加新的属性。
- en: 'For the last property, `forest_color`, you need to create a `colorScale` somewhere
    in higher scope:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个属性，`forest_color`，你需要在更高作用域的某个地方创建一个`colorScale`：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Coloring the globe
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为地球着色
- en: 'Note that you have implemented all these changes before you draw the globe.
    That’s great as you can now simply draw it with the new color scheme. The only
    change is in our `drawScene()` function, filling the `countries` accordingly in
    a loop:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你在绘制地球之前已经实现了所有这些更改。这很好，因为你现在可以简单地使用新的颜色方案绘制它。唯一的变化是在我们的`drawScene()`函数中，在循环中相应地填充`countries`：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also, note that we adjusted the sphere fill and the graticule colors a little
    to work better with our yellow-green country color scale:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们对球体填充和网格线颜色做了一些调整，以更好地与我们的黄色-绿色国家颜色尺度相匹配：
- en: '![](img/d09ac20e-fb0d-45f4-ab4a-a6a21dbdfceb.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d09ac20e-fb0d-45f4-ab4a-a6a21dbdfceb.png)'
- en: A choropleth globe visualizing forest cover ratio per country
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表示每个国家森林覆盖率比率的等值线地球视觉
- en: Adding a tooltip
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加工具提示
- en: 'Your globe is colored by forest cover. Yellow countries have a low percentage
    of cover; dark green a higher one. That’s already a good clue about how much forest
    there is proportionally in each country. However, a user might additionally be
    interested in how high the forest cover is exactly, and how this compares to other
    countries. You have all the data in your hands, so let’s not be stingy, and add
    the following tooltip:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你的地球通过森林覆盖率着色。黄色国家覆盖率低；深绿色覆盖率较高。这已经是一个很好的线索，说明了每个国家森林的比例。然而，用户可能还想知道森林覆盖的确切程度，以及这与其他国家相比如何。你手中拥有所有数据，所以让我们不要吝啬，添加以下工具提示：
- en: '![](img/0d04cdee-f36b-4b53-9f4f-e4a6e336f1e0.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d04cdee-f36b-4b53-9f4f-e4a6e336f1e0.png)'
- en: Our tooltip
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具提示
- en: The visual on the tooltip shows a sorted bar chart of all countries, forest
    cover percentage, and a red indicator of the hovered country’s place in the overall
    distribution.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 工具提示中的视觉显示了一个所有国家的排序条形图、森林覆盖率百分比，以及一个表示悬停国家在整体分布中位置的红色指示器。
- en: The HTML
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML
- en: 'It is simple, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，如下所示：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A tooltip wrapper `div`, a header with an `h1` for the country, and a `div`
    to hold the info. The following is a body with an SVG element to hold the bar
    chart. Note here that we add an HTML and SVG element to a Canvas, which is, of
    course, no problem. We could even draw SVG elements over the Canvas element or
    vice versa.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工具提示包装器`div`，一个带有`h1`标题的国家头部，以及一个`div`来存放信息。以下是一个包含用于存放条形图的SVG元素的正文。注意，我们在画布上添加了HTML和SVG元素，这当然没问题。我们甚至可以在画布元素上绘制SVG元素，反之亦然。
- en: Building the static parts of the tooltip
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建工具提示的静态部分
- en: 'Next, we will build the tooltip. To be precise, we will build the *static*
    part of the tooltip, that is, the bar chart. We will add the changing parts such
    as the header information and the red indicator as soon as we hover over the country.
    First, we twist the data into the right shape, and then we build a simple bar
    chart:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建工具提示。更准确地说，我们将构建工具提示的*静态*部分，即条形图。我们将添加在悬停国家时立即出现的可变部分，如标题信息和红色指示器。首先，我们将数据扭曲成正确的形状，然后构建一个简单的条形图：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The data we pass into this function is—you guessed it—our forestry-boosted
    countries'' GeoJSON. `forestsByPercent` is just a sorted array of objects holding
    the data we need for the bar chart. `countryList` is just an array of (also sorted)
    `countries` we will use as an extension to our ordinal scale. The following is
    the resulting bar chart:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给这个函数的数据是——正如你所猜到的——我们的林业增强国家的GeoJSON。`forestsByPercent`只是一个包含我们需要的用于条形图数据的对象的排序数组。`countryList`只是一个（也排序的）`countries`数组，我们将将其用作我们的序数刻度的扩展。以下就是生成的条形图：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That was simple. By the way, we build all our interactive tooltip functions
    in the `ready()` function. This way, we have access to all the data we need and
    have it all nicely cordoned off from any outside JavaScript scopes. In real life,
    it might be worth considering outsourcing interactivity to its own module to keep
    concerns separate.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。顺便说一下，我们在`ready()`函数中构建了我们所有的交互式工具提示函数。这样，我们可以访问我们需要的所有数据，并且将它们很好地隔离在任何外部JavaScript作用域之外。在现实生活中，可能值得考虑将交互性外包给其自己的模块，以保持关注点的分离。
- en: We call this `buildTooltip()` function in `ready()` after defining an `svg`
    variable we can address from the other two tooltip functions, `tooltipShow()`
    and `tooltipHide()` which we will build next.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在定义了一个可以从其他两个工具提示函数`tooltipShow()`和`tooltipHide()`中访问的`svg`变量后，在`ready()`函数中调用这个`buildTooltip()`函数，这两个函数我们将在后面构建。
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Showing and hiding the tooltip
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示和隐藏工具提示
- en: 'We need a small chunk of logic to tell our app when to show and when to hide
    the tooltip. With SVG, this logic is usually straightforward, as we can leverage
    mouseover and mouseout. With Canvas, we only really have mousemove on the entire
    Canvas. So, we build our own mouseover and mouseout logic. We start in the mousemove
    handler called `highlightPicking()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个小的逻辑块来告诉我们的应用程序何时显示工具提示，何时隐藏工具提示。使用SVG，这个逻辑通常很简单，因为我们可以利用mouseover和mouseout。使用Canvas，我们实际上只有整个Canvas上的mousemove。因此，我们构建了自己的mouseover和mouseout逻辑。我们从名为`highlightPicking()`的mousemove处理程序开始：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You store the data of the country the mouse is over in `country.` If `selected`
    holds a number (a country index), we trigger the creatively named function `showTooltip()`
    and pass it the main Canvas’s mouse positions and the country. If `selected` returns
    `false`, the mouse is not over a country, and we will trigger the equally creatively
    named function `hideTooltip()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将鼠标悬停的国家的数据存储在`country.`中。如果`selected`包含一个数字（一个国家索引），我们将触发名为`showTooltip()`的创意函数，并传递主画布的鼠标位置和国家。如果`selected`返回`false`，则鼠标没有悬停在某个国家上，我们将触发同样具有创意的函数`hideTooltip()`。
- en: The key thing you want to figure out in `showTooltip()` is when to build a new
    tooltip and when to just move the existing tooltip. You want to build a new tooltip
    when the mouse moves from one country to another country. You just want to move
    the tooltip along with the mouse when the mouse is within the borders of a specific
    country.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`showTooltip()`中，你需要弄清楚何时构建一个新的工具提示，何时只是移动现有的工具提示。当鼠标从一个国家移动到另一个国家时，你想要构建一个新的工具提示。当鼠标在特定国家的边界内时，你只想将工具提示随鼠标移动。
- en: We will achieve this by an array that will work like a **queue**. You can imagine
    a stack to stand up vertically, able to only add new data to the top or remove
    data from the top. In contrast, you can imagine a queue horizontally like a queue
    in front of an ice-cream shop. People arrive in the queue at the back and leave
    the queue at the front.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个像**队列**一样工作的数组来实现这一点。你可以想象一个堆栈垂直站立，只能将新数据添加到顶部或从顶部移除数据。相比之下，你可以想象一个像冰淇淋店前排队一样水平的队列。人们从队列的后面到达，从队列的前面离开。
- en: Our queue will, however, only be two-people long. In fact, it won’t be two people
    long but two countries long. Whenever we move the mouse, the queue will be fed
    the country we’re over to one side of it (the front actually), immediately pushing
    off the country at the other side (the back). When we’re moving from one spot
    in the US to another spot in the US, it will say `[“United States of America”,
    “United States of America”]`. As soon as our mouse moves effortlessly over to
    Mexico, it will add `“Mexico”` at the front of the queue, pushing the previously
    *0*-indexed `“United States of America”` to index position *1* and cutting off
    the array right there. Now, we have an array with `[“Mexico”, “United States of
    America”]`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的队列将只有两个人长。实际上，它不会是两个人长，而是两个国家长。每次我们移动鼠标，队列都会将我们所在的国家的名字添加到队列的一侧（实际上是在前面），立即将另一侧（在后面）的国家推出。当我们从美国的一个地方移动到另一个地方时，它会说`[“United
    States of America”, “United States of America”]`。一旦我们的鼠标轻松地移动到墨西哥，它就会在队列的前面添加`“Mexico”`，将之前`0`索引的`“United
    States of America”`推到索引位置`1`，并在那里切断数组。现在，我们有一个包含`[“Mexico”, “United States of
    America”]`的数组。
- en: Checking whether we change a country is now a simple affair of comparing the
    two values in our queue. If they are the same, we just move the mouse; if they
    are different, we create a new tooltip for Mexico.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查我们是否更改了国家变得简单，只需比较队列中的两个值。如果它们相同，我们只需移动鼠标；如果不同，我们为墨西哥创建一个新的工具提示。
- en: 'This is a textbook example of why SVG or HTML is often preferred over Canvas
    when the application is interaction heavy. Still, that wasn’t too bad, was it?
    Let’s implement it. First, you will need to define your yet-empty queue:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在应用程序交互频繁时，SVG或HTML通常比Canvas更受欢迎的典型例子。尽管如此，这并不太糟糕，对吧？让我们来实现它。首先，你需要定义你的空队列：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, you need to write `showTooltip()`, taking in the mouse positions and
    the element, that is, the country the mouse is over:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要编写`showTooltip()`函数，它接受鼠标位置和元素，即鼠标所在的那个国家：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You save the country’s data in `countryProps`, add the country’s name to the
    front of the queue with JavaScript’s own `.unshift()` method, and `pop()` off
    the last value from the queue.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你将国家的数据保存在`countryProps`中，使用JavaScript的`.unshift()`方法将国家的名字添加到队列的前面，然后使用`pop()`方法从队列中移除最后一个值。
- en: 'Then, we will establish if there is a country change or not:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将确定是否有国家变更：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If there is one, you fill the tooltip’s header with the country-specific information.
    You also color all bars according to the appropriate country color before the
    bar of this specific country gets colored red. The rest is just moving the tip
    along with the mouse and cranking its opacity up to make it visible.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有，你将工具提示的标题填充上特定国家的信息。在为这个特定国家的条形图着色红色之前，你也会根据适当的颜色为所有条形图着色。其余的只是随着鼠标移动移动提示，并提高其透明度以使其可见。
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Remember, `showTooltip()` gets shown every time the mouse is over a country,
    and our selected variable gets filled with a country index. If `selected` is false,
    we know we’re not over a country, meaning that we want to remove our tooltip.
    We do this with, well, `hideTooltip():`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`showTooltip()`每次鼠标悬停在某个国家上时都会显示，并且我们的`selected`变量会填充一个国家索引。如果`selected`为假，我们知道我们不在国家上，这意味着我们想要移除我们的工具提示。我们用`hideTooltip()`来做这件事：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We decided to appropriately allocate `undefined` to the queue if we’re not over
    a country, so we `unshift()` it to the front of the queue and `pop()` off the
    last value of the array to always keep it in pairs we can compare at the next
    move. Finally, we will transition the opacity back to zero and it is gone again.
    That’s it! All done.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定，如果我们不在一个国家上，就适当地将`undefined`分配给队列，所以我们将其`unshift()`到队列的前面，并`pop()`掉数组的最后一个值，以确保我们总是可以比较下一移动的成对数据。最后，我们将透明度过渡回零，它又消失了。就是这样！全部完成。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have officially seen and used Canvas. You’ve reveled in its shining moments
    and mastered its quirks. You have started with a royal blue rectangle and have
    now successfully built a whole world, which you can spin, resize as desired, and
    retrieve country-specific information from. On the way, you have also seen how
    Canvas works in comparison to SVG. You have learned about the benefits and issues
    when coding a little closer to the graphics processing part of your machine.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经正式看到并使用了Canvas。你享受了它的辉煌时刻，掌握了它的怪癖。你从一个皇家蓝色的矩形开始，现在已经成功地构建了一个整个世界，你可以旋转它，按需调整大小，并检索特定国家的信息。在这个过程中，你也看到了Canvas与SVG相比的工作方式。你了解了在接近机器图形处理部分编码时的好处和问题。
- en: The idea of these chapters has, of course, been to extend your technical skill
    set. However, beyond that, it’s the alternative concept of how to approach Canvas—the
    procedural style, the game loop routine, and the way Canvas interacts with D3—that
    broadens your horizon as a developer and allows for a different perspective to
    tackle problems.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些章节的目的是扩展你的技术技能集。然而，除此之外，它还提出了如何接近Canvas的替代概念——过程式风格、游戏循环常规以及Canvas与D3交互的方式——这些内容拓宽了作为开发者的视野，并允许从不同的角度来解决问题。
