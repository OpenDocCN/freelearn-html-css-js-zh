- en: Adding Interactivity to Your Canvas Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding chapter, you saw one of the shining qualities of Canvas in
    action – animating thousands of points on the screen in a smooth animation. In
    this chapter, you will deal with one Canvas caveat: interaction. While interaction
    with HTML or SVG elements is straightforward, it requires a little more thought
    and some tricks to achieve with Canvas. In this chapter, you will follow along
    these thoughts and learn the tricks needed to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a globe move, and adding zoom and rotation interaction to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to interact with Canvas elements through **picking**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from a Canvas element to display it in a tooltip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter, you will have covered all important facets of Canvas, drawing,
    animating, and, finally, interacting with Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Why Canvas interaction is different
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, you achieved a smooth animation of thousands of points
    by doing away with the DOM. The DOM is a representation of each element in browser
    memory. Bypassing it, you were dealing with much less overhead during animation.
    However, the DOM can be very useful for other goals in web development. High up
    on that list – especially for data visualization – is the **interaction** with
    elements on screen.
  prefs: []
  type: TYPE_NORMAL
- en: You can just add an `onmousemove` or `onclick` listener to an element. You can’t
    do that to elements on a Canvas. They are a pixel manifestation of past code,
    not represented as a model within the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, don’t despair, there are indirect yet simple techniques to interact
    with your Canvas. We’ll be looking at the most important techniques in this chapter,
    building an interactive globe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56ecc99f-4a88-4175-9571-e33a954922e0.png)'
  prefs: []
  type: TYPE_IMG
- en: A map of the world’s forest cover by country
  prefs: []
  type: TYPE_NORMAL
- en: Leaving flying planes behind, you will build a globe showing each country's
    forest cover percentage. The greener a country is (you guessed it), the higher
    the forest cover. As you can see in the preceding figure, you will have a tooltip
    showing country-specific information when hovering over each country. Users will
    further be able to rotate the globe and zoom into specific areas at their leisure.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the final app at [https://larsvers.github.io/learning-d3-mapping-10-4](https://larsvers.github.io/learning-d3-mapping-10-4)
    and a c[ode example at](https://larsvers.github.io/learning-d3-mapping-10-4) [10_04.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html).
  prefs: []
  type: TYPE_NORMAL
- en: At the conclusion of each step, you will find two links in an info box close
    to the relevant image. The first link brings you to a working implementation of
    this step that you can view in the browser. The second *code example* link brings
    you to the full code. If you're reading the print version, you can find all code
    examples at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)
    in their relevant chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the world on a Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start drawing a globe. This is straightforward, very much building on
    the preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you will create a few variables required for initialization. We’ll come
    back to this list as the application grows, but, for now, it’s lean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You are setting the `width` and `height` of the Canvas as well as the scale
    and the translation of the globe. Each projection has their own ideal starting
    scale. You can play with this number to find the right scale. You will use the
    `width` and `height` straight away, setting up the Canvas and its context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: No magic here. Note that we have a `div` with the `#canvas-container` ID in
    our HTML, in which you add the main Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also produce a `bufferCanvas`. You learned about the benefits of buffer
    Canvases in the preceding chapter. In short, rendering an image in memory and
    copying it onto your main Canvas is more performant than rendering an image directly
    onto the main Canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A rather central part of building a globe is the right projection. Building
    a globe reduces our options dramatically to the `d3.geoOrthographic()` projection,
    a 2D globe projection which is part of the standard d3-geo module. You already
    used it in [chapter 5](d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml), *Click-Click
    Boom! Applying Interactivity to Your Map*. Let''s set it up first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We applied the scale and translation array we specified above, as well as the
    `.clipAngle()` to 90 degrees to always clip the backside of the projection, our
    globe.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we use the `bufferCanvas` for all our drawings, we will tie our projection
    to a path generator that will exclusively draw to the buffer Canvas , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two more geo helpers you will create: a base **sphere** and a **graticule**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Both are geo-visualization primitives. The **sphere** is, well, a sphere you
    use to underlay your globe with. You can then fill it or give it an outline to
    give your globe a round shape beyond the countries. A **graticule** is a grid
    of the main meridians (longitude lines) and parallels (latitude lines) 10 degrees
    apart from each other (and, yes, you need four parentheses to produce the actual
    graticule object). We shall see them in action very soon.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The scene is set. In this section, you will load some country shape data to
    draw the world. You will set up four small functions to achieve the draw:'
  prefs: []
  type: TYPE_NORMAL
- en: A `data load` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ready()` function that prepares the data and passes it on to the render function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `renderScene()` function that kicks off the world draw and copies the final
    image from the buffer onto the main Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `drawScene()` function that renders the world onto the `bufferCanvas`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This might sound overkill for just drawing a static globe, and let me assure
    you it is. However, we are aiming for higher goals, which will be greatly helped
    by having this structure set up already.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data load function just requests the data and passes it on to the `ready()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ready()` function doesn’t really add much more complexity so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns the TopoJSON to an array of GeoJSON `countries` and calls `renderScene()`.
    `renderScene()` does what we’ve already described in the preceding code. It draws
    the globe on the `bufferContext` in thin air, and as soon as it’s done, copies
    it over to the freshly cleared main Canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `drawScene()` is our longest function, it’s not very complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It clears the `buffer` context, then draws a base sphere in a light blue and
    a graticule grid in a slightly more saturated blue. It then fills the countries
    in a light gray color and strokes each country in a darker gray. That’s it. Here’s
    your very own Canvas globe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6915f37c-f7cf-4031-9c94-d8b518d15d60.png)'
  prefs: []
  type: TYPE_IMG
- en: A static Canvas globe
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-10-1](https://larsvers.github.io/learning-d3-mapping-10-1)
    and a code example at [10_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_01.html).
  prefs: []
  type: TYPE_NORMAL
- en: Great! You learned to draw a Canvas globe, which is nice, even if a little mono-dimensional.
    So, let’s add our first bit of interaction with it and let the users (and ourselves)
    zoom and rotate the globe.
  prefs: []
  type: TYPE_NORMAL
- en: Making the world move
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zooming into and rotating a globe projection is a truly joyous pastime, I find.
    Apart from being such fun, it’s also extremely useful when dealing with globe
    projections, as the user needs to be able to view the world from different angles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will add our first bit of Canvas interactivity to the globe.
    We will equip the users with the ability to zoom into and rotate the globe. Apart
    from setting up two additional global variables, we will exclusively do work in
    the `ready()` function–our central function tasked to prepare the data. From now
    onward, it will also deal with interactivity, right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Also, note that we wrapped our `renderScene()` function into a `requestAnimationFrame()`
    function to always let the browser decide the best time point for a new render.
  prefs: []
  type: TYPE_NORMAL
- en: Note, that here is a prominent and often preferred way to deal with zooming
    and panning (not so much rotating) in D3 using `context.scale()` and `context.translate()`.
    However, to implement both zooming and rotating, we won’t use these in-built methods,
    but will change the projection instead. We’ll get back to the why a little later
    as it becomes clear on the way.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zooming is no more than changing the scale for our projection. Rotating is
    no more than changing the rotation values of our projection. When you want the
    user to mandate zoom and rotation, you will need to listen to their mouse movement.
    As such, you will need to set up a zoom listener to track the user''s mouse wheel
    and drag moves, and attach it to the Canvas. We implemented zoom and rotation
    already in [chapter 5](d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml), *Click-Click
    Boom! Applying Interactivity to Your Map*. In our `ready()` function, as specified
    above, we will use D3’s zoom behavior to deliver all the user interaction changes
    we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, you create the zoom behavior with `d3.zoom()`, define scaling bounds
    between *0.5* and *4*, and inform the behavior to trigger our `zoomed()` handler
    as soon as a `“zoom”` event has been triggered. However, so far, this has been
    a blunt tool. To understand what it does, you have to call it on an element. Call
    it on your Canvas element, and that element will be the sensor of all zoom-related
    user events. Importantly, it will listen for mouse wheel and drag events and expose
    the event information in the global `d3.event` object. It will further store the
    information in the base element it got called on (in our case, the main Canvas),
    but we’ll be happily served by the `d3.event` object you can tap into at each
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we want to set up some variables for tracking our scale and rotation
    whereabouts during zoom. We do this at the very top of our code with the following
    global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The newcomers in the preceding code are `origProjectionScale`, `projectionScaleChange`,
    `prevTransformScale`, and `rotation`. Their mission will become clear in the following
    paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Handling zoom and rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We set up the zoom behavior, meaning that our Canvas is
  prefs: []
  type: TYPE_NORMAL
- en: listening on every mouse wheel and drag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: firing the `zoomed()` handler on each of these events
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s now fill our handler to do something to the globe.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we want to do? From a bird’s perspective, for each zoom, we want to
    establish the scale for the projection, apply it to the path, and redraw the globe
    a little bit bigger or a little smaller. For each drag, we would want to establish
    the new rotation values, apply them to the projection and path, and redraw the
    globe a little bit rotated. To get there, the handler should distinguish between
    a zoom and a drag. A zoom should lead to a projection-scale change and a drag
    should lead to a rotation change. For each path, you calculate the position change.
    Once that’s done, you will need to redraw the globe. It’s the game-loop mantra:
    process user-input, clear the Canvas, then redraw the Canvas with updated data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the zoom action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At first, we will need to distinguish between a zoom and a drag event. D3 makes
    this easy for us with the `d3.event` object holding a `sourceEvent` property specifying
    what event `type` the user triggers. If it’s a `wheel` event, we change the scale
    if it's a `mousemove` event, we change the rotation. Simple.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the scale looks involved but is pretty straightforward. Before we dive
    into the code, let’s make one important distinction. The projection has a scale,
    and the transformation upon user zoom also has a scale. However, they are different.
    Projection scales differ between projections. Our `d3.geoOrthographic()` projection
    has an initial scale of around *286* (we set it to *height / 2.1 = 286*). Our
    transformation has an initial scale of *1*. That’s the default.
  prefs: []
  type: TYPE_NORMAL
- en: So, you retrieve the current `transformScale` via `d3.transform.k`. You note
    down the change of this scale to the previous transform scale, which can be negative
    for zoom in or positive for zoom out. However, as your projection scale is quite
    a big number (as in *286* to start with) and the transform scale change per zoom
    will be small (for a normal mouse wheel turn the change might be around *0.005*),
    you will want to boost this number up to get a noticeable change in your projection.
    Hence, you will multiply it with a larger number. You can choose any large number
    you like, but choosing your initial projection scale we called `origProjectionScale`
    allows you to port this calculation over to any other projection, and it should
    work nicely. You then just change the current `projectionScale` by this `projectionScaleChange.`
  prefs: []
  type: TYPE_NORMAL
- en: The rest is simple. Just apply it to your globe’s projection with `projection.scale(projectionScale)`,
    set the previous transform scale to the updated transform scale, and re-render
    the globe. Note, that you don’t need to update the path generator, as whenever
    it’s called, it will use the projection as is at the moment of being called, which
    we’ve changed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was the hard bit. Rotating is even simpler. You just need to track the
    changes in the user’s mouse movements and apply them to D3’s `projection.rotate()`
    parameters. Let’s track the change in mouse coordinates right at the top of the
    `zoomed()` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note, that the two `MouseEvent` properties `.movementX` and `.movementY` are
    not available in Safari or Internet Explorer. You can see a cross-browser implementation,
    which is calculating the two values on the fly in code example [10_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html#L237)
    at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping).
  prefs: []
  type: TYPE_NORMAL
- en: 'The rotation logic will trigger when the user drags or rather triggers the
    `mousemove` event, which goes into the `else if` part of our conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first retrieve the current rotation values from the
    projection in the variable `r`. Then, you change the `r[0]`, the yaw value (responsible
    for rotating the world around its normal or vertical axis) by the *x* change of
    the mouse coordinates. You further change `r[1]`, the roll value (rotating the
    world around its lateral axis, going horizontally from left to right) by the y
    change of the mouse coordinates. We leave the third pitch value as is, and yes,
    the best way is to throttle these values to a reasonable speed of rotation with
    `dx * 0.4` and `dy * 0.5`, respectively. Note that this is the straightforward
    but naive way to rotate the globe. It will fully do in our case. If you want to
    apply utmost precision, you could use **versor** dragging (check out [http://tiny.cc/versor](http://tiny.cc/versor)).
    The key difference is that versor dragging rotates the globe in the right direction
    even when it's upside down.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it for rotation. Remember, the world gets re-rendered after this conditional
    as we do this in the following Canvas game loop: get user input – calculate the
    new position – re-render.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a static attempt to show dynamic zooming and rotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed98d35d-88fb-4cf9-bf78-115e400d2056.png)'
  prefs: []
  type: TYPE_IMG
- en: Zooming and rotating a Canvas globe
  prefs: []
  type: TYPE_NORMAL
- en: View the step shown in the preceding screenshot in the browser at [https://larsvers.github.io/learning-d3-mapping-10-2](https://larsvers.github.io/learning-d3-mapping-10-2)
    and its code example at [10_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html).
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of zooming via a projection change is that it allows rotating
    (that’s a win) and guarantees **semantic zooming** of the world rather than **geometric
    zooming**. When you zoom into a Canvas object with `context.scale()`, it naively
    enlarges anything that’s on the Canvas. So, a country border, for example, gets
    wider and wider, the more you scale it. That’s **geometric zooming**. We, however,
    want to keep everything constant, apart from the area of the individual country
    polygons. This is called **semantic zooming**. Another benefit of the **projection
    change** is that getting the coordinate of a Canvas object by mouse-over is more
    straightforward. This is our next stop.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Canvas object under the mouse - Picking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve done zooming and rotating. Let’s celebrate by adding another key piece
    of interactivity: the mouseover. In fact, we don’t want just any mouseover. We
    want to mouse over an object drawn on the Canvas and retrieve information from
    that object. Once we have that, we have a lot—we can create tooltips, we can highlight
    the object, we can link views with another graph showing the same data point,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Picking, the theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how are we doing this? As established many times above, we can’t just add
    a listener to a set of pixels, because an event is an object maintained by the
    browser, interacting with DOM nodes. However, our browser doesn’t know about the
    pixel. It doesn’t have a representation of the Canvas pixels it wants to interact
    with. So, how?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is relatively simple: we build it ourselves. Not the DOM, that would
    be madness, but a representation of our Canvas drawing in which the target object’s
    pixel are charged with this object’s information.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what do we need to build our own little visual object representation? In
    short, you will build two Canvases. One **main Canvas** that produces our visual
    (done already) and one **hidden Canvas** (as in you can’t see it) that produces
    the same visual. The key here is that all elements on the second Canvas will be
    at the same position in relation to the Canvas origin compared to the first Canvas.
    We will bend this rule a little in practice, but, for now, imagine that the northern
    tip of Scotland is at pixel position *250, 100* of the main Canvas and that it
    is also at *250, 100* of the hidden Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one key difference between the main and the hidden Canvas. Each
    element on the hidden Canvas will get a **unique color**. What’s more, these color
    values will be indexes to look up our data values. In our case, we will assign
    *rgb(0,0,0)* to the first country in our country list: Afghanistan. Our second
    country will get the color value *rgb(1,0,0)* and so on until our last country–Zimbabwe–will
    get the color value *rgb(176,0,0)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Why? Because, next, we will attach a mousemove listener to the main Canvas to
    retrieve a flow of mouse positions as we move the mouse. At each mouse position,
    we can use the Canvas's own method `context.getImageData()` to pick the color
    of the pixel at this exact position. We just extract the R value from our RGB
    color and can query our data array to get the object we need.
  prefs: []
  type: TYPE_NORMAL
- en: Our itinerary is clear and, with three steps, relatively short. First, we will
    create the hidden Canvas. Secondly, we will draw the world with a unique color
    per country. Finally, we will write the mousemove handler to pick the color and
    get the data. Lastly, we have to decide what to do with all that data we can access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let’s make sure that we actually have some data for each country.
    Here’s our GeoJSON country object that shows the contents of the first two of
    177 countries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51458214-8499-4fd2-87cf-988d935ffcd7.png)'
  prefs: []
  type: TYPE_IMG
- en: The data properties of the country’s array
  prefs: []
  type: TYPE_NORMAL
- en: 'Our GeoJSON world is a `FeatureCollection` with one feature per country, ascendingly
    sorted by country name. Each feature is an object holding a `type` property, the
    `geometry` for the country polygon, and a property called `properties`. In here,
    we have three data points: the country abbreviation, the country name, and even
    an estimate of the country’s population. Now, let’s get to that data by mouse
    over.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating all things hidden
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, you’ve set up so many Canvases that, at worst, this code just bores
    you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only thing we want to make sure of here is to apply the same width and height
    that we applied to the main Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will draw the world to it. In order to do so, we have to build a projection
    and path generator and then loop through all countries to draw each country to
    the Canvas; let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We, of course, need a new path generator, as we need to feed our now hidden
    drawing context to the `.context()` method. However–hold on–we already have a
    projection for the main Canvas. Shouldn’t we use it for the hidden Canvas also?
    Especially, as we said above that ideally the objects on our hidden Canvas should
    be in the exact same position as the objects on our main Canvas to query the hidden
    positions easily? However, here, we use an **equi-rectangular** projection, which
    will draw the world in a rather different way to our **orthographic** projection
    on the main Canvas. Don’t we need the same projection to produce the same globe?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no, we don’t need the same projection. When our mouse is on a
    specific position on the main Canvas, we just need to find the same position on
    the hidden Canvas. No doubt, the easiest way to do this is to use the exact same
    coordinates. However, we can also use the main projection’s `projection.invert([x,y])`
    function to retrieve this position’s longitude and latitude values. We will then
    use the hidden projection to convert the geo-coordinates to pixel coordinates
    on the hidden Canvas. Long-winded? Yes, a little. However, with a moving object
    such as a zooming and rotating globe, this saves us from re-drawing the hidden
    Canvas. We shall see this in action very soon when we build the handler in the
    third step.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s draw the hidden Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the hidden Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s just a single simple function that does what you need in this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The only argument—`world`—is our GeoJSON feature collection. `countries` pulls
    out just the array of country information, including the polygons and the additional
    data we’re after. We loop through all of them, drawing each country with the `hiddenContext`
    and — most importantly—we gave each country a color using the `rgb(<country index>,
    0, 0)` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Here we have it! A graph-like structure of our Canvas visual, representing our
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, it’s only a function, so let’s invoke it. We only need to call `drawHiddenCanvas()`
    once whenever we have the data available. So, we venture to the `ready()` function
    and invoke it right after we draw the main Canvas with `renderScene()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here they are; our two worlds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b95c2f-20ad-4338-8e97-53477c1ec9f7.png)'
  prefs: []
  type: TYPE_IMG
- en: The main and the hidden Canvas
  prefs: []
  type: TYPE_NORMAL
- en: 'Each country has a slightly different color, ranging from black to red or from
    *rgb(0,0,0)* = *Afghanistan* to *rbg(176,0,0) = Zimbabwe*. You can see how countries
    that start high up in the alphabet—Antarctica, Australia, Brasil, or Canada—are
    much darker than countries that are low down in the alphabet—the United States
    or Russia. Note that we’ll keep our hidden Canvas visible for demonstration purposes,
    but, in production, we can just add the CSS rule `{ display: hidden }` to hide
    our Canvas. No one needs to know about our little trick.'
  prefs: []
  type: TYPE_NORMAL
- en: Picking the values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you have all tools at hands to implement a hover. Now, you will
    need to make it happen. To wire it all up, you need to do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Listen to mousemoves on the main Canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Translate these coordinates to positions on the hidden Canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the color from that position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strip out the color value that represents the data array index for your data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lean back and think of ways to use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Listening on mousemove is easy; you just need to perform the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Done. The first thing we will do in `highlightPicking()` is translate the mouse
    position on the main Canvas to the coordinates on the hidden Canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We first get the *x, y* mouse coordinates. This will be updated whenever we
    move the mouse. An example value of the `pos` variable is *[488, 85]*, which is
    in the north of France. We use D3’s own `projection.invert()` which is the inverse
    of `projection()`. What does `projection()` do? It takes an array of [longitude,
    latitude] values and returns a pair of [x, y] pixel coordinates. Well, `projection.invert()`
    does the opposite. It takes a pixel coordinate array and returns the respective
    longitude and latitude array. In our case, that will be [2.44, 48.81]. The longitude
    is a bit further right of *0*, which is Greenwich, so yes, that seems right. Note,
    that this projection is our main Canvas projection. Next, we use our `hiddenProjection()`
    function to reproject our `longlat` values to the pixel coordinates of this very
    place. In our example, `hiddenPos` gets the pixel coordinates [485.83, 183.17]
    assigned to it. That’s the very same spot in the north of France on the hidden
    Canvas! Exactly what we were after.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, take a look at the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b5b3bee-eb0d-421b-bf5c-ece23935491a.png)'
  prefs: []
  type: TYPE_IMG
- en: Translating the main Canvas mouse coordinates to the hidden Canvas coordinates
  prefs: []
  type: TYPE_NORMAL
- en: Our mouse position on the upper main Canvas represented by `pos` gets translated
    to the lower orange circle represented by the `hiddenPos` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we finally get to pick that color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a special array with the unwieldy name `Uint8ClampedArray` representing
    the R, the G, the B, and the alpha value (peculiarly also ranging from *0* to
    *255*) at exactly that pixel. In our case, for example, for France (the left most
    pick in the preceding screenshot), the color is `52`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82452b63-cb05-49c3-bce9-aa1860dde291.png)'
  prefs: []
  type: TYPE_IMG
- en: The picked color array
  prefs: []
  type: TYPE_NORMAL
- en: Cross-checking with our `countries` array, we can confirm that the array element
    with the index `52` is **France**.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we will build in two security checks before we can be sure of hovering
    over a country. First, you will check whether the user’s mouse is on the globe
    and not somewhere in the outer space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In an ideal world, for our purpose, `projection.invert(pos)` above would return
    `undefined` or similar when we move beyond the globe; however, it still returns
    actual pixel coordinates, which is not what we want. The problem is that `projection.invert()`
    is not **bijective**, meaning it can in fact return the same *[long, lat]* coordinates
    for different pixel position inputs. This is especially the case when we move
    the mouse beyond the globe bounds. To alleviate this issue, we do a so called
    **forward projection** here. This just means that we project the inverse of our
    projection. We take in the pixel coordinates, translate them to *[long, lat]*
    values and project them back to pixel coordinates. If our mouse is within the
    globe, this will return our exact mouse position (in fact we give it a leeway
    of +/- 0.5 pixels here). If our mouse is outside the globe, the forward projection
    will deviate from our mouse position in pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second check we perform is to make sure that our mouse is over a country
    and not a country border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take this one by one. `selected` will hold the index. You will, however,
    only get the index if the user’s mouse is inside the globe (`inGlobe` === `true`).
    This is our first check. Secondly, the fourth element of our special `pickedColor`
    array has to be exactly *255*. Otherwise, selected will be false. This second
    check is to surpass **antialiasing** effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we need that? The problem with pixels in browsers is that they outsmart
    us. Lines are feathered at the edges to allow the impression of a smooth transition
    from line to background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e529dada-a2c0-4afb-a9f9-ef0b1f473653.png)'
  prefs: []
  type: TYPE_IMG
- en: An aliased line above an antialiased line
  prefs: []
  type: TYPE_NORMAL
- en: Picking values at these feathered edges would not return fully opaque colors,
    but transparent values of varying degree. These values have an alpha channel lower
    than 255, so checking for our alpha to be 255 allows us to pick only from aliased
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: Fabulous! We’ve built ourself a second Canvas that functions as a memory of
    the objects on our main data. Next, we’ll use it. The Canvas way of changing anything
    with our elements and objects is to pass the information to the redrawing part
    of our app to use it in there accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Storing more data and using a lookup array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are blessed with the fact that the world we visualize only has 176 countries.
    This way, we only need to keep track of 176 indeces. However, you often deal with
    more data objects so that 256 (as in 0-255) will be used up rather quickly. Luckily,
    we not only have R but also G and B values and their unique combinations, which
    gets us to *256*256*256 = 16,777,216* possible indeces you can store. That will
    bring you far.
  prefs: []
  type: TYPE_NORMAL
- en: Check the tutorial at [http://tiny.cc/d3-canvas](http://tiny.cc/d3-canvas) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the country on mouse over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever a country is picked, we just pass the selected variable through to
    our `drawScene()` function that draws the world at each mouseover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At the end of our highlight handler, we didn’t only pass the `countries` to
    our render function, we also sent our newly created `selected` on the way. The
    `renderScene()` function just passes it through to `drawScene()`, which draws
    the world to the `buffer` Canvas. Remember that `renderScene()` just calls `drawScene()`,
    then clears the main Canvas and copies the `buffer` image over to the main Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `drawCanvas()`, we will add a single block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the `selected` index via the `countryIndex` argument and check
    whether it''s larger or equal to *0* (remember, that would be *Afghanistan*).
    If so, we draw a dashed path around the country. How do we know which country?
    We access the right country via `countries.features[countryIndex]` and draw it
    accordingly. The mind boggles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d94adbe9-f76b-4d32-a236-72c2363a7d6f.png)'
  prefs: []
  type: TYPE_IMG
- en: A dashed line around the US, just because we picked the right color
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-10-3](https://larsvers.github.io/learning-d3-mapping-10-3)
    and the code example at [10_03.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_03.html).
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing data per country and adding a tooltip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned to build a data-driven and -giving representation of your visual.
    You have also used it to highlight the country at hover. However, you haven’t
    really tapped into the plentiful options of interaction this gives you. Let’s
    do this now. There’s a lot you could do, but I think a tooltip would be a reasonable
    place to start.
  prefs: []
  type: TYPE_NORMAL
- en: Before we embark on the tooltip build, let’s add some more interesting data
    to the globe. So far, we have **country name**, **country name abbreviation**,
    and **population estimate**. That’s already something to work with. However, let’s
    task ourselves with adding an additional data source to our globe, visualize it
    appropriately, and add a sensible interaction for user exploration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a little reminder, this is what you will build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7d07b70-2fa9-414f-ae6e-93ed530c9f35.png)'
  prefs: []
  type: TYPE_IMG
- en: Our final Canvas adventure
  prefs: []
  type: TYPE_NORMAL
- en: View the final app at [https://larsvers.github.io/learning-d3-mapping-10-4](https://larsvers.github.io/learning-d3-mapping-10-4)
    and the code example at [10_04.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows a globe visualization of forest cover per country.
    The data comes from the source of all solid wisdom, Wikipedia. The suggestion
    is to visualize it as a choropleth map. Arguably, choropleth maps have been overused
    in recent years, but they are nonetheless a great option to show percentage comparisons
    of geo-areas.
  prefs: []
  type: TYPE_NORMAL
- en: The data is from [https://en.wikipedia.org/wiki/List_of_countries_by_forest_area](https://en.wikipedia.org/wiki/List_of_countries_by_forest_area).
    The missing North Cyprus, Somaliland, and Haiti have been estimated.
  prefs: []
  type: TYPE_NORMAL
- en: The steps are relatively simple. First, we add our forest data to our GeoJSON
    world object. We’ll move on swiftly to color our countries according to the new
    data, and finally add a tooltip with HTML and SVG.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new data to our old globe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After copying and pasting or scraping the data from Wikipedia, you should save
    your forest file in a data format of your choice. We saved it in CSV, and as we
    now have several data sources to load for one visual, we will use `d3.queue()`
    to wait for both files to load before invoking `ready()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, adapt your `ready()` function arguments and start accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Leave the country data prep as is (in that we push the world’s country arrays
    into a variable called `countries`) and move on to including the forest data into
    the world. What we want is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c00718-1299-4794-b0a5-84855436574a.png)'
  prefs: []
  type: TYPE_IMG
- en: The updated data object we strive for
  prefs: []
  type: TYPE_NORMAL
- en: The properties we need for the coloring and the tooltip are country name (`admin`),
    `forest_percent`, and `forest_area`. Note, that we also have `forest_color` here.
    This is the choropleth color for that country. It’s often beneficial to have your
    data in place before the draw. Hefty calculations during redraw can slow down
    performance and re-render.
  prefs: []
  type: TYPE_NORMAL
- en: The forest CSV country names have been changed to match the exact naming of
    the countries GeoJSON. This way, you can use the names to join the two datasets.
    To join the data speedily, we will use **binary search**. Binary search leverages
    the sorted nature of our `countries` array to find a country match quickly. In
    short, it looks at the country name we want to find, and instead of looping through
    all countries in the GeoJSON, it splits the `countries` array in two halves and
    checks whether the search term is in the upper or the lower half. It does that
    repeatedly until it finds the term. This is much quicker than **linear search**
    (looping through all data); in our case, around 10 times faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement binary search in D3 with `d3.bisect()` and that’s what we
    shall use. We add the data with a function we call `insertForestDataBinary()`.
    We shall add this function call and the function to the data preparation flow
    in the `ready()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, you create a *bisector* function so that D3 knows which variable we want
    to find a name (`d.properties.admin`, the country name). You then iterate through
    all forest objects. Each forest object holds the `country` (the name we match),
    `forest_percent` and `forest_area` properties. The bisector will search the array
    and return the index after the matching `countries` object (or to the `.right`,
    as we specified above). Once you have that, you can add the new properties one
    index position before.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the last property, `forest_color`, you need to create a `colorScale` somewhere
    in higher scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Coloring the globe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that you have implemented all these changes before you draw the globe.
    That’s great as you can now simply draw it with the new color scheme. The only
    change is in our `drawScene()` function, filling the `countries` accordingly in
    a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, note that we adjusted the sphere fill and the graticule colors a little
    to work better with our yellow-green country color scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d09ac20e-fb0d-45f4-ab4a-a6a21dbdfceb.png)'
  prefs: []
  type: TYPE_IMG
- en: A choropleth globe visualizing forest cover ratio per country
  prefs: []
  type: TYPE_NORMAL
- en: Adding a tooltip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your globe is colored by forest cover. Yellow countries have a low percentage
    of cover; dark green a higher one. That’s already a good clue about how much forest
    there is proportionally in each country. However, a user might additionally be
    interested in how high the forest cover is exactly, and how this compares to other
    countries. You have all the data in your hands, so let’s not be stingy, and add
    the following tooltip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d04cdee-f36b-4b53-9f4f-e4a6e336f1e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Our tooltip
  prefs: []
  type: TYPE_NORMAL
- en: The visual on the tooltip shows a sorted bar chart of all countries, forest
    cover percentage, and a red indicator of the hovered country’s place in the overall
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A tooltip wrapper `div`, a header with an `h1` for the country, and a `div`
    to hold the info. The following is a body with an SVG element to hold the bar
    chart. Note here that we add an HTML and SVG element to a Canvas, which is, of
    course, no problem. We could even draw SVG elements over the Canvas element or
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Building the static parts of the tooltip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will build the tooltip. To be precise, we will build the *static*
    part of the tooltip, that is, the bar chart. We will add the changing parts such
    as the header information and the red indicator as soon as we hover over the country.
    First, we twist the data into the right shape, and then we build a simple bar
    chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The data we pass into this function is—you guessed it—our forestry-boosted
    countries'' GeoJSON. `forestsByPercent` is just a sorted array of objects holding
    the data we need for the bar chart. `countryList` is just an array of (also sorted)
    `countries` we will use as an extension to our ordinal scale. The following is
    the resulting bar chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That was simple. By the way, we build all our interactive tooltip functions
    in the `ready()` function. This way, we have access to all the data we need and
    have it all nicely cordoned off from any outside JavaScript scopes. In real life,
    it might be worth considering outsourcing interactivity to its own module to keep
    concerns separate.
  prefs: []
  type: TYPE_NORMAL
- en: We call this `buildTooltip()` function in `ready()` after defining an `svg`
    variable we can address from the other two tooltip functions, `tooltipShow()`
    and `tooltipHide()` which we will build next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Showing and hiding the tooltip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a small chunk of logic to tell our app when to show and when to hide
    the tooltip. With SVG, this logic is usually straightforward, as we can leverage
    mouseover and mouseout. With Canvas, we only really have mousemove on the entire
    Canvas. So, we build our own mouseover and mouseout logic. We start in the mousemove
    handler called `highlightPicking()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You store the data of the country the mouse is over in `country.` If `selected`
    holds a number (a country index), we trigger the creatively named function `showTooltip()`
    and pass it the main Canvas’s mouse positions and the country. If `selected` returns
    `false`, the mouse is not over a country, and we will trigger the equally creatively
    named function `hideTooltip()`.
  prefs: []
  type: TYPE_NORMAL
- en: The key thing you want to figure out in `showTooltip()` is when to build a new
    tooltip and when to just move the existing tooltip. You want to build a new tooltip
    when the mouse moves from one country to another country. You just want to move
    the tooltip along with the mouse when the mouse is within the borders of a specific
    country.
  prefs: []
  type: TYPE_NORMAL
- en: We will achieve this by an array that will work like a **queue**. You can imagine
    a stack to stand up vertically, able to only add new data to the top or remove
    data from the top. In contrast, you can imagine a queue horizontally like a queue
    in front of an ice-cream shop. People arrive in the queue at the back and leave
    the queue at the front.
  prefs: []
  type: TYPE_NORMAL
- en: Our queue will, however, only be two-people long. In fact, it won’t be two people
    long but two countries long. Whenever we move the mouse, the queue will be fed
    the country we’re over to one side of it (the front actually), immediately pushing
    off the country at the other side (the back). When we’re moving from one spot
    in the US to another spot in the US, it will say `[“United States of America”,
    “United States of America”]`. As soon as our mouse moves effortlessly over to
    Mexico, it will add `“Mexico”` at the front of the queue, pushing the previously
    *0*-indexed `“United States of America”` to index position *1* and cutting off
    the array right there. Now, we have an array with `[“Mexico”, “United States of
    America”]`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether we change a country is now a simple affair of comparing the
    two values in our queue. If they are the same, we just move the mouse; if they
    are different, we create a new tooltip for Mexico.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a textbook example of why SVG or HTML is often preferred over Canvas
    when the application is interaction heavy. Still, that wasn’t too bad, was it?
    Let’s implement it. First, you will need to define your yet-empty queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to write `showTooltip()`, taking in the mouse positions and
    the element, that is, the country the mouse is over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You save the country’s data in `countryProps`, add the country’s name to the
    front of the queue with JavaScript’s own `.unshift()` method, and `pop()` off
    the last value from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will establish if there is a country change or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If there is one, you fill the tooltip’s header with the country-specific information.
    You also color all bars according to the appropriate country color before the
    bar of this specific country gets colored red. The rest is just moving the tip
    along with the mouse and cranking its opacity up to make it visible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Remember, `showTooltip()` gets shown every time the mouse is over a country,
    and our selected variable gets filled with a country index. If `selected` is false,
    we know we’re not over a country, meaning that we want to remove our tooltip.
    We do this with, well, `hideTooltip():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We decided to appropriately allocate `undefined` to the queue if we’re not over
    a country, so we `unshift()` it to the front of the queue and `pop()` off the
    last value of the array to always keep it in pairs we can compare at the next
    move. Finally, we will transition the opacity back to zero and it is gone again.
    That’s it! All done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have officially seen and used Canvas. You’ve reveled in its shining moments
    and mastered its quirks. You have started with a royal blue rectangle and have
    now successfully built a whole world, which you can spin, resize as desired, and
    retrieve country-specific information from. On the way, you have also seen how
    Canvas works in comparison to SVG. You have learned about the benefits and issues
    when coding a little closer to the graphics processing part of your machine.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of these chapters has, of course, been to extend your technical skill
    set. However, beyond that, it’s the alternative concept of how to approach Canvas—the
    procedural style, the game loop routine, and the way Canvas interacts with D3—that
    broadens your horizon as a developer and allows for a different perspective to
    tackle problems.
  prefs: []
  type: TYPE_NORMAL
