["```js\nko.bindingHandlers.yourBindingName = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // This will be called when the binding is first applied\n        // Set up any initial state, event handlers, etc. here\n    },\n    update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // This will be called once when the binding is first applied\n        // and again whenever dependant observables change.\n        // Update the DOM element based on the supplied values here.\n    }\n};\n```", "```js\n<p data-bind=\"flash: vmProperty\">Flashy! (bum dum tish)</p>\n```", "```js\nko.bindingHandlers.slideVisible = {\n    init: function(element, valueAccessor) {\n        var value = ko.unwrap(valueAccessor());\n        $(element).toggle(value);\n    },\n    update: function(element, valueAccessor, allBindings) {\n        var value = ko.unwrap(valueAccessor());\n        var duration = allBindings.get('slideDuration') || 400;\n\n        if (value === true)\n            $(element).slideDown(duration); //show\n        else\n            $(element).slideUp(duration); //hide\n    }\n};\n```", "```js\n<p data-bind=\"slideVisible: isShowing, slideDuration: 200\">Quick</p>\n```", "```js\nvar duration = ko.unwrap(allBindings.get('slideDuration')) || 400;\n```", "```js\nko.bindingHandlers.datepicker = {\n    init: function(element, valueAccessor, allBindingsAccessor) {\n        var options = allBindingsAccessor().datepickerOptions || {},\n            $el = $(element);\n\n        //initialize datepicker with some optional options\n        $el.datepicker(options);\n\n        //handle the field changing\n        ko.utils.registerEventHandler(element, \"change\", function() {\n            var observable = valueAccessor();\n            observable($el.datepicker(\"getDate\"));\n        });\n\n        //handle disposal (if KO removes by the template binding)\n        ko.utils.domNodeDisposal.addDisposeCallback(element, function() {\n            $el.datepicker(\"destroy\");\n        });\n\n    },\n    update: function(element, valueAccessor) {\n        var value = ko.unwrap(valueAccessor()),\n            $el = $(element),\n            current = $el.datepicker(\"getDate\");\n\n        if (value - current !== 0) {\n            $el.datepicker(\"setDate\", value);   \n        }\n    }\n};\n```", "```js\n<input data-bind=\"datepicker: myDate, datepickerOptions: { mandate: new Date() }\" />\n```", "```js\nif (ko.isObservable(valueAccessor())) {\n  ko.utils.registerEventHandler(element, \"change\", function () {\n        var observable = valueAccessor();\n        observable($el.datepicker(\"getDate\"));\n    });\n}\n```", "```js\nko.bindingHandlers.starRating = {\n    init: function(element, valueAccessor) {\n        $(element).addClass(\"starRating\");\n        for (var i = 0; i < 5; i++) {\n           $(\"<span>\").appendTo(element);\n}\n\n        // Handle mouse events on the stars\n        $(\"span\", element).each(function(index) {\n            $(this).hover(\n                function() { \n                  $(this).prevAll().add(this)\n                    .addClass(\"hoverChosen\");\n                }, \n                function() { \n                  $(this).prevAll().add(this)\n                    .removeClass(\"hoverChosen\");\n                }                \n            ).click(function() { \n                var observable = valueAccessor();\n                observable(index + 1); \n            });\n        });            \n    },\n    update: function(element, valueAccessor) {\n        // Give the first x stars the \"chosen\" class\n        // where x <= rating\n        var observable = valueAccessor();\n        $(\"span\", element).each(function(index) {\n            $(this).toggleClass(\"chosen\", index < observable());\n        });\n    }\n};\n```", "```js\n<span data-bind=\"text: name\"></span>\n<span data-bind=\"starRating: rating\"></span>\n```", "```js\ninit: function(element, valueAccessor) {\n    var childElementToBind = document.createElement('input');\n  element.appendChild(childElementToBind);\n\n  ko.applyBindingsToNode(childElementToBind, {\n    value: valueAccessor()\n  });\n}\n```", "```js\nko.bindingHandlers.labelInput = {\n      init: function(element, valueAccessor) {\n          var input = document.createElement('input'),\n            label = document.createElement('label'),\n            labelText = valueAccessor().label,\n            inputValue = valueAccessor().value;\n\n          label.innerHTML = labelText;\n          label.appendChild(input);\n\n      element.appendChild(label);\n\n      ko.applyBindingsToNode(input, {\n        value: inputValue,\n        valueUpdate: 'afterkeydown'\n      });\n      }\n```", "```js\n<div data-bind=\"labelInput: { label: 'Custom', value: name }\"></div>\n```", "```js\nko. applyBindingAccessorsToNode (input, {\n  value: function() { return inputValue },\n  valueUpdate: function() { return 'afterkeydown' }\n});\n```", "```js\nko.bindingHandlers.valuePlus = {\n    'after': ['options', 'value'],\n    'init': function (element, valueAccessor, allBindings) {\n        /* some code /*\n     }\n}\n```", "```js\nko.bindingHandlers.doughnutChart = {\n    init: function(element, valueAccessor) {\n        var canvas = document.createElement('canvas'),\n            options = ko.utils.extend(defaultChartOptions, valueAccessor());\n\n        element.appendChild(canvas);\n    },\n    update: function(element, valueAccessor) {\n        var chartContext = canvas.getContext('2d')\n\n        /* Drawing code */\n\n        new Chart(chartContext).Doughnut(data, options);\n    }\n};\n//HTML\n<div data-bind=\"doughnutChart: {data: chartSeries}\"></div>\n```", "```js\nko.bindingHandlers.doughnutChart = {\n    init: function(element, valueAccessor) {\n        var canvas = document.createElement('canvas'),\n            options = ko.utils.extend(defaultChartOptions, valueAccessor());\n\n        ko.utils.domData.set(element, 'canvas', canvas);\n\n        element.appendChild(canvas);\n    },\n    update: function(element, valueAccessor) {\n        var canvas = ko.utils.domData.get(element, 'canvas'),\n            chartContext = canvas.getContext('2d');\n\n        /* Drawing code */\n\n        new Chart(chartContext).Doughnut(data, options);\n    }\n};\n```", "```js\nko.bindingHandlers.doughnutChart = {\n    init: function(element, valueAccessor) {\n        var canvas = document.createElement('canvas'),\n            options = ko.utils.extend(defaultChartOptions, valueAccessor()),\n            chartContext = canvas.getContext('2d');\n\n        element.appendChild(canvas);        \n\n        ko.computed(function() { \n  canvas.height = ko.unwrap(options.height);\n          canvas.width = ko.unwrap(options.width);\n\n          var data = ko.toJS(options.data).map(function(x) {\n            return {\n              value: parseFloat(x.value),\n              color: x.color.indexOf('#') === 0 ? \"#\" + x.color : x.color\n            }\n          });\n\n            new Chart(chartContext).Doughnut(data, options);\n        }, null, {disposeWhenNodeIsRemoved: element});\n    }\n};\n```", "```js\nvar defaultChartOptions = { \n    height: 300, \n    width: 300,\n    animation: false\n  };\n```", "```js\nko.computed(function() {\n\n  canvas.height = ko.unwrap(options.height);\n  canvas.width = ko.unwrap(options.width);\n\n  var data = ko.toJS(options.data).map(function(x) {\n    return {\n      value: parseFloat(x.value),\n      color: x.color.indexOf('#') === 0 ? x.color : \"#\" + x.color\n    };\n  });\n\n  new Chart(chartContext).Doughnut(data, options);\n}, null, {disposeWhenNodeIsRemoved: element});\n```", "```js\nvar chart = new Chart(chartContext),\n  chartType = ko.unwrap(options.type);\n\nif (circularChartTypes.indexOf(chartType) === -1) {\n  throw new Error('Chart Type ' + chartType + 'is not a Circular Chart Type');\n}\n\nchart[chartType](data, options);\n```", "```js\n<div data-bind=\"circularChart: { \n            data: chartSeries, \n            width: chartWidth, \n            height: chartHeight, \n            type: selectedChartType \n}\"></div>\n```", "```js\nvar BindingSample = function() {\n  var self = this;\n\n  self.zoom = ko.observable(8);\n  self.latitude = ko.observable(45.51312335271636);\n  self.longitude = ko.observable(-122.67063820362091);\n};\n```", "```js\n<div data-bind=\"map: { lat: latitude, long: longitude, zoom:zoom }\"  ></div>\n```", "```js\nko.bindingHandlers.map = {\n   init: function(element, valueAccessor) {\n      var data = valueAccessor(),\n         options = ko.utils.extend(ko.maps.defaults, data),\n         //just get the relevant options\n         mapOptions = {\n            zoom: ko.unwrap(options.zoom),\n            center: new google.maps.LatLng(ko.unwrap(options.lat), \n              ko.unwrap(options.long)),\n            mapTypeId: options.mapType\n         },\n         map = new google.maps.Map(element, mapOptions);\n\n      ko.computed(function() {\n         map.setZoom(parseFloat(ko.unwrap(options.zoom)));\n      }, null, { disposeWhenNodeIsRemoved: element });\n\n      ko.computed(function() {\n         map.panTo(new google.maps.LatLng(ko.unwrap(options.lat), ko.unwrap(options.long)));\n      }, null, { disposeWhenNodeIsRemoved: element });\n\n      google.maps.event.addListener(map, 'center_changed', function() {\n         var center = map.getCenter();\n         if (ko.isObservable(data.lat)) {\n            data.lat(center.lat());\n    }\n         if (ko.isObservable(data.long)) {\n            data.long(center.lng());\n    }\n      });\n\n      if (ko.isObservable(data.zoom)) {\n         google.maps.event.addListener(map, 'zoom_changed', function() {\n            data.zoom(map.getZoom());\n         });\n      }\n   }\n};\n```", "```js\nko.bindingHandlers.stopBinding = {\n    init: function(element, valueAccessor) {\n        return { controlsDescendantBindings: ko.unwrap(valueAccessor()) };\n    }\n};\n```", "```js\n<div data-bind=\"stopBinding: true\">\n  <h4 data-bind=\"text: 'Bound'\">Unbound</h4>\n</div>\n```", "```js\nko.bindingHandlers.merge = {\n    init: function(element, valueAccessor, allBindings, viewmodel, bindingContext) {\n\n        var value = valueAccessor(),\n          merge = ko.utils.extend(value.target, value.source);\n          child = bindingContext.createChildContext(merge);\n\n    ko.applyBindingsToDescendants(child, element);          \n\n        // Don't bind the descendants\n      return { controlsDescendantBindings: true };\n    }\n};\n```", "```js\nvar BindingSample = function() {\n   var self = this;\n   self.name = 'Scout Retreat';\n   self.springCourse = { knots: true, woodworking: true, metalworking: true };\n   self.summerCourse = { rafting: true, diving: true, tracking: false };\n};\n```", "```js\n<div data-bind=\"merge: { source: springCourse, target: summerCourse }\">\n  <h3 data-bind=\"text: $parent.name\"></h3>\n  <div>\n    <label for=\"knots\">Knots</label>\n    <input type=\"checkbox\" id=\"knots\" disabled data-bind=\"checked: knots\">\n  </div>\n  <div>\n    <label for=\"woodworking\">Woodworking</label>\n    <input type=\"checkbox\" id=\"woodworking\" disabled data-bind=\"checked: woodworking\">\n<div>\n    <label for=\"tracking\">Tracking</label>\n    <input type=\"checkbox\" id=\"tracking\" disabled data-bind=\"checked: tracking\">\n  </div>\n  </div>\n  <!-- More inputs -->\n</div> \n```", "```js\nko.bindingHandlers.merge = {\n    init: function(element, valueAccessor, allBindings, viewmodel, bindingContext) {\n\n        var value = valueAccessor(),\n         merge = ko.utils.extend(value.target, value.source);\n         context = bindingContext.extend(merge);\n\n      ko.applyBindingsToDescendants(context, element);         \n\n        // Also tell KO *not* to bind the descendants itself, otherwise they will be bound twice\n      return { controlsDescendantBindings: true };\n    }\n};\n```", "```js\n<div data-bind=\"merge: { source: springCourse, target: summerCourse }\">\n  <h3 data-bind=\"text: name\"></h3>\n```", "```js\nvar treeTemplate = '<div>Name: <span data-bind=\"text:name\"></span><br>'\n   +'Root: <span data-bind=\"text: isRoot ? \\'Self\\' : $root.name\"></span><br>'\n   +'<ul data-bind=\"foreach: { data: children, as: \\'child\\' }\">'\n      +'<li data-bind=\"tree: { data: child, children: $root.__children, name: $root.__name, isRoot: false }\"></li>'\n   +'</ul></div>';\n\nko.bindingHandlers.tree = {\n    init: function(element, valueAccessor, allBindings, viewmodel, bindingContext) {\n\n      var value = valueAccessor();\n      var context =  { \n         __name: value.name,\n         __children: value.children,\n         //Default to true since template specifies\n         isRoot: value.isRoot === undefined || value.isRoot,\n         name: value.data[value.name],\n         children: value.data[value.children],\n      };\n\n      element.innerHTML = treeTemplate;\n\n      if (context.isRoot) {\n         ko.applyBindings(context, element.firstChild);\n    }\n      else {\n      ko.applyBindingsToDescendants(bindingContext.extend(context), element);   \n    }       \n\n      // Also tell KO *not* to bind the descendants itself, otherwise they will be bound twice\n      return { controlsDescendantBindings: true };\n    }\n};\n```", "```js\nvar BindingSample = function() {\n   var self = this;\n\n   self.person = { \n      fullName: 'Alexander Hamilton',\n      descendants: [ /* self-same children */]\n   };\n};\n```", "```js\n<div data-bind=\"tree: { \n               data: person, \n               children: 'descendants', \n               name: 'fullName'\n}\"></div>\n```", "```js\nko.bindingHandlers.widthSort = {\n    init: function(element, valueAccessor) {\n      // Pull out each of the child elements into an array\n      var children = [];\n      for (var i = element.children.length - 1; i >= 0; i--) {\n         var child = element.children[i];\n         //Don't take empty text nodes, they are not real nodes\n         if (!isWhitespaceNode(child))\n            children.push(child);\n      };\n\n      //Width calc must be done while the node is still in the DOM\n      children.sort(function(a, b) {\n         return $(a).width() <= $(b).width() ? -1 : 1;\n      });\n\n      while(children.length) {\n         //Append will remove the node if it's already in the DOM\n         element.appendChild(children.shift());\n      }\n   }\n};\n```", "```js\n<ul data-bind=\"widthSort: true\">\n```", "```js\nfunction isWhitespaceNode(node) {\n  return !(/[^\\t\\n\\r ]/.test(node.textContent)) \n          && node.nodeType == 3;\n}\n```", "```js\n<ul data-bind=\"widthSort: true\">\n   <li>Jimmy Dean</li>\n   <li>Sara Lee</li>\n   <li>Famous Amos</li>\n   <li>Orville Redenbacher</li>\n   <li>Dr. Pepper</li>\n</ul>\n```", "```js\nko.virtualElements.allowedBindings.widthSort = true;\n```", "```js\nko.bindingHandlers.widthSort = {\n   init: function(element, valueAccessor) {\n      // Pull out each of the child elements into an array\n      var children = [],\n         childNodes = ko.virtualElements.childNodes(element);\n      for (var i = childNodes.length - 1; i >= 0; i--) {\n         var child = childNodes[i];\n         //Don't take empty text nodes, they are not real nodes\n         if (!isWhitespaceNode(child)) {\n             children.push(child);\n    }\n      };\n\n      //Width calc must be done while the node is still in the DOM\n      children.sort(function(a, b) {\n         return $(a).width() <= $(b).width() ? -1 : 1;\n      });\n\n      ko.virtualElements.setDomNodeChildren(element, children);\n   }\n};\n```", "```js\n<ul class=\"oddball clearfix\">\n   <li>Jimmy Dean</li>\n   <!-- ko widthSort: true -->\n   <li>Sara Lee</li>\n   <li>Famous Amos</li>\n   <li>Orville Redenbacher</li>\n   <li>Johnny Appleseed</li>\n   <li>The Kellog Brothers</li>\n   <!-- /ko -->\n</ul>\n```"]