- en: Chapter 7. Facebook Messenger Bot, Who's Off – A Scheduler Bot for Teams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. Facebook Messenger机器人，谁休假 - 团队的调度机器人
- en: Facebook has launched its own messaging platform ([https://developers.facebook.com/docs/messenger-platform/product-overview](https://developers.facebook.com/docs/messenger-platform/product-overview)),
    which enables us to enrich our conversation experience with other users on a messengers.
    Companies, apart from just showing information, can now provide new ways of conversational
    experience using custom bots. These bots can be integrated with the company's
    Facebook Page. With this, customers or employees of that company can easily look
    for information on the page and also chat at the same time on Facebook Messenger
    itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook推出了自己的消息平台([https://developers.facebook.com/docs/messenger-platform/product-overview](https://developers.facebook.com/docs/messenger-platform/product-overview))，这使得我们能够通过自定义机器人丰富与其他用户在消息平台上的对话体验。除了仅显示信息外，公司现在可以通过自定义机器人提供新的对话体验方式。这些机器人可以与公司的Facebook页面集成。有了这个，该公司的客户或员工可以轻松地在页面上查找信息，同时也可以在Facebook
    Messenger上聊天。
- en: The Facebook Messenger platform's APIs can be used not only to send messages,
    but also to send links, photos, videos, files, and images. Facebook Messenger
    has a feature called secret messages or conversations. These secret conversations
    are currently available only in the Messenger app, downloaded on iOS and Android
    devices. With these conversations, we can only send messages, pictures, and stickers.
    Group messages, videos, GIFs, video calling, and payments are not supported in
    secret conversations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook Messenger平台API不仅可以用来发送消息，还可以用来发送链接、图片、视频、文件和图像。Facebook Messenger有一个名为秘密消息或对话的功能。这些秘密对话目前仅在iOS和Android设备上下载的Messenger应用中可用。在这些对话中，我们只能发送消息、图片和贴纸。秘密对话不支持群发消息、视频、GIF、视频通话和支付。
- en: Recently, I read about Domino's pizzas getting ordered from Facebook Messenger!
    So just by chatting, you can now select your pizza, order it, and process the
    payment as well. Here, users are provided with a seamless experience during the
    chat itself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我了解到多米诺披萨可以通过Facebook Messenger订购！所以，只需聊天，你现在就可以选择披萨，下单，甚至处理支付。在这里，用户在聊天过程中得到了无缝的体验。
- en: In this chapter, we'll build a Facebook Messenger bot and enhance it to schedule
    off-hours. Our bot will also help us discover who and when a person will take
    off; this will all be done through an elegant calendar-based user interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个Facebook Messenger机器人，并增强其安排非工作时间的功能。我们的机器人还将帮助我们发现谁将在何时休假；这一切都将通过一个优雅的基于日历的用户界面来完成。
- en: Awesome! Let's start now.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们现在开始吧。
- en: Setting up our Facebook Messenger bot
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的Facebook Messenger机器人
- en: Facebook has great documentation on how to set up a bot. You can also refer
    to the steps mentioned at [https://developers.facebook.com/docs/messenger-platform/guides/quick-start](https://developers.facebook.com/docs/messenger-platform/guides/quick-start).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook提供了关于如何设置机器人的优秀文档。您还可以参考[https://developers.facebook.com/docs/messenger-platform/guides/quick-start](https://developers.facebook.com/docs/messenger-platform/guides/quick-start)中提到的步骤。
- en: 'We will be using the following steps to build a basic bot:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下步骤来构建一个基本的机器人：
- en: Create a Facebook Page for our bot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的机器人创建一个Facebook页面
- en: Create an app within Facebook
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Facebook中创建一个应用
- en: Create a basic Facebook Messenger bot in Node.js, specifically in Microsoft
    Azure
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js中创建一个基本的Facebook Messenger机器人，特别是在Microsoft Azure上
- en: Wire up the Facebook app and the basic bot
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接Facebook应用和基本机器人
- en: Let's start working on these steps one by one.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地开始工作在这些步骤上。
- en: The Facebook Page for our basic bot
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的Facebook基本机器人的页面
- en: First of all, log in to Facebook. You can use the existing pages or create a
    new page.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，登录到Facebook。您可以使用现有的页面或创建一个新的页面。
- en: We will implement our bot in a way that it will tell users who would be off
    and when. Let's create a page called *Who's Off* by navigating to [https://www.facebook.com/pages/create/](https://www.facebook.com/pages/create/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现我们的机器人，使其能够告诉用户谁将休假以及何时休假。让我们通过导航到[https://www.facebook.com/pages/create/](https://www.facebook.com/pages/create/)创建一个名为“Who's
    Off”的页面。
- en: 'Once you hit the URL, you will see the following screen:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击URL，您将看到以下屏幕：
- en: '![The Facebook Page for our basic bot](img/image00325.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![我们的基本机器人的Facebook页面](img/image00325.jpeg)'
- en: 'Choose the page type as **Company, Organization or Institution**. This will
    show the following input screen:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 选择页面类型为**公司、组织或机构**。这将显示以下输入屏幕：
- en: '![The Facebook Page for our basic bot](img/image00326.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![我们的基本机器人的Facebook页面](img/image00326.jpeg)'
- en: Provide information on this page, such as the type and name of the company.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Internet Company** and set the name as `Who''s Off`. Then click on
    the **Get Started** button. This will open up a wizard to set up all the other
    properties for your company, such as the profile information:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![The Facebook Page for our basic bot](img/image00327.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: You can skip this wizard or directly go to the last tab, **4\. Preferred Page
    Audience**, to save the information.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a Facebook Page for our bot. This will appear as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![The Facebook Page for our basic bot](img/image00328.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Creating a Facebook app for our basic bot
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating a page, now let''s create a Facebook app for our bot via [https://developers.facebook.com/quickstarts/](https://developers.facebook.com/quickstarts/).
    This will lead us to a screen where we can configure our app as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Facebook app for our basic bot](img/image00329.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Click on **basic setup** to open a popup and enter the following information:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Facebook app for our basic bot](img/image00330.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'While creating the app ID, security check will be done as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Facebook app for our basic bot](img/image00331.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Please respond to **Security Check** and click on **Submit** to set up your
    Facebook app by following the instructions on this screen:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Facebook app for our basic bot](img/image00332.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Since we want to set up a messenger, click on the **Get Started** button available
    in **Messenger**. This will lead you to the following screen:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Facebook app for our basic bot](img/image00333.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Now locate the section called **Token Generation** in the page and select the
    Facebook Page created earlier. This will generate a token for the selected page,
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Facebook app for our basic bot](img/image00334.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: This page token will be used while communicating with the APIs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: To receive messages from users, our Facebook app needs the Webhooks integration.
    Before we set up Webhooks, let's create a Node.js Facebook Messenger app. The
    Facebook Webhook integration needs our bot app to be accessible over HTTPs. So
    we will need to do this using Microsoft Azure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our bot server in Azure
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, we need an HTTPs-enabled bot server so that we can integrate it
    in Facebook. We will build our bot server in Microsoft Azure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s log in to the Azure portal and locate **App Services** to create a Node.js-based
    bot server. Refer to the following screen:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up our bot server in Azure](img/image00335.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Add** link to open the following screen. Then, select the **Web
    + Mobile** option and search for an empty Node.js-based web app template, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up our bot server in Azure](img/image00336.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'After selecting the template as **Node JS Empty Web App**, click on the **Create**
    button to create the Node.js-based site. The next screen will ask you to input
    the name of your site and resources:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择模板为**Node JS Empty Web App**后，点击**创建**按钮以创建基于Node.js的站点。下一屏幕将要求你输入站点的名称和资源：
- en: '![Setting up our bot server in Azure](img/image00337.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中设置我们的机器人服务器](img/image00337.jpeg)'
- en: Provide the required information and click on the **Create** button at the bottom
    to create a site called `whosoffchatbotsite.azurewebsites.net`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提供所需信息并点击底部的**创建**按钮以创建名为`whosoffchatbotsite.azurewebsites.net`的站点。
- en: 'Once created, you should see the following properties of the site using the
    **Overview** menu option from the **App Services** selected site:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，你应该会看到以下属性，使用**应用服务**中选定站点的**概览**菜单选项：
- en: '![Setting up our bot server in Azure](img/image00338.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中设置我们的机器人服务器](img/image00338.jpeg)'
- en: 'Click on `http://whosoffchatbotsite.azurewebsites.net` to check how our initial
    Node.js site looks or whether there are any issues:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`http://whosoffchatbotsite.azurewebsites.net`以检查我们的初始Node.js站点的外观或是否存在任何问题：
- en: '![Setting up our bot server in Azure](img/image00339.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中设置我们的机器人服务器](img/image00339.jpeg)'
- en: With this, we were able to create and run Node.js from Microsoft Azure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们能够在Microsoft Azure中创建和运行Node.js。
- en: In [Chapter 2](part0021.xhtml#aid-K0RQ2 "Chapter 2. Getting Skype to Work for
    You") , *Getting Skype to Work for You*, we looked at how to create a Node.js
    site using the Azure command-line interface. In this chapter, we have so far created
    a Node.js site in Azure itself; now, we will modify the basic Node.js site for
    our bot.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0021.xhtml#aid-K0RQ2 "第2章。让Skype为您服务")，*让Skype为您服务*中，我们探讨了如何使用Azure命令行界面创建Node.js站点。在本章中，我们已经在Azure本身创建了Node.js站点；现在，我们将修改基本的Node.js站点以适应我们的机器人。
- en: To modify the basic bot program, first we will clone the template on our local
    file system using git commands. Then, we will modify and deploy it to Microsoft
    Azure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改基本的机器人程序，我们首先将使用git命令在我们的本地文件系统中克隆模板。然后，我们将对其进行修改并部署到Microsoft Azure。
- en: 'Let''s start by creating a folder in our local drive in order to store our
    bot program from the Command Prompt:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在我们的本地驱动器中创建一个文件夹开始，以便从命令提示符存储我们的机器人程序：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now go to the newly created directory and run the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到新创建的目录并运行以下命令：
- en: '![Setting up our bot server in Azure](img/image00340.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中设置我们的机器人服务器](img/image00340.jpeg)'
- en: 'This command will clone our site from a remote URL to a local file system.
    Once the site is cloned, move to the `NodeJS-EmptySiteTemplate` directory and
    run `server.js` as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将从远程URL克隆我们的站点到本地文件系统。一旦站点被克隆，切换到`NodeJS-EmptySiteTemplate`目录并按照以下方式运行`server.js`：
- en: '![Setting up our bot server in Azure](img/image00341.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中设置我们的机器人服务器](img/image00341.jpeg)'
- en: 'Once the cloning is successful, you should see the bot program in Node.js running,
    as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦克隆成功，你应该会看到Node.js中运行的机器人程序，如下所示：
- en: '![Setting up our bot server in Azure](img/image00342.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中设置我们的机器人服务器](img/image00342.jpeg)'
- en: So far, we have used a template from a remote git repository and cloned it to
    a local file system. Now we'll set our own git location for the bot program. The
    reason is that, whenever we make a change in `server.js`, which is our bot program,
    we would also like the changes to be deployed to Azure; we can do this using git
    commands. So we will be setting up a local git repository for our bot program
    in Azure itself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从一个远程git仓库的模板中使用了模板并将其克隆到本地文件系统中。现在，我们将为机器人程序设置自己的git位置。原因是，每当我们在我们的机器人程序`server.js`中进行更改时，我们也希望这些更改被部署到Azure；我们可以使用git命令来完成此操作。因此，我们将在Azure本身为我们的机器人程序设置本地git仓库。
- en: Setting up a local git repository for our bot server in Azure
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Azure中为我们的机器人服务器设置本地git仓库
- en: 'First, disconnect the remote git library of our program using the **Disconnect**
    menu option:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用**断开连接**菜单选项断开我们程序的远程git库：
- en: '![Setting up a local git repository for our bot server in Azure](img/image00343.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中为我们的机器人服务器设置本地git仓库](img/image00343.jpeg)'
- en: 'Once disconnected, use the **Setup** option to set up a code repository for
    our program, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 断开连接后，使用**设置**选项为我们的程序设置代码仓库，如下所示：
- en: '![Setting up a local git repository for our bot server in Azure](img/image00344.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中为我们的机器人服务器设置本地git仓库](img/image00344.jpeg)'
- en: Once you click on **Setup**, the **Deployment Source** screen will be launched,
    as shown in the following screenshot.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击**设置**，将启动**部署源**屏幕，如下面的截图所示。
- en: '![Setting up a local git repository for our bot server in Azure](img/image00345.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中为我们的机器人服务器设置本地git仓库](img/image00345.jpeg)'
- en: Choose the **Local Git Repository** option to set up a git-based repository
    for the site.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**本地Git仓库**选项为网站设置基于git的仓库。
- en: 'Now if you look at the website properties, you will see that a git URL as well
    as an FTP account has been set up. We can deploy our site to Azure using either
    git commands or FTP. Refer to the following screenshot for the newly updated properties:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您查看网站属性，您将看到已经设置了git URL以及FTP账户。我们可以使用git命令或FTP将我们的网站部署到Azure。请参考以下截图查看新更新的属性：
- en: '![Setting up a local git repository for our bot server in Azure](img/image00346.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中为我们的机器人服务器设置本地git仓库](img/image00346.jpeg)'
- en: 'So we have set up a git repository in Azure, but the site we cloned from a
    local file system earlier is still pointing to a remote URL. Let''s point our
    local git configurations to the newly created Azure clone repository using the
    following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在Azure中设置了一个git仓库，但之前从本地文件系统克隆的站点仍然指向远程URL。让我们使用以下命令将我们的本地git配置指向新创建的Azure克隆仓库：
- en: '![Setting up a local git repository for our bot server in Azure](img/image00347.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure中为我们的机器人服务器设置本地git仓库](img/image00347.jpeg)'
- en: Modifying our bot program for Facebook verification
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改我们的机器人程序以进行Facebook验证
- en: 'When we cloned bot program code within `server.js`, the following is auto-generated:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`server.js`内部克隆机器人程序代码时，以下内容会自动生成：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s start modifying our code. But before that, we need to install some
    node modules; we can do this using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始修改我们的代码。但在那之前，我们需要安装一些node模块；我们可以使用以下命令来完成：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `body-parser` npm module helps in parsing the incoming requests available
    under `req.body`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`body-parser` npm模块有助于解析在`req.body`下可用的传入请求。'
- en: 'Now let''s open our `server.js` and modify it as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开我们的`server.js`并按以下方式修改它：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s run our bot program using the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行我们的机器人程序：
- en: '![Modifying our bot program for Facebook verification](img/image00348.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![修改我们的机器人程序以进行Facebook验证](img/image00348.jpeg)'
- en: 'Then open a browser window and hit `http://localhost:8080` :'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开一个浏览器窗口并访问`http://localhost:8080`：
- en: '![Modifying our bot program for Facebook verification](img/image00349.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![修改我们的机器人程序以进行Facebook验证](img/image00349.jpeg)'
- en: This will show us that our Node.js program is working fine. Now let's deploy
    this code to Azure using git commands. This time, all our node modules, which
    are marked as a dependent using `--save`, will also be pushed to Azure. Sometimes,
    you may encounter a timeout error while pushing the code. But again, try to push
    the code; it should get deployed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将表明我们的Node.js程序运行良好。现在让我们使用git命令将此代码部署到Azure。这次，所有标记为依赖项的node模块（使用`--save`标记），也将被推送到Azure。有时，在推送代码时可能会遇到超时错误。但再次尝试推送代码；它应该会被部署。
- en: 'The git commands that we need to execute are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的git命令如下：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the code is deployed to Azure, browse the site and check whether it reflects
    the latest changes, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码部署到Azure，浏览网站并检查它是否反映了最新的更改，如下所示：
- en: '![Modifying our bot program for Facebook verification](img/image00350.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![修改我们的机器人程序以进行Facebook验证](img/image00350.jpeg)'
- en: Setting up a Webhook and Facebook verification of our bot program
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置我们的机器人程序Webhook和Facebook验证
- en: 'Now let''s go back to our Facebook app; we had stopped at token generation.
    Let''s set up Webhooks in our Facebook app, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到我们的Facebook应用；我们在令牌生成处停止了。让我们在Facebook应用中设置Webhooks，如下所示：
- en: '![Setting up a Webhook and Facebook verification of our bot program](img/image00351.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的机器人程序Webhook和Facebook验证](img/image00351.jpeg)'
- en: 'A few important things to note here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的几个重要事项：
- en: '**Callback URL** has to be accessible from Facebook and should be on HTTPS.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调URL**必须可以从Facebook访问，并且应该是HTTPS。'
- en: '**Callback URL** with Webhook should return a token, as mentioned at **Verify
    token**. Verify that the token is the same as the one we referred to in `server.js`,
    as follows:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Webhook的**回调URL**应返回一个令牌，如**验证令牌**中所述。验证该令牌是否与我们在`server.js`中引用的令牌相同，如下所示：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The token `'whosoffbot_verify_token`, provided in the code should match the
    token on Facebook.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中提供的`'whosoffbot_verify_token'`令牌应与Facebook上的令牌匹配。
- en: 'Once your token is verified, you should see the following screen:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的令牌被验证，您应该会看到以下屏幕：
- en: '![Setting up a Webhook and Facebook verification of our bot program](img/image00352.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的机器人程序Webhook和Facebook验证](img/image00352.jpeg)'
- en: 'So Webhook is verified and set, but we need a page to subscribe to this Webhook.
    Refer to the following screen and subscribe to the **Who''s Off** page, which
    we created at the beginning:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Webhook 已经验证并设置，但我们需要一个页面来订阅这个 Webhook。参考以下屏幕并订阅我们最初创建的 **Who's Off** 页面：
- en: '![Setting up a Webhook and Facebook verification of our bot program](img/image00353.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Webhook 和我们机器人程序的 Facebook 验证](img/image00353.jpeg)'
- en: 'This is how we linked our basic bot to a Facebook Page. Now let''s open our
    **Who''s Off** page from Facebook and click on the **Message** button to make
    our bot active. You should see a green dot before the bot name indicating it is
    active. Refer to the following screenshot for details:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何将我们的基本机器人链接到 Facebook 页面。现在让我们从 Facebook 打开我们的 **Who's Off** 页面，并点击 **消息**
    按钮使我们的机器人活跃。您应该在机器人名称前看到一个绿色的点，表示它处于活跃状态。有关详细信息，请参考以下截图：
- en: '![Setting up a Webhook and Facebook verification of our bot program](img/image00354.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Webhook 和我们机器人程序的 Facebook 验证](img/image00354.jpeg)'
- en: 'If you try to post anything to this bot, it will not do anything as we have
    not programmed Webhooks in relation to posting commands. Now let''s ask our bot
    to echo what the user is saying in a chat window. To achieve this, let''s include
    the following code snippet in our `server.js`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试向这个机器人发布任何内容，它将不会做任何事情，因为我们还没有为发布命令编程 Webhooks。现在让我们让我们的机器人在一个聊天窗口中回声用户说的话。为了实现这一点，让我们在
    `server.js` 中包含以下代码片段：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let me explain the code snippet here. When the data is posted from a page that
    is subscribing to the Webhook, `app.post('/webhook',function(req,res){})` will
    get called. This will parse the incoming messages, and bot will form an echo message
    and will call the `sendMessage()` function to send the message to the same recipient
    with the help of a page access token.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来解释这里的代码片段。当数据从一个订阅 Webhook 的页面发布时，`app.post('/webhook',function(req,res){})`
    将会被调用。这将解析传入的消息，并且机器人将形成一个回声消息，并调用 `sendMessage()` 函数，通过页面访问令牌将消息发送给相同的接收者。
- en: Deploying a modified bot that returns an echo
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署返回回声的修改后机器人
- en: 'Let''s use git commands to deploy the modified code and check whether the bot
    would echo what we say:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 git 命令部署修改后的代码，并检查机器人是否会回声我们说的话：
- en: '![Deploying a modified bot that returns an echo](img/image00355.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![部署返回回声的修改后机器人](img/image00355.jpeg)'
- en: 'Once you deploy the updated code, hit the Facebook Page again, and the Messenger
    and post data as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署了更新后的代码，再次点击 Facebook 页面，并按以下方式发送 Messenger 和帖子数据：
- en: '![Deploying a modified bot that returns an echo](img/image00356.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![部署返回回声的修改后机器人](img/image00356.jpeg)'
- en: We have made multiple posts to our bot, but it is not yet doing anything. Let's
    see what's happening at the Azure end, that is, whether there are any errors at
    the application level.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向我们的机器人发送了多次帖子，但它还没有做任何事情。让我们看看 Azure 端发生了什么，也就是说，应用程序级别是否有任何错误。
- en: Troubleshooting our bot in Azure
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Azure 中排查我们的机器人问题
- en: 'To troubleshoot the problem of bot not echoing anything, let''s turn to **Diagnostics
    logs** for our site and also start **Log stream**. Log stream will show us whether
    there are any errors in our program:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了排除机器人不回声的问题，让我们转向我们网站的 **诊断日志** 并开始 **日志流**。日志流将显示我们的程序中是否有任何错误：
- en: '![Troubleshooting our bot in Azure](img/image00357.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![在 Azure 中排查我们的机器人问题](img/image00357.jpeg)'
- en: 'Now let''s enter or post anything to our bot from the Facebook Page and refer
    to the log streams. You will get to see the line number and the error we will
    get, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从 Facebook 页面向我们的机器人输入或发布任何内容，并参考日志流。您将看到行号和我们将得到的错误，如下所示：
- en: '![Troubleshooting our bot in Azure](img/image00358.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![在 Azure 中排查我们的机器人问题](img/image00358.jpeg)'
- en: 'So our code is failing to parse the input, resulting into an error. To fix
    this, let''s make a small change while parsing. Use `bodyParser` before the `urlencoded`
    call, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的代码在解析输入时失败，导致出现错误。为了修复这个问题，让我们在解析时进行一个小改动。在 `urlencoded` 调用之前使用 `bodyParser`，如下所示：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, deploy the modified code to Azure using git commands and try to post
    something to our bot. The code will run successfully and echo out what a user
    would post in the chat window, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，使用 git 命令将修改后的代码部署到 Azure，并尝试向我们的机器人发布一些内容。代码将成功运行并回声用户在聊天窗口中发布的内容，如下所示：
- en: '![Troubleshooting our bot in Azure](img/image00359.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![在 Azure 中排查我们的机器人问题](img/image00359.jpeg)'
- en: Wow! So far, we have been able to wire up our bot with the Facebook Page and
    Messenger as well. We have also looked at how to use Azure diagnostics for logging
    into our site if there are issues with our bot program; we also understood how
    to trace and fix the problem. Now let's look at the core functionality we are
    trying to build for our Who's Off bot.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！到目前为止，我们已经能够将我们的机器人与Facebook页面和Messenger连接起来。我们还了解了如何使用Azure诊断来登录我们的网站，如果我们的机器人程序有问题；我们还了解了如何跟踪和修复问题。现在让我们看看我们为“谁不在”机器人构建的核心功能。
- en: Enhancing our Who's Off bot
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强我们的“谁不在”机器人
- en: Having built a very basic Facebook Messenger bot, let's enhance our Who's Off
    bot.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了一个非常基本的Facebook Messenger机器人之后，让我们增强我们的“谁不在”机器人。
- en: Assume our team members are collaborating over Facebook Messenger. Our bot should
    be able to help this team schedule a meeting and should also be able to show who
    is busy on a particular day before setting up the meeting.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的团队成员正在Facebook Messenger上协作。我们的机器人应该能够帮助这个团队安排会议，并且在设置会议之前也应该能够显示特定日期的忙碌情况。
- en: 'Now let me show you, what we will be building in Facebook Messenger for our
    bot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将向您展示，我们将为我们的机器人构建以下内容：
- en: '![Enhancing our Who''s Off bot](img/image00360.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![增强我们的“谁不在”机器人](img/image00360.jpeg)'
- en: Let's dive into the flow and then look into the code implementation one by one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入流程，然后逐一查看代码实现。
- en: 'When a user starts a conversation with our bot with `hi`, as shown in the preceding
    screenshot, then the Who''s Off bot will show the first three options: **Schedule
    a Meeting**, **Whos Off When**, and **My Schedule**.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户用“hi”与我们的机器人开始对话，如先前的屏幕截图所示，然后“谁不在”机器人将显示前三个选项：**安排会议**、**谁不在**和**我的日程**。
- en: 'Depending upon the option the user chooses, the bot will prompt options for
    when they would like to carry out the mentioned operation, such as scheduling
    a meeting, seeing who is off when, or checking out their own meetings. Refer to
    the following screenshot for the operation''s flow:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户选择的选项，机器人将提示他们想要执行的操作的时间选项，例如安排会议、查看谁在特定时间不在，或查看他们的会议。请参考以下屏幕截图以了解操作流程：
- en: '![Enhancing our Who''s Off bot](img/image00361.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![增强我们的“谁不在”机器人](img/image00361.jpeg)'
- en: These operations will be done using options such as **Today** and **Tomorrow**.
    Based on what you choose, the bot will display the meeting details or will ask
    for it to schedule the meeting. In the preceding screenshot, it shows the meeting
    for the **Whos Off When** option selected in Facebook Messenger is scheduled today.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作将使用**今天**和**明天**等选项来完成。根据您的选择，机器人将显示会议详情或请求您安排会议。在先前的屏幕截图中，它显示了在Facebook
    Messenger中选择的**谁不在**选项今天安排的会议。
- en: 'So at a higher level, we will be:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以从更高的层面来看，我们将：
- en: Enhancing our basic bot program for a better conversational experience within
    Facebook Messenger by leveraging message templates; for more information, refer
    to [https://developers.facebook.com/docs/messenger-platform/send-api-reference/templates](https://developers.facebook.com/docs/messenger-platform/send-api-reference/templates)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用消息模板来增强我们的基本机器人程序，以在Facebook Messenger中提供更好的对话体验；更多信息，请参阅[https://developers.facebook.com/docs/messenger-platform/send-api-reference/templates](https://developers.facebook.com/docs/messenger-platform/send-api-reference/templates)
- en: Storing meeting's information in the NoSQL database-DocumentDB
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在NoSQL数据库-DocumentDB中存储会议信息
- en: Wiring up DocumentDB APIs and Messenger platform APIs
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接DocumentDB API和Messenger平台API
- en: Building a conversational experience with the Who's Off bot
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用“谁不在”机器人构建对话体验
- en: We have already seen how users will arrive at our bot's Facebook Page and then
    start a conversation with our bot.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了用户如何到达我们的Facebook页面并与我们的机器人开始对话。
- en: Setting up a Messenger greeting
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置Messenger问候语
- en: 'Let''s enhance the conversational experience of this bot now. We''ll begin
    by adding a greeting message whenever a user starts a conversation. Follow these
    steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们增强这个机器人的对话体验。我们将从在用户开始对话时添加问候消息开始。按照以下步骤操作：
- en: Locate your bot page on Facebook and click on the **Settings** option:![Setting
    up a Messenger greeting](img/image00362.jpeg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Facebook上找到您的机器人页面并点击**设置**选项：![设置Messenger问候语](img/image00362.jpeg)
- en: On the **Settings** page, locate the **Messaging** menu on the left-hand side,
    as follows:![Setting up a Messenger greeting](img/image00363.jpeg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置**页面，在左侧找到**消息**菜单，如下所示：![设置Messenger问候语](img/image00363.jpeg)
- en: Choose the option **Yes** for **Show a Messenger Greeting**, as follows:![Setting
    up a Messenger greeting](img/image00364.jpeg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**是**选项以**显示消息问候**，如下所示：![设置消息问候](img/image00364.jpeg)
- en: Provide the greeting text and click on the **Save** button to save the text:![Setting
    up a Messenger greeting](img/image00365.jpeg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供问候文本并点击**保存**按钮以保存文本：![设置消息问候](img/image00365.jpeg)
- en: Go back to the bot's Facebook Page and start messaging. The first time you start
    a conversation, the Who's Off bot will greet you like this:![Setting up a Messenger
    greeting](img/image00366.jpeg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到机器人的Facebook页面并开始发消息。第一次开始对话时，Who's Off机器人将这样问候你：![设置消息问候](img/image00366.jpeg)
- en: Showing the initial options of what a bot can do
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示机器人可以执行的基本选项
- en: 'At the start of a conversation, our bot will display the tasks it can perform.
    The user can then choose which operation he or she wants to perform. To achieve
    this, let''s modify `server.js` as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话开始时，我们的机器人将显示它可以执行的任务。用户可以选择他或她想要执行的操作。为了实现这一点，让我们按照以下方式修改`server.js`：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use git commands to push the preceding code changes to Azure. Once deployed
    successfully, start a conversation with the bot by saying `hi`. The Who''s Off
    bot will respond with what it can do for you, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用git命令将前面的代码更改推送到Azure。一旦成功部署，通过说“hi”与机器人开始对话。Who's Off机器人将回应它能为你做什么，如下所示：
- en: '![Showing the initial options of what a bot can do](img/image00367.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![显示机器人可以执行的基本选项](img/image00367.jpeg)'
- en: After checking out how our bot will respond, let's look at the code now.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查我们的机器人将如何响应之后，现在让我们看看代码。
- en: 'The `app.post(''/webhook'')` function captures all the messages that come to
    our bot. So when a user says `hi`, there is a pattern-matching done and bot responds
    with the initial options for operations that it can perform. This is done using
    the following lines of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.post(''/webhook'')`函数捕获所有发送到我们的机器人的消息。所以当用户说“hi”时，会进行模式匹配，机器人会以它可以执行的操作的初始选项进行响应。这是通过以下代码行完成的：'
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `sendMessageWithInitialOptions()` function actually prepares a formatted
    message using structured messaging templates. Since we would like to display operations
    that the user can choose from, we use `template_type` as `button`. Every button
    is of the `postback` type, and when a user clicks on one of these buttons, we
    can capture what the user has selected and respond to the selection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendMessageWithInitialOptions()`函数实际上使用结构化消息模板准备一个格式化的消息。由于我们希望显示用户可以选择的操作，我们使用`template_type`作为`button`。每个按钮都是`postback`类型，当用户点击这些按钮之一时，我们可以捕获用户的选择并对此做出响应。'
- en: This structured message is then returned to a sender using the `sendMessage()`
    function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构化消息随后通过`sendMessage()`函数返回给发送者。
- en: Based on what a user selects, the bot will respond in a button-type display.
    This is done to avoid wasting the end user's time in typing messages or entering
    keywords.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的选择，机器人将以按钮类型显示进行响应。这是为了避免浪费最终用户的时间在输入消息或输入关键词。
- en: So far, we have seen how a basic conversation can happen between an end user
    and a bot. This same pattern will be used to further enhance our bot.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一个基本对话是如何在最终用户和机器人之间发生的。这个相同的模式将被用来进一步增强我们的机器人。
- en: I hope you now have a little idea about how to build and enhance a conversational
    experience. Now let's look at how to store meeting-related information. We will
    use DocumentDB to store this information. Let's quickly see how we can set this
    up on the Azure platform.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你现在对如何构建和增强对话体验有了一点了解。现在让我们看看如何存储与会议相关的信息。我们将使用DocumentDB来存储这些信息。让我们快速看看我们如何在Azure平台上设置它。
- en: What is DocumentDB?
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是DocumentDB？
- en: In [Chapter 6](part0040.xhtml#aid-164MG2 "Chapter 6. BotKit – Document Manager
    Agent for Slack") , *BotKit - Document Manager Agent for Slack*, I explained NoSQLs.
    DocumentDB is also a NoSQL where data is stored in JSON documents and offered
    by the Microsoft Azure platform.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0040.xhtml#aid-164MG2 "第6章。BotKit – Slack的文档管理代理")，*BotKit - Slack的文档管理代理*，我解释了NoSQL。DocumentDB也是一个NoSQL，其中数据以JSON文档的形式存储，并由Microsoft
    Azure平台提供。
- en: For further details on DocumentDB, refer to [https://azure.microsoft.com/en-in/services/documentdb/](https://azure.microsoft.com/en-in/services/documentdb/)
    .
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关DocumentDB的更多详细信息，请参阅[https://azure.microsoft.com/en-in/services/documentdb/](https://azure.microsoft.com/en-in/services/documentdb/)。
- en: Setting up a DocumentDB for our Who's Off bot
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的“Who's Off”机器人设置DocumentDB
- en: Assuming you already have a Microsoft Azure subscription, follow the ensuing
    steps to configure a DocumentDB for your bot.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经拥有一个微软Azure订阅，请按照以下步骤为您的机器人配置DocumentDB。
- en: Creating an account ID for the DocumentDB
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为DocumentDB创建账户ID
- en: 'Let''s create a new account called `botdb` using the following screen from
    the Azure portal. Select **DocumentDB** as the NoSQL API. Select the appropriate
    subscription and resources. Let''s use existing resources for this account. You
    can also create a new dedicated resource. Once you enter all of the required information,
    hit the **Create** button at the bottom to create a new account for the DocumentDB:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下Azure门户屏幕创建一个名为`botdb`的新账户。选择**DocumentDB**作为NoSQL API。选择合适的订阅和资源。让我们为这个账户使用现有资源。您也可以创建一个新的专用资源。一旦输入所有必要的信息，点击底部的**创建**按钮来为DocumentDB创建一个新的账户：
- en: '![Creating an account ID for the DocumentDB](img/image00368.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![为DocumentDB创建账户ID](img/image00368.jpeg)'
- en: 'A newly created account called `botdb` will appear, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新创建的账户名为`botdb`，如下所示：
- en: '![Creating an account ID for the DocumentDB](img/image00369.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![为DocumentDB创建账户ID](img/image00369.jpeg)'
- en: Creating a collection and database
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建集合和数据库
- en: Select a `botdb` account from the account list shown in the preceding screenshot.
    It will show various menu options, such as **Properties**, **Settings**, **Collections**,
    and so on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面截图所示的账户列表中选择一个`botdb`账户。它将显示各种菜单选项，如**属性**、**设置**、**集合**等。
- en: 'Under this account, we need to create a collection to store meetings or event
    data. To create a new collection, click on the **Add Collection** option, as shown
    in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在此账户下，我们需要创建一个集合来存储会议或事件数据。要创建一个新的集合，请点击以下截图所示的**添加集合**选项：
- en: '![Creating a collection and database](img/image00370.jpeg)![Creating a collection
    and database](img/image00371.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![创建集合和数据库](img/image00370.jpeg)![创建集合和数据库](img/image00371.jpeg)'
- en: As per the preceding screenshot, we are creating a new database along with our
    new collection called `Events`. This new database will be named `EventsDB`. Now
    we can integrate this storage using the DocumentDB APIs in our Node.js program.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的截图，我们正在创建一个新的数据库以及名为`Events`的新集合。这个新数据库将被命名为`EventsDB`。现在我们可以使用Node.js程序中的DocumentDB
    API来集成这个存储。
- en: Wiring up DocumentDB, Moment.js, and Node.js
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接DocumentDB、Moment.js和Node.js
- en: Let's go back to our `whosoffchatbot` directory and install the `documentdb`
    package from npm. This is nothing but the Node.js SDK for Microsoft Azure's DocumentDB.
    It can be located at [https://www.npmjs.com/package/documentdb](https://www.npmjs.com/package/documentdb)
    .
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`whosoffchatbot`目录，并从npm安装`documentdb`包。这实际上是微软Azure DocumentDB的Node.js
    SDK。它可以在[https://www.npmjs.com/package/documentdb](https://www.npmjs.com/package/documentdb)找到。
- en: 'In order to install it, run this npm command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装它，运行以下npm命令：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While storing the meetings, we will consider the following JSON:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储会议时，我们将考虑以下JSON：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So when the meetings get added, it''ll be great if you generate a unique ID
    for each meeting, and the meeting information should get stored in DocumentDB.
    To generate these unique IDs, we will use the `guid` package. This can be located
    at [https://www.npmjs.com/package/guid](https://www.npmjs.com/package/guid) .
    Let''s install the `guid` package by using the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当会议被添加时，为每个会议生成一个唯一的ID将非常棒，并且会议信息应该存储在DocumentDB中。为了生成这些唯一ID，我们将使用`guid`包。这个包可以在[https://www.npmjs.com/package/guid](https://www.npmjs.com/package/guid)找到。让我们使用以下命令安装`guid`包：
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, all the timings for the meetings will be stored in Unix epoch or Unix
    time. This is done to simplify our storing process as well as query a meeting
    or event data with DocumentDB. So, to enable the conversion of dates to Unix epoch,
    we will use the npm package `moment`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有会议的时间都将存储在Unix纪元或Unix时间中。这样做是为了简化我们的存储过程以及使用DocumentDB查询会议或事件数据。因此，为了启用日期到Unix纪元的转换，我们将使用npm包`moment`：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Utility functions and Node.js
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 辅助函数和Node.js
- en: Considering the functionalities to be developed for this bot, I have decided
    to move some of the functionalities to be helper functions. These functions can
    be grouped under `utils.js`. Later, these functions will be called in our main
    Node.js file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个机器人将要开发的各项功能，我决定将一些功能移动到辅助函数中。这些函数可以归类到`utils.js`中。稍后，这些函数将在我们的主Node.js文件中被调用。
- en: 'Refer to the following code for `utils.js`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下代码以了解`utils.js`：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Looking at the preceding code, you may notice that the `isvalidateInput()` function
    mainly validates whether the user has entered the intended meeting information
    or not. If not, then the bot will help by providing sample meeting information
    while scheduling the meeting. This function mainly validates user input against
    the `Team Meeting@10:00to11:00` pattern.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的代码，你可能注意到 `isvalidateInput()` 函数主要验证用户是否已输入预期的会议信息。如果没有，那么在安排会议时，机器人将通过提供示例会议信息来提供帮助。此函数主要验证用户输入是否与
    `Team Meeting@10:00to11:00` 模式匹配。
- en: The functions `getFormattedTime()` and `getFormattedDay()` convert Unix epoch
    to human-readable date formats.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFormattedTime()` 和 `getFormattedDay()` 函数将 Unix 纪元转换为可读的日期格式。'
- en: The function `meeting()` is the constructor used during the creation of a new
    meeting based on the user's option.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`meeting()` 函数是在根据用户的选项创建新会议时使用的构造函数。'
- en: The `getUserName()` function helps in getting the Facebook user's name, based
    on the recipient ID or the user ID passed to the function. When we store meetings,
    we will also store the recipient ID as well as the meeting owner's name with the
    help of this function and the `meeting()`function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUserName()` 函数有助于根据传递给函数的接收者 ID 或用户 ID 获取 Facebook 用户的姓名。当我们存储会议时，我们也将使用此函数和
    `meeting()` 函数存储接收者 ID 以及会议所有者的姓名。'
- en: Wiring it all up together
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将所有这些连接起来
- en: Now that we have our utility or helper functions and the required Node.js packages
    in place, we are ready to finally integrate our bot in the right sense. Let's
    start with the breakdown of the code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的实用程序或辅助函数以及所需的 Node.js 包，我们终于可以正确地集成我们的机器人了。让我们从代码的分解开始。
- en: 'First, we will refer to all the npm modules and their instantiation for this
    bot implementation. This can be seen in the following code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将引用所有 npm 模块及其实例化，用于此机器人的实现。这可以在以下代码片段中看到：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will also establish a connection to the DocumentDB database from Azure using
    the following code snippet:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用以下代码片段建立与 Azure 中的 DocumentDB 数据库的连接：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have a Webhook set up in Facebook, and upon receiving a call to our Webhook,
    our bot should capture and send us the initial options. This can be achieved using
    the `sendMessageWithInitialOptions()` function from the following code snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Facebook 上设置了一个 Webhook，当我们的 Webhook 收到调用时，我们的机器人应该捕获并发送初始选项。这可以通过以下代码片段中的
    `sendMessageWithInitialOptions()` 函数实现：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So here, whenever a user posts `hi`, he or she will see the initial options
    to proceed further.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这里，每当用户发布 `hi` 时，他或她将看到进一步操作的初始选项。
- en: 'While scheduling a meeting as well, we expect the user to provide the meeting
    details in a specific format. Based on what the user has sent, we will validate
    the input and process it further with the help of the `processMeetingDetails()`
    function. This is achieved using the following code snippet:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在安排会议的同时，我们期望用户以特定格式提供会议详情。根据用户发送的内容，我们将验证输入并使用 `processMeetingDetails()` 函数进一步处理它。这是通过以下代码片段实现的：
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Based on the options shown to the user, when they respond, the response is
    captured in `event.postback.payload`. Based on what the user has selected to proceed
    further, we''ll execute the next options. This is done using the following code
    snippet:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 根据向用户显示的选项，当用户做出回应时，回应将被捕获在 `event.postback.payload` 中。根据用户选择进一步操作的内容，我们将执行下一个选项。这是通过以下代码片段完成的：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you look at the preceding code lines, you will see payloads captured as `SCHEDULE
    A MEETING`, `SCHEDULETODAY`, and so on. So when a user selects these options from
    the Messenger screen, a post back or a call goes to our Webhook and we get what
    the user has selected. The function `sendMessageWithScheduleOptions()` shows options
      to the user for scheduling a meeting either today or tomorrow.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看前面的代码行，你会看到捕获的负载作为 `SCHEDULE A MEETING`、`SCHEDULETODAY` 等等。所以当用户从 Messenger
    屏幕中选择这些选项时，会向我们的 Webhook 发送回执或调用，我们就能得到用户的选择。函数 `sendMessageWithScheduleOptions()`
    向用户显示选项，以便安排今天的会议或明天的会议。
- en: When a user responds to an option, Whos Off When, the Webhook is called and
    the function `sendMessageWithAllScheduleOptions()` gets executed to show the options
    to choose the day for which you would like to see who is busy and when. This again
    shows the options `Today` or `Tomorrow` to the end user on the screen. Based on
    the option selected by the user, the function `showWhosIsBusyWhen`() gets called
    with appropriate parameters to get the details of who is busy and when, meaning
    whose meetings are scheduled when.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户对“何时休息”的选项做出响应时，Webhook 被调用，并执行 `sendMessageWithAllScheduleOptions()` 函数来显示选择查看谁忙碌以及何时忙碌的选项。这再次在屏幕上向最终用户显示“今天”或“明天”的选项。根据用户选择的选项，`showWhosIsBusyWhen()`
    函数被调用，并带有适当的参数以获取谁忙碌以及何时忙碌的详细信息，即谁的会议在何时安排。
- en: While building this bot, we are not asking the user to key in or type in options;
    instead, we are showing options to choose from the screen. These options are nothing
    but structured message templates. We are using a button template and list template
    while showing the options and data to the end user.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个机器人时，我们没有要求用户输入或键入选项；相反，我们在屏幕上显示可供选择的选项。这些选项实际上就是结构化消息模板。在向最终用户展示选项和数据时，我们使用按钮模板和列表模板。
- en: 'One of the templates we are using in the function `sendMessageWithInitialOptions`()
    is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sendMessageWithInitialOptions()` 函数中，我们使用的一个模板如下：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding function generates a structured message with the help of a button
    template and using function `sendMessage()`, message with initial options are
    shown to end user.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数使用按钮模板和 `sendMessage()` 函数生成结构化消息，并将带有初始选项的消息显示给最终用户。
- en: 'On similar lines, we have the function `sendMessageWithScheduleOptions()`.
    This generates a structured message to show the options `Today` and `Tomorrow`
    so as to select when to schedule a meeting:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的思路下，我们有一个名为 `sendMessageWithScheduleOptions()` 的函数。这个函数生成一个结构化的消息，以显示“今天”和“明天”选项，以便选择何时安排会议：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To process meeting data and check whether there are any conflicts, the following
    function is used:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理会议数据并检查是否存在任何冲突，使用以下函数：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding function extracts the meeting details and passes them to check
    whether there are any conflicts. This function uses the utility function from
    `Utils.js` to get the username of the current user and check whether there are
    any meeting conflicts in relation to the current user. If there are no conflicts,
    then the meeting is scheduled with the help of the `CheckMeetingsIfExistsOrInsert()`
    function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数提取会议详情，并将它们传递给检查是否存在任何冲突。这个函数使用 `Utils.js` 中的实用函数来获取当前用户的用户名，并检查与当前用户相关的会议冲突。如果没有冲突，则使用
    `CheckMeetingsIfExistsOrInsert()` 函数安排会议：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function queries our DocumentDB-based database and checks whether any meeting
    is scheduled for that duration with the help of the `docclient.queryDocuments()`
    function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数查询我们的基于 DocumentDB 的数据库，并使用 `docclient.queryDocuments()` 函数检查在该时间段内是否已安排任何会议。
- en: If there are no meetings for the said duration, a new meeting is created using
    the `docclient.createDocument()` function. For a newly created meeting, the user
    who is scheduling a meeting is made the meeting owner by default.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在该时间段内没有会议，则使用 `docclient.createDocument()` 函数创建一个新的会议。对于新创建的会议，默认情况下，安排会议的用户成为会议的所有者。
- en: 'When a user selects an option for **Whos Off When**, the `showWhosIsBusyWhen()`
    function gets invoked and displays the information of all the meetings scheduled
    along with their owners and time slots:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择“何时休息”的选项时，`showWhosIsBusyWhen()` 函数被调用，并显示所有已安排会议及其所有者和时间段的信息：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Based on the passed dates, the scheduled meeting''s details are shown in a
    list along with their owners using the `sendMessageWithMeetingsOwnerInList`()
    function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传递的日期，使用 `sendMessageWithMeetingsOwnerInList()` 函数显示已安排会议的详情及其所有者，列表中包含：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding function generates a list of meetings using a generic template
    and displays them as cards.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数使用通用模板生成一系列会议，并将它们显示为卡片。
- en: 'I hope you now have an overall understanding of the code implementations we
    have done for this bot. Our final `server.js` should look as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你现在已经对为这个机器人所做的代码实现有一个整体的理解。我们的最终 `server.js` 应该如下所示：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running our bot - the Who's Off bot
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行我们的机器人 - 何时休息机器人
- en: Having understood the code implementation and assuming our final code is up
    and running on Microsoft Azure, let's look at how our bot is executed from the
    end user's perspective.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了代码实现并假设我们的最终代码已经在Microsoft Azure上运行之后，让我们从最终用户的视角来看一下我们的机器人是如何执行的。
- en: Initial options
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始选项
- en: 'Here are some initial options as in the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了初始选项：
- en: '![Initial options](img/image00372.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![初始选项](img/image00372.jpeg)'
- en: Scheduling a meeting
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安排会议
- en: 'When a user clicks on **Schedule a Meeting**, two options are sent by our bot,
    as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**安排会议**时，我们的机器人会发送两个选项，如下所示：
- en: '![Scheduling a meeting](img/image00373.jpeg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![安排会议](img/image00373.jpeg)'
- en: 'Now when the user clicks on **Tomorrow**, our bot will respond with some guiding
    text to the end user as **Pl. provide meeting details e.g. Team Meeting@10:00to11:00**:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当用户点击**明天**时，我们的机器人会向最终用户响应一些指导性文本，例如**请提供会议详情，例如Team Meeting@10:00to11:00**：
- en: '![Scheduling a meeting](img/image00374.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![安排会议](img/image00374.jpeg)'
- en: 'After receiving the guiding text, the user would enter the meeting details
    as `Team Meeting@10:00to11:00`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到指导性文本后，用户会输入会议详情，例如`Team Meeting@10:00to11:00`：
- en: '![Scheduling a meeting](img/image00375.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![安排会议](img/image00375.jpeg)'
- en: The bot checks for conflicts, and if no conflicts are found, the meeting is
    scheduled and the bot responds with the message **Meeting has been scheduled.**,
    as shown in the preceding screenshot.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人检查冲突，如果没有发现冲突，会议将被安排，并且机器人会以如前截图所示的“会议已安排”的消息进行响应。
- en: Whos Off When
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时休假
- en: When the user selects an option for **Whos Off When**, the following screen
    shows the options from which days, **Today** or **Tomorrow,** you would like to
    see who is off when.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择**何时休假**的选项时，以下屏幕显示了您希望查看哪一天（**今天**或**明天**）谁在休假的选项。
- en: '![Whos Off When](img/image00376.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![何时休假](img/image00376.jpeg)'
- en: 'If the user selects the option **Today**, the meetings for that day are shown
    as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户选择**今天**的选项，该天的会议将如下显示：
- en: '![Whos Off When](img/image00377.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![何时休假](img/image00377.jpeg)'
- en: 'The arrow on the right-hand side shows there are multiple meetings. Just scroll
    to the left to see the meetings, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的箭头显示有多个会议。只需向左滚动即可查看会议，如下所示：
- en: '![Whos Off When](img/image00378.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![何时休假](img/image00378.jpeg)'
- en: This way, we are showing who is busy when, based on the meetings scheduled by
    individual members.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们根据个人成员安排的会议显示谁在何时忙碌。
- en: 'So we have implemented our bot in a way that it can schedule our meetings and
    also show all our scheduled meetings in an elegant way within the Facebook Messenger
    interface. There is one more operation left: **My Schedule**. I will leave the
    implementation of this operation to you now.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们以这种方式实现了我们的机器人，使其能够安排我们的会议，并在Facebook Messenger界面中以优雅的方式显示所有安排的会议。还有一个操作尚未完成：**我的日程**。我现在将这个操作的实现留给你。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So with Facebook, we built a bot and enhanced our team's collaborative experience.
    With this bot, our team can just send the meeting details on a chat window to
    our bot, such as the name and start and end date, and the bot will take care of
    rest.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，利用Facebook，我们构建了一个机器人并增强了我们团队的协作体验。有了这个机器人，我们的团队只需将会议详情发送到聊天窗口中的机器人，例如名称和开始和结束日期，机器人就会处理其余的事情。
- en: To summarize, we learned how to create a Facebook Page and app. We also created
    a basic bot wired up in Node.js and deployed this basic bot to Microsoft Azure.
    We did this as Facebook Messenger needs an HTTPS-based Webhooks integration. Then,
    we subscribed to a page within Webhooks so that the messages that come from our
    bot pages could be accepted by our Node.js bot.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们学习了如何创建Facebook页面和应用。我们还创建了一个基于Node.js的基本机器人，并将其部署到Microsoft Azure上。我们这样做是因为Facebook
    Messenger需要一个基于HTTPS的Webhooks集成。然后，我们在Webhooks中订阅了一个页面，以便我们的机器人页面发送的消息可以被我们的Node.js机器人接受。
- en: Finally, we enhanced our bot to display information, such as who is off when,
    and displayed it within a Facebook Messenger interface.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们增强了我们的机器人以显示信息，例如谁在休假，并在Facebook Messenger界面中显示这些信息。
- en: We saw that the Who's Off bot with its little intelligence can check for a conflict
    and then scheduled a meeting accordingly. It can also present us with a team's
    schedule in a Facebook-compatible Messenger template format.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，拥有一定智能的“何时休假”机器人可以检查冲突，并据此安排会议。它还可以以Facebook兼容的Messenger模板格式向我们展示团队的日程。
- en: Further, if you would really like to develop intelligent bots, then it's worth
    taking a look at [https://wit.ai/](https://wit.ai/) and [https://api.ai/](https://api.ai/).
    These platforms enable us to develop chat bots that can understand humans in a
    better way.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你真的想开发智能机器人，那么查看 [https://wit.ai/](https://wit.ai/) 和 [https://api.ai/](https://api.ai/)
    是值得的。这些平台使我们能够开发能够更好地理解人类的聊天机器人。
- en: Hopefully, this chapter has given you an amazing experience of building Facebook
    Messenger bots!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一章已经给你带来了构建Facebook Messenger机器人的惊人体验！
- en: In the next chapter, we will explore how to develop IRC bots and how we can
    wire them up within Node.js and help our developers use it for bug-tracking purposes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何开发IRC机器人，以及我们如何在Node.js中连接它们，并帮助我们的开发者将其用于错误跟踪目的。
