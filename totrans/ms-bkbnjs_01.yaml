- en: Chapter 1. Architecture of a Backbone application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. Backbone 应用程序的架构
- en: One of the best things about Backbone is the freedom to build applications with
    the libraries of your choice, no batteries included. Note that Backbone is not
    a framework but a library; due to this, building applications with Backbone can
    be challenging as no structure is provided. You, as a developer, are responsible
    for code organization and how to wire the pieces of the code across the application;
    it's a big responsibility. Bad decisions can lead to buggy and unmaintainable
    applications that nobody wants to work with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 最好的特性之一是能够自由地使用你选择的库来构建应用程序，无需附带任何电池。请注意，Backbone 不是一个框架，而是一个库；因此，使用
    Backbone 构建应用程序可能会具有挑战性，因为它不提供任何结构。作为开发者，你负责代码的组织以及如何在应用程序中连接代码的各个部分；这是一项重大的责任。不良的决策可能导致存在缺陷且难以维护的应用程序，没有人愿意与之合作。
- en: Code organization on small Backbone applications is not a big deal. Create a
    directory for models, collections, and views; put a router for all possible routes;
    and write the business logic directly in the views. However, this way of developing
    Backbone applications is not suitable for bigger projects. There should be a better
    way to separate responsibilities and file organization in order to create maintainable
    applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在小型 Backbone 应用程序中进行代码组织并不是什么大问题。为模型、集合和视图创建一个目录；为所有可能的路由放置一个路由器；并将业务逻辑直接写入视图。然而，这种方式开发
    Backbone 应用程序并不适合大型项目。应该有更好的方法来分离责任和文件组织，以便创建可维护的应用程序。
- en: This chapter can be difficult to understand if you don't know Backbone at all;
    to understand the principles that are exposed here better, you will need to understand
    at least the basics of Backbone. Therefore, if you are a beginner in Backbone,
    I would encourage you to first understand what Backbone is and how it works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本不了解 Backbone，那么这一章可能会很难理解；为了更好地理解这里所展示的原则，你需要至少了解 Backbone 的基础知识。因此，如果你是
    Backbone 的初学者，我鼓励你首先了解 Backbone 是什么以及它是如何工作的。
- en: 'The goal of this chapter is to explore the best practices of project organization
    on two main levels: logic organization and file structure. In this chapter, you
    will learn the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是探讨在两个主要层面上的项目组织最佳实践：逻辑组织和文件结构。在本章中，你将学习以下内容：
- en: Delegating the right responsibilities to the objects provided by Backbone
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将适当的职责委托给 Backbone 提供的对象
- en: Defining plain JavaScript objects in order to deal with logic out of scope of
    Backbone objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义普通的 JavaScript 对象以处理超出 Backbone 对象作用域的逻辑
- en: Splitting the application in to small and maintainable scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序拆分为小型且易于维护的脚本
- en: Creating a clean file structure for your projects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的项目创建一个清晰的文件结构
- en: Subapplications based architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于子应用程序的架构
- en: We can compose a Backbone application with many independent subapplications.
    The subapplications should work independently. You can think about each one as
    a small Backbone application, with its own dependencies and responsibilities;
    it should not depend on other subapplications directly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用许多独立的子应用程序来组合一个 Backbone 应用程序。子应用程序应该独立工作。你可以将每个子应用程序视为一个小型 Backbone 应用程序，具有自己的依赖项和职责；它不应直接依赖于其他子应用程序。
- en: Subapplications should be focused on a specific domain area. For example, you
    can have a subapplication for invoices, another for the mailbox, and one more
    for payments; with these subapplications in place, you can build an application
    in order to manage payments through email.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 子应用程序应专注于特定的领域区域。例如，你可以有一个用于发票的子应用程序，另一个用于邮箱，还有一个用于支付；有了这些子应用程序，你可以构建一个应用程序来通过电子邮件管理支付。
- en: 'To decouple subapplications from each other, we can build an infrastructure
    application responsible for managing the subapplications, bootstrapping the whole
    application, and providing the subapplications with common functions and services:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使子应用程序相互解耦，我们可以构建一个负责管理子应用程序、启动整个应用程序以及为子应用程序提供公共功能和服务的应用程序基础设施：
- en: '![Subapplications based architecture](img/B01962_01_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![基于子应用程序的架构](img/B01962_01_01.jpg)'
- en: Figure 1.1\. Composition of a Backbone application with subapplications
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1\. 基于子应用程序的 Backbone 应用程序的组成
- en: You can use the infrastructure application to provide your subapplications with
    services such as confirmation and dialog messages, notification pop-ups, modal
    boxes, and so on. The infrastructure application does nothing by itself, it behaves
    as a framework for the subapplications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用基础设施应用程序为您的子应用程序提供诸如确认和对话框消息、通知弹出窗口、模态框等服务。基础设施应用程序本身不执行任何操作，它作为子应用程序的框架存在。
- en: When a subapplication wants to communicate with another subapplication, the
    infrastructure application can be used as a communication channel, it can take
    advantage of the `Backbone.Event` object in order to send and receive messages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当子应用程序想要与其他子应用程序通信时，可以使用基础设施应用程序作为通信通道，它可以利用 `Backbone.Event` 对象来发送和接收消息。
- en: In the following figure, you can see a scenario where the subapplications communicate
    through the infrastructure application. When the user clicks on **Compose message**
    in the Mailbox subapplication, the infrastructure application creates and renders
    the **Compose mail** subapplication and allows the user to write an e-mail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，您可以看到子应用程序通过基础设施应用程序进行通信的场景。当用户在邮箱子应用程序中点击**撰写消息**时，基础设施应用程序创建并渲染**撰写邮件**子应用程序，并允许用户撰写电子邮件。
- en: When the user is done, they have to click on the **Send** button in the **Compose**
    subapplication; then the e-mail is sent through a RESTful API or using plain SMTP,
    don't care, the important thing is that, when it finishes, it triggers an event
    in the `email:sent` infrastructure application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户完成操作后，他们必须在**撰写**子应用程序中点击**发送**按钮；然后电子邮件通过 RESTful API 或使用纯 SMTP 发送，不重要的是，重要的是，当它完成时，它会在
    `email:sent` 基础设施应用程序中触发一个事件。
- en: 'The infrastructure application forwards the event to the Mailbox subapplication,
    so that the list of emails that are sent can be updated. Another interesting thing
    is that the infrastructure application can use the `email:sent` event to show
    a successful pop-up message to the user to tell them that the email was successfully
    sent:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施应用程序将事件转发到邮箱子应用程序，以便更新已发送电子邮件的列表。另一个有趣的事情是，基础设施应用程序可以使用 `email:sent` 事件向用户显示一个成功的弹出消息，告诉他们电子邮件已成功发送：
- en: '![Subapplications based architecture](img/B01962_01_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![基于子应用程序的架构](img/B01962_01_02.jpg)'
- en: Figure 1.2\. Communication between subapplications
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2\. 子应用程序之间的通信
- en: Subapplication anatomy
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子应用程序结构
- en: As mentioned earlier, a subapplication is like a small Backbone application;
    they should be independent of other subapplications and work as a standalone.
    You should be able to put the Compose mail subapplication on a blank page without
    any other subapplication and still be able to send emails.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，子应用程序就像一个小型的 Backbone 应用程序；它们应该独立于其他子应用程序，并作为一个独立的应用程序运行。您应该能够在没有任何其他子应用程序的空白页面上放置撰写邮件子应用程序，并且仍然能够发送电子邮件。
- en: To achieve this, the subapplications should contain all the necessary objects
    that are to be auto-contained. You can see that the entry point of the subapplication
    is `Backbone.Router`. When the browser changes the URL and a route is matched
    for a given subapplication, the router creates a subapplication controller and
    delegates it the route handling.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，子应用程序应包含所有必要的对象，以便它们可以自动包含。您可以看到子应用程序的入口点是 `Backbone.Router`。当浏览器更改
    URL 并为特定子应用程序匹配到一个路由时，路由器创建一个子应用程序控制器并将其委托处理路由。
- en: The subapplication controller coordinates the models/collections and how they
    are shown. The controller can instruct the **Application** infrastructure to show
    a loading message while the data is fetched and when it's done, the controller
    can build the necessary views with the models and collections that are recently
    fetched in order to show them in the DOM.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 子应用程序控制器协调模型/集合以及它们的显示方式。控制器可以指示**应用程序**基础设施在数据检索时显示加载消息，并在完成后，控制器可以使用最近检索到的模型和集合构建必要的视图，以便在
    DOM 中显示。
- en: In short, a subapplication behaves exactly like a small Backbone application,
    with the main difference being that it uses the Application infrastructure to
    delegate common tasks and a communication channel between the subapplications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，子应用程序的行为与一个小型的 Backbone 应用程序完全相同，主要区别在于它使用应用程序基础设施来委托常见任务以及子应用程序之间的通信通道。
- en: 'In the next sections, we will examine how these parts are connected and I will
    show you the code for a working Contacts application. The following figure shows
    an anatomy view of a subapplication:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查这些部分是如何连接的，我会向你展示一个工作联系人应用的代码。以下图显示了子应用的结构视图：
- en: '![Subapplication anatomy](img/B01962_01_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![子应用结构](img/B01962_01_03.jpg)'
- en: Figure 1.3\. Anatomy of a subapplication
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3. 子应用结构
- en: Responsibilities of Backbone objects
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone 对象的责任
- en: One of the biggest issues with the Backbone documentation is not to have a clue
    about how to use its objects. You, as developers, should figure out the responsibilities
    for each object across the application; if you have some experience working with
    Backbone, then you would know how difficult it would be to build a Backbone application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 文档最大的问题之一是不知道如何使用其对象。作为开发者，你应该弄清楚应用程序中每个对象的责任；如果你有一些使用 Backbone 的经验，那么你就会知道构建
    Backbone 应用程序有多困难。
- en: In this section, I will describe the best uses of the Backbone objects. Starting
    at this point, you will have a clearer idea about the scope of responsibilities
    in Backbone and this will lead the design of our application architecture. Keep
    in mind that Backbone is a library with only the foundation objects; therefore,
    you will need to bring your own objects and structure to make scalable, testable,
    and robust Backbone applications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将描述 Backbone 对象的最佳用途。从这一点开始，你将对 Backbone 中责任的范围有一个更清晰的认识，这将引导我们应用架构的设计。记住，Backbone
    是一个仅包含基础对象的库；因此，你需要自己带来对象和结构，以创建可扩展、可测试和健壮的 Backbone 应用程序。
- en: Views
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The only responsibilities of views are to handle the **Document Object Model**
    (**DOM**) and listen for low-level events (jQuery/DOM events), and transform them
    into domain ones. The Backbone Views works closely with template engines in order
    to create markups that represent the information that is contained in models and
    collections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的唯一责任是处理 **文档对象模型** (**DOM**) 和监听低级事件（jQuery/DOM 事件），并将它们转换为领域事件。Backbone
    视图与模板引擎紧密合作，以创建代表模型和集合中包含的信息的标记。
- en: Views abstract the user interactions, transforming their actions into business
    value data structures for the application. For example, when a click event is
    triggered from a Save button in the DOM, the view should transform the event into
    something similar to a `save:contact` event using Backbone Events with the data
    written in the form. Then, a domain-specific object can apply some business logic
    to the data and show a result.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 视图抽象用户交互，将它们的操作转换为应用程序的业务价值数据结构。例如，当 DOM 中的保存按钮触发点击事件时，视图应将事件转换为类似于 `save:contact`
    事件，使用 Backbone Events 将表单中写入的数据。然后，一个特定领域的对象可以对数据进行一些业务逻辑处理，并显示结果。
- en: It is a rule that business logic on views should be avoided; however, basic
    form validations such as accept only numbers are allowed. Complex validations
    should still be done on the model or the controller.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是避免在视图中使用业务逻辑；然而，基本表单验证，如只接受数字，是允许的。复杂的验证仍然应该在模型或控制器上完成。
- en: Models
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: Backbone Models are like database gateways in the server side, their main use
    is to fetch and save data to and from a RESTful server and then provide an API
    to the rest of the application in order to handle the information. They can run
    general-purpose business logic, such as validation and data transformation, handle
    other server connections, and upload an image for a model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 模型在服务器端类似于数据库网关，它们的主要用途是从 RESTful 服务器获取和保存数据，然后为应用程序的其余部分提供一个 API 以处理信息。它们可以运行通用业务逻辑，例如验证和数据转换，处理其他服务器连接，并为模型上传图片。
- en: The models do not know anything about views; however, they can implement functionality
    that is useful for views. For example, you can have a view that shows the total
    of an invoice and the invoice model can implement a method that does the calculation,
    leaving the view without knowledge of the computation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模型对视图一无所知；然而，它们可以实现对视图有用的功能。例如，你可以有一个显示发票总额的视图，而发票模型可以实现一个执行计算的方法，使视图无需了解计算过程。
- en: Collections
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收藏
- en: You can think of Backbone Collections as a container of a set of Backbone Models,
    for example, a Collection of `Contacts` models. With a model, you can only fetch
    a single document at time; however, Collections allow us to fetch lists of Models.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Backbone集合视为一组Backbone模型的容器，例如，`Contacts`模型的集合。使用模型，你一次只能获取一个文档；然而，集合允许我们获取模型列表。
- en: A big difference from Models is that Collections should be used as read-only,
    they fetch the data but they should not write in the server; also it is not usual
    to see business logic here.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与模型相比，集合应该用作只读，它们获取数据但不应在服务器上写入；此外，在这里看到业务逻辑也不常见。
- en: Another use for Collection is to abstract RESTful APIs responses as each server
    has different ways to deal with a list of resources. For instance, while some
    servers accept a `skip` parameter for pagination, others have a `page` parameter
    for the same purpose. Another case is on responses, a server can respond with
    a plain array, while others prefer to send an object with a `data`, `list`, or
    other key, where the array of objects is placed. There is no standard way. Collections
    can deal with these issues, making server requests transparent for the rest of
    the application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的另一个用途是将RESTful API响应抽象化，因为每个服务器都有不同的方式来处理资源列表。例如，有些服务器接受`skip`参数用于分页，而其他服务器则有一个`page`参数用于相同的目的。另一个情况是在响应中，服务器可以返回一个纯数组，而其他服务器则更倾向于发送一个包含`data`、`list`或其他键的对象，其中对象数组被放置。没有标准的方式。集合可以处理这些问题，使服务器请求对应用程序的其他部分来说是透明的。
- en: Routers
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器
- en: 'Routers have a simple responsibility: listening for URL changes in the browser
    and transforming them into a call to a handler. A router knows which handler to
    call for a given URL. Also, they have to decode URL parameters and pass them to
    the handlers. The infrastructure application bootstraps the application; however,
    routers decide which subapplication will be executed. In this way, routers are
    a kind of entry point.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器有一个简单的职责：监听浏览器中的URL变化并将它们转换为对处理器的调用。路由器知道对于给定的URL应该调用哪个处理器。此外，它们还需要解码URL参数并将它们传递给处理器。基础设施应用程序启动应用程序；然而，路由器决定哪个子应用程序将被执行。因此，路由器是一种入口点。
- en: Objects not provided by Backbone
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone未提供对象
- en: It is possible to develop Backbone applications only using the Backbone objects
    that are described in the previous section; however, for a medium-to-large application,
    it's not sufficient. We need to introduce a new kind of object with delimited
    responsibilities that use and coordinate Backbone foundation objects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用前一小节中描述的Backbone对象来开发Backbone应用程序是可能的；然而，对于中型到大型应用程序来说，这还不够。我们需要引入一种具有明确职责的新对象，这些对象使用并协调Backbone基础对象。
- en: Subapplication façade
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子应用程序外观
- en: This object is the public interface of the subapplications. Any interaction
    with the subapplications should be done through its methods. The calls made directly
    to internal objects of the subapplication are discouraged. Typically, methods
    on this controller are called from the router; however, they can be called from
    anywhere.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象是子应用程序的公共接口。任何与子应用程序的交互都应该通过其方法来完成。直接调用子应用程序内部对象的调用是不被鼓励的。通常，此控制器上的方法是从路由器调用的；然而，它们也可以从任何地方调用。
- en: The main responsibility of this object is to simplify subapplication internals.
    Its main work is to fetch data from the server through models or collections and,
    if an error occurs during the process, it is responsible to show an error message
    to the user. Once the data is loaded in a model or collection, it creates a subapplication
    controller that knows the views which should be rendered and have the handlers
    deal with its events.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象的主要责任是简化子应用程序的内部结构。其主要工作是通过对模型或集合从服务器获取数据，如果在过程中发生错误，它负责向用户显示错误消息。一旦数据被加载到模型或集合中，它就创建一个子应用程序控制器，该控制器知道应该渲染哪些视图，并让处理器处理其事件。
- en: Subapplication controller
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子应用程序控制器
- en: A controller acts like an air traffic controller for views, models, and collections.
    When given a Backbone data object, it will instantiate and render the appropriate
    views and then coordinate them. On complex layouts, it is not an easy task to
    coordinate the views with the models and collections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器充当视图、模型和集合的空中交通控制器。当给定一个Backbone数据对象时，它将实例化和渲染适当的视图，然后协调它们。在复杂的布局中，协调视图与模型和集合并不是一件容易的事情。
- en: The Business logic for the use cases should be implemented here. The subapplication
    controller implements a **mediator pattern**, allowing other basic objects such
    as views and models keep it simple and loose coupling.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应在此处实现用例的业务逻辑。子应用控制器实现了一个**中介者模式**，允许其他基本对象，如视图和模型保持简单和松散耦合。
- en: Due to loose coupling reasons, a view should not directly call to methods or
    events of other views Instead of this, a view triggers events and the controller
    handles the event and orchestrates the views behavior if necessary. Note how views
    are isolated, handling just its owned portion of DOM and triggering events when
    required to communicate something.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于松散耦合的原因，视图不应直接调用其他视图的方法或事件。相反，视图触发事件，控制器处理事件并在必要时编排视图的行为。注意视图是如何隔离的，仅处理其拥有的DOM部分，并在需要通信时触发事件。
- en: Contacts application
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系人应用
- en: In this book, we will develop a simple contacts application in order to demonstrate
    how to develop Backbone applications following the principles explained throughout
    this book. The application should be able to list all the available contacts in
    RESTful API and provide the mechanisms to show and edit them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将开发一个简单的联系人应用来演示如何根据本书中解释的原则开发Backbone应用。该应用应能够列出所有可用的联系人，并通过RESTful
    API提供显示和编辑它们的机制。
- en: 'The application starts when the Application infrastructure is loaded in the
    browser and the `start()` method on it is called. It will bootstrap all the common
    components and then instantiate all the available routers in the subapplications:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在浏览器中加载应用程序基础设施并调用其上的`start()`方法时启动。它将引导所有通用组件，然后实例化子应用中所有可用的路由器：
- en: '![Contacts application](img/B01962_01_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![联系人应用](img/B01962_01_04.jpg)'
- en: Figure 1.4\. Application instantiates all the routers available in the subapplications
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4. 应用程序实例化子应用中所有可用的路由器
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The entry point of subapplication is given by its routes, which ideally share
    the same namespace. For instance, in the contacts subapplication, all the routes
    start with the `contacts/` prefix:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 子应用的入口点由其路由给出，理想情况下这些路由共享相同的命名空间。例如，在联系人子应用中，所有路由都以`contacts/`前缀开始：
- en: '`Contacts`: This lists all available contacts'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contacts`：列出所有可用的联系人'
- en: '`contacts/new`: This shows a form to create a new contact'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contacts/new`：显示一个表单来创建新的联系人'
- en: '`contacts/view/:id`: This shows an invoice given its ID'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contacts/view/:id`：根据其ID显示发票'
- en: '`contacts/edit/:id`: This shows a form to edit a contact'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contacts/edit/:id`：显示一个表单来编辑联系人'
- en: 'Subapplications should register its routers in the `App.Routers` global object
    in order to be initialized. For the Contacts subapplication, the `ContactsRouter`
    does the job:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 子应用应将其路由器注册到`App.Routers`全局对象中以便初始化。对于联系人子应用，`ContactsRouter`负责这项工作：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the user points its browser to one of these routes, a route handler is
    triggered. The handler function parses the URL and delegates the request to the
    subapplication façade:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将其浏览器指向这些路由之一时，会触发一个路由处理器。处理器函数解析URL并将请求委派给子应用门面：
- en: '![Contacts application](img/B01962_01_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![联系人应用](img/B01962_01_05.jpg)'
- en: Figure 1.5\. Route delegation to Subapplication Façade
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5. 路由委派到子应用门面
- en: 'The `startSubApplication()` method in the `App` object starts a new subapplication
    and closes any other subapplication that is running at a given time, this is useful
    to free resources in the user''s browser:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`对象中的`startSubApplication()`方法启动一个新的子应用并关闭在给定时间运行的任何其他子应用，这有助于在用户的浏览器中释放资源：'
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册以直接将文件通过电子邮件发送给您。
- en: The `App.mainRegion` attribute is an instance of a `Region` object that points
    to a DOM element in the page; regions are useful to render views in a contained
    region of the DOM. We will learn more about this object in [Chapter 2](ch02.html
    "Chapter 2. Managing Views"), *Managing views*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.mainRegion` 属性是一个指向页面中 DOM 元素的 `Region` 对象实例；区域对于在 DOM 的包含区域中渲染视图非常有用。我们将在[第
    2 章](ch02.html "第 2 章。管理视图")中了解更多关于这个对象的信息，*管理视图*。'
- en: 'When the subapplication is started, a façade method is called on it to handle
    the user request. The responsibility of the façade is to fetch the necessary data
    from the RESTful API and pass the data to a controller:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当子应用启动时，将对其调用外观方法来处理用户请求。外观的责任是从 RESTful API 获取必要的数据并将数据传递给控制器：
- en: '![Contacts application](img/B01962_01_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![联系人应用程序](img/B01962_01_06.jpg)'
- en: Figure 1.6\. Façade responsibility
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6\. 外观责任
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The façade object receives a region object as argument in order to indicate
    to the subapplication where it should be rendered. The `Region` objects will be
    explained in detail in [Chapter 2](ch02.html "Chapter 2. Managing Views"), *Managing
    views*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 外观对象接收一个区域对象作为参数，以指示子应用应在何处渲染。`Region` 对象将在[第 2 章](ch02.html "第 2 章。管理视图")中详细解释，*管理视图*。
- en: When the façade is fetching data from the RESTful server, a `loading:start`
    event is emitted on the `App` object in order to allow us to show the loading
    in progress view for the user. When the loading finishes, it creates and uses
    a controller that knows how to deal with the model or fetched collection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当外观从 RESTful 服务器获取数据时，会在 `App` 对象上发出 `loading:start` 事件，以便我们可以向用户显示正在进行的加载视图。当加载完成后，它创建并使用一个知道如何处理模型或获取的集合的控制器。
- en: 'The business logic starts when the controller is invoked, it will render all
    the necessary views for the request and show them to the user, then it will listen
    for user interactions in the views:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制器被调用时，业务逻辑开始，它将为请求渲染所有必要的视图并展示给用户，然后它将监听视图中的用户交互：
- en: '![Contacts application](img/B01962_01_07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![联系人应用程序](img/B01962_01_07.jpg)'
- en: Figure 1.7\. Controller creates the necessary views
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7\. 控制器创建必要的视图
- en: 'For the `ContactList` controller, here is a very simple code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ContactList` 控制器，以下是一段非常简单的代码：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function that handles the request is very simple and follows the same pattern
    for all other controllers, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 处理请求的功能非常简单，并且所有其他控制器都遵循相同的模式，如下所示：
- en: It creates all the necessary views with the model or collection that is passed
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用传递的模型或集合创建所有必要的视图
- en: It renders the views in a region of the DOM
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在 DOM 的一个区域中渲染视图
- en: It listens for events in the views
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它监听视图中的事件
- en: 'If you don''t entirely understand what region and layout means, don''t worry,
    I will cover the implementation of these objects in detail in [Chapter 2](ch02.html
    "Chapter 2. Managing Views"), *Managing views*. Here, the important thing is the
    algorithm described earlier:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全不理解区域和布局的含义，不要担心，我将在[第 2 章](ch02.html "第 2 章。管理视图")中详细解释这些对象的实现，*管理视图*。在这里，重要的是之前描述的算法：
- en: '![Contacts application](img/B01962_01_08.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![联系人应用程序](img/B01962_01_08.jpg)'
- en: Figure 1.8\. ContactList controller result
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8\. ContactList 控制器结果
- en: 'As you can see in the above figure, the contact list shows a set of cards for
    each contact in the list. The user is allowed to delete a contact by clicking
    on the **delete** button. When this happens, a `contact:delete` event is triggered,
    the controller is listening for the event and uses the `deleteContact()` method
    to handle the event:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，联系人列表为列表中的每个联系人显示一组卡片。用户可以通过点击**删除**按钮来删除联系人。当发生这种情况时，会触发 `contact:delete`
    事件，控制器正在监听该事件并使用 `deleteContact()` 方法来处理该事件：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The handler is pretty easy to understand, it uses the `askConfirmation()` method
    in the infrastructure app to ask for the user confirmation. If the user confirms
    the deletion, the contact is destroyed. The infrastructure App provides two methods
    to show notifications to the user: `notifySuccess()` and `notifyError()`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器很容易理解，它使用基础设施应用中的 `askConfirmation()` 方法来请求用户确认。如果用户确认删除，则联系人将被销毁。基础设施应用提供了两种方法向用户显示通知：`notifySuccess()`
    和 `notifyError()`。
- en: The cool thing about these App methods is that the controllers do not need to
    know the details about the confirmation and notification mechanisms. From the
    controller point of view, it just works.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 App 方法的一个优点是控制器不需要了解确认和通知机制的具体细节。从控制器的角度来看，它只是正常工作。
- en: 'The method that asks for the confirmation can be a simple `confirm()` call,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请求确认的方法可以是一个简单的`confirm()`调用，如下所示：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, in the modern web applications, using the plain `confirm()` function
    is not the best way to ask for confirmation. Instead, we can show a Bootstrap
    dialog box or use an available library for that. For simplicity, we will use the
    nice JavaScript `SweetAlert` library; however, you can use whatever you want:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现代Web应用程序中，使用普通的`confirm()`函数并不是请求确认的最佳方式。相反，我们可以显示一个Bootstrap对话框或使用可用的库。为了简单起见，我们将使用漂亮的JavaScript
    `SweetAlert`库；然而，你可以使用任何你想要的：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Contacts application](img/B01962_01_09.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![联系人应用程序](img/B01962_01_09.jpg)'
- en: Figure 1.9\. Using SweetAlert for confirmation messages
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9\. 使用SweetAlert进行确认消息
- en: 'We can implement the notification methods in a similar way. We will use the
    JavaScript `noty` library; however, you can use whatever you want:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以类似的方式实现通知方法。我们将使用JavaScript `noty`库；然而，你可以使用任何你想要的：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Contacts application](img/B01962_01_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![联系人应用程序](img/B01962_01_10.jpg)'
- en: Figure 1.10\. Using noty to show notification messages
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10\. 使用noty显示通知消息
- en: This is how you can implement a robust and maintainable Backbone application;
    please go to the GitHub repo for this book in order to see the complete code for
    the application. The views are not covered in the chapter as we will see them
    in detail in [Chapter 2](ch02.html "Chapter 2. Managing Views"), *Managing views*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以实现一个健壮且可维护的Backbone应用程序的方法；请访问本书的GitHub仓库，以查看应用程序的完整代码。由于我们将在[第2章](ch02.html
    "第2章。管理视图")中详细讨论，本章没有涵盖视图。
- en: File organization
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件组织
- en: 'When you work with MVC frameworks, file organization is trivial. However, Backbone
    is not an MVC framework, therefore, bringing your own file structure is the rule.
    You can organize the code on these paths:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与MVC框架一起工作时，文件组织是微不足道的。然而，Backbone不是一个MVC框架，因此，自己带来文件结构是规则。你可以按照这些路径组织代码：
- en: '`apps/`: This directory is where modules or subapplications live. All subapplications
    should be on this path'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apps/`：这个目录是模块或子应用程序所在的位置。所有子应用程序都应该在这个路径上'
- en: '`Components/`: These are the common components that multiple subapplications
    require or use on the common layout as a breadcrumbs component'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Components/`：这些是多个子应用程序需要或在使用公共布局时作为面包屑组件使用的通用组件'
- en: '`core/`: Under this path, we can put all the core functions such as utilities,
    helpers, adapters, and so on'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core/`：在这个路径下，我们可以放置所有核心功能，如工具、助手、适配器等'
- en: '`vendor/`: On vendor, you can put all third-party libraries; here you can put
    Backbone and its dependencies.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendor/`：在供应商下，你可以放置所有第三方库；这里你可以放置Backbone及其依赖项。'
- en: '`app.js`: This is the entry point of the application that is loaded from `index.html`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.js`：这是应用程序的入口点，从`index.html`加载'
- en: Subapplications can have a file structure as they are a small Backbone Application.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子应用程序可以有自己的文件结构，因为它们是小的Backbone应用程序。
- en: '`models/`: This defines the models and collections'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models/`：这定义了模型和集合'
- en: '`app.js`: This is the application façade that is called from the router'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.js`：这是从`index.html`加载的应用程序外观，由路由器调用'
- en: '`router.js`: This is the router of the application that is instantiated by
    the root application at bootstrap process'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.js`：这是由根应用程序在引导过程中实例化的应用程序路由器'
- en: '`contactList.js`, `contactEditor.js`, `contactViewer.js`: These are the controllers
    for the application'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contactList.js`、`contactEditor.js`、`contactViewer.js`：这些是应用程序的控制器'
- en: 'For a `contacts` application, the code organization can be as shown in the
    following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个`联系人`应用程序，代码组织可以像以下所示：
- en: '![File organization](img/B01962_01_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![文件组织](img/B01962_01_11.jpg)'
- en: Figure 1.11\. File structure
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11\. 文件结构
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We started by describing, in a general way, how a Backbone application works.
    It describes two main parts: a root application and subapplications. The root
    application provides a common infrastructure to other smaller and focused applications
    that we call subapplications.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先以一般的方式描述了Backbone应用程序的工作方式。它描述了两个主要部分：根应用程序和子应用程序。根应用程序为其他较小且专注的应用程序提供公共基础设施，我们称之为子应用程序。
- en: Subapplications should be loose coupled with other subapplications and should
    own its resources such as views, controllers, routers, and so on. A subapplication
    manages a small part of the system with a well-focused business value and the
    communication between subapplications and infrastructure application is made through
    an events-driven bus with `Backbone.Events`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 子应用应该与其他子应用松散耦合，并拥有自己的资源，例如视图、控制器、路由器等。子应用通过一个由`Backbone.Events`驱动的事件总线与基础设施应用进行通信，管理系统的一部分，具有明确的业务价值。
- en: The user interacts with the application using views that a subapplication renders.
    A subapplication controller orchestrates interaction between views, models, and
    collections and owns the business logic for the use case.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过子应用渲染的视图与应用程序进行交互。子应用控制器协调视图、模型和集合之间的交互，并拥有用例的业务逻辑。
- en: Finally, a file system organization explains the right sites to put your files
    and keep your project clean and organized. This organization does not follow an
    MVC pattern; however, it is powerful and simple. It encapsulates all the necessary
    code for a module in a single path (subapplication paths) instead of putting all
    the code across multiple paths.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，文件系统组织解释了放置文件的正确位置，以保持项目整洁和有序。这种组织不遵循MVC模式；然而，它强大且简单。它将模块的所有必要代码封装在单个路径（子应用路径）中，而不是将所有代码分散在多个路径上。
- en: In this way the structure of Backbone applications has been proven to be robust,
    a proof for this is that several open source applications such as TodoMVC follow
    (more or less) the principles exposed here. It facilitates the testability of
    the code due to separation of responsibilities so that each object can be tested
    separately.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，Backbone应用程序的结构已被证明是健壮的，这一点可以从遵循（或多或少）此处公开的原则的几个开源应用程序（如TodoMVC）中得到证明。由于职责分离，这有助于提高代码的可测试性，因此每个对象都可以单独进行测试。
- en: Large Backbone applications are often built on top of Backbone Marionette as
    it reduces the boilerplate code; however, Marionette uses its own conventions
    to work. If you are fine with it using its own conventions, you will be happy
    to use Marionette on top of Backbone.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 大型Backbone应用程序通常建立在Backbone Marionette之上，因为它减少了样板代码；然而，Marionette使用自己的约定来工作。如果您对使用自己的约定感到满意，那么您将很高兴在Backbone之上使用Marionette。
- en: However, if you love the freedom of doing things your way, you may prefer plain
    Backbone and create your own utilities and classes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您喜欢按照自己的方式做事的自由，您可能更喜欢纯Backbone，并创建自己的实用工具和类。
- en: In the next chapter, I will show you how to manage and organize views and simplify
    the complex layouts, identifying the common uses of the views. You will build
    general purpose views that will be useful for all your projects and forget about
    the implementation of the `render()` method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将向您展示如何管理和组织视图，简化复杂的布局，并识别视图的常见用法。您将构建通用视图，这些视图将对所有项目都有用，并且可以忘记`render()`方法的实现。
