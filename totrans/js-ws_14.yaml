- en: 14\. Understanding Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 理解函数式编程
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to use functional programming concepts
    such as pure functions, immutability, composition, and currying; use higher-order
    functions such as filter, map, and reduce; apply techniques such as cloning objects
    to reduce side effects in your code; and demonstrate strategies for reducing imperative
    logic and `for` loops in your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用纯函数、不可变性、组合和柯里化等函数式编程概念；使用如 filter、map 和 reduce 的高级函数；应用如克隆对象等技术以减少代码中的副作用；并展示减少代码中命令式逻辑和
    `for` 循环的策略。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we talked about how JavaScript is a multi-paradigm
    programming language. It's possible to write code with procedural, object-oriented,
    and functional design patterns. In this chapter, we'll look closely at the functional
    programming design pattern.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 JavaScript 是一种多范式编程语言。可以编写具有过程式、面向对象和函数式设计模式的代码。在本章中，我们将仔细研究函数式编程设计模式。
- en: Functional programming is a programming paradigm that has become popular in
    the last few years, though most JavaScript developers were unfamiliar with it
    before then.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种在最近几年变得流行的编程范式，尽管在此之前，大多数 JavaScript 开发者对它并不熟悉。
- en: JavaScript is not a purely functional language like some others, such as Haskell,
    Scheme, and Clojure. However, JavaScript has support for functional structures
    and techniques if you choose to use them. It is worthwhile becoming familiar with
    its concepts and gaining a working knowledge of how to use them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 并不像 Haskell、Scheme 和 Clojure 那样是一种纯粹的函数式语言。然而，如果你选择使用，JavaScript
    支持函数式结构和技巧。熟悉其概念并掌握如何使用它们是值得的。
- en: 'Functional programming has a set of features. Among others, here are some of
    the important ones:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程有一系列特性。其中，以下是一些重要的特性：
- en: Pure functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: Immutability and avoiding shared state, mutable data, and side effects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性和避免共享状态、可变数据和副作用
- en: Declarative rather than imperative
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式而非命令式
- en: Higher-order functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Function composition and piping
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合和管道
- en: Currying functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化函数
- en: Reduces the use of traditional flow control structures such as `for`, `while`,
    and even `if`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少了使用传统的流程控制结构，如 `for`、`while`，甚至 `if`
- en: These concepts will be covered over the course of this chapter. If implemented
    correctly, functional programming can result in code that is more predictable,
    less error-prone, and easier to test compared to other programming methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念将在本章中介绍。如果正确实现，函数式编程可以产生比其他编程方法更可预测、更少错误、更容易测试的代码。
- en: Pure Functions
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: Pure functions are one of the pillars of functional programming. A function
    is pure if it always returns the same result when it's given the same parameters.
    It also cannot depend on or modify variables or state outside of the function's
    scope.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是函数式编程的支柱之一。一个函数是纯的，如果它总是对相同的参数返回相同的结果。它也不能依赖于或修改函数作用域之外的变量或状态。
- en: 'A simple example of an impure function is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不纯函数的简单例子如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can plainly see how the function is manipulating a value outside of its
    scope in the `positionX` global variable. A pure function should only use the
    arguments that have been passed in for its logic, and should not directly modify
    them. Another issue is that the function doesn't actually return a value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到函数如何在其作用域之外操作一个值，即 `positionX` 全局变量。一个纯函数应该只使用传递给它的参数进行逻辑，而不应该直接修改它们。另一个问题是该函数实际上没有返回值。
- en: Consider the following code. Can you see why it would not be considered a pure
    function?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码。你能看出为什么它不被认为是纯函数吗？
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Though the function only reads the global variable value and does not manipulate
    the variable directly, it is still not pure. To see why think about what happens
    if you call the function multiple times with the value `5` for the `numSlots`
    parameter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该函数只读取全局变量的值，并没有直接操作该变量，但它仍然不是纯的。为了理解原因，考虑如果你多次以 `numSlots` 参数的值 `5` 调用该函数会发生什么：
- en: The first time, the result is `15` (since `positionX` is `10` and `10 + 5 =
    15`)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次，结果是 `15`（因为 `positionX` 是 `10`，`10 + 5 = 15`）
- en: The second time, the result would be `20`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次，结果将是 `20`
- en: The third time, the result would be `25`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次，结果将是 `25`
- en: In other words, there is a different result for each invocation. For the function
    to be pure, the result would have had to resolve to the exact same value for the
    given parameter value, that is, `5`. Also, consider how difficult it would be
    to write tests for this function since the result is not predictable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每次调用都会得到不同的结果。为了使函数纯净，结果必须对于给定的参数值解析为完全相同的值，即`5`。同时，考虑一下编写此函数测试的难度，因为结果是不可预测的。
- en: 'The correct way of making this function pure is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使此函数纯净的正确方法如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this version, all the data that the function uses in its logic is passed
    in as arguments, and it does not refer to any data outside of the function''s
    scope. It will also always have the same result for a set of given parameters:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，函数在逻辑中使用的所有数据都作为参数传递，它不会引用函数作用域之外的数据。它也将对于给定参数集始终产生相同的结果：
- en: If `x=10` and `numSlots=5`, the result will always be `15`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`x=10`且`numSlots=5`，结果将始终是`15`。
- en: If `x=15` and `numSlots=5`, the result will always be `20`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`x=15`且`numSlots=5`，结果将始终是`20`。
- en: If `x=20` and `numSlots=5`, the result will always be `25`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`x=20`且`numSlots=5`，结果将始终是`25`。
- en: The predictability of the result makes the code quality higher, makes it easier
    to reason about the function, and makes it easier to write tests. It also makes
    the code maintainable and less risky if the function ever needs to be refactored.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的可预测性使得代码质量更高，更容易对函数进行推理，也更容易编写测试。它还使得代码易于维护且风险较低，如果函数需要重构。
- en: Side Effects
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 副作用
- en: An important concept in functional programming that is closely related to pure
    functions is reducing side effects. A side effect is when a function performs
    some action, either directly or indirectly, that is not strictly for the purpose
    of the function or its return value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的一个重要概念是与纯净函数密切相关的是减少副作用。副作用是指函数执行某些操作，无论是直接还是间接的，这些操作并非严格为了函数或其返回值的目的。
- en: Examples of side effects are actions such as showing an alert box, writing to
    a file, triggering a service call on the network, or making changes to the DOM.
    (Actually, when we manipulated the global variable in the impure function example
    in the previous section, we were also creating a type of side effect known as
    the shared state.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用的例子包括显示警告框、写入文件、在网络上触发服务调用或更改DOM的操作。（实际上，当我们在上一个章节的纯函数示例中操作全局变量时，我们也在创建一种称为共享状态的副作用。）
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is not possible or desirable to create programs that have no side effects
    whatsoever. After all, what good is the program if you can't see the output in
    some way? However, functional programmers aim to create pure functions most of
    the time and isolate the functions and parts of the code that require output or
    side effects. Keeping such code separate helps you understand your software better
    for debugging, to create better tests, and to ease future maintenance and extensions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 完全没有副作用的程序是不可能的，也是不希望的。毕竟，如果你不能以某种方式看到输出，这个程序有什么用呢？然而，函数式程序员大多数时候的目标是创建纯净函数，并隔离需要输出或副作用的函数和代码部分。保持此类代码的分离有助于你更好地理解软件，以便进行调试、创建更好的测试，以及简化未来的维护和扩展。
- en: Immutability
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: Another concept in functional programming is to prefer immutable values and
    objects over mutable ones as much as possible. In short, immutable objects are
    those whose values cannot change once they are created, even if those objects
    are used. Going forward, we will perform a few exercises to demonstrate how certain
    objects such as strings and numbers are immutable, whereas arrays are not. We
    will begin with the immutability of strings in the following exercise.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的另一个概念是尽可能优先选择不可变值和对象而不是可变对象。简而言之，不可变对象是指一旦创建后其值就不能改变的值，即使这些对象被使用。接下来，我们将进行一些练习，以展示某些对象，如字符串和数字是不可变的，而数组不是。我们将从以下练习开始字符串的不可变性。
- en: 'Exercise 14.01: Immutable Values and Objects – Strings'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.01：不可变值和对象 – 字符串
- en: 'In this exercise, we will demonstrate how strings are immutable. Let''s get
    started:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将展示字符串是如何不可变的。让我们开始吧：
- en: In the Google Chrome browser, go to `Developer Tools` (go to the menu with the
    three dots at the upper-right of the screen | `More Tools` | `Developer Tools`,
    or just hit the *F12* key).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Google Chrome浏览器中，转到“开发者工具”（在屏幕右上角带有三个点的菜单中选择“更多工具”|“开发者工具”，或者直接按*F12*键）。
- en: 'JavaScript has several built-in immutable objects, such as strings. Create
    two constants, `string1` and `string2`, and assign the variable so that `string2`
    is a substring of `string1`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 有几个内置的不可变对象，例如字符串。创建两个常量 `string1` 和 `string2`，并将变量赋值，使得 `string2`
    是 `string1` 的子字符串：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Display both strings. Type the following into the console:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示两个字符串。在控制台中输入以下内容：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code results in the following output:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码产生以下输出：
- en: '![Figure 14.1: Output of strings'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.1：字符串的输出'
- en: '](img/C14377_14_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_14_01.jpg)'
- en: 'Figure 14.1: Output of strings'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：字符串的输出
- en: From this, you can see that the execution of `substring()` on `string1` did
    not change the value of `string1` in any way, demonstrating that the string is
    immutable. It actually results in a new string consisting of the characters of
    the partial string between the given indices. This result is then set as the value
    of the `string2` variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，你可以看到对 `string1` 执行 `substring()` 操作并没有以任何方式改变 `string1` 的值，这证明了字符串是不可变的。实际上，它产生了一个由给定索引之间的部分字符串字符组成的新字符串。然后，这个结果被设置为
    `string2` 变量的值。
- en: 'Exercise 14.02: Immutable Values and Objects – Numbers'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.02：不可变值和对象 – 数字
- en: Primitives such as numbers are also immutable. In this exercise, we will perform
    an operation on a number to demonstrate immutability in numbers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型，如数字，也是不可变的。在这个练习中，我们将对数字执行操作以演示数字的可变性。
- en: 'Create two constants, `number1` and `number2`, and assign them numeric values
    such that `number2` is half of the value of `number1`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个常量 `number1` 和 `number2`，并赋予它们数值，使得 `number2` 是 `number1` 值的一半：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Display both number objects. Type the following into the console:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中显示两个数字对象。输入以下内容：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code results in the following output:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码产生以下输出：
- en: '![Figure 14.2: Output of numbers'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.2：数字的输出'
- en: '](img/C14377_14_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_14_02.jpg)'
- en: 'Figure 14.2: Output of numbers'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：数字的输出
- en: We can see that performing a calculation with `number1` and setting the result
    to a new variable does not affect the original variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，对 `number1` 进行计算并将结果设置到新变量中不会影响原始变量。
- en: 'Exercise 14.03: Mutability – Arrays'
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.03：可变性 – 数组
- en: So far, we have looked at immutable objects. From this point on, we will look
    at examples of objects that do not have this immutability. In this exercise, we'll
    create an array and assign its values to another array, and then we'll modify
    its value to demonstrate how arrays are mutable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了不可变对象。从现在开始，我们将查看不具有这种不可变性的对象示例。在这个练习中，我们将创建一个数组并将其值赋给另一个数组，然后我们将修改其值以演示数组是如何可变的。
- en: 'Create and define `array1` so that it has three value elements, namely, `''one''`,
    `''two''`, and `''three''`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并定义 `array1`，使其具有三个值元素，即 `'one'`、`'two'` 和 `'three'`：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create another array, `array2`, with the value equal to `array1`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个数组 `array2`，其值等于 `array1`：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, append another element, `''four''`, to `array2`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向 `array2` 添加另一个元素 `'four'`：
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Display both outputs in the console, like so:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中显示两个输出，如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code results in the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码产生以下输出：
- en: '![Figure 14.3: Output of arrays'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.3：数组的输出'
- en: '](img/C14377_14_03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_14_03.jpg)'
- en: 'Figure 14.3: Output of arrays'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：数组的输出
- en: Here, we assigned the `array2` variable to the same array as `array1`, and then
    appended another element to `array2` (the value `'four'`). It may surprise you
    that `array1` is affected and gets the element added to it as well, unlike the
    other examples so far. This is because when the assignment is made to `array2,`
    it does not create a new array. Rather, it assigns only a reference that points
    to the original array, that is, `array1`. Manipulating either array would affect
    both of the variables as they are in fact the same array.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `array2` 变量赋值给与 `array1` 相同的数组，然后向 `array2` 添加另一个元素（值 `'four'`）。你可能感到惊讶，`array1`
    也会受到影响，并添加了相同的元素，这与之前的例子不同。这是因为当对 `array2` 进行赋值时，它并没有创建一个新的数组。相反，它只分配了一个指向原始数组的引用，即
    `array1`。操纵任一数组都会影响这两个变量，因为它们实际上是同一个数组。
- en: 'Exercise 14.04: Mutability – Objects'
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.04：可变性 – 对象
- en: In this exercise, we will assign values to properties in an object to demonstrate
    mutability in objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向对象属性赋值以演示对象的可变性。
- en: 'Create an object, `actor1`, with the properties `name` and `show`. Assign the
    value `Sheldon` and `BB Theory` to these properties:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 `name` 和 `show` 属性的对象 `actor1`。将这些属性赋值为 `Sheldon` 和 `BB Theory`：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, create another variable, `actor2`, and assign it to the same object as
    `actor1`. Then, also add a new property to `actor2` called `name`
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建另一个变量，`actor2`，并将其赋值给与`actor1`相同的对象。然后，也为`actor2`添加一个名为`name`的新属性
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Type the following into the console:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中输入以下内容：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code results in the following output:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码的结果如下：
- en: '![Figure 14.4: Output for objects'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.4：对象的输出'
- en: '](img/C14377_14_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.4：对象的输出'
- en: 'Figure 14.4: Output for objects'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：对象的输出
- en: As you can see, both the objects in the `actor1` and `actor2` variables end
    up being exactly the same. The `name` property is not only in `actor2`, as you
    might expect. This is once again because `actor2` is only a reference to `actor1`,
    and is not its own object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`actor1`和`actor2`变量中的对象最终都是完全相同的。`name`属性不仅存在于`actor2`中，正如你可能预期的。这又是由于`actor2`只是对`actor1`的引用，而不是它自己的对象。
- en: Another point is worth mentioning as well. In all these examples, the variables
    were defined as constants using the `const` keyword. However, as we have seen
    in the last two examples, we were able to make changes to the object and the compiler
    did not complain. This shows that the `const` keyword is *not* equivalent to saying
    the value is immutable!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的点。在所有这些例子中，变量都是使用`const`关键字定义为常量的。然而，正如我们在最后两个例子中看到的，我们能够修改对象，并且编译器没有报错。这表明`const`关键字并不等同于说值是不可变的！
- en: All `const` means is that the compiler prevents you from being able to reassign
    the variable to a new object. It does not restrict you from changing the properties
    of the assigned object or adding array elements, though.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`实际上意味着编译器阻止你将变量重新赋值给一个新的对象。但它并不限制你改变分配对象的属性或添加数组元素。'
- en: The next section will show you some strategies regarding how to handle mutable
    objects effectively.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示一些关于如何有效处理可变对象的方法。
- en: Cloning Objects and Arrays
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆对象和数组
- en: In the previous exercise, you saw how arrays and objects are mutable. What if
    you need to make modifications, though? How can you do this in a safe manner that
    avoids side effects?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，你看到了数组和对象是可变的。那么，如果你需要修改它们怎么办？你如何以安全的方式修改，避免副作用？
- en: First, there's a simple technique for arrays. If you are just adding an element
    to the array, you can use `Array.prototype.concat` rather than `Array.prototype.push`.
    The difference is that `concat` returns a new array copy with the element added,
    whereas `push` modifies the original array.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个简单的数组技术。如果你只是向数组中添加一个元素，你可以使用`Array.prototype.concat`而不是`Array.prototype.push`。区别在于`concat`返回一个包含新元素的新数组副本，而`push`则修改原始数组。
- en: 'We can see this in the following code. Here, `array1` and `array2` are now,
    in fact, distinct objects:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码中看到这一点。在这里，`array1`和`array2`现在实际上是不同的对象：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding code would be as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For other array modifications or to manipulate objects, you would usually need
    to clone the array or object and operate on the clone. How do you make clones,
    you ask? Here''s a neat trick: in newer JavaScript versions (since ECMAScript
    2018), the spread syntax works for both arrays and objects. Using the spread syntax,
    you can do the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他数组的修改或操作对象，你通常需要克隆数组或对象，并在克隆上进行操作。你可能会问，如何制作克隆？这里有一个小技巧：在较新的JavaScript版本中（自ECMAScript
    2018以来），展开语法对数组和对象都有效。使用展开语法，你可以做以下操作：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of `const actor1` will be as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`const actor1`的输出如下：'
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of `const actor2` will be as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`const actor2`的输出如下：'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that there are three consecutive dots in `[...array1]` and `{...actor1}`.
    These dots are known as spread operators. Using the spread syntax in this fashion
    effectively clones the array, or key-value pairs in the case of an object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在`[...array1]`和`{...actor1}`中有三个连续的点。这些点被称为展开运算符。以这种方式使用展开语法实际上会克隆数组，或者对象中的键值对。
- en: There is one caveat, though. This method only makes a shallow copy, which means
    only the top-level elements or properties are copied. Beyond the top level, only
    references are created. What this means is that, for example, multi-dimensional
    arrays or nested objects are not copied.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，有一个需要注意的地方。这种方法只进行浅拷贝，这意味着只有顶层元素或属性被复制。在顶层之上，只创建引用。这意味着，例如，多维数组或嵌套对象不会被复制。
- en: 'If a deep copy is required, one popular method is to convert the object into
    a JSON string and parse it right back, similar to the following code. This works
    for both objects and arrays:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要深拷贝，一个流行的方法是将对象转换为JSON字符串，然后再将其解析回来，类似于以下代码。这对对象和数组都有效：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The deep copy method also has the added benefit of working on older versions
    of JavaScript.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 深拷贝方法还有一个额外的优点，即它可以在较旧的JavaScript版本上工作。
- en: Sample Data for Examples and Exercises
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例数据和练习样本
- en: 'Before we go further, we need to introduce a scenario with sample data. In
    the upcoming sections, the following data will be used in the examples and exercises:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要介绍一个带有样本数据的场景。在接下来的章节中，以下数据将在示例和练习中使用：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is an array of objects that represents the results of runners in a 5 km
    race. The name, sex, age, and time are indicated for each runner in object fields.
    Time is recorded in seconds, allowing for easy minutes/seconds and pace calculations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示5公里赛跑跑步者结果的数组对象。每个跑步者的姓名、性别、年龄和时间都在对象字段中指示。时间以秒为单位记录，便于进行分钟/秒和配速计算。
- en: We will also define three helper functions to display the data. They will use
    some concepts that you may not be familiar with yet, particularly, arrow function
    notation and the `Array.prototype.map` method. But don't worry – these concepts
    will be covered in upcoming sections and they will become clear soon.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义三个辅助函数来显示数据。它们将使用一些你可能还不熟悉的概念，特别是箭头函数表示法和 `Array.prototype.map` 方法。但别担心——这些概念将在接下来的章节中介绍，并且很快就会变得清晰。
- en: 'The purpose of our first helper function is to format seconds into `MM:SS`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个辅助函数的目的是将秒数格式化为 `MM:SS`：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s understand the code in detail:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解一下代码：
- en: The `minsSecs` variable defines an arrow function with a `timeSeconds` input
    parameter.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minsSecs` 变量定义了一个带有 `timeSeconds` 输入参数的箭头函数。'
- en: For the minutes portion, the `Math.floor()` method removes the decimal part
    of the minutes when dividing seconds by 60, resulting in just a whole number integer.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于分钟部分，`Math.floor()` 方法在将秒数除以60时移除了小数部分，从而得到一个整数。
- en: For the seconds portion, the `Math.round()` method returns the number rounded
    to the nearest integer. (Note that we only wish to round fractional seconds. For
    the minute portion, it would not be correct to round.)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于秒数部分，`Math.round()` 方法返回四舍五入到最接近整数的数字。（注意，我们只想四舍五入小数秒。对于分钟部分，四舍五入是不正确的。）
- en: The `String.prototype.padStart` method pads the seconds value with a leading
    `0` if the value is less than 10\. The seconds themselves are calculated using
    the remainder operator, `%`, which returns any remainder value in the division.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.padStart` 方法在值小于10时，会在秒值前面填充一个前导 `0`。秒数本身是通过使用取余运算符 `%` 计算的，它返回除法中的任何余数值。'
- en: 'Our second helper function creates a string that prints the fields of the `runner`
    object in custom formats:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个辅助函数创建一个字符串，以自定义格式打印 `runner` 对象的字段：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s understand the code in detail:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解一下代码：
- en: Once again, arrow function syntax is used. The function is named `printRunner`
    and has a `runner` input parameter.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次使用箭头函数语法。该函数名为 `printRunner` 并有一个 `runner` 输入参数。
- en: An array of formatted strings is created, one for each field in the `runner`
    object.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个格式化字符串数组，每个字段对应一个 `runner` 对象。
- en: Lastly, all the string elements are joined together with a tab character separator
    by calling `Array.prototype.join('\t')`, resulting in nice columns when printed.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，通过调用 `Array.prototype.join('\t')` 将所有字符串元素使用制表符分隔符连接在一起，当打印时将形成整齐的列。
- en: 'The final helper function prints all the runners:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个辅助函数打印所有跑步者：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s go through the different parts of the above code in detail:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地分析上述代码的不同部分：
- en: 'The function is called `printRunners` and takes two parameters: an array of
    `runners`, and `listType`, which is a description of what type of list is being
    printed. It returns a string.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数名为 `printRunners` 并接受两个参数：一个 `runners` 数组和一个 `listType`，它描述了正在打印的列表类型。它返回一个字符串。
- en: '`Array.prototype.map` is used to form the runner details for printing.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.map` 用于形成打印的跑步者详细信息。'
- en: In short, the `Array.prototype.map` method iterates over every array element
    executes a callback function on them and results in a new array with the transformed
    values of each element. We'll explain how this works in detail later.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，`Array.prototype.map` 方法遍历数组的每个元素，对它们执行回调函数，并生成一个包含每个元素转换值的新数组。我们将在稍后详细解释这是如何工作的。
- en: But for now, the `Array.prototype.map` call here calls the `printRunner` function
    specified previously on each array element to get the formatted strings. Since
    the `printRunner` function only takes one parameter, in this case, it is not necessary
    to explicitly specify the parameter, since it is implied.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但目前，这里的`Array.prototype.map`调用会在每个数组元素上调用之前指定的`printRunner`函数，以获取格式化的字符串。由于`printRunner`函数只接受一个参数，在这种情况下，没有必要显式指定参数，因为它已经隐含了。
- en: The strings are then joined together with a newline character by calling `Array.prototype.join('\n')`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后通过调用`Array.prototype.join('\n')`将字符串与换行符连接起来。
- en: 'To print all the runners to the console, invoke it like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要将所有跑者打印到控制台，可以这样调用：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output will look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 14.5: Sample output of all the runners in the console'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.5：控制台所有跑者的示例输出'
- en: '](img/C14377_14_05.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_14_05.jpg)'
- en: 'Figure 14.5: Sample output of all the runners in the console'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：控制台所有跑者的示例输出
- en: Higher-Order Functions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Functions in JavaScript are first-class citizens. This means they can be passed
    as parameter values to other functions, or even assigned to a variable. This is
    one of the main characteristics that make JavaScript well-suited to the functional
    style of programming.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的函数是一等公民。这意味着它们可以作为参数值传递给其他函数，甚至可以分配给一个变量。这是使JavaScript非常适合函数式编程风格的主要特征之一。
- en: 'Higher-order functions are functions that operate on other functions. They
    can do this in one of three ways:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是操作其他函数的函数。它们可以通过以下三种方式之一来实现：
- en: If the function takes another function as an argument
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数接受另一个函数作为参数
- en: If the function returns another function as its result
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数返回另一个函数作为其结果
- en: In both of these ways
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这两种方式中
- en: In the previous chapters, we've already seen several higher-order functions,
    perhaps without you even realizing it. Remember the callback functions that get
    executed in response to DOM events, or the callbacks in *Chapter 10, Accessing
    External Resources*, which were called once the AJAX response was ready? These
    are all examples of higher-order functions since these functions are parameters
    that are passed into other functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到了几个高阶函数，可能你甚至没有意识到。记得响应DOM事件的回调函数，或者在*第10章，访问外部资源*中的回调函数，一旦AJAX响应就绪就会被调用？这些都是高阶函数的例子，因为这些函数是传递给其他函数的参数。
- en: 'The following sections will introduce three higher-order functions that are
    commonly used in functional programming: `Array.prototype.filter`, `Array.prototype.map`,
    and `Array.prototype.reduce`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将介绍在函数式编程中常用到的三个高阶函数：`Array.prototype.filter`、`Array.prototype.map`和`Array.prototype.reduce`。
- en: The Array.prototype.filter Method
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array.prototype.filter 方法
- en: The first function we will look at is the `Array.prototype.filter` method, which
    is simple. Given an existing array, `filter()` creates a new array with elements
    that fall under the specified criteria.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个函数是`Array.prototype.filter`方法，它很简单。给定一个现有数组，`filter()`会创建一个新数组，其中包含符合指定标准的元素。
- en: 'The syntax is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The callback function is called for each element of the array in turn. If the
    condition passes and the function returns `true`, the element is added to the
    new array. If the function returns `false`, the element is skipped and will not
    be added.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数会依次对数组的每个元素进行调用。如果条件通过且函数返回`true`，则该元素将被添加到新数组中。如果函数返回`false`，则该元素将被跳过，不会添加到数组中。
- en: Note that the return value is a new array. The original array is not impacted
    at all by this operation. In other words, it is not the case that items are filtered
    out and removed from the original array if they don't pass the condition. Rather,
    a new array is created with the elements that pass the test.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，返回值是一个新数组。原始数组完全不受此操作的影响。换句话说，如果项目不通过条件，则不会从原始数组中过滤并删除项目。相反，会创建一个新数组，其中包含通过测试的元素。
- en: 'The reason for creating a new array rather than modifying the existing one
    is due to the fundamental principles of functional programming you learned about
    earlier: immutability and avoiding side effects.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新数组而不是修改现有数组的原因是由于你之前学到的函数式编程的基本原则：不可变性和避免副作用。
- en: We will look at some examples of how `Array.prototype.filter` is used in the
    following section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中查看`Array.prototype.filter`的使用示例。
- en: A Refresher
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习
- en: Before we look at these examples, though, it is prudent for us to take a step
    back and review basic JavaScript function syntax and arrow function notation.
    This will ensure that you have a good grounding for what's to come. We will do
    this review by showing you different ways that the filtering function can be specified
    for `Array.prototype.filter`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们查看这些示例之前，我们审慎地退一步回顾基本的JavaScript函数语法和箭头函数表示法是明智的。这将确保你对即将到来的内容有一个良好的基础。我们将通过向您展示不同的方式来指定`Array.prototype.filter`的过滤函数来完成这项回顾。
- en: 'Say we wanted to filter the array of runners (presented earlier in this chapter)
    for only female runners. The most straightforward filtering function looks like
    this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要过滤本章前面提到的跑步者数组，只保留女性跑步者。最直接的过滤函数看起来像这样：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This filtering function would be called from another function that actually
    invokes `filter()` with the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤函数将从另一个函数中调用，该函数实际上使用以下代码调用`filter()`：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To make the function self-contained, it takes the `runners` array as a parameter.
    It is not good practice to require `runners` to be a global variable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使函数独立，它将`runners`数组作为参数。要求`runners`为全局变量并不是一个好的实践。
- en: Note that we only pass in the name of the filtering function, `femaleFilter`,
    as the argument, and not with parentheses, like `femaleFilter()`. We do not want
    the function to be executed right away, which is what would happen if there were
    parentheses. Rather, when a function is passed by name without parentheses, you
    are passing the function object itself. The `filter` method is a higher-order
    function that takes a callback function as its input, which requires the actual
    function object.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只传递过滤函数的名称`femaleFilter`作为参数，而不是像`femaleFilter()`那样带有括号。我们不希望函数立即执行，如果有括号就会发生这种情况。相反，当不带括号通过名称传递函数时，你实际上是在传递函数对象本身。`filter`方法是一个高阶函数，它接受一个回调函数作为输入，这需要实际的函数对象。
- en: 'The results of this filtering can be displayed with the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码显示此过滤的结果：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This code should be used to display the results of the following examples as
    well. The same results are expected for each example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用此代码显示以下示例的结果。每个示例都应期望得到相同的结果。
- en: 'We''ve done pretty well so far, but we could do better. As an alternative,
    the filtering function could be specified directly inline:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做得相当不错，但我们可以做得更好。作为替代方案，过滤函数可以直接内联指定：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can simplify this a bit more if we change the filtering test to a Boolean
    expression rather than explicitly returning `true` or `false` in an `if` statement:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将过滤测试改为布尔表达式，而不是在`if`语句中显式返回`true`或`false`，我们可以进一步简化这一点：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In newer versions of JavaScript, since ES6, this function can also be expressed
    more concisely using an arrow function expression:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的新版本中，自ES6以来，这个函数也可以使用箭头函数表达式更简洁地表示：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, note that this function has only one argument and a single `return`
    statement in its body. This allows us to make the code even more concise with
    the following one-liner, which omits the open/close brackets and the `return`
    keyword:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，这个函数只有一个参数，并且其主体中只有一个`return`语句。这使得我们可以用以下单行代码使代码更加简洁，该代码省略了开/闭括号和`return`关键字：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If desired, the filtering function can also be split into its own function
    and stored in a variable, since functions are first-class objects in JavaScript:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，过滤函数也可以拆分成它自己的函数并存储在一个变量中，因为函数在JavaScript中是一等对象：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Eliminating for Loops
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消除for循环
- en: 'The `Array.prototype.filter` function is a great demonstration of powerful
    functional programming techniques that are used to eliminate looping code, particularly
    the `for` loop. To get a feel of the potential pitfalls of the traditional `for`
    loop, consider the equivalent imperative code to filter female runners:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.filter`函数是强大函数式编程技术的绝佳演示，这些技术用于消除循环代码，特别是`for`循环。为了感受传统`for`循环的潜在陷阱，考虑过滤女性跑步者的等效命令式代码：'
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Compare this to the one-liner we saw in the previous section, which does the
    same thing:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与我们在上一节中看到的单行代码进行比较，它做的是同样的事情：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The imperative looping code requires the use of the looping variable, `i`. This
    introduces mutation of the state into our code and is a potential source of bugs.
    Even though, in this case, it is a local state, it is best to avoid the state
    in all situations when possible. At some point in the future, there is a risk
    that a variable will change for an unknown reason, producing an issue that's difficult
    to debug.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 强制性循环代码需要使用循环变量`i`。这会将状态突变引入我们的代码中，并可能成为错误的一个来源。尽管在这种情况下，它是一个局部状态，但在所有可能的情况下最好避免使用状态。在未来的某个时刻，存在一个风险，即变量会因未知原因而改变，从而产生难以调试的问题。
- en: With the functional equivalent, it is easier to see at a glance what the code
    does, is easier to test, and has more opportunity for potential reuse. It has
    no indentation, no loops, and the code is more concise and expressive.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式等价物，可以更直观地看到代码做了什么，更容易测试，并且有更多潜在的复用机会。它没有缩进，没有循环，代码更加简洁和表达性强。
- en: This also demonstrates how functional code is most often declarative rather
    than imperative. It specifies "what to do" (declarative) rather than the steps
    and flow of "how to do it" (imperative). In this example, the functional code
    simply says, "filter the array elements passed in the `runners` parameter where
    gender is female". Compare this to imperative code that requires multiple variables,
    statements, loops, and so on, which describes "how" rather than "what."
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这也展示了函数式代码通常是声明性的，而不是命令性的。它指定了“做什么”（声明性），而不是“如何做”的步骤和流程（命令性）。在这个例子中，函数式代码只是简单地说明了，“过滤掉`runners`参数中性别为女性的数组元素”。与此相比，命令性代码需要多个变量、语句、循环等，它描述的是“如何做”而不是“做什么”。
- en: In the upcoming sections, we will look at other array methods that eliminate
    loops as well, such as `Array.prototype.map` and `Array.prototype.reduce`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨其他消除循环的数组方法，例如`Array.prototype.map`和`Array.prototype.reduce`。
- en: The Array.prototype.map Method
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Array.prototype.map`方法'
- en: The array `map()` method is used when you want to transform array elements.
    It applies a function to every element of the calling array and builds a new array
    consisting of the returned values. The new array will have the same length as
    the input array, but each element's contents will be transformed (mapped) into
    something else.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想转换数组元素时，会使用`map()`数组方法。它将一个函数应用于调用数组的每个元素，并构建一个由返回值组成的新数组。新数组将与输入数组具有相同的长度，但每个元素的内部内容将被转换（映射）成其他内容。
- en: Say you wanted to calculate the average pace per mile of each runner of the
    5 km race. Our dataset provides a `timeSeconds` field, which is the total amount
    of time in seconds the runner needs to complete the full distance. There are also
    3.1 miles in 5 kilometers. Therefore, to get the pace per mile, you would divide
    the number of seconds by 3.1.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想计算5公里比赛中每位跑步者的平均配速。我们的数据集提供了一个`timeSeconds`字段，这是跑步者完成全程所需的总秒数。5公里中也有3.1英里。因此，要得到每英里的配速，你需要将秒数除以3.1。
- en: 'We can calculate the pace for all runners with the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码计算所有跑步者的配速：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code results in a new array with elements that have the `pace` value of
    the corresponding runner at the same index of the input array. In other words,
    the value of `paces[0]` corresponds to the runner in `runner[0]`, the value of
    `paces[1]` corresponds to the runner in `runner[1]`, and so on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成一个新数组，其元素具有与输入数组中相同索引的对应跑步者的`pace`值。换句话说，`paces[0]`的值对应于`runner[0]`中的跑步者，`paces[1]`的值对应于`runner[1]`中的跑步者，依此类推。
- en: 'The pace results can be printed to the console as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式将配速结果打印到控制台：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Exercise 14.05: Another Way of Using Array.prototype.map'
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.05：另一种使用Array.prototype.map的方法
- en: The results from the previous section in regards to mapping to an array of single-valued
    elements are useful as-is for some contexts, such as if you intend to subsequently
    calculate the sum or average of the values. This is okay when you just require
    the raw numbers and context isn't important. But what if you need more values
    or context for each element, such as the name of the runner that achieved the
    pace? This exercise shows another way we can use `Array.prototype.map` to achieve
    different results using the original dataset; for example, to get the calculated
    pace of each runner.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于映射到单值元素的数组的结果在前一节中是有用的，对于某些上下文来说，例如如果你打算随后计算值的总和或平均值。当你只需要原始数字且上下文不重要时，这是可以的。但如果你需要每个元素更多的值或上下文，比如达到特定配速的跑者的名字呢？这个练习展示了另一种我们可以使用
    `Array.prototype.map` 来使用原始数据集实现不同结果的方法；例如，获取每个跑者的计算配速。
- en: 'In the Google Chrome browser, go to `Developer Tools` (go to the menu with
    the three dots at the upper-right of the screen | `More Tools` | `Developer Tools`,
    or just hit the *F12* key):![Figure 14.6: Developer Tools in the Google Chrome
    browser'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Google Chrome 浏览器中，转到 `开发者工具`（点击屏幕右上角的三个点菜单 | `更多工具` | `开发者工具`，或者直接按 *F12*
    键）：![图 14.6：Google Chrome 浏览器中的开发者工具
- en: '](img/C14377_14_06.jpg)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_14_06.jpg)'
- en: 'Figure 14.6: Developer Tools in the Google Chrome browser'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.6：Google Chrome 浏览器中的开发者工具
- en: 'In the console, paste in the sample runner data (beginning with `const runners
    = [...]`) from the *Sample Data for Examples* section of this chapter:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台粘贴本章 *示例数据* 部分的样本跑者数据（以 `const runners = [...]` 开头）：
- en: '[PRE38]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the console, paste in the code for the `minsSecs()` helper function, also
    from the *Sample Data for Examples* section of this chapter:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台粘贴 `minsSecs()` 辅助函数的代码，也来自本章的 *示例数据* 部分：
- en: '[PRE39]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Type the following code into the console:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入到控制台：
- en: '[PRE40]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code shows a simple way of adding context to the array elements: rather
    than returning just a single value from the mapping function, an object with multiple
    fields can be returned instead that includes as many fields as desired. In this
    case, the object has the `name` and `pace` fields for each array element.'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码展示了向数组元素添加上下文的简单方法：而不是从映射函数中返回单个值，可以返回一个包含所需字段的对象。在这种情况下，对象为每个数组元素包含 `name`
    和 `pace` 字段。
- en: 'We can see the output by using the following code:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码查看输出：
- en: '[PRE41]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After running the preceding commands, your console log should look like the
    one shown in the following screenshot. Notice the list of names and paces at the
    bottom:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行前面的命令后，你的控制台日志应该看起来像下面的截图所示。注意底部的姓名和配速列表：
- en: '![Figure 14.7: Output of the name and pace fields'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.7：姓名和配速字段的输出'
- en: '](img/C14377_14_07.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_14_07.jpg)'
- en: 'Figure 14.7: Output of the name and pace fields'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.7：姓名和配速字段的输出
- en: You'll notice that we have all the same runners from the original data but without
    gender, age, or times in seconds. We've also added a new value called `pace`,
    which we created with the `getPacesWithNames` function.What if you want your array
    to contain elements with all the original fields and append an additional `pace`
    field?
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到我们有了原始数据中的所有相同的跑者，但没有性别、年龄或秒数。我们还添加了一个新的值 `pace`，这是通过 `getPacesWithNames`
    函数创建的。如果你想让你的数组包含所有原始字段并附加一个额外的 `pace` 字段怎么办？
- en: 'We could use the spread operator you learned about earlier. Type the following
    into the console:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用你之前学到的扩展运算符。在控制台输入以下内容：
- en: '[PRE42]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `...runner` spread syntax effectively clones all the key-value pairs in
    the object, adds them to the new mapped value, and displays the output. Add and
    run the `addPacesToRunners` function to your console.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`...runner` 扩展运算符有效地克隆了对象中的所有键值对，将它们添加到新的映射值中，并显示输出。将 `addPacesToRunners` 函数添加并运行到你的控制台。'
- en: Note
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Copies will be made of the fields. As before, we do not want to just modify
    the original object so that we can add the new field either, as this has the potential
    for side effects.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将会复制字段。和之前一样，我们不想仅仅修改原始对象以便添加新字段，因为这可能会产生副作用。
- en: 'The following code runs the function and displays the results in the console:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码运行函数并在控制台显示结果：
- en: '[PRE43]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once you run the `forEach()` function to iterate over the elements of the `pacesWithAllFields`,
    you should get a list of runners with all the original data, but in addition,
    there will be a new field for the average pace:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行 `forEach()` 函数来遍历 `pacesWithAllFields` 的元素，您应该得到一个包含所有原始数据的跑者列表，但除此之外，还将有一个新的平均配速字段：
- en: '![Figure 14.8: Results of addPacesToRunners with the pace field appended'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.8：添加配速字段后的 addPacesToRunners 结果'
- en: '](img/C14377_14_08.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_14_08.jpg)'
- en: 'Figure 14.8: Results of addPacesToRunners with the pace field appended'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：添加配速字段后的 addPacesToRunners 结果
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Do not use the spread technique if you expect your code to run in older browsers.
    Use alternatives such as `Object.assign()` to clone your fields. Here''s how `addPacesToRunners`
    could be coded for older environments:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您预计代码将在较旧的浏览器中运行，请不要使用展开技术。使用 `Object.assign()` 等替代方案来克隆您的字段。以下是 `addPacesToRunners`
    在较旧环境中编码的方式：
- en: '`const addPacesToRunners = runners => runners.map(runner =>`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`const addPacesToRunners = runners => runners.map(runner =>`'
- en: '`    Object.assign({}, runner, {pace: runner.timeSeconds / 3.1}));`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`    Object.assign({}, runner, {pace: runner.timeSeconds / 3.1}));`'
- en: Alternatively, transpilers such as Babel support the spread syntax, even in
    older browsers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，像 Babel 这样的转译器支持在较旧的浏览器中扩展语法。
- en: In this exercise, we looked at using the `Array.prototype.map` method and how
    we can use functional programming design patterns to combine functions to create
    complex results. We used `addPacesToRunners` in combination with `minsSecs` and
    `pacesWithNames` to print the pace of each runner in addition to the data from
    the original set. Importantly, we added the additional data value of pace without
    modifying the original dataset. Using the techniques in this exercise thus allows
    you to retain context when mapping values.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们探讨了使用 `Array.prototype.map` 方法以及如何使用函数式编程设计模式来组合函数以创建复杂的结果。我们结合了 `addPacesToRunners`、`minsSecs`
    和 `pacesWithNames` 来打印每个跑者的配速，以及原始数据集中的数据。重要的是，我们在不修改原始数据集的情况下添加了额外的配速数据值。因此，使用本练习中的技术可以在映射值时保留上下文。
- en: In the next section, we will learn about another array method, `reduce`, which
    allows us to take a set of values from an array and compute them into a single
    value.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习另一个数组方法 `reduce`，它允许我们从数组中取出一组值并将它们计算成一个单一值。
- en: The Array.prototype.reduce method
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array.prototype.reduce 方法
- en: Similar to `map()`, the array `reduce()` method operates on every element of
    an array. It is used when you need to compute a single value from them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `map()` 类似，数组 `reduce()` 方法作用于数组的每个元素。当您需要从它们计算出一个单一值时使用它。
- en: 'A simple example of this is if you need the sum of a collection of numbers:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是如果您需要一组数字的总和：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output of the preceding function will be as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数的输出将如下所示：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, the `reduce()` method takes two parameters: a combining function and
    a start value (0, in this case). It causes the combining function to be called
    repeatedly with each array element in turn, as it does in a `for` loop. For each
    invocation, the present element is passed as the `current` value, along with the
    `total` value so far (sometimes referred to as the accumulator).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`reduce()` 方法接受两个参数：一个组合函数和一个起始值（在这种情况下为 `0`）。它会导致组合函数依次与数组的每个元素一起调用，就像在
    `for` 循环中做的那样。对于每次调用，当前元素作为 `current` 值传递，同时传递到目前为止的 `total` 值（有时称为累加器）。
- en: The first time the combining function is invoked, `total` is the start value
    (`0`) and `current` is the first number in the array (`2`). The addition, that
    is, `total` `+` `current`, results in the value of `2`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用组合函数时，`total` 是起始值（`0`），而 `current` 是数组中的第一个数字（`2`）。加法运算，即 `total` `+`
    `current`，结果是 `2`。
- en: The second time the combining function is invoked, `total` is the result of
    the previous invocation (`2`) and `current` is the second number in the array
    (`4`). The addition, that is, `total` `+` `current`, results in `6`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用组合函数时，`total` 是上一次调用的结果（`2`），而 `current` 是数组中的第二个数字（`4`）。加法运算，即 `total`
    `+` `current`，结果是 `6`。
- en: 'This process is repeated for the remaining elements in the array until there
    are no elements remaining to process. Here is a simple table that shows the values
    at each invocation:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会重复进行，直到数组中剩余的元素都被处理。以下是一个简单的表格，显示了每次调用的值：
- en: '![Figure 14.9: Invocation value and their result'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.9：调用值及其结果'
- en: '](img/C14377_14_09.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_14_09.jpg)'
- en: 'Figure 14.9: Invocation value and their result'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：调用值及其结果
- en: 'Here is another visualization of this reduction process that may help you see
    it more clearly:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个可视化这个减少过程，可能有助于你更清楚地看到它：
- en: '![Figure 14.10: A depiction of the reduction process'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.10：减少过程的描述](img/C14377_14_10.jpg)'
- en: '](img/C14377_14_10.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_14_10.jpg)'
- en: 'Figure 14.10: A depiction of the reduction process'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：减少过程的描述
- en: 'Going back to using our `runners` dataset, here''s how you can use `reduce()`
    to compute the average pace of all runners. But first, recall the code from the
    previous section that used `map()` to calculate the pace for each runner and returned
    the results in a new array:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 回到使用我们的`runners`数据集，以下是如何使用`reduce()`计算所有跑者的平均配速。但首先，回忆一下上一节中使用的`map()`来计算每个跑者的配速，并将结果返回到一个新数组中的代码：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can use these paces to calculate the average with `reduce()`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些配速来使用`reduce()`计算平均值：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output of the `reduce()` function will be as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`函数的输出如下：'
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, in `reduce()`, we calculate the sum of all `pace` values using a similar
    technique as when we summed up the array of numbers. But there's one additional
    step. Rather than returning the sum, we divide it by the length of the array before
    returning the result.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`reduce()`中，我们使用与之前求和数组数字类似的技术计算所有`pace`值的总和。但有一个额外的步骤。我们不是返回总和，而是在返回结果之前将其除以数组的长度。
- en: 'Exercise 14.06: Grouping with Array.prototype.reduce'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.06：使用Array.prototype.reduce进行分组
- en: What if you wanted to calculate the average pace of all runners grouped by gender?
    We can do this with `reduce()`, but it is a bit more involved than the previous
    example. In this exercise, we'll implement one approach to grouping.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想计算按性别分组的所有跑者的平均配速呢？我们可以使用`reduce()`来实现，但这比之前的例子要复杂一些。在这个练习中，我们将实现一种分组方法。
- en: 'Unlike when we calculated the average of straight numbers, for group averages,
    we''ll need to do this in two steps: first, gather the sum and count of each gender,
    and then calculate the averages in a second step.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们计算直线数字的平均值不同，对于分组平均值，我们需要分两步进行：首先，收集每个性别的总和和计数，然后在第二步中计算平均值。
- en: 'The following outlines the approach for the summing and counting step:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下概述了求和和计数步骤的方法：
- en: Use an empty object (`{}`) as our starting value.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个空对象（`{}`）作为我们的起始值。
- en: When cycling through the array elements, get the group `sum` and `count` stats
    calculated so far for the gender of the current element. (If there are no stats
    for gender yet, create an empty group with `sum` and `count` set to `0`.)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当遍历数组元素时，获取当前元素性别的到目前为止的组`sum`和`count`统计数据。（如果还没有性别统计数据，则创建一个空的组，并将`sum`和`count`设置为`0`。）
- en: Add the pace of the current element to the group sum.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前元素的配速加到组总和中。
- en: Increase the count of the group by `1`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组的计数增加`1`。
- en: 'Here are the steps to do this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完成此操作的步骤：
- en: In the Google Chrome browser, go to Developer Tools (go to the menu with the
    three dots at the upper-right of the screen | `More Tools` | `Developer Tools`,
    or just hit the *F12* key).
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Google Chrome浏览器中，前往开发者工具（点击屏幕右上角的三个点菜单 | 更多工具 | 开发者工具，或者直接按*F12*键）。
- en: In the console, paste in the sample runner data (beginning with `const runners
    = [...]`) from the *Sample Data for Examples* section of this chapter.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中粘贴来自本章“示例数据”部分的样本跑者数据（以`const runners = [...]`开始）。
- en: In the console, paste in the code for the `minsSecs()` helper function, which
    is also from the *Sample Data for Examples* section of this chapter.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中粘贴来自本章“示例数据”部分的`minsSecs()`辅助函数的代码。
- en: 'We will make use of the `pacesWithAllFields` value from the example in the
    *Array.prototype.map()* section, which creates a new array with a calculated `pace`
    field added to each element. Type the following into the console:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用来自“Array.prototype.map()”部分的`pacesWithAllFields`值，该值创建了一个新数组，并为每个元素添加了一个计算出的`pace`字段。在控制台中输入以下内容：
- en: '[PRE49]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is the code for this first summing and counting step, which we
    outlined previously:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们之前概述的第一个求和和计数步骤的代码：
- en: '[PRE50]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point, the object that results from `sumPacesByGender` will have two
    keys that represent the gender values, that is, "`M`" and "`F`". The value for
    each is also an object, in which there are `pace` and `count` fields that contain
    the calculated stats for gender corresponding to the key.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，`sumPacesByGender`函数返回的对象将有两个键，代表性别值，即"`M`"和"`F`"。每个键的值也是一个对象，其中包含`pace`和`count`字段，它们包含与键对应的性别的计算统计数据。
- en: 'Displaying such objects in the JavaScript console is a bit clunky and unwieldy.
    A trick is in order: we''ll convert the object into formatted JSON text and display
    that instead. Type the following code into the console:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript控制台中显示这样的对象有点笨拙且难以操作。我们需要一个技巧：我们将对象转换为格式化的JSON文本并显示它。在控制台中输入以下代码：
- en: '[PRE51]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will output the JSON with a 4-space indentation:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将输出带有4个空格缩进的JSON：
- en: '[PRE52]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now that we have the sums and counts for each group determined, we can proceed
    to the second step and calculate the average of each group. We can do this by
    using `Object.keys()` to get an array with the keys of the object (that have the
    values "`M`" and "`F`") and then call `Array.prototype.map()` with a function
    to calculate the average for each gender. Type the following into the console:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经确定了每个组的总和和计数，我们可以进行第二步，计算每个组的平均值。我们可以通过使用 `Object.keys()` 获取一个包含对象键的数组（这些键具有值"`M`"和"`F`"），然后使用一个函数调用
    `Array.prototype.map()` 来计算每个性别的平均值。在控制台中输入以下内容：
- en: '[PRE53]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s write the code to display the output:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写代码来显示输出：
- en: '[PRE54]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output should be displayed as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应显示如下：
- en: '![Figure 14.11: Grouping the result of gender pace with Array.prototype.reduce'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11：使用 Array.prototype.reduce 对性别配速进行分组](img/C14377_14_11.jpg)'
- en: '](img/C14377_14_11.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11：使用 Array.prototype.reduce 对性别配速进行分组](img/C14377_14_11.jpg)'
- en: 'Figure 14.11: Grouping the result of gender pace with Array.prototype.reduce'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：使用 Array.prototype.reduce 对性别配速的结果进行分组
- en: This output allowed us to take a large number of data points and "reduce" them
    to a smaller amount of results in an efficient manner.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出使我们能够以有效的方式将大量的数据点“减少”为更少的结果。
- en: In this exercise, we looked at using the `Array.prototype.reduce` method for
    grouping. As in the previous exercise, we combined several functions to create
    a more complex result, without modifying the original dataset. First, we added
    the `pace` value for each entry in the set using `addPacesToRunners`, then we
    created a group sum for each gender with `groupSumPaceByGender`, and finally,
    we used `calcAvgPaceByGender` to get a value for the average pace for both males
    and females in the race.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们探讨了使用 `Array.prototype.reduce` 方法进行分组。与之前的练习一样，我们通过组合几个函数来创建一个更复杂的结果，而没有修改原始数据集。首先，我们使用
    `addPacesToRunners` 为集合中的每个条目添加了 `pace` 值，然后我们使用 `groupSumPaceByGender` 为每个性别创建了一个分组总和，最后，我们使用
    `calcAvgPaceByGender` 来获取比赛中男性和女性平均配速的值。
- en: In the next section, we'll talk about the concept of composition. We've used
    composition several times already in this chapter, that is, each time we combined
    smaller functions to create a larger process. However, we haven't looked at the
    concept specifically and spoken of its importance in the functional paradigm.
    We'll also look at the `pipe()` and `compose()` functions, which make combining
    functions in this way easier and more readable.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论组合的概念。在本章中，我们已经多次使用了组合，即每次我们通过组合较小的函数来创建一个更大的过程。然而，我们还没有具体探讨这个概念，也没有讨论它在函数式范式中的重要性。我们还将查看
    `pipe()` 和 `compose()` 函数，这些函数使得以这种方式组合函数变得更加容易和可读。
- en: Composition with compose() and pipe()
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `compose()` 和 `pipe()` 进行组合
- en: 'In the previous exercise, we saw that starting from the runners array, we required
    three different functions to calculate the average pace for each gender:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们看到从跑步者数组开始，我们需要三个不同的函数来计算每个性别的平均配速：
- en: '`addPacesToRunners`: This is used to calculate the pace per mile.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addPacesToRunners`: 这用于计算每英里的配速。'
- en: '`groupSumPaceByGender`: This is used to sum the pace of each gender.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupSumPaceByGender`: 这用于计算每个性别的配速总和。'
- en: '`calcAvgPaceByGender`: This is used to calculate the average pace for each
    gender.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calcAvgPaceByGender`: 这用于计算每个性别的平均配速。'
- en: 'Each function required the result of the one before it as input in order to
    do its job. Basically, it did the following, though it may not have been apparent
    up to this point:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都需要前一个函数的结果作为输入来完成其工作。基本上，它做了以下事情，尽管这一点可能直到现在还不明显：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is equivalent to the following, that is, using nested functions and removing
    the intermediate variables:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于以下，即使用嵌套函数并移除中间变量：
- en: '[PRE56]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is the idea of composition: that multiple simple functions are combined
    to build a more complex function. The result of each function is passed along
    to the next one.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是组合的概念：多个简单的函数组合起来构建一个更复杂的函数。每个函数的结果都传递给下一个函数。
- en: 'We can create high-order functions called `compose` and `pipe` to achieve function
    composition in a more general manner, though. Putting aside the actual implementation
    for a moment, let''s see how the functions would be used. With `compose`, the
    preceding nested functions would be written as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建称为`compose`和`pipe`的高阶函数，以更通用的方式实现函数组合。暂时不考虑实际的实现，让我们看看函数将如何被使用。使用`compose`，前面的嵌套函数可以这样编写：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This function would be used as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以这样使用：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output of the function would be as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的输出如下：
- en: '[PRE59]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that, perhaps counter-intuitively, the functions in `compose` are actually
    called in reverse order from how they are given in the parameter list, that is,
    right to left. So, the `addPacesToRunners` method is first invoked with the `runners`
    argument (even though it is the last function in the given list), then the results
    are passed to `groupSumPaceByGender`, and finally, those results are passed to
    `calcAvgPaceByGender`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可能有些反直觉，`compose`中的函数实际上是按照与参数列表中给出的相反的顺序调用的，即从右到左。因此，`addPacesToRunners`方法首先使用`runners`参数被调用（即使它是给定列表中的最后一个函数），然后结果传递给`groupSumPaceByGender`，最后这些结果传递给`calcAvgPaceByGender`。
- en: 'Many people find this function call order unnatural, though it is consistent
    with the order we called our nested functions above. The `pipe` function is similar
    to `compose`, but functions are composed in the opposite direction, left-to-right
    rather than the right-to-left. The `pipe` approach is more consistent with linear
    thinking: first, do A, then B, then C, and the functions to do A, B and C would
    be given in that order.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人发现这种函数调用顺序不自然，尽管它与我们在上面嵌套函数中调用的顺序一致。`pipe`函数与`compose`类似，但函数的组合方向相反，是从左到右而不是从右到左。`pipe`方法更符合线性思维：首先做A，然后做B，然后做C，而做A、B和C的函数将按此顺序给出。
- en: 'With `pipe`, the equivalent code would be:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pipe`，等效的代码如下：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Implementation of compose() and pipe()
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`compose()`和`pipe()`
- en: Now, let's look at one way we could actually implement these functions. The
    implementations are similar, but we'll start with `pipe` first as it is a bit
    easier to understand.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一种实际实现这些函数的方法。实现方式相似，但我们将首先从`pipe`开始，因为它更容易理解。
- en: 'It turns out to be a pretty straightforward implementation when using `Array.prototype.reduce`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Array.prototype.reduce`时，实现变得相当直接：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `pipe` function takes one or more functions passed in as parameters, which
    are converted into an array of functions with the spread operator, that is, `...fns`.
    Then, we apply `reduce` to the function array, starting by invoking the first
    function, `fn`, with the `input` argument passed in as `prev`. On the next invocation,
    the result of the first function is passed (as `prev`) and used as the parameter
    when calling the next function in the array. The rest of the functions in the
    array are processed in a similar fashion, with the result value of the final function
    returned.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe`函数接受一个或多个作为参数传递的函数，这些函数通过扩展运算符转换为函数数组，即`...fns`。然后，我们对函数数组应用`reduce`，首先使用`input`参数作为`prev`调用第一个函数`fn`。在下一次调用中，第一个函数的结果（作为`prev`）被传递并用作调用数组中下一个函数的参数。数组中的其余函数以类似的方式处理，最终函数的结果值被返回。'
- en: 'Note that this function can be simplified a bit by using `full fat-arrow` notation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个函数可以通过使用`full fat-arrow`符号稍微简化一下：
- en: '[PRE62]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As far as `compose` is concerned, recall that it is almost the same as `pipe`
    except that the order of functions is processed from right to left rather than
    left to right. Consequently, the implementation of `compose` is also basically
    the same, but rather than using `Array.prototype.reduce`, the sister function,
    `Array.prototype.reduceRight`, is utilized instead. The `reduceRight` function
    processes the array in reverse order from `reduce` and operates on the last element
    of the array first, then operates on the second to last element, and so on.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`compose`函数，回想一下，它几乎与`pipe`相同，只是函数的处理顺序是从右到左而不是从左到右。因此，`compose`的实现基本上也是相同的，但不是使用`Array.prototype.reduce`这个姐妹函数，而是使用`Array.prototype.reduceRight`。`reduceRight`函数从数组的末尾开始处理数组，首先操作数组的最后一个元素，然后操作倒数第二个元素，依此类推。
- en: 'Here''s the implementation of `compose`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`compose`函数的实现：
- en: '[PRE63]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Currying Functions
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数柯里化
- en: Currying is taking a function with multiple arguments and breaking it down into
    one or more additional functions that take just one argument and eventually resolve
    to a value. The initial function call does not take all the arguments but returns
    a function whose input is the remaining arguments and whose output is the intended
    result for all the arguments.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是将一个接受多个参数的函数分解为一个或多个接受单个参数的额外函数，这些函数最终会解析为一个值。初始函数调用并不接受所有参数，而是返回一个函数，该函数的输入是剩余的参数，其输出是所有参数的预期结果。
- en: 'That was a mouthful, so let''s look at an example. Say you have a simple `sum`
    function:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这段话有点长，让我们来看一个例子。假设你有一个简单的`sum`函数：
- en: '[PRE64]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s express this as a curried function in arrow notation:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个表达式写成箭头符号中的柯里化函数：
- en: '[PRE65]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that we have two levels of functions here, and each function takes one
    parameter. The first function takes one parameter, `a`, and returns another function,
    which takes the second parameter, `b`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有两层函数，每个函数都接受一个参数。第一个函数接受一个参数，`a`，然后返回另一个函数，该函数接受第二个参数，`b`。
- en: Note
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are having trouble seeing the two function levels, here''s an equivalent
    that may help:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现难以理解两个函数层级，这里有一个等效的表达可能有助于理解：
- en: function sum(a) {
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: function sum(a) {
- en: return function(b) {
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: return function(b) {
- en: return a + b;
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: return a + b;
- en: '};'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '};'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'You can also write it in arrow notation:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用箭头符号来写：
- en: '[PRE66]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To invoke this curried `sum` function with multiple arguments, you would need
    to use the following rather awkward syntax:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要用多个参数调用这个柯里化的`sum`函数，你需要使用以下相当笨拙的语法：
- en: '[PRE67]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This indicates to first call `sum` with the parameter value `3`, then call the
    function that is returned with the parameter `5`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着首先用参数值`3`调用`sum`，然后调用返回的函数，用参数`5`调用。
- en: But most often, you wouldn't invoke curried functions this way, and here's where
    the real utility of currying will become apparent. Typically, the functions will
    be called one at a time, which allows us to create intermediate functions that
    "remember" the parameter that's passed to it.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常情况下，你不会这样调用柯里化函数，这正是柯里化的真正用途所在。通常，函数会逐个调用，这允许我们创建中间函数，这些函数“记住”传递给它们的参数。
- en: 'For example, we can create the following intermediate functions:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建以下中间函数：
- en: '[PRE68]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Both the intermediate functions remember their parameter: `incrementByOne`
    holds onto the parameter value of `1` (as in `sum(1)`) and `addThree` remembers
    `3`. These functions are also referred to as `a` parameter was applied to them,
    but the actual result is not known until the returned function is invoked with
    the `b` parameter. (Note that partial application is not quite the same as a curried
    function, though, as partial applications can hold on to multiple parameters,
    whereas curried functions always take only one argument.)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个中间函数都记住了它们的参数：`incrementByOne`保留参数值`1`（如在`sum(1)`中），而`addThree`记住`3`。这些函数也被称为参数被应用到的函数，但实际结果只有在返回的函数用`b`参数调用时才知道。（注意，尽管部分应用与柯里化函数并不完全相同，因为部分应用可以保留多个参数，而柯里化函数始终只接受一个参数。）
- en: These are essentially new functions that could be potentially reused multiple
    times. They are also good candidates for `compose` or `pipe`, as these functions
    have only one parameter.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些本质上是可以被多次重用的新函数。它们也是`compose`或`pipe`的良好候选者，因为这些函数只有一个参数。
- en: 'Exercise 14.07: More Uses for Composition and Curried Functions'
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.07：组合和柯里化函数的更多用途
- en: In this exercise, you will further explore currying and composition. Most notably,
    you will see how you can create curried versions of common functions such as `Array.prototype.map`
    and `Array.prototype.filter` to compose other functions. In functional programming,
    common functions often need to be restructured so that they can be used as a building
    block for processing data in a chain of functions.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将进一步探索柯里化和组合。最值得注意的是，你将看到如何创建常见函数的柯里化版本，如`Array.prototype.map`和`Array.prototype.filter`，以组合其他函数。在函数式编程中，常见函数通常需要重构，以便它们可以作为函数链中处理数据的构建块。
- en: The exercise will once again use the `runners` dataset. You will create a function
    to scan the data and return the age of the oldest female runner. The challenge
    is to do this using composition with `compose` or `pipe`, thereby feeding the
    results of one function into the next one in the pipeline.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将再次使用`runners`数据集。你需要创建一个函数来扫描数据并返回最年长女跑者的年龄。挑战在于使用`compose`或`pipe`的组合来完成这个任务，从而将一个函数的结果传递给下一个函数。
- en: 'The basic outline of what we need to do is as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的基本轮廓如下：
- en: Create a function to filter the data just for female runners
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个仅针对女性跑者过滤数据的函数
- en: Create a function to map that data to just get the age of each runner
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数来映射这些数据，以获取每个跑者的年龄
- en: Create a function that uses `Math.max()` to get the highest age value
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用 `Math.max()` 获取最高年龄值的函数
- en: Compose the functions we've created so far and call them in sequence to get
    the final result
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们迄今为止创建的函数组合起来，并按顺序调用它们以获得最终结果
- en: 'The following steps show you how we do this in detail:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了我们如何详细地进行这项操作：
- en: Open the Chrome menu at the top-right of your browser window, then select `Tools`
    | `Developer Tools`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口的右上角打开 Chrome 菜单，然后选择 `工具` | `开发者工具`。
- en: Go to the console and paste in the sample runner data (beginning with `const
    runners = [...]`) from the *Sample Data for Examples* section of this chapter.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往控制台，粘贴本章 *示例数据* 部分的样本运行数据（以 `const runners = [...]` 开头）。
- en: 'First, create a curried version of `Array.prototype.filter`. Type the following
    into the console:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 `Array.prototype.filter` 的柯里化版本。在控制台中输入以下内容：
- en: '[PRE69]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, `fx` is the filtering function and `arr` is the array that is to be filtered.
    Note the ordering of the parameters, where the filtering function will be passed
    in before the array. This allows us to process the data itself as the last step.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，`fx` 是过滤函数，而 `arr` 是要过滤的数组。注意参数的顺序，过滤函数将在数组之前传递。这允许我们将数据处理本身作为最后一步。
- en: 'Similar to `filter`, you will need to create a curried version of `Array.prototype.map`.
    Type the following into the console:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 `filter` 类似，您需要创建一个 `Array.prototype.map` 的柯里化版本。在控制台中输入以下内容：
- en: '[PRE70]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, `fx` is the function to be called to map each array element, and `arr`
    is the array itself that is to be mapped to something else.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`fx` 是要调用的函数，用于映射每个数组元素，而 `arr` 是要映射到其他内容的数组本身。
- en: 'The next function we need to restructure is `Math.max()`, which returns the
    highest number of the parameters passed in. Type the following into the console:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个需要重构的函数是 `Math.max()`，它返回传入参数中的最大值。在控制台中输入以下内容：
- en: '[PRE71]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, `arr` is the array of numbers on which to find the max value. By default,
    `Math.max()` does not take an array as a parameter. However, by making use of
    the spread operator, that is, `...arr`, the individual array elements will be
    passed in as a series of parameters to `Math.max()` rather than as an array.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`arr` 是要找到最大值的数字数组。默认情况下，`Math.max()` 不接受数组作为参数。然而，通过使用扩展运算符，即 `...arr`，单个数组元素将被作为一系列参数传递给
    `Math.max()`，而不是作为数组。
- en: 'Type in the implementation of the compose function:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `compose` 函数的实现：
- en: '[PRE72]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You are ready for our first attempt at composing these functions together.
    Type the following into the console:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以尝试将这些函数组合在一起了。在控制台中输入以下内容：
- en: '[PRE73]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Remember that, with `compose`, the order of operations is from bottom to top.
    First, we have a filter function that picks out the female runners with the `runner.gender
    === "F"` expression. Next, we have a `map` function that *plucks* the `age` property
    from the female runners we resolved in the previous `filter` function and creates
    a new array with just the age values. Finally, `max` is called to obtain the oldest
    age from these values.
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，使用 `compose` 时，操作顺序是从下到上。首先，我们有一个选择女性跑者的过滤函数，使用 `runner.gender === "F"` 表达式。接下来，我们有一个
    `map` 函数，从之前 `filter` 函数中解析的女性跑者中 *提取* `age` 属性，并创建一个只包含年龄值的新数组。最后，调用 `max` 以从这些值中获得最大年龄。
- en: 'We now have all the functions composed, but we still haven''t actually run
    the array data through them to obtain the result. To do so, type the following
    into the console:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经组合了所有函数，但还没有实际运行数组数据通过它们来获得结果。为此，在控制台中输入以下内容：
- en: '[PRE74]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now print the result:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在打印结果：
- en: '[PRE75]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You will get an output stating that the oldest female runner is 39:'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将得到一个输出，说明最年长的女性跑者年龄为 39：
- en: '[PRE76]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This works, but there is a slight improvement that can be made for the `femaleFilter`
    portion. Why not make it into a reusable function? We can do this like so:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这方法是可行的，但可以对 `femaleFilter` 部分进行一些轻微的改进。为什么不将其制作成一个可重用的函数呢？我们可以这样做：
- en: '[PRE77]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Recall that `filter` was a curried function with two layers of parameters (`fx`
    and `arr`). Here, we are calling `filter` with the first parameter, `fx`, which
    results in a partially applied function. This `femaleFilter` function can now
    be used in any context, not just here.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回想一下，`filter`是一个具有两层参数（`fx`和`arr`）的柯里化函数。在这里，我们使用`filter`的第一个参数，`fx`，这会产生一个部分应用函数。这个`femaleFilter`函数现在可以在任何上下文中使用，而不仅仅是这里。
- en: 'Test the function by applying `femaleFilter` to compose the following:'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将`femaleFilter`应用于以下组合来测试该函数：
- en: '[PRE78]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You will get an output stating that the oldest female runner is 39 when using
    the `filter` function, which is as follows:'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`filter`函数时，你会得到一个输出，表明最年长的女性跑者是39岁，如下所示：
- en: '[PRE79]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Some people find the bottom-to-top order of processing confusing and unintuitive.
    Luckily, we have the `pipe` function, which functions the same as `compose` but
    in a top-to-bottom order. First, type in the implementation of the pipe function
    itself:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有些人发现从下到上的处理顺序令人困惑且不直观。幸运的是，我们有`pipe`函数，它的功能与`compose`相同，但顺序是从上到下。首先，输入`pipe`函数本身的实现：
- en: '[PRE80]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here is the equivalent using `pipe`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是使用`pipe`的等效实现：
- en: '[PRE81]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You will get the same output, that is, stating that the oldest female runner
    is 39 when using the pipe function, as follows:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用管道函数时，你会得到相同的输出，即表明最年长的女性跑者是39岁，如下所示：
- en: '[PRE82]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this exercise, we looked at composition and currying in more detail and how
    these can be used in tandem to complement each other. We used the curried version
    of `filter` to pass a filter for the runner's gender, passed the results to a
    `map` function to get only the `age` value, and finally used `Math.max` to find
    the highest value from the array of `age` values. While the previous exercise
    involved some aspects of combining simple functions into a more complex process,
    in this exercise, we actually used `compose` to create a new function that combined
    the subfunctions. This allows the new function, `oldestFemaleRunner1`, to be used
    by others without them having to consider the underlying subfunctions.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们更详细地研究了组合和柯里化，以及如何将这些结合起来相互补充。我们使用了`filter`的柯里化版本来传递一个针对跑者性别的过滤器，然后将结果传递给`map`函数以获取`age`值，最后使用`Math.max`从`age`值的数组中找到最高值。虽然前面的练习涉及了一些将简单函数组合成更复杂过程的部分，但在这次练习中，我们实际上使用了`compose`来创建一个新的函数，该函数结合了子函数。这使得新函数`oldestFemaleRunner1`可以被其他人使用，而无需考虑底层子函数。
- en: In the next section, we'll learn about recursive functions – another vital aspect
    of functional programming that is somewhat limited in the JavaScript programming
    language due to the lack of something called tail-call optimization, which is
    present in other functional programming languages.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习递归函数——这是函数式编程的另一个重要方面，但由于JavaScript编程语言缺乏尾调用优化（这在其他函数式编程语言中是存在的），因此在JavaScript编程语言中有所限制。
- en: Function Recursion
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数递归
- en: Another technique of functional programming involves functions calling themselves
    recursively. This generally means you start with a big problem and break it down
    into multiple instances of the same problem, but in smaller chunks each time the
    function is called.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的另一种技术涉及函数的自我递归调用。这通常意味着你从一个大问题开始，将其分解成多个相同问题的多个实例，但每次函数调用时，问题都变得更小。
- en: 'One common example of recursion is a function to reverse the characters of
    a string, `reverse(str)`. Think about how you can state this problem in terms
    of itself. Let''s say you have a string, `"abcd"`, and want to reverse it to `"dcba"`.
    Recognize that `"dcba"` can be restated as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的一个常见例子是反转字符串字符的函数，`reverse(str)`。思考一下如何用自身来表述这个问题。假设你有一个字符串，`"abcd"`，并想将其反转成`"dcba"`。认识到`"dcba"`可以重新表述如下：
- en: '[PRE83]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In other words, you are taking the input string and breaking it down into a
    smaller problem by taking off the first character and making a recursive call
    with the remaining characters of the string. This may be easier to see in the
    following code:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你正在通过移除第一个字符并将剩余字符串的递归调用作为更小的问题来分解输入字符串。以下代码可能更容易理解：
- en: '[PRE84]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s break this down:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: The `if` condition of `str.length == 1` is the base case. When the input has
    exactly one character, there is nothing left to reverse, so the solution is just
    the character itself.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.length == 1`的`if`条件是基本案例。当输入恰好有一个字符时，就没有东西可以反转了，所以解决方案就是字符本身。'
- en: Otherwise, use `String.slice()` with an index of `1` to get a new string minus
    the first character of the input. Use this as the input to make the recursive
    call to `reverse()`.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，使用 `String.slice()` 并以索引 `1` 为参数来获取一个新字符串，该字符串不包含输入的第一个字符。将这个字符串用作 `reverse()`
    的递归调用的输入。
- en: Return the result of the recursive call, plus the first character of the string
    (`str[0]`).
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回递归调用的结果，加上字符串的第一个字符（`str[0]`）。
- en: 'Here''s the step-by-step progression of calls:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是调用步骤的逐步进展：
- en: '[PRE85]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'It is important to realize that these function calls are nested on the internal
    execution stack. Once the base case of one character is reached, the recursion
    finally has an actual return value, which causes the stack to "unwind." When this
    happens, the innermost function returns a value, then the function before it,
    and so on in reverse order until execution propagates back to the first call.
    This results in the return values of `"d"` for the innermost function, followed
    by `"dc"`, `"dcb"`, and finally our expected result: `"dcba"`.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到这些函数调用在内部执行栈上是嵌套的。一旦达到一个字符的基例，递归最终有一个实际的返回值，这导致栈“展开”。当发生这种情况时，最内层的函数返回一个值，然后是它之前的函数，以此类推，直到执行回传到第一个调用。这导致最内层函数的返回值是
    `"d"`，然后是 `"dc"`，`"dcb"`，最后是我们预期的结果：`"dcba"`。
- en: Recursion could be useful as another technique for avoiding code that requires
    the mutation of state and looping. As a matter of fact, it is possible to code
    recursive implementations of almost any loop, and some purely functional programming
    languages have a preference for recursion. However, current JavaScript engines
    are not optimized for recursion, which puts a damper on this and limits its usefulness.
    It is too easy to write code that would result in slow performance and excessive
    memory consumption. (Future enhancements that would mitigate these problems have
    been proposed, but until then, you need to be very careful if you are considering
    using recursion in your programs.)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 递归可以作为避免需要状态突变和循环的代码的另一种技术。事实上，几乎任何循环都可以用递归实现，一些纯函数式编程语言更喜欢递归。然而，当前的JavaScript引擎并没有针对递归进行优化，这限制了它的用途。编写会导致性能缓慢和内存消耗过度的代码太容易了。（已经提出了可以缓解这些问题的未来增强功能，但在此之前，如果你考虑在程序中使用递归，需要非常小心。）
- en: 'Exercise 14.08: Creating a Deck of Cards Using reduce()'
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.08：使用 reduce() 创建一副扑克牌
- en: 'We''ve looked at the basic elements of functional programming in JavaScript
    and a few data processing examples with runner data. But dealing with data doesn''t
    have to be all number crunching – it can actually be fun. Take, for instance,
    a deck of cards, which in a way is simply a set of data values ordered in some
    way. In this exercise, we''re going to create a deck of cards by combining four
    functions: `suits`, `rankNames`, and `createOrderedDeck`.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了JavaScript中函数式编程的基本元素和一些使用runner数据的数据处理示例。但处理数据不必全是数字计算——实际上可以很有趣。以一副扑克牌为例，从某种意义上说，它只是以某种方式有序排列的数据值集合。在这个练习中，我们将通过组合四个函数：`suits`、`rankNames`
    和 `createOrderedDeck` 来创建一副扑克牌。
- en: 'Create a function called `suits` and another called `rankNames` to describe
    the suits and values of a deck of playing cards. Rather than being arrays, they
    are functions that return arrays:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `suits` 的函数和另一个名为 `rankNames` 的函数来描述一副扑克牌的花色和数值。它们不是数组，而是返回数组的函数：
- en: '[PRE86]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Create a function called ranks that takes the rankNames array as input and returns
    each rank mapped as a key-value pair.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ranks` 的函数，该函数接受 `rankNames` 数组作为输入，并返回每个点数映射为键值对。
- en: '[PRE87]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Create a function called `createOrderedDeck` that takes `suits` and `rank`
    as input and returns all the possible combinations (for example, every card in
    the deck):'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `createOrderedDeck` 的函数，该函数接受 `suits` 和 `rank` 作为输入，并返回所有可能的组合（例如，牌组中的每张牌）：
- en: '[PRE88]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We use `Array.prototype.reduce` with an empty array `[]` as the initial value.
    We then "iterate" over the `suits`, and use `Array.prototype.map` over the `ranks`
    to combine the suits and ranks by using the spread operator (`...`). The `Array.prototype.concat()`
    method then adds the new cards to the resulting array. Once the "nested loop"
    is complete, we end up with 52 unique cards with all the combinations of suits
    and ranks.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `Array.prototype.reduce` 并以空数组 `[]` 作为初始值。然后我们“迭代”`suits`，并使用 `Array.prototype.map`
    对 `ranks` 进行操作，通过使用扩展运算符 (`...`) 来组合花色和点数。然后 `Array.prototype.concat()` 方法将新牌添加到结果数组中。一旦“嵌套循环”完成，我们就得到了52张独特的牌，包含了所有花色和点数的组合。
- en: 'Next, we''ll create an instance of a deck of cards by creating a variable from
    the result of `createOrderedDeck` and our `suits` and `ranks` functions:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过从`createOrderedDeck`的结果以及我们的`suits`和`ranks`函数创建一个变量来创建一副牌的实例：
- en: '[PRE89]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To demonstrate what has been done so far, open up the Google Chrome browser,
    go to `Developer` Tools, and then paste in the preceding steps. After you''ve
    done that, type in `orderedDeck`. You should get an array like the one shown in
    the following screenshot. Try clicking on some of the items to look at the contained
    cards:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示到目前为止所做的工作，打开 Google Chrome 浏览器，转到`开发者工具`，然后粘贴前面的步骤。完成之后，输入`orderedDeck`。你应该得到一个类似于以下截图所示的数组。尝试点击一些项目来查看包含的牌：
- en: '![Figure 14.12: List of a deck of cards using the reduce function'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.12：使用`reduce`函数创建的牌堆列表'
- en: '](img/C14377_14_12.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_14_12.jpg)'
- en: 'Figure 14.12: List of a deck of cards using the reduce function'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12：使用`reduce`函数创建的牌堆列表
- en: In this exercise, we looked at the `reduce` function we learned about earlier
    in the chapter and applied it to the situation of creating a deck of cards. We'll
    build on this in the next exercise to create a function that shuffles a deck randomly,
    in a way that would make it useful for games.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们回顾了本章 earlier 学习到的`reduce`函数，并将其应用于创建牌堆的情况。我们将在下一个练习中在此基础上创建一个函数，该函数可以随机洗牌，这对于游戏来说非常有用。
- en: 'Exercise 14.09: Using the pipe Method to Create a Card Shuffling Function'
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.09：使用管道方法创建洗牌函数
- en: Now that we have an ordered deck of cards, we'll look at how we can shuffle
    it. Of course, as with all functional code, we'll do this without modifying any
    existing variables.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一副有序的牌，我们将看看我们如何可以洗牌。当然，就像所有功能性代码一样，我们将不修改任何现有变量来完成这个操作。
- en: 'Continuing in the same console as the previous exercise, define the `pipe`
    and `map` functions we discussed earlier. We won''t use `compose` here, but you
    should get into the habit of defining these three functions for each program when
    writing functional code as you''ll be using them a lot:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与上一个练习相同的控制台中，定义我们之前讨论的`pipe`和`map`函数。这里我们不会使用`compose`，但你应该养成在编写功能性代码时为每个程序定义这三个函数的习惯，因为你将大量使用它们：
- en: '[PRE90]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `addRandom` function adds a field called `random` to each element. Note
    how the random number itself is obtained from a separate `randomizer` method.
    This is to keep the `addRandom` function as pure as possible, and isolate the
    code that has side-effects.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addRandom`函数为每个元素添加一个名为`random`的字段。注意随机数本身是从一个单独的`randomizer`方法中获得的。这是为了尽可能保持`addRandom`函数的纯度，并隔离具有副作用代码。'
- en: 'Create a `randomizer` variable, followed by an `addRandom` curry function:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`randomizer`变量，然后创建一个`addRandom` curry函数：
- en: '[PRE91]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a `sortByRandom` function that sorts an input deck randomly:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`sortByRandom`函数，该函数可以随机排序输入的牌堆：
- en: '[PRE92]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This function sorts the cards by the added `random` field. The `spread` operator
    (...) is used to clone the array before sorting it, rather than sorting the original
    array.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数根据添加的`random`字段对牌进行排序。使用`spread`操作符(...)在排序之前克隆数组，而不是对原始数组进行排序。
- en: 'Create a `shuffle` function that takes a deck and a randomizer value (the randomizer
    can be changed later if there is a need for a more random value, as would be the
    case in real casino games). We then use `pipe` to create a function that combines
    `addRandom` *(to specify our randomizer)*, `sortByRandom`, and a `map` function.
    Finally, we''ll execute the `doShuffle` function we just created and use our deck
    of cards as the input:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`shuffle`函数，它接受一副牌和一个随机化值（如果需要更随机的值，可以在需要时更改随机化值，就像在真正的赌场游戏中那样）。然后我们使用`pipe`来创建一个函数，该函数结合了`addRandom`（用于指定我们的随机化器），`sortByRandom`和一个`map`函数。最后，我们将执行我们刚刚创建的`doShuffle`函数，并使用我们的牌堆作为输入：
- en: '[PRE93]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The purpose of the curried `map` function is to remove the `random` field that
    was added earlier and just preserve the original fields related to the card itself.
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: curried `map`函数的目的是移除之前添加的`random`字段，仅保留与牌本身相关的原始字段。
- en: 'Open up the Google Chrome `Developer Tools` session from the previous exercise.
    If you don''t have it saved, you''ll need to input the code from the previous
    exercise. At that point, input the preceding four code snippets from this exercise.
    With that, execute the `shuffle` function with `shuffle(orderedDeck, randomizer)`
    and then explore the returned object by clicking it and observing that the cards
    are shuffled, as shown in the following screenshot:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前练习中的 Google Chrome `开发者工具` 会话。如果您没有保存，您需要输入之前练习中的代码。到那时，输入本练习中的前四个代码片段。有了这些，执行
    `shuffle` 函数，使用 `shuffle(orderedDeck, randomizer)`，然后通过点击并观察以下截图来探索返回的对象，以查看牌已经被洗好：
- en: '![Figure 14.13: List of a deck of cards using the reduce function'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.13：使用 reduce 函数的牌组列表'
- en: '](img/C14377_14_13.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_14_13.jpg)'
- en: 'Figure 14.13: List of a deck of cards using the reduce function'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13：使用 reduce 函数的牌组列表
- en: We can see the shuffled lists of cards as using the `pipe and map` functions.
    We can now go ahead and use these functions to work on the Blackjack card game.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到洗好的牌组是使用 `管道和映射` 函数。现在我们可以继续使用这些函数来处理黑杰克牌局。
- en: Blackjack
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑杰克
- en: For the remainder of this chapter, we will be using what we've learned about
    functional programming to write an implementation of a simple variant of the card
    game Blackjack.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将使用关于函数式编程的知识来实现一个简单的纸牌游戏黑杰克。
- en: Unlike regular Blackjack, though, our game only has one player. The player can
    draw as many cards as they want (`hit`), as long as the total value does not exceed
    21.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与常规黑杰克不同，我们的游戏只有一个玩家。玩家可以抽取任意数量的牌（`抽牌`），只要总价值不超过 21。
- en: 'The total is the sum of the values of the cards in the player''s hand. Cards
    have the following values:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 总计是玩家手中牌的价值总和。牌有以下价值：
- en: Numeric cards have their face value (for example, a 6 of hearts has a value
    of 6)
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字牌有它们的面值（例如，红桃 6 的价值为 6）
- en: A Jack, Queen, or King has a value of 10
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: J、Q 或 K 的价值为 10
- en: For simplicity, the Ace is worth 1 (unlike regular Blackjack, where it has a
    value of either 1 or 11)
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化，A 牌的价值为 1（与常规黑杰克不同，在那里它可以是 1 或 11）
- en: If the total value exceeds 21, the hand has gone bust and the game is over.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总价值超过 21，则手牌爆牌，游戏结束。
- en: Mapping Card Values to Cards
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将牌面值映射到牌上
- en: 'The two previous exercises will be very useful in the final assignment, where
    you''ll be implementing a Blackjack game. Feel free to use those code snippets
    directly. Of course, it won''t be sufficient to know just the cards'' names –
    you''ll also want to know the value of each card. The `map` function we previously
    explored will come in very handy for this. Enhance the `ranks` currying function
    from *Exercise 8: Creating a Deck of Cards Using reduce* to convert `rankNames`
    into both `rank` and `value` fields:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个练习在最终作业中将会非常有用，在最终作业中，你将实现一个黑杰克游戏。你可以直接使用那些代码片段。当然，仅仅知道牌的名字是不够的——你还需要知道每张牌的价值。我们之前探索的
    `map` 函数将在这个任务中非常有用。增强 *练习 8：使用 reduce 创建牌组* 中的 `ranks` 柔性函数，将 `rankNames` 转换为
    `rank` 和 `value` 字段：
- en: '[PRE94]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This function takes advantage of the index passed in as the optional second
    parameter in the mapping function. The rank "`A`" is at index `0`, so the value
    resolves as `1` (since the formula is `index` + `1`). The rank "`2`" is at index
    `1`, so the value would resolve to `2` (since `index` + `1` = `2`). Same applies
    to the rest of the numbers, the value would resolve to the same as the number.
    Once we get to "`J`" and above, though, the value resolves to `10` due to `Math.min()`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数利用映射函数中作为可选第二个参数传递的索引。牌面值 "`A`" 在索引 `0`，所以值解析为 `1`（因为公式是 `索引` + `1`）。牌面值
    "`2`" 在索引 `1`，所以值解析为 `2`（因为 `索引` + `1` = `2`）。同样的规则适用于其他数字，值解析为与数字相同的值。一旦我们到达
    "`J`" 及以上，由于 `Math.min()`，值解析为 `10`。
- en: 'Now, enter `orderedDeck` and explore the object that is returned. You''ll notice
    that all the items now have a value, and the value for the face suits (`J`, `Q`,
    `K`) are all 10:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入 `orderedDeck` 并探索返回的对象。你会注意到现在所有项目都有一个值，面值牌（`J`、`Q`、`K`）的值都是 10：
- en: '![Figure 14.14: Ordered list of a deck of cards using the order function'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.14：使用排序函数的牌组有序列表'
- en: '](img/C14377_14_14.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_14_14.jpg)'
- en: 'Figure 14.14: Ordered list of a deck of cards using the order function'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14：使用排序函数的牌组有序列表
- en: With the functions we've now covered relating to cards using the basics of functional
    programming, that is, `map`, `reduce`, `compose`, and `pipe`, you will have a
    strong foundation for building your own card games.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们现在所涵盖的与卡片相关的函数，即函数式编程的基本原理，例如`map`、`reduce`、`compose`和`pipe`，你将为构建自己的卡片游戏打下坚实的基础。
- en: 'Activity 14.01: Blackjack Card Functions'
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 14.01：黑杰克卡片函数
- en: The aim of this activity is to get you to create some of the functions that
    are needed to code a Blackjack game with what you learned about functional programming.
    You will not be coding the whole game, just some of the core functions related
    to card logic.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是让你使用所学的函数式编程知识创建一些编写黑杰克游戏所需的函数。你将不会编写整个游戏，只是与卡片逻辑相关的核心函数。
- en: In the GitHub project, you'll find a pre-built HTML file `start.html` with some
    CSS in it that you should use as a starting point.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub项目中，你会找到一个预构建的HTML文件`start.html`，其中包含一些CSS，你应该将其作为起点使用。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的概要步骤如下：
- en: Open the starting point HTML/CSS file called `blackjack/start.html.`
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开名为`blackjack/start.html`的起始HTML/CSS文件。
- en: Add or implement the functions for creating a deck of cards using suits, rank
    names, and values.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加或实现使用花色、牌名和值创建一副牌的函数。
- en: Write implementations for the core functional programming methods, that is,
    `pipe`, `compose`, and `map`.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为核心的函数式编程方法编写实现，即`pipe`、`compose`和`map`。
- en: Add functions for drawing a card, getting the sum of a player's cards, checking
    whether a hand is over 21 points, and checking whether the game is over (the player
    stayed or went bust).
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加抽取一张牌、计算玩家牌的总和、检查手牌是否超过21点以及检查游戏是否结束（玩家选择停留或爆牌）的函数。
- en: Add a function for updating the card display and card images.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个更新卡片显示和卡片图像的函数。
- en: Add a function for updating the status display, which tells the user the sum
    of their hand.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个更新状态显示的函数，告诉用户他们手牌的总和。
- en: Add the `play`, `hit`, and `stay` handler functions for the different actions
    a user can take.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用户可以采取的不同操作的`play`、`hit`和`stay`处理函数。
- en: Finally, add any impure functions you may need, such as helpers for getting
    an element by ID or class.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加你可能需要的任何不纯函数，例如通过ID或类获取元素的辅助函数。
- en: Add a function for setting the state, as well as a function to trigger the game
    itself.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加设置状态和触发游戏的函数。
- en: 'With these steps done, you should now be able to open the HTML file in a browser
    and have a running version of the game, as shown in the following screenshot:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你现在应该能够打开HTML文件并在浏览器中运行游戏，如下面的截图所示：
- en: '![Figure 14.15: Screenshot of the Blackjack game'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.15：黑杰克游戏的截图'
- en: '](img/C14377_14_15.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_14_15.jpg)'
- en: 'Figure 14.15: Screenshot of the Blackjack game'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15：黑杰克游戏的截图
- en: Note
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 758.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第758页找到。
- en: Admittedly, this implementation of Blackjack is not very playable and won't
    win awards for visual design. However, it is a great demonstration of functional
    programming. See if you can use this code as a basis to implement your own full
    two-player version of the game.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，这个黑杰克的实现并不太好玩，也不会因为视觉设计而获奖。然而，它是一个很好的函数式编程演示。看看你是否可以用这段代码作为基础来实现你自己的完整两人版本的游戏。
- en: Managing Blackjack Game State
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理黑杰克游戏状态
- en: 'This game only requires a small amount of state: namely, the player''s hand,
    the game deck, and if the player has selected to stay (and not ask for another
    card). This state management is isolated to the following code:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏只需要少量状态：即玩家的手牌、游戏牌组和玩家是否选择停留（而不是再抽一张牌）。这种状态管理被隔离到以下代码中：
- en: '[PRE95]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Notice the `return` statement at the end. Only the two methods `getState` and
    `setState` end up being exposed to the caller, but the `_state` variable remains
    safe in the closure and acts as the equivalent of a "private" field in object-oriented
    programming. In addition:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后的`return`语句。只有两个方法`getState`和`setState`最终暴露给调用者，但`_state`变量仍然在闭包中保持安全，并作为面向对象编程中“私有”字段的等价物。此外：
- en: To isolate the code that produces side-effects as much as possible, there is
    a separate parameter `dom` that has references to other functions that actually
    do DOM manipulation.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了尽可能隔离产生副作用（side-effects）的代码，有一个单独的参数`dom`，它引用了实际进行DOM操作的其它函数。
- en: The `getState` function returns a clone of the state fields (using the spread
    operator ...), not the actual values in the fields
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState` 函数返回状态字段的克隆（使用扩展运算符 ...），而不是字段中的实际值'
- en: When `setState` is called, two other functions `updateCardDisplay` and `updateStatusDisplay`
    are called (presented soon) to update the respective portions of the display to
    correspond to the new state. These functions are designed to dynamically regenerate
    all the HTML related to the state values each time the state changes. his way
    there is no additional state needed in the display logic itself. (Popular web
    frameworks like Angular and React update displays in much the same way, though
    with some optimizations for the sake of performance).
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 `setState` 时，会调用另外两个函数 `updateCardDisplay` 和 `updateStatusDisplay`（即将介绍）来更新显示的相应部分以对应新的状态。这些函数被设计为每次状态改变时动态重新生成所有与状态值相关的HTML。这样，在显示逻辑本身中就不需要额外的状态。（流行的Web框架如Angular和React以类似的方式更新显示，尽管为了性能进行了一些优化）。
- en: 'The state is created at the start of the game:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是在游戏开始时创建的：
- en: '[PRE96]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Blackjack Game Logic Flow
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑杰克游戏逻辑流程
- en: 'The `startGame` function itself registers three event handling functions to
    respond to the three buttons the user may click: `New Game`, `Hit` or `Stay`:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`startGame` 函数本身注册了三个事件处理函数来响应用户可能点击的三个按钮：“新游戏”、“击中”或“停留”：'
- en: '[PRE97]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `playHandler` function looks like this:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`playHandler` 函数看起来如下：'
- en: '[PRE98]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: First the deck is created and shuffled to create the full game deck. Two cards
    are then drawn from the game deck as the hand. The hand and remaining game deck
    (minus the two cards drawn) are saved by calling `setState` (which indirectly
    also triggers the screen to display the cards).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建并洗牌以创建完整的游戏牌组。然后从游戏牌组中抽取两张牌作为手牌。通过调用 `setState` 保存手牌和剩余的游戏牌组（减去抽取的两张牌）（这间接也触发了屏幕显示牌）。
- en: 'The `hitHandler` function follows a similar pattern:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`hitHandler` 函数遵循类似的模式：'
- en: '[PRE99]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The current hand and game deck is retrieved by calling `getState`. Then one
    card is drawn from the game deck. This card is added to the hand and saved by
    calling `setState` (which once again indirectly also triggers the screen to display
    the cards).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `getState` 获取当前手牌和游戏牌组。然后从游戏牌组中抽取一张牌。这张牌被添加到手牌中并通过调用 `setState` 保存（这再次间接触发屏幕显示牌）。
- en: 'The `stayHandler` is simpler. It doesn''t make any state modifications besides
    calling `setState` with `true` in the last parameter, indicating the player has
    stayed:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`stayHandler` 较简单。除了在最后一个参数中调用 `setState` 并传入 `true` 以指示玩家已停留外，不进行任何状态修改：'
- en: '[PRE100]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Blackjack Game Display Functions
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑杰克游戏显示函数
- en: 'The `updateCardDisplay` function is the following:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateCardDisplay` 函数如下：'
- en: '[PRE101]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The HTML for each card in the hand is determined in this function using `Array.prototype.map`
    and joined together at the end to make one string. The calculations for the styles
    `top` and `left` take advantage of the optional `index` parameter of the mapping
    function to allow the cards to have a staggered effect. Different CSS classes
    `top`, `rank`, `bigsuit` and `bottom` position and size the different parts of
    the card. The suit name itself is also a CSS class to apply the correct color
    for the suit (black or red).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中使用 `Array.prototype.map` 确定手牌中每张牌的HTML，并在最后将它们连接成一个字符串。对样式 `top` 和 `left`
    的计算利用了映射函数的可选 `index` 参数，以允许牌有错落的效果。不同的CSS类 `top`、`rank`、`bigsuit` 和 `bottom`
    用于定位和调整牌的不同部分的大小。花色名称本身也是一个CSS类，用于应用正确的花色颜色（黑色或红色）。
- en: 'The other function related to display, `updateStatusDisplay`, is implemented
    as follows:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 与显示相关的另一个函数 `updateStatusDisplay` 的实现如下：
- en: '[PRE102]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This function does several things:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数做了几件事情：
- en: Calculates the total value of the cards and displays it
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算牌的总值并显示
- en: Determines if the game is over by calling `isBust` and `isGameOver.` (If a hand
    is in play, the New Game button should not be visible. If the game is over or
    not active, the Hit and Stay buttons should not be visible. See Figure 14.16.)
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `isBust` 和 `isGameOver` 来确定游戏是否结束。（如果手牌正在游戏中，则“新游戏”按钮不应可见。如果游戏结束或未激活，则“击中”和“停留”按钮不应可见。见图14.16。）
- en: Shows or hides the different buttons depending on if the game is over or not
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据游戏是否结束显示或隐藏不同的按钮
- en: Changes the status message depending on if the game is over or not
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据游戏是否结束来更改状态信息
- en: '![Figure 14.16: The Hit and Stay buttons are visible when the game is active'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.16：当游戏活跃时，击中和停留按钮可见]'
- en: '](img/C14377_14_16.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_14_16.jpg)'
- en: 'Figure 14.16: The Hit and Stay buttons are visible when the game is active'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16：当游戏处于活动状态时，击中和停留按钮是可见的
- en: Effectively, this function actually drives much of the game flow, as the UI
    elements available to the user are set within it.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个函数实际上驱动了游戏流程的大部分，因为用户可用的UI元素都设置在其中。
- en: Blackjack Code Listing
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑杰克代码列表
- en: 'The previous sections covered the most important parts of the code. The full
    code listing for the game is linked as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节涵盖了代码最重要的部分。游戏的完整代码列表如下所示：
- en: '[https://packt.live/370zgaq](https://packt.live/370zgaq)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.live/370zgaq](https://packt.live/370zgaq)'
- en: For simplicity, all the code is contained within one file, including all the
    CSS styles and JavaScript supporting functions. In a real-world application, though,
    you should consider splitting up the files.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，所有代码都包含在一个文件中，包括所有CSS样式和JavaScript支持函数。然而，在实际应用中，你应该考虑将文件拆分。
- en: Summary
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you got a taste of functional programming. It is quite different
    from other programming paradigms such as imperative and object-oriented approaches,
    and it takes a while to get used to. But when properly applied, it is a very powerful
    way of structuring programs so that they're more declarative, correct, testable,
    and have fewer errors.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你体验了函数式编程。它与命令式和面向对象等其他编程范式相当不同，需要一段时间才能习惯。但一旦正确应用，它是一种非常强大的程序结构方式，使程序更加声明性、正确、可测试，并且错误更少。
- en: Even if you don't use pure functional programming in your projects, there are
    many useful techniques that can be used on their own. This is especially true
    for the `map`, `reduce`, and `filter` array methods, which can have many applications.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不在项目中使用纯函数式编程，也有许多有用的技术可以单独使用。这尤其适用于`map`、`reduce`和`filter`数组方法，它们有广泛的应用。
- en: This chapter also only used functionality that's available in native JavaScript.
    But note that there are also a number of popular libraries available to assist
    with functional programming. These libraries facilitate practical functional programming
    concerns such as immutability, side-effect-free functions, composition, and automatic
    currying.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也仅使用了原生JavaScript中可用的功能。但请注意，还有许多流行的库可用于辅助函数式编程。这些库简化了函数式编程的实际问题，如不可变性、无副作用函数、组合和自动柯里化。
- en: The topics we covered in this chapter will help you bolster the skills you need
    to pursue a programming project in the functional style.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中涉及的主题将帮助你增强在函数式风格中进行编程项目所需的技能。
- en: In the next chapter, you will take a deeper look at asynchronous coding, including
    the history of asynchronous callbacks, generators, promises, and async/await.
    This will complete your journey through modern JavaScript development, priming
    you with all you need to create great-looking software.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将更深入地了解异步编程，包括异步回调的历史、生成器、承诺和async/await。这将完成你对现代JavaScript开发的旅程，为你创建出色的软件做好准备。
