- en: 11\. Creating Clean and Maintainable Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 创建清洁且可维护的代码
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to identify and implement basic
    regular expressions (regex); use best practices to produce clean and maintainable
    code; utilize code quality tools such as `ESLint`, `JSLint`, and `JSHint` and
    implement strategies for refactoring code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够识别和实现基本正则表达式（regex）；使用最佳实践来生成清洁且可维护的代码；利用代码质量工具，如 `ESLint`、`JSLint`
    和 `JSHint`，并实施代码重构策略。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you will learn about the techniques that can be used for pattern
    matching and clean coding, which have many uses, perhaps even to facilitate your
    testing as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到可用于模式匹配和清洁编码的技术，这些技术在许多方面都有应用，甚至可能有助于你的测试。
- en: '**Regular expressions** (**regex** for short) are a concise and powerful method
    to search for and match patterns. They may appear alien and intimidating at first,
    but once you learn the basics, they will quickly appear less difficult, and so
    you are likely to recognize their usefulness. Regexes are common in many languages
    and in tools where text and data are involved. So, it is a worthwhile investment
    to take the time to learn them. A pattern that''s expressed as a regex is usually
    much shorter than the equivalent code that''s required to parse and match the
    same pattern using conventional techniques.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**（简称 **regex**）是一种简洁而强大的方法，用于搜索和匹配模式。它们一开始可能看起来很陌生且令人畏惧，但一旦你掌握了基础知识，它们就会迅速变得不那么困难，因此你可能会认识到它们的有用性。正则表达式在许多涉及文本和数据的语言和工具中都很常见。因此，花时间学习它们是值得的。用正则表达式表达的模式通常比使用传统技术解析和匹配相同模式的等效代码要短得多。'
- en: Making use of regexes also leads to clean and maintainable coding practices.
    For programming projects to be successful, it is critical that the code is easily
    understood by others and that it is orderly, focused, and flexible. This chapter
    introduces techniques and best practices for coding, starting with choosing the
    clearest and most understandable names for your variables and methods.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 利用正则表达式还可以导致清洁且可维护的编码实践。为了使编程项目成功，代码必须易于他人理解，并且必须是有序的、专注的和灵活的。本章介绍了编码技术和最佳实践，从为你的变量和方法选择最清晰、最易懂的名称开始。
- en: What Is a Regex?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是正则表达式？
- en: A **regex** is a sequence of characters that form a pattern that's used to search.
    Each character in the pattern either has special meaning (a metacharacter) or
    is meant to match the character itself (a literal). This is perhaps best understood
    by the following example.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**是一个字符序列，它形成一个用于搜索的模式。模式中的每个字符要么具有特殊含义（元字符），要么是为了匹配字符本身（字面量）。这一点可以通过以下示例最好地理解。'
- en: 'As a demonstration of the difference between pattern matching with conventional
    coding versus regex techniques, consider the following code for matching phone
    number format patterns in a conventional way. We''ll then rewrite the matching
    logic using a regex for comparison. To keep things simple, we will only look for
    phone numbers that match the following pattern, which is common for phone numbers,
    particularly in the United States:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示传统编码与正则表达式技术进行模式匹配之间的差异，考虑以下用于以传统方式匹配电话号码格式模式的代码。然后我们将使用正则表达式重写匹配逻辑以进行比较。为了使事情简单，我们只将寻找符合以下模式的电话号码，这对于电话号码来说很常见，尤其是在美国：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `X` can be any digit from `0-9`, and the first digit cannot be a zero
    or one (only `2-9` are permitted). For example, `234-567-8901` is a valid phone
    number in this format.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`X` 可以是 `0-9` 之间的任何数字，第一个数字不能是零或一（只允许 `2-9`）。例如，`234-567-8901` 是这种格式下的有效电话号码。
- en: 'You can use the following code to do the matching using conventional methods:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码使用传统方法进行匹配：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot show the output of the preceding code when a number
    is entered in an invalid format:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在输入无效格式的数字时，前面代码的输出：
- en: '![Figure 11.1: Sample output when a number is input in an incorrect format'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1：输入数字格式不正确时的示例输出'
- en: '](img/C14377_11_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_11_01.jpg]'
- en: 'Figure 11.1: Sample output when a number is input in an incorrect format'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：输入数字格式不正确时的示例输出
- en: 'Here''s the output when a number is entered in a valid format:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入有效格式的数字时，这是输出结果：
- en: '![Figure 11.2: Sample output when a number is input correctly'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2：正确输入数字时的示例输出'
- en: '](img/C14377_11_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_11_02.jpg]'
- en: 'Figure 11.2: Sample output when a number is input correctly'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：输入数字格式正确时的示例输出
- en: 'Let''s focus on the important parts of the JavaScript code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注JavaScript代码中的重要部分：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These lines set up the phone number validation, which is to be done as the user
    enters a value. It finds the DOM element of the input text and adds an event listener
    for the `input` event. This event occurs when the value of `<input>` is changed,
    such as with a keypress or even if a value is pasted in using cut/paste. When
    triggered, the `validatePhoneNumber()` function is called.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行设置了电话号码验证，该验证将在用户输入值时进行。它找到输入文本的DOM元素并为`input`事件添加事件监听器。此事件发生在`<input>`的值改变时，例如按键或粘贴值。当触发时，调用`validatePhoneNumber()`函数。
- en: 'Note the code that checks whether a character is a digit:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意检查一个字符是否为数字的代码：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function has a parameter that must be just one character. What may not
    be intuitive is that JavaScript allows greater than or less than operators on
    character types. This allows us to check that the character is any digit in the
    range between the `0` and `9` characters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个参数，它必须是一个字符。可能不太直观的是，JavaScript允许在字符类型上使用大于或小于运算符。这允许我们检查字符是否在`0`和`9`字符之间的任何数字。
- en: 'The following is the code for the `validatePhoneNumber()` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是`validatePhoneNumber()`方法的代码：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code does the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: Checks the expected length of the phone number to make sure there are no extraneous
    characters, such as additional digits, alphabetic characters, or symbols. Note
    that since we're calling the `trim()` function when we initially read the phone
    number value, this check is forgiving of leading and trailing whitespace.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查电话号码的预期长度，以确保没有多余的字符，例如额外的数字、字母字符或符号。请注意，由于我们在最初读取电话号码值时调用了`trim()`函数，因此这个检查对首尾空白字符是宽容的。
- en: Checks that the first character is not a `0`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查第一个字符不是`0`。
- en: Checks that the first three characters are digits (indices `0-2`).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查前三个字符是否为数字（索引`0-2`）。
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Rather than calling the `isDigit()` function multiple times, we could have added
    parameters to the function so that multiple characters would be checked in one
    invocation. However, for the purposes of this exercise, we chose to keep the code
    simpler and easier to understand.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以不必多次调用`isDigit()`函数，而是可以向函数添加参数，以便在一次调用中检查多个字符。然而，为了这个练习的目的，我们选择保持代码更简单、更容易理解。
- en: Checks for the `-` character afterward.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查随后的`-`字符。
- en: The rest of the validation repeats and is similar for the rest of the characters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的其余部分重复，对于其余字符也是类似的。
- en: 'Finally, the validation message is formed and set in the `<div>`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，验证信息被形成并设置在`<div>`中：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will now compare this logic to an equivalent implementation using regexes.
    We'll describe regexes more methodically and in more depth in the next section,
    but for now, we'll look at how to code with regex techniques, even though it may
    not make much sense to you yet. We will code an alternative to the phone number
    validation function we presented, which uses regexes. So, don't worry if you don't
    quite understand all the concepts yet, as they will be explained in detail later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将比较使用正则表达式的等效实现。我们将在下一节更系统、更深入地描述正则表达式，但就目前而言，我们将看看如何使用正则表达式技术进行编码，即使这可能对你来说现在还没有太多意义。我们将为之前提供的电话号码验证函数编写一个使用正则表达式的替代方案。所以，如果你现在还没有完全理解所有概念，不要担心，因为它们将在稍后详细解释。
- en: Consider the preceding code, which is for pattern matching with conventional
    methods. Let's modify it so that it uses a regex.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面的代码，这是使用传统方法进行模式匹配的代码。让我们修改它，使其使用正则表达式。
- en: 'To do this, find the `validatePhoneNumber()` function and the declaration of
    the `valid` variable. Then, delete the entire expression all the way to the semicolon
    (`;`) character until the comment above it. Replace the area you deleted with
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，找到`validatePhoneNumber()`函数和`valid`变量的声明。然后，删除从该注释之上的整个表达式直到分号（`;`）字符。用以下内容替换你删除的区域：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, you only have a shell of a regex in the area between the two
    forward slash marks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只在两个正斜杠之间的区域有一个正则表达式的框架。
- en: 'After the first forward slash, add a `^` character (called a caret). Your code
    should now look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个正斜杠之后，添加一个`^`字符（称为撇号）。你的代码现在应该看起来像这样：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `^` symbol is an **anchor** that indicates matching should begin at the
    start of the string.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`^`符号是一个**锚点**，表示匹配应从字符串的开始处开始。'
- en: 'Now, add the characters `[2-9]` so that the code now looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加字符`[2-9]`，使得代码现在看起来像这样：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `[2-9]` characters specify a `2` and `9`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`[2-9]`字符指定了`2`和`9`。'
- en: 'By now, you will be able to see how you are progressively adding more characters
    with each step. In a similar fashion, add the remaining characters one by one,
    as shown in the left column of the following table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能够看到你如何逐步添加更多字符。以类似的方式，逐个添加剩余的字符，如下表左侧所示：
- en: '![Figure 11.3: Table of characters'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3：字符表'
- en: '](img/C14377_11_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_03.jpg)'
- en: 'Figure 11.3: Table of characters'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：字符表
- en: 'The complete code should now look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码现在应该看起来像这样：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, you have seen the power of regular expressions and that all of them can
    be expressed in just one line of code. The different concepts of a regular expressions
    are shown in the following figure:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已经看到了正则表达式的强大功能，以及所有这些都可以用一行代码表达。以下图中展示了正则表达式的不同概念：
- en: '![Figure 11.4: Showing different concepts in the regular expression'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4：展示正则表达式中的不同概念'
- en: '](img/C14377_11_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_04.jpg)'
- en: 'Figure 11.4: Showing different concepts in the regular expression'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：展示正则表达式中的不同概念
- en: Regexes in Detail
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式详解
- en: 'In the upcoming sections, the following sample phrase is used for illustration:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，以下样本短语被用来进行说明：
- en: '"The ships were loaded with all these belongings of the mother"'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '"The ships were loaded with all these belongings of the mother"'
- en: This phrase will be used to demonstrate various regex concepts, including literal
    characters, word boundaries, character classes, and others.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个短语将被用来演示各种正则表达式概念，包括文本字符、单词边界、字符类等。
- en: Literal Characters
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本字符
- en: 'The simplest regex is one of more `the`. This indicates a pattern that is a
    match if the `t` character is immediately followed by `h` and finally an `e` character.
    This expression would have four matches in the sample phrase: the initial `the`,
    the second to last word, `the`, `the` in the word `these`, and the sequence of
    `the` as part of the word `mother`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的正则表达式之一是`the`。这表示一个模式，如果`t`字符紧跟着`h`字符，最后是一个`e`字符，则匹配。这个表达式在样本短语中有四个匹配项：开头的`the`，倒数第二个单词，`the`，`these`单词中的`the`，以及作为单词`mother`一部分的`the`序列。
- en: Special Characters, Anchors, and Escaping
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊字符、锚点和转义
- en: If a regex only had literals, its usefulness would be limited. In most cases,
    you do not want to only match literals; therefore, regexes have a number of characters
    that have special meanings. These are also known as metacharacters. Two of these
    special characters are the `^` and `$` **anchors** that you saw earlier, which
    indicate the beginning and end of a string, respectively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个正则表达式只有文本字符，它的用途将是有限的。在大多数情况下，你不想只匹配文本字符；因此，正则表达式有一系列具有特殊意义的字符。这些也被称为元字符。其中两个特殊字符是之前看到的`^`和`$`
    **锚点**，分别表示字符串的开始和结束。
- en: So, if you change the regex to `^the`, only the initial `the` of the phrase
    would now be a match since this is the only instance of `the` in the phrase that
    is at the beginning of the string. Anchors are often important in situations where
    you need to avoid matching too much that is not intended to be matched.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你将正则表达式更改为`^the`，那么现在短语开头的`the`将是唯一匹配的，因为这是短语中唯一一个位于字符串开头的`the`实例。锚点在需要避免匹配非预期匹配内容的情况下通常很重要。
- en: 'The following are the most common characters that have special meaning in regexes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在正则表达式中具有特殊意义的最常见的字符：
- en: '![Figure 11.5: Special characters'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5：特殊字符'
- en: '](img/C14377_11_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_05.jpg)'
- en: 'Figure 11.5: Special characters'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：特殊字符
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you need to use any of these characters in your regexes as a literal character,
    in most cases, the character will need to be escaped. You do that by placing a
    backslash `\` before the character.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在你的正则表达式中使用这些字符作为文本字符，在大多数情况下，字符将需要被转义。你通过在字符前放置反斜杠`\`来实现这一点。
- en: 'Here are two examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个例子：
- en: If you need to match a dollar sign as part of your pattern, you would use `\$`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要将美元符号作为模式的一部分进行匹配，你会使用`\$`。
- en: Some less obvious escapes are the backslash character itself (you would just
    use two consecutive backslashes, for example, `\\`), and a dot, where `\.` is
    the correct escaping sequence.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些不太明显的转义包括反斜杠字符本身（例如，你只需要使用两个连续的反斜杠，例如`\\`），以及点，其中`\.`是正确的转义序列。
- en: Word Boundary
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词边界
- en: 'Another type of anchor is a `\b` (a backslash followed by a `b`). A word boundary
    is defined as either of the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的锚点是 `\b`（一个反斜杠后跟一个 `b`）。单词边界被定义为以下两种情况之一：
- en: The beginning of a string, followed by a word character
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的开始，后面跟着一个单词字符
- en: The character between whitespace and a word character, or after a word character
    leading to either whitespace or the end of the string
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白字符和单词字符之间的字符，或者单词字符后面跟着空白字符或字符串的末尾
- en: Note that the word characters are defined as follows.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，单词字符被定义为以下内容。
- en: 'If the preceding regex was changed to `\bthe`, there would only be three matches
    in the sample phrase: the four previous matches, minus `the` in `mother`. (The
    initial `\b` of the pattern are special characters, and the remainder are literal
    characters.)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将先前的正则表达式更改为 `\bthe`，样本短语中只有三个匹配项：之前的四个匹配项减去 `mother` 中的 `the`。 (模式的初始 `\b`
    是特殊字符，其余的是字面字符。)
- en: If the regex was changed to `\bthe\b`, only the two standalone `the` words would
    be matches, and not the ones in `these` or `mother`. This is one way to specify
    to search for whole words, but with no other leading or trailing characters in
    a given word.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将正则表达式更改为 `\bthe\b`，只有两个独立的 `the` 单词会匹配，而不是 `these` 或 `mother` 中的那些。这是指定搜索整个单词的一种方法，但给定单词中没有其他前导或尾随字符。
- en: Shorthand Character Classes and Word Characters
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简写字符类和单词字符
- en: There are a number of `\d` sequence, which denotes any digit `[0-9]`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个 `\d` 序列，表示任何数字 `[0-9]`。
- en: 'Another is the `\w`, which is defined as `[A-Za-z0-9_]`. (Character classes
    and ranges will be defined in more detail next. For now, this is read as a character
    in the range of uppercase characters `A-Z`, range of characters `a-z`, range of
    digits `0-9`, or the underscore `_` character.) Here are some examples:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是 `\w`，定义为 `[A-Za-z0-9_]`。 (字符类和范围将在下一节中更详细地定义。现在，这被读作大写字母 `A-Z` 的范围内的字符，小写字母
    `a-z` 的范围内的字符，数字 `0-9` 的范围内的字符，或者下划线 `_` 字符。) 这里有一些例子：
- en: If the `the\w` regex were used on the preceding sample phrase, only the sequence
    of `the` in the words `these` and `mother` would be a match, since the other two
    `the` words do not have a word character following it.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在先前的示例短语上使用 `the\w` 正则表达式，只有单词 `these` 和 `mother` 中的 `the` 序列会匹配，因为其他两个 `the`
    单词后面没有单词字符。
- en: If the `\wthe\w` regex were used, only the sequence of `the` in the word `mother`
    would match, as it is the only place in the string where the sequence `the` is
    both preceded and followed by a word character. This is one way to specify how
    to search for characters that are only contained within a word.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `\wthe\w` 正则表达式，只有单词 `mother` 中的 `the` 序列会匹配，因为它是字符串中唯一一个 `the` 序列既被单词字符前缀又后缀的地方。这是指定如何搜索仅包含在单词中的字符的一种方法。
- en: Combining the word boundary and word character shortcuts, if the regex `\bthe\w`
    were used, only the sequence of `the` in the word `these` would match as it is
    the only place in the string where the sequence `the` starts on a word boundary
    and is followed by a word character.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合单词边界和单词字符简写，如果使用 `\bthe\w` 正则表达式，只有单词 `these` 中的 `the` 序列会匹配，因为它是字符串中唯一一个
    `the` 序列从单词边界开始并且后面跟着一个单词字符的地方。
- en: Another common shorthand character class is `\s`, which is shorthand for whitespace,
    including space characters, tabs, and newlines.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的简写字符类是 `\s`，它是空白字符的简写，包括空格字符、制表符和换行符。
- en: Inverse Classes
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向类
- en: 'Every shorthand character class has an inverse class as well, denoted by making
    the letter uppercase:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个简写字符类都有一个相反的类，通过将字母转换为大写来表示：
- en: '`\B`: The opposite of a word boundary, such as in the middle of a word'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\B`：单词边界的相反，例如在单词中间'
- en: '`\D`: Represents any non-digit character'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\D`：表示任何非数字字符'
- en: '`\W`: Any character that is not included in `[A-Za-z0-9_]`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\W`：任何不在 `[A-Za-z0-9_]` 中的字符'
- en: '`\S`: Any non-whitespace character'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\S`：任何非空白字符'
- en: For example, as the inverse of the first example in the previous section, if
    the `the\W` regex were used on the preceding sample phrase, only the two `the` characters
    would match, including the trailing space character. The words `these` and `mother`
    would be a match, since in both cases there is a word character following `the`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，作为上一节第一个示例的反面，如果使用 `the\W` 正则表达式在先前的示例短语上，只有两个 `the` 字符会匹配，包括尾随的空格字符。单词 `these`
    和 `mother` 会匹配，因为在两种情况下 `the` 后面都有一个单词字符。
- en: Dot Character
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点字符
- en: 'The dot, `.`, matches any character except newlines. For instance, the `.h.`
    regex looks for any `h` and matches it with the character before and after it,
    as long as it is not a newline. The highlighted characters that follow are the
    result of applying the regex to the earlier sample phrase:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 点号，`.`，匹配任何字符（除了换行符）。例如，`.h.` 正则表达式会寻找任何 `h` 并将其与它之前和之后的字符匹配，只要它不是换行符。以下高亮显示的字符是应用正则表达式到早期示例短语后的结果：
- en: '"The ships were loaded with all these belongings of the mother"'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '"The ships were loaded with all these belongings of the mother"'
- en: Take special note of the third match of the last two letters of the word `with`,
    along with the space character that follows it. It is easy to forget that a dot
    matches any character, including a space. This can be a common error if you do
    intend to allow spaces in your pattern.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意单词 `with` 的最后两个字母的第三次匹配，以及随后的空格字符。很容易忘记点号匹配任何字符，包括空格。如果你打算在模式中允许空格，这可能会是一个常见的错误。
- en: Sets
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'One or more characters or character classes enclosed in square brackets, `[...]`,
    indicates we should match any of the given characters. This is called a **set**.
    Here are two examples:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在方括号 `[...]` 中的一个或多个字符或字符类表示我们应该匹配给定的任何字符。这被称为**集合**。以下有两个例子：
- en: The `[AEIOUaeiou]` regex can be used to match vowel characters.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[AEIOUaeiou]` 正则表达式可以用来匹配元音字符。'
- en: When combining a set followed by two literal characters, the `[oi]ng` regex
    would match the `ong` and the `ing` in the word `belongings` (from the sample
    phrase).
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将集合与两个字面字符结合时，`[oi]ng` 正则表达式会匹配单词 `belongings`（来自示例短语）中的 `ong` 和 `ing`。
- en: Ranges
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: One `[2-9]`, which indicated a character between `2` and `9`. Similar to sets,
    ranges are specified within square brackets, `[...]`, and use a dash character
    to separate the characters that indicate the range.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `[2-9]`，表示在 `2` 和 `9` 之间的字符。类似于集合，范围是在方括号 `[...]` 中指定的，并使用破折号字符来分隔表示范围的字符。
- en: Another range you saw earlier was `[A-Za-z0-9_]`, which specified the word characters.
    This also shows how multiple ranges and even a character that's not part of a
    range can be indicated in one expression, as this allows characters from `A-Z`,
    `a-z`, and `0-9`, as well as the underscore character.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到的另一个范围是 `[A-Za-z0-9_]`，它指定了单词字符。这也显示了如何在单个表达式中指示多个范围，甚至是一个不属于范围的字符，因为这允许
    `A-Z`、`a-z` 和 `0-9` 的字符，以及下划线字符。
- en: Excluding Sets and Ranges
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排除集合和范围
- en: The opposite of regular sets and ranges, an excluding range indicates to "match
    a character except for the following". Excluding sets or ranges is indicated by
    placing a caret character, `^`, immediately after the first square bracket in
    the expression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正则集合和范围的相反，排除范围表示“匹配除以下字符之外的字符”。排除集合或范围是通过在表达式中第一个方括号后立即放置一个撇号字符 `^` 来表示的。
- en: For instance, `[^AEIOUaeiou]` would match any character that is NOT a vowel.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`[^AEIOUaeiou]` 会匹配任何不是元音的字符。
- en: The dash can also be included in the exclusion to indicate a range of characters
    to be excluded. For example, `[^0-9]` would indicate to match any character that
    is not a digit (similar to `\d`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 破折号也可以包含在排除中，以表示要排除的字符范围。例如，`[^0-9]` 会指示匹配任何不是数字的字符（类似于 `\d`）。
- en: Quantifiers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量词
- en: A **quantifier** specifies how many of a given character, character class, or
    token are required for a match.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**量词**指定了匹配给定字符、字符类或标记所需的数量。'
- en: Perhaps the most straightforward is a `{4}`. For example, the `a{4}` regex would
    require the letter `a` to be repeated four times, and `\d{3}` would require three
    digits in sequence.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的可能是一个 `{4}`。例如，`a{4}` 正则表达式要求字母 `a` 重复四次，而 `\d{3}` 要求连续三个数字。
- en: Its close cousin, the range quantifier, can be specified using a format similar
    to `{min,max}`. This one would match if anything between the specified minimum
    and maximum number of occurrences was present. For example, the `a{2,5}` regex
    would match any of `aa`, `aaa`, `aaaa`, or `aaaaa`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它的近亲，范围量词，可以使用类似于 `{min,max}` 的格式进行指定。这个量词会匹配在指定的最小和最大出现次数之间的任何内容。例如，`a{2,5}`
    正则表达式会匹配 `aa`、`aaa`、`aaaa` 或 `aaaaa` 中的任何一个。
- en: A special type of range allows for an unbounded upper limit if the numeral after
    the comma is omitted. For example, `a{3,}` would match any number of consecutive
    `a` characters of at least three occurrences.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了逗号后的数字，则特殊类型的范围允许无界上限。例如，`a{3,}` 会匹配至少出现三次的连续 `a` 字符的任何数量。
- en: Shorthand Quantifiers
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简写量词
- en: 'There are three quantifiers that are used so often that they have special shortcut
    characters designated to denote them. They are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个量词使用得非常频繁，以至于为它们指定了特殊的快捷字符来表示它们。它们如下所示：
- en: '![Figure 11.6: Quantifiers'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.6：量词](img/C14377_11_06.jpg)'
- en: '](img/C14377_11_06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_06.jpg)'
- en: 'Figure 11.6: Quantifiers'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：量词
- en: 'Combining these shorthand qualifiers with the concepts we previously covered
    (literals, character classes, sets, ranges, and so on), the following are example
    regexes and what they would match:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些简写量词与我们之前介绍的概念（文字、字符类、集合、范围等）结合起来，以下是一些示例正则表达式以及它们会匹配的内容：
- en: '![Figure 11.7: Regex and their Matches'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.7：正则表达式及其匹配项](img/C14377_11_07.jpg)'
- en: '](img/C14377_11_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_07.jpg)'
- en: 'Figure 11.7: Regex and their Matches'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：正则表达式及其匹配项
- en: Alternation
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择
- en: Let's say you want your pattern to allow either of two (or more) words. You
    can do this by separating the words with a pipe `|` character, which is equivalent
    to an `OR` indicating `expression1 OR expression2`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望您的模式允许两个（或更多）单词中的任意一个。您可以通过使用管道 `|` 字符分隔单词来实现这一点，这相当于 `OR` 操作符，表示 `expression1
    OR expression2`。
- en: 'In most cases, it is also a good idea to enclose the alternative expressions
    in parenthesis, for example,`(expression1|expression2)`, to separate them from
    the rest of the pattern. For example, to scan for either a word, `the`, followed
    by one or more whitespace characters, which would be either `mother` or `father`,
    the regex would be as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，将备选表达式括在括号中也是一个好主意，例如 `(expression1|expression2)`，以将其与模式的其他部分分开。例如，要扫描一个单词
    `the` 后跟一个或多个空白字符的情况，这将匹配 `mother` 或 `father`，正则表达式如下：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Many More Regex Concepts
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多其他正则表达式概念
- en: 'This chapter covers only a brief overview of basic regex concepts and provides
    a good background so that you can get started with them. You are encouraged to
    explore more advanced features using the many available resources. These include
    the following concepts:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅对基本正则表达式概念进行了简要概述，并提供了良好的背景知识，以便您可以开始使用它们。鼓励您使用许多可用资源探索更多高级功能。以下是一些概念：
- en: 'Greedy versus lazy quantifiers: [https://packt.live/33vxqvQ](https://packt.live/33vxqvQ)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪婪量词与懒惰量词：[https://packt.live/33vxqvQ](https://packt.live/33vxqvQ)
- en: 'Capturing groups: [https://packt.live/34Iq0G0](https://packt.live/34Iq0G0)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获组：[https://packt.live/34Iq0G0](https://packt.live/34Iq0G0)
- en: 'Backreferences: [https://packt.live/2NqrDCe](https://packt.live/2NqrDCe)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回溯：[https://packt.live/2NqrDCe](https://packt.live/2NqrDCe)
- en: 'Lookahead and lookbehind: [https://packt.live/2NrkMbR](https://packt.live/2NrkMbR)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预查和后查：[https://packt.live/2NrkMbR](https://packt.live/2NrkMbR)
- en: 'Sticky flag: https://packt.live/32q86Gw'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粘性标志：[https://packt.live/32q86Gw](https://packt.live/32q86Gw)
- en: 'The internals of how regex engines actually work: [https://packt.live/2oXQUKE](https://packt.live/2oXQUKE)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式引擎实际工作原理的内部细节：[https://packt.live/2oXQUKE](https://packt.live/2oXQUKE)
- en: Pattern Specification and Flags
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式规范和标志
- en: So far, we have covered the elements that comprise regex patterns, but now,
    we will cover how these patterns are conveyed in JavaScript code. The most common
    method is to enclose the pattern in a pair of slash characters, for example, `/pattern/`.
    Flags can also be added after the second slash, though this is optional.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了构成正则表达式模式的元素，但现在，我们将介绍这些模式如何在 JavaScript 代码中传达。最常见的方法是将模式括在成对的斜杠字符中，例如
    `/pattern/`。也可以在第二个斜杠之后添加标志，但这不是必需的。
- en: 'Flags can change the behavior of how matching and searching occurs. The most
    common flags are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 标志可以改变匹配和搜索的行为。最常见的标志如下：
- en: '`g`: If specified, all matches are returned (if not specified, only the first
    match is returned by default).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`：如果指定，将返回所有匹配项（如果没有指定，默认情况下将返回第一个匹配项）。'
- en: '`i`: Makes the matching case-insensitive; there''s no differentiation between
    uppercase and lowercase letters.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：使匹配不区分大小写；大写字母和小写字母之间没有区别。'
- en: Others include `m` (multiline search), `s` (dot  `.` matches newline), `u` (Unicode
    support), and `y` (sticky mode).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其他包括 `m`（多行搜索）、`s`（点 `.` 匹配换行符）、`u`（Unicode 支持）和 `y`（粘性模式）。
- en: Finding Matches with String.match()
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 String.match() 查找匹配项
- en: The JavaScript `String` class has a number of built-in methods that accept regex
    parameters. This section outlines some of them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript `String` 类有几个内置方法，可以接受正则表达式参数。本节概述了其中一些。
- en: 'The most common method you would use is `String.match()`. This method behaves
    differently, and its return value varies depending on whether the `g` flag is
    included:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您最常用的方法是 `String.match()`。此方法的行为不同，其返回值取决于是否包含 `g` 标志：
- en: 'If there is no `g` flag: Searching stops after the first match is found. The
    result is an array with the match returned as the array element, the additional
    property `index`, indicating the position where the match was found, and some
    additional properties. (Note that it has other functionalities if the regex contains
    groupings, but groups are not covered in this chapter)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有 `g` 标志：找到第一个匹配项后停止搜索。结果是包含匹配项作为数组元素的数组，额外的属性 `index` 指示匹配项找到的位置，以及一些额外的属性。（注意，如果正则表达式包含分组，它还有其他功能，但分组在本章中未涉及）
- en: 'If there is a `g` flag: Searches for all possible matches and returns those
    found in an array. There are no other properties in the return value.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有 `g` 标志：搜索所有可能的匹配项，并返回找到的匹配项数组。返回值中没有其他属性。
- en: 'Exercise 11.01: The Effect of the g Flag'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.01：g 标志的影响
- en: 'The following code illustrates the difference regarding whether the `g` flag
    is present or not. It matches words that begin with the letter `t`. (The `i` flag
    is also demonstrated to make the match case insensitive.) Let''s get started:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了是否存在 `g` 标志的差异。它匹配以字母 `t` 开头的单词。（`i` 标志也用于演示以使匹配不区分大小写。）让我们开始吧：
- en: In the Google Chrome browser, go into `Developer Tools` (Menu (the three dots
    in the upper right of the screen), `More Tools` | `Developer Tools`, or just hit
    the `F12` key).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Google Chrome 浏览器中，进入 `开发者工具`（菜单（屏幕右上角的三个点），`更多工具` | `开发者工具`，或者直接按 `F12` 键）。
- en: 'Type the following into the console to set up our test string:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容输入控制台以设置测试字符串：
- en: '[PRE11]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`g` flag is not present. Type the following:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`g` 标志不存在。输入以下内容：'
- en: '[PRE12]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the steps that follow, the lines of the code snippets that begin with `>`
    indicate what you should type in. The lines that begin with `<-` is the output
    you are expected to see.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，以 `>` 开头的代码片段的行表示你应该输入的内容。以 `<-` 开头的行是你预期的输出。
- en: 'Let''s see what was matched. To do that, type the following:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看匹配了什么。为此，请输入以下内容：
- en: '[PRE13]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Check at what character index the match was made:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查匹配发生的字符索引：
- en: '[PRE14]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since there is no `g`, we are not expecting any further matches. To verify
    this, use the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有 `g`，我们预期不会有更多的匹配项。为了验证这一点，请使用以下代码：
- en: '[PRE15]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The matches from the first expression will be displayed as follows:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个表达式的匹配项将显示如下：
- en: '![Figure 11.8: Full output of the first match expression'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.8：第一个匹配表达式的完整输出'
- en: '](img/C14377_11_08.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_11_08.jpg)'
- en: 'Figure 11.8: Full output of the first match expression'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.8：第一个匹配表达式的完整输出
- en: '`g` flag is present. Type the following to reassign the match variable to include
    `g` (and `i`):'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`g` 标志存在。输入以下内容以重新分配匹配变量以包含 `g`（和 `i`）：'
- en: '[PRE16]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Type the remaining lines in succession, checking the expected output of each:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按顺序输入剩余的行，检查每行的预期输出：
- en: '[PRE17]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The matches of the expression with a `g` will be displayed as follows:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 带有 `g` 标志的表达式匹配将显示如下：
- en: '![Figure 11.9: Full output of the match expression with the g flag'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.9：带有 g 标志的匹配表达式的完整输出'
- en: '](img/C14377_11_09.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_09.jpg)'
- en: 'Figure 11.9: Full output of the match expression with the g flag'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：带有 g 标志的匹配表达式的完整输出
- en: In this exercise, you saw how to use the `g` flag of the `String.match()` method
    to can obtain multiple matches. Next, you will learn about other methods that
    involve regexes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了如何使用 `String.match()` 方法的 `g` 标志来获取多个匹配项。接下来，你将学习其他涉及正则表达式的相关方法。
- en: Other String Methods for Regexes
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他用于正则表达式的字符串方法
- en: 'The following table briefly describes some of the other methods in the String
    object related to regexes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格简要描述了与正则表达式相关的 String 对象中的其他一些方法：
- en: '![Figure 11.10: String methods'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.10：字符串方法'
- en: '](img/C14377_11_10.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_10.jpg)'
- en: 'Figure 11.10: String methods'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：字符串方法
- en: 'There is another useful method to take note of when using regexes in JavaScript.
    The `test()` method returns a simple `true` or `false` that indicates whether
    a match has been found. You can use it in code such as the following to test whether
    a string begins with the characters `hello`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 JavaScript 中的正则表达式时，还有一个有用的方法需要注意。`test()` 方法返回一个简单的 `true` 或 `false`，指示是否找到了匹配项。你可以在如下代码中使用它来测试字符串是否以字符
    `hello` 开头：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are other more advanced methods of the String object that are not covered
    here. JavaScript also has a dedicated built-in RegExp object that supports advanced
    use cases (the `test()` method actually belongs to RegExp).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: String 对象还有其他一些更高级的方法，这里没有涵盖。JavaScript 还有一个专门的内置 RegExp 对象，支持高级用例（`test()`
    方法实际上属于 RegExp）。
- en: 'Exercise 11.02: Modifying Regex to Match a Pattern'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.02：修改正则表达式以匹配模式
- en: 'Recall the regex pattern we presented at the beginning of this chapter, which
    we used to match phone numbers in the format `XXX-XXX-XXXX`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在本章开头提出的正则表达式模式，我们用它来匹配格式为 `XXX-XXX-XXXX` 的电话号码：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using what you''ve learned so far, in this exercise, you will modify the regex
    to match phone numbers of a slightly different format:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你到目前为止所学到的知识，在这个练习中，你将修改正则表达式以匹配稍有不同的电话号码格式：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are many sites that help you craft and test regexes. We will use [https://regex101.com/](https://regex101.com/)
    to work on our regex. Let''s get started:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多网站可以帮助你构建和测试正则表达式。我们将使用 [https://regex101.com/](https://regex101.com/) 来处理我们的正则表达式。让我们开始吧：
- en: First, compare the two formats to see how similar they are. Notice that the
    new format, `(XXX) XXX-XXXX`, is identical to the original format, `XXX-XXX-XXXX`
    , for the last seven digits and is only different at the beginning of the pattern.
    We only need to replace the first four characters of the original pattern (the
    three digits and a dash, `XXX-`) with the new characters (an open parenthesis,
    three digits, a close parenthesis, and a space).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，比较这两种格式，看看它们有多相似。注意，新的格式 `(XXX) XXX-XXXX` 在最后七位数字上与原始格式 `XXX-XXX-XXXX` 完全相同，只是在模式的开头有所不同。我们只需要将原始模式的前四个字符（三个数字和一个连字符，`XXX-`）替换为新字符（一个开括号，三个数字，一个闭括号和一个空格）。
- en: 'We need to come up with a regex that corresponds to `(XXX)`, including a trailing
    space character that is not displayed:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要想出一个与 `(XXX)` 对应的正则表达式，包括一个不显示的尾随空格字符：
- en: '[PRE21]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s break this code down:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们分析这段代码：
- en: '`\(`: The first character you need to match is a parenthesis. Remember that
    parentheses are special characters (metacharacters) in a regex, so they need to
    be escaped with a backslash to indicate that you really intend for the parenthesis
    character to be matched.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\(`：你需要匹配的第一个字符是一个括号。记住，括号在正则表达式中是特殊字符（元字符），所以它们需要用反斜杠转义，以表示你确实想要匹配括号字符。'
- en: '`[2-9]`: A character range to match a character between 2 and 9.'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[2-9]`：一个字符范围，用于匹配介于 2 和 9 之间的字符。'
- en: '`\d`: This is a character class that specifies to match a digit character.'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d`：这是一个字符类，指定匹配一个数字字符。'
- en: '`{2}`: A fixed quantifier that indicates that the previous digit character
    (\d) needs to repeat twice for it to be considered a match.'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{2}`：一个固定量词，表示前面的数字字符（\d）需要重复两次才能被认为是匹配。'
- en: '`\)`: The closing parenthesis, also escaped.'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\)`：闭括号，也进行了转义。'
- en: 'By combining this with the rest of the original regex, you get the final regex:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过与原始正则表达式的其余部分结合，你得到最终的正则表达式：
- en: '[PRE22]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To test this solution, there are many sites that help you craft and test regexes.
    You can go to [https://regex101.com/](https://regex101.com/) and enter the regex
    in the input box. Also, enter `(234) 567-8910` in the TEST STRING area, as shown
    here:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了测试这个解决方案，有许多网站可以帮助你构建和测试正则表达式。你可以访问 [https://regex101.com/](https://regex101.com/)
    并在输入框中输入正则表达式。此外，在 TEST STRING 区域输入 `(234) 567-8910`，如图所示：
- en: '![Figure 11.11: Screenshot of https://regex101.com/'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.11：https://regex101.com/ 的截图](https://regex101.com/)'
- en: '](img/C14377_11_11.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_11_11.jpg](img/C14377_11_11.jpg)'
- en: 'Figure 11.11: Screenshot of https://regex101.com/'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.11：https://regex101.com/ 的截图](https://regex101.com/)'
- en: As you can see, the MATCH INFORMATION section indicates that our test string
    is a full match.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，MATCH INFORMATION 部分表明我们的测试字符串是一个完整的匹配。
- en: 'There is quite a bit happening on this screen, and a lot of information that
    helps you understand and work with regexes. If you look at the REGULAR EXPRESSION
    input box, you will see that the various elements of the regex have been color-coded
    to help break it down to its constituent parts. The EXPLANATION area goes even
    further and provides detailed explanations of each character or token. Since the
    full text was not visible in the preceding screenshot, here are the explanations
    that were provided:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上发生了很多事情，有很多信息可以帮助你理解和处理正则表达式。如果你查看 REGULAR EXPRESSION 输入框，你会看到正则表达式的各个元素已经被着色，以帮助将其分解为其组成部分。EXPLANATION
    区域更进一步，为每个字符或标记提供详细的解释。由于前面的截图中没有显示全部文本，以下是提供的解释：
- en: '![Figure 11.12: The EXPLANATION area'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.12：解释区域](img/C14377_11_12.jpg)'
- en: '](img/C14377_11_12.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_11_12.jpg](img/C14377_11_12.jpg)'
- en: 'Figure 11.12: The EXPLANATION area'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：解释区域
- en: Adding More Strings to the Regex
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在正则表达式中添加更多字符串
- en: 'Besides having a test string that passes matching, it is a good idea to also
    put in other test strings that are similar but are not expected to pass. The following
    screenshot shows some other such patterns in the TEST STRING area, but notice
    that only the first one of those patterns shows a match (as expected):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有一个通过匹配的测试字符串外，还应该放入其他类似的测试字符串，这些字符串不应该通过匹配。以下截图显示了TEST STRING区域中的一些其他此类模式，但请注意，只有这些模式中的第一个模式显示为匹配（正如预期的那样）：
- en: '![Figure 11.13: More test strings that are not expected to match'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13：更多不期望匹配的测试字符串'
- en: '](img/C14377_11_13.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_13.jpg)'
- en: 'Figure 11.13: More test strings that are not expected to match'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：更多不期望匹配的测试字符串
- en: The pattern to match phone numbers in the previous exercise works okay, but
    it looks for a very specific pattern. The following activity will challenge you
    into making the regex more flexible so that it accepts multiple phone number formats.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中匹配电话号码的模式是可行的，但它寻找一个非常具体的模式。以下活动将挑战你使正则表达式更加灵活，以便它接受多种电话号码格式。
- en: What if you were asked to come up with one regex that can be used to match either
    of the `XXX-XXX-XXXX` or `(XXX) XXX-XXXX` patterns?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人要求你提出一个正则表达式，使其能够匹配`XXX-XXX-XXXX`或`(XXX) XXX-XXXX`中的任意一种模式，你会怎么做？
- en: The challenge is to come up with just one regex that can match either phone
    number format. Before presenting a good solution, let's consider an incorrect
    and naive one that, at first glance, seems like the most obvious approach to take,
    but is actually flawed and fraught with pitfalls.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于只提出一个正则表达式，使其能够匹配这两种电话号码格式。在提出一个好的解决方案之前，让我们先考虑一个不正确且简单的方法，它乍一看似乎是采取的最明显的方法，但实际上是有缺陷的，充满了陷阱。
- en: 'Observe that the second format is mostly similar to the original one, with
    the exception that the first set of three digits begins and end with parenthesis
    characters (`(` and `)`) and is followed by a space rather than a dash character.
    You may begin to think of representing these differences by adding parenthesis
    to the regular expression and simply making them optional (using the ? quantifier)
    and placing the dash and space in a set (using **[]** syntax). Such a regex would
    look like this (the additions are emphasized):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到第二种格式与原始格式大部分相似，只是第一组三位数字以括号字符（`(`和`)`）开始和结束，并且后面是空格而不是破折号字符。你可能开始考虑通过在正则表达式中添加括号来表示这些差异，并简单地使用问号量词使它们成为可选的，并将破折号和空格放在一个集合中（使用**[]**语法）。这样的正则表达式看起来会像这样（强调的是新增部分）：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The problem is that this regex is incomplete and would also allow matches of
    some incorrect and undesirable formats, such as the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个正则表达式是不完整的，它也会允许一些不正确且不希望出现的格式匹配，如下所示：
- en: '`(234 567-8901` (no ending parenthesis)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(234 567-8901` (没有结束括号)'
- en: '`234) 567-8901` (no starting parenthesis)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`234) 567-8901` (没有起始括号)'
- en: '`234 567-8901` (using a space character inappropriately)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`234 567-8901` (不恰当地使用空格字符)'
- en: '`(234)-567-8901` (using a dash inappropriately)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(234)-567-8901` (不恰当地使用破折号)'
- en: 'This can be seen if you enter these test strings into the tool as well:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些测试字符串输入到工具中，你也会看到这种情况：
- en: '![Figure 11.14: All the test strings match due to a flawed regex'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14：所有测试字符串都匹配，因为正则表达式有缺陷'
- en: '](img/C14377_11_14.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_14.jpg)'
- en: 'Figure 11.14: All the test strings match due to a flawed regex'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：所有测试字符串都匹配，因为正则表达式有缺陷
- en: Only the first two test strings should have matched, but they all did (indicated
    by them all being highlighted in blue).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 只有前两个测试字符串应该匹配，但它们都匹配了（通过它们都被突出显示为蓝色来表示）。
- en: 'Activity 11.01: Expanding Phone Number Matching Patterns to Accept Multiple
    Formats'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动内容11.01：扩展电话号码匹配模式以接受多种格式
- en: 'In the previous exercise, we modified a regex to match phone numbers that have
    the following format: `(XXX) XXX-XXXX`. In this activity, we will create one regex
    that can be used to match either of the `XXX-XXX-XXXX` or `(XXX) XXX-XXXX` patterns.
    Once you have completed this activity, you should have a regex that accepts either
    of the `(XXX) XXX-XXXX` or `XXX-XXX-XXXX` number formats.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们修改了一个正则表达式来匹配具有以下格式的电话号码：`(XXX) XXX-XXXX`。在这个活动中，我们将创建一个正则表达式，可以用来匹配`XXX-XXX-XXXX`或`(XXX)
    XXX-XXXX`中的任意一种模式。一旦完成这个活动，你应该会有一个接受`(XXX) XXX-XXXX`或`XXX-XXX-XXXX`号码格式的正则表达式。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的总体步骤如下：
- en: Indicate that the regex snippets corresponding to each format are alternate
    expressions of an alternation.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指出与每种格式对应的正则表达式片段是交替表达式的不同形式。
- en: Combine them with the rest of the original regex in the previous exercise to
    get the complete regex.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们与上一练习中的原始正则表达式结合，以获得完整的正则表达式。
- en: 'Now, test the regex with the following numbers: (234) 567-8901; 234-567-8907;
    234) 567-8901; (234 567-8901; 234 567-8901; and (234)-567-8901.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下数字测试正则表达式：(234) 567-8901；234-567-8907；234) 567-8901；234 567-8901；234
    567-8901；以及(234)-567-8901。
- en: 'The expected output of this activity should be as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的预期输出应该是以下内容：
- en: '![Figure 11.15: Output to the Activity 11.01'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.15：活动11.01的输出'
- en: '](img/C14377_11_15.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_15.jpg)'
- en: 'Figure 11.15: Output to the Activity 11.01'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：活动11.01的输出
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to the activity can be found on page 745.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 活动解决方案可以在第745页找到。
- en: 'Activity 11.02: Expanding Phone Number Matching Patterns to Accept a Particular
    Format'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动作业11.02：扩展电话号码匹配模式以接受特定格式
- en: 'In this activity, we will`+XXX` ), such as one of the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将`+XXX`（例如以下之一）：
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once you've completed this activity, you should have a regex that successfully
    tests for the `+xxx` format.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这个活动，你应该有一个能够成功测试`+xxx`格式的正则表达式。
- en: '**Steps:**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤：**'
- en: Construct the regex for the `+XXX` pattern (where between 1-3 digits are acceptable).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`+XXX`模式（其中1-3位数字是可接受的）构造正则表达式。
- en: Combine this with the original regex to get the complete regex.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此与原始正则表达式结合，以获得完整的正则表达式。
- en: Modify the regex to allow the use of space or dot characters as digit separators
    rather than only dashes.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改正则表达式，允许使用空格或点字符作为数字分隔符，而不是仅使用破折号。
- en: 'Test the patterns with the following numbers:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下数字测试模式：
- en: '![Figure 11.16: Many of the patterns that match the regular expression'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.16：许多与正则表达式匹配的模式'
- en: '](img/C14377_11_16.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_16.jpg)'
- en: 'Figure 11.16: Many of the patterns that match the regular expression'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16：许多与正则表达式匹配的模式
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 747.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第747页找到。
- en: Useful Regexes
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的正则表达式
- en: 'The following table presents a number of regexes for different purposes. You
    should be able to understand them using the concepts we''ve covered, but in most
    cases, no further explanation will be given besides for the regex itself:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了一些用于不同目的的正则表达式。你应该能够使用我们介绍的概念来理解它们，但在大多数情况下，除了正则表达式本身外，不会提供进一步的解释：
- en: '![Figure 11.17: Regex and their purpose'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.17：正则表达式及其用途'
- en: '](img/C14377_11_17.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_17.jpg)'
- en: 'Figure 11.17: Regex and their purpose'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：正则表达式及其用途
- en: 'In this topic, you learned about the basics of regular expressions and their
    usefulness. Just a word of caution, though: while regexes are very powerful, they
    can also be very tricky to implement, and it can take some practice to get them
    right.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，你学习了正则表达式的基础及其用途。不过，有一个注意事项：虽然正则表达式非常强大，但它们也可能非常难以实现，正确使用它们可能需要一些练习。
- en: Now, for a bit of an admission. While our exercise presented regexes for validating
    phone numbers, they were for the sake of learning and education about regexes.
    In a real-world application, you would probably want to consider using a dedicated
    library for such validation. Several such libraries are available, and the advantages
    of using such libraries are that they are well thought out, tested, and support
    a wide variety of options and phone number formats from different countries around
    the world. One such library is Google's [libphonenumber](http://libphonenumber).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一点要坦白。虽然我们的练习展示了用于验证电话号码的正则表达式，但它们是为了学习和教育正则表达式而设计的。在实际应用中，你可能希望考虑使用专门的库来进行此类验证。有几种这样的库可用，使用这些库的优点是它们经过深思熟虑、经过测试，并支持来自世界各地的各种选项和电话号码格式。其中一个这样的库是Google的[libphonenumber](http://libphonenumber)。
- en: In the next topic, you'll get into clean coding.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，你将学习到整洁的编码。
- en: Best Practices for Clean Coding
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整洁编码的最佳实践
- en: Code often has a way of living longer than anyone would think it would. Just
    look at all the mainframe systems that are still in use today. At times, even
    experienced developers are baffled by it and have a difficult time understanding
    code they themselves wrote when looking at the code just a few weeks or months
    later. It behooves software developers to adopt a mindset of good practices and
    habits when coding.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 代码往往比任何人想象的都要长寿。只需看看今天仍在使用的所有大型机系统。有时，即使是经验丰富的开发者也会对它感到困惑，在几周或几个月后再次查看自己编写的代码时，很难理解。软件开发者有责任在编码时采取良好的实践和习惯的心态。
- en: Code is almost never written just once to never be used again. Often, you or
    someone else will need to work on the code at a later date. If you write clean
    code, you are helping your future self and co-workers work more efficiently when
    that time comes. You are also making it easier to maintain the system and fix
    bugs.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎永远不会只写一次就不再使用。通常，你或其他人会在以后需要修改代码。如果你编写了干净的代码，你将帮助未来的自己和同事在那时更高效地工作。你也在使系统维护和修复错误变得更加容易。
- en: Many of the ideas and practices in this section are based on the books and blogs
    of Robert C. Martin, also known as "Uncle Bob," who is a recognized expert in
    the field of clean coding and has produced popular books, blogs, and training
    videos. We will only present a brief overview and highlights, but entire books
    have been written on the subject. You are encouraged to delve deeper into this
    subject.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的许多想法和实践都基于罗伯特·C·马丁（Robert C. Martin）的书籍和博客，他也被称作“Uncle Bob”，是清洁编码领域的公认专家，并创作了广受欢迎的书籍、博客和培训视频。我们将只提供一个简要的概述和亮点，但关于这个主题已经写出了整本书。我们鼓励你深入研究这个主题。
- en: 'Look at the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一段代码示例：
- en: '[PRE25]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The purpose of this code is to calculate the circumference of a circle, but
    I''ll bet this was not very obvious to you based on how it is written. Perhaps
    adding some explanatory comments would help, but compare the preceding code to
    this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目的是计算圆的周长，但根据它的编写方式，这对你来说可能并不明显。也许添加一些解释性注释会有所帮助，但将前面的代码与以下代码进行比较：
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You would agree that this code was much more understandable and leaves little
    doubt about what it does, what the parameter is, and what is returned. Renaming
    the function from `circ` to `circumference` and the parameter from `r` to `radius`
    is all it took to achieve understanding. This was all done without the need to
    add any explanatory comments.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你会同意这段代码更容易理解，并且几乎不会对其功能、参数和返回值产生任何疑问。将函数从 `circ` 重命名为 `circumference`，将参数从
    `r` 重命名为 `radius` 就足以实现理解。这一切都无需添加任何解释性注释。
- en: 'We''ve improved our code so far by using better naming, but here''s another
    improvement worth making. The usual formula for circumference is `C = πd`, where
    `d` is the diameter. If you split our calculation into two steps, the code would
    be clearer. Compare the preceding code to the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用更好的命名改进了代码，但这里还有一个值得改进的地方。周长的常用公式是 `C = πd`，其中 `d` 是直径。如果你将我们的计算分成两个步骤，代码将更清晰。将前面的代码与以下代码进行比较：
- en: '[PRE27]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This simple change makes it clearer why the calculation needed to multiply the
    radius by 2, namely, to calculate the diameter before multiplying it by pi to
    get the circumference.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的更改使计算需要将半径乘以2的原因更加清晰，即先计算直径，然后再乘以π以得到周长。
- en: This may not seem like a big improvement, and arguably the extra line of code
    does not add much value or clarity. You would probably be correct in this simple
    instance. But consider how coding in such a way could potentially simplify scenarios
    where more complex calculations or logic is required.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不是很大的改进，并且可以说额外的代码行并没有增加多少价值或清晰度。在这个简单的例子中，你可能会正确地认为。但考虑一下以这种方式编码如何可能简化需要更复杂计算或逻辑的场景。
- en: Good Naming Practices
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好的命名习惯
- en: 'Use the following guidelines when naming variables, functions, or other objects:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名变量、函数或其他对象时，请遵循以下指南：
- en: '`timeElapsedInDays`, `daysSinceCreation`, and `ageInDays`. In general, code
    should be as self-documenting as possible and comments should be kept to a minimum.
    Comments have a way of becoming outdated as code is refactored and logic is changed
    over time, and programmers tend to forget to update them.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeElapsedInDays`, `daysSinceCreation`, 和 `ageInDays`。一般来说，代码应该尽可能地自我文档化，注释应尽量保持最少。随着代码重构和逻辑随时间变化，注释有变得过时的倾向，程序员也往往会忘记更新它们。'
- en: '`bookList` if it is in fact an array of books. Just calling it `books` is preferred.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它实际上是一个书籍数组，则使用 `bookList`。直接称为 `books` 更为可取。
- en: '`BookInfo` and `BookData`, you have made the names different without making
    them mean anything different. Use more specific names that differentiate what
    the purpose of each class is.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookInfo` 和 `BookData`，你虽然使名称不同，但并没有使它们代表不同的含义。使用更具体的名称来区分每个类的用途。'
- en: '`const yyyymmdstr = moment().format("YYYY/MM/DD");`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const yyyymmdstr = moment().format("YYYY/MM/DD");`'
- en: 'Now, let''s compare it with a good one:'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们与一个好的例子进行比较：
- en: '[PRE28]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`SECONDS_IN_DAY` is more meaningful than `86400` and explains what that number
    represents better. It also makes it easier to locate later when searching over
    the body of text.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECONDS_IN_DAY` 比起 `86400` 更有意义，并且更好地解释了这个数字代表什么。它还使得在搜索文本主体时更容易定位。'
- en: '`Customer`, `Account`, and `AddressParser`. Avoid words such as `Manager`,
    `Processor`, `Data`, or `Info`, which are either verbs or too generic.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Customer`、`Account` 和 `AddressParser`。避免使用像 `Manager`、`Processor`、`Data` 或
    `Info` 这样的词，这些词要么是动词，要么过于通用。'
- en: '`addFunds`, `deleteUser`, or `save`. Accessors and mutators should be prefixed
    with `get` or `set`.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addFunds`、`deleteUser` 或 `save`。访问器和修改器应该以 `get` 或 `set` 前缀。'
- en: '`fetch`, `retrieve`, and `get`, which do the same thing. It''s best to pick
    one word and use it consistently across your code.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch`、`retrieve` 和 `get` 都做同样的事情。最好选择一个单词并在代码中一致地使用它。'
- en: '`eatMyShorts()` to mean `abort()`.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `eatMyShorts()` 用于表示 `abort()`。
- en: '**Don''t add unneeded context**: If your class or object is already named descriptively,
    there is no need to repeat the name in the variables within. Take a look at the
    following examples.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要添加不必要的上下文**：如果你的类或对象已经具有描述性的名称，就没有必要在变量中重复该名称。看看以下示例。'
- en: 'This is bad:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是错误的：
- en: '[PRE29]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Whereas this is good:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而这是好的：
- en: '[PRE30]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Following are the best practices for functions:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数的最佳实践：
- en: '**Functions should only do one thing and be small**: When functions are concise
    and limited in what they do, they are easier to understand, test, and work with.
    They would also read cleaner and be refactored easily. Coupled with a good function
    name, they are self-documenting as well.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数应该只做一件事情并且保持简洁**：当函数简洁且功能有限时，它们更容易理解、测试和操作。它们也会读起来更清晰，并且更容易重构。结合良好的函数名，它们也是自我文档化的。'
- en: 'Here''s a bad function:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个糟糕的函数：
- en: '[PRE31]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s a good function:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个好的函数：
- en: '[PRE32]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Limit the number of function arguments**: Ideally, there should be no more
    than two or three arguments. This makes testing easier. If there are more arguments,
    consider that your function is probably trying to tackle too much and should be
    split into multiple functions.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制函数参数的数量**：理想情况下，参数不应超过两个或三个。这使得测试更容易。如果有更多参数，考虑你的函数可能试图处理太多事情，应该拆分成多个函数。'
- en: '**Function names should say what they do**: Here''s an example of a bad function
    name:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数名应该说明其功能**：以下是一个糟糕的函数名示例：'
- en: '[PRE33]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is a good function name:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个好的函数名：
- en: '[PRE34]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`doSomething()` and instead turns into `doSomethingOrSomethingDifferentIfAFlagIsSet()`,
    it''s time to split the function.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `doSomething()` 和 `doSomethingOrSomethingDifferentIfAFlagIsSet()`，那么是时候拆分函数了。
- en: 'Take a look at the following code:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE35]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Rather than using the preceding code, use the following instead:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是使用前面的代码，可以使用以下代码代替：
- en: '[PRE36]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`playerX` and `playerY` variables represent the character''s current coordinates:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerX` 和 `playerY` 变量表示角色的当前坐标：'
- en: '[PRE37]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It is better to take x as a parameter and reassign the result to a global variable
    outside the function so that the function remains pure and maintains predictable
    return values (and makes it easier to test):'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最好将 x 作为参数传递，并将结果重新赋值给函数外部的全局变量，这样函数保持纯净并保持可预测的返回值（并且使测试更容易）：
- en: '[PRE38]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Side effects and pure functions are covered in more detail in *Chapter 14, Understanding
    Functional Programming*, on functional programming. Another important example
    is to clone objects, arrays, or lists when making modifications, rather than directly
    doing the modification itself on the input.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 副作用和纯净函数在 *第14章，理解函数式编程* 中有更详细的介绍。另一个重要例子是在进行修改时克隆对象、数组或列表，而不是直接在输入上进行修改。
- en: '**Create functions to capture conditional clauses**: Your code could become
    cluttered, unfocused, and hard to follow if you have complex conditions. Creating
    dedicated functions for your conditions and naming them descriptively makes the
    code self-documenting and easier to follow.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建函数来捕获条件语句**：如果你有复杂的条件，你的代码可能会变得杂乱无章、缺乏焦点且难以理解。为你的条件创建专用函数并给它们起描述性的名称，可以使代码自我文档化并更容易理解。'
- en: 'An example of a bad function:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个糟糕的函数示例：
- en: '[PRE39]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'An example of a good function:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个好的函数示例：
- en: '[PRE40]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: JavaScript Linters
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript Linters
- en: A linter is a tool that analyzes source code to help you debug your code, find
    potential issues and bugs and check coding styles (which is often subjective). Using
    a linter in your projects could help you and your team improve the quality of
    your code and provide consistent styling, which could help smooth out differences
    of code that different team members write.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查工具是一种分析源代码的工具，可以帮助您调试代码，查找潜在的问题和错误，并检查编码风格（这通常是主观的）。在项目中使用代码检查工具可以帮助您和您的团队提高代码质量，并提供一致的样式，这有助于平滑不同团队成员编写的代码之间的差异。
- en: 'Linters can typically be used in three different ways:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查工具通常可以以三种不同的方式使用：
- en: Typing or pasting your code into the online version of a tool via a browser
    page. This is the simplest way, but it is not convenient for anything but small
    spot checks.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过浏览器页面将您的代码键入或粘贴到工具的在线版本中。这是最简单的方法，但不适用于任何除了小范围检查之外的事情。
- en: Using a plugin for your IDE or text editor, either to show your errors and warnings
    as you type or separately.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您 IDE 或文本编辑器的插件，在您键入时显示错误和警告，或者单独显示。
- en: Running scans and generating reports as part of your automated build process
    every time your source code is built, or periodically. (If desired, you can even
    cause builds to fail if the scan results in errors of sufficient severity.)
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建源代码时运行扫描并生成报告，或者定期进行。 (如果需要，您甚至可以设置构建失败，如果扫描结果显示出足够严重的错误。)
- en: 'There are several linters available for JavaScript, including the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JavaScript，有几种可用的代码检查工具，包括以下几种：
- en: '**ESLint**: This is very configurable and customizable. This perhaps makes
    it the most complex and hardest linter to just pick up and start using.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ESLint**：这是一个非常可配置和可定制的工具。这也许使得它成为最复杂且最难上手使用的代码检查工具。'
- en: '**JSLint**: This is somewhat configurable but highly opinionated on a popular
    but particular coding style, as described in the tool''s documentation.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSLint**：这是可以配置的，但在一个流行的但特定的编码风格上非常主观，如工具文档中所述。'
- en: '**JSHint**: This is somewhere between the other two in terms of customizability.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSHint**：在可定制性方面，它介于其他两种之间。'
- en: 'Exercise 11.03: JSLint'
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.03：JSLint
- en: 'This exercise will describe `JSLint` in more detail since it is the easiest
    to set up and start using, uses a good coding style, and is a good fit for many
    projects. Let''s get started:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将更详细地描述 `JSLint`，因为它最容易设置和开始使用，使用良好的编码风格，并且适合许多项目。让我们开始吧：
- en: Open a web browser such as Google Chrome and go to [www.jslint.com](http://www.jslint.com).
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个网络浏览器，例如 Google Chrome，并访问 [www.jslint.com](http://www.jslint.com)。
- en: 'In the Options section on the lower part of the screen, select `Assume → a
    browser` (this sets the scan to define certain objects that are usually available
    in a browser, such as a `document` object):![Figure 11.18: Online version of JSLint'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕下方的“选项”部分，选择“Assume → a browser”（这将设置扫描以定义通常在浏览器中可用的某些对象，例如 `document` 对象）：![图
    11.18：JSLint 的在线版本
- en: '](img/C14377_11_18.jpg)'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_11_18.jpg)'
- en: 'Figure 11.18: Online version of JSLint'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.18：JSLint 的在线版本
- en: Paste in the code from `conventional.html` file into the *Source* window.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `conventional.html` 文件中的代码粘贴到 *Source* 窗口中。
- en: 'Press the *JSLint* button, which will result in an output that''s similar to
    what''s shown in the following screenshot:![Figure 11.19: Result of the scan'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 *JSLint* 按钮，这将产生一个输出结果，类似于以下截图所示：![图 11.19：扫描结果
- en: '](img/C14377_11_19.jpg)'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_11_19.jpg)'
- en: 'Figure 11.19: Result of the scan'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.19：扫描结果
- en: 'The scan results have multiple warnings of the following: `Use double quotes,
    not single quotes`. This is perhaps an example of a subjective preference as it
    is common in many languages for single characters to use single quotes, not double-quotes.
    Luckily, this is a configurable option if you select `Tolerate → single quote
    strings` in the Options section, as shown in the following screenshot. After clicking
    the *JSLint* button once again, this will result in all the warnings being removed:![Figure
    11.20: Tolerate → single quote strings option'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描结果有多个以下警告：`使用双引号，而不是单引号`。这可能是一个主观偏好的例子，因为在许多语言中，单字符通常使用单引号，而不是双引号。幸运的是，这是一个可配置的选项，如果您在“选项”部分选择“Tolerate
    → single quote strings”，如以下截图所示。再次点击 *JSLint* 按钮后，这将导致所有警告被移除：![图 11.20：Tolerate
    → single quote strings 选项
- en: '](img/C14377_11_20.jpg)'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_11_20.jpg)'
- en: 'Figure 11.20: Tolerate → single quote strings option'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.20：Tolerate → single quote strings 选项
- en: 'An alternative way of specifying the option to allow single quote strings (and
    a number of other options) is by means of a special comment syntax that begins
    with `/*jslint`. Uncheck the `Tolerate → single quote strings` option and add
    the following to the top of the code:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The warnings will continue to be empty upon clicking the JSLint button.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This exercise explains how your JavaScript code compiles using the `Jslint`
    tool. It also helps to decrease the debugging time by providing a fixing issues
    report.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.03: Refactoring to Clean Code'
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making a habit of using clean coding best practices is an essential skill. We
    are now ready to put our newly acquired clean coding skills to test.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Look at the JavaScript code in the `<script>` section of the following file
    and figure out how you can refactor it to be cleaner and easier to maintain and
    test.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In short, this is a simple web page that calculates worker pay based on the
    number of hours, pay rate per hour, and worker type. There are three types of
    workers that have different rules regarding how their pay is determined: `Standard`,
    who gets overtime pay at `No Overtime`, who do not get any overtime, and `Double
    Overtime` workers, who are paid **2x** after **50** hours.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also format checks for the two number fields (implemented with regexes)
    and a facility to show validation error messages. The following screenshot shows
    the output with valid inputs (there is only minimal color and styling in this
    implementation):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21: Sample output with valid inputs'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_21.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.21: Sample output with valid inputs'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output with a validation error:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22: Sample output with a validation error'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_22.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.22: Sample output with a validation error'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 748.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: To refactor the code, create a function called `processForm()`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function called `resetErrorsAndResults()`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class to hold form field values and perform validations.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a function called `getFormFields()`. This function is limited to
    getting the values from the form and creating an instance of the `FormFields`
    class.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `displayError()` and `displayResult()` functions to display errors
    and results.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create the `calculateStandardWorkerPay()`, `calculateNoOvertimeWorkerPay()`,
    and `calculateDoubleOvertimeWorkerPay()` functions, which take the same two parameters
    and have the same return value definition so that they can be called abstractly
    in `doCalculation()`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the best practices for clean and maintainable
    coding. As you saw in this chapter's activity, the refactored code that used clean
    coding techniques resulted in code that was much longer than before. However,
    you can see that the code as-is is much cleaner and is easier to understand and
    test compared to the original.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: It is arguably overkill to refactor to the degree that we presented for our
    simple application, and many developers feel this way. But the value of this programming
    style really shows itself more in a complex real-world application, and it is
    good practice to do work in this way. Developers and tech leads need to decide
    what standards and clean coding practices make sense for their particular project.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们简单应用所展示的这种程度的重构，可以说是过度了，许多开发者都有这样的感觉。但真正体现这种编程风格价值的，其实是在复杂现实世界的应用中，以这种方式工作是一种良好的实践。开发者和技术负责人需要决定对于他们特定的项目，哪些标准和清洁编码实践是有意义的。
- en: In the next chapter, you will explore the current trends and cutting-edge features
    that JavaScript has to offer.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索JavaScript所能提供的当前趋势和前沿特性。
