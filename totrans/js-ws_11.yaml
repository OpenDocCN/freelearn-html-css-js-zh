- en: 11\. Creating Clean and Maintainable Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to identify and implement basic
    regular expressions (regex); use best practices to produce clean and maintainable
    code; utilize code quality tools such as `ESLint`, `JSLint`, and `JSHint` and
    implement strategies for refactoring code.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the techniques that can be used for pattern
    matching and clean coding, which have many uses, perhaps even to facilitate your
    testing as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular expressions** (**regex** for short) are a concise and powerful method
    to search for and match patterns. They may appear alien and intimidating at first,
    but once you learn the basics, they will quickly appear less difficult, and so
    you are likely to recognize their usefulness. Regexes are common in many languages
    and in tools where text and data are involved. So, it is a worthwhile investment
    to take the time to learn them. A pattern that''s expressed as a regex is usually
    much shorter than the equivalent code that''s required to parse and match the
    same pattern using conventional techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Making use of regexes also leads to clean and maintainable coding practices.
    For programming projects to be successful, it is critical that the code is easily
    understood by others and that it is orderly, focused, and flexible. This chapter
    introduces techniques and best practices for coding, starting with choosing the
    clearest and most understandable names for your variables and methods.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Regex?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **regex** is a sequence of characters that form a pattern that's used to search.
    Each character in the pattern either has special meaning (a metacharacter) or
    is meant to match the character itself (a literal). This is perhaps best understood
    by the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a demonstration of the difference between pattern matching with conventional
    coding versus regex techniques, consider the following code for matching phone
    number format patterns in a conventional way. We''ll then rewrite the matching
    logic using a regex for comparison. To keep things simple, we will only look for
    phone numbers that match the following pattern, which is common for phone numbers,
    particularly in the United States:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `X` can be any digit from `0-9`, and the first digit cannot be a zero
    or one (only `2-9` are permitted). For example, `234-567-8901` is a valid phone
    number in this format.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following code to do the matching using conventional methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot show the output of the preceding code when a number
    is entered in an invalid format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Sample output when a number is input in an incorrect format'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.1: Sample output when a number is input in an incorrect format'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the output when a number is entered in a valid format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Sample output when a number is input correctly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.2: Sample output when a number is input correctly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus on the important parts of the JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These lines set up the phone number validation, which is to be done as the user
    enters a value. It finds the DOM element of the input text and adds an event listener
    for the `input` event. This event occurs when the value of `<input>` is changed,
    such as with a keypress or even if a value is pasted in using cut/paste. When
    triggered, the `validatePhoneNumber()` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the code that checks whether a character is a digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function has a parameter that must be just one character. What may not
    be intuitive is that JavaScript allows greater than or less than operators on
    character types. This allows us to check that the character is any digit in the
    range between the `0` and `9` characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `validatePhoneNumber()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks the expected length of the phone number to make sure there are no extraneous
    characters, such as additional digits, alphabetic characters, or symbols. Note
    that since we're calling the `trim()` function when we initially read the phone
    number value, this check is forgiving of leading and trailing whitespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks that the first character is not a `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks that the first three characters are digits (indices `0-2`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rather than calling the `isDigit()` function multiple times, we could have added
    parameters to the function so that multiple characters would be checked in one
    invocation. However, for the purposes of this exercise, we chose to keep the code
    simpler and easier to understand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Checks for the `-` character afterward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the validation repeats and is similar for the rest of the characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the validation message is formed and set in the `<div>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will now compare this logic to an equivalent implementation using regexes.
    We'll describe regexes more methodically and in more depth in the next section,
    but for now, we'll look at how to code with regex techniques, even though it may
    not make much sense to you yet. We will code an alternative to the phone number
    validation function we presented, which uses regexes. So, don't worry if you don't
    quite understand all the concepts yet, as they will be explained in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the preceding code, which is for pattern matching with conventional
    methods. Let's modify it so that it uses a regex.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, find the `validatePhoneNumber()` function and the declaration of
    the `valid` variable. Then, delete the entire expression all the way to the semicolon
    (`;`) character until the comment above it. Replace the area you deleted with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you only have a shell of a regex in the area between the two
    forward slash marks.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first forward slash, add a `^` character (called a caret). Your code
    should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `^` symbol is an **anchor** that indicates matching should begin at the
    start of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the characters `[2-9]` so that the code now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `[2-9]` characters specify a `2` and `9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you will be able to see how you are progressively adding more characters
    with each step. In a similar fashion, add the remaining characters one by one,
    as shown in the left column of the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: Table of characters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.3: Table of characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you have seen the power of regular expressions and that all of them can
    be expressed in just one line of code. The different concepts of a regular expressions
    are shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Showing different concepts in the regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.4: Showing different concepts in the regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: Regexes in Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the upcoming sections, the following sample phrase is used for illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The ships were loaded with all these belongings of the mother"'
  prefs: []
  type: TYPE_NORMAL
- en: This phrase will be used to demonstrate various regex concepts, including literal
    characters, word boundaries, character classes, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Literal Characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest regex is one of more `the`. This indicates a pattern that is a
    match if the `t` character is immediately followed by `h` and finally an `e` character.
    This expression would have four matches in the sample phrase: the initial `the`,
    the second to last word, `the`, `the` in the word `these`, and the sequence of
    `the` as part of the word `mother`.'
  prefs: []
  type: TYPE_NORMAL
- en: Special Characters, Anchors, and Escaping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a regex only had literals, its usefulness would be limited. In most cases,
    you do not want to only match literals; therefore, regexes have a number of characters
    that have special meanings. These are also known as metacharacters. Two of these
    special characters are the `^` and `$` **anchors** that you saw earlier, which
    indicate the beginning and end of a string, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you change the regex to `^the`, only the initial `the` of the phrase
    would now be a match since this is the only instance of `the` in the phrase that
    is at the beginning of the string. Anchors are often important in situations where
    you need to avoid matching too much that is not intended to be matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the most common characters that have special meaning in regexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Special characters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.5: Special characters'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you need to use any of these characters in your regexes as a literal character,
    in most cases, the character will need to be escaped. You do that by placing a
    backslash `\` before the character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to match a dollar sign as part of your pattern, you would use `\$`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some less obvious escapes are the backslash character itself (you would just
    use two consecutive backslashes, for example, `\\`), and a dot, where `\.` is
    the correct escaping sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word Boundary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another type of anchor is a `\b` (a backslash followed by a `b`). A word boundary
    is defined as either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of a string, followed by a word character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The character between whitespace and a word character, or after a word character
    leading to either whitespace or the end of the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the word characters are defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the preceding regex was changed to `\bthe`, there would only be three matches
    in the sample phrase: the four previous matches, minus `the` in `mother`. (The
    initial `\b` of the pattern are special characters, and the remainder are literal
    characters.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the regex was changed to `\bthe\b`, only the two standalone `the` words would
    be matches, and not the ones in `these` or `mother`. This is one way to specify
    to search for whole words, but with no other leading or trailing characters in
    a given word.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shorthand Character Classes and Word Characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of `\d` sequence, which denotes any digit `[0-9]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another is the `\w`, which is defined as `[A-Za-z0-9_]`. (Character classes
    and ranges will be defined in more detail next. For now, this is read as a character
    in the range of uppercase characters `A-Z`, range of characters `a-z`, range of
    digits `0-9`, or the underscore `_` character.) Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `the\w` regex were used on the preceding sample phrase, only the sequence
    of `the` in the words `these` and `mother` would be a match, since the other two
    `the` words do not have a word character following it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `\wthe\w` regex were used, only the sequence of `the` in the word `mother`
    would match, as it is the only place in the string where the sequence `the` is
    both preceded and followed by a word character. This is one way to specify how
    to search for characters that are only contained within a word.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining the word boundary and word character shortcuts, if the regex `\bthe\w`
    were used, only the sequence of `the` in the word `these` would match as it is
    the only place in the string where the sequence `the` starts on a word boundary
    and is followed by a word character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another common shorthand character class is `\s`, which is shorthand for whitespace,
    including space characters, tabs, and newlines.
  prefs: []
  type: TYPE_NORMAL
- en: Inverse Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every shorthand character class has an inverse class as well, denoted by making
    the letter uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\B`: The opposite of a word boundary, such as in the middle of a word'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\D`: Represents any non-digit character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\W`: Any character that is not included in `[A-Za-z0-9_]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\S`: Any non-whitespace character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, as the inverse of the first example in the previous section, if
    the `the\W` regex were used on the preceding sample phrase, only the two `the` characters
    would match, including the trailing space character. The words `these` and `mother`
    would be a match, since in both cases there is a word character following `the`.
  prefs: []
  type: TYPE_NORMAL
- en: Dot Character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dot, `.`, matches any character except newlines. For instance, the `.h.`
    regex looks for any `h` and matches it with the character before and after it,
    as long as it is not a newline. The highlighted characters that follow are the
    result of applying the regex to the earlier sample phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The ships were loaded with all these belongings of the mother"'
  prefs: []
  type: TYPE_NORMAL
- en: Take special note of the third match of the last two letters of the word `with`,
    along with the space character that follows it. It is easy to forget that a dot
    matches any character, including a space. This can be a common error if you do
    intend to allow spaces in your pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One or more characters or character classes enclosed in square brackets, `[...]`,
    indicates we should match any of the given characters. This is called a **set**.
    Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The `[AEIOUaeiou]` regex can be used to match vowel characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When combining a set followed by two literal characters, the `[oi]ng` regex
    would match the `ong` and the `ing` in the word `belongings` (from the sample
    phrase).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One `[2-9]`, which indicated a character between `2` and `9`. Similar to sets,
    ranges are specified within square brackets, `[...]`, and use a dash character
    to separate the characters that indicate the range.
  prefs: []
  type: TYPE_NORMAL
- en: Another range you saw earlier was `[A-Za-z0-9_]`, which specified the word characters.
    This also shows how multiple ranges and even a character that's not part of a
    range can be indicated in one expression, as this allows characters from `A-Z`,
    `a-z`, and `0-9`, as well as the underscore character.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding Sets and Ranges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The opposite of regular sets and ranges, an excluding range indicates to "match
    a character except for the following". Excluding sets or ranges is indicated by
    placing a caret character, `^`, immediately after the first square bracket in
    the expression.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, `[^AEIOUaeiou]` would match any character that is NOT a vowel.
  prefs: []
  type: TYPE_NORMAL
- en: The dash can also be included in the exclusion to indicate a range of characters
    to be excluded. For example, `[^0-9]` would indicate to match any character that
    is not a digit (similar to `\d`).
  prefs: []
  type: TYPE_NORMAL
- en: Quantifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **quantifier** specifies how many of a given character, character class, or
    token are required for a match.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most straightforward is a `{4}`. For example, the `a{4}` regex would
    require the letter `a` to be repeated four times, and `\d{3}` would require three
    digits in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Its close cousin, the range quantifier, can be specified using a format similar
    to `{min,max}`. This one would match if anything between the specified minimum
    and maximum number of occurrences was present. For example, the `a{2,5}` regex
    would match any of `aa`, `aaa`, `aaaa`, or `aaaaa`.
  prefs: []
  type: TYPE_NORMAL
- en: A special type of range allows for an unbounded upper limit if the numeral after
    the comma is omitted. For example, `a{3,}` would match any number of consecutive
    `a` characters of at least three occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand Quantifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three quantifiers that are used so often that they have special shortcut
    characters designated to denote them. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Quantifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.6: Quantifiers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining these shorthand qualifiers with the concepts we previously covered
    (literals, character classes, sets, ranges, and so on), the following are example
    regexes and what they would match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: Regex and their Matches'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.7: Regex and their Matches'
  prefs: []
  type: TYPE_NORMAL
- en: Alternation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say you want your pattern to allow either of two (or more) words. You
    can do this by separating the words with a pipe `|` character, which is equivalent
    to an `OR` indicating `expression1 OR expression2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, it is also a good idea to enclose the alternative expressions
    in parenthesis, for example,`(expression1|expression2)`, to separate them from
    the rest of the pattern. For example, to scan for either a word, `the`, followed
    by one or more whitespace characters, which would be either `mother` or `father`,
    the regex would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Many More Regex Concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter covers only a brief overview of basic regex concepts and provides
    a good background so that you can get started with them. You are encouraged to
    explore more advanced features using the many available resources. These include
    the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Greedy versus lazy quantifiers: [https://packt.live/33vxqvQ](https://packt.live/33vxqvQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capturing groups: [https://packt.live/34Iq0G0](https://packt.live/34Iq0G0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backreferences: [https://packt.live/2NqrDCe](https://packt.live/2NqrDCe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lookahead and lookbehind: [https://packt.live/2NrkMbR](https://packt.live/2NrkMbR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sticky flag: https://packt.live/32q86Gw'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The internals of how regex engines actually work: [https://packt.live/2oXQUKE](https://packt.live/2oXQUKE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern Specification and Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have covered the elements that comprise regex patterns, but now,
    we will cover how these patterns are conveyed in JavaScript code. The most common
    method is to enclose the pattern in a pair of slash characters, for example, `/pattern/`.
    Flags can also be added after the second slash, though this is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags can change the behavior of how matching and searching occurs. The most
    common flags are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`g`: If specified, all matches are returned (if not specified, only the first
    match is returned by default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i`: Makes the matching case-insensitive; there''s no differentiation between
    uppercase and lowercase letters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others include `m` (multiline search), `s` (dot  `.` matches newline), `u` (Unicode
    support), and `y` (sticky mode).
  prefs: []
  type: TYPE_NORMAL
- en: Finding Matches with String.match()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript `String` class has a number of built-in methods that accept regex
    parameters. This section outlines some of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common method you would use is `String.match()`. This method behaves
    differently, and its return value varies depending on whether the `g` flag is
    included:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is no `g` flag: Searching stops after the first match is found. The
    result is an array with the match returned as the array element, the additional
    property `index`, indicating the position where the match was found, and some
    additional properties. (Note that it has other functionalities if the regex contains
    groupings, but groups are not covered in this chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If there is a `g` flag: Searches for all possible matches and returns those
    found in an array. There are no other properties in the return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 11.01: The Effect of the g Flag'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code illustrates the difference regarding whether the `g` flag
    is present or not. It matches words that begin with the letter `t`. (The `i` flag
    is also demonstrated to make the match case insensitive.) Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Google Chrome browser, go into `Developer Tools` (Menu (the three dots
    in the upper right of the screen), `More Tools` | `Developer Tools`, or just hit
    the `F12` key).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following into the console to set up our test string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`g` flag is not present. Type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the steps that follow, the lines of the code snippets that begin with `>`
    indicate what you should type in. The lines that begin with `<-` is the output
    you are expected to see.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s see what was matched. To do that, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check at what character index the match was made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since there is no `g`, we are not expecting any further matches. To verify
    this, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The matches from the first expression will be displayed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.8: Full output of the first match expression'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_11_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 11.8: Full output of the first match expression'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`g` flag is present. Type the following to reassign the match variable to include
    `g` (and `i`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type the remaining lines in succession, checking the expected output of each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The matches of the expression with a `g` will be displayed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.9: Full output of the match expression with the g flag'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.9: Full output of the match expression with the g flag'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you saw how to use the `g` flag of the `String.match()` method
    to can obtain multiple matches. Next, you will learn about other methods that
    involve regexes.
  prefs: []
  type: TYPE_NORMAL
- en: Other String Methods for Regexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table briefly describes some of the other methods in the String
    object related to regexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10: String methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.10: String methods'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another useful method to take note of when using regexes in JavaScript.
    The `test()` method returns a simple `true` or `false` that indicates whether
    a match has been found. You can use it in code such as the following to test whether
    a string begins with the characters `hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are other more advanced methods of the String object that are not covered
    here. JavaScript also has a dedicated built-in RegExp object that supports advanced
    use cases (the `test()` method actually belongs to RegExp).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.02: Modifying Regex to Match a Pattern'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall the regex pattern we presented at the beginning of this chapter, which
    we used to match phone numbers in the format `XXX-XXX-XXXX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using what you''ve learned so far, in this exercise, you will modify the regex
    to match phone numbers of a slightly different format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many sites that help you craft and test regexes. We will use [https://regex101.com/](https://regex101.com/)
    to work on our regex. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, compare the two formats to see how similar they are. Notice that the
    new format, `(XXX) XXX-XXXX`, is identical to the original format, `XXX-XXX-XXXX`
    , for the last seven digits and is only different at the beginning of the pattern.
    We only need to replace the first four characters of the original pattern (the
    three digits and a dash, `XXX-`) with the new characters (an open parenthesis,
    three digits, a close parenthesis, and a space).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to come up with a regex that corresponds to `(XXX)`, including a trailing
    space character that is not displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break this code down:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`\(`: The first character you need to match is a parenthesis. Remember that
    parentheses are special characters (metacharacters) in a regex, so they need to
    be escaped with a backslash to indicate that you really intend for the parenthesis
    character to be matched.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[2-9]`: A character range to match a character between 2 and 9.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d`: This is a character class that specifies to match a digit character.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{2}`: A fixed quantifier that indicates that the previous digit character
    (\d) needs to repeat twice for it to be considered a match.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\)`: The closing parenthesis, also escaped.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By combining this with the rest of the original regex, you get the final regex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test this solution, there are many sites that help you craft and test regexes.
    You can go to [https://regex101.com/](https://regex101.com/) and enter the regex
    in the input box. Also, enter `(234) 567-8910` in the TEST STRING area, as shown
    here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.11: Screenshot of https://regex101.com/'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.11: Screenshot of https://regex101.com/'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the MATCH INFORMATION section indicates that our test string
    is a full match.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is quite a bit happening on this screen, and a lot of information that
    helps you understand and work with regexes. If you look at the REGULAR EXPRESSION
    input box, you will see that the various elements of the regex have been color-coded
    to help break it down to its constituent parts. The EXPLANATION area goes even
    further and provides detailed explanations of each character or token. Since the
    full text was not visible in the preceding screenshot, here are the explanations
    that were provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12: The EXPLANATION area'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.12: The EXPLANATION area'
  prefs: []
  type: TYPE_NORMAL
- en: Adding More Strings to the Regex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides having a test string that passes matching, it is a good idea to also
    put in other test strings that are similar but are not expected to pass. The following
    screenshot shows some other such patterns in the TEST STRING area, but notice
    that only the first one of those patterns shows a match (as expected):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13: More test strings that are not expected to match'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.13: More test strings that are not expected to match'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern to match phone numbers in the previous exercise works okay, but
    it looks for a very specific pattern. The following activity will challenge you
    into making the regex more flexible so that it accepts multiple phone number formats.
  prefs: []
  type: TYPE_NORMAL
- en: What if you were asked to come up with one regex that can be used to match either
    of the `XXX-XXX-XXXX` or `(XXX) XXX-XXXX` patterns?
  prefs: []
  type: TYPE_NORMAL
- en: The challenge is to come up with just one regex that can match either phone
    number format. Before presenting a good solution, let's consider an incorrect
    and naive one that, at first glance, seems like the most obvious approach to take,
    but is actually flawed and fraught with pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that the second format is mostly similar to the original one, with
    the exception that the first set of three digits begins and end with parenthesis
    characters (`(` and `)`) and is followed by a space rather than a dash character.
    You may begin to think of representing these differences by adding parenthesis
    to the regular expression and simply making them optional (using the ? quantifier)
    and placing the dash and space in a set (using **[]** syntax). Such a regex would
    look like this (the additions are emphasized):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that this regex is incomplete and would also allow matches of
    some incorrect and undesirable formats, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(234 567-8901` (no ending parenthesis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`234) 567-8901` (no starting parenthesis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`234 567-8901` (using a space character inappropriately)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(234)-567-8901` (using a dash inappropriately)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be seen if you enter these test strings into the tool as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14: All the test strings match due to a flawed regex'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.14: All the test strings match due to a flawed regex'
  prefs: []
  type: TYPE_NORMAL
- en: Only the first two test strings should have matched, but they all did (indicated
    by them all being highlighted in blue).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: Expanding Phone Number Matching Patterns to Accept Multiple
    Formats'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, we modified a regex to match phone numbers that have
    the following format: `(XXX) XXX-XXXX`. In this activity, we will create one regex
    that can be used to match either of the `XXX-XXX-XXXX` or `(XXX) XXX-XXXX` patterns.
    Once you have completed this activity, you should have a regex that accepts either
    of the `(XXX) XXX-XXXX` or `XXX-XXX-XXXX` number formats.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for the activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Indicate that the regex snippets corresponding to each format are alternate
    expressions of an alternation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combine them with the rest of the original regex in the previous exercise to
    get the complete regex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, test the regex with the following numbers: (234) 567-8901; 234-567-8907;
    234) 567-8901; (234 567-8901; 234 567-8901; and (234)-567-8901.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output of this activity should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15: Output to the Activity 11.01'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.15: Output to the Activity 11.01'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the activity can be found on page 745.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.02: Expanding Phone Number Matching Patterns to Accept a Particular
    Format'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will`+XXX` ), such as one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once you've completed this activity, you should have a regex that successfully
    tests for the `+xxx` format.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps:**'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the regex for the `+XXX` pattern (where between 1-3 digits are acceptable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combine this with the original regex to get the complete regex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the regex to allow the use of space or dot characters as digit separators
    rather than only dashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test the patterns with the following numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.16: Many of the patterns that match the regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.16: Many of the patterns that match the regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 747.
  prefs: []
  type: TYPE_NORMAL
- en: Useful Regexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table presents a number of regexes for different purposes. You
    should be able to understand them using the concepts we''ve covered, but in most
    cases, no further explanation will be given besides for the regex itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17: Regex and their purpose'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.17: Regex and their purpose'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this topic, you learned about the basics of regular expressions and their
    usefulness. Just a word of caution, though: while regexes are very powerful, they
    can also be very tricky to implement, and it can take some practice to get them
    right.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, for a bit of an admission. While our exercise presented regexes for validating
    phone numbers, they were for the sake of learning and education about regexes.
    In a real-world application, you would probably want to consider using a dedicated
    library for such validation. Several such libraries are available, and the advantages
    of using such libraries are that they are well thought out, tested, and support
    a wide variety of options and phone number formats from different countries around
    the world. One such library is Google's [libphonenumber](http://libphonenumber).
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, you'll get into clean coding.
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices for Clean Coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code often has a way of living longer than anyone would think it would. Just
    look at all the mainframe systems that are still in use today. At times, even
    experienced developers are baffled by it and have a difficult time understanding
    code they themselves wrote when looking at the code just a few weeks or months
    later. It behooves software developers to adopt a mindset of good practices and
    habits when coding.
  prefs: []
  type: TYPE_NORMAL
- en: Code is almost never written just once to never be used again. Often, you or
    someone else will need to work on the code at a later date. If you write clean
    code, you are helping your future self and co-workers work more efficiently when
    that time comes. You are also making it easier to maintain the system and fix
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the ideas and practices in this section are based on the books and blogs
    of Robert C. Martin, also known as "Uncle Bob," who is a recognized expert in
    the field of clean coding and has produced popular books, blogs, and training
    videos. We will only present a brief overview and highlights, but entire books
    have been written on the subject. You are encouraged to delve deeper into this
    subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of this code is to calculate the circumference of a circle, but
    I''ll bet this was not very obvious to you based on how it is written. Perhaps
    adding some explanatory comments would help, but compare the preceding code to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You would agree that this code was much more understandable and leaves little
    doubt about what it does, what the parameter is, and what is returned. Renaming
    the function from `circ` to `circumference` and the parameter from `r` to `radius`
    is all it took to achieve understanding. This was all done without the need to
    add any explanatory comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve improved our code so far by using better naming, but here''s another
    improvement worth making. The usual formula for circumference is `C = πd`, where
    `d` is the diameter. If you split our calculation into two steps, the code would
    be clearer. Compare the preceding code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This simple change makes it clearer why the calculation needed to multiply the
    radius by 2, namely, to calculate the diameter before multiplying it by pi to
    get the circumference.
  prefs: []
  type: TYPE_NORMAL
- en: This may not seem like a big improvement, and arguably the extra line of code
    does not add much value or clarity. You would probably be correct in this simple
    instance. But consider how coding in such a way could potentially simplify scenarios
    where more complex calculations or logic is required.
  prefs: []
  type: TYPE_NORMAL
- en: Good Naming Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following guidelines when naming variables, functions, or other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timeElapsedInDays`, `daysSinceCreation`, and `ageInDays`. In general, code
    should be as self-documenting as possible and comments should be kept to a minimum.
    Comments have a way of becoming outdated as code is refactored and logic is changed
    over time, and programmers tend to forget to update them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bookList` if it is in fact an array of books. Just calling it `books` is preferred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BookInfo` and `BookData`, you have made the names different without making
    them mean anything different. Use more specific names that differentiate what
    the purpose of each class is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const yyyymmdstr = moment().format("YYYY/MM/DD");`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s compare it with a good one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SECONDS_IN_DAY` is more meaningful than `86400` and explains what that number
    represents better. It also makes it easier to locate later when searching over
    the body of text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Customer`, `Account`, and `AddressParser`. Avoid words such as `Manager`,
    `Processor`, `Data`, or `Info`, which are either verbs or too generic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addFunds`, `deleteUser`, or `save`. Accessors and mutators should be prefixed
    with `get` or `set`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch`, `retrieve`, and `get`, which do the same thing. It''s best to pick
    one word and use it consistently across your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eatMyShorts()` to mean `abort()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t add unneeded context**: If your class or object is already named descriptively,
    there is no need to repeat the name in the variables within. Take a look at the
    following examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is bad:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Whereas this is good:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following are the best practices for functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions should only do one thing and be small**: When functions are concise
    and limited in what they do, they are easier to understand, test, and work with.
    They would also read cleaner and be refactored easily. Coupled with a good function
    name, they are self-documenting as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a bad function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s a good function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Limit the number of function arguments**: Ideally, there should be no more
    than two or three arguments. This makes testing easier. If there are more arguments,
    consider that your function is probably trying to tackle too much and should be
    split into multiple functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function names should say what they do**: Here''s an example of a bad function
    name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a good function name:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`doSomething()` and instead turns into `doSomethingOrSomethingDifferentIfAFlagIsSet()`,
    it''s time to split the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rather than using the preceding code, use the following instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`playerX` and `playerY` variables represent the character''s current coordinates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is better to take x as a parameter and reassign the result to a global variable
    outside the function so that the function remains pure and maintains predictable
    return values (and makes it easier to test):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Side effects and pure functions are covered in more detail in *Chapter 14, Understanding
    Functional Programming*, on functional programming. Another important example
    is to clone objects, arrays, or lists when making modifications, rather than directly
    doing the modification itself on the input.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Create functions to capture conditional clauses**: Your code could become
    cluttered, unfocused, and hard to follow if you have complex conditions. Creating
    dedicated functions for your conditions and naming them descriptively makes the
    code self-documenting and easier to follow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of a bad function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An example of a good function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: JavaScript Linters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A linter is a tool that analyzes source code to help you debug your code, find
    potential issues and bugs and check coding styles (which is often subjective). Using
    a linter in your projects could help you and your team improve the quality of
    your code and provide consistent styling, which could help smooth out differences
    of code that different team members write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linters can typically be used in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Typing or pasting your code into the online version of a tool via a browser
    page. This is the simplest way, but it is not convenient for anything but small
    spot checks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a plugin for your IDE or text editor, either to show your errors and warnings
    as you type or separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running scans and generating reports as part of your automated build process
    every time your source code is built, or periodically. (If desired, you can even
    cause builds to fail if the scan results in errors of sufficient severity.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several linters available for JavaScript, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ESLint**: This is very configurable and customizable. This perhaps makes
    it the most complex and hardest linter to just pick up and start using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSLint**: This is somewhat configurable but highly opinionated on a popular
    but particular coding style, as described in the tool''s documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSHint**: This is somewhere between the other two in terms of customizability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 11.03: JSLint'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will describe `JSLint` in more detail since it is the easiest
    to set up and start using, uses a good coding style, and is a good fit for many
    projects. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a web browser such as Google Chrome and go to [www.jslint.com](http://www.jslint.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Options section on the lower part of the screen, select `Assume → a
    browser` (this sets the scan to define certain objects that are usually available
    in a browser, such as a `document` object):![Figure 11.18: Online version of JSLint'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_11_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 11.18: Online version of JSLint'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Paste in the code from `conventional.html` file into the *Source* window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press the *JSLint* button, which will result in an output that''s similar to
    what''s shown in the following screenshot:![Figure 11.19: Result of the scan'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_11_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 11.19: Result of the scan'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The scan results have multiple warnings of the following: `Use double quotes,
    not single quotes`. This is perhaps an example of a subjective preference as it
    is common in many languages for single characters to use single quotes, not double-quotes.
    Luckily, this is a configurable option if you select `Tolerate → single quote
    strings` in the Options section, as shown in the following screenshot. After clicking
    the *JSLint* button once again, this will result in all the warnings being removed:![Figure
    11.20: Tolerate → single quote strings option'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_11_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 11.20: Tolerate → single quote strings option'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An alternative way of specifying the option to allow single quote strings (and
    a number of other options) is by means of a special comment syntax that begins
    with `/*jslint`. Uncheck the `Tolerate → single quote strings` option and add
    the following to the top of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The warnings will continue to be empty upon clicking the JSLint button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This exercise explains how your JavaScript code compiles using the `Jslint`
    tool. It also helps to decrease the debugging time by providing a fixing issues
    report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.03: Refactoring to Clean Code'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making a habit of using clean coding best practices is an essential skill. We
    are now ready to put our newly acquired clean coding skills to test.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the JavaScript code in the `<script>` section of the following file
    and figure out how you can refactor it to be cleaner and easier to maintain and
    test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, this is a simple web page that calculates worker pay based on the
    number of hours, pay rate per hour, and worker type. There are three types of
    workers that have different rules regarding how their pay is determined: `Standard`,
    who gets overtime pay at `No Overtime`, who do not get any overtime, and `Double
    Overtime` workers, who are paid **2x** after **50** hours.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also format checks for the two number fields (implemented with regexes)
    and a facility to show validation error messages. The following screenshot shows
    the output with valid inputs (there is only minimal color and styling in this
    implementation):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21: Sample output with valid inputs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.21: Sample output with valid inputs'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output with a validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22: Sample output with a validation error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_11_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.22: Sample output with a validation error'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 748.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for the activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To refactor the code, create a function called `processForm()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function called `resetErrorsAndResults()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class to hold form field values and perform validations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a function called `getFormFields()`. This function is limited to
    getting the values from the form and creating an instance of the `FormFields`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `displayError()` and `displayResult()` functions to display errors
    and results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create the `calculateStandardWorkerPay()`, `calculateNoOvertimeWorkerPay()`,
    and `calculateDoubleOvertimeWorkerPay()` functions, which take the same two parameters
    and have the same return value definition so that they can be called abstractly
    in `doCalculation()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the best practices for clean and maintainable
    coding. As you saw in this chapter's activity, the refactored code that used clean
    coding techniques resulted in code that was much longer than before. However,
    you can see that the code as-is is much cleaner and is easier to understand and
    test compared to the original.
  prefs: []
  type: TYPE_NORMAL
- en: It is arguably overkill to refactor to the degree that we presented for our
    simple application, and many developers feel this way. But the value of this programming
    style really shows itself more in a complex real-world application, and it is
    good practice to do work in this way. Developers and tech leads need to decide
    what standards and clean coding practices make sense for their particular project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will explore the current trends and cutting-edge features
    that JavaScript has to offer.
  prefs: []
  type: TYPE_NORMAL
