- en: Chapter 2. A Robust Movie API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build a movie API that allows you to add actor and movie information
    to a database and connect actors with movies, and vice versa. This will make use
    of the information introduced in [Chapter 1](ch01.html "Chapter 1. Building a
    Basic Express Site"), *Building a Basic Express Site*, and give you a hands-on
    feel for what Express.js offers. We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Folder structure and organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object modeling with Mongoose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating unique IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folder structure and organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Folder structure is a very controversial topic. Though there are many clean
    ways to structure your project, we will use the following code for the remainder
    of our chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look this at in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`: It is conventional to have the main `app.js` file in the root directory.
    The `app.js` is the entry point of our application and will be used to launch
    the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json:` As with any Node.js app, we have `package.json` in the root
    folder specifying our application name and version as well as all of our npm dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules:` The `node_modules` folder and its content are generated via
    npm installation and should usually be ignored in your version control of choice
    because it depends on the platform the app runs on. Having said that, according
    to the npm FAQ, it is probably better to commit the `node_modules` folder as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Check `node_modules` into git for things you deploy, such as websites and apps.
    Do not check `node_modules` into git for libraries and modules intended to be
    reused.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Refer to the following article to read more about the rationale behind this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`http://www.futurealoof.com/posts/nodemodules-in-git.html`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`src`: The `src` folder contains all the logic of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib`: Within the `src` folder, we have the `lib` folder, which contains the
    core of the application. This includes the middleware, routes, and creating the
    database connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models`: The `models` folder contains our `mongoose` models, which defines
    the structure and logic of the models we want to manipulate and save.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`routes`: The `routes` folder contains the code for all the endpoints the API
    is able to serve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: The `test` folder will contain our functional tests using Mocha as
    well as two other node modules, `should` and `supertest`, to make it easier to
    aim for 100 percent coverage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term CRUD refers to the four basic operations one can perform on data:
    create, read, update, and delete. Express gives us an easy way to handle those
    operations by supporting the basic methods `GET`, `POST`, `PUT`, and `DELETE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This method is used to retrieve the existing data from the database.
    This can be used to read single or multiple rows (for SQL) or documents (for MongoDB)
    from the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This method is used to write new data into the database, and it is
    common to include a JSON payload that fits the data model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This method is used to update existing data in the database, and a JSON
    payload that fits the data model is often included for this method as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This method is used to remove an existing row or document from the
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express 4 has dramatically changed from version 3\. A lot of the core modules
    have been removed in order to make it even more lightweight and less dependent.
    Therefore, we have to explicitly `require` modules when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'One helpful module is `body-parser`. It allows us to get a nicely formatted
    body when a `POST` or `PUT` HTTP request is received. We have to add this middleware
    before our business logic in order to use its result later. We write the following
    in `src/lib/parser.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is then used in `src/lib/app.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example allows you to respond to a `GET` request on `http://host/path`.
    Once a request hits our API, Express will run it through the necessary middleware
    as well as the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the path we want to handle a `GET` function. The path
    can contain parameters prefixed with `:`. Those path parameters will then be parsed
    in the request object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter is the callback that will be executed when the server
    receives the request. This function gets populated with three parameters: `req`,
    `res`, and `next`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `req` parameter represents the HTTP request object that has been customized
    by Express and the middlewares we added in our applications. Using the path `http://host/``path/:id`,
    suppose a `GET` request is sent to `http://hos``t/path/1?a=1&b=2`. The `req` object
    would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `params` object is a representation of the path parameters. The `query`
    is the query string, which are the values stated after `?` in the URL. In a `POST`
    request, there will often be a body in our request object as well, which includes
    the data we wish to place in our database.
  prefs: []
  type: TYPE_NORMAL
- en: The `res` parameter represents the response object for that request. Some methods,
    such as `status()` or `json()`, are provided in order to tell Express how to respond
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `next()` function will execute the next middleware defined in our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving an actor with GET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Retrieving a movie or actor from the database consists of submitting a `GET`
    request to the route: `/movies/:id or /actors/:id`. We will need a unique ID that
    refers to a unique movie or actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the URL parameter `:id` will be placed in our request object. Since we
    call the first variable in our callback function `req` as before, we can access
    the URL parameter by calling `req.params.id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since an actor may be in many movies and a movie may have many actors, we need
    a nested endpoint to reflect this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If a bad `GET` request is submitted or no actor with the specified ID is found,
    then the appropriate status code bad request `400` or not found `404` will be
    returned. If the actor is found, then success request `200` will be sent back
    along with the actor information. On a success, the response JSON will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new actor with POST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our API, creating a new movie in the database involves submitting a `POST`
    request to `/movies` or `/actors` for a new actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the user accessing our API sends a `POST` request with data
    that would be placed into `request.body`. Here, we call the first variable in
    our callback function `req`. Thus, to access the body of the request, we call
    `req.body`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request body is sent as a JSON string; if an error occurs, a `400` (bad
    request) status would be sent back. Otherwise, a `201` (created) status is sent
    to the response object. On a success request, the response will look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Updating an actor with PUT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update a movie or actor entry, we first create a new route and submit a
    `PUT` request to `/movies/:id` or `/actors /:id`, where the `id` parameter is
    unique to an existing `movie/actor`. There are two steps to an update. We first
    find the movie or actor by using the unique id and then we update that entry with
    the body of the request object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the request, we would need `request.body` to be a JSON object that reflects
    the actor fields to be updated. The `request.params.id` would still be a unique
    identifier that refers to an existing actor in the database as before. On a successful
    update, the response JSON looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the response will reflect the changes we made to the data.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an actor with DELETE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting a movie is as simple as submitting a `DELETE` request to the same
    routes that were used earlier (specifying the ID). The actor with the appropriate
    id is found and then deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the actor with the unique id is found, it is then deleted and a response
    code of `204` is returned. If the actor cannot be found, a response code of `400`
    is returned. There is no response body for a `DELETE()` method; it will simply
    return the status code of `204` on a successful deletion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final endpoints for this simple app will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Express 4, there is an alternative way to describe your routes. Routes that
    share a common URL, but use a different HTTP verb, can be grouped together as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Whether you prefer it this way or not is up to you. At least now you have a
    choice!
  prefs: []
  type: TYPE_NORMAL
- en: We have not discussed the logic of the function being run for each endpoint.
    We will get to that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Express allows us to easily CRUD our database objects, but how do we model our
    objects?
  prefs: []
  type: TYPE_NORMAL
- en: Object modeling with Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mongoose is an object data modeling library (ODM) that allows you to define
    schemas for your data collections. You can find out more about Mongoose on the
    project website: [http://mongoosejs.com/](http://mongoosejs.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: To connect to a MongoDB instance using the `mongoose` variable, we first need
    to install npm and save Mongoose. The `save` flag automatically adds the module
    to your `package.json` with the latest version, thus, it is always recommended
    to install your modules with the save flag. For modules that you only need locally
    (for example, Mocha), you can use the `savedev` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, we create a new file `db.js` under `/src/lib/db.js`, which
    requires Mongoose. The local connection to the `mongodb` database is made in `mongoose.connect`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In our movies database, we need separate schemas for actors and movies. As
    an example, we will go through object modeling in our actor database `/src/models/actor.js`
    by creating an actor schema as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each actor has a unique id, a name, and a birth year. The entries also contain
    validators such as the type and boolean value that are required. The model is
    exported upon definition (`module.exports`), so that we can reuse it directly
    in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could fetch each model through Mongoose using `mongoose.model('Actor',
    actorSchema)`, but this would feel less explicitly coupled compared to our approach
    of directly requiring it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we need a movie schema as well. We define the movie schema as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Generating unique IDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In both our movie and actor schemas, we used a plugin called `generateId()`.
  prefs: []
  type: TYPE_NORMAL
- en: While MongoDB automatically generates `ObjectID` for each document using the
    `_id` field, we want to generate our own IDs that are more human readable and
    hence friendlier. We also would like to give the user the opportunity to select
    their own id of choice.
  prefs: []
  type: TYPE_NORMAL
- en: However, being able to choose an id can cause conflicts. If you were to choose
    an id that already exists, your `POST` request would be rejected. We should autogenerate
    an ID if the user does not pass one explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Without this plugin, if either an actor or a movie is created without an explicit
    ID passed along by the user, the server would complain since the ID is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create middleware for Mongoose that assigns an `id` before we persist
    the object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are a few important notes about this code.
  prefs: []
  type: TYPE_NORMAL
- en: See what we did to get the `var` model? This makes the plugin generic so that
    it can be applied to multiple Mongoose schemas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that there are two callbacks available: `next` and `done`. The `next`
    variable passes the code to the next pre-validation middleware. That''s something
    you would usually put at the bottom of the function right after you make your
    asynchronous call. This is generally a good thing since one of the advantages
    of asynchronous calls is that you can have many things running at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: However, in this case, we cannot call the `next` variable because it would conflict
    with our model definition of id required. Thus, we just stick to using the `done`
    variable when the logic is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Another concern arises due to the fact that MongoDB doesn't support transactions,
    which means you may have to account for this function failing in some edge cases.
    For example, if two calls to `POST` `/actor` happen at the same time, they will
    both have their IDs auto incremented to the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the code for our `generateId()` plugin, we require it in our
    actor and movie schema as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Validating your database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each key in the Mongoose schema defines a property that is associated with a
    SchemaType. For example, in our `actors.js` schema, the actor's name key is associated
    with a string SchemaType. String, number, date, buffer, boolean, mixed, objectId,
    and array are all valid schema types.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to schema types, numbers have min and max validators and strings
    have enum and match validators. Validation occurs when a document is being saved
    `(.save())` and will return an error object, containing type, path, and value
    properties, if the validation has failed.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting functions to reusable middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use our anonymous or named functions as middleware. To do so, we would
    export our functions by calling `module.exports` in `routes/actors.js` and `routes/movies.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our `routes/actors.js` file. At the top of this file,
    we require the Mongoose schemas we defined before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This allows our variable `actor` to access our MongoDB using mongo functions
    such as `find()`, `create()`, and `update()`. It will follow the schema defined
    in the file `/models/actor`.
  prefs: []
  type: TYPE_NORMAL
- en: Since actors are in movies, we will also need to require the `Movie` schema
    to show this relationship by the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our schema, we can begin defining the logic for the functions
    we described in endpoints. For example, the endpoint `GET` `/actors/:id` will
    retrieve the actor with the corresponding ID from our database. Let''s call this
    function `getOne()`. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the mongo `findOne()` method to retrieve the actor with `id:` `req.params.id`.
    There are no joins in MongoDB so we use the `.populate()` method to retrieve the
    movies the actor is in.
  prefs: []
  type: TYPE_NORMAL
- en: The `.populate()` method will retrieve documents from a separate collection
    based on its `ObjectId`.
  prefs: []
  type: TYPE_NORMAL
- en: This function will return a status `400` if something went wrong with our Mongoose
    driver, a status `404` if the actor with `:id` is not found, and finally, it will
    return a status `200` along with the JSON of the actor object if an actor is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define all the functions required for the actor endpoints in this file.
    The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For all of our movie endpoints, we need the same functions but applied to the
    movie collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'After exporting these two files, we require them in `app.js` (`/src/lib/app.js`)
    by simply adding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By exporting our functions as reusable middleware, we keep our code clean and
    can refer to functions in our CRUD calls in the `/routes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocha is used as the test framework along with `should.js` and supertest. The
    principles behind why we use testing in our apps along with some basics on Mocha
    are covered in [Chapter 1](ch01.html "Chapter 1. Building a Basic Express Site"),
    *Building a Basic Express Site*. Testing supertest lets you test your HTTP assertions
    and testing API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The tests are placed in the root folder `/test`. Tests are completely separate
    from any of the source code and are written to be readable in plain English, that
    is, you should be able to follow along with what is being tested just by reading
    through them. Well-written tests with good coverage can serve as a readme for
    its API, since it clearly describes the behavior of the entire app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial setup to test our movies API is the same for both `/test/actors.js`
    and `/test/movies.js` and will look familiar if you have read [Chapter 1](ch01.html
    "Chapter 1. Building a Basic Express Site"), *Building a Basic Express Site*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In `src/test/actors.js`, we test the basic CRUD operations: creating a new
    actor object, retrieving, editing, and deleting the actor object. An example test
    for the creation of a new actor is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the tests are readable in plain English. We create a new `POST`
    request for a new actor to the database with the `id` of `1`, `name` of `AxiomZen`,
    and `birth_year` of `2012`. Then, we send the request with the .`send()` function.
    Similar tests are present for `GET` and `DELETE` requests as given in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To test our `PUT` request, we will edit the `name` and `birth_year` of our
    first actor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the test modifies the actor `name` and `birth_year` keys,
    sends a `PUT` request for `/actors/1` (`1` is the actors `id`), and then saves
    the new information to the database. The second part of the test checks whether
    the database entry for the actor with `id` `1` has been changed. The `name` and
    `birth_year` values are checked against their expected values using `.should.eql()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to performing CRUD actions on the actor object, we can also perform
    these actions to the movies we add to each actor (associated by the actor''s ID).
    The following snippet shows a test to add a new movie to our first actor (with
    the `id` of `1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the test creates a new movie object with `id`, `title`, and
    `year` keys, and sends a `POST` request to add the movies as an array to the actor
    with `id` of `1`. The second part of the test sends a `GET` request to retrieve
    the actor with `id` of `1`, which should now include an array with the new movie
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can similarly delete the movie entries as illustrated in the `actors.js`
    test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Again, this code snippet should look familiar to you. The first part tests that
    sending a `DELETE` request specifying the actor ID and movie ID will delete that
    movie entry. In the second part, we make sure that the entry no longer exists
    by submitting a `GET` request to view the actor's details where no movies should
    be listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to ensuring that the basic CRUD operations work, we also test our
    schema validations. The following code tests to make sure two actors with the
    same ID do not exist (IDs are specified as unique):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We should expect code `400` (bad request) if we try to create an actor who already
    exists in the database.
  prefs: []
  type: TYPE_NORMAL
- en: A similar set of tests is present for `tests/movies.js`. The function and outcome
    of each test should be evident now.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a basic API that connects to MongoDB and supports
    CRUD methods. You should now be able to set up an API complete with tests, for
    any data, not just movies and actors!
  prefs: []
  type: TYPE_NORMAL
- en: The astute reader will have noticed that we have not addressed some issues in
    the current chapter such as dealing with race conditions in MongoDB. These will
    be clarified in detail in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We hope you found that this chapter has laid a good foundation for the Express
    and API setup.
  prefs: []
  type: TYPE_NORMAL
