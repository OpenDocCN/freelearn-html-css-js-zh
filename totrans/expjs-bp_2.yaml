- en: Chapter 2. A Robust Movie API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章.一个健壮的电影API
- en: 'We will build a movie API that allows you to add actor and movie information
    to a database and connect actors with movies, and vice versa. This will make use
    of the information introduced in [Chapter 1](ch01.html "Chapter 1. Building a
    Basic Express Site"), *Building a Basic Express Site*, and give you a hands-on
    feel for what Express.js offers. We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个电影API，允许您将演员和电影信息添加到数据库中，并将演员与电影连接起来，反之亦然。这将利用在[第一章](ch01.html "第一章.构建基本的Express网站")中介绍的信息，*构建基本的Express网站*，并让您亲身体验Express.js能提供什么。在本章中，我们将涵盖以下主题：
- en: Folder structure and organization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹结构和组织
- en: Responding to CRUD operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应CRUD操作
- en: Object modeling with Mongoose
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mongoose进行对象建模
- en: Generating unique IDs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成唯一ID
- en: Testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Folder structure and organization
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹结构和组织
- en: 'Folder structure is a very controversial topic. Though there are many clean
    ways to structure your project, we will use the following code for the remainder
    of our chapters:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构是一个非常有争议的话题。尽管有许多干净的方式来组织你的项目，但我们将使用以下代码作为我们后续章节的示例：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s take a look this at in detail:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看：
- en: '`app.js`: It is conventional to have the main `app.js` file in the root directory.
    The `app.js` is the entry point of our application and will be used to launch
    the server.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.js`：在根目录中通常有一个主要的`app.js`文件。`app.js`是应用程序的入口点，将用于启动服务器。'
- en: '`package.json:` As with any Node.js app, we have `package.json` in the root
    folder specifying our application name and version as well as all of our npm dependencies.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`：与任何Node.js应用程序一样，我们在根目录中都有`package.json`，指定我们的应用程序名称和版本以及所有npm依赖项。'
- en: '`node_modules:` The `node_modules` folder and its content are generated via
    npm installation and should usually be ignored in your version control of choice
    because it depends on the platform the app runs on. Having said that, according
    to the npm FAQ, it is probably better to commit the `node_modules` folder as well.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules`：`node_modules`文件夹及其内容是通过npm安装生成的，通常应该在你的版本控制中忽略，因为它依赖于应用程序运行的平台。话虽如此，根据npm
    FAQ，将`node_modules`文件夹提交可能更好。'
- en: Note
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Check `node_modules` into git for things you deploy, such as websites and apps.
    Do not check `node_modules` into git for libraries and modules intended to be
    reused.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将部署的项目，如网站和应用程序，的`node_modules`检查到git中。不要将用于重用的库和模块的`node_modules`检查到git中。
- en: 'Refer to the following article to read more about the rationale behind this:'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考以下文章了解更多关于这一做法的原理：
- en: '`http://www.futurealoof.com/posts/nodemodules-in-git.html`'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.futurealoof.com/posts/nodemodules-in-git.html](http://www.futurealoof.com/posts/nodemodules-in-git.html)'
- en: '`src`: The `src` folder contains all the logic of the application.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：`src`文件夹包含应用程序的所有逻辑。'
- en: '`lib`: Within the `src` folder, we have the `lib` folder, which contains the
    core of the application. This includes the middleware, routes, and creating the
    database connection.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：在`src`文件夹中，我们有`lib`文件夹，它包含应用程序的核心。这包括中间件、路由以及创建数据库连接。'
- en: '`models`: The `models` folder contains our `mongoose` models, which defines
    the structure and logic of the models we want to manipulate and save.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`：`models`文件夹包含我们的`mongoose`模型，它定义了我们想要操作和保存的模型的结构和逻辑。'
- en: '`routes`: The `routes` folder contains the code for all the endpoints the API
    is able to serve.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`：`routes`文件夹包含API能够服务的所有端点的代码。'
- en: '`test`: The `test` folder will contain our functional tests using Mocha as
    well as two other node modules, `should` and `supertest`, to make it easier to
    aim for 100 percent coverage.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：`test`文件夹将包含我们使用Mocha以及两个其他node模块`should`和`supertest`的功能测试，以使达到100%覆盖率变得更容易。'
- en: Responding to CRUD operations
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应CRUD操作
- en: 'The term CRUD refers to the four basic operations one can perform on data:
    create, read, update, and delete. Express gives us an easy way to handle those
    operations by supporting the basic methods `GET`, `POST`, `PUT`, and `DELETE`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD术语指的是可以在数据上执行的四项基本操作：创建、读取、更新和删除。Express通过支持基本方法`GET`、`POST`、`PUT`和`DELETE`，为我们处理这些操作提供了一个简单的方法：
- en: '`GET`: This method is used to retrieve the existing data from the database.
    This can be used to read single or multiple rows (for SQL) or documents (for MongoDB)
    from the database.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：此方法用于从数据库中检索现有数据。这可以用来从数据库中读取单行或多行（对于SQL）或文档（对于MongoDB）。'
- en: '`POST`: This method is used to write new data into the database, and it is
    common to include a JSON payload that fits the data model.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：此方法用于将新数据写入数据库，并且通常也会包含一个符合数据模型的 JSON 有效负载。'
- en: '`PUT`: This method is used to update existing data in the database, and a JSON
    payload that fits the data model is often included for this method as well.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：此方法用于在数据库中更新现有数据，并且通常也会包含一个符合数据模型的 JSON 有效负载。'
- en: '`DELETE`: This method is used to remove an existing row or document from the
    database.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：此方法用于从数据库中删除现有行或文档。'
- en: Express 4 has dramatically changed from version 3\. A lot of the core modules
    have been removed in order to make it even more lightweight and less dependent.
    Therefore, we have to explicitly `require` modules when needed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Express 4 与版本 3 相比发生了巨大变化。为了使其更加轻量级和减少依赖，许多核心模块已被移除。因此，我们需要在需要时显式地 `require`
    模块。
- en: 'One helpful module is `body-parser`. It allows us to get a nicely formatted
    body when a `POST` or `PUT` HTTP request is received. We have to add this middleware
    before our business logic in order to use its result later. We write the following
    in `src/lib/parser.js`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的模块是 `body-parser`。它允许我们在接收到 `POST` 或 `PUT` HTTP 请求时获取一个格式良好的体。我们必须在业务逻辑之前添加此中间件，以便稍后使用其结果。我们在
    `src/lib/parser.js` 中写入以下内容：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code is then used in `src/lib/app.js` as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码随后被用于 `src/lib/app.js` 中，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following example allows you to respond to a `GET` request on `http://host/path`.
    Once a request hits our API, Express will run it through the necessary middleware
    as well as the following function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例允许您对 `http://host/path` 上的 `GET` 请求做出响应。一旦请求击中我们的 API，Express 将运行它通过必要的中间件以及以下函数：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first parameter is the path we want to handle a `GET` function. The path
    can contain parameters prefixed with `:`. Those path parameters will then be parsed
    in the request object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们想要处理的 `GET` 函数的路径。路径可以包含以 `:` 为前缀的参数。这些路径参数随后将在请求对象中解析。
- en: 'The second parameter is the callback that will be executed when the server
    receives the request. This function gets populated with three parameters: `req`,
    `res`, and `next`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是当服务器收到请求时将执行的回调。此函数包含三个参数：`req`、`res` 和 `next`。
- en: 'The `req` parameter represents the HTTP request object that has been customized
    by Express and the middlewares we added in our applications. Using the path `http://host/``path/:id`,
    suppose a `GET` request is sent to `http://hos``t/path/1?a=1&b=2`. The `req` object
    would be the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`req` 参数代表由 Express 和我们在应用程序中添加的中间件定制的 HTTP 请求对象。使用路径 `http://host/path/:id`，假设向
    `http://host/path/1?a=1&b=2` 发送了一个 `GET` 请求。`req` 对象将是以下内容：'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `params` object is a representation of the path parameters. The `query`
    is the query string, which are the values stated after `?` in the URL. In a `POST`
    request, there will often be a body in our request object as well, which includes
    the data we wish to place in our database.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`params` 对象是路径参数的表示。`query` 是查询字符串，它是 URL 中 `?` 后的值。在 `POST` 请求中，我们的请求对象中通常还会有一个体，其中包含我们希望放入数据库中的数据。'
- en: The `res` parameter represents the response object for that request. Some methods,
    such as `status()` or `json()`, are provided in order to tell Express how to respond
    to the client.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`res` 参数代表该请求的响应对象。一些方法，如 `status()` 或 `json()`，被提供以便告诉 Express 如何响应用户。'
- en: Finally, the `next()` function will execute the next middleware defined in our
    application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`next()` 函数将执行我们应用程序中定义的下一个中间件。
- en: Retrieving an actor with GET
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GET 检索演员
- en: 'Retrieving a movie or actor from the database consists of submitting a `GET`
    request to the route: `/movies/:id or /actors/:id`. We will need a unique ID that
    refers to a unique movie or actor:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中检索电影或演员包括向路由 `/movies/:id` 或 `/actors/:id` 提交一个 `GET` 请求。我们需要一个唯一的 ID 来引用一个唯一的电影或演员：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the URL parameter `:id` will be placed in our request object. Since we
    call the first variable in our callback function `req` as before, we can access
    the URL parameter by calling `req.params.id`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，URL 参数 `:id` 将被放置在我们的请求对象中。由于我们在回调函数中之前将第一个变量命名为 `req`，因此我们可以通过调用 `req.params.id`
    来访问 URL 参数。
- en: 'Since an actor may be in many movies and a movie may have many actors, we need
    a nested endpoint to reflect this as well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个演员可能参演多部电影，而一部电影可能有多个演员，因此我们需要一个嵌套端点来反映这一点：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a bad `GET` request is submitted or no actor with the specified ID is found,
    then the appropriate status code bad request `400` or not found `404` will be
    returned. If the actor is found, then success request `200` will be sent back
    along with the actor information. On a success, the response JSON will look like
    this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提交了一个坏的`GET`请求或者没有找到指定ID的演员，那么将返回适当的错误状态码`400`（错误请求）或`404`（未找到）。如果找到了演员，则将发送成功请求`200`，并附带演员信息。成功时，响应的JSON将如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating a new actor with POST
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用POST创建新的演员
- en: 'In our API, creating a new movie in the database involves submitting a `POST`
    request to `/movies` or `/actors` for a new actor:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的API中，在数据库中创建一个新的电影涉及向`/movies`或为新的演员向`/actors`提交一个`POST`请求：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the user accessing our API sends a `POST` request with data
    that would be placed into `request.body`. Here, we call the first variable in
    our callback function `req`. Thus, to access the body of the request, we call
    `req.body`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，访问我们的API的用户发送一个包含将被放置到`request.body`中的数据的`POST`请求。在这里，我们将回调函数中的第一个变量称为`req`。因此，要访问请求体，我们调用`req.body`。
- en: 'The request body is sent as a JSON string; if an error occurs, a `400` (bad
    request) status would be sent back. Otherwise, a `201` (created) status is sent
    to the response object. On a success request, the response will look like the
    following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体以JSON字符串的形式发送；如果发生错误，将返回`400`（错误请求）状态。否则，将向响应对象发送`201`（已创建）状态。在成功请求的情况下，响应将如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Updating an actor with PUT
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PUT更新演员
- en: 'To update a movie or actor entry, we first create a new route and submit a
    `PUT` request to `/movies/:id` or `/actors /:id`, where the `id` parameter is
    unique to an existing `movie/actor`. There are two steps to an update. We first
    find the movie or actor by using the unique id and then we update that entry with
    the body of the request object, as shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新电影或演员条目，我们首先创建一个新的路由，并向`/movies/:id`或`/actors/:id`提交一个`PUT`请求，其中`id`参数是现有`movie/actor`的唯一标识。更新有两个步骤。我们首先使用唯一的ID找到电影或演员，然后使用请求对象的主体更新该条目，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the request, we would need `request.body` to be a JSON object that reflects
    the actor fields to be updated. The `request.params.id` would still be a unique
    identifier that refers to an existing actor in the database as before. On a successful
    update, the response JSON looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求中，我们需要`request.body`是一个JSON对象，它反映了要更新的演员字段。`request.params.id`仍然是一个唯一的标识符，它引用数据库中现有的演员，就像之前一样。在成功更新后，响应的JSON看起来如下所示：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the response will reflect the changes we made to the data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，响应将反映我们对数据所做的更改。
- en: Removing an actor with DELETE
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DELETE删除演员
- en: 'Deleting a movie is as simple as submitting a `DELETE` request to the same
    routes that were used earlier (specifying the ID). The actor with the appropriate
    id is found and then deleted:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 删除电影就像提交一个`DELETE`请求到之前使用的相同路由（指定ID）一样简单。找到具有适当ID的演员，然后将其删除：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the actor with the unique id is found, it is then deleted and a response
    code of `204` is returned. If the actor cannot be found, a response code of `400`
    is returned. There is no response body for a `DELETE()` method; it will simply
    return the status code of `204` on a successful deletion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到具有唯一ID的演员，则将其删除，并返回响应代码`204`。如果演员找不到，则返回响应代码`400`。对于`DELETE()`方法没有响应体；它将简单地返回成功删除的状态代码`204`。
- en: 'Our final endpoints for this simple app will be as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个简单应用的最终端点将如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Express 4, there is an alternative way to describe your routes. Routes that
    share a common URL, but use a different HTTP verb, can be grouped together as
    follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express 4中，有一种描述路由的替代方法。具有相同URL但使用不同HTTP动词的路由可以如下分组：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Whether you prefer it this way or not is up to you. At least now you have a
    choice!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否喜欢这种方式，这取决于你。至少现在你有选择！
- en: We have not discussed the logic of the function being run for each endpoint.
    We will get to that shortly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论每个端点运行函数的逻辑。我们很快就会讨论这个问题。
- en: Express allows us to easily CRUD our database objects, but how do we model our
    objects?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Express允许我们轻松地CRUD我们的数据库对象，但我们如何对对象进行建模呢？
- en: Object modeling with Mongoose
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mongoose进行对象建模
- en: 'Mongoose is an object data modeling library (ODM) that allows you to define
    schemas for your data collections. You can find out more about Mongoose on the
    project website: [http://mongoosejs.com/](http://mongoosejs.com/).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose是一个对象数据建模库（ODM），允许你为你的数据集合定义模式。你可以在项目网站上了解更多关于Mongoose的信息：[http://mongoosejs.com/](http://mongoosejs.com/)。
- en: To connect to a MongoDB instance using the `mongoose` variable, we first need
    to install npm and save Mongoose. The `save` flag automatically adds the module
    to your `package.json` with the latest version, thus, it is always recommended
    to install your modules with the save flag. For modules that you only need locally
    (for example, Mocha), you can use the `savedev` flag.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`mongoose`变量连接到MongoDB实例，我们首先需要安装npm并保存Mongoose。`save`标志会自动将模块添加到你的`package.json`中，并使用最新版本，因此，始终建议使用`save`标志安装你的模块。对于你只需要本地使用的模块（例如，Mocha），你可以使用`savedev`标志。
- en: 'For this project, we create a new file `db.js` under `/src/lib/db.js`, which
    requires Mongoose. The local connection to the `mongodb` database is made in `mongoose.connect`
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们在`/src/lib/db.js`下创建了一个新的文件`db.js`，它需要Mongoose。在`mongoose.connect`中建立到`mongodb`数据库的本地连接，如下所示：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our movies database, we need separate schemas for actors and movies. As
    an example, we will go through object modeling in our actor database `/src/models/actor.js`
    by creating an actor schema as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电影数据库中，我们需要为演员和电影分别创建模式。作为一个例子，我们将通过在演员数据库`/src/models/actor.js`中创建演员模式来遍历对象建模，如下所示：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each actor has a unique id, a name, and a birth year. The entries also contain
    validators such as the type and boolean value that are required. The model is
    exported upon definition (`module.exports`), so that we can reuse it directly
    in the app.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个演员都有一个唯一的id、一个名字和一个出生年份。条目还包含所需的有效验证器，如类型和布尔值。模型在定义后导出（`module.exports`），这样我们就可以直接在应用中重用它。
- en: Alternatively, you could fetch each model through Mongoose using `mongoose.model('Actor',
    actorSchema)`, but this would feel less explicitly coupled compared to our approach
    of directly requiring it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过Mongoose使用`mongoose.model('Actor', actorSchema)`来获取每个模型，但这与我们的直接要求它的方法相比，感觉不那么明确耦合。
- en: 'Similarly, we need a movie schema as well. We define the movie schema as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们还需要一个电影模式。我们定义电影模式如下：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Generating unique IDs
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成唯一ID
- en: In both our movie and actor schemas, we used a plugin called `generateId()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电影和演员模式中，我们使用了一个名为`generateId()`的插件。
- en: While MongoDB automatically generates `ObjectID` for each document using the
    `_id` field, we want to generate our own IDs that are more human readable and
    hence friendlier. We also would like to give the user the opportunity to select
    their own id of choice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MongoDB自动使用`_id`字段为每个文档生成`ObjectID`，但我们想生成更易于阅读的ID，因此更友好。我们还希望给用户选择他们自己的id的机会。
- en: However, being able to choose an id can cause conflicts. If you were to choose
    an id that already exists, your `POST` request would be rejected. We should autogenerate
    an ID if the user does not pass one explicitly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，能够选择一个id可能会导致冲突。如果你选择了一个已经存在的id，你的`POST`请求将被拒绝。如果用户没有明确传递id，我们应该自动生成一个ID。
- en: Without this plugin, if either an actor or a movie is created without an explicit
    ID passed along by the user, the server would complain since the ID is required.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个插件，如果用户没有明确传递ID，无论是创建演员还是电影，服务器都会抱怨，因为ID是必需的。
- en: 'We can create middleware for Mongoose that assigns an `id` before we persist
    the object as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为Mongoose创建中间件，在持久化对象之前分配一个`id`，如下所示：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are a few important notes about this code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此代码有几个重要的注意事项。
- en: See what we did to get the `var` model? This makes the plugin generic so that
    it can be applied to multiple Mongoose schemas.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们是如何得到`var`模型的？这使得插件通用，因此它可以应用于多个Mongoose模式。
- en: 'Notice that there are two callbacks available: `next` and `done`. The `next`
    variable passes the code to the next pre-validation middleware. That''s something
    you would usually put at the bottom of the function right after you make your
    asynchronous call. This is generally a good thing since one of the advantages
    of asynchronous calls is that you can have many things running at the same time.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两个回调可用：`next`和`done`。`next`变量将代码传递给下一个预验证中间件。这通常是好事，因为异步调用的一项优点是你可以同时运行许多事情。
- en: However, in this case, we cannot call the `next` variable because it would conflict
    with our model definition of id required. Thus, we just stick to using the `done`
    variable when the logic is complete.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，我们不能调用`next`变量，因为它会与我们的id模式定义冲突。因此，当逻辑完成时，我们只使用`done`变量。
- en: Another concern arises due to the fact that MongoDB doesn't support transactions,
    which means you may have to account for this function failing in some edge cases.
    For example, if two calls to `POST` `/actor` happen at the same time, they will
    both have their IDs auto incremented to the same value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MongoDB 不支持事务，因此可能会出现一些边缘情况导致此函数失败。例如，如果同时发生两个对 `POST` `/actor` 的调用，它们都将自动递增到相同的
    ID 值。
- en: 'Now that we have the code for our `generateId()` plugin, we require it in our
    actor and movie schema as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `generateId()` 插件的代码，我们按照以下方式在我们的演员和电影模式中引入它：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Validating your database
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证您的数据库
- en: Each key in the Mongoose schema defines a property that is associated with a
    SchemaType. For example, in our `actors.js` schema, the actor's name key is associated
    with a string SchemaType. String, number, date, buffer, boolean, mixed, objectId,
    and array are all valid schema types.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 模式中每个键都定义了一个与 SchemaType 关联的属性。例如，在我们的 `actors.js` 模式中，演员的姓名键与字符串 SchemaType
    关联。字符串、数字、日期、缓冲区、布尔值、混合、objectId 和数组都是有效的模式类型。
- en: In addition to schema types, numbers have min and max validators and strings
    have enum and match validators. Validation occurs when a document is being saved
    `(.save())` and will return an error object, containing type, path, and value
    properties, if the validation has failed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模式类型之外，数字有最小和最大验证器，字符串有枚举和匹配验证器。验证发生在文档正在保存 `(.save())` 时，如果验证失败，将返回一个包含类型、路径和值属性的错误对象。
- en: Extracting functions to reusable middleware
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数提取为可重用的中间件
- en: 'We can use our anonymous or named functions as middleware. To do so, we would
    export our functions by calling `module.exports` in `routes/actors.js` and `routes/movies.js`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的匿名或命名函数作为中间件。为此，我们通过在 `routes/actors.js` 和 `routes/movies.js` 中调用 `module.exports`
    来导出我们的函数：
- en: 'Let''s take a look at our `routes/actors.js` file. At the top of this file,
    we require the Mongoose schemas we defined before:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的 `routes/actors.js` 文件。在这个文件的顶部，我们引入了我们之前定义的 Mongoose 模式：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This allows our variable `actor` to access our MongoDB using mongo functions
    such as `find()`, `create()`, and `update()`. It will follow the schema defined
    in the file `/models/actor`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们的变量 `actor` 使用 mongo 函数（如 `find()`、`create()` 和 `update()`）访问我们的 MongoDB。它将遵循
    `/models/actor` 文件中定义的模式。
- en: Since actors are in movies, we will also need to require the `Movie` schema
    to show this relationship by the following.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于演员在电影中，我们还需要通过以下方式引入 `Movie` 模式来显示这种关系。
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have our schema, we can begin defining the logic for the functions
    we described in endpoints. For example, the endpoint `GET` `/actors/:id` will
    retrieve the actor with the corresponding ID from our database. Let''s call this
    function `getOne()`. It is defined as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的模式，我们可以开始定义我们在端点中描述的函数的逻辑。例如，端点 `GET` `/actors/:id` 将从我们的数据库中检索具有相应
    ID 的演员。让我们称这个函数为 `getOne()`。它定义如下：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we use the mongo `findOne()` method to retrieve the actor with `id:` `req.params.id`.
    There are no joins in MongoDB so we use the `.populate()` method to retrieve the
    movies the actor is in.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 mongo 的 `findOne()` 方法来检索具有 `id:` `req.params.id` 的演员。MongoDB 中没有连接，所以我们使用
    `.populate()` 方法来检索演员参演的电影。
- en: The `.populate()` method will retrieve documents from a separate collection
    based on its `ObjectId`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`.populate()` 方法将根据其 `ObjectId` 从单独的集合中检索文档。'
- en: This function will return a status `400` if something went wrong with our Mongoose
    driver, a status `404` if the actor with `:id` is not found, and finally, it will
    return a status `200` along with the JSON of the actor object if an actor is found.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 Mongoose 驱动程序出现错误，此函数将返回状态 `400`，如果找不到具有 `:id` 的演员，则返回状态 `404`，最后，如果找到演员，它将返回状态
    `200` 并附带演员对象的 JSON。
- en: 'We define all the functions required for the actor endpoints in this file.
    The result is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个文件中定义了所有用于演员端点的函数。结果如下：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For all of our movie endpoints, we need the same functions but applied to the
    movie collection.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们所有的电影端点，我们需要相同的函数，但应用于电影集合。
- en: 'After exporting these two files, we require them in `app.js` (`/src/lib/app.js`)
    by simply adding:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 导出这两个文件后，我们在 `app.js` (`/src/lib/app.js`) 中通过简单地添加以下内容来引入它们：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By exporting our functions as reusable middleware, we keep our code clean and
    can refer to functions in our CRUD calls in the `/routes` folder.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的函数作为可重用的中间件导出，我们保持我们的代码整洁，并且可以在 `/routes` 文件夹中的 CRUD 调用中引用函数。
- en: Testing
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Mocha is used as the test framework along with `should.js` and supertest. The
    principles behind why we use testing in our apps along with some basics on Mocha
    are covered in [Chapter 1](ch01.html "Chapter 1. Building a Basic Express Site"),
    *Building a Basic Express Site*. Testing supertest lets you test your HTTP assertions
    and testing API endpoints.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 被用作测试框架，同时使用 `should.js` 和 supertest。为什么我们在应用程序中使用测试以及 Mocha 的基础知识在 [第
    1 章](ch01.html "第 1 章。构建基本的 Express 网站") *Building a Basic Express Site* 中进行了介绍。使用
    supertest 进行测试可以让你测试你的 HTTP 断言和 API 端点。
- en: The tests are placed in the root folder `/test`. Tests are completely separate
    from any of the source code and are written to be readable in plain English, that
    is, you should be able to follow along with what is being tested just by reading
    through them. Well-written tests with good coverage can serve as a readme for
    its API, since it clearly describes the behavior of the entire app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试被放置在根目录 `/test` 中。测试与任何源代码完全分离，并编写为纯英文可读，也就是说，你应该能够通过阅读它们来了解正在测试的内容。编写良好的测试用例，具有良好的覆盖率，可以作为其
    API 的说明文档，因为它清楚地描述了整个应用程序的行为。
- en: 'The initial setup to test our movies API is the same for both `/test/actors.js`
    and `/test/movies.js` and will look familiar if you have read [Chapter 1](ch01.html
    "Chapter 1. Building a Basic Express Site"), *Building a Basic Express Site*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的电影 API 的初始设置对 `/test/actors.js` 和 `/test/movies.js` 都是相同的，如果你已经阅读了 [第 1
    章](ch01.html "第 1 章。构建基本的 Express 网站") *Building a Basic Express Site*，那么这应该看起来很熟悉。
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In `src/test/actors.js`, we test the basic CRUD operations: creating a new
    actor object, retrieving, editing, and deleting the actor object. An example test
    for the creation of a new actor is shown as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/test/actors.js` 中，我们测试基本的 CRUD 操作：创建新的演员对象、检索、编辑和删除演员对象。以下是一个创建新演员的示例测试：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can see that the tests are readable in plain English. We create a new `POST`
    request for a new actor to the database with the `id` of `1`, `name` of `AxiomZen`,
    and `birth_year` of `2012`. Then, we send the request with the .`send()` function.
    Similar tests are present for `GET` and `DELETE` requests as given in the following
    code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，测试用例可以用纯英文阅读。我们为数据库中的新演员创建一个新的 `POST` 请求，该演员的 `id` 为 `1`，`name` 为 `AxiomZen`，`birth_year`
    为 `2012`。然后，我们使用 `.send()` 函数发送请求。以下代码中给出了 `GET` 和 `DELETE` 请求的类似测试。
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To test our `PUT` request, we will edit the `name` and `birth_year` of our
    first actor as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的 `PUT` 请求，我们将编辑第一个演员的 `name` 和 `birth_year`，如下所示：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first part of the test modifies the actor `name` and `birth_year` keys,
    sends a `PUT` request for `/actors/1` (`1` is the actors `id`), and then saves
    the new information to the database. The second part of the test checks whether
    the database entry for the actor with `id` `1` has been changed. The `name` and
    `birth_year` values are checked against their expected values using `.should.eql()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第一部分修改了演员的 `name` 和 `birth_year` 键，向 `/actors/1` 发送 `PUT` 请求（`1` 是演员的 `id`），然后将新信息保存到数据库中。测试的第二部分检查具有
    `id` `1` 的演员的数据库条目是否已更改。使用 `.should.eql()` 检查 `name` 和 `birth_year` 的值是否与预期值相符。
- en: 'In addition to performing CRUD actions on the actor object, we can also perform
    these actions to the movies we add to each actor (associated by the actor''s ID).
    The following snippet shows a test to add a new movie to our first actor (with
    the `id` of `1`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对演员对象执行 CRUD 操作外，我们还可以对每个演员添加的电影（通过演员的 ID 关联）执行这些操作。以下代码片段展示了向我们的第一个演员（`id`
    为 `1`）添加新电影的测试。
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first part of the test creates a new movie object with `id`, `title`, and
    `year` keys, and sends a `POST` request to add the movies as an array to the actor
    with `id` of `1`. The second part of the test sends a `GET` request to retrieve
    the actor with `id` of `1`, which should now include an array with the new movie
    input.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第一部分创建了一个新的电影对象，包含 `id`、`title` 和 `year` 键，并向具有 `id` 为 `1` 的演员发送一个 `POST`
    请求，将电影数组添加到该演员。测试的第二部分发送一个 `GET` 请求以检索具有 `id` 为 `1` 的演员，此时应该包含一个包含新电影输入的数组。
- en: 'We can similarly delete the movie entries as illustrated in the `actors.js`
    test file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地删除 `actors.js` 测试文件中的电影条目：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Again, this code snippet should look familiar to you. The first part tests that
    sending a `DELETE` request specifying the actor ID and movie ID will delete that
    movie entry. In the second part, we make sure that the entry no longer exists
    by submitting a `GET` request to view the actor's details where no movies should
    be listed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个代码片段应该对您来说很熟悉。第一部分测试发送指定演员 ID 和电影 ID 的 `DELETE` 请求将删除该电影条目。在第二部分中，我们通过提交一个
    `GET` 请求来查看演员的详细信息（不应列出任何电影），以确保该条目不再存在。
- en: 'In addition to ensuring that the basic CRUD operations work, we also test our
    schema validations. The following code tests to make sure two actors with the
    same ID do not exist (IDs are specified as unique):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保基本的 CRUD 操作正常工作外，我们还测试了我们的模式验证。以下代码测试确保没有两个具有相同 ID 的演员存在（ID 被指定为唯一的）：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We should expect code `400` (bad request) if we try to create an actor who already
    exists in the database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试创建一个已在数据库中存在的演员，我们应该期望代码返回 `400`（错误请求）。
- en: A similar set of tests is present for `tests/movies.js`. The function and outcome
    of each test should be evident now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `tests/movies.js`，也存在类似的测试集。每个测试的功能和结果现在应该很清楚。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a basic API that connects to MongoDB and supports
    CRUD methods. You should now be able to set up an API complete with tests, for
    any data, not just movies and actors!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个基本的 API，该 API 连接到 MongoDB 并支持 CRUD 方法。现在您应该能够为任何数据（而不仅仅是电影和演员）设置一个包含测试的完整
    API！
- en: The astute reader will have noticed that we have not addressed some issues in
    the current chapter such as dealing with race conditions in MongoDB. These will
    be clarified in detail in the following chapters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者会注意到，我们尚未在本章中解决一些问题，例如在 MongoDB 中处理竞争条件。这些问题将在接下来的章节中详细说明。
- en: We hope you found that this chapter has laid a good foundation for the Express
    and API setup.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您发现这一章节为 Express 和 API 设置奠定了良好的基础。
