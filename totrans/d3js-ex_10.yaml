- en: Chapter 10. Using Layouts to Visualize Series and Hierarchical Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。使用布局可视化系列和层次数据
- en: We are now going to get into what some refer to as the most powerful features
    of D3.js —layouts. Layouts encapsulate algorithms that examine your data and calculate
    the positions for visual elements for specific type of graphs such as bars, areas,
    bubbles, chords, trees, and many others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨一些人认为的D3.js最强大的功能——布局。布局封装了检查你的数据并计算特定类型图表（如条形、面积、气泡、弦、树等）的视觉元素位置的算法。
- en: We will dive into several useful layouts. These will be categorized into several
    main categories based upon the structure of the data and type of visualization
    such as stacked, hierarchical, chords, and flow-based diagrams. For each of the
    categories, we will go over creating a number of examples, complete with data
    and code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入研究几个有用的布局。这些将根据数据的结构和可视化类型（如堆叠、层次、弦和基于流的图表）分为几个主要类别。对于每个类别，我们将介绍一些示例，包括数据和代码。
- en: 'Specifically, we will examine creating the following types of graphs and layouts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将检查创建以下类型的图表和布局：
- en: Stacked layouts to create bar and area graphs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用堆叠布局创建条形图和面积图
- en: Hierarchical diagrams including trees, cluster dendrograms, and enclosures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次图包括树、簇树状图和围栏
- en: Relationships between items using chord diagrams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弦图表示项目之间的关系
- en: Flowing data using streamgraphs and Sankey diagrams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流图和桑基图流动数据
- en: Using stacked layouts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用堆叠布局
- en: Stacks are a class of layouts that take multiple series of data, where each
    measurement from each series is rendered atop each other. These are suited for
    demonstrating the comparative size of the measurements from each series at each
    measurement. They are also great at demonstrating how the multiple streams of
    data change over the entire set of measurements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠是一类布局，它接受多个数据系列，其中每个系列中的每个测量值都渲染在彼此之上。这些非常适合展示每个系列在每个测量点上的测量值的比较大小。它们也非常擅长展示多个数据流在整个测量集中的变化。
- en: 'Stacked diagrams basically come down to two different representations: stacked
    bar graphs and stacked area graphs. We will examine both of these and explain
    how to create these with D3.js.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠图基本上归结为两种不同的表示：堆叠条形图和堆叠面积图。我们将检查这两种，并解释如何使用D3.js创建它们。
- en: Creating a stacked bar graph
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建堆叠条形图
- en: The implementation of a stacked bar graph is similar to that of a bar graph,
    except that we need to take into account the fact that the height of each bar
    consists of the sum of each measurement. Normally, each bar is subdivided, with
    each division sized relative to the sum, and is given a different color to differentiate
    it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠条形图的实现与条形图类似，但我们需要考虑每个条形的高度是由每个测量的总和组成的这一事实。通常，每个条形会被细分，每个部分的大小相对于总和，并且会赋予不同的颜色以区分它们。
- en: Let's jump into creating our own stacked bar graph. The data that will be used
    can be found at [https://goo.gl/6fJrxE](https://goo.gl/6fJrxE).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建自己的堆叠条形图。将要使用的数据可以在[https://goo.gl/6fJrxE](https://goo.gl/6fJrxE)找到。
- en: The following are the first few lines of the file. This data represents seven
    series of data, each series a specific range of age, broken down categorically
    by state. Each value represents the population for the given state in that age
    group.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件的前几行。这些数据代表七个数据系列，每个系列代表一个特定的年龄范围，按州进行分类。每个值代表该年龄组给定州的居民人数。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The online example is available at the following link:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中可以找到在线示例：
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (10.1): [http://goo.gl/G3BIL7](http://goo.gl/G3BIL7)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (10.1): [http://goo.gl/G3BIL7](http://goo.gl/G3BIL7)'
- en: 'The resulting bar graph is the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 结果条形图如下：
- en: '![Creating a stacked bar graph](img/B04230_10_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![创建堆叠条形图](img/B04230_10_01.jpg)'
- en: 'The data is loaded using `d3.csv()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据使用`d3.csv()`加载：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Examining the first object in the resulting data, we see the following structure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 检查结果数据中的第一个对象，我们看到以下结构：
- en: '![Creating a stacked bar graph](img/B04230_10_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建堆叠条形图](img/B04230_10_02.jpg)'
- en: This array has 51 elements, one for each state of the US and Washington D.C.
    This data needs to be converted into a structure that gives us information for
    rendering each bar and the rectangle for each series within each of the bars.
    To do this, we need to go through three steps, the last one culminating with the
    use of `d3.layout.stack()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组有51个元素，每个元素代表美国和华盛顿特区的每个州。这些数据需要转换成一个结构，为我们提供渲染每个条形以及每个条形内每个序列的矩形的信息。为此，我们需要进行三个步骤，最后一个步骤使用`d3.layout.stack()`。
- en: First, the code extracts the unique keys for each series of data, which is the
    age groups. This can be retrieved by filtering out all properties of each object
    in the array where the property name is not equal to `State`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码提取每个数据序列的唯一键，即年龄组。这可以通过过滤掉数组中每个对象的非`State`属性的所有属性来实现。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Creating a stacked bar graph](img/B04230_10_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![创建堆积条形图](img/B04230_10_03.jpg)'
- en: 'Using these keys, we can reorganize the data so that we have an array representing
    the values for each age group:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些键，我们可以重新组织数据，以便我们有一个表示每个年龄组值的数组：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `statesAndAges` variables now is a seven-element array, with each element
    being an array of objects representing the `x` and `y` values for each series:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`statesAndAges`变量现在是一个包含七个元素的数组，每个元素都是一个对象数组，代表每个序列的`x`和`y`值：'
- en: '![Creating a stacked bar graph](img/B04230_10_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![创建堆积条形图](img/B04230_10_04.jpg)'
- en: Now, using these keys, we create a `d3.layout.stack()` function and have it
    process this data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这些键，我们创建一个`d3.layout.stack()`函数，并让它处理这些数据。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result of the stacking of this data is that the stack function will add
    an additional property, `y0`, to each object in each series. The value of `y0`
    will be the value of the sum of the `y` values in the previously lower-numbered
    series. To demonstrate, the following are the values of the objects in the first
    object of each array:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据的堆叠结果是将堆叠函数添加一个额外的属性`y0`到每个序列中的每个对象。`y0`的值将是之前编号较低的序列中`y`值的总和。为了演示，以下是在每个数组第一个对象中的对象值：
- en: '![Creating a stacked bar graph](img/B04230_10_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![创建堆积条形图](img/B04230_10_05.jpg)'
- en: The value of `y0` in the first object is `0`. The value of `y0` in the second
    is `310504`, which is equal to `y0` + `y` of the first object. The value of `y0`
    in the third object is `y0` + `y` of the second, or `862843`. This function has
    stacked the `y` values, with each `y` value being the value of `y` for the individual
    segment of the bar that will be rendered.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对象中`y0`的值为`0`。第二个对象中`y0`的值为`310504`，等于第一个对象的`y0` + `y`。第三个对象中`y0`的值为第二个的`y0`
    + `y`，即`862843`。此函数已堆叠`y`值，每个`y`值都是将要渲染的条形单个段的`y`值。
- en: 'The data is now organized to render the bar graph. The next step is to create
    the main SVG element:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数据现在已组织好以渲染条形图。下一步是创建主SVG元素：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code next calculates the `x` and `y` scales to map the bars into the specified
    number of pixels. The `y` scale will have a domain that ranges from `0` to the
    maximum sum of `y0` and `y` within all the series:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码计算`x`和`y`比例尺，以将条形映射到指定的像素数。`y`比例尺的域将从`0`到所有序列中`y0`和`y`的最大总和：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The *x* scale is set up as an ordinal `rangeRoundBands`, one for each state:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`比例尺设置为每个州的序数`rangeRoundBands`：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code then creates a group for each of the series, assigning to each the
    color that the rectangles within will be filled with:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码随后为每个序列创建一个组，并为每个组分配一个颜色，该颜色将用于填充矩形：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last step is to render all the rectangles. The following performs this
    by creating `51` rectangles within each group:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是渲染所有矩形。以下是在每个组内创建`51`个矩形的操作：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's it! You have drawn this graph using this data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！您已经使用这些数据绘制了这个图表。
- en: Modifying the stacked bar into a stacked area graph
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将堆积条形图修改为堆积面积图
- en: Stacked area graphs give a different view of the data than a stacked bar does.
    To create a stacked area graph, we change the rendering of each series of data
    as a path. The path is defined using an area generator, which has the `y` values
    on the lower end and the sum of `y0 + y` on the upper end.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 堆积面积图与堆积条形图对数据的展示方式不同。要创建堆积面积图，我们需要将每个数据序列的渲染方式改为路径。路径是通过一个面积生成器定义的，该生成器在底部具有`y`值，在顶部具有`y0
    + y`的总和。
- en: 'The code for the stacked area graph is available online at the following link:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 堆积面积图的代码可在以下链接在线获取：
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (10.2): [http://goo.gl/PRw8wv](http://goo.gl/PRw8wv)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (10.2): [http://goo.gl/PRw8wv](http://goo.gl/PRw8wv)'
- en: 'The resulting output from this example is the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的结果如下：
- en: '![Modifying the stacked bar into a stacked area graph](img/B04230_10_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![将堆叠条形图修改为堆叠面积图](img/B04230_10_06.jpg)'
- en: The change from the previous example is relatively small. The data is loaded
    and organized exactly the same. The scales and colors are also created the same
    way.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例相比，这种变化相对较小。数据加载和组织方式完全相同。刻度和颜色也是以相同的方式创建的。
- en: 'The difference comes in the rendering of the visuals. Instead of groups of
    rectangles, we render a filled path for each series. The following creates these
    paths and assigns the color for each:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于视觉效果的呈现。我们不是渲染矩形组，而是为每个系列渲染一个填充路径。以下创建这些路径并为每个分配颜色：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This has generated the path elements, but has not assigned the path''s `d`
    property yet to create the actual path data. That''s our next step, but we first
    need to create an area generator to convert our data to that which is needed for
    the path. This area generator needs to have three values specified, the `x` value,
    `y0` (which represents the bottom of the area), and `y1` (which is at the top
    of the area):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经生成了路径元素，但尚未分配路径的`d`属性以创建实际的路径数据。这是我们下一步要做的事情，但首先我们需要创建一个面积生成器，将我们的数据转换为路径所需的数据。这个面积生成器需要指定三个值，即`x`值，`y0`（表示区域的底部），以及`y1`（位于区域的顶部）：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And finally, we select the paths we just created and bind to each the appropriate
    series, setting the `d` attribute of the corresponding path to the result of calling
    the area generator. Note that this calls the area generator for each series:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们选择我们刚刚创建的路径并将它们绑定到每个适当的系列上，将对应路径的`d`属性设置为调用面积生成器的结果。请注意，这是为每个系列调用面积生成器：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Converting the area graph to an expanded area graph
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将面积图转换为扩展面积图
- en: There is a variant of a stacked area graph known as an expanded area graph.
    An expanded area graph fills the entire area of the graph completely and can be
    used to easily visualize the relative percentage that each series represents at
    each point.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种堆叠面积图的变体，称为扩展面积图。扩展面积图完全填充图表的整个区域，可以用来轻松地可视化每个系列在每个点所代表的相对百分比。
- en: 'This type of graph is created from a stacked area graph by normalizing the
    data at each point across all series to 1.0\. The following example demonstrates
    how this is performed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图表是通过将所有系列中每个点的数据归一化到1.0来从堆叠面积图创建的。以下示例演示了这是如何执行的：
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (10.3): [http://goo.gl/g9BH4L](http://goo.gl/g9BH4L)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (10.3): [http://goo.gl/g9BH4L](http://goo.gl/g9BH4L)'
- en: 'The resulting graph is the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表如下：
- en: '![Converting the area graph to an expanded area graph](img/B04230_10_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![将面积图转换为扩展面积图](img/B04230_10_07.jpg)'
- en: This visually gives us a good feel of how the relative size of each age group
    changes during the period. For the most part, the age groups have stayed at the
    same proportion, except for perhaps one state near the end of the data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这从视觉上很好地展示了每个年龄组在期间相对大小如何变化。大多数情况下，年龄组的比例保持不变，除了数据末尾可能的一个州。
- en: 'It''s a really easy thing to convert the stacked area graph to an expanded
    area graph. To accomplish this, we need to do two things. The first of these is
    to change how we stack the data. We change the stack operation to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将堆叠面积图转换为扩展面积图是一件非常容易的事情。为了完成这个任务，我们需要做两件事。其中之一是改变我们堆叠数据的方式。我们将堆叠操作更改为以下内容：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The change here is to add a call to `.offset("expand")`. This informs D3.js
    to normalize the results to `[0, 1]` for each point. The default offset is `"zero",`
    which, as we have seen, starts *Y* values at `0` and does a running sum.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的变化是添加对`.offset("expand")`的调用。这通知D3.js将每个点的结果归一化到`[0, 1]`。默认偏移量是`"zero"`，正如我们所看到的，它从`*Y*`值开始为`0`并执行运行总和。
- en: 'The data is now ready, and the second change is to change the `Y` scale to
    the account for the domain as `[0, 1]`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数据现在已准备好，第二个更改是将`Y`轴范围更改为考虑域为`[0, 1]`：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You now have your expanded area graph.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了你的扩展面积图。
- en: Visualizing hierarchical data
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示分层数据
- en: '**Hierarchal layouts** display information that is hierarchical in nature.
    That is perhaps a slightly recursive definition, but the basic idea is that certain
    data items break down into zero or more data items at a lower level, and then
    perhaps to another level, and so on, for as many levels as is required.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**分层布局**显示具有分层性质的信息。这可能是一个稍微递归的定义，但基本思想是某些数据项在较低级别分解为零个或多个数据项，然后可能到另一个级别，依此类推，直到所需的级别。'
- en: Hierarchical layouts are all created from the `d3.layout.hierarchy()` function,
    but there are specializations of this function that create various layouts which
    fall into common visual patterns such as trees, clusters, and enclosures and packs.
    We will take a look at an example of each of these types of layouts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 层次布局都是通过`d3.layout.hierarchy()`函数创建的，但该函数有专门化的版本，可以创建各种布局，这些布局属于常见的视觉模式，如树、簇和包围与包装。我们将查看每种类型布局的示例。
- en: Tree diagrams
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树形图
- en: 'Tree diagrams are essentially node-link diagrams. In [Chapter 9](ch09.html
    "Chapter 9. Complex Shapes Using Paths"), *Complex Shapes using Paths*, we saw
    the use of a path generator known as a diagonal. This generator was able to create
    curved line segments that can connect a node to one or more nodes. To refresh
    you, we had an example that generated the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 树形图本质上是一种节点-链接图。在[第9章](ch09.html "第9章. 使用路径的复杂形状")中，我们看到了使用一种称为对角线生成器的路径生成器的应用。这种生成器能够创建可以连接一个节点到一个或多个节点的曲线线段。为了帮助您回忆，我们有一个生成以下内容的示例：
- en: '![Tree diagrams](img/B04230_10_08.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![树形图](img/B04230_10_08.jpg)'
- en: This is a basic node-link diagram. Tree diagrams utilize diagonals and apply
    them to many levels of hierarchy. The diagram can be structured as a tree or in
    other more complex layouts such as a radial cluster (which we will examine). The
    layouts will calculate the positions of the nodes and then we need to render the
    nodes and the attached diagonals.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的节点-链接图。树形图利用对角线并将它们应用于多个层次。该图可以结构化为树形或其他更复杂的布局，如辐射簇（我们将对其进行研究）。布局将计算节点的位置，然后我们需要渲染节点和连接的对角线。
- en: 'We will start by creating a simple tree diagram. The data is available at [https://goo.gl/mcdT9r](https://goo.gl/mcdT9r).
    The contents of the data are the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的树形图开始。数据可在[https://goo.gl/mcdT9r](https://goo.gl/mcdT9r)找到。数据的内容如下：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The example is available at the following location:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例可在以下位置找到：
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (10.4): [http://goo.gl/t1hBTS](http://goo.gl/t1hBTS)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (10.4): [http://goo.gl/t1hBTS](http://goo.gl/t1hBTS)'
- en: 'The result of the rendering is the following tree diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染的结果是以下树形图：
- en: '![Tree diagrams](img/B04230_10_09.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![树形图](img/B04230_10_09.jpg)'
- en: 'Our example begins with loading the data, establishing metrics for the diagram,
    creating the main SVG element, and establishing a main group and margins:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例从加载数据、为图表建立度量标准、创建主要SVG元素以及建立主要组和边距开始：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To convert the data into a visual representation of a tree, we will create a
    tree layout using the `d3.layout.tree()` function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据转换为树的可视表示，我们将使用`d3.layout.tree()`函数创建树布局。
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This informs D3.js that we want to create a tree that will map its data into
    a rectangle specified by `height` and `width`. Notice that the `height` is specified
    before `width`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉D3.js我们想要创建一个树，它将数据映射到由`height`和`width`指定的矩形中。请注意，`height`是在`width`之前指定的。
- en: 'There are two visual components to the graph: the nodes, represented by circles,
    and the edges, which are diagonals. To calculate the nodes, we use the `.nodes()`
    function of the layout and pass it our data.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图表有两个视觉组件：节点，由圆圈表示，以及边，即对角线。为了计算节点，我们使用布局的`.nodes()`函数，并将我们的数据传递给它。
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The tree function looks for a top-level node with a `children` property. It
    will traverse all the nodes in the hierarchy and determine its depth, which, in
    this case, has four levels. It will then add `x` and `y` properties to each node,
    where these represent the calculated position of the nodes based upon the layout
    and the specific `width` and `height`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 树函数寻找具有`children`属性的顶级节点。它将遍历层次结构中的所有节点，并确定其深度，在这种情况下，有四个级别。然后它将为每个节点添加`x`和`y`属性，这些属性代表基于布局和特定`width`和`height`计算出的节点位置。
- en: 'Examining the contents of the `nodes` variable, we can see that D3.js has given
    us the positions for each node (the following shows the first two nodes):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`nodes`变量的内容，我们可以看到D3.js已经为我们提供了每个节点的位置（以下显示了前两个节点）：
- en: '![Tree diagrams](img/B04230_10_10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![树形图](img/B04230_10_10.jpg)'
- en: 'To get the links in the tree, we call `tree.links(nodes)`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取树中的链接，我们调用`tree.links(nodes)`：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following shows the link that results in this example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了导致此示例的链接：
- en: '![Tree diagrams](img/B04230_10_11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![树形图](img/B04230_10_11.jpg)'
- en: The newly created data structure consists of an element for each link, of which
    each object contains a `source` and `target` property that points to the node
    that is on each end of the link.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的数据结构由每个链接的元素组成，其中每个对象包含一个指向链接每端节点的`source`和`target`属性。
- en: 'We now have our data ready for creating visuals. Next is the statement for
    creating the generator for the diagonals. We use the `.projection()` function,
    since we need to tell the generator how to find the `x` and `y` value from each
    datum:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了创建视觉数据的数据准备就绪。接下来是创建对角线生成器的语句。我们使用`.projection()`函数，因为我们需要告诉生成器如何从每个数据中找到`x`和`y`值：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can create the diagonals, reusing the generator for each. The diagonals
    are created before the nodes, because we want the nodes to be in front:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建对角线，为每个对角线重用生成器。对角线是在节点之前创建的，因为我们希望节点在前：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now the code creates the circles and the labels. We will represent each node
    with a group containing a circle and a piece of text. The following creates these
    groups and places them at the calculated locations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码创建圆和标签。我们将用包含一个圆和一段文本的组来表示每个节点。以下创建这些组并将它们放置在计算出的位置：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we add the circles as a child of each node''s group element:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将圆作为每个节点组元素的子元素添加：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And then we add the text for the node label to the group:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将节点标签文本添加到组中：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function, when assigning the `y` attribute, offsets the position of the
    text to be above the circle if the node is not a leaf and underneath the node
    if it is a leaf node.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当分配`y`属性时，如果节点不是叶子节点，则将文本位置偏移到圆上方；如果是叶子节点，则位于节点下方。
- en: Creating a cluster dendrogram
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建聚类树状图
- en: A hierarchy can also be visualized as a variant of a tree known as a **cluster
    dendrogram**. A cluster dendrogram differs from a tree graph in that we use a
    cluster layout. This layout places the root of the tree at the center. The depth
    of the data is calculated, and that number of levels of concentric circles are
    fit into the diagram. The nodes for each level of depth are then placed around
    the edge of the circle for their respective depth.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个层次结构也可以被可视化为一个称为**聚类树状图**的树形变体。聚类树状图与树图的不同之处在于我们使用聚类布局。这种布局将树的根放在中心。计算数据深度，并将相应数量的同心圆层放入图中。然后，将每个深度的节点放置在圆的边缘，以对应其深度。
- en: To demonstrate this, we will utilize the data available at [https://goo.gl/t3M7n1](https://goo.gl/t3M7n1).
    This data represents three levels of data, with one root node and four nodes on
    the second level; each of those nodes has nine children.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将利用位于[https://goo.gl/t3M7n1](https://goo.gl/t3M7n1)的数据。这些数据代表三个级别的数据，有一个根节点和第二级上的四个节点；这些节点中的每一个都有九个孩子。
- en: 'The following is a sample of the data:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些数据的样本：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The example is available at the following location:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例可在以下位置找到：
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (10.5): [http://goo.gl/cQtPuH](http://goo.gl/cQtPuH)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (10.5): [http://goo.gl/cQtPuH](http://goo.gl/cQtPuH)'
- en: 'The resulting graph is the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如下：
- en: '![Creating a cluster dendrogram](img/B04230_10_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![创建聚类树状图](img/B04230_10_12.jpg)'
- en: 'Let''s step through how this is created. The code is similar to the tree example,
    but with some differences. After the data is loaded, the main SVG element is created,
    and then a group is placed within the element:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解这是如何创建的。代码与树示例类似，但有一些不同。在数据加载后，创建主SVG元素，然后在元素内放置一个组：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The layout algorithm will calculate the points around a center at (**0, 0**),
    so we center the group to center the graph.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 布局算法将在中心点（**0, 0**）周围计算点，因此我们将组居中以便图形居中。
- en: 'The layout is then created using `d3.layout.cluster()`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`d3.layout.cluster()`创建布局：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The size specifies two things; the first parameter is the number of degrees
    that the points will sweep through on the outer circle. This specifies `360` degrees
    so that we completely fill the outer circle. The second parameter is the tree
    depth, or what is essentially the radius of the outermost circle.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 大小指定了两件事；第一个参数是点在圆外圈上扫过的角度数。这指定了`360`度，以便我们完全填满外圈。第二个参数是树深度，或者说外圈的最外层圆的半径。
- en: 'Next, we use the layout to calculate the position for the nodes and links:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用布局来计算节点和链接的位置：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It is worth examining the first few nodes that result from these calculations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得检查这些计算结果的前几个节点：
- en: '![Creating a cluster dendrogram](img/B04230_10_13.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建聚类树状图](img/B04230_10_13.jpg)'
- en: The `x` and `y` properties specify a direction and distance at which the node
    (and edges) is to be placed. The `x` property specifies the angle from vertical,
    and the value of the `y` property specifies the distance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 和 `y` 属性指定了节点（以及边）放置的方向和距离。`x` 属性指定了与垂直方向的夹角，而 `y` 属性的值指定了距离。'
- en: 'The diagonals are calculated using a radial diagonal, which needs to convert
    the `x` values into radians:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对角线是使用径向对角线计算的，需要将 `x` 值转换为弧度：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can use this radial generator diagonal that connects the nodes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用连接节点的对角线径向生成器：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we create a group to hold the node and the text. The trick to this is
    that we need to translate and rotate the group into the correct position:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个组来包含节点和文本。这个技巧在于我们需要将组转换并旋转到正确的位置：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We rotate the group by `90` degrees from the calculated angle. This changes
    the orientation of the the text to flow out from the circle, along the diagonals.
    Note that rotate works in degrees, not radians, as was required for the radial
    generator. The translate uses just the `y` value, which moves the group out that
    distance along the specified angle. Now we add the circles to the group:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组绕计算出的角度旋转 `90` 度。这改变了文本的流向，使其从圆圈流出，沿着对角线。请注意，旋转使用的是度数，而不是弧度，正如径向生成器所要求的。平移仅使用
    `y` 值，它将组沿指定角度移动这个距离。现在我们将圆圈添加到组中：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And finally, we add the text. Note the small calculation around the text being
    at an angle greater or less than 180 degrees. This essentially says that nodes
    on the left-half of the diagram are positioned with the end of the text against
    the node and on the right side, start at the beginning of the text. The text is
    also transformed by twice the circle radius to prevent it from overlapping the
    circle:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加文本。注意围绕文本的小计算，它表示角度大于或小于 180 度。这本质上意味着图左侧的节点位置是文本的末端对着节点，而在右侧，从文本的开始处开始。文本还通过圆半径的两倍进行变换，以防止它与圆重叠：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Representing hierarchy with an enclosure diagram
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用封装图表示层次结构
- en: Enclosure diagrams use nesting of visuals to represent the hierarchy. The size
    of each leaf node's circle reveals a quantitative dimension of each data point.
    The enclosing circles show the approximate cumulative size of each subtree, but
    note that because of wasted space, there is some distortion between levels. Therefore,
    only the leaf nodes can be compared accurately.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 封装图使用视觉嵌套来表示层次结构。每个叶节点圆圈的大小揭示了每个数据点的定量维度。包含的圆圈显示了每个子树的近似累积大小，但请注意，由于空间浪费，不同级别之间存在一些扭曲。因此，只有叶节点可以准确比较。
- en: 'The following is the location of the online example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在线示例的位置：
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (10.6): [http://goo.gl/MQ3CwG](http://goo.gl/MQ3CwG)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '块 (10.6): [http://goo.gl/MQ3CwG](http://goo.gl/MQ3CwG)'
- en: 'The following image is the resulting visual:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是生成的视觉结果：
- en: '![Representing hierarchy with an enclosure diagram](img/B04230_10_14.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![使用封装图表示层次结构](img/B04230_10_14.jpg)'
- en: The data used by the example is available at [https://goo.gl/RzvlV3](https://goo.gl/RzvlV3).
    It is similar in structure to the data in the previous example, except that a
    `value` property is added to each node. The values of the leaf nodes are summed
    in their parents, repeating all the way to the top.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中使用的数据可在 [https://goo.gl/RzvlV3](https://goo.gl/RzvlV3) 获取。它的结构类似于前面的示例，除了每个节点都添加了一个
    `value` 属性。叶节点的值在它们的父节点中汇总，一直重复到顶部。
- en: Essentially, this data is a rollup of the values, much like what would be performed
    when rolling up sales numbers from sales persons, to offices, to divisions, to
    the corporate level. The diagram then allows us to see relative sizes of the numbers
    in the leaf nodes, which are colored orange, and then get an idea of the total
    at each level up the tree.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这些数据是对值的汇总，就像从销售人员到办公室、到部门、到公司层面的销售额汇总时所执行的操作一样。然后，图表使我们能够看到叶节点中数字的相对大小，这些节点被涂成橙色，并且可以了解树中每个级别的总数。
- en: 'Now let''s examine how this is created. The example begins with loading of
    the data and then creating an SVG element of a specified diameter. Then, a pack
    layout is created that is also used the diameter. The hierarchical bubbles that
    are created will be measured to fit within the specified diameter:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这是如何创建的。示例从加载数据开始，然后创建一个指定直径的 SVG 元素。然后创建一个包装布局，它也使用了直径。创建的层次气泡将被测量以适应指定的直径：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we render the circles. For each node, we append a group that is translated
    to the appropriate position and then a circle is appended with its radius set
    to the calculated radius `(d.r),` the `fill`, `fill-opacity`, and the `stroke`
    to different values depending on whether the node is a leaf or not:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们渲染圆圈。对于每个节点，我们添加一个平移到适当位置的组，然后添加一个圆圈，其半径设置为计算出的半径`(d.r)`，`fill`、`fill-opacity`和`stroke`根据节点是否为叶子节点而设置不同的值：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last step is to add the text to the leaf circles (the ones without children,
    as specified using the filter):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将文本添加到叶子圆圈（没有子节点的那些，如使用过滤器指定的）：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Representing relationships with chord diagrams
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用弦图表示关系
- en: 'Chord diagrams demonstrate the relationships among a group of entities. To
    demonstrate, we will use the example available at the following link:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 弦图展示了实体组之间的关系。为了展示，我们将使用以下链接中的示例：
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (10.7): [http://goo.gl/8mRDSg](http://goo.gl/8mRDSg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (10.7): [http://goo.gl/8mRDSg](http://goo.gl/8mRDSg)'
- en: 'The resulting diagram is the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表如下：
- en: '![Representing relationships with chord diagrams](img/B04230_10_15.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用弦图表示关系](img/B04230_10_15.jpg)'
- en: 'The data in this example is a square matrix of data, with rows and columns
    representing hair color (black, blonde, brown, and red). The data represents a
    total sample of **100000** measurements, where each row demonstrates the total
    count of the other hair colors which a person of a given hair color prefers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的数据是一个方阵数据，行和列代表发色（黑色、金色、棕色和红色）。数据代表总共**100000**次测量，其中每一行展示了具有特定发色的人所偏好的其他发色的总计数：
- en: '|   | ***Prefers*** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|   | ***偏好*** |'
- en: '| ***Has*** | **Black** | **Blonde** | **Brown** | **Red** | **Total** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| ***拥有*** | **黑色** | **金色** | **棕色** | **红色** | **总计** |'
- en: '| **Black** | 11975 | 5871 | 8916 | 2868 | 29630 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **黑色** | 11975 | 5871 | 8916 | 2868 | 29630 |'
- en: '| **Blonde** | 1951 | 10048 | 2060 | 6171 | 20230 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **金色** | 1951 | 10048 | 2060 | 6171 | 20230 |'
- en: '| **Brown** | 8010 | 16145 | 8090 | 8045 | 40290 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **棕色** | 8010 | 16145 | 8090 | 8045 | 40290 |'
- en: '| **Red** | 1013 | 990 | 940 | 6907 | 9850 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **红色** | 1013 | 990 | 940 | 6907 | 9850 |'
- en: '| **Total** | 22949 | 30354 | 20006 | 23991 | 10000 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **总计** | 22949 | 30354 | 20006 | 23991 | 10000 |'
- en: To explain the diagram, each outer ring segment represents the number of people
    that have a given hair color. The size of these ring segments is relative to the
    percentage of people of a given hair color. Each arc from a given color ring segment
    to another ring segment (or itself) represents the number of people of that hair
    color that prefer the hair color on the other side of that arc and vice versa.
    The ticks on the outside of each ring segment gives a feel for the total number
    of the people represented.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这个图表，每个外环段代表具有特定发色的人数。这些环段的尺寸与具有特定发色的人数的百分比成比例。从给定颜色的环段到另一个环段（或自身）的每个弧线代表喜欢该弧线另一侧发色的人数，反之亦然。每个环段外部的刻度给出了所代表的人数的总体感觉。
- en: 'Now let''s step through creating this graph. First, we create our top-level
    SVG elements. The main group is translated to the center, as the positions will
    be centered around (**0, 0**):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们逐步创建此图。首先，我们创建我们的顶级SVG元素。主组被平移到中心，因为位置将围绕（**0, 0**）进行居中：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s declare the data. We will use a hard-coded array instead of reading
    from a file. These values represent the values from the previous table, exclusive
    of the totals:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们声明数据。我们将使用硬编码的数组而不是从文件中读取。这些值代表之前表格中的值，不包括总计：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We then use the `d3.layout.chord()` function to create the layout object for
    this graph.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`d3.layout.chord()`函数来创建此图的布局对象。
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`.padding(0.05)` states that there will be `0.05` radians of space between
    the sections on the outside of the diagram, and the call to `.matrix()` specifies
    the data to use.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`.padding(0.05)`表示在图表外部区域的部分之间将有`0.05`弧度的空间，而`.matrix()`的调用指定了要使用的数据。'
- en: 'The following line of code creates the colors that will be utilized (black,
    blondish, brownish, and reddish):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代码创建了将要使用的颜色（黑色、金色、棕色和红色）：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, the ring segments are rendered. The inner and outer radius of the ring
    segments is calculated as percentages of the smallest dimension of the visual.
    The data that is bound is the group''s property of the layout object. For each
    of these, we render a path using an arc generator:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，渲染环段。环段的内半径和外半径是视觉的最小维度的百分比。绑定的是布局对象的组属性。对于这些中的每一个，我们使用弧生成器渲染一个路径：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, the chords are rendered. A `d3.svg.chord()` function will be applied
    to each datum, and a path of the size `innerRadius` is generated:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，渲染弦。将对每个数据项应用 `d3.svg.chord()` 函数，并生成大小为 `innerRadius` 的路径：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At this point, we have created the entire chord graph sans ticks and labels.
    We will omit covering those in the book, but feel free to check out the sample
    code with the text to see how this is performed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了整个弦图，不包括刻度和标签。我们将省略这部分内容，但请随意查看带有文本的示例代码，以了解这是如何实现的。
- en: Techniques to demonstrate the flow of information
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示信息流动的技术
- en: The last two layouts and corresponding visualizations that we will examine help
    the viewer to understand how data changes as it flows over time or through intermediate
    points.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个布局和相应的可视化有助于观众了解数据如何随时间流动或通过中间点而变化。
- en: Using streamgraphs to show changes in values
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用流图显示值的变化
- en: A **streamgraph** demonstrates the change in values in a multiple series of
    data as a flowing stream of data. The height of each stream represents the value
    of that stream at that moment in time.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**流图**展示了多系列数据值的变化，就像流动的数据流一样。每个流的高度代表该流在某一时刻的值。'
- en: They are useful for demonstrating where certain categories start or stop at
    different points along the graph. Common examples are data such as box-office
    receipts or the number of listeners for various artists on streaming media as
    they change over time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它们对于演示某些类别在不同点沿图开始或结束的位置非常有用。常见的例子包括票房收入或流媒体上各种艺术家听众数量的数据，这些数据随时间变化。
- en: To demonstrate a streamgraph, we will use the data available at [https://goo.gl/HTL4HG](https://goo.gl/HTL4HG).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示流图，我们将使用在 [https://goo.gl/HTL4HG](https://goo.gl/HTL4HG) 可用的数据。
- en: 'This data consists of four series of data:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据由四个系列的数据组成：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The online example is available at the following location:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下位置可以找到在线示例：
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (10.8): [http://goo.gl/LMd3F3](http://goo.gl/LMd3F3)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (10.8): [http://goo.gl/LMd3F3](http://goo.gl/LMd3F3)'
- en: 'The following is the resulting streamgraph:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的结果是流图：
- en: '![Using streamgraphs to show changes in values](img/B04230_10_16.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![使用流图显示值的变化](img/B04230_10_16.jpg)'
- en: This graph allows us to see how each individual series of data is related to
    each other at each point of measurement. It is, in a way, like a stacked area
    chart, but instead of each being fixed at a common baseline, the bottom of the
    graph is also allowed to vary in location.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此图使我们能够看到每个数据系列在每次测量点如何相互关联。在某种程度上，它就像堆叠区域图，但与每个都固定在共同的基线不同，图表的底部位置也可以变化。
- en: 'The example begins by loading the data and setting up the main SVG element:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 示例首先加载数据并设置主要的 SVG 元素：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We need to massage the data a little bit, as the call to the layout function
    will expect it in the same format as an area graph, which is an array of arrays
    of objects with `x` and `y` properties. The following code creates this, using
    the position of the value in each array as the `x` value:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对数据进行一些调整，因为布局函数的调用将期望它以与区域图相同的格式，即具有 `x` 和 `y` 属性的对象的数组数组。以下代码创建了这个，使用数组中值的每个位置作为
    `x` 值：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, the code creates the axes, with the *X* axis being a linear axis representing
    the number of points in each series:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码创建轴，其中 *X* 轴是一个线性轴，表示每个系列中的点数：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The layout is the familiar stack layout that was used in the area graph example,
    but we chain a call to `.offset(''wiggle'')`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是熟悉的堆叠布局，就像在区域图示例中使用的那样，但我们通过调用 `.offset('wiggle')` 来链式调用：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The remainder of the code continues just as an area graph, using an area path
    generator and similarly scaled *Y* axis.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分继续像区域图一样，使用区域路径生成器和类似缩放的 *Y* 轴。
- en: Representing flows through multiple nodes
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过多个节点表示流程
- en: Instead of showing a continuous flow like a streamgraph, a **Sankey** diagram
    emphasizes how the flow quantity changes proportionally. This is somewhat like
    a chord diagram, but a Sankey has the ability to visualize more complex flows
    than just between two items.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与显示连续流动的流图不同，**桑基图**强调流动量的比例变化。这有点像弦图，但桑基图能够可视化比仅两个项目之间的更复杂的流动。
- en: In a Sankey diagram, the width of the lines between the nodes represents the
    volume of the flow between two nodes. Normally, flows start at one or more nodes
    on the left, flow through intermediates, and then terminate at nodes on the right.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sankey 图中，节点之间的线条宽度表示两个节点之间的流量量。通常，流量从左侧的一个或多个节点开始，通过中间节点，然后终止在右侧的节点上。
- en: 'The example diagram uses the data available at [https://goo.gl/lgQZBz](https://goo.gl/lgQZBz).
    This data consists of declarations for eight nodes and then the links between
    the nodes along with the amount of the flow between the nodes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 示例图表使用可在 [https://goo.gl/lgQZBz](https://goo.gl/lgQZBz) 找到的数据。这些数据包括八个节点的声明以及节点之间的链接和节点之间的流量：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The online example is available at the following location:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下位置可以找到在线示例：
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (10.9): [http://goo.gl/exZkI4](http://goo.gl/exZkI4)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (10.9): [http://goo.gl/exZkI4](http://goo.gl/exZkI4)'
- en: 'The resulting Sankey diagram from this data will be the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些数据生成的 Sankey 图如下所示：
- en: '![Representing flows through multiple nodes](img/B04230_10_17.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![通过多个节点表示流](img/B04230_10_17.jpg)'
- en: The Sankey layout is considered a plugin to D3.js. It is not in the base library,
    so you need to retrieve the code, and make sure to reference it in your app. This
    code is available at [https://github.com/d3/d3-plugins/tree/master/sankey](https://github.com/d3/d3-plugins/tree/master/sankey),
    or you can grab it from the book's example.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Sankey 布局被视为 D3.js 的一个插件。它不在基础库中，因此您需要检索代码，并确保在您的应用程序中引用它。此代码可在 [https://github.com/d3/d3-plugins/tree/master/sankey](https://github.com/d3/d3-plugins/tree/master/sankey)
    找到，或者您可以从本书的示例中获取它。
- en: 'The example begins by loading the data and creating the main SVG elements:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 示例首先通过加载数据并创建主要的 SVG 元素开始：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We create the layout using the plugin as follows. There are lot of parameters
    here to specify the size of the nodes, the padding, overall size of the diagram,
    where to get the links and nodes in your data, and layout specifying the number
    of iterations to be processed for positioning the nodes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下方式创建布局。这里有很多参数可以指定节点的大小、填充、整个图表的大小、在您的数据中获取链接和节点的地方，以及布局指定用于定位节点的迭代次数：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The flow paths (links) are rendered by creating paths representing flows. The
    structure of the path is provided by referencing the `sankey.link()`, which is
    a function that creates the path data for the flow:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 流路径（链接）通过创建表示流的路径来渲染。路径的结构是通过引用 `sankey.link()` 提供的，这是一个创建流路径数据的函数：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we create a group to hold the nodes and place them into position based
    on the `x` and `y` properties provided by the layout. The `.node` style is used
    simply to differentiate the selection of these groups from those of the paths
    (which used `.link`):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个组来存放节点，并根据布局提供的 `x` 和 `y` 属性将它们放置到合适的位置。`.node` 样式仅用于区分这些组的选择与路径（使用
    `.link`）的选择：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we insert a colored rectangle into the groups:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在组中插入一个彩色矩形：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We also include text to describe the node, with some logic to position the
    label:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含文本来描述节点，并使用一些逻辑来定位标签：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a lot in this chapter. The overall focus was on creating complex
    graphs that utilize D3.js layout objects. These included a multitude of graphs
    in different categories including stacked, packed, clustered, flow-based, hierarchical,
    and radial.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量的内容。总体重点是创建利用 D3.js 布局对象的复杂图表。这些图表包括不同类别的大量图表，包括堆叠、打包、聚类、基于流、层次和径向。
- en: One of the beauties of D3.js is the ease at which it allows you to create these
    complex visuals. They are pattern-oriented such that the code for each is often
    very similar, with just a slight change of layout objects.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 的一个优点是它允许您轻松地创建这些复杂视觉效果的便捷性。它们是模式导向的，因此每个的代码通常非常相似，只是布局对象略有不同。
- en: 'In the next chapter, we will look at a specific type of graph in detail: the
    network diagram. These extend upon several concepts we have seen in this chapter,
    such as flow and hierarchy, to allow us to visualize very complex network data
    such as those found in social networks.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨一种特定的图形：网络图。这些图扩展了我们本章中看到的一些概念，如流和层次结构，使我们能够可视化非常复杂的数据，如社交网络中的数据。
