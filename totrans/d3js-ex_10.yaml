- en: Chapter 10. Using Layouts to Visualize Series and Hierarchical Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to get into what some refer to as the most powerful features
    of D3.js —layouts. Layouts encapsulate algorithms that examine your data and calculate
    the positions for visual elements for specific type of graphs such as bars, areas,
    bubbles, chords, trees, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive into several useful layouts. These will be categorized into several
    main categories based upon the structure of the data and type of visualization
    such as stacked, hierarchical, chords, and flow-based diagrams. For each of the
    categories, we will go over creating a number of examples, complete with data
    and code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will examine creating the following types of graphs and layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: Stacked layouts to create bar and area graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hierarchical diagrams including trees, cluster dendrograms, and enclosures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships between items using chord diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flowing data using streamgraphs and Sankey diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using stacked layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stacks are a class of layouts that take multiple series of data, where each
    measurement from each series is rendered atop each other. These are suited for
    demonstrating the comparative size of the measurements from each series at each
    measurement. They are also great at demonstrating how the multiple streams of
    data change over the entire set of measurements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacked diagrams basically come down to two different representations: stacked
    bar graphs and stacked area graphs. We will examine both of these and explain
    how to create these with D3.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stacked bar graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of a stacked bar graph is similar to that of a bar graph,
    except that we need to take into account the fact that the height of each bar
    consists of the sum of each measurement. Normally, each bar is subdivided, with
    each division sized relative to the sum, and is given a different color to differentiate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump into creating our own stacked bar graph. The data that will be used
    can be found at [https://goo.gl/6fJrxE](https://goo.gl/6fJrxE).
  prefs: []
  type: TYPE_NORMAL
- en: The following are the first few lines of the file. This data represents seven
    series of data, each series a specific range of age, broken down categorically
    by state. Each value represents the population for the given state in that age
    group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The online example is available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (10.1): [http://goo.gl/G3BIL7](http://goo.gl/G3BIL7)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting bar graph is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a stacked bar graph](img/B04230_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The data is loaded using `d3.csv()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the first object in the resulting data, we see the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a stacked bar graph](img/B04230_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This array has 51 elements, one for each state of the US and Washington D.C.
    This data needs to be converted into a structure that gives us information for
    rendering each bar and the rectangle for each series within each of the bars.
    To do this, we need to go through three steps, the last one culminating with the
    use of `d3.layout.stack()`.
  prefs: []
  type: TYPE_NORMAL
- en: First, the code extracts the unique keys for each series of data, which is the
    age groups. This can be retrieved by filtering out all properties of each object
    in the array where the property name is not equal to `State`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating a stacked bar graph](img/B04230_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using these keys, we can reorganize the data so that we have an array representing
    the values for each age group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `statesAndAges` variables now is a seven-element array, with each element
    being an array of objects representing the `x` and `y` values for each series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a stacked bar graph](img/B04230_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, using these keys, we create a `d3.layout.stack()` function and have it
    process this data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the stacking of this data is that the stack function will add
    an additional property, `y0`, to each object in each series. The value of `y0`
    will be the value of the sum of the `y` values in the previously lower-numbered
    series. To demonstrate, the following are the values of the objects in the first
    object of each array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a stacked bar graph](img/B04230_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The value of `y0` in the first object is `0`. The value of `y0` in the second
    is `310504`, which is equal to `y0` + `y` of the first object. The value of `y0`
    in the third object is `y0` + `y` of the second, or `862843`. This function has
    stacked the `y` values, with each `y` value being the value of `y` for the individual
    segment of the bar that will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data is now organized to render the bar graph. The next step is to create
    the main SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code next calculates the `x` and `y` scales to map the bars into the specified
    number of pixels. The `y` scale will have a domain that ranges from `0` to the
    maximum sum of `y0` and `y` within all the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The *x* scale is set up as an ordinal `rangeRoundBands`, one for each state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code then creates a group for each of the series, assigning to each the
    color that the rectangles within will be filled with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to render all the rectangles. The following performs this
    by creating `51` rectangles within each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That's it! You have drawn this graph using this data.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the stacked bar into a stacked area graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stacked area graphs give a different view of the data than a stacked bar does.
    To create a stacked area graph, we change the rendering of each series of data
    as a path. The path is defined using an area generator, which has the `y` values
    on the lower end and the sum of `y0 + y` on the upper end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the stacked area graph is available online at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (10.2): [http://goo.gl/PRw8wv](http://goo.gl/PRw8wv)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting output from this example is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying the stacked bar into a stacked area graph](img/B04230_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The change from the previous example is relatively small. The data is loaded
    and organized exactly the same. The scales and colors are also created the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference comes in the rendering of the visuals. Instead of groups of
    rectangles, we render a filled path for each series. The following creates these
    paths and assigns the color for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This has generated the path elements, but has not assigned the path''s `d`
    property yet to create the actual path data. That''s our next step, but we first
    need to create an area generator to convert our data to that which is needed for
    the path. This area generator needs to have three values specified, the `x` value,
    `y0` (which represents the bottom of the area), and `y1` (which is at the top
    of the area):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we select the paths we just created and bind to each the appropriate
    series, setting the `d` attribute of the corresponding path to the result of calling
    the area generator. Note that this calls the area generator for each series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Converting the area graph to an expanded area graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a variant of a stacked area graph known as an expanded area graph.
    An expanded area graph fills the entire area of the graph completely and can be
    used to easily visualize the relative percentage that each series represents at
    each point.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of graph is created from a stacked area graph by normalizing the
    data at each point across all series to 1.0\. The following example demonstrates
    how this is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (10.3): [http://goo.gl/g9BH4L](http://goo.gl/g9BH4L)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting graph is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting the area graph to an expanded area graph](img/B04230_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This visually gives us a good feel of how the relative size of each age group
    changes during the period. For the most part, the age groups have stayed at the
    same proportion, except for perhaps one state near the end of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a really easy thing to convert the stacked area graph to an expanded
    area graph. To accomplish this, we need to do two things. The first of these is
    to change how we stack the data. We change the stack operation to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The change here is to add a call to `.offset("expand")`. This informs D3.js
    to normalize the results to `[0, 1]` for each point. The default offset is `"zero",`
    which, as we have seen, starts *Y* values at `0` and does a running sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data is now ready, and the second change is to change the `Y` scale to
    the account for the domain as `[0, 1]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You now have your expanded area graph.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing hierarchical data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hierarchal layouts** display information that is hierarchical in nature.
    That is perhaps a slightly recursive definition, but the basic idea is that certain
    data items break down into zero or more data items at a lower level, and then
    perhaps to another level, and so on, for as many levels as is required.'
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical layouts are all created from the `d3.layout.hierarchy()` function,
    but there are specializations of this function that create various layouts which
    fall into common visual patterns such as trees, clusters, and enclosures and packs.
    We will take a look at an example of each of these types of layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Tree diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tree diagrams are essentially node-link diagrams. In [Chapter 9](ch09.html
    "Chapter 9. Complex Shapes Using Paths"), *Complex Shapes using Paths*, we saw
    the use of a path generator known as a diagonal. This generator was able to create
    curved line segments that can connect a node to one or more nodes. To refresh
    you, we had an example that generated the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagrams](img/B04230_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a basic node-link diagram. Tree diagrams utilize diagonals and apply
    them to many levels of hierarchy. The diagram can be structured as a tree or in
    other more complex layouts such as a radial cluster (which we will examine). The
    layouts will calculate the positions of the nodes and then we need to render the
    nodes and the attached diagonals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a simple tree diagram. The data is available at [https://goo.gl/mcdT9r](https://goo.gl/mcdT9r).
    The contents of the data are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (10.4): [http://goo.gl/t1hBTS](http://goo.gl/t1hBTS)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the rendering is the following tree diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagrams](img/B04230_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our example begins with loading the data, establishing metrics for the diagram,
    creating the main SVG element, and establishing a main group and margins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To convert the data into a visual representation of a tree, we will create a
    tree layout using the `d3.layout.tree()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This informs D3.js that we want to create a tree that will map its data into
    a rectangle specified by `height` and `width`. Notice that the `height` is specified
    before `width`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two visual components to the graph: the nodes, represented by circles,
    and the edges, which are diagonals. To calculate the nodes, we use the `.nodes()`
    function of the layout and pass it our data.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The tree function looks for a top-level node with a `children` property. It
    will traverse all the nodes in the hierarchy and determine its depth, which, in
    this case, has four levels. It will then add `x` and `y` properties to each node,
    where these represent the calculated position of the nodes based upon the layout
    and the specific `width` and `height`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the contents of the `nodes` variable, we can see that D3.js has given
    us the positions for each node (the following shows the first two nodes):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagrams](img/B04230_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the links in the tree, we call `tree.links(nodes)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the link that results in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagrams](img/B04230_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The newly created data structure consists of an element for each link, of which
    each object contains a `source` and `target` property that points to the node
    that is on each end of the link.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have our data ready for creating visuals. Next is the statement for
    creating the generator for the diagonals. We use the `.projection()` function,
    since we need to tell the generator how to find the `x` and `y` value from each
    datum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create the diagonals, reusing the generator for each. The diagonals
    are created before the nodes, because we want the nodes to be in front:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the code creates the circles and the labels. We will represent each node
    with a group containing a circle and a piece of text. The following creates these
    groups and places them at the calculated locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the circles as a child of each node''s group element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we add the text for the node label to the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The function, when assigning the `y` attribute, offsets the position of the
    text to be above the circle if the node is not a leaf and underneath the node
    if it is a leaf node.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cluster dendrogram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hierarchy can also be visualized as a variant of a tree known as a **cluster
    dendrogram**. A cluster dendrogram differs from a tree graph in that we use a
    cluster layout. This layout places the root of the tree at the center. The depth
    of the data is calculated, and that number of levels of concentric circles are
    fit into the diagram. The nodes for each level of depth are then placed around
    the edge of the circle for their respective depth.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we will utilize the data available at [https://goo.gl/t3M7n1](https://goo.gl/t3M7n1).
    This data represents three levels of data, with one root node and four nodes on
    the second level; each of those nodes has nine children.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (10.5): [http://goo.gl/cQtPuH](http://goo.gl/cQtPuH)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting graph is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a cluster dendrogram](img/B04230_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s step through how this is created. The code is similar to the tree example,
    but with some differences. After the data is loaded, the main SVG element is created,
    and then a group is placed within the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The layout algorithm will calculate the points around a center at (**0, 0**),
    so we center the group to center the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout is then created using `d3.layout.cluster()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The size specifies two things; the first parameter is the number of degrees
    that the points will sweep through on the outer circle. This specifies `360` degrees
    so that we completely fill the outer circle. The second parameter is the tree
    depth, or what is essentially the radius of the outermost circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the layout to calculate the position for the nodes and links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth examining the first few nodes that result from these calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a cluster dendrogram](img/B04230_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `x` and `y` properties specify a direction and distance at which the node
    (and edges) is to be placed. The `x` property specifies the angle from vertical,
    and the value of the `y` property specifies the distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagonals are calculated using a radial diagonal, which needs to convert
    the `x` values into radians:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use this radial generator diagonal that connects the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a group to hold the node and the text. The trick to this is
    that we need to translate and rotate the group into the correct position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We rotate the group by `90` degrees from the calculated angle. This changes
    the orientation of the the text to flow out from the circle, along the diagonals.
    Note that rotate works in degrees, not radians, as was required for the radial
    generator. The translate uses just the `y` value, which moves the group out that
    distance along the specified angle. Now we add the circles to the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we add the text. Note the small calculation around the text being
    at an angle greater or less than 180 degrees. This essentially says that nodes
    on the left-half of the diagram are positioned with the end of the text against
    the node and on the right side, start at the beginning of the text. The text is
    also transformed by twice the circle radius to prevent it from overlapping the
    circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Representing hierarchy with an enclosure diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enclosure diagrams use nesting of visuals to represent the hierarchy. The size
    of each leaf node's circle reveals a quantitative dimension of each data point.
    The enclosing circles show the approximate cumulative size of each subtree, but
    note that because of wasted space, there is some distortion between levels. Therefore,
    only the leaf nodes can be compared accurately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the location of the online example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (10.6): [http://goo.gl/MQ3CwG](http://goo.gl/MQ3CwG)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image is the resulting visual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Representing hierarchy with an enclosure diagram](img/B04230_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The data used by the example is available at [https://goo.gl/RzvlV3](https://goo.gl/RzvlV3).
    It is similar in structure to the data in the previous example, except that a
    `value` property is added to each node. The values of the leaf nodes are summed
    in their parents, repeating all the way to the top.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, this data is a rollup of the values, much like what would be performed
    when rolling up sales numbers from sales persons, to offices, to divisions, to
    the corporate level. The diagram then allows us to see relative sizes of the numbers
    in the leaf nodes, which are colored orange, and then get an idea of the total
    at each level up the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s examine how this is created. The example begins with loading of
    the data and then creating an SVG element of a specified diameter. Then, a pack
    layout is created that is also used the diameter. The hierarchical bubbles that
    are created will be measured to fit within the specified diameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we render the circles. For each node, we append a group that is translated
    to the appropriate position and then a circle is appended with its radius set
    to the calculated radius `(d.r),` the `fill`, `fill-opacity`, and the `stroke`
    to different values depending on whether the node is a leaf or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to add the text to the leaf circles (the ones without children,
    as specified using the filter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Representing relationships with chord diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chord diagrams demonstrate the relationships among a group of entities. To
    demonstrate, we will use the example available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (10.7): [http://goo.gl/8mRDSg](http://goo.gl/8mRDSg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting diagram is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Representing relationships with chord diagrams](img/B04230_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The data in this example is a square matrix of data, with rows and columns
    representing hair color (black, blonde, brown, and red). The data represents a
    total sample of **100000** measurements, where each row demonstrates the total
    count of the other hair colors which a person of a given hair color prefers:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | ***Prefers*** |'
  prefs: []
  type: TYPE_TB
- en: '| ***Has*** | **Black** | **Blonde** | **Brown** | **Red** | **Total** |'
  prefs: []
  type: TYPE_TB
- en: '| **Black** | 11975 | 5871 | 8916 | 2868 | 29630 |'
  prefs: []
  type: TYPE_TB
- en: '| **Blonde** | 1951 | 10048 | 2060 | 6171 | 20230 |'
  prefs: []
  type: TYPE_TB
- en: '| **Brown** | 8010 | 16145 | 8090 | 8045 | 40290 |'
  prefs: []
  type: TYPE_TB
- en: '| **Red** | 1013 | 990 | 940 | 6907 | 9850 |'
  prefs: []
  type: TYPE_TB
- en: '| **Total** | 22949 | 30354 | 20006 | 23991 | 10000 |'
  prefs: []
  type: TYPE_TB
- en: To explain the diagram, each outer ring segment represents the number of people
    that have a given hair color. The size of these ring segments is relative to the
    percentage of people of a given hair color. Each arc from a given color ring segment
    to another ring segment (or itself) represents the number of people of that hair
    color that prefer the hair color on the other side of that arc and vice versa.
    The ticks on the outside of each ring segment gives a feel for the total number
    of the people represented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s step through creating this graph. First, we create our top-level
    SVG elements. The main group is translated to the center, as the positions will
    be centered around (**0, 0**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s declare the data. We will use a hard-coded array instead of reading
    from a file. These values represent the values from the previous table, exclusive
    of the totals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We then use the `d3.layout.chord()` function to create the layout object for
    this graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`.padding(0.05)` states that there will be `0.05` radians of space between
    the sections on the outside of the diagram, and the call to `.matrix()` specifies
    the data to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code creates the colors that will be utilized (black,
    blondish, brownish, and reddish):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the ring segments are rendered. The inner and outer radius of the ring
    segments is calculated as percentages of the smallest dimension of the visual.
    The data that is bound is the group''s property of the layout object. For each
    of these, we render a path using an arc generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the chords are rendered. A `d3.svg.chord()` function will be applied
    to each datum, and a path of the size `innerRadius` is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have created the entire chord graph sans ticks and labels.
    We will omit covering those in the book, but feel free to check out the sample
    code with the text to see how this is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques to demonstrate the flow of information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last two layouts and corresponding visualizations that we will examine help
    the viewer to understand how data changes as it flows over time or through intermediate
    points.
  prefs: []
  type: TYPE_NORMAL
- en: Using streamgraphs to show changes in values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **streamgraph** demonstrates the change in values in a multiple series of
    data as a flowing stream of data. The height of each stream represents the value
    of that stream at that moment in time.
  prefs: []
  type: TYPE_NORMAL
- en: They are useful for demonstrating where certain categories start or stop at
    different points along the graph. Common examples are data such as box-office
    receipts or the number of listeners for various artists on streaming media as
    they change over time.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate a streamgraph, we will use the data available at [https://goo.gl/HTL4HG](https://goo.gl/HTL4HG).
  prefs: []
  type: TYPE_NORMAL
- en: 'This data consists of four series of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The online example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (10.8): [http://goo.gl/LMd3F3](http://goo.gl/LMd3F3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the resulting streamgraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using streamgraphs to show changes in values](img/B04230_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This graph allows us to see how each individual series of data is related to
    each other at each point of measurement. It is, in a way, like a stacked area
    chart, but instead of each being fixed at a common baseline, the bottom of the
    graph is also allowed to vary in location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example begins by loading the data and setting up the main SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to massage the data a little bit, as the call to the layout function
    will expect it in the same format as an area graph, which is an array of arrays
    of objects with `x` and `y` properties. The following code creates this, using
    the position of the value in each array as the `x` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the code creates the axes, with the *X* axis being a linear axis representing
    the number of points in each series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The layout is the familiar stack layout that was used in the area graph example,
    but we chain a call to `.offset(''wiggle'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The remainder of the code continues just as an area graph, using an area path
    generator and similarly scaled *Y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Representing flows through multiple nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of showing a continuous flow like a streamgraph, a **Sankey** diagram
    emphasizes how the flow quantity changes proportionally. This is somewhat like
    a chord diagram, but a Sankey has the ability to visualize more complex flows
    than just between two items.
  prefs: []
  type: TYPE_NORMAL
- en: In a Sankey diagram, the width of the lines between the nodes represents the
    volume of the flow between two nodes. Normally, flows start at one or more nodes
    on the left, flow through intermediates, and then terminate at nodes on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example diagram uses the data available at [https://goo.gl/lgQZBz](https://goo.gl/lgQZBz).
    This data consists of declarations for eight nodes and then the links between
    the nodes along with the amount of the flow between the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The online example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (10.9): [http://goo.gl/exZkI4](http://goo.gl/exZkI4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting Sankey diagram from this data will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Representing flows through multiple nodes](img/B04230_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Sankey layout is considered a plugin to D3.js. It is not in the base library,
    so you need to retrieve the code, and make sure to reference it in your app. This
    code is available at [https://github.com/d3/d3-plugins/tree/master/sankey](https://github.com/d3/d3-plugins/tree/master/sankey),
    or you can grab it from the book's example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example begins by loading the data and creating the main SVG elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the layout using the plugin as follows. There are lot of parameters
    here to specify the size of the nodes, the padding, overall size of the diagram,
    where to get the links and nodes in your data, and layout specifying the number
    of iterations to be processed for positioning the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The flow paths (links) are rendered by creating paths representing flows. The
    structure of the path is provided by referencing the `sankey.link()`, which is
    a function that creates the path data for the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create a group to hold the nodes and place them into position based
    on the `x` and `y` properties provided by the layout. The `.node` style is used
    simply to differentiate the selection of these groups from those of the paths
    (which used `.link`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we insert a colored rectangle into the groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We also include text to describe the node, with some logic to position the
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter. The overall focus was on creating complex
    graphs that utilize D3.js layout objects. These included a multitude of graphs
    in different categories including stacked, packed, clustered, flow-based, hierarchical,
    and radial.
  prefs: []
  type: TYPE_NORMAL
- en: One of the beauties of D3.js is the ease at which it allows you to create these
    complex visuals. They are pattern-oriented such that the code for each is often
    very similar, with just a slight change of layout objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will look at a specific type of graph in detail: the
    network diagram. These extend upon several concepts we have seen in this chapter,
    such as flow and hierarchy, to allow us to visualize very complex network data
    such as those found in social networks.'
  prefs: []
  type: TYPE_NORMAL
