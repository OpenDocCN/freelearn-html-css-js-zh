- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: What Do You Need Before Getting Started?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始之前您需要什么？
- en: The microservice approach does not inherently depend on any specific programming
    language. You can implement it using different programming languages. The concept
    of microservices supports using different languages for different services within
    a single application. This means the choice of programming language for each service
    can be based on its specific needs and functionalities. For example, you’re able
    to implement *microservice A* using C# but *microservice B* using JavaScript.
    That is the beauty of microservice development, which allows us to bypass programming
    language barriers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务方法本身并不依赖于任何特定的编程语言。您可以使用不同的编程语言来实现它。微服务概念支持在单个应用程序中使用不同的语言来构建不同的服务。这意味着每个服务的编程语言选择可以基于其特定的需求和功能。例如，您可以使用C#实现*microservice
    A*，但*microservice B*使用JavaScript。这就是微服务开发的美丽之处，它允许我们绕过编程语言障碍。
- en: This book is about writing microservices in JavaScript. As in any programming
    language, before implementing the microservice approach, it is best to understand
    the basics of the given language, which will help us to build better and more
    effective microservices. The focus of this chapter is to provide the foundation,
    rather than a comprehensive guide, for the language, along with Node.js. There
    are a few topics, especially in JavaScript, that need to be reviewed before implementing
    any microservice applications using the language itself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是关于用JavaScript编写微服务的。与任何编程语言一样，在实施微服务方法之前，最好先了解该语言的基本知识，这将帮助我们构建更好、更有效的微服务。本章的重点是提供基础，而不是全面的指南，包括Node.js。在实施任何使用该语言的微服务应用程序之前，有一些主题，尤其是在JavaScript中，需要先进行回顾。
- en: 'In this chapter, we’re going to explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: JavaScript essentials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 基础知识
- en: Node.js essentials
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 基础知识
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要以下内容：
- en: A browser (select your favorite one)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器（选择您喜欢的）
- en: 'Visual Studio Code (or you can use your OS’s default text editor): Simply go
    to [https://code.visualstudio.com/](https://code.visualstudio.com/) and install
    it'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code（或者您可以使用操作系统默认的文本编辑器）：只需访问[https://code.visualstudio.com/](https://code.visualstudio.com/)并安装它
- en: '**GitHub**: Go to [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub**：访问[https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03)'
- en: The next chapter will explain the required software installation processes in
    detail. For now, you can download the GitHub repository source code without using
    any GitHub commands and experiment with it.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一章将详细解释所需的软件安装过程。目前，您可以在不使用任何GitHub命令的情况下下载GitHub仓库源代码，并对其进行实验。
- en: JavaScript essentials
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 基础知识
- en: 'JavaScript is a popular, single-threaded, synchronous programming language
    that helps us mostly to build interactive web applications. Its strength is its
    ability to mix different programming methods. This mix lets you write code in
    several ways: focusing on objects, using functions like building blocks, reacting
    to events, or giving step-by-step instructions, making your code clear and easier
    to handle. The JavaScript you use in the browser or in Node.js is not completely
    *native*. That is why we need to differentiate between the concepts of the *JavaScript
    engine* and the *JavaScript runtime*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种流行的、单线程的、同步的编程语言，它主要帮助我们构建交互式Web应用程序。其优势在于能够混合不同的编程方法。这种混合让您可以用多种方式编写代码：关注对象、使用函数作为构建块、对事件做出反应，或提供逐步指令，使您的代码更加清晰且易于处理。在浏览器或Node.js中使用的JavaScript并非完全*原生*。这就是为什么我们需要区分*JavaScript
    引擎*和*JavaScript 运行时*的概念。
- en: JavaScript engine
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 引擎
- en: A JavaScript engine is a special type of program that reads, parses, and translates
    our JavaScript code into computer-understandable language (machine instructions)
    – see *Figure 3**.1*. We don’t have one single JavaScript engine for all browsers.
    For instance, Google Chrome, Opera, and the latest Microsoft Edge browsers use
    the *V8 engine*, Firefox has *SpiderMonkey*, and Safari uses the *JavascriptCore
    engine*. Anyone with the ability to follow ECMAScript engine standards can create
    their own JavaScript engine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 引擎是一种特殊的程序，它读取、解析和将我们的 JavaScript 代码翻译成计算机可理解的语言（机器指令）——见 *图 3.1*。我们并不是所有浏览器都只有一个
    JavaScript 引擎。例如，Google Chrome、Opera 和最新的 Microsoft Edge 浏览器使用 *V8 引擎*，Firefox
    使用 *SpiderMonkey*，Safari 使用 *JavascriptCore 引擎*。任何有能力遵循 ECMAScript 引擎标准的人都可以创建自己的
    JavaScript 引擎。
- en: But how can we have compatible JavaScript across the browsers? How do we make
    sure that the JavaScript code will work for all browsers? That is why we need
    a standard that will tell us exactly what we need to do to make sure that JavaScript
    will work for all browsers. Thankfully, we have a combination of rules that allows
    us to ensure consistency across different web browsers. This essential rulebook
    for scripting is called **ECMAScript** (**ES**). Of course, ES isn’t just for
    JavaScript; it applies to other scripting languages as well, but JavaScript is
    the most well-known implementation of it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何确保在所有浏览器中具有兼容的 JavaScript 呢？我们如何确保 JavaScript 代码能在所有浏览器中运行？这就是为什么我们需要一个标准，它将确切地告诉我们需要做什么来确保
    JavaScript 在所有浏览器中都能运行。幸运的是，我们有一套规则组合，可以确保在不同浏览器之间的一致性。这本脚本必备的规则手册被称为 **ECMAScript**
    （**ES**）。当然，ES 不仅适用于 JavaScript；它也适用于其他脚本语言，但 JavaScript 是其最著名的实现。
- en: '![Figure 3.1: JavaScript translation process](img/B09148_03_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：JavaScript 翻译过程](img/B09148_03_1.jpg)'
- en: 'Figure 3.1: JavaScript translation process'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：JavaScript 翻译过程
- en: Let’s look at the JavaScript engine in depth in the next few subsections.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几个小节中深入探讨 JavaScript 引擎。
- en: Call stack and memory heap
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用栈和内存堆
- en: JavaScript engine consists of multiple elements, and two of them are the **call
    stack** and the **memory heap** (*Figure 3**.2*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 引擎由多个元素组成，其中两个是 **调用栈** 和 **内存堆** （*图 3.2*）。
- en: '![Figure 3.2: Call stack and memory heap](img/B09148_03_2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：调用栈和内存堆](img/B09148_03_2.jpg)'
- en: 'Figure 3.2: Call stack and memory heap'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：调用栈和内存堆
- en: When we run our JavaScript application, code is executed in the call stack.
    Think of it as a series of steps that your code can walk through in a given order.
    On the other hand, the heap is about data storage. It is unstructured memory that
    stores the objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的 JavaScript 应用程序时，代码是在调用栈中执行的。把它想象成代码可以按给定顺序遍历的一系列步骤。另一方面，堆是关于数据存储的。它是无结构的内存，用于存储对象。
- en: JavaScript translation process
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 翻译过程
- en: The **translator** is a program that can translate human-readable source code
    into machine-readable instructions. It has two main parts. The first part is the
    **compiler**. In the compilation process, the program converts the entire code
    into machine code at once. The second part is the **interpreter**. In the interpretation
    process, the interpreter goes through the source code and runs it line by line,
    converting it into machine instructions. Several years ago, JavaScript used to
    be a purely interpreted language, but fortunately, some modern JavaScript engines
    work in a hybrid mode of translation. Modern JavaScript engines use a combination
    of interpretation and JIT compilation, where the interpreter runs code line by
    line, while the compiler converts frequently used code to machine code to optimize
    performance. The V8 engine, for instance, combines the compiler and interpreter,
    which is called the **Just-in-Time** (**JIT**) compilation process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**翻译器** 是一个可以将人类可读的源代码翻译成机器可读指令的程序。它有两个主要部分。第一部分是 **编译器**。在编译过程中，程序将整个代码一次性转换成机器代码。第二部分是
    **解释器**。在解释过程中，解释器遍历源代码并逐行执行，将其转换成机器指令。几年前，JavaScript 一直是一种纯解释语言，但幸运的是，一些现代 JavaScript
    引擎以混合模式进行翻译。现代 JavaScript 引擎结合了解释和 JIT 编译，其中解释器逐行运行代码，而编译器将频繁使用的代码转换成机器代码以优化性能。例如，V8
    引擎结合了编译器和解释器，这被称为 **即时** （**JIT**） 编译过程。'
- en: Interpreters are fast in terms of getting up and running. There is no need to
    convert the source into another language, which means there is no compilation
    step. For options such as executing something right away, interpreters are a better
    option than compilers. The major problem here is that if you run the same code
    (say, the same JavaScript function) again and again, it can get really slow. Interpreters
    don’t apply any optimization to your code. That is when the compiler comes in.
    It takes a bit more time than interpreters because it converts your code into
    another language, but it is smart, and when it sees the same code again, it just
    optimizes it in order to not interpret it again.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器在启动和运行方面速度很快。无需将源代码转换为另一种语言，这意味着没有编译步骤。对于立即执行等选项，解释器比编译器更合适。这里的主要问题是，如果你反复运行相同的代码（比如，相同的JavaScript函数），它可能会变得非常慢。解释器不会对你的代码进行任何优化。这时编译器就派上用场了。它比解释器花费更多的时间，因为它将你的代码转换为另一种语言，但它很聪明，当它再次看到相同的代码时，它会优化它以避免再次解释。
- en: In terms of translation, JavaScript uses the advantages of interpreter and compiler
    together.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在翻译方面，JavaScript结合了解释器和编译器的优势。
- en: A classical compilation means that the machine code is stored in a portable
    file and can be executed at any time, but for the JIT compiler, it is a bit different.
    The machine code should be executed as soon as possible before compilation ends.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的编译意味着机器代码存储在一个可移植的文件中，并且可以随时执行，但对于即时编译器（JIT compiler）来说，情况略有不同。机器代码应该在编译结束时尽快执行。
- en: Let’s try to understand how JavaScript-specific JIT works over Google’s V8 engine.
    As a JavaScript runtime, Node.js also relies on the V8 engine, and understanding
    its internals will help us a lot from the Node.js perspective.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解在Google的V8引擎上如何工作JavaScript特定的JIT。作为一个JavaScript运行时，Node.js也依赖于V8引擎，理解其内部结构将极大地帮助我们从Node.js的角度来看。
- en: When you execute your source code written in JavaScript, the JavaScript engine
    parses it. The *parser* is a sub-element of the JavaScript engine that takes your
    source code and outputs tokens. That is how the JavaScript engine understands
    whether there is an error. It acts as a **lexical analyzer** and the final output
    is called an **Abstract Syntax Tree** (**AST**). To witness the beauty of the
    AST, you can just navigate to the AST explorer ([https://astexplorer.net/](https://astexplorer.net/)),
    type any JavaScript code, and see the parsing process.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行用JavaScript编写的源代码时，JavaScript引擎会解析它。*解析器*是JavaScript引擎的一个子元素，它接收你的源代码并输出标记。这就是JavaScript引擎理解是否存在错误的方式。它充当**词法分析器**，最终输出称为**抽象语法树**（**AST**）。要见证AST的美丽，你只需导航到AST浏览器([https://astexplorer.net/](https://astexplorer.net/))，输入任何JavaScript代码，并查看解析过程。
- en: An AST is an engine-specific data structure that is generated by splitting up
    each line of your JavaScript code into pieces that are understandable to the language.
    The engine uses it to generate machine code. The AST is then taken by the *interpreter*
    and converted to byte code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: AST是引擎特定的数据结构，它通过将你的JavaScript代码的每一行分解成语言可理解的部分来生成。引擎使用它来生成机器代码。然后AST被*解释器*接收并转换为字节码。
- en: '**Byte code** is a special type of collection of instructions that is approximately
    similar to machine code but acts as a wrapper and abstracts us from the complexities
    of the machine code. The default interpreter in V8, called **Ignition**, outputs
    byte code; on the other hand, the compiler, **Turbofan**, optimizes this bytecode
    into efficient machine code'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**字节码**是一组特殊的指令集合，其与机器代码大致相似，但作为包装器并抽象化我们免受机器代码复杂性的影响。V8的默认解释器称为**Ignition**，输出字节码；另一方面，编译器**Turbofan**将此字节码优化为高效的机器代码'
- en: Turbofan also acts as a JIT compiler. In the middle of the interpreter and compiler,
    there is a *profiler* that profiles the interpretation process (Ignition) and
    forwards the code that needs to be optimized to the compiler (Turbofan). (See
    *Figure 3**.3*.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Turbofan也充当即时编译器。在解释器和编译器之间，有一个*分析器*，它分析解释过程（Ignition）并将需要优化的代码转发给编译器（Turbofan）。（见*图3**.3*.）
- en: '![Figure 3.3: JavaScript engine internals](img/B09148_03_3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：JavaScript引擎内部结构](img/B09148_03_3.jpg)'
- en: 'Figure 3.3: JavaScript engine internals'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：JavaScript引擎内部结构
- en: Okay, but you might be asking yourself why we need to understand under-the-hood
    operations in the JavaScript engine. Well, that actually will help you to write
    better, faster code with optimized microservices. That knowledge will help you
    to write optimization-friendly code. The JavaScript engine is not always able
    to apply optimization and, in some cases, it depends on your writing style. It
    is possible to write deoptimization code that might be difficult for your JavaScript
    engine to optimize. That is why it is better to always understand the internals.
    For instance, using the `delete`, `evals`, `arguments`, and `with` keywords and
    mechanisms such as *hidden classes* and *inline caching* may slow down code optimization.
    These concepts are beyond our book, but you can learn about them by checking the
    open source JavaScript tutorials and documentation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但你可能想知道为什么我们需要理解 JavaScript 引擎底层的操作。实际上，这实际上会帮助你编写更好、更快的代码，并使用优化的微服务。这种知识将帮助你编写优化友好的代码。JavaScript
    引擎并不总是能够应用优化，在某些情况下，它取决于你的编写风格。你可能会编写一些可能难以优化你的 JavaScript 引擎的代码。这就是为什么始终理解内部结构是更好的选择。例如，使用
    `delete`、`evals`、`arguments` 和 `with` 关键字以及诸如 *hidden classes* 和 *inline caching*
    这样的机制可能会减慢代码优化。这些概念超出了我们这本书的范围，但你可以通过查看开源 JavaScript 教程和文档来了解它们。
- en: The next thing we need to talk about is the single-threaded nature of JavaScript,
    and believe me, things get interesting when we dive into the threading details.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要讨论的是 JavaScript 的单线程特性，相信我，当我们深入研究线程细节时，事情会变得很有趣。
- en: Threading in JavaScript
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript中的线程
- en: As we mentioned before, JavaScript is a single-threaded, blocking, synchronous
    programming language that has only one call stack. JavaScript is "single-threaded,"
    but it's not necessarily "blocking." It is synchronous by default but can handle
    asynchronous code execution using callbacks, promises, and async/await. But what
    does this mean and why do we need to understand it? Well, most programming languages
    support multithreading out of the box. This means it is possible to run multiple
    independent operations at a given time. But when it comes to JavaScript, things
    are a bit different. It is possible to run only one set of instructions at a given
    time for JavaScript natively, and this is a big problem in the world of multithreading,
    especially for long-running tasks. Fortunately, when you deal with JavaScript,
    you’re not dealing with only a JavaScript engine but also something called a **JavaScript
    runtime**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，JavaScript 是一种单线程、阻塞、同步的编程语言，它只有一个调用栈。JavaScript 是“单线程”的，但并不一定是“阻塞”的。它默认是同步的，但可以使用回调、承诺和
    async/await 来处理异步代码执行。但这究竟意味着什么，为什么我们需要理解它呢？好吧，大多数编程语言都默认支持多线程。这意味着在给定时间内可以运行多个独立的操作。但是，当涉及到
    JavaScript 时，事情就有些不同了。对于 JavaScript 来说，在给定时间内只能运行一组指令，这在多线程的世界中是一个大问题，尤其是对于长时间运行的任务。幸运的是，当你处理
    JavaScript 时，你不仅处理 JavaScript 引擎，还处理一个叫做**JavaScript 运行时**的东西。
- en: JavaScript runtime
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 运行时
- en: 'The browser, by its nature, is a wrapper and a runtime for the JavaScript engine.
    The responsibility of the runtime is to provide *additional* support to implement
    all the required functionalities for the given context. Here, in browsers, the
    context is a web-based interactive application. Node.js is also a runtime based
    on Google’s V8 engine. Engines help you to extend native JavaScript engine functionalities
    even more and add an async nature to them. These functionalities together in the
    browser are called **web APIs**. To see browser-based, important web APIs, just
    do the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器本质上是一个 JavaScript 引擎的包装器和运行时。运行时的责任是为给定上下文提供**额外**的支持，以实现所有必需的功能。在这里，在浏览器中，上下文是基于网络的交互式应用程序。Node.js
    也是一个基于谷歌 V8 引擎的运行时。引擎可以帮助你扩展原生 JavaScript 引擎的功能，并给它们添加异步特性。这些功能在浏览器中统称为**Web API**。要查看基于浏览器的、重要的
    Web API，请按照以下步骤操作：
- en: Open your favorite browser (in our case, it is Google Chrome).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的浏览器（在我们的例子中，是谷歌Chrome）。
- en: Right-click and select **Inspect**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击并选择**检查**。
- en: Go to the `window`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `window`。
- en: Hit *Enter*.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Enter*。
- en: 'You can also see this in *Figure 3**.4*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在*图 3.4*中看到这一点：
- en: '![Figure 3.4: window global object](img/B09148_03_4.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4：窗口全局对象](img/B09148_03_4.jpg)'
- en: 'Figure 3.4: window global object'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：窗口全局对象
- en: The elements of the `window` object (its properties and methods) that you can
    see are in addition to your JavaScript engine, which is built into the browser
    you use. Browsers have web APIs that are approximately similar for all of them.
    Most core web APIs are designed to be standardized so that websites can function
    similarly across different browsers. However, there can be minor differences in
    implementation or features between browsers, and some APIs might be specific to
    a particular browser. Most popular API functions, such as `fetch`, `settimeout`,
    `setinterval`, and `document`, are part of this huge API called `window`. It means
    they are not native JavaScript functions but engine-based functions for us in
    the given context. Web APIs decorate our JavaScript code with async behaviors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到的 `window` 对象的元素（其属性和方法）除了你的 JavaScript 引擎外，还内置在你使用的浏览器中。浏览器具有适用于所有浏览器的近似相似的
    Web API。大多数核心 Web API 都被设计为标准化，以便网站可以在不同的浏览器中以类似的方式运行。然而，在实现或功能方面，浏览器之间可能存在细微的差异，并且某些
    API 可能仅针对特定浏览器。大多数流行的 API 函数，如 `fetch`、`setTimeout`、`setInterval` 和 `document`，都是这个称为
    `window` 的大 API 的一部分。这意味着它们不是原生 JavaScript 函数，而是在给定上下文中为我们提供的基于引擎的函数。Web API 为我们的
    JavaScript 代码添加了异步行为。
- en: When you write code that has these functions (`fetch`, `document`, etc.), the
    JavaScript engine will forward them to the web APIs. Web APIs are written in low-level
    languages (in most cases in C/C++) and after execution, your callback, which is
    provided in the given instruction, will be added to the *callback queue*. All
    native JavaScript functions will be executed directly in the call stack, but non-native
    instructions need to be executed first in the web API and the result of the execution,
    as a callback, will be added to the callback queue (*Figure 3**.5*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写具有这些功能（`fetch`、`document`等）的代码时，JavaScript 引擎会将它们转发到 Web API。Web API 使用低级语言编写（在大多数情况下是
    C/C++），执行后，你提供的回调，即给定指令中提供的回调，将被添加到**回调队列**中。所有原生 JavaScript 函数都将直接在调用栈中执行，但非原生指令需要首先在
    Web API 中执行，执行的结果，作为一个回调，将被添加到回调队列（**图 3.5**.5）。
- en: There is also the *event loop*. The responsibility of the event loop is just
    to check the call stack and to push callback queue elements there only if it is
    empty.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有**事件循环**。事件循环的职责仅仅是检查调用栈，并且只有在调用栈为空时才将回调队列元素推入其中。
- en: 'To make sure all the terms we mentioned are understood well, let’s consider
    a simple example. Look at *Figure 3**.5*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们提到的所有术语都得到很好的理解，让我们考虑一个简单的例子。看看**图 3.5**：
- en: '![Figure 3.5: JavaScript event loop with a callback queue](img/B09148_03_5.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5: 带有回调队列的 JavaScript 事件循环](img/B09148_03_5.jpg)'
- en: 'Figure 3.5: JavaScript event loop with a callback queue'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3.5: 带有回调队列的 JavaScript 事件循环'
- en: 'Open your favorite web browser, right-click on the page, select `event_loop.js`
    in the `Ch03``/js` folder of the book’s GitHub repository:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你喜欢的网络浏览器，在页面右键单击，选择书籍 GitHub 存储库中的 `Ch03/js` 文件夹中的 `event_loop.js`：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here in our code, you might expect to see `setTimeout`’s message first and then
    other messages in the given order. Because we have specified `0` for `setTimeout`,
    it should immediately execute our code. But the output is different, as we can
    see in *Figure 3**.6*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，你可能会期望首先看到 `setTimeout` 的消息，然后按照给定的顺序看到其他消息。因为我们已经将 `setTimeout` 的值指定为
    `0`，它应该立即执行我们的代码。但输出是不同的，正如我们在**图 3.6**中看到的那样。
- en: '![Figure 3.6: The call stack executes a queue item at the end](img/B09148_03_6.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6: 调用栈在最后执行队列项](img/B09148_03_6.jpg)'
- en: 'Figure 3.6: The call stack executes a queue item at the end'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3.6: 调用栈在最后执行队列项'
- en: As you might guess, if the executed function is non-native, which means it is
    a web-API-based function, then the JavaScript engine will forward it to the web
    API, and after execution, its callback will be added to the callback queue. Meanwhile,
    `setTimeout` is going to be a non-blocking, asynchronous operation, and that is
    why we see the result of `print` functions first.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，如果执行的函数是非原生的，这意味着它是一个基于 Web API 的函数，那么 JavaScript 引擎会将它转发到 Web API，并在执行后，将其回调添加到回调队列中。同时，`setTimeout`
    将是一个非阻塞的异步操作，这就是为什么我们首先看到 `print` 函数的结果。
- en: So, it doesn’t matter if you have set `0` or more as the second argument to
    `setTimeout`; it goes through the pipeline we explained anyway. The event loop
    will check whether the call stack is empty and when both `print` functions are
    done, it does become empty, so we’re able to see the result of `setTimeout` only
    after the event loop pushes it to the call stack.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论你将`setTimeout`的第二个参数设置为`0`还是更多，它都会通过我们解释的管道。事件循环将检查调用栈是否为空，当两个`print`函数都完成后，调用栈确实变为空，因此我们只能在事件循环将其推入调用栈后才能看到`setTimeout`的结果。
- en: Now let’s talk about the asynchronous nature of JavaScript in more detail.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地谈谈JavaScript的异步特性。
- en: Callback-based asynchronous JavaScript
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于回调的异步JavaScript
- en: '`setTimeout` or `setInterval`, you usually rely on callbacks.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout`或`setInterval`，你通常依赖于回调。'
- en: Callbacks are indispensable, but sometimes their usage makes your code less
    understandable and less maintainable, especially from an asynchronous code perspective.
    To prove that, go to `callback_hell.html` and run it in any browser. (You can
    find `callback_hell.html` in the `Ch03` folder of the book’s GitHub repository.
    For the sake of simplicity, all the GitHub repository references will contain
    only the path, i.e., `Ch03``/callback_hell.html`.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是必不可少的，但有时它们的用法会使你的代码更难以理解，更难以维护，尤其是在异步代码方面。为了证明这一点，请访问`callback_hell.html`并在任何浏览器中运行它。（你可以在书籍GitHub仓库的`Ch03`文件夹中找到`callback_hell.html`。为了简化，所有GitHub仓库引用将只包含路径，即`Ch03``/callback_hell.html`。）
- en: The file contains callback-based multiple asynchronous actions that we call
    *callback hell*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含基于回调的多个异步操作，我们称之为*回调地狱*。
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is what this script does:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个脚本做了什么：
- en: Dynamically adds the provided script to the head of the HTML file.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态地将提供的脚本添加到HTML文件的头部。
- en: Runs a function that belongs to that script (in our case, it is an `execute`
    function).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行属于该脚本的功能（在我们的例子中，它是一个`execute`函数）。
- en: Runs the `operation completed successfully` message after `three` seconds.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在三秒后运行`操作完成成功`的消息。
- en: '`Three` seconds after the preceding message runs, it outputs the `ready for
    another execution` message to the console. If the loaded file doesn’t exist, then
    the error message will be printed as an output.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一条消息运行三秒后，它将`准备进行另一次执行`的消息输出到控制台。如果加载的文件不存在，则错误消息将被打印为输出。
- en: As you can see, the code is hard to read, understand, and maintain this code
    due to its nesting. In software development, *maintaining* refers to the ongoing
    process of keeping software functioning properly, secure, and up to date. It might
    be more complex if you have more operations to do.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码难以阅读、理解和维护，这主要是因为它的嵌套。在软件开发中，*维护*指的是保持软件正常、安全并更新到最新状态的持续过程。如果你有更多操作要做，可能会更复杂。
- en: The way to promises
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺的方式
- en: While callbacks are still a main part of JavaScript, promises are the preferred
    way to handle asynchronous operations in modern JavaScript development due to
    the benefits they offer in readability, error handling, and code maintainability.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然回调仍然是JavaScript的主要部分，但由于它们在可读性、错误处理和代码可维护性方面提供的优势，承诺（promises）是现代JavaScript开发中处理异步操作的首选方式。
- en: '**Promises** were added in JavaScript with the **ECMAScript 6** (**ES6**) specification,
    which was released in 2015\. Before ES6, callback hell was a common way to handle
    asynchronous operations in JavaScript. Thanks to promises, now we have a clean
    and more manageable approach for asynchronous programming. We actively use promises
    in Node.js development, so it is crucial to understand and properly use them.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**承诺**（Promises）是在2015年发布的**ECMAScript 6**（**ES6**）规范中添加到JavaScript中的，这使得在JavaScript中处理异步操作从回调地狱中解脱出来，现在我们有了异步编程的干净且更易于管理的途径。我们在Node.js开发中积极使用承诺，因此理解和正确使用它们至关重要。'
- en: 'To create a promise, we use a `Promise` object. It has a single callback argument,
    which is called `executor`. It runs automatically when the promise is constructed
    successfully. The executor consists of two callbacks:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个承诺（promise），我们使用一个`Promise`对象。它有一个单一的回调参数，称为`executor`。当承诺（promise）成功构建时，它会自动运行。`executor`由两个回调组成：
- en: '`resolve`: We use this to inform a user about a successful operation'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolve`: 我们使用这个来通知用户操作成功'
- en: '`reject`: We use this to indicate that something went wrong'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reject`: 我们使用这个来表示出了问题'
- en: When a promise is done, it should call one of the functions, either `resolve`
    (value) or `reject` (error).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当承诺（promise）完成时，它应该调用其中一个函数，要么是`resolve`（值）要么是`reject`（错误）。
- en: The promise is initially in a `pending` state. It will be moved to a `fulfilled`
    state if `resolve` happens; otherwise (if rejected), the state will be moved to
    `rejected`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The promise’s result is initially `undefined`. It will store `value` if `resolve`
    is executed; otherwise (if rejected), it will store `error`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Promise state and result](img/B09148_03_7.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Promise state and result'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: It is completely okay to use only `resolve` or `reject` for `executor` if you
    want to provide only one path for your execution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to implement the callback example in *Figure 3**.7* using promises.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `Ch03``/js/promise_chaining.js`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, instead of nested callbacks, we have promise chaining. So, why should
    you choose promises over callbacks? Consider the following benefits:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to their linear syntax, promises help us to make code easier to follow
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have `.catch()`, which provides a central way to handle errors
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises allow you to chain multiple asynchronous operations together in a more
    readable way
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a``sync`/`await` builds on top of promises and provides an even more synchronous
    looking way to write asynchronous code (we’ll learn about `async`/`await` in this
    chapter too)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How about making the promise-based code more readable?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `Ch03``/js/promise.js`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, adding a simple delay function can make our code more readable,
    instead of having nested callbacks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: A promise acts as a producer. If you want to handle the response of your promise,
    you need to register a consumer. This registration is mainly done by using a `.then`
    instruction. It is a continuation of a promise that gets the result of the previous
    promise. This instruction can handle both responses (success and failure).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the code here to see how we can handle success and error cases. When
    the operation succeeds in `addPromisifiedScript`, the `resolve` part of the code
    will be triggered; otherwise, `reject` will be triggered:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We often use `.then()` with only `resolve` mode. If you want to have one centralized
    way of handling errors, it is better to use `.catch()`, which is the equivalent
    of applying `.``then(null,reject=> {})`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: You can set up a promise to handle online book orders (an async operation).
    You might get a confirmation email for the order (a resolved promise) or encounter
    an error (a rejected promise), but either way, you’re still finished interacting
    with the bookstore’s website (the `finally` block). You can put code in the `finally`
    block to clean things up after the promise is done, win or lose. This could be
    things such as turning off a loading wheel on your screen, closing a connection
    you don’t need anymore, or anything else that needs to happen regardless of the
    outcome.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Promise API
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instantiating a promise object using a `new` keyword is not the only way of
    using it. The Promise API has several useful static methods that we can use in
    practice. Let’s take a look at them in the following subsections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Promise.all()
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have multiple promises that need to be executed in parallel, and you
    need to wait for all of them to be ready, then `Promise.all()` might be a good
    choice. It returns an array of results if all promises resolve successfully or
    rejects as soon as one of the promises fails.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要并行执行多个承诺，并且需要等待它们全部准备好，那么`Promise.all()`可能是一个不错的选择。如果所有承诺都成功解析，它将返回一个结果数组；如果任何一个承诺失败，它将立即拒绝。
- en: 'Open `github_avatars.html` in the GitHub chapter repository and run it by double-clicking
    on it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub章节仓库中打开`github_avatars.html`，并通过双击运行它：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Promise.all()` waits for all promises to be executed in parallel and be ready
    and then returns multiple promises.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()`等待所有承诺并行执行并准备好，然后返回多个承诺。'
- en: 'In our example, we use it in two scenarios:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们在两种场景中使用它：
- en: Fetching data from GitHub in parallel (*line 25*)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub并行获取数据（*第25行*）
- en: Getting data as JavaScriptON from all promises (*line 27*)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从所有承诺中获取JavaScriptON数据（*第27行*）
- en: For `Promise.all()`, we wait for all promises to be successfully executed. If
    even one promise fails (doesn’t work out), `Promise.all()` immediately stops and
    gives up entirely. It forgets about all the other promises in the list and completely
    ignores their results.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Promise.all()`，我们等待所有承诺成功执行。如果即使有一个承诺失败（没有成功），`Promise.all()`也会立即停止并完全放弃。它会忘记列表中的所有其他承诺，并完全忽略它们的结果。
- en: The code we just looked at should render two GitHub users’ avatars as images
    in an `.``html` file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的代码应该将两个GitHub用户的头像作为图像渲染到`.html`文件中。
- en: Imagine you have several tasks to run, such as fetching things from the internet.
    If one task fails, the others might still keep going. But `Promise.all()` won’t
    care about them anymore. They might finish eventually, but their results won’t
    be used. (`Ch03``/js/promiseAPI.js` contains all Promise API examples demonstrated.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一系列任务要运行，比如从互联网上获取东西。如果一个任务失败，其他任务可能仍然继续进行。但`Promise.all()`将不再关心它们。它们最终可能完成，但它们的结果不会被使用。（`Ch03``/js/promiseAPI.js`包含所有展示的Promise
    API示例。）
- en: 'The following sample code shows that `Promise.all` accepts multiple promises
    as an array:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码显示`Promise.all`接受多个承诺作为数组：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Promise.all()` doesn’t try to stop the other tasks because there’s no way
    to cancel promises once they’ve started.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()`不会尝试停止其他任务，因为一旦承诺开始，就无法取消它们。'
- en: Promise.allSettled()
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise.allSettled()
- en: Unlike `Promise.all()`, `Promise.allSettled()` is more patient. Even if one
    promise fails, it waits for all the promises to finish before giving you the results.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Promise.all()`不同，`Promise.allSettled()`更有耐心。即使有一个承诺失败，它也会等待所有承诺完成后再给你结果。
- en: Imagine a similar scenario with the tasks. This time, `Promise.allSettled()`
    will wait for all the tasks to be completed, regardless of whether one fails.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个类似场景的任务。这次，`Promise.allSettled()`将等待所有任务完成，无论其中一个是否失败。
- en: 'In the end, it will give you a report on all the tasks, telling you whether
    each one succeeded (`success resolve`) or failed (`Something` `went wrong!!`):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将给出所有任务的报告，告诉你每个任务是成功（`成功解析`）还是失败（`出了点问题!!`）：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This way, you get a complete picture of what happened with all your tasks, even
    if some failed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以全面了解所有任务的情况，即使有些失败了。
- en: Promise.race()
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise.race()
- en: '`Promise.race()` is like a race between promises. You provide it with a bunch
    of promises, and it waits for the very first one to either succeed or fail.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.race()`就像是一系列承诺之间的比赛。你向它提供一串承诺，它等待第一个承诺要么成功要么失败。'
- en: 'Whichever promise finishes first (wins the race), its result (a success or
    error value) becomes the result of `Promise.race()`. The rest of the promises
    are completely ignored, regardless of whether they eventually succeed or fail:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪个承诺先完成（赢得比赛），其结果（成功或错误值）都将成为`Promise.race()`的结果。其余的承诺将被完全忽略，无论它们最终是否成功或失败：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You need to be careful when you use `Promise.race` for the following reasons:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`Promise.race`时，需要小心以下原因：
- en: It’s useful when you only need the result from the fastest promise
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你只需要从最快的承诺中获取结果时，这很有用
- en: It stops listening to other promises as soon as one finishes
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦一个承诺完成，它就停止监听其他承诺
- en: It returns the result (success value or error) from the winning promise
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从获胜的承诺返回结果（成功值或错误）
- en: Promise.any()
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise.any()
- en: '`Promise.any()` waits for any of the promises to succeed, not necessarily the
    first one.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.any()`等待任何一个承诺成功，不一定是第一个承诺。'
- en: As soon as one promise resolves successfully, `Promise.any` immediately stops
    waiting for the others and returns the success value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦某个承诺成功解决，`Promise.any` 立即停止等待其他承诺，并返回成功值。
- en: 'However, if all the promises in the list end up failing (rejected), `Promise.any`
    itself rejects with a special error called `AggregateError`. This error contains
    information about why all the individual promises failed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果列表中的所有承诺最终都失败了（被拒绝），`Promise.any` 本身会以一个特殊错误 `AggregateError` 拒绝。这个错误包含了所有单个承诺失败的原因：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We also have `Promise.resolve()` and `Promise.reject()`, but they are rarely
    used due to the `async`/`await` keyword.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有 `Promise.resolve()` 和 `Promise.reject()`，但由于 `async`/`await` 关键字，它们很少被使用。
- en: Async/await in JavaScript
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 中的 Async/await
- en: Promises are so popular that there is a special syntax to work with them. This
    combination is called `async`/`await` keyword in the `async_await.js` file in
    the chapter’s repository.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺非常流行，以至于有一个特殊的语法来处理它们。这个组合在章节的仓库中的 `async_await.js` 文件中被称为 `async`/`await`
    关键字。
- en: 'You’re able to add an `async` keyword to any function, even just a simple function.
    But what is the value of using the `async` keyword before your functions? Well,
    the `async` keyword is a syntactical sugar that helps us to wrap our function
    to a promise. Check out this function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为任何函数添加 `async` 关键字，甚至是一个简单的函数。但为什么要在你的函数之前使用 `async` 关键字呢？嗯，`async` 关键字是一种语法糖，它帮助我们将函数包装成一个承诺。看看这个函数：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is exactly the same as this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这与这个完全一样：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The async version of the function, behind the scenes, will generate a promise
    (*Figure 3**.7*). This means that using this syntax, you’re able to add continuations
    such as `.then()`, `.finally()`, and .`catch()` to that function. It is just a
    promise-based function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的异步版本在幕后将生成一个承诺（*图 3**.7*）。这意味着使用这种语法，你可以向该函数添加续集，如 `.then()`、`.finally()`
    和 `.catch()`。它只是一个基于承诺的函数。
- en: '![Figure 3.8: The async function is promise-based](img/B09148_03_8.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8：异步函数基于承诺](img/B09148_03_8.jpg)'
- en: 'Figure 3.8: The async function is promise-based'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：异步函数基于承诺
- en: 'So, the responsibility of async is to ensure that the functions always return
    a promise. But that is not all. There is another keyword in this pair that is
    called `await`. If you need to wait for your promise to be settled, then you’re
    able to use this keyword. Say we have a simple `delayedMessage()` function that
    returns exactly the same message as provided by the arguments but with some delays:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，异步的责任是确保函数始终返回一个承诺。但这还不是全部。这对关键字中还有一个叫做 `await` 的关键字。如果你需要等待你的承诺解决，那么你就可以使用这个关键字。比如说我们有一个简单的
    `delayedMessage()` 函数，它返回与提供的参数完全相同的信息，但有一些延迟：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead of getting data by chaining (using `.then` ), you can simply apply
    a synchronous programming technique. This means just waiting for functions to
    return data, get the data, and then continue:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过链式调用（使用 `.then`）获取数据不同，你可以简单地应用同步编程技术。这意味着只需等待函数返回数据，获取数据，然后继续：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is simple. So, instead of working with `then`, `catch`, and `finally`,
    you can interact with promise-based functions using just async-based syntax. Put
    simply, await is just a more elegant way of working with promises.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。所以，而不是使用 `then`、`catch` 和 `finally`，你可以仅使用基于 async 的语法与基于承诺的函数交互。简单来说，await
    只是一种更优雅地处理承诺的方式。
- en: 'Here is a simple example of fetching data from multiple URLs using promises:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用承诺从多个 URL 获取数据的简单示例：
- en: 'File: `Ch03``/js/getdata_promise.js`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`Ch03``/js/getdata_promise.js`
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In our preceding example, we fetch data from `/posts` and `/comments` of the
    JavaScript `onplaceholder` URL using promises.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的例子中，我们使用承诺从 JavaScript `onplaceholder` URL 的 `/posts` 和 `/comments` 获取数据。
- en: 'Using async/await, we’re able to simplify it, like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 async/await，我们可以简化它，如下所示：
- en: 'File: `Ch03``/js/getdata_async.js`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`Ch03``/js/getdata_async.js`
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instead of using `.then()` every time, we are now able to use synchronous-programming-based
    syntax.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次都使用 `.then()`，我们现在能够使用基于同步编程的语法。
- en: 'You might be wondering how to handle exceptions in this code? If we are free
    to not use `.catch()`, then how will we be able to catch exceptions? The answer
    here is also really simple: just use `try..catch`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何处理这段代码中的异常？如果我们可以自由地不使用 `.catch()`，那么我们如何能够捕获异常呢？这里的答案也是非常简单的：只需使用 `try..catch`。
- en: We have talked enough about promises. It is time to see how JavaScript internally
    handles promises.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经足够多地讨论了承诺。现在是时候看看 JavaScript 内部是如何处理承诺的了。
- en: Microtask queue
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微任务队列
- en: We’ve talked about promises and async/await. It is now the exact time to talk
    about the related topic of the `PromiseJobs`) – see *Figure 3**.8*. To better
    manage asynchronous tasks in JavaScript, the ECMA standard added this internal
    queue. It has approximately the same behavior as a callback queue in terms of
    the call stack because the execution of these tasks is possible only when nothing
    else is running in the call stack.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 promises 和 async/await。现在是讨论相关主题 `PromiseJobs` 的确切时机——参见 *图 3.8*。为了更好地管理
    JavaScript 中的异步任务，ECMA 标准添加了这个内部队列。在调用栈方面，它具有与回调队列相似的行为，因为这些任务的执行只有在调用栈中没有其他运行时才可能。
- en: '![Figure 3.9: Microtask queue](img/B09148_03_9.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9：微任务队列](img/B09148_03_9.jpg)'
- en: 'Figure 3.9: Microtask queue'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：微任务队列
- en: So, when a given promise is ready, the continuations, such as `then`/`catch`/`finally`
    handlers, are put into the queue. When the call stack is empty, the JavaScript
    engine will take these tasks in a **First in, First out** (**FIFO**) order and
    execute them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当给定的 promise 准备就绪时，续集，如 `then`/`catch`/`finally` 处理程序，会被放入队列中。当调用栈为空时，JavaScript
    引擎将按照 **先进先出**（**FIFO**）的顺序执行这些任务。
- en: 'Here is a simple example (`Ch03``/js/microtasks.js`):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有一个简单的示例 (`Ch03``/js/microtasks.js`):'
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The order of the output is seen in *Figure 3**.10*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的顺序可以在 *图 3.10* 中看到。
- en: '![Figure 3.10: The output of the preceding code](img/B09148_03_10.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10：前述代码的输出](img/B09148_03_10.jpg)'
- en: 'Figure 3.10: The output of the preceding code'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：前述代码的输出
- en: Because, when the JavaScript engine detects a promise, it moves its `.then()`
    to the microtask queue. It is an async operation, so we directly switch to the
    next line. It is possible to execute a promise only if the call stack is empty.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，当 JavaScript 引擎检测到 promise 时，它会将 `.then()` 移动到微任务队列中。这是一个异步操作，所以我们直接切换到下一行。只有在调用栈为空时，才能执行
    promise。
- en: Of course, the topics we discussed are not the whole list of topics you need
    to work with Node.js. We bypassed some simple and middle-level topics and covered
    only some important ones we think might help you when working with Node.js. JavaScript
    skills are essential, and you need to be aware of its syntax. Having better JavaScript
    skills will be a guide for you throughout the learning process of the book.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们讨论的主题并不是你需要与 Node.js 一起工作的所有主题列表。我们跳过了一些简单和中级主题，只涵盖了我们认为可能在你使用 Node.js
    时有所帮助的一些重要主题。JavaScript 技能是必不可少的，你需要了解其语法。拥有更好的 JavaScript 技能将在你学习本书的过程中起到指导作用。
- en: Node.js essentials
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 基础知识
- en: Node.js is not a separate programming language. It is a runtime over Google’s
    V8 engine. This simply means that the creator of Node.js just took the V8 engine
    out of the browser and put it into another runtime. Node.js is a wrapper over
    the V8 engine and extends it by adding networking, APIs for I/O, and other operations.
    A key aspect of Node.js is its non-blocking I/O model. This means Node.js can
    handle multiple requests simultaneously without being blocked by slow operations.
    The event loop and callback queue become even more important in this context.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 不是一个独立的编程语言。它是 Google 的 V8 引擎上的一个运行时环境。这意味着 Node.js 的创建者只是将 V8 引擎从浏览器中提取出来，并将其放入另一个运行时环境中。Node.js
    是 V8 引擎的包装器，通过添加网络、I/O API 和其他操作来扩展它。Node.js 的一个关键方面是其非阻塞 I/O 模型。这意味着 Node.js
    可以在不被缓慢操作阻塞的情况下同时处理多个请求。在这种情况下，事件循环和回调队列变得更加重要。
- en: Node.js has different dependencies under the hood, but the most interesting
    one for us to discuss is **Libuv**. Libuv provides a thread pool for handling
    certain tasks, with four threads by default, but this can be configured based
    on the application’s requirements.This is the main magic that provides I/O-based
    non-blocking operations. It is written in C, and it provides an event-driven asynchronous
    I/O model. It is possible to perform blocking operations using a thread pool to
    distribute CPU loads. We have four threads to use in Libuv by default. For network-based
    async operations, Libuv relies on the OS itself, but for some other async functions,
    such as reading something from a file, Libuv relies on its thread pool. The concept
    of a thread pool allows us to do some important operations in a separate thread
    and not block others.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js在底层有不同的依赖，但对我们来说最有趣的一个是**Libuv**。Libuv为处理某些任务提供了一个线程池，默认情况下有四个线程，但可以根据应用程序的要求进行配置。这是提供基于I/O的非阻塞操作的主要魔法。它是用C语言编写的，提供了一个基于事件的异步I/O模型。可以使用线程池执行阻塞操作以分配CPU负载。默认情况下，我们在Libuv中有四个线程可以使用。对于基于网络的异步操作，Libuv依赖于操作系统本身，但对于某些其他异步函数，例如从文件中读取，Libuv依赖于其线程池。线程池的概念允许我们在单独的线程中执行一些重要操作，而不会阻塞其他操作。
- en: Node.js primarily focuses on asynchronous I/O and aims to minimize blocking
    operations. The thread pool is mainly used for tasks that cannot be efficiently
    handled asynchronously by the OS, such as intensive calculations or filesystem
    operations requiring significant processing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js主要关注异步I/O，并旨在最小化阻塞操作。线程池主要用于那些无法由操作系统高效异步处理的任务，例如需要大量处理的密集计算或文件系统操作。
- en: Like in browsers, we have different queues to be used when it comes to the Node.js
    async nature. The general concept is the same. They both use an event-loop-based
    model, but for Node.js, we have some more queues.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在浏览器中一样，当涉及到Node.js的异步特性时，我们有不同的队列可以使用。一般概念是相同的。它们都使用基于事件循环的模型，但Node.js有一些更多的队列。
- en: The event loop is a mechanism that continuously operates while your Node.js
    application is running. It’s responsible for handling different asynchronous events.
    The event loop utilizes queues to organize these events, ensuring they are processed
    in the proper order. The event loop consists of six different queues.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是在你的Node.js应用程序运行期间持续运行的机制。它负责处理不同的异步事件。事件循环利用队列来组织这些事件，确保它们按正确的顺序处理。事件循环由六个不同的队列组成。
- en: 'The event loop utilizes several queues to manage different types of asynchronous
    operations (*Figure 3**.9*). These queues ensure tasks are processed in a specific
    order, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环利用几个队列来管理不同类型的异步操作（**图3.9**）。这些队列确保任务按照特定顺序处理，如下所示：
- en: '`setTimeout` and `setInterval` functions. These callbacks are executed after
    a specified delay or at regular intervals. (Technically, it’s a min-heap for efficient
    scheduling.)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTimeout`和`setInterval`函数。这些回调在指定延迟后或定期执行。（技术上，它是一个用于高效调度的最小堆。）'
- en: '`fs` and `http` modules. The event loop processes these callbacks when the
    I/O operation completes.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`和`http`模块。事件循环在I/O操作完成时处理这些回调。'
- en: '`setImmediate`. These callbacks are considered a high priority and are executed
    before other tasks in the next loop iteration.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setImmediate`。这些回调被视为高优先级，并在下一次循环迭代之前执行。'
- en: '**Close queue**: This queue contains functions meant to run when an asynchronous
    resource is closed, ensuring proper cleanup.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭队列**：这个队列包含在异步资源关闭时运行的函数，确保适当的清理。'
- en: '`process.nextTick`. These are also a high priority and get executed immediately
    after the current operation finishes.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process.nextTick`。这些也是高优先级，并在当前操作完成后立即执行。'
- en: '**Promise queue**: This queue contains callbacks associated with resolving
    or rejecting promises. These are processed whenever the event loop encounters
    a resolved or rejected promise during its execution.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Promise队列**：这个队列包含与解析或拒绝承诺相关的回调。这些回调在事件循环执行过程中遇到已解析或已拒绝的承诺时被处理。'
- en: It’s important to note that the first four queues (timers, I/O, check, and close
    callbacks) are managed by Libuv. The microtask queues (`nextTick` and `Promise`)
    are separate but still play a crucial role in determining the order of callback
    execution within the event loop.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，前四个队列（定时器、I/O、检查和关闭回调）由Libuv管理。微任务队列（`nextTick`和`Promise`）是独立的，但仍在确定事件循环中回调执行顺序方面发挥着关键作用。
- en: '![Figure 3.11: Node.js queues](img/B09148_03_11.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：Node.js队列](img/B09148_03_11.jpg)'
- en: 'Figure 3.11: Node.js queues'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：Node.js队列
- en: 'Let’s talk about the priority order of the queues. First things first, it is
    important to understand that user-written, synchronous JavaScript code has the
    highest priority over all of these queues. This simply means that these queue
    elements will be executed only if the call stack is empty. However, what about
    these six queue orders? We will discuss them in more detail now:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下队列的优先级顺序。首先，重要的是要理解用户编写的同步JavaScript代码在这些队列中具有最高优先级。这仅仅意味着，只有当调用栈为空时，这些队列元素才会被执行。然而，这六个队列的顺序又是什么呢？我们现在将更详细地讨论它们：
- en: '`nextTick` queue, executing those tasks first, followed by any callbacks in
    the promise queue.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nextTick`队列，首先执行这些任务，然后是`promise`队列中的任何回调。'
- en: '`setTimeout` and `setInterval`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTimeout`和`setInterval`。'
- en: After the timers queue, the event loop is going to check the microtask queue
    again. First, the `nextTick` queue will be executed, and then the `promise` queue
    will be executed.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在计时器队列之后，事件循环将再次检查微任务队列。首先，将执行`nextTick`队列，然后执行`promise`队列。
- en: '**I/O callbacks**: Next, the event loop handles callbacks from the I/O queue.
    These represent asynchronous operations, such as file I/O or network requests,
    which have completed.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/O回调**：接下来，事件循环处理I/O队列中的回调。这些代表异步操作，如文件I/O或网络请求，它们已经完成。'
- en: '**Microtask check (again)**: The event loop checks for microtasks again after
    processing the I/O. This ensures that any microtasks created during those operations
    are executed immediately.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**再次检查微任务**：在处理I/O之后，事件循环再次检查微任务。这确保了在那些操作期间创建的任何微任务都能立即执行。'
- en: '`setImmediate`): The event loop then executes callbacks from the check queue,
    which holds functions scheduled with `setImmediate`. These are considered high-priority
    tasks and run before other callbacks in the next loop iteration.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setImmediate`：然后事件循环执行检查队列中的回调，该队列包含使用`setImmediate`计划的功能。这些被认为是高优先级任务，并在下一次循环迭代中先于其他回调执行。'
- en: After the check queue, the event loop is going to check the microtask queue
    again. First, the `nextTick` queue will be executed, and then the `promise` queue
    will be executed.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在检查队列之后，事件循环将再次检查微任务队列。首先，将执行`nextTick`队列，然后执行`promise`队列。
- en: '**Close callbacks**: Finally, the event loop processes callbacks associated
    with closing asynchronous resources, ensuring proper cleanup.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭回调**：最后，事件循环处理与关闭异步资源相关的回调，确保适当的清理。'
- en: Check the microtasks queue again and execute callbacks if they exist.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次检查微任务队列，如果存在回调则执行。
- en: '**Microtasks throughout the loop**: The event loop keeps the party going as
    long as there are callbacks waiting to be invited. Once everyone’s had their turn
    and there’s nothing left to do, it gracefully exits the stage.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环中的微任务**：只要还有等待被邀请的回调，事件循环就会继续进行。一旦每个人都轮换过，并且没有剩下任何要做的，它就会优雅地退出舞台。'
- en: As you might notice, microtasks are checked multiple times within the event
    loop. This ensures that any microtasks created during the execution of other callbacks
    are handled immediately. This prioritizes tasks scheduled with `nextTick` and
    `promise` resolutions, keeping the event loop responsive.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能注意到的，微任务在事件循环中被检查多次。这确保了在执行其他回调期间创建的任何微任务都能立即得到处理。这优先处理了使用`nextTick`和`promise`解析计划的任务，保持了事件循环的响应性。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter was about JavaScript and Node.js internals.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于JavaScript和Node.js内部机制的。
- en: First, we started our discussion with JavaScript internals. The main point was
    to understand the JavaScript engine and the JavaScript runtime. JavaScript is
    a single-thread language, but it has an async nature and we’re able to use callbacks
    and promises to implement it. In async programming, callbacks are a bit old school
    nowadays thanks to promises. We also talked about the Promise API and learned
    a lot of interesting functions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始讨论JavaScript内部机制。主要目的是理解JavaScript引擎和JavaScript运行时。JavaScript是一种单线程语言，但它具有异步特性，我们能够使用回调和promises来实现它。在异步编程中，由于promises的出现，回调现在有点过时了。我们还讨论了Promise
    API，并学习了许多有趣的功能。
- en: 'The popularity of promises brings other interesting features to JavaScript:
    async/await. Using examples, we tried to demonstrate how they make our code more
    readable, understandable, and similar to sync code.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Promises的流行给JavaScript带来了其他有趣的功能：async/await。通过示例，我们试图展示它们如何使我们的代码更易于阅读、理解和更接近同步代码。
- en: For promises, we have a special queue in the JavaScript engine pipeline called
    the microtask queue.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于承诺（promises），JavaScript 引擎管道中有一个特殊的队列，称为微任务队列。
- en: Then we started a discussion around Node.js and learned that it is also a runtime
    and uses the JavaScript engine to read and translate JavaScript code. It takesJavaScript
    to another level, and using Node.js, we can build real-time applications, microservices,
    web APIs, streaming applications, command-line tools, and more.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们围绕 Node.js 进行了讨论，了解到它也是一个运行时环境，并使用 JavaScript 引擎来读取和翻译 JavaScript 代码。它将
    JavaScript 推向了另一个层次，使用 Node.js，我们可以构建实时应用、微服务、Web API、流式应用、命令行工具等等。
- en: Internally, Node.js heavily relies on Libuv and provides tons of functionalities
    that mostly can be categorized under asynchronous I/O and thread pooling. Libuv
    provides the core functionality for Node.js’s asynchronous programming model,
    making it efficient and scalable for handling numerous concurrent connections
    and I/O operations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 内部来说，Node.js 严重依赖于 Libuv，并提供了大量的功能，这些功能大多可以归类为异步 I/O 和线程池。Libuv 为 Node.js 的异步编程模型提供了核心功能，使其在处理大量并发连接和
    I/O 操作时既高效又可扩展。
- en: The last discussion for this chapter was on Node.js queues and event loops.
    We have several queues in Node.js and they have special orders that we need to
    understand to build more effective applications.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后讨论是关于 Node.js 队列和事件循环。Node.js 中有几个队列，它们有特殊的顺序，我们需要理解这些顺序来构建更有效的应用。
- en: In our next chapter, we will talk about the stack development technologies that
    you need to know before writing any lines of code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论在编写任何代码之前你需要了解的堆栈开发技术。
