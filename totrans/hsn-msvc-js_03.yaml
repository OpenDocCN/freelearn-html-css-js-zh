- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Do You Need Before Getting Started?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservice approach does not inherently depend on any specific programming
    language. You can implement it using different programming languages. The concept
    of microservices supports using different languages for different services within
    a single application. This means the choice of programming language for each service
    can be based on its specific needs and functionalities. For example, you’re able
    to implement *microservice A* using C# but *microservice B* using JavaScript.
    That is the beauty of microservice development, which allows us to bypass programming
    language barriers.
  prefs: []
  type: TYPE_NORMAL
- en: This book is about writing microservices in JavaScript. As in any programming
    language, before implementing the microservice approach, it is best to understand
    the basics of the given language, which will help us to build better and more
    effective microservices. The focus of this chapter is to provide the foundation,
    rather than a comprehensive guide, for the language, along with Node.js. There
    are a few topics, especially in JavaScript, that need to be reviewed before implementing
    any microservice applications using the language itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript essentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js essentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A browser (select your favorite one)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visual Studio Code (or you can use your OS’s default text editor): Simply go
    to [https://code.visualstudio.com/](https://code.visualstudio.com/) and install
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub**: Go to [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter will explain the required software installation processes in
    detail. For now, you can download the GitHub repository source code without using
    any GitHub commands and experiment with it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JavaScript essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a popular, single-threaded, synchronous programming language
    that helps us mostly to build interactive web applications. Its strength is its
    ability to mix different programming methods. This mix lets you write code in
    several ways: focusing on objects, using functions like building blocks, reacting
    to events, or giving step-by-step instructions, making your code clear and easier
    to handle. The JavaScript you use in the browser or in Node.js is not completely
    *native*. That is why we need to differentiate between the concepts of the *JavaScript
    engine* and the *JavaScript runtime*.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A JavaScript engine is a special type of program that reads, parses, and translates
    our JavaScript code into computer-understandable language (machine instructions)
    – see *Figure 3**.1*. We don’t have one single JavaScript engine for all browsers.
    For instance, Google Chrome, Opera, and the latest Microsoft Edge browsers use
    the *V8 engine*, Firefox has *SpiderMonkey*, and Safari uses the *JavascriptCore
    engine*. Anyone with the ability to follow ECMAScript engine standards can create
    their own JavaScript engine.
  prefs: []
  type: TYPE_NORMAL
- en: But how can we have compatible JavaScript across the browsers? How do we make
    sure that the JavaScript code will work for all browsers? That is why we need
    a standard that will tell us exactly what we need to do to make sure that JavaScript
    will work for all browsers. Thankfully, we have a combination of rules that allows
    us to ensure consistency across different web browsers. This essential rulebook
    for scripting is called **ECMAScript** (**ES**). Of course, ES isn’t just for
    JavaScript; it applies to other scripting languages as well, but JavaScript is
    the most well-known implementation of it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: JavaScript translation process](img/B09148_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: JavaScript translation process'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the JavaScript engine in depth in the next few subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Call stack and memory heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript engine consists of multiple elements, and two of them are the **call
    stack** and the **memory heap** (*Figure 3**.2*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Call stack and memory heap](img/B09148_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Call stack and memory heap'
  prefs: []
  type: TYPE_NORMAL
- en: When we run our JavaScript application, code is executed in the call stack.
    Think of it as a series of steps that your code can walk through in a given order.
    On the other hand, the heap is about data storage. It is unstructured memory that
    stores the objects.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript translation process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **translator** is a program that can translate human-readable source code
    into machine-readable instructions. It has two main parts. The first part is the
    **compiler**. In the compilation process, the program converts the entire code
    into machine code at once. The second part is the **interpreter**. In the interpretation
    process, the interpreter goes through the source code and runs it line by line,
    converting it into machine instructions. Several years ago, JavaScript used to
    be a purely interpreted language, but fortunately, some modern JavaScript engines
    work in a hybrid mode of translation. Modern JavaScript engines use a combination
    of interpretation and JIT compilation, where the interpreter runs code line by
    line, while the compiler converts frequently used code to machine code to optimize
    performance. The V8 engine, for instance, combines the compiler and interpreter,
    which is called the **Just-in-Time** (**JIT**) compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreters are fast in terms of getting up and running. There is no need to
    convert the source into another language, which means there is no compilation
    step. For options such as executing something right away, interpreters are a better
    option than compilers. The major problem here is that if you run the same code
    (say, the same JavaScript function) again and again, it can get really slow. Interpreters
    don’t apply any optimization to your code. That is when the compiler comes in.
    It takes a bit more time than interpreters because it converts your code into
    another language, but it is smart, and when it sees the same code again, it just
    optimizes it in order to not interpret it again.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of translation, JavaScript uses the advantages of interpreter and compiler
    together.
  prefs: []
  type: TYPE_NORMAL
- en: A classical compilation means that the machine code is stored in a portable
    file and can be executed at any time, but for the JIT compiler, it is a bit different.
    The machine code should be executed as soon as possible before compilation ends.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to understand how JavaScript-specific JIT works over Google’s V8 engine.
    As a JavaScript runtime, Node.js also relies on the V8 engine, and understanding
    its internals will help us a lot from the Node.js perspective.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute your source code written in JavaScript, the JavaScript engine
    parses it. The *parser* is a sub-element of the JavaScript engine that takes your
    source code and outputs tokens. That is how the JavaScript engine understands
    whether there is an error. It acts as a **lexical analyzer** and the final output
    is called an **Abstract Syntax Tree** (**AST**). To witness the beauty of the
    AST, you can just navigate to the AST explorer ([https://astexplorer.net/](https://astexplorer.net/)),
    type any JavaScript code, and see the parsing process.
  prefs: []
  type: TYPE_NORMAL
- en: An AST is an engine-specific data structure that is generated by splitting up
    each line of your JavaScript code into pieces that are understandable to the language.
    The engine uses it to generate machine code. The AST is then taken by the *interpreter*
    and converted to byte code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Byte code** is a special type of collection of instructions that is approximately
    similar to machine code but acts as a wrapper and abstracts us from the complexities
    of the machine code. The default interpreter in V8, called **Ignition**, outputs
    byte code; on the other hand, the compiler, **Turbofan**, optimizes this bytecode
    into efficient machine code'
  prefs: []
  type: TYPE_NORMAL
- en: Turbofan also acts as a JIT compiler. In the middle of the interpreter and compiler,
    there is a *profiler* that profiles the interpretation process (Ignition) and
    forwards the code that needs to be optimized to the compiler (Turbofan). (See
    *Figure 3**.3*.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: JavaScript engine internals](img/B09148_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: JavaScript engine internals'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, but you might be asking yourself why we need to understand under-the-hood
    operations in the JavaScript engine. Well, that actually will help you to write
    better, faster code with optimized microservices. That knowledge will help you
    to write optimization-friendly code. The JavaScript engine is not always able
    to apply optimization and, in some cases, it depends on your writing style. It
    is possible to write deoptimization code that might be difficult for your JavaScript
    engine to optimize. That is why it is better to always understand the internals.
    For instance, using the `delete`, `evals`, `arguments`, and `with` keywords and
    mechanisms such as *hidden classes* and *inline caching* may slow down code optimization.
    These concepts are beyond our book, but you can learn about them by checking the
    open source JavaScript tutorials and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need to talk about is the single-threaded nature of JavaScript,
    and believe me, things get interesting when we dive into the threading details.
  prefs: []
  type: TYPE_NORMAL
- en: Threading in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned before, JavaScript is a single-threaded, blocking, synchronous
    programming language that has only one call stack. JavaScript is "single-threaded,"
    but it's not necessarily "blocking." It is synchronous by default but can handle
    asynchronous code execution using callbacks, promises, and async/await. But what
    does this mean and why do we need to understand it? Well, most programming languages
    support multithreading out of the box. This means it is possible to run multiple
    independent operations at a given time. But when it comes to JavaScript, things
    are a bit different. It is possible to run only one set of instructions at a given
    time for JavaScript natively, and this is a big problem in the world of multithreading,
    especially for long-running tasks. Fortunately, when you deal with JavaScript,
    you’re not dealing with only a JavaScript engine but also something called a **JavaScript
    runtime**.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The browser, by its nature, is a wrapper and a runtime for the JavaScript engine.
    The responsibility of the runtime is to provide *additional* support to implement
    all the required functionalities for the given context. Here, in browsers, the
    context is a web-based interactive application. Node.js is also a runtime based
    on Google’s V8 engine. Engines help you to extend native JavaScript engine functionalities
    even more and add an async nature to them. These functionalities together in the
    browser are called **web APIs**. To see browser-based, important web APIs, just
    do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite browser (in our case, it is Google Chrome).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and select **Inspect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `window`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also see this in *Figure 3**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: window global object](img/B09148_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: window global object'
  prefs: []
  type: TYPE_NORMAL
- en: The elements of the `window` object (its properties and methods) that you can
    see are in addition to your JavaScript engine, which is built into the browser
    you use. Browsers have web APIs that are approximately similar for all of them.
    Most core web APIs are designed to be standardized so that websites can function
    similarly across different browsers. However, there can be minor differences in
    implementation or features between browsers, and some APIs might be specific to
    a particular browser. Most popular API functions, such as `fetch`, `settimeout`,
    `setinterval`, and `document`, are part of this huge API called `window`. It means
    they are not native JavaScript functions but engine-based functions for us in
    the given context. Web APIs decorate our JavaScript code with async behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: When you write code that has these functions (`fetch`, `document`, etc.), the
    JavaScript engine will forward them to the web APIs. Web APIs are written in low-level
    languages (in most cases in C/C++) and after execution, your callback, which is
    provided in the given instruction, will be added to the *callback queue*. All
    native JavaScript functions will be executed directly in the call stack, but non-native
    instructions need to be executed first in the web API and the result of the execution,
    as a callback, will be added to the callback queue (*Figure 3**.5*).
  prefs: []
  type: TYPE_NORMAL
- en: There is also the *event loop*. The responsibility of the event loop is just
    to check the call stack and to push callback queue elements there only if it is
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure all the terms we mentioned are understood well, let’s consider
    a simple example. Look at *Figure 3**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: JavaScript event loop with a callback queue](img/B09148_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: JavaScript event loop with a callback queue'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your favorite web browser, right-click on the page, select `event_loop.js`
    in the `Ch03``/js` folder of the book’s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here in our code, you might expect to see `setTimeout`’s message first and then
    other messages in the given order. Because we have specified `0` for `setTimeout`,
    it should immediately execute our code. But the output is different, as we can
    see in *Figure 3**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: The call stack executes a queue item at the end](img/B09148_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: The call stack executes a queue item at the end'
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, if the executed function is non-native, which means it is
    a web-API-based function, then the JavaScript engine will forward it to the web
    API, and after execution, its callback will be added to the callback queue. Meanwhile,
    `setTimeout` is going to be a non-blocking, asynchronous operation, and that is
    why we see the result of `print` functions first.
  prefs: []
  type: TYPE_NORMAL
- en: So, it doesn’t matter if you have set `0` or more as the second argument to
    `setTimeout`; it goes through the pipeline we explained anyway. The event loop
    will check whether the call stack is empty and when both `print` functions are
    done, it does become empty, so we’re able to see the result of `setTimeout` only
    after the event loop pushes it to the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s talk about the asynchronous nature of JavaScript in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Callback-based asynchronous JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`setTimeout` or `setInterval`, you usually rely on callbacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks are indispensable, but sometimes their usage makes your code less
    understandable and less maintainable, especially from an asynchronous code perspective.
    To prove that, go to `callback_hell.html` and run it in any browser. (You can
    find `callback_hell.html` in the `Ch03` folder of the book’s GitHub repository.
    For the sake of simplicity, all the GitHub repository references will contain
    only the path, i.e., `Ch03``/callback_hell.html`.)
  prefs: []
  type: TYPE_NORMAL
- en: The file contains callback-based multiple asynchronous actions that we call
    *callback hell*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what this script does:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically adds the provided script to the head of the HTML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Runs a function that belongs to that script (in our case, it is an `execute`
    function).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Runs the `operation completed successfully` message after `three` seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Three` seconds after the preceding message runs, it outputs the `ready for
    another execution` message to the console. If the loaded file doesn’t exist, then
    the error message will be printed as an output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the code is hard to read, understand, and maintain this code
    due to its nesting. In software development, *maintaining* refers to the ongoing
    process of keeping software functioning properly, secure, and up to date. It might
    be more complex if you have more operations to do.
  prefs: []
  type: TYPE_NORMAL
- en: The way to promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While callbacks are still a main part of JavaScript, promises are the preferred
    way to handle asynchronous operations in modern JavaScript development due to
    the benefits they offer in readability, error handling, and code maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Promises** were added in JavaScript with the **ECMAScript 6** (**ES6**) specification,
    which was released in 2015\. Before ES6, callback hell was a common way to handle
    asynchronous operations in JavaScript. Thanks to promises, now we have a clean
    and more manageable approach for asynchronous programming. We actively use promises
    in Node.js development, so it is crucial to understand and properly use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a promise, we use a `Promise` object. It has a single callback argument,
    which is called `executor`. It runs automatically when the promise is constructed
    successfully. The executor consists of two callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resolve`: We use this to inform a user about a successful operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reject`: We use this to indicate that something went wrong'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a promise is done, it should call one of the functions, either `resolve`
    (value) or `reject` (error).
  prefs: []
  type: TYPE_NORMAL
- en: The promise is initially in a `pending` state. It will be moved to a `fulfilled`
    state if `resolve` happens; otherwise (if rejected), the state will be moved to
    `rejected`.
  prefs: []
  type: TYPE_NORMAL
- en: The promise’s result is initially `undefined`. It will store `value` if `resolve`
    is executed; otherwise (if rejected), it will store `error`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Promise state and result](img/B09148_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Promise state and result'
  prefs: []
  type: TYPE_NORMAL
- en: It is completely okay to use only `resolve` or `reject` for `executor` if you
    want to provide only one path for your execution.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to implement the callback example in *Figure 3**.7* using promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `Ch03``/js/promise_chaining.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of nested callbacks, we have promise chaining. So, why should
    you choose promises over callbacks? Consider the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to their linear syntax, promises help us to make code easier to follow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have `.catch()`, which provides a central way to handle errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises allow you to chain multiple asynchronous operations together in a more
    readable way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a``sync`/`await` builds on top of promises and provides an even more synchronous
    looking way to write asynchronous code (we’ll learn about `async`/`await` in this
    chapter too)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How about making the promise-based code more readable?
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `Ch03``/js/promise.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, adding a simple delay function can make our code more readable,
    instead of having nested callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: A promise acts as a producer. If you want to handle the response of your promise,
    you need to register a consumer. This registration is mainly done by using a `.then`
    instruction. It is a continuation of a promise that gets the result of the previous
    promise. This instruction can handle both responses (success and failure).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the code here to see how we can handle success and error cases. When
    the operation succeeds in `addPromisifiedScript`, the `resolve` part of the code
    will be triggered; otherwise, `reject` will be triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We often use `.then()` with only `resolve` mode. If you want to have one centralized
    way of handling errors, it is better to use `.catch()`, which is the equivalent
    of applying `.``then(null,reject=> {})`.
  prefs: []
  type: TYPE_NORMAL
- en: You can set up a promise to handle online book orders (an async operation).
    You might get a confirmation email for the order (a resolved promise) or encounter
    an error (a rejected promise), but either way, you’re still finished interacting
    with the bookstore’s website (the `finally` block). You can put code in the `finally`
    block to clean things up after the promise is done, win or lose. This could be
    things such as turning off a loading wheel on your screen, closing a connection
    you don’t need anymore, or anything else that needs to happen regardless of the
    outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Promise API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instantiating a promise object using a `new` keyword is not the only way of
    using it. The Promise API has several useful static methods that we can use in
    practice. Let’s take a look at them in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Promise.all()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have multiple promises that need to be executed in parallel, and you
    need to wait for all of them to be ready, then `Promise.all()` might be a good
    choice. It returns an array of results if all promises resolve successfully or
    rejects as soon as one of the promises fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `github_avatars.html` in the GitHub chapter repository and run it by double-clicking
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.all()` waits for all promises to be executed in parallel and be ready
    and then returns multiple promises.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we use it in two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data from GitHub in parallel (*line 25*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting data as JavaScriptON from all promises (*line 27*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `Promise.all()`, we wait for all promises to be successfully executed. If
    even one promise fails (doesn’t work out), `Promise.all()` immediately stops and
    gives up entirely. It forgets about all the other promises in the list and completely
    ignores their results.
  prefs: []
  type: TYPE_NORMAL
- en: The code we just looked at should render two GitHub users’ avatars as images
    in an `.``html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have several tasks to run, such as fetching things from the internet.
    If one task fails, the others might still keep going. But `Promise.all()` won’t
    care about them anymore. They might finish eventually, but their results won’t
    be used. (`Ch03``/js/promiseAPI.js` contains all Promise API examples demonstrated.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code shows that `Promise.all` accepts multiple promises
    as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.all()` doesn’t try to stop the other tasks because there’s no way
    to cancel promises once they’ve started.'
  prefs: []
  type: TYPE_NORMAL
- en: Promise.allSettled()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike `Promise.all()`, `Promise.allSettled()` is more patient. Even if one
    promise fails, it waits for all the promises to finish before giving you the results.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a similar scenario with the tasks. This time, `Promise.allSettled()`
    will wait for all the tasks to be completed, regardless of whether one fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, it will give you a report on all the tasks, telling you whether
    each one succeeded (`success resolve`) or failed (`Something` `went wrong!!`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This way, you get a complete picture of what happened with all your tasks, even
    if some failed.
  prefs: []
  type: TYPE_NORMAL
- en: Promise.race()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Promise.race()` is like a race between promises. You provide it with a bunch
    of promises, and it waits for the very first one to either succeed or fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever promise finishes first (wins the race), its result (a success or
    error value) becomes the result of `Promise.race()`. The rest of the promises
    are completely ignored, regardless of whether they eventually succeed or fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to be careful when you use `Promise.race` for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s useful when you only need the result from the fastest promise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It stops listening to other promises as soon as one finishes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns the result (success value or error) from the winning promise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promise.any()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Promise.any()` waits for any of the promises to succeed, not necessarily the
    first one.'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as one promise resolves successfully, `Promise.any` immediately stops
    waiting for the others and returns the success value.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if all the promises in the list end up failing (rejected), `Promise.any`
    itself rejects with a special error called `AggregateError`. This error contains
    information about why all the individual promises failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We also have `Promise.resolve()` and `Promise.reject()`, but they are rarely
    used due to the `async`/`await` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Async/await in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Promises are so popular that there is a special syntax to work with them. This
    combination is called `async`/`await` keyword in the `async_await.js` file in
    the chapter’s repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re able to add an `async` keyword to any function, even just a simple function.
    But what is the value of using the `async` keyword before your functions? Well,
    the `async` keyword is a syntactical sugar that helps us to wrap our function
    to a promise. Check out this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is exactly the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The async version of the function, behind the scenes, will generate a promise
    (*Figure 3**.7*). This means that using this syntax, you’re able to add continuations
    such as `.then()`, `.finally()`, and .`catch()` to that function. It is just a
    promise-based function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: The async function is promise-based](img/B09148_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: The async function is promise-based'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the responsibility of async is to ensure that the functions always return
    a promise. But that is not all. There is another keyword in this pair that is
    called `await`. If you need to wait for your promise to be settled, then you’re
    able to use this keyword. Say we have a simple `delayedMessage()` function that
    returns exactly the same message as provided by the arguments but with some delays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of getting data by chaining (using `.then` ), you can simply apply
    a synchronous programming technique. This means just waiting for functions to
    return data, get the data, and then continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That is simple. So, instead of working with `then`, `catch`, and `finally`,
    you can interact with promise-based functions using just async-based syntax. Put
    simply, await is just a more elegant way of working with promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of fetching data from multiple URLs using promises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `Ch03``/js/getdata_promise.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In our preceding example, we fetch data from `/posts` and `/comments` of the
    JavaScript `onplaceholder` URL using promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using async/await, we’re able to simplify it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `Ch03``/js/getdata_async.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using `.then()` every time, we are now able to use synchronous-programming-based
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering how to handle exceptions in this code? If we are free
    to not use `.catch()`, then how will we be able to catch exceptions? The answer
    here is also really simple: just use `try..catch`.'
  prefs: []
  type: TYPE_NORMAL
- en: We have talked enough about promises. It is time to see how JavaScript internally
    handles promises.
  prefs: []
  type: TYPE_NORMAL
- en: Microtask queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve talked about promises and async/await. It is now the exact time to talk
    about the related topic of the `PromiseJobs`) – see *Figure 3**.8*. To better
    manage asynchronous tasks in JavaScript, the ECMA standard added this internal
    queue. It has approximately the same behavior as a callback queue in terms of
    the call stack because the execution of these tasks is possible only when nothing
    else is running in the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: Microtask queue](img/B09148_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Microtask queue'
  prefs: []
  type: TYPE_NORMAL
- en: So, when a given promise is ready, the continuations, such as `then`/`catch`/`finally`
    handlers, are put into the queue. When the call stack is empty, the JavaScript
    engine will take these tasks in a **First in, First out** (**FIFO**) order and
    execute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example (`Ch03``/js/microtasks.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The order of the output is seen in *Figure 3**.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: The output of the preceding code](img/B09148_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: The output of the preceding code'
  prefs: []
  type: TYPE_NORMAL
- en: Because, when the JavaScript engine detects a promise, it moves its `.then()`
    to the microtask queue. It is an async operation, so we directly switch to the
    next line. It is possible to execute a promise only if the call stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the topics we discussed are not the whole list of topics you need
    to work with Node.js. We bypassed some simple and middle-level topics and covered
    only some important ones we think might help you when working with Node.js. JavaScript
    skills are essential, and you need to be aware of its syntax. Having better JavaScript
    skills will be a guide for you throughout the learning process of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is not a separate programming language. It is a runtime over Google’s
    V8 engine. This simply means that the creator of Node.js just took the V8 engine
    out of the browser and put it into another runtime. Node.js is a wrapper over
    the V8 engine and extends it by adding networking, APIs for I/O, and other operations.
    A key aspect of Node.js is its non-blocking I/O model. This means Node.js can
    handle multiple requests simultaneously without being blocked by slow operations.
    The event loop and callback queue become even more important in this context.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js has different dependencies under the hood, but the most interesting
    one for us to discuss is **Libuv**. Libuv provides a thread pool for handling
    certain tasks, with four threads by default, but this can be configured based
    on the application’s requirements.This is the main magic that provides I/O-based
    non-blocking operations. It is written in C, and it provides an event-driven asynchronous
    I/O model. It is possible to perform blocking operations using a thread pool to
    distribute CPU loads. We have four threads to use in Libuv by default. For network-based
    async operations, Libuv relies on the OS itself, but for some other async functions,
    such as reading something from a file, Libuv relies on its thread pool. The concept
    of a thread pool allows us to do some important operations in a separate thread
    and not block others.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js primarily focuses on asynchronous I/O and aims to minimize blocking
    operations. The thread pool is mainly used for tasks that cannot be efficiently
    handled asynchronously by the OS, such as intensive calculations or filesystem
    operations requiring significant processing.
  prefs: []
  type: TYPE_NORMAL
- en: Like in browsers, we have different queues to be used when it comes to the Node.js
    async nature. The general concept is the same. They both use an event-loop-based
    model, but for Node.js, we have some more queues.
  prefs: []
  type: TYPE_NORMAL
- en: The event loop is a mechanism that continuously operates while your Node.js
    application is running. It’s responsible for handling different asynchronous events.
    The event loop utilizes queues to organize these events, ensuring they are processed
    in the proper order. The event loop consists of six different queues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event loop utilizes several queues to manage different types of asynchronous
    operations (*Figure 3**.9*). These queues ensure tasks are processed in a specific
    order, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setTimeout` and `setInterval` functions. These callbacks are executed after
    a specified delay or at regular intervals. (Technically, it’s a min-heap for efficient
    scheduling.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs` and `http` modules. The event loop processes these callbacks when the
    I/O operation completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setImmediate`. These callbacks are considered a high priority and are executed
    before other tasks in the next loop iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Close queue**: This queue contains functions meant to run when an asynchronous
    resource is closed, ensuring proper cleanup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.nextTick`. These are also a high priority and get executed immediately
    after the current operation finishes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Promise queue**: This queue contains callbacks associated with resolving
    or rejecting promises. These are processed whenever the event loop encounters
    a resolved or rejected promise during its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that the first four queues (timers, I/O, check, and close
    callbacks) are managed by Libuv. The microtask queues (`nextTick` and `Promise`)
    are separate but still play a crucial role in determining the order of callback
    execution within the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: Node.js queues](img/B09148_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Node.js queues'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s talk about the priority order of the queues. First things first, it is
    important to understand that user-written, synchronous JavaScript code has the
    highest priority over all of these queues. This simply means that these queue
    elements will be executed only if the call stack is empty. However, what about
    these six queue orders? We will discuss them in more detail now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nextTick` queue, executing those tasks first, followed by any callbacks in
    the promise queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setTimeout` and `setInterval`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the timers queue, the event loop is going to check the microtask queue
    again. First, the `nextTick` queue will be executed, and then the `promise` queue
    will be executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**I/O callbacks**: Next, the event loop handles callbacks from the I/O queue.
    These represent asynchronous operations, such as file I/O or network requests,
    which have completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microtask check (again)**: The event loop checks for microtasks again after
    processing the I/O. This ensures that any microtasks created during those operations
    are executed immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setImmediate`): The event loop then executes callbacks from the check queue,
    which holds functions scheduled with `setImmediate`. These are considered high-priority
    tasks and run before other callbacks in the next loop iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the check queue, the event loop is going to check the microtask queue
    again. First, the `nextTick` queue will be executed, and then the `promise` queue
    will be executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Close callbacks**: Finally, the event loop processes callbacks associated
    with closing asynchronous resources, ensuring proper cleanup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the microtasks queue again and execute callbacks if they exist.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Microtasks throughout the loop**: The event loop keeps the party going as
    long as there are callbacks waiting to be invited. Once everyone’s had their turn
    and there’s nothing left to do, it gracefully exits the stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you might notice, microtasks are checked multiple times within the event
    loop. This ensures that any microtasks created during the execution of other callbacks
    are handled immediately. This prioritizes tasks scheduled with `nextTick` and
    `promise` resolutions, keeping the event loop responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was about JavaScript and Node.js internals.
  prefs: []
  type: TYPE_NORMAL
- en: First, we started our discussion with JavaScript internals. The main point was
    to understand the JavaScript engine and the JavaScript runtime. JavaScript is
    a single-thread language, but it has an async nature and we’re able to use callbacks
    and promises to implement it. In async programming, callbacks are a bit old school
    nowadays thanks to promises. We also talked about the Promise API and learned
    a lot of interesting functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The popularity of promises brings other interesting features to JavaScript:
    async/await. Using examples, we tried to demonstrate how they make our code more
    readable, understandable, and similar to sync code.'
  prefs: []
  type: TYPE_NORMAL
- en: For promises, we have a special queue in the JavaScript engine pipeline called
    the microtask queue.
  prefs: []
  type: TYPE_NORMAL
- en: Then we started a discussion around Node.js and learned that it is also a runtime
    and uses the JavaScript engine to read and translate JavaScript code. It takesJavaScript
    to another level, and using Node.js, we can build real-time applications, microservices,
    web APIs, streaming applications, command-line tools, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, Node.js heavily relies on Libuv and provides tons of functionalities
    that mostly can be categorized under asynchronous I/O and thread pooling. Libuv
    provides the core functionality for Node.js’s asynchronous programming model,
    making it efficient and scalable for handling numerous concurrent connections
    and I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: The last discussion for this chapter was on Node.js queues and event loops.
    We have several queues in Node.js and they have special orders that we need to
    understand to build more effective applications.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will talk about the stack development technologies that
    you need to know before writing any lines of code.
  prefs: []
  type: TYPE_NORMAL
