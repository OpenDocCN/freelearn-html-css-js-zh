- en: 'Chapter 13. Finishing Up: Performance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will finish off by talking about performance and with good reason. While
    it is important to think about performance while developing your enterprise application,
    you may end up optimizing for things that do not exhibit any performance issues
    later on. This is often referred to as premature optimization and can end up wasting
    a lot of time. Although it is a good practice to understand performance implications
    of every decision of the development process, web performance optimization should
    not be conceived as a final goal; instead it is a constant tuning to improve and
    reach acceptable speed times for our enterprise application. Our real goal is
    to build our application and ensure that it functions correctly, then, if it is
    still necessary, improve the response times.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Web Performance Optimization (WPO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript performance considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional page performance considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Performance Optimization (WPO)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because an HTML5 enterprise application has many different moving parts, it
    is important to consider which parts you are optimizing. By and large, your HTML5
    enterprise application will consist of HTML, images, and CSS and JavaScript code,
    and there are ways to optimize all three.
  prefs: []
  type: TYPE_NORMAL
- en: Following standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML was developed to be a forgiving language; that is, mistakes in syntax rather
    than blowing up the page and causing endless debugging nightmares are dealt with
    in a more graceful manner. The rendering engine attempts to ascertain the intent
    of the markup and lays out the page accordingly. In essence, it stumbles but manages
    to keep its footing. Of course, a race run without hurdles goes faster than one
    run with hurdles. In addition, different web browsers will recover from such errors
    in different ways leading to inconsistent results when your HTML5 enterprise application
    is viewed in different browsers. That is why it is important to deliver clean,
    standards-compliant markup to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Despite the fact that following standards is a good base to start our optimizations,
    this could lead, in some cases, to more verbose code (increasing parsing time).
    Moreover, HTML5, unlike its previous versions, is not a finished standard yet
    and should be considered as a guidance more than as a set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are many tools out there that will validate your markup for
    you. The **World Wide Web Consortium** (**W3C**), which is the body that develops
    web standards, has its own validation tools that can be found at [http://validator.w3.org/](http://validator.w3.org/).
    There are also tools such as HTML Lint ([http://lint.brihten.com/html/](http://lint.brihten.com/html/))
    and HTML Tidy ([http://infohound.net/tidy/](http://infohound.net/tidy/)) that
    will clean your markup for you. It is a good practice to validate your markup
    to make sure your enterprise applications behave quickly and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most websites these days embed images, and often these images are the biggest
    offenders when it comes to performance. Because of limited bandwidth and the large
    sizes of image files, your enterprise application could be in fact fairly snappy
    only to force users to wait while large images are delivered to their browsers.
    It is key to web optimize your images before using them in your web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two considerations for web optimization: size and type. With regard
    to size, while it is possible to set the width and height dimensions of an image
    in the `img` tag, it is a common mistake to take a single large image and use
    it for different purposes on a web application that calls for different sizes.
    For example, when displaying thumbnails, it is a bad practice to size a larger
    image down using only the `img` tag properties. Instead you should create different
    variants or renditions of the image for different purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specifying the `width` and `height` attributes on the `img` tag lets the browser
    know what real estate to allot an image before the image is actually downloaded,
    avoiding layout changes and undesired "jumps" in the UI. Be aware that this disagrees
    with the best practice of separate content and presentation layer to a great extent.
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to type, there are indeed three types of images used on the web:
    GIF, JPEG, and PNG. These are based on different compression algorithms built
    for very different purposes. GIF images are optimized for low color palette images.
    They support 256 colors and are lossless and interlaced, which means they are
    rendered in layers rather than all at once (going from blurry to focused as you
    download and render them). They are ideal for logos and site graphics based on
    a lower color palette. JPEG images are ideal for high resolution photos as they
    support a higher color palette of 16 million colors. PNG images can support 256,
    24 bit or 32 bit color palettes image formats with optional transparency, a very
    flexible and highly compressed lossless format, with superior transparency support
    and compression than GIF. The PNG algorithm was created as an open alternative
    to the GIF compression format, whose original creator, Unisys, announced in 1995
    that it would be enforcing its patent on the algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internet Explorer 6 and previous versions do not support PNG transparency based
    on HTML standards; instead it is necessary to use proprietary filters. For example,
    `filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='image.png' ,sizingMethod='crop');`.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to optimize your CSS is to reduce the file size. There are a number
    of things you can do to accomplish this. You can reduce whitespace by placing
    styles on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can use shorthand for many rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is also best to group similar styles as close together as possible and to
    combine duplicated styles wherever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you decide not to follow these recommendations to maintain readability, or
    even if you follow them, it is always possible to minify your code (as we explain
    in the following sections).
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative is to use a dynamic stylesheet language such as **Less**
    ([http://lesscss.org](http://lesscss.org)). Less extends basic CSS functionality,
    allowing us to use more complex and elegant structures that will be translated
    in a standard CSS after a compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'With normal CSS you need to repeat common properties such as colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Less you can define a variable `@active-color` and then use it through
    your styles, so you only need to change the value of those variables to change
    the color of multiple properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even create nested structures like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That will translate after compile in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript performance considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing JavaScript can be fraught with peril as it is very easy to introduce
    slow running code, keeping some simple guidelines in mind could keep your enterprise
    application from running too slow.
  prefs: []
  type: TYPE_NORMAL
- en: '![JavaScript performance considerations](img/5689_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First of all, traversing the DOM can be expensive. You want to minimize the
    number of times you invoke `document.getElementById` and, even worse, `document.getElementsByTagName`.
    Capturing a reference to a DOM element into a variable and using the variable
    can save on expensive calls to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'So instead of implementing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or implementing its equivalent in jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can implement the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can implement its equivalent in jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Secondly, avoid constructs such as `with()` and `for-in`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thirdly, remember that arrays can be slow. Traversing an array—especially a
    deep array—can be costly. If you are pulling the same element from an array many
    times, it is better to capture it in a variable first. That is, instead of the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Fourthly, arrays are not as slow as DOM collections. Looping over `document.getElementsByTagName('p')`
    is much slower than capturing the result in an array and looping over that.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, changing classes on a DOM element is less expensive than change styles.
    It is better to define multiple CSS classes and toggle between them than directly
    changing the style of an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or its jQuery version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can implement the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can also benchmark your JavaScript using a tool called **jsPerf** ([http://jsperf.com/](http://jsperf.com/)).
    It provides a way to create test cases for JavaScript code snippets so that you
    can benchmark their performance. If you are wondering which is faster, `document.getElementsByTagName`
    or `document.getElementsByClassName`, this tool will allow you to test your theory
    on your browser. Furthermore, it allows you to share your test cases so that others
    can test on different browsers giving you statistics across various browsers and
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Additional page performance considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An enterprise application can be composed of many files including HTML, CSS,
    JavaScript, and images. Although for maintainability, it is proper to break out
    your CSS and JavaScript files. When deploying your code, combining and minifying
    your files leads to better performance. **Minification** is a compression technique
    for code in which all unnecessary characters are removed while the behavior is
    preserved. There are a number of tools that will do this for you including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: JSMin ([http://www.crockford.com/javascript/jsmin.html](http://www.crockford.com/javascript/jsmin.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packer ([http://dean.edwards.name/packer/](http://dean.edwards.name/packer/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YUI Compressor ([http://developer.yahoo.com/yui/compressor/](http://developer.yahoo.com/yui/compressor/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the vein of reducing file size, minimizing requests, and in general using
    as little bandwidth as possible, the use of CSS sprites has become common these
    days wherein all of the static graphic elements for an application are combined
    into a single image, parts of which are displayed using CSS. This way only one
    image needs to be downloaded once instead of many.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An enterprise application often has many static assets that are downloaded from
    the server with each page request. As this creates a lot of unnecessary traffic
    on the server, one way to offload the burden is to use a content delivery network
    or CDN. A CDN allows you to mirror your pages on a network of servers that are
    optimized for delivering static assets quickly. You can place your static assets
    on a CDN such as Akamai, Edgecast, or Cloudflare as well as use CDN-hosted versions
    of popular libraries. Google hosts a number of libraries for public consumption
    such as jQuery in its CDN ([https://developers.google.com/speed/libraries/](https://developers.google.com/speed/libraries/))
    as does cdnjs ([http://cdnjs.com/](http://cdnjs.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Many web servers such as Apache can be instructed to compress what they send
    to the browser before they send it. If you are able to, adding a `Content-Encoding`
    header set to `gzip` in your response can reduce the amount of data transferred
    by 70 percent.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to consider caching in your enterprise application. If the
    same request is made over and over again, and the response is always the same
    or seldom changes, cache the response and send it back when subsequent requests
    are made. Browsers intrinsically support this with the `Cache-Control` header
    and the `Expires` header. While `Expires` tells the browser how long to keep content
    in the page cache, `Cache-Control` provides a set of rules for when to keep and
    when to invalidate the cache. Some useful parameters include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max-age`: This indicates the maximum amount of time before a piece of content
    should be refreshed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`: This indicates that a piece of content is cacheable even though it
    requires authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: This indicates that a piece of content is cacheable on a per-user
    basis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no-cache`: This indicates that a piece of content can be cached but should
    be refreshed on every request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no-store`: This indicates that a piece of content should not be kept in cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`must-revalidate`: This indicates that the browser must check with the server
    first before serving a cached version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching not only helps to improve response times, it relieves your server load
    and reduces network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Yahoo! has provided a number of useful guidelines for ensuring page performance.
    While many of these topics have already been covered, you are encouraged to check
    out the guidelines for yourself at [http://developer.yahoo.com/performance/](http://developer.yahoo.com/performance/).
  prefs: []
  type: TYPE_NORMAL
- en: Performance analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may yet follow all of the rules for optimal performance and still find yourself
    with a slow application. When this happens, you need to become adept at assessing
    load times and profiling your application. Fortunately, there are many tools available
    to help pinpoint the bottlenecks; these tools are explained in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Load times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the major browsers include a network tab that will graphically display
    all of the requests and responses between the browser and the servers it contacts.
    Firefox includes a **Net** tab as part of the Firebug add-on as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load times](img/5689_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It displays a set of bars that indicate load time per request over time. Here
    you can see the web page loading piece-by-piece including how it loads the HTML
    first and then requests the ancillary assets afterward: image files, CSS files,
    JavaScript files, and even subsequent AJAX requests. As you can see in the following
    screenshot, when you hover over each bar, you will see statistics about that request
    including DNS lookup, connection time, the time to send the request, wait, and
    receive the response, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load times](img/5689_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is particularly helpful when attempting to debug a performance problem
    because it tells you very clearly whether slowness is due to a connection problem
    or a page load problem, for example, how the HTML is constructed and parsed. Knowing
    these finer details helps greatly to uncover and remove bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to browser-based tools to assess load time, there are external
    services that allow you to assess load time. In particular, Pingdom ([http://tools.pingdom.com/fpt/](http://tools.pingdom.com/fpt/))
    provides a service that you can use to periodically test the load times of your
    web application. It provides a similar chart for determining where your bottlenecks
    are. Alternatives include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Google Speed ([https://developers.google.com/speed/](https://developers.google.com/speed/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YSlow ([http://developer.yahoo.com/yslow/](http://developer.yahoo.com/yslow/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gomez([http://www.gomez.com/website-performance-test/](http://www.gomez.com/website-performance-test/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profilers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Profilers are another way to assess performance. Typically, they list JavaScript
    calls in order of execution time, which can be really helpful to pinpoint slow-running
    functions. Some browsers such as Google Chrome and Safari include a CSS selector
    profiler, which lists the slowest running CSS selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Firefox has a profiler built into its Firebug add-on. Click on the **Console**
    tab and click on **Profile**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Profilers](img/5689_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Google Chrome's **Developer Tools**, you will find a **Profiles** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Safari provides an **Instrument** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer 9 offers a profiler as well in its Developer Tools. Click
    on **Profiler** and then the **Start profiling** button to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Profilers will usually list out the slowest running functions, how many times
    they were invoked, and the amount of time they took to execute. They typically
    split the notion of execution time into two categories. Some call it exclusive
    time while others call it self or own time. This is the execution time while within
    a function, excluding the execution time of other functions invoked from within
    that function. The other category is referred to as inclusive time, total time,
    or just time. This is the execution time of a function including functions that
    are invoked from within it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered ways to ensure performance of your enterprise application on many
    different levels. There are ways to ensure clean HTML that your browser will understand,
    and there are ways to ensure optimal CSS and JavaScript. There are ways to reduce
    the page footprint, decrease the number of requests, and place less of a burden
    on the browser. While each of these is important in their own way, real performance
    gains are not always apparent until you put them all together.
  prefs: []
  type: TYPE_NORMAL
- en: We have built our example application, MovieNow, including the most important
    steps to build any enterprise application; from the definition of a meaningful
    structure using semantic tags, to the styling and animations with CSS3, showing
    new and exciting features such as canvas 2D and WebGL, geolocation, video, audio,
    drag-and-drop, and web workers. We practised the use of real world APIs such as
    Twitter, and reviewed a set of tools and libraries to facilitate the process of
    development, testing, and performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to continue reading about new web technologies. As we speak,
    there are many developers who are creating not only new enterprise applications
    but new libraries, techniques, tools, and paradigms of thought that can redefine
    the web as we know it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we hope you have enjoyed this journey as much as we have, and that
    the initial guidelines of this book lead you to many successful HTML5 projects.
  prefs: []
  type: TYPE_NORMAL
