<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Plugins and Extensions</h1></div></div></div><p>This chapter introduces and defines the Ext JS plugins and extensions, the differences between<a id="id0" class="indexterm"/> them, and finally shows how to develop a plugin and an <a id="id1" class="indexterm"/>extension.</p><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What a plugin is</li><li class="listitem" style="list-style-type: disc">What an extension is</li><li class="listitem" style="list-style-type: disc">Differences between an extension and a plugin, and choosing the best option</li><li class="listitem" style="list-style-type: disc">Building an Ext JS plugin</li><li class="listitem" style="list-style-type: disc">Building an Ext JS extension</li></ul></div><p>In this modern world of JavaScript, Ext JS is the best JavaScript framework that includes a vast collection of cross-browser utilities, UI widgets, charts, data object stores, and much more.</p><p>When developing an application, we mostly look for the best functionality support and components that offer it to the framework. But we usually face situations wherein the framework lacks the specific functionality or component that we need. Fortunately, Ext JS has a powerful class system that makes it easy to extend an existing functionality or component, or build new ones altogether.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>What is a plugin?</h1></div></div></div><p>An Ext JS plugin is a class that is used to provide additional functionalities to an existing component. Plugins must implement a<a id="id2" class="indexterm"/> method named <code class="literal">init</code>, which is called by the component and is passed as the parameter at the initialization time, at the beginning of the<a id="id3" class="indexterm"/> component's lifecycle. The <code class="literal">destroy</code> method is invoked by the owning component of the plugin, at the time of the component's destruction. We don't need to instantiate a plugin class. Plugins are inserted in to a component using the plugin's configuration option for that component.</p><p>Plugins are used not <a id="id4" class="indexterm"/>only by components to which they are attached, but also by all the subclasses derived from that component. We can also use multiple plugins in a single component, but we need to be aware that using multiple plugins in a single component should not let the plugins conflict with each other.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>What is an extension?</h1></div></div></div><p>An Ext JS extension is a derived class or a subclass of an existing Ext JS class, which is designed to allow the inclusion of additional features. An Ext JS extension is mostly used to add custom <a id="id5" class="indexterm"/>functionalities or modify the behavior of an existing Ext JS class. An Ext JS extension can be as basic as the preconfigured Ext JS classes, which basically supply a set of default values to an existing class configuration. This type of extension is really helpful in situations where the required functionality is repeated at several places. Let us assume we have an application where several Ext JS windows have the same help button at the bottom bar. So we can create an extension of the Ext JS window, where we can add this help button and can use this extension window without providing the repeated code for the button. The advantage is that we can easily maintain the code for the help button in one place and can get the change in all places.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Differences between an extension and a plugin</h1></div></div></div><p>The Ext JS extensions and plugins are used for the same purpose; they add extended functionality to <a id="id6" class="indexterm"/>Ext JS classes. But they mainly<a id="id7" class="indexterm"/> differ in terms of how they are written and the reason for which they are used.</p><p>Ext JS extensions are extension <a id="id8" class="indexterm"/>classes or subclasses of Ext JS classes. To use these extensions, we need to instantiate these extensions by creating an object. We can provide additional properties, functions, and can even override any parent member to change its behavior. The extensions are very tightly coupled to the classes from which they are derived. The Ext JS extensions are mainly used when we need to modify the behavior of an existing class or component, or we need to create a fully new class or component.</p><p>Ext JS plugins are also Ext JS classes, but<a id="id9" class="indexterm"/> they include the <code class="literal">init</code> function. To use the plugins we don't need to directly instantiate these classes; instead, we need to register the plugins in the plugins' configuration option within the component. After adding, the options and functions will become available to the component itself. The plugins are loosely coupled with the components they are plugged in, and they can be easily detachable and interoperable with multiple components and derived components. Plugins are used when we need to add features to a component. As plugins must be attached to an existing component, creating a fully new component, as done in the extensions, is not useful.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Choosing the best option</h1></div></div></div><p>When we need to enhance or change the functionality of an existing Ext JS component, we have several <a id="id10" class="indexterm"/>ways to do that, each of which has both advantages and disadvantages.</p><p>Let us assume we need to develop an SMS text field having a simple functionality of changing the text color to red whenever the text length exceeds the allocated length for a message; this way the user can see that they are typing more than one message. Now, this functionality can be implemented in three different ways in Ext JS, which is discussed in the following sections.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>By configuring an existing class</h2></div></div></div><p>We can choose to <a id="id11" class="indexterm"/>apply configuration to the <a id="id12" class="indexterm"/>existing classes. For example, we can create a text field <a id="id13" class="indexterm"/>by providing the required SMS functionality as a configuration within the listener's configuration, or we can provide event handlers <a id="id14" class="indexterm"/>after the text field is instantiated with the <code class="literal">on</code> method.</p><p>This is the easiest option when the same functionality is used only at a few places. But as soon as the functionality is repeated at several places or in several situations, code duplication may arise.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>By creating a subclass or an extension</h2></div></div></div><p>By creating an<a id="id15" class="indexterm"/> extension, we can easily solve the problem as discussed in the previous section. So, if we create an extension for the SMS text field by <a id="id16" class="indexterm"/>extending the Ext JS text field, we can use this extension at as many places as we need, and can also create other extensions by using this extension. So, the code is centralized for this extension, and changing one place can reflect in all the places where this extension is used.</p><p>But there is a problem: when the same functionality is needed for SMS in other subclasses of Ext JS text fields such as Ext JS text area field, we can't use the developed SMS text field extension to take advantage of the SMS functionality. Also, assume a situation where there are two subclasses of a base class, each of which provides their own facility, and we want to use both the features on a single class, then it is not possible in this implementation.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>By creating a plugin</h2></div></div></div><p>By creating a plugin, we <a id="id17" class="indexterm"/>can gain the maximum re-use of a code. As a plugin for <a id="id18" class="indexterm"/>one class, it is usable by the subclasses of that class, and also, we have the flexibility to use multiple plugins in a single component. This is the reason why if we create a plugin for the SMS functionality we <a id="id19" class="indexterm"/>can use the SMS plugin both in the <a id="id20" class="indexterm"/>text field and in the text area field. Also, we can use other plugins, including this SMS plugin, in the class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Building an Ext JS plugin</h1></div></div></div><p>Let us start developing an Ext JS plugin. In this section we will develop a simple SMS plugin, targeting<a id="id21" class="indexterm"/> the Ext JS <code class="literal">textareafield</code> component. The feature we wish<a id="id22" class="indexterm"/> to provide for the SMS functionality is that it should show the number of characters and the number of messages on the bottom of the containing field. Also, the color of the text of the message should change in order to notify the users whenever they exceed the allowed length for a message.</p><p>Here, in the following code, the SMS plugin class has been created within the <code class="literal">Examples</code> namespace of an Ext JS application:</p><div><pre class="programlisting">Ext.define('Examples.plugin.Sms', {

  alias : 'plugin.sms',

  config : {

    perMessageLength : 160,
    defaultColor : '#000000',
    warningColor : '#ff0000'

  },

  constructor : function(cfg) {

    Ext.apply(this, cfg);

    this.callParent(arguments);
  },

  init : function(textField) {

    this.textField = textField;
    if (!textField.rendered) {
      textField.on('afterrender', this.handleAfterRender, this);
    }
    else {
      this.handleAfterRender();
    }
  },
  handleAfterRender : function() {

    this.textField.on({
      scope : this,
      change : this.handleChange
    });

    var dom = Ext.get(this.textField.bodyEl.dom);

    Ext.DomHelper.append(dom, {
      tag : 'div',
      cls : 'plugin-sms'
    });

  },

  handleChange : function(field, newValue) {

    if (newValue.length &gt; this.getPerMessageLength()) {
      field.setFieldStyle('color:' + this.getWarningColor());
    }
    else {
      field.setFieldStyle('color:' + this.getDefaultColor());
    }
    this.updateMessageInfo(newValue.length);

  },

  updateMessageInfo : function(length) {

    var tpl = ['Characters: {length}&lt;br/&gt;', 'Messages:{messages}'].join('');
    var text = new Ext.XTemplate(tpl);
    var messages = parseInt(length / this.getPerMessageLength());

    if ((length / this.getPerMessageLength()) - messages &gt; 0) {
      ++messages;
    }

    Ext.get(this.getInfoPanel()).update(text.apply({
      length : length,
      messages : messages
    }));

  },

  getInfoPanel : function() {

    return this.textField.el.select('.plugin-sms');

  }
});</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>In the preceding plugin class, you can see that within this class we have defined a "must implemented" function<a id="id23" class="indexterm"/> called <code class="literal">init</code>. Within the <code class="literal">init</code> function, we check whether the component, on which this plugin is attached, has rendered or not, and then call the <code class="literal">handleAfterRender</code> function whenever the rendering is. Within this function, a code is <a id="id24" class="indexterm"/>provided, such that when the <code class="literal">change</code> event fires off the <a id="id25" class="indexterm"/>
<code class="literal">textareafield</code> component, the <code class="literal">handleChange</code> function of this class should get executed; simultaneously, create an HTML <code class="literal">&lt;div&gt;</code> element <a id="id26" class="indexterm"/>within the <code class="literal">handleAfterRender</code> function, where we want to show the message information regarding the characters and message counter. And<a id="id27" class="indexterm"/> the <code class="literal">handleChange</code> function is the handler that calculates the message length in order to show the colored, warning text, and <a id="id28" class="indexterm"/>call the <code class="literal">updateMessageInfo</code> function to update the message information text for the characters length and the number of messages.</p><p>Now we can easily add the following plugin to the component:</p><div><pre class="programlisting">{
    xtype : 'textareafield',
    plugins : ['sms']
}</pre></div><p>Also, we can supply configuration options when we are inserting the plugin within the <code class="literal">plugins</code> configuration option to override the default values, as follows:</p><div><pre class="programlisting">plugins : [Ext.create('Examples.plugin.Sms', {
  perMessageLength : 20,
  defaultColor : '#0000ff',
  warningColor : "#00ff00"
})]</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Building an Ext JS extension</h1></div></div></div><p>Let us start developing an Ext JS extension. In this section we will develop an SMS extension that exactly satisfies the same requirements as the earlier-developed SMS plugin.</p><p>We already know <a id="id29" class="indexterm"/>that an Ext JS extension is a derived class of existing Ext JS class, we are going to extend the Ext JS's <code class="literal">textarea</code> field that facilitates for typing multiline text and provides several event handling, rendering and other functionalities.</p><p>Here is the following code where we have created the <code class="literal">Extension</code> class under the SMS view within the <code class="literal">Examples</code> namespace of an Ext JS application:</p><div><pre class="programlisting">Ext.define('Examples.view.sms.Extension', {
  extend : 'Ext.form.field.TextArea',
  alias : 'widget.sms',

  config : {

    perMessageLength : 160,
    defaultColor : '#000000',
    warningColor : '#ff0000'

  },

  constructor : function(cfg) {

    Ext.apply(this, cfg);

    this.callParent(arguments);
  },

  afterRender : function() {

    this.on({
      scope : this,
      change : this.handleChange
    });

    var dom = Ext.get(this.bodyEl.dom);

    Ext.DomHelper.append(dom, {
      tag : 'div',
      cls : 'extension-sms'
    });

  },

  handleChange : function(field, newValue) {

    if (newValue.length &gt; this.getPerMessageLength()) {
      field.setFieldStyle('color:' + this.getWarningColor());
    }
    else {
      field.setFieldStyle('color:' + this.getDefaultColor());
    }
    this.updateMessageInfo(newValue.length);

  },

  updateMessageInfo : function(length) {

    var tpl = ['Characters: {length}&lt;br/&gt;', 'Messages:{messages}'].join('');
    var text = new Ext.XTemplate(tpl);
    var messages = parseInt(length / this.getPerMessageLength());

    if ((length / this.getPerMessageLength()) - messages &gt; 0) {
      ++messages;
    }

    Ext.get(this.getInfoPanel()).update(text.apply({
      length : length,
      messages : messages
    }));

  },

  getInfoPanel : function() {

    return this.el.select('.extension-sms');

  }
});</pre></div><p>As seen in the preceding code, the<a id="id30" class="indexterm"/> <code class="literal">extend</code> keyword is used as a class property to extend the <code class="literal">Ext.form.field.TextArea</code> class in order to create the extension class. Within the <a id="id31" class="indexterm"/>
<code class="literal">afterRender</code> event handler, we <a id="id32" class="indexterm"/>provide a code so that when the <code class="literal">change</code> event fires off the <strong>textarea</strong> field, we can execute the<a id="id33" class="indexterm"/> <code class="literal">handleChange</code> function of this class and also create an Html <code class="literal">&lt;div&gt;</code> element within this <code class="literal">afterRender</code> event handler<a id="id34" class="indexterm"/> where we want to show the message information regarding the characters counter and message counter. And from this section, the logic to show the warning, message character counter, and message counter is the same as we used in the SMS plugin.</p><p>Now we can easily <a id="id35" class="indexterm"/>create an instance of this extension:</p><div><pre class="programlisting">Ext.create('Examples.view.sms.Extension');</pre></div><p>Also, we can supply configuration options when we are creating the instance of this class to override the default values:</p><div><pre class="programlisting">Ext.create('Examples.view.sms.Extension', {
    perMessageLength : 20,
    defaultColor : '#0000ff',
    warningColor : "#00ff00"
});</pre></div><p>The following is the screenshot where we've used the SMS plugin and extension:</p><div><img src="img/3725OS_1_1.jpg" alt="Building an Ext JS extension"/></div><p>In the above screenshot we have created an Ext JS window and incorporated the SMS extension and SMS plugin. As we have already discussed on the benefit of writing a plugin, we can not <a id="id36" class="indexterm"/>only use the SMS plugin with text area field, but we can also use it with text field.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>We have learned from this chapter what a plugin and an extension are, the differences between the two, the facilities they offer, how to use them, and take decisions on choosing either an extension or a plugin for the needed functionality. In this chapter we've also developed a simple SMS plugin and an SMS extension.</p></div></body></html>